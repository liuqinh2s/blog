---
title: 2018-06-12-《代码整洁之道》读书笔记-第3章-函数
tags:
  - 代码规范
categories:
  - 读书笔记
  - 《代码整洁之道》
comments: true
---

在编程的早年岁月，系统由程序和子程序组成。后来，在Fortran和PL/1的年代，系统由程序、子程序和函数组成。如今，只有函数存活下来。函数是所有程序中的第一组代码。

>在计算机领域，很多问题都是历史原因引起的，比如千年虫。因为计算机的发展非常之迅速，特别是硬件行业的发展，使得原先的很多稀有资源：比如存储和算力变得越来越便宜。软件行业也就向着更平易近人、更大规模演进。

看看下面的代码：

```Java
public static String testableHtml(PageData pageData, boolean includeSuiteSetup) throws Exception {
    WikiPage wikiPage = pageData.getWikiPage();
    StringBuffer buffer = new StringBuffer();
    if (pageData.hasAttribute("Test")) {
        if(includeSuiteSetup){
            WikiPage suiteSetup = PageCrawlerImpl.getInheritedPage(SuiteResponder.SUITE_SETUP_NAME, wikiPage);
            if(suiteSetup != null){
                WikiPagePath pagePath = suiteSetup.getPageCrawler().getFullPath(suiteSetup);
                String pagePathName = PathParser.render(pagePath);
                buffer.append("!include -setup .")
                      .append(pagePathName)
                      .append("\n");
            }
        }
        WikiPage setup = PageCrawlerImpl.getInheritedPage("SetUp", wikiPage);
        if(setup != null){
            WikiPagePath setupPath = wikiPage.getPageCrawler().getFullPath(setup);
            String setupPathName = PathParser.render(setupPath);
            buffer.append("!include -setup .")
                  .append(setupPathName)
                  .append("\n");
        }
    }
    buffer.append(pageData.getContent());
    if(pageData.hasAttribute("Test")){
        WikiPage teardown = PageCrawlerImpl.getInheritedPage("TearDown", wikiPage);
        if(teardown!=null){
            WikiPagePath tearDownPath = wikiPage.getPageCrawler().getFullPath(teardown);
            String tearDownPathName = PathParser.render(tearDownPath);
            buffer.append("!include -teardown .")
                  .append(tearDownPathName)
                  .append("\n");
        }
        if(includeSuiteSetup){
            WikiPage suiteTeardown = PageCrawlerImpl.getInheritedPage(SuiteReponder.SUITE_TEARDOWN_NAME, wikiPage);
            if(suiteTeardown!=null){
                WikiPagePath pagePath = suiteTeardown.getPageCrawler().getFullPath(suiteTeardown);
                String pagePathName = PathParse.render(pagePath);
                buffer.append("!include -teardown .")
                      .append(pagePathName)
                      .append("\n");
            }
        }
    }
    pageData.setContent(buffer.toString());
    return pageData.getHtml();
}
```

搞懂这个函数了吗？大概没有。**有太多事发生，有太多不懂层级的抽象。奇怪的字符串和函数调用，混以双重嵌套、用标识来控制的if语句等，不一而足。**

不过，只要做几个简单的方法抽离和重命名操作，加上一点点重构，就能在9行代码之内搞定。

```Java
public static String renderPageWithSetupsAndTeardown(PageData pageData, boolean isSuite) throws Exception{
    boolean isTestPage = pageData.hasAttribute("Test");
    if(isTestPage){
        WikiPage testPage = pageData.getWikiPage();
        StringBuffer newPageContent = new StringBuffer();
        includeSetupPages(testPage, newPageContent, isSuite);
        newPageContent.append(pageData.getContent());
        includeTeardownPages(testPage, newPageContent, isSuite);
        pageData.setContent(newPageContent.toString());
    }
    return pageData.getHtml();
}
```

除非你正在研究FitNesse，否则就理解不了所有细节。不过，你大概能明白，该函数包含把一些设置和拆解页放入一个测试页面，再渲染为HTML的操作。如果你熟悉JUnit，或许会想到，该函数归属于某个基于Web的测试框架。

## 短小

**函数的第一规则是要短小。第二条规则还要更短小**。

### 代码块和缩进

if语句、else语句、while语句等，其中的代码块应该只有一行。该行大抵应该是一个函数调用语句。这样不但能保持函数短小，而且，因为块内调用的函数拥有较具说明性的名称，从而增加了文档上的价值。

这也意味着函数不应该大到足以容纳嵌套结构。所以，函数的缩进层级不该多于一层或两层。当然，这样的函数易于阅读和理解。

### 只做一件事

函数应该做一件事。做好这件事。只做这一件事。