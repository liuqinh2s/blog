---
title: pom.xml详解
categories: [Java, Java web]
comments: true
---

POM, Project Object Model，项目对象模型，是Maven的配置文件。

>[什么是xml?](https://zh.wikipedia.org/zh-hans/XML)

<!-- more -->

## POM配置一览

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0"
 xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                     http://maven.apache.org/xsd/maven-4.0.0.xsd">
 <modelVersion>4.0.0</modelVersion>

 <!-- The Basics -->
 <groupId>...</groupId>
 <artifactId>...</artifactId>
 <version>...</version>
 <packaging>...</packaging>
 <dependencies>...</dependencies>
 <parent>...</parent>
 <dependencyManagement>...</dependencyManagement>
 <modules>...</modules>
 <properties>...</properties>

 <!-- Build Settings -->
 <build>...</build>
 <reporting>...</reporting>

 <!-- More Project Information -->
 <name>...</name>
 <description>...</description>
 <url>...</url>
 <inceptionYear>...</inceptionYear>
 <licenses>...</licenses>
 <organization>...</organization>
 <developers>...</developers>
 <contributors>...</contributors>

 <!-- Environment Settings -->
 <issueManagement>...</issueManagement>
 <ciManagement>...</ciManagement>
 <mailingLists>...</mailingLists>
 <scm>...</scm>
 <prerequisites>...</prerequisites>
 <repositories>...</repositories>
 <pluginRepositories>...</pluginRepositories>
 <distributionManagement>...</distributionManagement>
 <profiles>...</profiles>
</project>
```

官方参考：[Maven Model](http://maven.apache.org/ref/3.6.0/maven-model/maven.html)

实际例子中的 [pom.xml](../../../../assets/2018/pom.xml)

## 基本配置

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                      http://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
 
  <groupId>org.codehaus.mojo</groupId>
  <artifactId>my-project</artifactId>
  <version>1.0</version>
  <packaging>war</packaging>
</project>
```

- project：pom.xml中描述符的根
- xmlns：xml namespace，和C++的命名空间一样，肯定都是用来[解决命名冲突](#xml命名冲突的例子)的
- modelVersion：指定pom.xml符合哪个版本。maven2和3只能为4.0.0

在Maven中，根据`groupId`、`artifactId`、`version`组合成`groupId:artifactId:version`来唯一标识一个jar包：
- **groupId**: 团体、组织的标识符。它以创建这个项目的组织的逆向域名（reverse domain name）开头。
- **artifactId**: 单独项目的唯一标识符，比如tomcat。**不要在artifactId中包含`.`（点号）**。
- **version**: 一个项目的特定版本。[版本相关的小知识](#maven版本规范)
- **packaging**: 项目的类型，描述了项目打包后的输出，默认是jar。常见的输出类型有：pom, jar, maven-plugin, ejb, war, ear, rar, par

## dependencies

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                      https://maven.apache.org/xsd/maven-4.0.0.xsd">
  ...
  <dependencies>
    <dependency>
     <groupId>org.apache.maven</groupId>
      <artifactId>maven-embedder</artifactId>
      <version>2.0</version>
      <type>jar</type>
      <scope>test</scope>
      <optional>true</optional>
      <exclusions>
        <exclusion>
          <groupId>org.apache.maven</groupId>
          <artifactId>maven-core</artifactId>
        </exclusion>
      </exclusions>
    </dependency>
    ...
  </dependencies>
  ...
</project>
```

- **groupId, artifactId, version**：和基本配置中的 `groupId`、`artifactId`、`version` 意义相同。
- **type**：对应 `packaging` 的类型，如果不使用 `type` 标签，maven 默认为 jar。
- **scope**：此元素指的是任务的类路径（编译和运行时，测试等）以及如何限制依赖关系的传递性。有 5 种可用的限定范围：
    - **compile** - 如果没有指定 scope 标签，maven 默认为这个范围。编译依赖关系在所有 classpath 中都可用。此外，这些依赖关系被传播到依赖项目。
    - **provided** - 与 compile 类似，但是表示您希望 jdk 或容器在运行时提供它。它只适用于编译和测试 classpath，不可传递。
    - **runtime** - 此范围表示编译不需要依赖关系，而是用于执行。它是在运行时和测试 classpath，但不是编译 classpath。
    - **test** - 此范围表示正常使用应用程序不需要依赖关系，仅适用于测试编译和执行阶段。它不是传递的。
    - **system** - 此范围与 provided 类似，除了您必须提供明确包含它的 jar。该 artifact 始终可用，并且不是在仓库中查找。
- **systemPath**：仅当依赖范围是系统时才使用。否则，如果设置此元素，构建将失败。该路径必须是绝对路径，因此建议使用 propertie 来指定特定的路径，如$ {java.home} / lib。由于假定先前安装了系统范围依赖关系，maven 将不会检查项目的仓库，而是检查库文件是否存在。如果没有，maven 将会失败，并建议您手动下载安装。
- **optional**：optional 让其他项目知道，当您使用此项目时，您不需要这种依赖性也能正常工作。
- **exclusions**：包含一个或多个排除元素，每个排除元素都包含一个表示要排除的依赖关系的 groupId 和 artifactId。与可选项不同，可能或可能不会安装和使用，排除主动从依赖关系树中删除自己。

## build

[官方文档](https://maven.apache.org/pom.html#Build_Settings)

build用于声明项目目录结构和管理插件。

build元素从概念上被分为两部分：

- BasicBuild
- Build

BasicBuild是Build的子集。

build标签也分为两种：

1. 根标签`<project>`下的`build`标签（称为profile build）该配置可以被`profile`全部继承
2. `profile`标签中的`build`标签（称为profile build），用于重写覆盖掉 project build 中的配置，是project build的子集。

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0"    
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"    
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0    
                      http://maven.apache.org/maven-v4_0_0.xsd">    
  
  <!–- "Project Build" 除了包含 BaseBuild 集合外，还包含其它构建元素 -–>   
  <build>…</build>    
  
  <!–- "Profile Build" 是 "Project Build"s 的子集 -–>   
  <profiles>    
    <profile>  
      <build>…</build>    
    </profile>    
  </profiles>    
</project>    
```

### 配置说明

#### 基本元素：BaseBuild

```xml
<build>    
        <defaultGoal>install</defaultGoal>    
        <directory>${basedir}/target</directory>    
        <finalName>${artifactId}-${version}</finalName>    
        <filters>    
                <filter>filters/filter1.properties</filter>    
        </filters>    
         ...    
</build> 
```

1. **defaultGoal:** 执行mvn命令时，如果没有指定目标，指定使用的默认目标。如上配置：在命令行中执行mvn，则相当于执行：`mvn install`
2. **directory:** 目标文件的存放目录，默认在`${basedir}/target`目录
3. **finalName:** 目标文件的名称，默认情况为`${artifactId}-${version}`
4. **filter:** 定义`*.properties`文件，包含一个properties列表，该列表会应用到支持filter的resources中。也就是说，定义在 filter 的文件中的 name = value 键值对，会在build时代替 ${name} 值应用到 resources 中。maven的默认filter文件夹为 ${basedir}/src/main/filters。

#### Resource 配置

用于包含或排除某些资源文件。
说明：资源通常不是源代码（也可以是），它们一般不被编译，例如：.xml文件，.properties文件等。

```xml
<build>    
   ...    
   <resources>    
       <resource>    
            <targetPath>META-INF/plexus</targetPath>    
            <filtering>false</filtering>    
            <directory>${basedir}/src/main/plexus</directory>    
            <includes>    
                <include>configuration.xml</include>    
            </includes>    
            <excludes>    
                <exclude>**/*.properties</exclude>    
            </excludes>    
       </resource>    
    </resources>    
    <testResources>    
        ...    
    </testResources>    
    ...    
</build>    
```

1. **resources:** 一个resource元素的列表。每一个都描述与项目关联的文件是什么和在哪里
2. **targetPath:** 指定build后的resource存放的文件夹，默认是basedir。通常被打包在jar中的resources的目标路径是META-INF
3. **filtering:** true/false，表示为这个resource，filter是否激活。
4. **directory:** 定义resources文件所在的文件夹，默认为：`${basedir}/src/main/resources`
5. **includes:** 指定哪些文件将被匹配，以*作为通配符
6. **excludes:** 指定哪些文件将被忽略
7. **testResources:** 定义和resources类似，只不过在test时使用

```xml
<resources>  
   <!--   
     | 有几个路径，就对应几个 resource 标签   
     | 或：  
     | 一个目录，对应一个 resource 标签  
   -->  
   <resource>  
       <directory>  
           ${basedir}/src/main/content/META-INF  
       </directory>  
       <targetPath>../vault-work/META-INF</targetPath>  
       <filtering>true</filtering>  
   </resource>  
   <resource>  
       <directory>  
           ${basedir}/src/main/content/jcr_root  
       </directory>  
       <excludes>  
           <!-- 用法1：不包括一整个目录-->  
           <exclude>apps/ui/**</exclude>    
  
           <!-- 用法2：不包括某类文件（所有路径下）-->    
           <exclude>**/*.jpg</exclude>  
  
           <!-- 用法3：不包括某个文件（所有路径下）-->  
           <exclude>**/.DS_Store</exclude>  
       </excludes>  
       <targetPath>.</targetPath>  
       <filtering>false</filtering>  
   </resource>  
</resources> 
```

#### plugins

用于指定使用的插件

```xml
<build>    
    ...    
    <plugins>    
        <plugin>    
            <groupId>org.apache.maven.plugins</groupId>    
            <artifactId>maven-jar-plugin</artifactId>    
            <version>2.0</version>    
            <extensions>false</extensions>    
            <inherited>true</inherited>    
            <configuration>    
                <classifier>test</classifier>    
            </configuration>    
            <dependencies>...</dependencies>    
            <executions>...</executions>    
        </plugin>    
    </plugins>    
</build>  
```

1. GAV(groupId, artifactId, version)，指定插件的标准坐标
2. extensions是否加载plugin的extensions，默认为false
3. inherited： true/false，这个plugin是否应用到该pom的孩子pom，默认为true
4. configuration配置该plugin期望得到的properties
5. dependencies作为plugin的依赖
6. executionsplugin可以有多个目标，每一个目标都可以有一个分开的配置，可以将一个plugin绑定到不同的阶段假如绑定antrun：run目标到verify阶段 

```xml
<build>    
    <plugins>    
        <plugin>    
            <artifactId>maven-antrun-plugin</artifactId>    
            <version>1.1</version>    
            <executions>    
                <execution>    
                    <id>echodir</id>    
                    <goals>    
                        <goal>run</goal>    
                    </goals>    
                    <phase>verify</phase>    
                    <inherited>false</inherited>    
                    <configuration>    
                        <tasks>    
                            <echo>Build Dir: ${project.build.directory}</echo>    
                        </tasks>    
                    </configuration>    
                </execution>    
            </executions>    
        </plugin>    
    </plugins>    
</build>    
```

- id：标识，用于和其他 execution 区分。当这个阶段执行时，它将以这个形式展示[plugin:goal execution:id]。举例：在这里为： [antrun:run execution:echodir] 
- goals：目标列表 
- phase：目标执行的阶段 
- inherit：子类pom是否继承 
- configuration：在指定目标下的配置

#### pluginManagement

pluginManagement的配置和plugins的配置是一样的，只是用于继承，使得可以在孩子pom中使用。父pom：

```xml
<build>    
    ...    
    <pluginManagement>    
        <plugins>    
            <plugin>    
              <groupId>org.apache.maven.plugins</groupId>    
              <artifactId>maven-jar-plugin</artifactId>    
              <version>2.2</version>    
                <executions>    
                    <execution>    
                        <id>pre-process-classes</id>    
                        <phase>compile</phase>    
                        <goals>    
                            <goal>jar</goal>    
                        </goals>    
                        <configuration>    
                            <classifier>pre-process</classifier>    
                        </configuration>    
                    </execution>    
                </executions>    
            </plugin>    
        </plugins>    
    </pluginManagement>    
    ...    
</build>    
```

则在子pom中，我们只需要配置：

```xml
<build>    
    ...    
    <plugins>    
        <plugin>    
            <groupId>org.apache.maven.plugins</groupId>    
            <artifactId>maven-jar-plugin</artifactId>    
        </plugin>    
    </plugins>    
    ...    
</build>  
```

这样就大大简化了孩子pom的配置

## xml命名冲突的例子

```xml
<table>
   <tr>
       <td>Apples</td>
       <td>Bananas</td>
   </tr>
</table>

<table>
   <name>African Coffee Table</name>
   <width>80</width>
   <length>120</length>
</table>
```

这两个xml文档片段如果一起使用的话，会冲突，因为都包含了`<table>`元素，而这两个table元素的定义与所包含的内容又各不相同。解决冲突的办法就是使用xmlns。

```xml
<h:table xmlns:h="http://www.w3.org/TR/html4/">
   <h:tr>
       <h:td>Apples</h:td>
       <h:td>Bananas</h:td>
   </h:tr>
</h:table>

<f:table xmlns:f="http://www.w3schools.com/furniture">
   <f:name>African Coffee Table</f:name>
   <f:width>80</f:width>
   <f:length>120</f:length>
</f:table>
```

也可以使用默认命名空间

```xml
<table xmlns="http://www.w3.org/TR/html4/">
   <tr>
       <td>Apples</td>
       <td>Bananas</td>
   </tr>
</table>

<table xmlns="http://www.w3schools.com/furniture">
   <name>African Coffee Table</name>
   <width>80</width>
   <length>120</length>
</table>
```

>默认命名空间没有名字，无法被再次直接引用。

## Maven版本规范

maven有自己的版本规范，一般是如下定义:

```
major version.minor version.incremental version-qualifier
```

比如 `1.2.3-beta-01`。要说明的是，maven自己判断版本的算法是`major`、`minor`、`incremental`部分用数字比较，`qualifier`部分用字符串比较，所以要小心形如`alpha-2`和`alpha-15`的比较关系，最好用`alpha-02`的格式。
maven在版本管理的时候可以使用几个特殊的字符串`SNAPSHOT`、`LATEST`、`RELEASE`。比如`1.0-SNAPSHOT`。
- **SNAPSHOT**：这个版本一般用于开发过程中，表示不稳定的版本。
- **LATEST**：指定某个特定构件的最新发布，这个发布可能是一个RELEASE版，也可能是一个SNAPSHOT版，具体看哪个时间最后。
- **RELEASE**：指最后一个发布版。
