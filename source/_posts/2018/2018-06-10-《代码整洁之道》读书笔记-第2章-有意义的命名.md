---
title: '《代码整洁之道》读书笔记--第2章:有意义的命名'
tags:
  - 代码规范
categories:
  - 读书笔记
  - 《代码整洁之道》
comments: true
date: 2018-06-10 18:19:48
---


我们写代码的时候需要不停的命名，项目、类、函数、变量 等等都要命名。而命名关乎程序的可读性，而程序的可读性又至关重要（代码是写给人看的）。

## 名副其实

一个很重要的原则是：**如果命名需要注释来补充，那就不算名副其实。**

举个例子：

```
int d;  //消逝的时间，以日计
```

名称`d`什么也没说，如果其他很多地方要用到这个变量那就十分糟糕了，因为用的人不一定想的起来`d`是什么意思（如果只是局部变量局部使用，那它的罪孽会轻一点，如果是全局变量或者类的成员变量那这简直就是大坑）。**其实我们很容易发现，注释没法像好的命名一样方便，因为我们不会在写代码的时候看到一个不懂的命名就去找它的定义处的注释，这样会浪费很多时间**。所以好的命名就应该能自己说明自己是什么。

好的命名如下：

```
int elapsedTimeInDays;
int daysSinceCreation;
int daysSinceModification;
int fileAgeInDays;
```

下面我们看一段代码：

```Java
public List<int[]> getThem() {
    List<int[]> list1 = new ArrayList<int[]>();
    for (int[] x : theList){
        if (x[0] == 4){
            list1.add(x);
        }
    }
    return list1;
}
```

这段代码很糟糕，虽然里面没有复杂的表达式，空格和缩进中规中矩，只用到三个变量和两个常量，甚至没涉及到其他类或多态方法。但这段代码很难说清它在做什么。问题不在于代码的简洁度，而在于代码的 **模糊度：即上下文在代码中未被明确体现的程度**。比如随便提几个问题：

1. theList 是什么类型的东西？
2. theList 零下标条目的意义是什么？
3. 值4的意义是什么？
4. 我们怎么使用返回的list1？

**问题的答案没体现在代码段中，可那就是它们该在的地方！如果不是对上下文及其熟悉，我们根本无法知道这代码在做什么！**

比方说，我们在开发一种扫雷游戏，我们发现，盘面是名为 theList 的单元格列表，那就将其命名为：gameBoard。盘面上每个单元格都用一个简单数组表示。我们还发现，零下标条目是一种状态值，而这种状态值为4表示“已标记”。我们将代码修改如下：

```Java
public List<int[]> getFlaggedCells() {
    List<int[]> flaggedCells = new ArrayList<int[]>();
    for (int[] cell : gameBoard){
        if (cell[STATE_VALUE] == FLAGGED){
            flaggedCells.add(cell);
        }
    }
    return flaggedCells;
}
```

这下这段代码是什么功能，做了些什么工作简直一目了然。还可以进一步，不用int数组表示单元格，而是另写一个类。该类包括一个名副其实的函数（称为 isFlagged），从而掩盖住那个魔术数。

> 魔术数，magic number：指使用不明其意的立即数，至少我们应该用一个常量来对这种立即数进行命名，赋予其意义。

```Java
public List<Cell> getFlaggedCells() {
    List<Cell> flaggedCells = new ArrayList<>();
    for (Cell cell : gameBoard){
        if (cell.isFlagged()){
            flaggedCells.add(cell);
        }
    }
    return flaggedCells;
}
```

从int数组到Cell类，**抽象程度又提高了，代码可重用性也就提高了**。

## 避免误导

例如，hp、aix 和 sco 都不应该用作变量名，因为它们都是UNIX平台或类UNIX平台的专有名称。别用accountList来指称一组账号，除非它们真的是List类型，List一词对程序员来说有特殊的意义，如果包纳账号的容器并非是一个List，就会引起错误的判断（即便容器就是个List，最好也别在名称中写出容器的类型）。所以，用accountGroup或bunchOfAccounts，甚至直接用accounts都会好一些。

**提防使用不同之处较小的命名**。想区分模块中某处的XYZControllerForEfficientHandlingOfStrings 和另一处的 XYZControllerForEfficentStorageOfStrings，会花多长时间呢？这两个词外形实在太相似了。我们很享受线代Java编程环境的自动代码完成特性，键入某个名称的前几个字母，就可以得到一列该名称的可能性，假如相似的名字依字母顺序放在一起，且差异很明显，那就会相当有助益。

>在某些字体里，1和l，0和O很难分清。要注意这种混淆。

## 做有意义的区分

如果程序员只是为满足编译器或解释器的需要而写代码，就会制造麻烦。例如，因为同一作用域内不能重名，你可能随手改掉其中一个命名，有时候干脆以错误的拼写充数，结果就是有人一不小心更正拼写错误，然后导致编译器出错。

例如class已经是关键字，就给变量命名为klass，clazz，还有this，命名成thiz。

以数字系列命名（a1, a2, ..., aN）是以意义命名的对立面。试看：

```Java
public static void copyChars(char a1[], char a2[]){
    for (int i=0;i<a1.length;i++){
        a2[i] = a1[i];
    }
}
```

如果参数名改为 `source` 和 `destination`，这个函数就会像样许多。

**废话是另一种没意义的区分**。假设你有一个 Product 类。如果还有一个 ProductInfo 或 ProductData 类，那它们的名称虽然不同，意思却并无区别。Info和Data就像a、an和the一样是意义含混的废话。
注意，只要体现出有意义的区分，使用a和the这样的前缀就没错。例如，你可能把a用在域内变量，而把the用于函数参数。但如果你已经有一个名为zork的变量，又想调用一个名为theZork的变量，麻烦就来了。

废话都是冗余。Variable一词永远不应当出现在变量名中。Table一词永远不应当出现在表名中。NameString会比Name好吗？难倒Name会是一个浮点数不成？如果是这样，就触犯了关于误导的规则。设想有个名为Customer的类，还有一个名为CustomerObject的类。区别何在呢？哪个是表示客户历史支付情况的最佳途径？

举个例子：

```
getActiveAccount();
getActiveAccounts();
getActiveAccountInfo();
```

程序员怎么知道该调用哪个函数呢？

如果缺少明确约定，变量moneyAmount就与money没区别，customerInfo与custmoer没区别，accountData与account没区别，theMessage也与message没区别。**要区分名称，就要以读者能鉴别不同之处的方式来区分**。

## 使用读的出来的名称

人类长于记忆和使用单词，若不善加利用，实在是种耻辱。

**如果名称读不出来，讨论的时候会像个傻鸟**。“哎，这儿，鼻涕阿三喜摁踢（bee cee arr three cee enn tee， BCR3CNT的读音）上头，有个皮挨死极翘（pee ess zee kyew）整数，看见没？” **这不是小事，因为编程本就是一种社会活动**。

有家公司，程序里面写了个 genymdhms（生成日期，年、月、日、时、分、秒），他们一般读作：“gen why emm dee aich emm ess”，YMDHMS的读音。我有个见字照读的恶习，于是开口就念“gen-yah-mudda-hims”。后来好些设计师和分析师都有样学样，听起来傻乎乎。我们知道典故，所以觉得很搞笑。搞笑归搞笑，实际是在强忍糟糕的命名。在给新开发者解释变量的意义时，他们总是读出傻乎乎的自造词，而非恰当的英语词。比较：

```Java
class DtaRcrd102 {
    private Date genymdhms;
    private Date modymdhms;
    private final String pszqint = "102";
    /* ... */
}
```

```C++
class Customer {
    private Date generationTimestamp;
    private Date modificationTimestamp;
    private final String recordId = "102";
    /* ... */
}
```

现在读起来就像人话了：“喂，Mikey，看看这条记录！生成时间戳（generation timestamp）被设置为明天了！不能这样吧？”

## 使用可搜索的名称

单字母名称和数字常量有个问题，就是很难在一大篇文字中找出来。

## 避免使用编码

编码已经太多，无谓再自找麻烦。把类型或作用域编进名称里面，徒然增加了解码的负担。没理由要求每位新人都在弄清要应付的编码之外（那算是正常的），还要再搞懂另一套编码“语言”。这对于解决问题而言，纯属多余的负担。带编码的名称通常也不便发音，容易打错。

### 匈牙利命名法

在往昔名称长短很要命的时代，我们毫无必要的破坏了不编码的规矩，如今后悔不迭。Fortran语言要求首字母体现出类型，导致了编码的产生。BASIC早期版本只允许使用一个字母再加一位数字。匈牙利命名法（Hungarian Notation，HN）将这种态势愈演愈烈。

在Windows的C语言API的时代，HN相当重要，那时所有名称要么是个整数句柄，要么是个长指针或者void指针，要不然就是string的几种实现（有不同的用途和属性）之一。那时候编译器并不做类型检查，程序员需要匈牙利命名法来帮助自己记住类型。

现代编程语言具有更丰富的类型系统，编译器也记得并强制使用类型。而且，人们趋向于使用更小的类、更短的方法，好让每个变量的定义都在视野范围内。

Java程序员不需要类型编码。对象是强类型的，代码编辑环境已经先进到在编译开始前就侦测到类型错误的程度！所以，如今HN和其他类型编码形式都纯属多余。它们增加了修改变量、函数或类的名称或类型的难度。它们增加了阅读代码的难度。它们制造了让编码系统误导读者的可能性。

```
PhoneNumber phoneString;    // 类型变化时，名称并不会自动变化，若名称中编码了类型，还要我们手动去改。
```

### 成员前缀

也不必用m_前缀来标明成员变量。应当把类和函数做得足够小，消除对成员前缀的需要。你应当使用某种可以高亮或用颜色标出成员的编辑环境。

```
public class Part {
    private String m_dsc;   // The textual description
    void setName(String name) {
        m_dsc = name;
    }
}
```

```Java
public class Part{
    String description;
    void setDescription(String description) {
        this.description = description;
    }
}
```

此外，人们会很快就学会无视前缀（或后缀），只看到名称中有意义的部分。代码读的越多，眼中就越没有前缀。最终，前缀变作了不入法眼的废料，变作了旧代码的标志物。

### 接口和实现

有时也会出现采用编码的特殊情形。比如，你在做一个创建形态用的抽象工厂（Abstract Factory）。该工厂是个接口，要用具体类来实现。你怎么 命名工厂和具体类呢？IShapeFactory和ShapeFactory吗？我喜欢不加修饰的接口。前导字母I被滥用到了说好听点是干扰，说难听点根本就是废话的程度。我不想让用户知道我给他们的是接口。我就想让他们知道那是个ShapeFactory。如果接口和实现必须选一个来编码的话，我宁肯选择实现。ShapeFactoryImp，甚至是丑陋的CShapeFactory，都比对接口名称编码来得好。

## 避免思维映射

不应当让读者在脑海中把你的名称翻译为他们熟知的名称。这种问题经常出现在选择是使用问题领域术语还是解决方案领域术语时。

单字母变量名就是个问题。在作用域较小，也没有名称冲突时，循环计数器自然有可能被命名为i或j或k（但千万别用字母l）。这是因为传统上惯用单字母名称做循环计数器。然而，在多数其他情况下，单字母名称不是个好选择，读者必须在脑海中将它映射为真实概念。仅仅是因为有了a和b，就要取名为c，实在并非像样的理由。

程序员通常都是聪明人。聪明人有时会借脑筋急转弯炫耀其聪明。总而言之，假使你记得r代表不包含主机和图式（scheme）的小写字母版url的话，那你真是太聪明了。

聪明程序员和专业程序员之间的区别在于，专业程序员了解，明确是王道。专业程序员善用其能，编写其他人能理解的代码。

## 类名

类名和对象名应该是名词或名词短语，如Customer、WikiPage、Account和AddressParser。避免使用Manager、Processor、Data或Info这样的类名。类名不应当是动词。

>这里没看懂，举的例子并不是动词啊

## 方法名

方法名应当是动词或动词短语，如 postPayment、deletePage或save。属性访问器、修改器和断言应该根据其值命名，并依Javabean标准加上get、set和is前缀。

```Java
String name = employee.getName();
customer.setName("mike");
if(paycheck.isPosted())...
```

重载构造器时，使用描述了参数的静态工厂方法名。例如：

```Java
Complex fulcrumPoint = Complex.FromRealNumber(23.0);
```

通常好于

```Java
Complex fulcrumPoint = new Complex(23.0);
```

可以考虑将相应的构造器设置为private，强制使用这种命名手段。

## 别扮可爱

如果名称太耍宝，那就只有同作者一般有幽默感的人才能记得住，而且还是在他们记得那个笑话的时候才行。谁会知道名为HolyHandGrenade的函数是用来做什么的呢？没错，这名字挺伶俐，不过DeleteItems或许是更好的名称。宁可明确，毋为好玩。

扮可爱的做法在代码中经常体现为使用俗语或俚语。例如，别用whack()来表示kill()。别用eatMyShorts()这类与文化紧密相关的笑话来表示abort()。

## 每个概念对应一个词

给每个抽象概念选一个词，并且一以贯之。例如，使用fetch、retrieve和get来给在多个类中的同种方法命名。你怎么记得住哪个类中是哪个方法呢？

Eclipse和Intellj之类的线代编程环境提供了与环境相关的线索，比如某个对象能调用的方法列表。不过要注意，列表中通常不会给出你为函数名和参数列表编写的注释。如果参数名称来自函数声明，你就太幸运了。函数名称应当独一无二，而且要保持一致，这样你才能不借助多余的浏览就能找到正确的方法。

同样，在同一堆代码中有controller，又有manager，还有driver，就会令人困惑。DeviceManager和Protocal-Controller之间有何根本区别？为什么不全用controllers或managers？他们都是Drivers吗？这种名称，让人觉得这两个对象是不同类型的，也分属不同的类。

对于那些会用到你代码的程序员，一以贯之的命名法简直就是天降福音。

## 别用双关语

避免将同一个单词用于不同目的。如果遵循“一词一意”的规则，可能在好多类里面都会有add方法。只要这些add方法的参数列表和返回值在语义上等价，就一切顺利。

但是，可能会有人决定为“保持一致”而使用add这个词来命名，即便并非真的想表示这种意思。比如，在多个类种都有add方法，该方法通过增加或连接两个现存值来获得新值。假设要写个新类，该类中有一个方法，把单个参数放到群集（collection）中。该把这个方法叫做add吗？这样做貌似和其他add方法保持了一致，但实际上语义却不同，应该用insert或append之类的词来命名才对。把该方法命名为add，就是双关语了。

## 使用解决方案领域的名称

记住，只有程序员才会读你的代码。所以，尽管用那些计算机科学（Computer Science, CS）术语、算法名、模式名、数学术语吧。

对于熟悉访问者（VISITOR）模式的程序来说，名称AccountVisitor富有意义。那个程序员会不知道JobQueue的意思呢？

## 使用源自所涉及问题领域的名称

如果不能用程序员熟悉的术语来给手头的工作命名，就采用从所涉及领域而来的名称吧。至少，负责维护代码的程序员就能去请教领域专家了。

## 添加有意义的语境

很少有名称是能自我说明的--多数都不能。反之，你需要用有良好命名的类、函数或名称空间来放置名称，给读者提供语境。如果没这么做，给名称添加前缀就是最后一招了。

设想你有名为firstName、lastName、street、houseNumber、city\state和zipcode的变量。当它们搁一块儿的时候，很明确是构成了一个地址。不过，假使只是在某个方法中看见孤零零的一个state变量呢？你会理所当然推断那是某个地址的一部分吗？

可以添加前缀addrFirstName、addrLastName、addrState等，以此提供语境。至少，读者会明白这些变量都是某个更大结构的一部分。当然，更好的方案是创建名为Address的类。这样，即便是编译器也会知道这些变量隶属某个更大的概念了。

看一个例子：

语境不明确的变量：

```Java
private void printGuessStatistics(char candidate, int count){
    String number;
    String verb;
    String pluralModifier;
    if(count==0){
        number="no";
        verb="are";
        pluralModifier="s";
    }else if(count==1){
        number="1";
        verb="is";
        pluralModifier="";
    }else{
        number=Integer.toString(count);
        verb="are";
        pluralModifier="s";
    }
    String guessMessage = String.format(
        "There %s %s %s%s", verb, number, candidate, pluralModifier);
    print(guessMessage);
}
```

上列函数有点过长，变量的使用贯穿始终。要分解这个函数，需要创建一个名为GuessStatisticsMessage的类，把三个变量做成该类的成员字段。这样它们就在定义上变作了GuessStatisticsMessage的一部分。语境的增强也让算法能够通过分解为更小的函数而变得更为干净利落。

有语境的变量：

```Java
public class GuessStatisticsMessage {
    private String number;
    private String verb;
    private String pluralModifier;

    public String make(char candidate, int count){
        createPluralDependentMessageParts(count);
        return String.format(
            "There %s %s %s%s", verb, number, candidate, pluralModifier);
    }

    private void createPluralDependentMessageParts(int count){
        if(count==0){
            thereAreNoLetters();
        }else if (count==1){
            thereIsOneLetter();
        }else{
            thereAreManyLetters(count);
        }
    }

    private void thereAreManyLetters(int count){
        number = Integer.toString(count);
        verb = "are";
        pluralModifier="s";
    }

    private void thereIsOneLetters(){
        number="1";
        verb = "is";
        pluralModifier = "";
    }

    private void thereAreNoLetters(){
        number = "no";
        verb = "are";
        pluralModifier = "s";
    }
}
```

## 不要添加没用的语境

设若有一个名为“加油站豪华版”（Gas Station Deluxe）的应用，在其中给每个类添加GSD前缀就不是什么好点子。说白了，你是在和自己在用的工具过不去。输入G，按下自动完成键，结果会得到系统中全部类的列表，列表恨不得有一英里那么长。这样做聪明吗？为什么要搞得IDE没法帮助你？

再比如，你在GSD应用程序中的记账模块创建了一个表示邮件地址的类，然后给该类命名为GSDAccountAddress。稍后，你的客户联络应用中需要用到邮件地址，你会用GSDAccountAddress吗？这名字听起来没问题吗？在这17个字母里面，有10个字母纯属多余，与当前语境毫无关联。

只要短名称足够清楚，就要比长名称好。别给名称添加不必要的语境。

对于Address类的实体来说，accountAddress和customerAddress都是不错的名称，不过用在类名上就不太好了。Address是个好类名。如果需要与MAC地址、端口地址和Web地址相区别，我会考虑使用PostalAddress、MAC和URI。这样的名称更为精确，而精确正是命名的要点。
