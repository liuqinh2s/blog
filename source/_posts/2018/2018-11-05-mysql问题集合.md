---
title: mysql问题集合
categories: [数据库, mysql]
comments: true
---

## 删除操作

delete from table where id not in (select id from table where name1=)
这样直接又查又写是不行的，只能造个临时表
1093 - You can't specify target table 'contacts' for update in FROM clause

delete from table where id not in (select * from (select id from table where name1=) t)
另外还要关闭一个属性：
set SQL_SAFE_UPDATES = 0;

## 跨表查询

跨表查询的时候，我老是先想到子查询，然后会困在一个地方，那就是我认为查询只能选择一个表，例如：
select * from table where ...
其实这里的table可以不止一个table，而是table1[table2,]
所以当你查一个监控的宝贝的时候，你在监控表里面只能查到宝贝id，宝贝名称则需要去宝贝表里面根据宝贝id查询，如果我们只需要宝贝名就好办，直接一个子查询。
select goods_name from t_goods where goods_guid in (select goods_guid from t_goods_monitor where user_guid = "73ed02cc-c69d-48d9-87c1-8ffbe4fa3e47" and platform = 1 and sm_status = 1)
而如果我们还需要用到t_goods_monitor中的字段，则子查询就办不到了。
这个时候可以查多个表，也可以用join，正规的做法是用join可以节省查询时间。

查多个表：

select  t_goods_monitor.*, t_goods.goods_name from t_goods, t_goods_monitor where t_goods_monitor.user_guid = "73ed02cc-c69d-48d9-87c1-8ffbe4fa3e47" 
    and t_goods_monitor.platform = 1
    and t_goods_monitor.sm_status = 1
    and t_goods_monitor.goods_guid = t_goods.goods_guid

使用JOIN

select  t_goods_monitor.*, t_goods.goods_name from t_goods_monitor LEFT JOIN t_goods ON
 t_goods_monitor.goods_guid = t_goods.goods_guid
 and t_goods_monitor.platform = t_goods.platform
where  t_goods_monitor.user_guid = "73ed02cc-c69d-48d9-87c1-8ffbe4fa3e47" 
and t_goods_monitor.platform = 1
    and t_goods_monitor.sm_status = 1

t_goods是大表，里面可能包含几百万的宝贝，t_goods_monitor是小表。

查询小表，然后左连接大表。如果某个goods_guid没有对应的宝贝名，则依然查询出来。这就是LEFT JOIN，返回左表所有行。
这里要注意的是ON的条件只对右表起作用。

关于 “A LEFT JOIN B ON 条件表达式” 的一点提醒
ON 条件（“A LEFT JOIN B ON 条件表达式”中的ON）用来决定如何从 B 表中检索数据行。
如果 B 表中没有任何一行数据匹配 ON 的条件,将会额外生成一行所有列为 NULL 的数据
在匹配阶段 WHERE 子句的条件都不会被使用。仅在匹配阶段完成以后，WHERE 子句条件才会被使用。它将从匹配阶段产生的数据中检索过滤。

ON 子句和 WHERE 子句有什么不同？

一个问题：下面两个查询的结果集有什么不同么？

1. SELECT * FROM product LEFT JOIN product_details
         ON (product.id = product_details.id)
         AND   product_details.id=2;
2. SELECT * FROM product LEFT JOIN product_details
         ON (product.id = product_details.id)
         WHERE product_details.id=2;

用例子来理解最好不过了：

mysql> SELECT * FROM product LEFT JOIN product_details
       ON (product.id = product_details.id);
+----+--------+------+--------+-------+
| id | amount | id   | weight | exist |
+----+--------+------+--------+-------+
|  1 |    100 | NULL |   NULL |  NULL |
|  2 |    200 |    2 |     22 |     0 |
|  3 |    300 | NULL |   NULL |  NULL |
|  4 |    400 |    4 |     44 |     1 |
+----+--------+------+--------+-------+
4 rows in set (0.00 sec)

mysql> SELECT * FROM product LEFT JOIN product_details
       ON (product.id = product_details.id)
       AND product_details.id=2;
+----+--------+------+--------+-------+
| id | amount | id   | weight | exist |
+----+--------+------+--------+-------+
|  1 |    100 | NULL |   NULL |  NULL |
|  2 |    200 |    2 |     22 |     0 |
|  3 |    300 | NULL |   NULL |  NULL |
|  4 |    400 | NULL |   NULL |  NULL |
+----+--------+------+--------+-------+
4 rows in set (0.00 sec)
 
mysql> SELECT * FROM product LEFT JOIN product_details
       ON (product.id = product_details.id)
       WHERE product_details.id=2;
+----+--------+----+--------+-------+
| id | amount | id | weight | exist |
+----+--------+----+--------+-------+
|  2 |    200 |  2 |     22 |     0 |
+----+--------+----+--------+-------+
1 row in set (0.01 sec)


第一条查询使用 ON 条件决定了从 LEFT JOIN的 product_details表中检索符合的所有数据行。
第二条查询做了简单的LEFT JOIN，然后使用 WHERE 子句从 LEFT JOIN的数据中过滤掉不符合条件的数据行。
再来看一些示例：

mysql>
mysql> SELECT * FROM product LEFT JOIN product_details
       ON product.id = product_details.id
       AND product.amount=100;
+----+--------+------+--------+-------+
| id | amount | id   | weight | exist |
+----+--------+------+--------+-------+
|  1 |    100 | NULL |   NULL |  NULL |
|  2 |    200 | NULL |   NULL |  NULL |
|  3 |    300 | NULL |   NULL |  NULL |
|  4 |    400 | NULL |   NULL |  NULL |
+----+--------+------+--------+-------+
4 rows in set (0.00 sec)

所有来自product表的数据行都被检索到了，但没有在product_details表中匹配到记录（product.id = product_details.id AND product.amount=100 条件并没有匹配到任何数据）

mysql> SELECT * FROM product LEFT JOIN product_details
       ON (product.id = product_details.id)
       AND product.amount=200;
+----+--------+------+--------+-------+
| id | amount | id   | weight | exist |
+----+--------+------+--------+-------+
|  1 |    100 | NULL |   NULL |  NULL |
|  2 |    200 |    2 |     22 |     0 |
|  3 |    300 | NULL |   NULL |  NULL |
|  4 |    400 | NULL |   NULL |  NULL |
+----+--------+------+--------+-------+
4 rows in set (0.01 sec)

有来自product表的数据行都被检索到了，但没有在product_details表中匹配到记录（product.id = product_details.id AND product.amount=100 条件并没有匹配到任何数据）

提问：能不能先where再on，因为先where再on可以提高效率。就拿根据宝贝ID跨表查询宝贝名来说，如果能先用where筛选出需要的宝贝ID在去查询宝贝名的话就能节省查询次数，而如果是先用on直接把所有宝贝ID对应的宝贝名查出来，再where过滤不符合条件的宝贝ID，这样第一步的on操作就做了一些无用功。

## 中文显示问题

```
MariaDB [BookMarkSocial]> show create table users \G;
*************************** 1. row ***************************
      Table: users
Create Table: CREATE TABLE `users` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `unique_name` varchar(20) CHARACTER SET latin1 NOT NULL,
  `password` varchar(512) CHARACTER SET latin1 NOT NULL,
  `email` varchar(40) CHARACTER SET latin1 NOT NULL,
  `phone` varchar(20) CHARACTER SET latin1 DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8
```

```
alter table table_name convert to character set utf8;
//此后再往这个table插入中文的时候，就可以正常存储和读取了，但不知道为什么之前的乱码还是不能纠正，只能新插入的数据没有问题。
```

```
MariaDB [BookMarkSocial]> show variables like '%char%'
    -> ;
+--------------------------+----------------------------+
| Variable_name            | Value                      |
+--------------------------+----------------------------+
| character_set_client    | utf8                      |
| character_set_connection | utf8                      |
| character_set_database  | utf8                      |
| character_set_filesystem | binary                    |
| character_set_results    | utf8                      |
| character_set_server    | utf8                      |
| character_set_system    | utf8                      |
| character_sets_dir      | /usr/share/mysql/charsets/ |
+--------------------------+----------------------------+
```

```
set character_set_server=utf8;
set character_set_database=utf8;
```