---
title: POJ 1006 Biorhythms
date: 2018-02-15
categories: [ACM, POJ]
comments: true
---

## 同余

两个整数 a, b，若它们除以正整数 m所得的余数相等，则称 a,b对于模 m 同余，记作：$a \equiv b (mod\quad m)$。最先引用同余的概念与”$\equiv$”符号的是德国数学家 高斯。

## 中国剩余定理

在《孙子算经》中有这样一个问题：“今有物不知其数，三三数之剩二（除以3余2），五五数之剩三（除以5余3），七七数之剩二（除以7余2），问物几何？”这个问题称为“孙子问题”，该问题的一般解法国际上称为“中国剩余定理”。具体解法分三步：

找出三个数：从3和5的公倍数中找出被7除余1的最小数15，从3和7的公倍数中找出被5除余1 的最小数21，最后从5和7的公倍数中找出除3余1的最小数70。
用15乘以2（2为最终结果除以7的余数），用21乘以3（3为最终结果除以5的余数），同理，用70乘以2（2为最终结果除以3的余数），然后把三个乘积相加（15*2+21*3+70*2）得到和233。
用233除以3，5，7三个数的最小公倍数105，得到余数23，即233%105=23。这个余数23就是符合条件的最小数。

为什么要这么做呢？

这就牵涉到一个最基本数学定理，如果有a%b=c,则有(a+kb)%b=c(k为非零整数)，换句话说，如果一个除法运算的余数为c，那么被除数与k倍的除数相加（或相减）的和（差）再与除数相除，余数不变。这就是上面提到的同余。

以此定理为依据，如果n2是3的倍数，n1+n2就依然满足除以3余2。同理，如果n3也是3的倍数，那么n1+n2+n3的和就满足除以3余2。这是从n1的角度考虑的，再从n2，n3的角度出发，我们可推导出以下三点：

- 为使n1+n2+n3的和满足除以3余2，n2和n3必须是3的倍数。
- 为使n1+n2+n3的和满足除以5余3，n1和n3必须是5的倍数。
- 为使n1+n2+n3的和满足除以7余2，n1和n2必须是7的倍数。

因此，为使n1+n2+n3的和作为“孙子问题”的一个最终解，需满足：

- n1除以3余2，且是5和7的公倍数。
- n2除以5余3，且是3和7的公倍数。
- n3除以7余2，且是3和5的公倍数。

所以，孙子问题解法的本质是从5和7的公倍数中找一个除以3余2的数n1，从3和7的公倍数中找一个除以5余3的数n2，从3和5的公倍数中找一个除以7余2的数n3，再将三个数相加得到解。在求n1，n2，n3时又用了一个小技巧，以n1为例，并非从5和7的公倍数中直接找一个除以3余2的数，而是先找一个除以3余1的数，再乘以2。

最后，我们还要清楚一点，n1+n2+n3只是问题的一个解，并不是最小的解。如何得到最小解？我们只需要从中最大限度的减掉掉3，5，7的公倍数105即可。道理就是前面讲过的定理“如果a%b=c,则有(a-kb)%b=c”。所以（n1+n2+n3）%105就是最终的最小解。

总结就两个公式：

- 如果 a%b=c , 则有 (a+kb)%b=c (k为非零整数)。
- 如果 a%b=c，那么 (a*k)%b=kc (k为大于零的整数)。

## 解题代码

最后我们再来看看我们这道题，如何使用中国剩余定理来得到时间复杂度 O(1) 的解。

已知(n+d)%23=p; (n+d)%28=e; (n+d)%33=i

使33×28×a被23除余1，用33×28×8=5544；

使23×33×b被28除余1，用23×33×19=14421；

使23×28×c被33除余1，用23×28×2=1288。

因此有（5544×p+14421×e+1288×i）% lcm(23,28,33) =n+d

又23、28、33互质，即lcm(23,28,33)= 21252;

所以有n=（5544×p+14421×e+1288×i-d）%21252

本题所求的是最小整数解，避免n为负，因此最后结果为n= [n+21252]% 21252

那么最终求解n的表达式就是：
n=(5544p+14421e+1288*i-d+21252)%21252

```C++
#include <iostream>

using namespace std;

#define P 23
#define E 28
#define I 33
#define C 21252

int main() {
    int p, e, i, d;
    int count=1;
    int J=E*I;
    int K=P*I;
    int H=P*E;
    int j;
    int k;
    int h;
    for(j=J;j%P!=1;j+=J);
    for(k=K;k%E!=1;k+=K);
    for(h=H;h%I!=1;h+=H);
    // cout << j << endl;
    // cout << k << endl;
    // cout << h << endl;
    while (cin >> p >> e >> i >> d) {
        if(p==-1){
            break;
        }
        int result = (j*p+k*e+h*i-d+C)%C;
        if(result==0)
            result = C;
        cout << "Case "<< count << ": the next triple peak occurs in " << result << " days." << endl;
        count++;
    }
    return 0;
}
```
