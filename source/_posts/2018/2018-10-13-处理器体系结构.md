---
title: 处理器体系结构
categories: [读书笔记,《CSAPP》]
comments: true
---

## Y86指令集体系结构

Y86指令集基本上是IA32指令集的一个子集。这个指令集就是我们处理器实现的目标。如下图：

![Y86指令集](../../../../images/2018/Y86指令集.png)

IA32的movl指令分成了4个不同指令：irmovl、rrmovl、mrmovl和rmmovl，i表示立即数Immediate，r表示寄存器Register，m表示存储器Memmory。第一个字母表示源，第二个字母表示目的。

这里不实现的功能有：

1. 存储器引用方式是简单的基址+偏移量形式，不支持变址寄存器（second index register）和任何寄存器伸缩（scaling）。
2. 和IA32一样不允许从一个存储器直接传送到另一个存储器地址。
3. 不允许立即数传送到存储器

4个整数操作指令：addl、subl、andl、xorl

7个跳转指令：jmp、jle、jl、je、jne、jge、jg。

6个条件传送指令：cmovle、cmovl、cmove、cmovne、cmovge、cmovg。

另外还有：call、ret、pushl、popl，halt指令停止指令执行。IA32中有一个与之相当的指令hlt，IA32的应用程序不允许使用这条指令，因为它会导致整个系统暂停运行。对于Y86来说，执行halt指令会导致处理器停止，并将状态码设置为HLT。

### 指令编码

与IA32一样使用小端编码。

![指令编码](../../../../images/2018/指令编码.png)

每条指令的第一个字节表明指令的类型，这个字节分为两部分，每部分4位：高4位是代码（code）部分，低4位是功能（function）部分。代码值为 0~0xB。可以观察到，`rrmvol`与条件传送指令有同样的指令代码，可以把它看作是一个无条件传送，就好像jmp指令是无条件跳转一样，它们的功能代码都是0。

寄存器编码如下：

![寄存器编码](../../../../images/2018/寄存器编码.png)

举个例子：用16进制表示指令 `rmmvol %esp, 0x12345(%edx)`的字节编码。

从上面图中可以看到，rmmovl第一个字节为40，由于%esp是4（占4位），%edx是2（占4位），所以第二个字节是42，最后再加上偏移量 00 01 23 45，小端表示是：45 23 01 00，所以最后得到指令的编码是：`404245230100`。

指令集的一个重要性质是字节编码必须有唯一解释，任意一个字节序列要么是一个唯一的指令，要么是一个不合法的指令。

相比于IA32，Y86没那么紧凑，IA32对寄存器只用了3位来编码，5位表明指令类型，所以IA32能将出栈入栈放进一个字节里。另外IA32可以将常数值编码成1、2、4字节，Y86总是编码成4字节。

### RISC 和 CISC

- RISC: reduced instruction set computers，精简指令集
- CISC: complex instruction set computers，复杂指令集

## Y86异常

![Y86异常](../../../../images/2018/Y86异常.png)

对于Y86，当遇到这些异常的时候，我们简单的让处理器停止执行指令。在更完善的设计中，处理器通常会调用一个 exception handler（异常处理程序），这个过程被指定用来处理遇到的某种类型的异常，例如放弃程序或调用一个用户自定义的 signal handler（信号处理程序）。

## Y86程序

```C
int Sum(int *Start, int Count)
{
    int sum = 0;
    while (Count) {
        sum += *Start;
        Start++;
        Count--;
    }
    return sum; 
}
```

![IA32对比Y86代码](../../../../images/2018/IA32对比Y86代码.png)

可以看到Y86有时候需要两条指令来完成IA32一条指令就能完成的事。然而如果用数组索引来写这个程序，要转换成Y86会很困难，因为Y86没有伸缩寻址。

完整代码如下：

![Y86汇编代码](../../../../images/2018/Y86汇编代码.png)

以`.`开头的是 assembler directive（汇编器命令），命令`.pos 0`告诉汇编器应该从地址0处开始产生代码。第3、4行使用的Stack标签，在最后有声明，其位置是0x100。第9到13行声明了一个数组，4字节对齐，值分别是：0xd，0xc0，0xb00，0xa000，array标签是起址。

>细节问题，`pushl %esp`（这个指令只能用汇编语言写，C语言无法产生）是先把%esp的值转移到栈，还是先%esp减4再将结果转移到栈，实际上不同版本的intel处理器都会产生不同的结果，所以一个很重要的教训是
要保证细节上的一贯性。

## 逻辑设计和硬件控制语言HCL

![逻辑门](../../../../images/2018/逻辑门.png)

构建一个组合电路有两条限制：

1. 两个或多个逻辑门的输出不能连接在一起。这样会导致线上的信号矛盾，产生不合法的电压或电路故障。
2. 必须是无环的，也就是不能形成回路。

下面是个简单的例子：

![组合电路](../../../../images/2018/组合电路.png)

用HCL来写这个网的函数就是：`bool eq = (a && b) || (!a && !b)`

HCL是用来C语言风格的语法，但这里同C语言不一样，该语句的意思不是执行了一次计算并将结果放入存储器，而是使用一个名字eq来称谓一个表达式。

实际上上面的组合电路就是同或，异或的表达式是：`bool eq = (!a && b) || (a && !b)`

多路复用器（multiplexor，通常称为：MUX）：

![MUX组合电路](../../../../images/2018/MUX组合电路.png)

`bool out = (s && a) || (!s && b)`

### 字级的组合电路和HCL整数表达式

字级与电路：

![字级与电路](../../../../images/2018/字级与电路.png)

`bool Eq = (A == B);`

也可以用异或来实现：

![字级异或电路](../../../../images/2018/字级异或电路.png)

字级多路复用电路：

![字级多路复用电路](../../../../images/2018/字级多路复用电路.png)

用HCL来描述就是：

```
int Out = [
    s: A;
    1: B;
];
```

四路复用器：

![四路复用器](../../../../images/2018/四路复用器.png)

```
int Out4 = [
    !s1 && !s0: A; # 00
    !s1       : B; # 01
    !s0       : C; # 10
    1         : D; # 11
];
```

第二个表达式可以写成`!s1`，而不用写的更完整`!s1&&s0`，是因为另一种可能`s0=0`已经出现在了第一个选择表达式了，若能到达第二个选择表达式，则`s0=1`。类似的，第三个表达式可以写成`!s0`，第四个表达式可以简单的写成1。




