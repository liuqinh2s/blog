---
title: Java反射
categories: [Java]
comments: true
tags: [Java]
---

## 应用场景

研究一个东西我通常喜欢从应用场景入手，从需求出发。

java反射如果直接看维基百科的定义，会有点让人困惑。

我们来看一个例子：

假设现在有4个类，分别为`Apple`、`Pear`、`StrawBerry`、`Orange`，它们的基类是`Fruit`，以及一个主类Main。主类中有一个`eat`方法。

```java
public class Main{
    Fruit fruit = null;
    @org.junit.Test
    public void eat(String name){
        if("Apple".equals(name)){
            fruit = new Apple();
        }
        if("Pear".equals(name)){
            fruit = new Pear();
        }
        if("StrawBerry".equals(name)){
            fruit = new StrawBerry();
        }
        if("Orange".equals(name)){
            fruit = new Orange();
        }
    }
}
```

如果我们使用反射，代码可以更加抽象：

```java
public class Main{
    Class fruit = null;
    @org.junit.Test
    public void eat(String name){
        fruit = Class.forName(name);
    }
}
```

>唯一要注意的一点是，传给eat方法的参数必须是完整的类路径，例如：`eat(com.example.demo.Apple)`

## 获取Class

1. 类名.class
2. 对象.getClass()
3. Class.forName("className")

## 获取方法

1. **getDeclaredMethods**: 返回类或接口声明的所有方法（包括公共、私有、包（默认）、保护），但不包括继承来的方法。
```java
public Method[] getDeclaredMethods() throws SecurityException
```
2. **getMethods**: 返回某个类的所有公共（public）的方法，包括继承来的方法。
```java
public Method[] getMethods() throws SecurityException
```
3. **getMethod**: 返回一个特定的方法，其中第一个参数为方法名，后面的参数为方法参数对应的Class的对象。
```java
public Method getMethod(String name, Class<?>... parameterTypes)
```
4. **getDeclaredMethod**: 返回一个特定的方法，但不包括继承来的方法。
```java
public Method getDeclaredMethod(String name, Class<?>... parameterTypes)
```

`DemoApplication.java`文件：
```java
public class DemoApplication {

    Class fruit = null;

    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
        DemoApplication d = new DemoApplication();
        d.eat("com.example.demo.Apple");
    }

    public void eat(String name){
        try {
            fruit = Class.forName(name);
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
        System.out.println(fruit);
        Method[] declaredMethods = fruit.getDeclaredMethods();
        Method[] methods = fruit.getMethods();
        Method method = null;
        Method declaredMethod = null;
        try {
            method = fruit.getMethod("fruit", String.class);
//            declaredMethod = fruit.getDeclaredMethod("fruit", String.class);
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
        }
//        for(Method m:declaredMethods){
//            System.out.println(m);
//        }
//        for(Method m:methods){
//            System.out.println(m);
//        }
        System.out.println(method);
//        System.out.println(declaredMethod);
    }


}

abstract class Fruit {
    public void fruit(String str){}
}

class Apple extends Fruit {
    public void hello(String str){}
}

class Orange extends Fruit {
}

class StrawBerry extends Fruit {
}

class Pear extends Fruit {
}
```

如果是内部类的形式：

```java
public class DemoApplication {

    Class fruit = null;

    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
        DemoApplication d = new DemoApplication();
        d.eat("com.example.demo.DemoApplication$Apple");
    }

    public void eat(String name){
        try {
            fruit = Class.forName(name);
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
        System.out.println(fruit);
        Method[] declaredMethods = fruit.getDeclaredMethods();
        Method[] methods = fruit.getMethods();
        Method method = null;
        Method declaredMethod = null;
        try {
            method = fruit.getMethod("fruit", String.class);
//            declaredMethod = fruit.getDeclaredMethod("fruit", String.class);
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
        }
//        for(Method m:declaredMethods){
//            System.out.println(m);
//        }
//        for(Method m:methods){
//            System.out.println(m);
//        }
        System.out.println(method);
//        System.out.println(declaredMethod);
    }

    abstract class Fruit {
        public void fruit(String str){}
    }

    class Apple extends Fruit {
        public void hello(String str){}
    }

    class Orange extends Fruit {
    }

    class StrawBerry extends Fruit {
    }

    class Pear extends Fruit {
    }
}
```

### java基础知识

我一般习惯了一个文件放一个类，现在来回顾一下如果一个文件放多个类会是怎样。

一个`.java`文件只能有一个`public`类，且public类名字要跟文件名一样。一个文件中如果有多个类，编译之后得到多个`.class`文件。

实例：

```java
public   class   A   {}   
class   B   {}   
class   C   {} 
```

编译得到：A.class、B.class、C.class

```java
public   class   A   {
    class   B   {}   
    class   C   {} 
}   
```

编译得到：A.class、A$B.class、A$C.class

## 获取构造函数

通过反射机制得到某个类的构造器，然后调用该构造器创建该类的一个实例 

```java
//返回有指定参数的构造器(共有)
public Constructor<T> getConstructor(Class<?>... parameterTypes)

//返回所有构造器(共有)
public Constructor<?>[] getConstructors()

//返回有指定参数的构造器(共有和私有)
public Constructor<T> getDeclaredConstructor(Class<?>...parameterTypes)

//返回所有构造器(共有和私有)
public Constructor<?>[] getDeclaredConstructors()
```

## 获取属性

```java
getField(String name)   //获取class对象的公有name字段
getFields()             //获取class对象的所有共有字段

getDeclaredField(name)  //获取class对象name字段，无论是公有还是私有，但不能得到其父类的成员变量                                     
getDeclaredFields()     //获取class对象所有字段，无论是公有还是私有，但不能得到其父类的成员变量
```

## 调用方法

```java
public class test1 {
    public static void main(String[] args) throws IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException {
        Class<?> klass = methodClass.class;
        //创建methodClass的实例
        Object obj = klass.newInstance();
        //获取methodClass类的add方法
        Method method = klass.getMethod("add",int.class,int.class);
        //调用method对应的方法 => add(1,4)
        Object result = method.invoke(obj,1,4);
        System.out.println(result);
    }
}
class methodClass {
    public final int fuck = 3;
    public int add(int a,int b) {
        return a+b;
    }
    public int sub(int a,int b) {
        return a+b;
    }
}
```

## 利用反射创建数组

```java
public static void testArray() throws ClassNotFoundException {
    Class<?> cls = Class.forName("java.lang.String");
    Object array = Array.newInstance(cls,25);
    //往数组里添加内容
    Array.set(array,0,"hello");
    Array.set(array,1,"Java");
    Array.set(array,2,"fuck");
    Array.set(array,3,"Scala");
    Array.set(array,4,"Clojure");
    //获取某一项的内容
    System.out.println(Array.get(array,3));
}
```

其中的Array类为java.lang.reflect.Array类

## 注意事项

反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。