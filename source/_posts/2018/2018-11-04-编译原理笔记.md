---
title: 编译原理笔记
categories: [编译原理]
comments: true
---

## 编译原理知识点

总共六个阶段：
1. 词法分析
2. 语法分析
3. 语义分析
4. 中间代码生成
5. 代码优化
6. 目标代码生成

![编译原理.png](https://i.loli.net/2018/11/04/5bdead1f04562.png)

DFA（确定有穷自动机） 和 NFA（非确定有穷自动机）
区别就是，NFA 可以包含多个状态作为一个集，从这个集中跳到下一个集。而 DAF 是单个单个的状态，从一个状态跳到下一个状态。

![编译原理2.png](https://i.loli.net/2018/11/04/5bdeada2958c9.png)
![编译原理4.png](https://i.loli.net/2018/11/04/5bdeada4b572b.png)
![编译原理3.png](https://i.loli.net/2018/11/04/5bdeada864ff4.png)

所以文法G的形式定义如上所述
Vt：终结符，我们一般用除了大写字母表示。
Vn：非终结符，我们一般用大写字母表示。
S：一般是开始符号。
P：就表示一种规则啦。
a->b被称为产生式（定义式）

![编译原理5.png](https://i.loli.net/2018/11/04/5bdeada888830.png)

文法类型 | 规则 | 示例
--------|-----|--------
0型文法 | a->b 产生式左边a至少含有一个非终结符 | nA->b 
1型文法 | 在0型基础上，a->b 产生式右侧的长度越来越长。`|b| >=|a| S->ε` 除外。| nA->bSd 
2型文法 | 在1型基础上，a->b左侧为一个非终结符。| A->bSd 
3型文法 | 在2型基础上，a->b 右侧的形式为：A->cB 或A->c （仅此两种形式）AB为非终结符 | A->bSA-n

从0型文法到3型文法，规则越来越严格了。
**0型文法**：可由图灵机识别（关于图灵机，百度百科描述很详细了。）
**1型文法**：上下文有关文法。（任何产生规则的左手端和右手端都可以被终结符和非终结符的上下文所围绕，乔姆斯基描述自然语言的一种方式介入的，在自然语言中一个单词是否可以出现在特定的位置要依赖于上下文。）
**2型文法**：上下文无关文法。之所以称为上下文无关文法，是因为在推导式中a->b ，字符a总可以被字符串b自由替换，而无需考虑字符a出现的上下文。
**3型文法**：正规语言，之所人称作正规语言（正则语言），可能是因为3型文法只有两种形式 A->aB A->a ，比较固定，规则明显，所以称为正规语言。（小菜这么想的）

- 文法
- 正规式
- 有穷自动机
- 语法推导树


正规式：
正规式：正则表达式，表示正规集的工具。
一个正规式对应一个正规文法（3型文法）
之间能够进行准换
三个基本规则：
A->xB,B->y  则 A=xy。
A->xA|y  则A=x*y  （x*代表x从0到无穷多个）
A->x,A->y 则A=x|y

正规式主要用到了递归的思想，无论遇到多复杂的正规式都可以拆分成上面这三种形式，然后进行解题。

![编译原理6.png](https://i.loli.net/2018/11/04/5bdeaf42b0418.png)

编译器，解释器
预处理器（preprocessor），汇编器（assembler），链接器（linker），加载器（loader）

# 龙书笔记

## 1.1 语言处理器

概念

- 语言处理器
- 源语言
- 目标语言
- 编译器（compiler）
- 解释器（interpreter）
- 字节码（bytecode）
- 即时（just in time）编译器
- 预处理器（preprocessor）
- 编译器 （compiler）
- 汇编器（assembler）
- 链接器（linker）
- 加载器（loader）

知识点

- 编译器的一个重要任务是报告它在翻译过程中发现的源程序中的错误
- 编译器产生的机器语言目标程序通常比解释器快很多，但解释器由于逐个语句的执行源程序所以错误诊断效果比编译器好
- Java字节码有很好的平台移植性
- 预处理器的任务是把多个文件中的源程序集合到一起，并处理宏，然后输出给编译器
- 编译器输出汇编语言程序（因为汇编程序容易输出，便于阅读和调试）
- 汇编器把汇编程序生成可重定位的机器代码
- 大型程序经常被分为多个部分进行编译，因此可重定位的机器代码有必要和其他可重定位的目标文件及库文件连接到一起，形成真正可运行的机器代码。一个文件中的代码可能指向另一个文件中的位置，而 链接器能够解决外部内存地址的问题。
- 最后加载器把所有可执行文件放进内存中执行

## 1.1节练习

1.1.1：编译器和解释器的区别是什么？ 
编译器一次编译完所有的源代码并生成目标文件，解释器对源程序像读取执行指令一样挨个语句执行。 
1.1.2：编译器相对于解释器的优点是什么？解释器相对于编译器的有点是什么？ 
编译器生成的目标文件运行比解释器直接执行源程序快很多，解释器比编译器的错误诊断能力好 
1.1.3：在一个语言处理系统中，编译器产生汇编语言而不是机器语言的好处是什么？ 
汇编语言和机器语言是一一对应的，但汇编语言比机器语言容易阅读和调试，汇编语言面向人，机器语言面向机器。 
1.1.4：把一种高级语言翻译成另一种高级语言的编译器称为源到源（source-to-source）的翻译器。编译器使用C语言作为目标语言有什么好处？ 
C语言是跨平台的 
1.1.5：描述一下汇编器所要完成的一些任务。 
汇编器把汇编程序生成可重定位的机器程序。

## 一个编译器的结构

概念

- 分析（analysis）部分
- 综合（synthesis）部分
- 组成要素
- 中间表示
- 符号表（symbol table）
- 词法分析（lexical analysis）或扫描（scanning）
- 词素（lexeme）
- 词法单元（token）：
- 语法分析（syntax analysis）器或解析（parsing）
- 语义分析器（semantic analyzer）
- 中间代码生成器
- 代码优化器
- 代码生成器
- 语法树（syntax tree）
- 类型检查（type checking）
- 自动类型转换（coercion）

知识点

- 分析部分把源程序分解成多个组成要素，并在这些要素只上加上语法结构


