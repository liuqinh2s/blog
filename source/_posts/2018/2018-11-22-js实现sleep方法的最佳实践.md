---
title: js实现sleep方法的最佳实践
categories: [Programming Language, JavaScript]
comments: true
tags: JavaScript
---

`setTimeout`是异步的，跟其他语言里的`sleep`和`delay`并不一样，不能阻塞住程序。上网查了之后发现js没有自带的sleep方法，那么如何自己实现sleep方法呢？

[What is the JavaScript version of sleep()?](https://stackoverflow.com/questions/951021/what-is-the-javascript-version-of-sleep)

<!-- more -->

```javascript
function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function demo() {
  console.log('Taking a break...');
  await sleep(2000);
  console.log('Two seconds later');
}

demo();
```

[async](http://es6.ruanyifeng.com/#docs/async)

`await` 表达式会暂停当前 async function 的执行，等待 Promise 处理完成。若 Promise 正常处理(fulfilled)，其回调的resolve函数参数作为 await 表达式的值，继续执行 async function。

若 Promise 处理异常(rejected)，await 表达式会把 Promise 的异常原因抛出。

另外，如果 await 操作符后的表达式的值不是一个 Promise，则返回该值本身。



>如果你对箭头函数不了解，可以先去了解一下[箭头函数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions)。

这里利用了[Promise](http://es6.ruanyifeng.com/#docs/promise)对象。有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。

```javascript
const promise = new Promise(function(resolve, reject) {
  // ... some code

  if (/* 异步操作成功 */){
    resolve(value);
  } else {
    reject(error);
  }
})
```

Promise本身是一个容器，这个对象里面有两个回调方法和三种状态：

回调方法：`resolve`（此函数的作用是：将Promise对象的状态从“未完成”变为“成功”，即从pending变为fulfilled，并将value作为操作的结果返回出去）和`reject`（此函数的作用是：将将Promise对象的状态从“未完成”变为”失败“，即从pending变为rejected，并将value作为操作的结果返回出去）
三种状态：`pending`（进行中）、`fulfilled`（已成功）和`rejected`（已失败）。

```javascript
promise.then(function(value) {
  // success
}, function(error) {
  // failure
});
```

`then`方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved（也就是fulfilled）时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。

## JavaScript是单线程的

[JavaScript Promise：简介](https://developers.google.com/web/fundamentals/primers/promises?hl=zh-cn)

## JavaScript生成一个对象

var a = new Object;

## JavaScript继承机制

[Javascript继承机制的设计思想](http://www.ruanyifeng.com/blog/2011/06/designing_ideas_of_inheritance_mechanism_in_javascript.html)

阮一峰这篇文章并没有将彻底，他少了一个例子：

```javascript
function DOG(name){

　　　　this.name = name;

　　}

　　DOG.prototype = { species : '犬科' };

　　var dogA = new DOG('大毛');

　　var dogB = new DOG('二毛');


  DOG.prototype.species = '猫科';


// 　　console.log(dogA.species); // 猫科

// 　　console.log(dogB.species); // 猫科

　　dogA.species = "犬科"

　　dogA.__proto__.species = "hhhhh"

  console.log(dogA.species); // 猫科

　　console.log(dogB.species); // 猫科　　　
```

如果真的想理解，应该从对象的内存模型入手。

## JavaScript作用域

let是局部声明的，var是全局声明

## JavaScript 单线程与异步

![JavaScript 单线程与异步](https://juejin.im/entry/598d21d251882548bd4dbf53#comment)
