---
title: leetcode： 1074. 元素和为目标值的子矩阵数量
tags: [leetcode]
---

> 这个问题需要拆分出子问题才好解决，要不然没有思路。它的子问题是：[560. 和为 K 的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)

## [1074. 元素和为目标值的子矩阵数量](https://leetcode-cn.com/problems/number-of-submatrices-that-sum-to-target/)

当你理解了子问题之后，我们来想想，怎么把这个问题转换到子问题上呢？也就是如何把二维问题变一维问题呢？

我们想象把一个矩阵的列上的元素全部加起来，不就是一个一维数组了吗。这个一维数组可以等效的应用在这个问题上。

<!--more-->

那这样的组合有哪些呢？通过简单的二次遍历，就能得出我们想要的组合：

JavaScript 代码：

```javascript
for (let i = 0; i < n; i++) {
  for (let j = i; j < n; j++) {}
}
```

每次 i 到 j 之间的数就是我们想要的组合，拿这些数的和，组成新的一维数组，然后用一维数组的解法去解。这里有个小技巧是这个和也要避免重复计算，所以要把每次计算所得存下来，下次在这个基础上算，这样可以省下从头开始求和的时间。

JavaScript 代码：

```javascript
/**
 * @param {number[][]} matrix
 * @param {number} target
 * @return {number}
 */
var numSubmatrixSumTarget = function (matrix, target) {
  let count = 0;
  for (let i = 0; i < matrix.length; i++) {
    let sum = new Array(matrix[0].length).fill(0);
    for (let j = i; j < matrix.length; j++) {
      for (let k = 0; k < matrix[0].length; k++) {
        sum[k] += matrix[j][k];
      }
      count += subarraySum(sum, target);
    }
  }
  return count;
};

var subarraySum = function (nums, k) {
  let pre = 0;
  let preRecord = { 0: 1 };
  let count = 0;
  for (let i = 0; i < nums.length; i++) {
    pre += nums[i];
    if (preRecord[pre - k]) {
      count += preRecord[pre - k];
    }
    if (preRecord[pre]) {
      preRecord[pre]++;
    } else {
      preRecord[pre] = 1;
    }
  }
  return count;
};
```

> 简化问题的办法有很多，比如降低问题规模，降低维度，二维 -> 一维。
