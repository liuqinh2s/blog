---
title: 自己写json解释器
categories: [动手实践]
comments: true
---

## 前言

最近发现自己似乎除了公司的项目外，基本没什么别的项目。有一个gitbook正在制作（严格来说并不是项目）：[leetcode刷题笔记](https://liuqinh2s.gitbooks.io/leetcode/)。最近一直在语雀上看阮一峰的每周分享，在第四期中看到这个：[Douglas Crockford 的名片](http://seriot.ch/parsing_json.php#1)。想来想去，觉得可以做几个解析器，比如**json解析器**，**markdown解析器**，**正则表达式解析器**等等，然后可以回过头再去看看编译原理，夯实基础。

说干就干，先深入了解一下json，并看看别人如何实现json的解析。
* [https://www.json.org/](https://www.json.org/)
* [https://zhuanlan.zhihu.com/p/28049617](https://zhuanlan.zhihu.com/p/28049617)

<!--more-->

## json知识

json（JavaScript Object Notation，JavaScript对象记法），是一种数据交换语言（data-interchange format，也就是在传输数据的时候用的标记语言）。相比XML更加简洁易读。尽管json脱胎于JavaScript，但json已经是独立于语言的文本格式了。常见的应用场景有：**WEB开发**，**NoSql数据库**。

**json的结构有两种：**

* 键值对。在其他语言中，又叫做：object（对象），record（记录），struct（结构体），dictionary（字典），hash table（哈希表），keyed list（键列），associative array（关联数组）。
* 数组。

![](https://cdn.nlark.com/yuque/0/2019/gif/243235/1548817346559-bec98671-6891-4e18-9c1b-f7495f20fba7.gif#align=left&display=inline&height=113&linkTarget=_blank&originHeight=113&originWidth=598&size=0&width=598)

![](https://cdn.nlark.com/yuque/0/2019/gif/243235/1548817346985-ad605362-85e9-4122-873c-3ea760702448.gif#align=left&display=inline&height=113&linkTarget=_blank&originHeight=113&originWidth=598&size=0&width=598)

**对于具体的值而言，有七种：**

![](https://cdn.nlark.com/yuque/0/2019/gif/243235/1548817346509-3ff705a1-3d80-4bb9-a007-6d7351d2ccc2.gif#align=left&display=inline&height=278&linkTarget=_blank&originHeight=278&originWidth=598&size=0&width=598)

其中`true`、`false`、`null`这三种都是极其容易解析的，这里就不展示铁路图。下面展示一下`string`和`number`的铁路图。

**string：**

![](https://cdn.nlark.com/yuque/0/2019/gif/243235/1548817346617-bbaece81-ac6b-44c5-8f3b-c812282d09bb.gif#align=left&display=inline&height=413&linkTarget=_blank&originHeight=413&originWidth=598&size=0&width=598)

`string`只有两种特殊情况，且都比较简单：
1. 遇到`\`且后面是`u`，那么说明接下来的4个字节是一组的，组成一个unicode编码。<br />
1. 遇到`\`且后面不是`u`，那么只对后面紧跟的一个字节转义。<br />

**number：**

![](https://cdn.nlark.com/yuque/0/2019/gif/243235/1548817346858-d84fda0d-6473-44b3-b68e-e94d7e9de14a.gif#align=left&display=inline&height=266&linkTarget=_blank&originHeight=266&originWidth=598&size=0&width=598)

这个图其实也很简单，首先是有负号或者没负号（如果是正数，不用写正号）；然后是数字部分，要么是0，要么是非0开头的一串数字。然后是小数点，然后是小数部分，然后是指数部分。

## 开始写代码

代码地址：[json解析器（java版）](https://gist.github.com/liuqinh2s/9cdae8d5d6e476259d82d92c7da1cb93)
**在json中解析一个值只需要看第一个字符就知道了，json的解析不需要先做tokenize。**
我们先对json字符串进行`trim()`操作，去除掉首位多余的空白符。
我们使用一个全局变量`index`，来记录读到哪个位置了。使用`ignoreWhiteSpace()`方法来略过空白符。

```java
private void ignoreWhiteSpace() throws Exception {
    while (index < json.length()) {
        if (json.charAt(index) <= ' ') {
            index++;
        } else {
            break;
        }
    }
    if (index >= json.length()) {
        throw new Exception("illegal json string, while parsing value ArrayIndexOutOfBounds");
    }
}
```

先针对模式进行匹配：

```java
private Object parseValue() throws Exception {
    ignoreWhiteSpace();
    switch (json.charAt(index)) {
        case '{':
            return parseObject();
        case '[':
            return parseArray();
        case 'n':
        case 'N':
            return parseNull();
        case 't':
        case 'T':
            return parseTrue();
        case 'f':
        case 'F':
            return parseFalse();
        case '"':
        case '\'':
            return parseString();
        default:
            return parseNumber();
    }
}
```

当遇到一个`{`就代表接下来是一个键值对结构；当遇到一个`[`就知道接下来是一个数组结构。代码很清晰这里就不做解释了。我们看每种模式下的处理方法：<br />先挑最简单的，`null`、`true`、`false`的解析：

```java
private Object parseNull() throws Exception {
    if (json.substring(index, index + 4).equals("null")) {
        index += 4;
        return null;
    } else {
        throw new Exception("illegal json string, while parsing null");
    }
}

private Boolean parseTrue() throws Exception {
    if (json.substring(index, index + 4).equals("true") || json.substring(index, index + 4).equals("True")) {
        index += 4;
        return true;
    } else {
        throw new Exception("illegal json string, while parsing true");
    }
}

private Boolean parseFalse() throws Exception {
    if (json.substring(index, index + 5).equals("false") || json.substring(index, index + 5).equals("False")) {
        index += 5;
        return false;
    } else {
        throw new Exception("illegal json string, while parsing false");
    }
}
```

是不是很简单呢？我这里对首字母的大小写做了兼容，实际上官方的json规定是必须小写。
然后我们看看`string`的解析：

```java
private String parseString() throws Exception {
    char firstChar = json.charAt(index);
    index++;
    int recordIndex = index;
    for (; index < json.length() && json.charAt(index) != firstChar; index++) {
        if (json.charAt(index) == '\\') {
            if (json.charAt(index + 1) == 'u') {
                index += 5;
            } else {
                index++;
            }
        }
    }
    if (json.charAt(index) != firstChar) {
        throw new Exception("illegal json string, while parsing string");
    }
    return json.substring(recordIndex, index++);
}
```

这里同样对单引号的字符串做了兼容，官方标准是必须用双引号。可以看到其实代码非常简单，遇到反斜杠就转义，并跳过转义的部分就行了。<br />然后我们看看`number`的解析，虽然我们把`parseNumber()`放在了default分支中，但其实合法的`number`的开头必须是在字符集：`-`、`0~9`里面。

```java
private Object parseNumber() throws Exception {
    ignoreWhiteSpace();
    int recordIndex = index;
    boolean hasDot = false;
    while (index < json.length() && isNumberChar(json.charAt(index))) {
        if(json.charAt(index)=='.'){
            hasDot = true;
        }
        index++;
    }
    ignoreWhiteSpace();
    return hasDot?Double.parseDouble(json.substring(recordIndex, index)):Integer.parseInt(json.substring(recordIndex, index));
}

private Boolean isNumberChar(char c) {
    return numChars.get(c) != null || c <= '9' && c >= '0';
}

private Map<Character, Boolean> numChars = new HashMap<>();

public Object parse(String json) throws Exception {
    char[] chars = {'-', '+', 'e', 'E', '.'};
    for (char c : chars) {
        numChars.put(c, true);
    }
    this.json = json.trim();
    return parseValue();
}
```

在这段代码中，我只对`number`的字符集进行了校验，字符集包括：`-`、`+`、`e`、`E`、`.`以及`0~9`。所以它可以兼容`+05`这样的数字。
最后我们解析两种基本结构，这两种结构都可以包含子json对象，可想而知里面肯定要递归调用`parseValue`。

```java
private Map parseObject() throws Exception {
    index++;
    ignoreWhiteSpace();
    Map<String, Object> map = new HashMap<>();
    while (index < json.length() && json.charAt(index) != '}') {
        String key = parseString();
        ignoreWhiteSpace();
        if (json.charAt(index++) != ':') {
            throw new Exception("illegal json string, while parsing :");
        }
        Object value = parseValue();
        map.put(key, value);
        ignoreWhiteSpace();
        if (json.charAt(index) == ',') {
            index++;
        }
        ignoreWhiteSpace();
    }
    if (json.charAt(index++) != '}') {
        throw new Exception("illegal json string, while parsing object");
    }
    return map;
}

private List parseArray() throws Exception {
    index++;
    ignoreWhiteSpace();
    List<Object> arrayList = new ArrayList<>();
    while (index < json.length() && json.charAt(index) != ']') {
        arrayList.add(parseValue());
        if (json.charAt(index) == ',') {
            index++;
        }
        ignoreWhiteSpace();
    }
    if (json.charAt(index++) != ']') {
        throw new Exception("illegal json string, while parsing array");
    }
    return arrayList;
}
```

写到这儿，一个简单且完整的json解析器就完成了。代码中需要注意的是`index`的增加，解析完了一个部分，就要加一。

如果有任何问题或者建议欢迎联系我，<img src="http://wx2.sinaimg.cn/mw690/006zFO3ggy1fzofc13iqfj30ku0fv0su.jpg" width=40px style="display: inline!important; margin: 0; border: none;">：1479001484
