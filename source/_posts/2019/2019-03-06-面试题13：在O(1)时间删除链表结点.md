---
title: 面试题13：在O(1)时间删除链表结点
categories: [读书笔记, 《剑指offer》]
comments: true
---

## 题目

给定单向链表的头指针和一个结点指针，定义一个函数在O(1)时间删除该结点。链表结点与函数的定义如下：

```c++
struct ListNode
{
	int m_nValue;
	ListNode* m_pNext;
};

void DeleteNode(ListNode** pListHead, ListNode* pToBeDeleted);
```

<!--more-->

## 解答

一般情况下，要删除给定指针的结点，首先还要获得其之前的一个结点，所以需要遍历链表找到它前面的那个结点。这个查找的过程时间复杂度是O(n)。

在O(1)时间内删除一个结点，做法其实有点trick的味道。实际上删除的是要删除的当前结点的下一个结点，只不过在删除下一个结点之前，先把下一个结点的值赋给当前结点完成掉包。

但要考虑一些特殊情况，比如删除的对象是尾结点怎么办？尾结点没有下一个结点，所以只能老老实实的找到尾结点前面的结点。

如果是一个单结点的链表，删除的是头结点（同时它也是尾结点）怎么办？让头结点为空即可。

```c++
/**
 * 《剑指offer》面试题13：在O(1)时间删除链表结点
 * 给定头结点和要删除的结点，在O(1)时间内删除该结点
 * @param pListHead
 * @param pToBeDeleted
 */
void DeleteNode(ListNode **pListHead, ListNode *pToBeDeleted) {
    if (pListHead == NULL || *pListHead == NULL || pToBeDeleted == NULL) {
        return;
    }
    if (pToBeDeleted->pNext == NULL) {
        if(*pListHead==pToBeDeleted){
            *pListHead = NULL;
        }else{
            ListNode *head = *pListHead;
            while (head->pNext != NULL && head->pNext != pToBeDeleted) {
                head = head->pNext;
            }
            head->pNext = NULL;
        }
    } else {
        ListNode *temp = pToBeDeleted->pNext;
        pToBeDeleted->value = pToBeDeleted->pNext->value;
        pToBeDeleted->pNext = pToBeDeleted->pNext->pNext;
        delete (temp);
    }
}
```

即便这样做，这段代码还是可能会出问题（如果`pToBeDeleted`不在链表中）。调用者要保证`pToBeDeleted`在链表中。

完整的测试程序在我的github上：[Algorithm](https://github.com/liuqinh2s/Algorithm)
