---
title: 面试题7：用两个栈实现队列
categories: [读书笔记, 《剑指offer》]
comments: true
---

## 题目

用两个栈实现一个队列。队列的声明如下，请实现它的两个函数`appendTail`和`deleteHead`，分别完成在队列尾部插入结点和在队列头部删除结点的功能。

<!--more-->

## 解答

这道题很有意思，揭示了栈和队列其实是可以互换的。

```java
import java.util.Stack;

public class Solution {
    Stack<Integer> stack1 = new Stack<Integer>();
    Stack<Integer> stack2 = new Stack<Integer>();

    public void push(int node) {
        stack1.push(node);
    }

    public int pop() {
        if(stack2.empty()){
            while (!stack1.empty()){
                stack2.push(stack1.pop());
            }
        }
        return stack2.pop();
    }
}
```

解释一下上面代码的意思：stack1用来缓存输入，stack2用来缓存输出。当stack2不为空的时候，直接pop就可以了。当stack2为空的时候，就要把stack1的全部数据倾倒进stack2。这样从根本上保证了先进先出。

用这种方法实现的栈，分摊时间复杂度是2。

那么反过来怎么用两个队列实现一个栈呢？

手法如下：用一个queue1来接收输入，输出的时候，由于要输出最后一个元素，于是我们先把前面的元素输出到queue2进行缓存，然后输出最后一个元素。此时queue1为空，queue2有若干数。若此时再执行一次pop，该怎么办呢？故伎重施。 先将queue2倾倒进queue1，然后故伎重施。

用这种方法的实现效率是比较低的，如果遇到连续的pop操作，那么每次的复杂度都是2n。分摊时间复杂度是n。

```java
import java.util.*;
public class Solution {
    Queue<Integer> queue1 = new LinkedList<>();
    Queue<Integer> queue2 = new LinkedList<>();

    public void push(int node) {
        queue1.offer(node);
    }

    public int pop() throws Exception{
        if(queue1.size()>0){
            while (queue1.size()!=1){
                queue2.offer(queue1.poll());
            }
        }else if(queue2.size()>0){
            while (!queue2.isEmpty()){
                queue1.offer(queue2.poll());
            }
            while (queue1.size()!=1){
                queue2.offer(queue1.poll());
            }
        }else{
            throw new Exception("Queue is Empty!");
        }
        return queue1.poll();
    }
}
```