---
title: 面试题16：反转单链表
categories: [读书笔记, 《剑指offer》]
comments: true
---

## 题目

定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。链表结点定义如下：

```c++
struct ListNode
{
    int m_nValue;
    ListNode* m_pNext;
};
```

<!--more-->

## 解答

若允许使用额外空间，则很自然想到用栈。若不能使用额外空间，则考察的是链表操作的基本功，那么这道题算是一道比较好的考察题。

```java
/*
public class ListNode {
    int val;
    ListNode next = null;

    ListNode(int val) {
        this.val = val;
    }
}*/
public class Solution {
    public ListNode ReverseList(ListNode head) {
        if(head==null || head.next==null){
            return head;
        }
        TowNode twoNode = new TowNode();
        twoNode.node1 = head;
        twoNode.node2 = head.next;
        ListNode node = recurse(twoNode);
        head.next = null;
        return node;
    }

    private ListNode recurse(TowNode nodes){
        if(nodes.node2==null){
            return nodes.node1;
        }
        TowNode twoNode = new TowNode();
        twoNode.node1 = nodes.node2;
        twoNode.node2 = nodes.node2.next;
        nodes.node2.next = nodes.node1;
        return recurse(twoNode);
    }
}

class TowNode{
    ListNode node1;
    ListNode node2;
}
```

操作的步骤如下：
使用两个相邻的指针，后面那个将会指向前面那个，但在此之前，新建两个指针，保留下一步该种操作的两个指针。递归解决。

测试用例：
1. 输入的链表为空
2. 输入的链表只有一个结点
3. 输入的链表有多个结点

```java
public ListNode ReverseList(ListNode head) {
    if(head==null || head.next==null){
        return head;
    }
    ListNode preNode = null;
    ListNode node = head;
    ListNode nextNode = head.next;
    while(nextNode!=null){
        node.next = preNode;
        preNode = node;
        node = nextNode;
        nextNode = nextNode.next;
    }
    node.next=preNode;
    return node;
}
```

用循环实现的这个代码中，用的是三个指针，循环最后还得搭上一句`node.next=preNode;`。

完整的测试环境：[Algorithm]