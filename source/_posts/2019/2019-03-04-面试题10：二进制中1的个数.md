---
title: 面试题10：二进制中1的个数
categories: [读书笔记, 《剑指offer》]
comments: true
---

## 题目

请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。例如把9表示成二进制是1001，有2位是1。因此如果输入9，该函数输出2。

<!--more-->

## 解答

这道题看起来很简单，但可能会写出一个死循环程序，因为负数的右移是带符号的。

输入负数会死循环的程序：

```java
public int NumberOf1(int n) {
    int count=0;
    while(n!=0){
        if((n&1)==1){
            count++;
        }
        n>>=1;
    }
    return count;
}
```

因此，我们可以不移动数字本身，而移动mask。

```java
public int NumberOf1(int n) {
        int count=0;
        int mask = 1;
        for(int i=0;i<32;i++){
            if((n&mask)!=0){
                count++;
            }
            mask<<=1;
        }
        return count;
    }
```

其实这个题存在一种非常巧妙的解法。一个数的二进制减一，再与上自身，会让其最后一个1消失。分析如下：

如果最后一位是1，那么减一之后，其他位都不变，拿1001001来举例子，减一变为：1001000，这个结果再与上自身，由于只有最后一位变了，所以其他位与操作之后都不变，最后一位变为0。

如果最后一位是0，那么减一之后，就会向前借位，最右边的一个1将变为0，其后的所有0则变为1。这个结果再与上自身，从最右边的1开始都将变为0。拿1001000来举例子，减一之后变为1000111，与上1001000，变为1000000。

```java
public int NumberOf1(int n) {
    int count=0;
    while (n!=0){
        if((n&1)==1){
            count++;
        }
        n=n&(n-1);
    }
    return count;
}
```

这个解法比移动mask那个解法更优，移动mask需要循环32次，而这个解法的次数取决于二进制中1的个数。