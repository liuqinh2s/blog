---
title: 面试题6：重建二叉树
categories: [读书笔记, 《剑指offer》]
comments: true
---

## 题目

输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列`{1,2,4,7,3,5,6,8}`和中序遍历序列`{4,7,2,1,5,3,8,6}`，则重建出图2.6所示的二叉树并输出它的头结点。二叉树定义如下：

```java
class TreeNode {
    int val;
    TreeNode left;
    TreeNode right;

    TreeNode(int x) {
        val = x;
    }
}
```

<!--more-->

## 解答

- 前序遍历的特点是：第一个结点是父节点，其后是左右子树
- 中序遍历的特点是：中间会有一个结点是父节点，其左右分别是左右子树
- 后续遍历的特点是：最后一个结点是父节点，其前面是左右子树

显然，用前序遍历和中序遍历，或者中序遍历和后序遍历，都可以重构二叉树，但用前序遍历和后序遍历不行，因为无法确定出左右子树（划不出边界）。

```java
public class Solution {
    public TreeNode reConstructBinaryTree(int [] pre,int [] in) {
        if(pre==null || pre.length<=0 || in==null || in.length<=0){
            return null;
        }
        return recurse(pre, 0, pre.length-1, in, 0, in.length-1);
    }
    
    private TreeNode recurse(int[] pre, int preBegin, int preEnd, int[] in, int inBegin, int inEnd){
        if(preBegin>preEnd || inBegin>inEnd){
            return null;
        }
        TreeNode root = new TreeNode(pre[preBegin]);
        int i=inBegin;
        for(;i<=inEnd;i++){
            if(in[i]==root.val){
                break;
            }
        }
        root.left = recurse(pre, preBegin+1, preBegin+i-inBegin, in, inBegin, i-1);
        root.right = recurse(pre, preBegin+i-inBegin+1, preEnd, in, i+1, inEnd);
        return root;
    }
}
```

这个OJ一遍就过了，没有犯任何小错误，还是挺开心的。