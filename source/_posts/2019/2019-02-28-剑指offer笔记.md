---
title: 剑指offer笔记
categories: [读书笔记, 《剑指offer》]
comments: true
---

## 二维数组的二分查找

### 题目描述

给定一个二维数组，每一行都是递增的，每一列也都是递增的，且每个数都唯一。然后给一个数，在这个二维数组中查找这个数，如果找到，返回坐标，如果没找到返回`(-1,-1)`。

举个例子：

```
1 2 6
4 5 9
7 8 10
```

今天面试字节跳动公司，问的第一题就是这一道，而这道题其实可以追溯到《剑指offer》中的面试题3。所以面试大公司的话最好先刷完这三本书，算法是绕不过去的一关：

- 《剑指offer》，国内特别喜欢出这个上面的题
- 《编程之美》，微软出的
- 《程序员面试经典》，主要是面向北美和欧洲的程序员

好钢要用在刀刃上，像leetcode这种可以先不刷，以上三本书的覆盖率已经可以完全应对面试了。

言归正传，回到这道题，最简单的做法是暴力法遍历每一个元素，时间复杂度是`O(m*n)`。

然后其实很容易想到二分法，但这是一个二维数组，要稍作一些变化。面试官一开始就提出了最优的时间复杂度：`O(log(m*n))`。如何做到呢？

灵光一闪：平面划分，如果找中间那个数，那么会将这个矩阵划分成多少份呢？第一个感觉是四份，但我们仔细分析一下：

1. 左上角这一块，一定是小于中间这个数的，右下角这一块一定是大于这个中间数的。
2. 右上角这一块呢？很遗憾，可能大于中间这个数，也可能小于中间这个数，左下角也一样。

当我们要查的这个数大于中间这个数，我们就可以肯定它不在左上角，但剩余了三个区间。当我们要查的这个数小于中间这个数，我们就可以肯定它不在右下角，但同样也剩下三个区间可能存在这个数。那么接下来该怎么办？答案是：递归解决。

那么时间复杂度是多少？怎么算？答案是：$O(3^{\log_4(m*n)})$

在每次递归中，我们将矩阵划分成四份，并对其中三份进行递归，简单的画一个树杈图，就能看出至少是3的次方级别，而是多少次方取决于树的深度，而深度就是四分的深度：$\log_4(m*n)$

如此来看，这个算法似乎并不怎么好。

网上的常见解法：

1. 对每行做二分查找，然后列顺序遍历；或者对每列做二分查找，然后顺序遍历行。时间复杂度是：$O(m\log n)$或$O(n\log m)$
2. 从右上角开始，如果当前这个数大于我们要查的数，那么我们就可以肯定当前这个数下面的数（列）都大于我们要查的数，于是我们抛弃这一列。反过来如果当前数小于我们要查的数，那么可以肯定当前数前面的数（行）都小于我们要查的数，于是我们抛弃这一行。这样每次都会行进一步，或者列进一步，逐步逼近最后的答案。那么时间复杂度是多少呢？在最坏情况下，这个要查的数可能出现在左下角。那么我们向左和向下都前进了尽可能多的步，时间复杂度是：O(m+n)。

第一个思路的代码如下：

```java
private int[] getPosition2(int[][] A, int value){
    for(int i=0;i<A.length;i++){
        int begin = 0;
        int end = A[i].length-1;
        while(begin<=end){
            int mid = (begin+end)/2;
            if(value==A[i][mid]){
                return new int[]{i, mid};
            }else if(value<A[i][mid]){
                end = mid-1;
            }else{
                begin = mid+1;
            }
        }
    }
    return new int[]{-1, -1};
}
```

第二个思路的代码如下：

```java
public class Solution {
    
    private int[] getPosition(int[][] A, int value) {
        int xIndex = 0;
        int yIndex = A[xIndex].length-1;
        while (xIndex < A.length && yIndex >= 0) {
            if (A[xIndex][yIndex] == value) {
                return new int[]{xIndex, yIndex};
            } else if (A[xIndex][yIndex] < value) {
                xIndex++;
            } else {
                yIndex--;
            }
        }
        return new int[]{-1, -1};
    }

    public static void main(String[] args) {
        int[][] A = {{1, 2, 6},{4, 5, 9},{7,8,10}};
        Solution solution = new Solution();
        int[] result = solution.getPosition(A, 7);
        for(int i=0;i<result.length;i++){
            System.out.println(result[i]);
        }
    }
}
```

我觉得并不能找到$O(\log(m*n))$，因为考虑添加这样一个条件：每一行都比上一行大。那么实际上二维数组就已经可以退化为一维的有序数组了，而在这种情况下就能达到：$O(\log(m*n))$。而反过来，我认为没有这个条件的情况下，就应该是达不到$O(\log(m*n))$的。

## C++

### 数组

数组和指针的区别：

```c++
int GetSize(int data[]){
    return sizeof(data);
}

int _tmain(int argc, _TCHAR* argv[]){
    int data1[] = {1, 2, 3, 4, 5};
    int size1 = sizeof(data1);

    int* data2 = data1;
    int size2 = sizeof(data2);

    int size3 = GetSize(data1);

    printf("%d, %d, %d\n", size1, size2, size3);
}
```

答案是输出：20, 4, 4

sizeof是个关键字而不是函数，sizeof(data1)是求数组的大小，这里有5个int型元素，所以总共20个字节，data2声明为指针，尽管指向了一个数组，但本质上只是一个指针，所以sizeof(data2)的语义范围收缩了，无法仅通过一个指针得知其所指范围。在32位系统上一个指针是4字节，所以结果就是4。在C/C++中，当数组作为函数的参数进行传递时，数组就自动退化为同类型的指针，因此size3的结果也是4。

### 字符串

字符串由char数组实现，字符串以`\0`结尾，这可以方便我们找到字符串的结尾。

```c++
char str[11];
strcpy(str, "0123456789\0");
```

为了节省内存，C/C++把常量字符串放到常量池中，当几个指针被赋值了相同的字符串常量时，实际上它们会指向相同的内存地址。但用常量字符串初始化数组，情况却不同。

```c++
int _tmain(int argc, _TCHAR* argv[]){
    char str1[] = "hello world";
    char str2[] = "hello world";

    char* str3 = "hello world";
    char* str4 = "hello world";

    if(str1==str2){
        printf("str1 and str2 are same.\n");
    }else{
        printf("str1 and str2 are not same.\n");
    }

    if(str3==str4){
        printf("str3 and str4 are same.\n");
    }else{
        printf("str3 and str4 are not same.\n");
    }
    return 0;
}
```

输出：
str1 and str2 are not same.
str3 and str4 are same.

常量池虽然好用，但这样会造成一个问题，就是我们拿其中一个指针改了字符串内容，就会造成另一个指针指向的字符串也变了。为此像C#和Java等语言都将字符串类型设为不可变对象，改变字符串实际上是新建了一个字符串，这样就不会引起冲突了。但如果需要不停的改变就要不停的新建，这样就太影响效率，所以又提供了`StringBuilder`类，这个类是支持在原字符串上改动的。

#### 面试题4：替换空格

题目：请实现一个函数，把字符串中的每个空格替换成“%20”。例如输入“We are happy.”，则输出“We%20are%20happy.”。

>在网络编程中，如果URL参数中含有特殊字符，如空格、'#'等，可能导致服务器端无法获得正确的参数值。我们需要将这些字符转换为服务器可以识别的字符。转换规则是在'%'后面跟上ASCII码的两位十六进制表示。

这一题我觉得完全没必要去想到$O(n^2)$那个算法，直接就可以想到$O(n)$的解法，而且也没必要像书中说的那样从后往前替换。我们只需要能得到一个足够大的新内存空间，然后把原来的字符串移动过去，在移动的同时注意替换空格就行了。

```java
public class Solution {

    private String replace(String text1, String text2){
        if(text1==null || text1.length()==0 || text2==null){
            return "";
        }
        StringBuilder text = new StringBuilder();
        for(int i=0;i<text1.length();i++){
            if(text1.charAt(i)==' '){
                text.append(text2);
            }else{
                text.append(text1.charAt(i));
            }
        }
        return text.toString();
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        String text1 = "We are happy.";
        String text2 = "%20";
        text1 = solution.replace(text1, text2);
        System.out.println(text1);
    }
}
```

为了更深入问题的本质，或许我们应该用字符数组来模拟这个操作过程。

```java
public class Solution {

    private String replace(char[] text1, char[] text2){
        if(text1==null || text1.length==0 || text2==null){
            return "";
        }
        int countSpace = 0;
        for(int i=0;i<text1.length;i++){
            if(text1[i]==' '){
                countSpace++;
            }
        }
        int newLength = text1.length+countSpace*2;
        char[] temp = new char[newLength];
        int index = 0;
        for(int i=0;i<text1.length;i++){
            if(text1[i]==' '){
                temp[index++] = '%';
                temp[index++] = '2';
                temp[index++] = '0';
            }else{
                temp[index++] = text1[i];
            }
        }
        return new String(temp);
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        String str = " We are happy. ";
        char[] text1 = str.toCharArray();
        str = "%20";
        char[] text2 = str.toCharArray();
        str = solution.replace(text1, text2);
        System.out.println(str);
    }
}
```

如果不能新建空间呢？请看下题：

有两个升序的数组A1和A2，内存在A1末尾有足够多余的空间容纳A2，请实现一个函数，把A2中所有元素插入到A1中，并且所有的元素都是升序。

```
```

### 值传递和引用传递

Java没有引用传递，本质上都是值传递，只不过如果传递的值可以是指针（Java没有指针，所以你也可以理解为对象，其实本质上还是指针）。

```java
public class Solution {

    private void getString(String text){
        text = "hello";
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        String text = "world";
        solution.getString(text);
        System.out.println(text);
    }
}
```

text本质上是一个指针，而getString中的text则是另一个指针（一个局部变量），所以这里实际上有两个不同的text，而我们实际上改变的就是一个局部变量。所以输出结果是：world。

如果深入了解了C语言程序栈的构造，就能彻底明白函数调用的细节。

值传递和引用传递是每个刚开始写代码的程序员的必经之路，比如经典的swap函数交换，就是一个大坑：

```java
public class Solution {

    private void swap(String text1, String text2){
        String temp = text1;
        text1 = text2;
        text2 = temp;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        String text1 = "world";
        String text2 = "hello";
        solution.swap(text1, text2);
        System.out.println(text1+" "+text2);
    }
}
```

输出是：world hello

实际上我觉得这应该算得上是编程语言底层设计影响到上层使用的一个例子，不是那么自然，比较容易让人困惑。可以算作是一种封装的失败吧。补救方法在C中是使用指针，C++中是使用引用，Java中是使用数组或者对象包装一层。