---
title: 当我们在做算法题时，我们在做什么
categories: [教案]
comments: true
---

## 754. Reach a Number

[题目地址](https://leetcode.com/problems/reach-a-number/)

You are standing at position `0` on an infinite number line. There is a goal at position `target`.

On each move, you can either go left or right. During the n-th move (starting from 1), you take n steps.

Return the minimum number of steps required to reach the destination.

<!-- more -->

**Example 1:**

```
Input: target = 3
Output: 2
Explanation:
On the first move we step from 0 to 1.
On the second step we step from 1 to 3.
```

**Example 2:**

```
Input: target = 2
Output: 3
Explanation:
On the first move we step from 0 to 1.
On the second move we step  from 1 to -1.
On the third move we step from -1 to 2.
```

**Note:**

- `target` will be a non-zero integer in the range `[-10^9, 10^9]`.

这道题是一道数论题。

$target = \sum_{i=1}^k \pm i$

这里的问题在于加减号未知，而且希望得到最小的k。

由于我们要用最少的步数到达目标，我们隐约感觉到加号应该尽可能的多，减号只在必要的时候添加。那么基于这个直觉，我们构建一个这样的式子：

$S = 1+2+\cdots+k=target+d \quad (0<=d<=k)$，d是S与target的差值。

接下来我们要尝试反转左边的一个符号，从而令d恰好消除。达到形如：

$1+2+\cdots-i+k=target$，显然 **d=2i**，如果d是偶数的话，那么我们很快就知道只要在第 $\frac{d}{2}$ 步时往反向走就行了。

如果d是奇数的话，我们不能直接这样凑出来。

>有个规律：每次我们反转一步i，S实际上都减少了2i。S与target的差值d也减少2i，所以无论我们怎么反转i，也不可能凑出奇数的d来。只能选择多走一步。

$1+2+\cdots-i+k+ (k+1) = target$，d=2i-(k+1)，因为d是奇数，所以这时候要求k必须是偶数。

如果碰巧我们的k不是偶数呢？只能再多加一步：

$1+2+\cdots-i+k - (k+1) + (k+2) = target$，d=2i+(k+1)-(k+2) => d=2i-1，不管k是奇数还是偶数，d都是奇数。但我们要谨记k要取最小，所以能用k+1解决的，绝不用k+2解决（即便k+2是d为奇数时候的通解）。

>当然也可以是+(k+1)-(k-2)，得到 d=2i+1

所以最终这道题用三个式子就可以概括了：

- if d%2==0（也就是说d是偶数）： $1+2+\cdots-i+k = target \quad i=\frac{d}{2}$
- if d%2==1（也就是说d是奇数）： 
	- if k%2==0：$1+2+\cdots-i+k+ (k+1) = target \quad i=\frac{d+(k+1)}{2}$
	- if k%2==1：$1+2+\cdots-i+k- (k+1) + (k+2) = target \quad i=\frac{d+1}{2}$

而这道题并不是让我们求整个序列，只需要求k。

第一个令 $\frac{k\times (k+1)}{2}>target$的k，用二次根的求根公式可以求出k，向上取整，然后算出d，这就是O(1)的复杂度了。

$k = \frac{-b \pm \sqrt{b^2-4ac}}{2a}$

$$
k = \frac{-1 + \sqrt{1+8\times target}}{2}
$$

```java
class Solution {
    public int reachNumber(int target) {
        int k = (int)Math.ceil((Math.sqrt(1+8.0*Math.abs(target))-1)/2);
        int d = k*(k+1)/2-Math.abs(target);
        if(d%2==0){
            return k;
        }else{
            return k%2==0?k+1:k+2;
        }
    }
}
```

做算法题的时候，很多时候会有一种困惑，做完一道题似乎只是会做了而已，学了一个很具体的套路而已，过一段时间再做又会忘记怎么做，那这样还有什么意义呢？

这道题中我学会了什么，扪心自问，似乎什么都没学会。小学奥数最大的毛病就在于此，什么鸡兔同笼，二元一次方程才是真正通用的方法，然而中国的数学始终没有建立起符号体系，所以鸡兔同笼永远是一个技术难题。如果只是做会了一个一个具体的题目，而没有领悟更通用的思维方式，做多少也是徒劳。

在冥思苦想很久之后，我发现了这题唯一的收获，我们的目标是两个：

1. 一个是要令这个步数序列之和等于target
2. 步数尽可能的少

我发现我在思考这个问题的时候，首先思考的其实是第一条，我专注于等于target，而这将导致我完全没有思路。而正确的打开方式应该是从步数尽可能少入手，先构造一个只有加的序列（哪怕它是个不等式），让序列之和刚好大于target，再做调整让其等于target。就是这一思维上的区别，将导致完全不同的结果。