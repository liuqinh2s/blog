---
title: 斐波那契数列
categories: [算法]
comments: true
---

斐波那契数列的计算非常有意思，因为算法的时间复杂度可以连续优化，最优达到`O(logN)`。

最简单的是递归计算，时间复杂度是：$O(2^n)$

然后是迭代（也就是循环）计算，时间复杂度是：$O(n)$

另外递归+备忘录也可以做到线性的时间复杂度。

这两个都非常常见，代码如下：

```java
public class Solution {

    private int fibonacci(int A){
        if(A<=1){
            return 1;
        }
        return fibonacci(A-1)+fibonacci(A-2);
    }

    private int fibonacci2(int A){
        int a = 1;
        int b = 1;
        int result = 1;
        for(int i=1;i<A;i++){
            result = a+b;
            a = b;
            b = result;
        }
        return result;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        for (int i=0;i<11;i++){
            System.out.println(solution.fibonacci2(i));
        }
    }
}
```

其实还存在一种利用矩阵的解法，然算法复杂度缩减到对数。
$$
\begin{bmatrix}
    f(n)  \\
    f(n-1) \\
\end{bmatrix}
=
\begin{bmatrix}
    1 1 \\
    1 0 \\
\end{bmatrix}
\begin{bmatrix}
    f(n-1) \\
    f(n-2) \\
\end{bmatrix}
$$
可以看到，这个式子里面蕴含了递归（右边的斐波那契数列可以再用这个式子展开）。

那么一直展开到`f(1)=1, f(0)=1`：
$$
\begin{bmatrix}
    f(n)  \\
    f(n-1) \\
\end{bmatrix}
=
\begin{bmatrix}
    1 1 \\
    1 0 \\
\end{bmatrix}^{n-1}
\begin{bmatrix}
    1 \\
    1 \\
\end{bmatrix}
$$
看到这里，最关键的点要来了。**矩阵乘法的结合性**

对，利用的就是矩阵乘法的结合性，如果我们已知n规模的矩阵，那么算2*n规模的矩阵，只需要将两个相同的n规模的矩阵相乘。而不需要重复计算n规模矩阵！效率大大提高。那么自然可知，计算n规模的矩阵其复杂度只有：$O(\log(n))$。

```java
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class Solution {

    Map<Integer, int[][]> fibonacci = new HashMap<>();

    private int fibonacci3(int A){
        int[][] matrix = {{1,1},{1,0}};
        int[][] tempMatrix = {{1,0},{0,1}};
        int count = 1;
        while(A>0){
            if(A%2==1){
                tempMatrix = multiply2Matrix(tempMatrix, multiplyMatrix(matrix, count));
            }
            A /= 2;
            count++;
        }
        return tempMatrix[0][0];
    }

    private int[][] multiplyMatrix(int[][] matrix, int A){
        if(fibonacci.get(A)!=null){
            return fibonacci.get(A);
        }
        int[][] newMatrix = new int[2][2];
        for(int i=1;i<A;i++){
            newMatrix[0][0] = matrix[0][0]*matrix[0][0]+matrix[0][1]*matrix[1][0];
            newMatrix[0][1] = matrix[0][0]*matrix[0][1]+matrix[0][1]*matrix[1][1];
            newMatrix[1][0] = matrix[1][0]*matrix[0][0]+matrix[1][1]*matrix[1][0];
            newMatrix[1][1] = matrix[1][0]*matrix[0][1]+matrix[1][1]*matrix[1][1];
            int[][] temp = newMatrix;
            newMatrix = matrix;
            matrix = temp;
        }
        fibonacci.put(A, matrix);
        return matrix;
    }

    private int[][] multiply2Matrix(int[][] matrix1, int[][] matrix2){
        int[][] newMatrix = new int[2][2];
        newMatrix[0][0] = matrix1[0][0]*matrix2[0][0]+matrix1[0][1]*matrix2[1][0];
        newMatrix[0][1] = matrix1[0][0]*matrix2[0][1]+matrix1[0][1]*matrix2[1][1];
        newMatrix[1][0] = matrix1[1][0]*matrix2[0][0]+matrix1[1][1]*matrix2[1][0];
        newMatrix[1][1] = matrix1[1][0]*matrix2[0][1]+matrix1[1][1]*matrix2[1][1];
        return newMatrix;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        for (int i=0;i<11;i++){
            System.out.println(solution.fibonacci3(i));
        }
    }
}
```

这里为了完美的体现性能，我将已经算得的2的次方规模的矩阵存储起来，避免重复计算。

以上是迭代的解法，通过先计算出2的次方规模的矩阵，然后再将这些2的次方规模的矩阵乘起来得到最终的结果。算法复杂度算起来不是那么直观。先分析最大的那个2的次方规模的矩阵，复杂度是O(logN)，然后由于使用了备忘录记录中间结果，小规模的2的次方规模的矩阵实际上是不需要计算，可以直接返回的。最后就是累乘这些2的次方规模的矩阵，主要看这些矩阵有多少个，很容易得知最多logN个。所以最终复杂度应该是：logN+logN，也就是：$O(\log(n))$

下面给出一个递归+备忘录模式的代码：

```
import java.util.HashMap;
import java.util.Map;

public class Solution {

    Map<Integer, int[][]> fibonacci = new HashMap<>();

    private int fibonacci4(int A){
        int[][] matrix = multiplyMatrix1(A);
        return matrix[0][0];
    }

    private int[][] multiplyMatrix1(int A){
        if(A<=1){
            return new int[][]{{1,1},{1,0}};
        }
        if(fibonacci.get(A)!=null){
            return fibonacci.get(A);
        }
        int half = A/2;
        int[][] matrix1 = multiplyMatrix1(half);
        int[][] matrix2 = multiplyMatrix1(A-half);
        int[][] newMatrix = new int[2][2];
        newMatrix[0][0] = matrix1[0][0]*matrix2[0][0]+matrix1[0][1]*matrix2[1][0];
        newMatrix[0][1] = matrix1[0][0]*matrix2[0][1]+matrix1[0][1]*matrix2[1][1];
        newMatrix[1][0] = matrix1[1][0]*matrix2[0][0]+matrix1[1][1]*matrix2[1][0];
        newMatrix[1][1] = matrix1[1][0]*matrix2[0][1]+matrix1[1][1]*matrix2[1][1];
        fibonacci.put(A, newMatrix);
        return newMatrix;
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        for (int i=0;i<15;i++){
            System.out.println(solution.fibonacci4(i));
        }
    }
}
```

这个写法就很容易看出来，经典的递归分治，树杈图的深度是$\log_2 n$，且因为使用备忘录而不用重复计算，所以算法复杂度就是树的深度：$O(\log(n))$

斐波那契数列数列的常见应用：
- 青蛙跳台阶，每次跳1或者2阶，问跳上n个台阶有多少种跳法？这种问题适合倒过来分析，也就是递归。在青蛙抵达终点时，它有可能是从第n-1个台阶跳上来的，也有可能是从第n-2个台阶跳上来的。那么实际上就是：$f(n) = f(n-1)+f(n-2)$，其中f函数是跳法数随规模变化的函数，比如`f(n)`就是跳到第n个台阶的跳法数，`f(n-1)`就是跳到第n-1个台阶的跳法数。如果正向思考的话就很难发现它是一个斐波那契数列了。