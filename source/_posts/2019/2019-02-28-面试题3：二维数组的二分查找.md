---
title: 面试题3：二维数组的二分查找
categories: [读书笔记, 《剑指offer》]
comments: true
---

## 题目

给定一个二维数组，每一行都是递增的，每一列也都是递增的，且每个数都唯一。然后给一个数，在这个二维数组中查找这个数，如果找到，返回坐标，如果没找到返回`(-1,-1)`。

举个例子：

```
1 2 6
4 5 9
7 8 10
```

<!--more-->

## 解答

最简单的做法是暴力法遍历每一个元素，时间复杂度是`O(m*n)`。

然后其实很容易想到二分法，但这是一个二维数组，要稍作一些变化。面试官一开始就提出了最优的时间复杂度：`O(log(m*n))`。如何做到呢？

灵光一闪：平面划分，如果找中间那个数，那么会将这个矩阵划分成多少份呢？第一个感觉是四份，但我们仔细分析一下：

1. 左上角这一块，一定是小于中间这个数的，右下角这一块一定是大于这个中间数的。
2. 右上角这一块呢？很遗憾，可能大于中间这个数，也可能小于中间这个数，左下角也一样。

当我们要查的这个数大于中间这个数，我们就可以肯定它不在左上角，但剩余了三个区间。当我们要查的这个数小于中间这个数，我们就可以肯定它不在右下角，但同样也剩下三个区间可能存在这个数。那么接下来该怎么办？答案是：递归解决。

那么时间复杂度是多少？怎么算？答案是：$O(3^{\log_4(m*n)})$

在每次递归中，我们将矩阵划分成四份，并对其中三份进行递归，简单的画一个树杈图，就能看出至少是3的次方级别，而是多少次方取决于树的深度，而深度就是四分的深度：$\log_4(m*n)$

如此来看，这个算法似乎并不怎么好。

网上的常见解法：

1. 对每行做二分查找，然后列顺序遍历；或者对每列做二分查找，然后顺序遍历行。时间复杂度是：$O(m\log n)$或$O(n\log m)$
2. 从右上角开始，如果当前这个数大于我们要查的数，那么我们就可以肯定当前这个数下面的数（列）都大于我们要查的数，于是我们抛弃这一列。反过来如果当前数小于我们要查的数，那么可以肯定当前数前面的数（行）都小于我们要查的数，于是我们抛弃这一行。这样每次都会行进一步，或者列进一步，逐步逼近最后的答案。那么时间复杂度是多少呢？在最坏情况下，这个要查的数可能出现在左下角。那么我们向左和向下都前进了尽可能多的步，时间复杂度是：O(m+n)。

第一个思路的代码如下：

```java
private int[] getPosition2(int[][] A, int value){
    for(int i=0;i<A.length;i++){
        int begin = 0;
        int end = A[i].length-1;
        while(begin<=end){
            int mid = (begin+end)/2;
            if(value==A[i][mid]){
                return new int[]{i, mid};
            }else if(value<A[i][mid]){
                end = mid-1;
            }else{
                begin = mid+1;
            }
        }
    }
    return new int[]{-1, -1};
}
```

第二个思路的代码如下：

```java
public class Solution {
    
    private int[] getPosition(int[][] A, int value) {
        int xIndex = 0;
        int yIndex = A[xIndex].length-1;
        while (xIndex < A.length && yIndex >= 0) {
            if (A[xIndex][yIndex] == value) {
                return new int[]{xIndex, yIndex};
            } else if (A[xIndex][yIndex] < value) {
                xIndex++;
            } else {
                yIndex--;
            }
        }
        return new int[]{-1, -1};
    }

    public static void main(String[] args) {
        int[][] A = {{1, 2, 6},{4, 5, 9},{7,8,10}};
        Solution solution = new Solution();
        int[] result = solution.getPosition(A, 7);
        for(int i=0;i<result.length;i++){
            System.out.println(result[i]);
        }
    }
}
```

我觉得并不能找到$O(\log(m*n))$，因为考虑添加这样一个条件：每一行都比上一行大。那么实际上二维数组就已经可以退化为一维的有序数组了，而在这种情况下就能达到：$O(\log(m*n))$。而反过来，我认为没有这个条件的情况下，就应该是达不到$O(\log(m*n))$的。