---
title: 面试题4：替换空格
categories: [读书笔记, 《剑指offer》]
comments: true
---

## 题目

请实现一个函数，把字符串中的每个空格替换成“%20”。例如输入“We are happy.”，则输出“We%20are%20happy.”。

>在网络编程中，如果URL参数中含有特殊字符，如空格、'#'等，可能导致服务器端无法获得正确的参数值。我们需要将这些字符转换为服务器可以识别的字符。转换规则是在'%'后面跟上ASCII码的两位十六进制表示。

<!--more-->

## 解答

这一题我觉得完全没必要去想到$O(n^2)$那个算法，直接就可以想到$O(n)$的解法，而且也没必要像书中说的那样从后往前替换。我们只需要能得到一个足够大的新内存空间，然后把原来的字符串移动过去，在移动的同时注意替换空格就行了。

```java
public class Solution {

    private String replace(String text1, String text2){
        if(text1==null || text1.length()==0 || text2==null){
            return "";
        }
        StringBuilder text = new StringBuilder();
        for(int i=0;i<text1.length();i++){
            if(text1.charAt(i)==' '){
                text.append(text2);
            }else{
                text.append(text1.charAt(i));
            }
        }
        return text.toString();
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        String text1 = "We are happy.";
        String text2 = "%20";
        text1 = solution.replace(text1, text2);
        System.out.println(text1);
    }
}
```

为了更深入问题的本质，或许我们应该用字符数组来模拟这个操作过程。

```java
public class Solution {

    private String replace(char[] text1, char[] text2){
        if(text1==null || text1.length==0 || text2==null){
            return "";
        }
        int countSpace = 0;
        for(int i=0;i<text1.length;i++){
            if(text1[i]==' '){
                countSpace++;
            }
        }
        int newLength = text1.length+countSpace*2;
        char[] temp = new char[newLength];
        int index = 0;
        for(int i=0;i<text1.length;i++){
            if(text1[i]==' '){
                temp[index++] = '%';
                temp[index++] = '2';
                temp[index++] = '0';
            }else{
                temp[index++] = text1[i];
            }
        }
        return new String(temp);
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        String str = " We are happy. ";
        char[] text1 = str.toCharArray();
        str = "%20";
        char[] text2 = str.toCharArray();
        str = solution.replace(text1, text2);
        System.out.println(str);
    }
}
```

如果不能新建空间呢？请看下题：

有两个升序的数组A1和A2，内存在A1末尾有足够多余的空间容纳A2，请实现一个函数，把A2中所有元素插入到A1中，并且所有的元素都是升序。

这个时候就要避免因为插入一个元素而需要移动其后的所有元素。所以我们不采用插入排序的插入操作，而是采用归并排序里的合并操作：从后往前依次比较，将较大的放到A数组最后，这样就可以保证每个元素最多只移动一次。

```java
public class Solution {

    private void merge(int[] A1, int length, int[] A2){
        int index = A1.length-1;
        int index1 = length-1;
        int index2 = A2.length-1;
        while(index1>=0 && index2>=0){
            if(A1[index1]>A2[index2]){
                A1[index--] = A1[index1--];
            }else{
                A1[index--] = A2[index2--];
            }
        }
        while(index2>=0){
            A1[index--] = A2[index2--];
        }
    }

    public static void main(String[] args) {
        Solution solution = new Solution();
        int[] A1 = new int[10];
        A1[0] = 1;
        A1[1] = 3;
        A1[2] = 5;
        A1[3] = 9;
        A1[4] = 10;
        int[] A2 = {2, 4, 6, 7, 8};
        solution.merge(A1, 5, A2);
        for(int i=0;i<A1.length;i++){
            System.out.println(A1[i]);
        }
    }
}
```