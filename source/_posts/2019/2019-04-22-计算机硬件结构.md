---
title: 计算机硬件结构
categories: [从零开始学习计算机]
comments: true
---

## [图灵机](https://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E6%9C%BA)

图灵机（Turing Machine）是 [英国数学家艾伦·图灵](https://zh.wikipedia.org/wiki/%E8%89%BE%E4%BC%A6%C2%B7%E5%9B%BE%E7%81%B5) 在1936年发表的 "[On Computable Numbers, with an Application to the Entscheidungsproblem](https://www.cs.virginia.edu/~robins/Turing_Paper_1936.pdf)"（《论可计算数及其在判定性问题上的应用》）中提出的数学模型。在文章中图灵描述了它是什么，并且证明了，只要图灵机可以被实现，就可以用来解决任何可计算问题。

### 历史

- [妈咪说：图灵](https://www.bilibili.com/video/av30479683?from=search&seid=11735601712045998475)
- [模仿游戏](https://movie.douban.com/subject/10463953/)

### 图灵机的基本思想

图灵机是一种 **抽象计算模型**，图灵机的构成：

- 一条无限长的纸带，纸带由很多个格子构成，用于输入输出信息。每个格子中包含一个来自有限字母表的符号，字母表中有一个特殊符号表示空白。纸带上一端的格子从0开始编号，另一端无限延伸一直到无穷大。
- 一个读写头，用于读写纸带
- 一个状态寄存器，用于保存机器状态。图灵机的状态个数有限，并且有一个特殊的状态：停机状态
- 一套控制规则，根据当前机器状态和纸带内容来确定下一步的动作：
	- 写入或擦除当前格子内容
	- 移动读写头，向左、向右、或不动
	- 保持当前状态或转移到另一状态

### 图灵机的正式定义

a (one-tape) Turing machine can be formally defined as a **7-tuple** $M=\langle Q,\Gamma ,b,\Sigma ,\delta ,q_{0},F\rangle $   where

- $Q$ is a finite, non-empty set of **states**;
- $\Gamma$  is a finite, non-empty set of **tape alphabet symbols**;
- $b\in \Gamma$  is the **blank symbol** (the only symbol allowed to occur on the tape infinitely often at any step during the computation);
- $\Sigma \subseteq \Gamma \setminus \{b\}$ is the set of **input symbols**, that is, the set of symbols allowed to appear in the initial tape contents;
- $q_{0}\in Q$ is the **initial state**;
- $F\subseteq Q$ is the set of **final states or accepting states**. The initial tape contents is said to be accepted by $M$ if it eventually halts in a state from $F$.
- $\delta :(Q\setminus F)\times \Gamma \not \to Q\times \Gamma \times \\{L,R\\}$ is a partial function called the **transition function**, where L is left shift, R is right shift. (A relatively uncommon variant allows "no shift", say N, as a third element of the latter set.) If $\delta$ is not defined on the current state and the current tape symbol, then the machine **halts**;

### 图灵机的实践

- [Brainfuck](https://zh.wikipedia.org/wiki/Brainfuck)

### 图灵完备

只要能模拟单带图灵机，就是图灵完备的。这也意味着其计算能力与通用图灵机等同。

不是图灵完备的的常见情况有；
1. 递归或循环有限，无法写不终止的程序，如`while(true){}`
2. 无法实现类似数组或列表这样的数据结构（不能模拟纸带）

图灵完备也有可能带来坏处，不图灵完备也不是完全没用，比如：有些场景我们需要限制语言的表达能力，如 限制无限循环和递归，保证我们的程序一定是可终止的。

### [停机问题](https://zh.wikipedia.org/wiki/%E5%81%9C%E6%9C%BA%E9%97%AE%E9%A2%98)

停机问题（英语：halting problem）是逻辑数学中可计算性理论的一个问题。通俗地说，停机问题就是判断任意一个程序是否能在有限的时间之内结束运行的问题。该问题等价于如下的判定问题：是否存在一个程序P，对于任意输入的程序w，能够判断w会在有限时间内 **结束或者死循环**。

艾伦·图灵在1936年用 [对角论证法](https://zh.wikipedia.org/wiki/%E5%B0%8D%E8%A7%92%E8%AB%96%E8%AD%89%E6%B3%95) 证明了，不存在解决停机问题的通用算法。

>停机问题包含了 [自我指涉](https://zh.wikipedia.org/wiki/%E8%87%AA%E6%8C%87)，本质是 [一阶逻辑](https://zh.wikipedia.org/wiki/%E4%B8%80%E9%98%B6%E9%80%BB%E8%BE%91) 的不完备性，类似的命题有 [理发师悖论](https://zh.wikipedia.org/wiki/%E7%90%86%E5%8F%91%E5%B8%88%E6%82%96%E8%AE%BA)、[全能悖论](https://zh.wikipedia.org/wiki/%E5%85%A8%E8%83%BD%E6%82%96%E8%AB%96) 等。

证明很简单，构造`G=~G`命题（G等于G非），让逻辑崩溃，无论G是真还是假，都是错的，最后推导出：不存在这样的G。

停机问题证明过程（反证法）：

1. 如果存在可以判定任意程序是否停机的程序，我们姑且称它为 **上帝程序**
2. 那我们定义这样一个程序，它利用上帝程序判断自己是否停机，但如果上帝程序输出停机，它就不停；如果上帝程序输出不停机，它就停机（就是反着干）。这样一来无论上帝程序输出什么，上帝程序都是错的。那么我们只能说不存在这样的上帝程序。

```python
def is_halt(program, input):
    if program halts on input:
        return true
    else:
        return false

def fuck_is_halt():
    if is_halt(fuck_is_halt):
        while (1):
            pass
    else:
        pass
```

- [Matrix67：停机问题、Chaitin常数与万能证明方法](http://www.matrix67.com/blog/archives/901)
- [刘未鹏：康托尔、哥德尔、图灵——永恒的金色对角线(rev#2)](https://blog.csdn.net/pongba/article/details/1336028)

### [自我指涉](https://zh.wikipedia.org/wiki/%E8%87%AA%E6%8C%87)

![自我指涉](https://upload.wikimedia.org/wikipedia/commons/thumb/f/fa/Ouroboros.png/220px-Ouroboros.png)

在数学中，对自指的研究最终导致了著名的 [哥德尔不完备定理](https://zh.wikipedia.org/wiki/%E5%93%A5%E5%BE%B7%E5%B0%94%E4%B8%8D%E5%AE%8C%E5%A4%87%E5%AE%9A%E7%90%86)。

>计算机程序中的自指主要是为 [递归](https://zh.wikipedia.org/wiki/%E9%80%92%E5%BD%92)

[德罗斯特效应](https://zh.wikipedia.org/wiki/%E5%BE%B7%E7%BD%97%E6%96%AF%E7%89%B9%E6%95%88%E5%BA%94)：

我们经常可以在主播间看到类似的画面：

![德罗斯特效应](https://upload.wikimedia.org/wikipedia/commons/thumb/b/b3/Screenshot_Recursion_via_vlc.png/128px-Screenshot_Recursion_via_vlc.png)

也可以用两面镜子自己做这个实验。

- [妈咪说：哥德尔](https://www.bilibili.com/video/av31411706?from=search&seid=7703410137961337640)

## [冯·诺依曼结构](https://zh.wikipedia.org/wiki/%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84)

冯·诺伊曼结构与 **存储程序型计算机** 是互相通用的名词

>**哈佛结构** 是一种将程序数据与普通数据分开存储的设计概念，可以说是冯·诺依曼结构的一种。

存储程序计算机在体系结构上主要特点有：

- 以运算单元为中心
- **采用存储程序原理**
- 存储器是按地址访问、线性编址的空间
- **控制流由指令流产生**
- 指令由 **操作码** 和 **地址码** 组成
- 数据以二进制编码

五个组成部分：

- 存储器
- 控制器
- 运算器（算术逻辑单元）
- 输入
- 输出

<!--more-->

### 历史

- [文明之光：电子计算机的发明－从图灵到冯诺依曼（上）](https://www.weibo.com/p/1001603799832564268572)
- [文明之光：冯诺依曼系统结构和电子计算机的发明（下）](http://blog.sina.com.cn/s/blog_ac194d320102vdzu.html)
- [妈咪说：过目不忘的天才——冯诺依曼的传奇人生 他为何被称作通用计算机之父？](https://www.bilibili.com/video/av30558057?from=search&seid=11377470098091075406)
- [冯·诺依曼](https://www.youtube.com/watch?v=WTbZRcW_iTM)

>冯·诺依曼由于在曼哈顿工程中需要大量的运算，从而使用了当时最先进的两台计算机 Mark I 和 ENIAC，在使用 Mark I 和 ENIAC 的过程中，他意识到了存储程序的重要性，从而提出了存储程序逻辑架构。

最早的计算机内含固定用途的程序，并非可编程，若想要改变此机器的程序，你必须更改线路、更改结构甚至重新设计机器。而存储程序型计算机的概念改变了这一切。借着将指令当成一种特别类型的静态数据，一台存储程序型计算机可轻易改变其程序，并在程序控制下改变其运算内容。

### 优势

冯·诺依曼架构第一次 **将存储器和运算器分开**，指令和数据均放置于存储器中，为计算机的 **通用性** 奠定了基础。虽然在规范中计算单元依然是核心，但冯·诺依曼架构事实上导致了 **以存储器为核心** 的现代计算机的诞生。

>注：请各位在心里明确一件事情：存储器指的是内存，即 RAM。磁盘理论上属于输入输出设备。

### 缺陷

1. **程序可修改很可能是非常具伤害性的**：在一个简单的存储程序型计算机上，一个设计不良的程序可能会伤害自己、其他程序甚或是操作系统，导致死机、缓存溢出就是一个典型例子。而创造或更改其他程序的能力也导致了恶意软件的出现。利用缓存溢出，一个恶意程序可以覆盖调用堆栈（Call stack）并改写代码，并且修改其他程序文件以造成连锁破坏。存储器保护机制及其他形式的访问控制可以保护意外或恶意的代码更动。
2. **冯·诺伊曼瓶颈（von Neumann bottleneck）**：在内存容量指数级提升以后，CPU 和内存之间的数据传输带宽成为了瓶颈。缓解的办法有：
	1. 在CPU和内存之间提供cache（缓存，速度比内存快很多倍）
	2. 将数据和指令分开存储并能够做到同时访问（在一般的冯·诺依曼结构中数据和指令放在同一内存通过同一数据总线访问，取数据和取指令不能同时进行，而哈佛结构则是将数据和指令分开，可同时访问）
	3. 分支预测和流水线
	
>实际上，绝大多数现代计算机使用的是所谓的“Modified Harvard Architecture”，指令和数据共享同一个 address space，但缓存是分开的。在内存里，指令和数据是在一起的。而在CPU内的缓存中，还是会区分指令缓存和数据缓存，最终执行的时候，指令和数据是从两个不同的地方出来的。你可以理解为在CPU外部，采用的是冯诺依曼模型，而在CPU内部用的是哈佛结构。

>大部分的[DSP](https://zh.wikipedia.org/wiki/%E6%95%B8%E4%BD%8D%E8%A8%8A%E8%99%9F%E8%99%95%E7%90%86%E5%99%A8)都没有缓存，因而直接就是哈佛结构。

![TIM图片20190422164727.png](https://i.loli.net/2019/04/22/5cbd7fbac175d.png)

上图是 i9-7980XE 18 核 36 线程的民用最强 CPU，其配合超频过的 DDR4 3200MHz 的内存，测试出的内存读取速度为 90GB/S。看起来很快了是不是？看看图中的 L1 Cache，3.7TB/S。

我们再来算算时间。这颗 CPU 最大睿频 4.4GHz，就是说 CPU 执行一个指令需要的时间是 0.000000000227273 秒，即 0.22ns（纳秒），而内存的延迟是 68.1ns。换句话说，只要去内存里取一个字节，就需要 CPU 等待 300 个周期，何其的浪费 CPU 的时间啊。

CPU L1 L2 L3 三级缓存是使用和 CPU 同样的 14 纳米工艺制造的硅半导体，每一个 bit 都使用六个场效应管（通俗解释成三极管）构成，成本高昂且非常占用 CPU 核心面积，故不能做成很大容量。

除此之外，L1 L2 L3 三级缓存对计算机速度的提升来源于计算机内存的「局部性」，相关内容我们之后会专门讨论。

[RAM](https://zh.wikipedia.org/zh-hans/%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E5%AD%98%E5%82%A8%E5%99%A8)（Random Access Memory，俗称 **内存**）：内存最大的特点是：**掉电失去数据**。程序是静态的文件存放在外存中，进程正在运行的程序，进程存放在内存中。我们之所以使用内存是因为内存的速度比外存快100倍左右。

[ROM](https://zh.wikipedia.org/wiki/%E5%94%AF%E8%AE%80%E8%A8%98%E6%86%B6%E9%AB%94)（Read-Only Memory，只读存储器）：**ROM掉电不失去数据**。

