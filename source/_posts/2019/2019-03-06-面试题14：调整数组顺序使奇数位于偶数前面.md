---
title: 面试题14：调整数组顺序使奇数位于偶数前面
categories: [读书笔记, 《剑指offer》]
comments: true
---

## 题目

输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。

<!--more-->

## 解答

解决这道题有很多种方法，如果可以使用额外空间的话，我们可以分别用两个数组装奇数和偶数，然后扫描一遍原数组即可分类。时间复杂度是O(n)，空间复杂度是O(n)。但如果不能使用额外空间的话，我们有两种做法：
1. 一种是用一个指针从前往后扫描一遍数组，若扫描到奇数就继续扫描，扫描到偶数就把偶数移到数组末尾，然后把其后的若干个数往前挪动一位。碰到需要挪动数组的情况是非常不好的，一般情况都是O(n^2)的复杂度，所以我们尽量不要挪动数组。
2. 我们用两个指针，分别用于记录奇数和偶数的位置。记录奇数的从数组前面开始，记录偶数的从数组末尾开始。操作类似快速排序的partition。

```java
public void reOrderArray(int [] array) {
    if(array==null || array.length<=1){
        return;
    }
    int index1 = 0;
    int index2 = array.length-1;
    while(index1<index2){
        if(isEven(array[index1])){
            int temp = array[index1];
            array[index1] = array[index2];
            array[index2--] = temp;
        }else{
            index1++;
        }
        if(!isEven(array[index2])){
            int temp = array[index2];
            array[index2] = array[index1];
            array[index1++] = temp;
        }else {
            index2--;
        }
    }
}

private boolean isEven(int a){
    if(a%2==0){
        return true;
    }else{
        return false;
    }
}
```

虽然时间复杂度表现很好，是O(n)，且空间复杂度是O(1)，但这种做法有个缺点就是不能保证顺序不变。而使用额外空间的那种算法，可以保证顺序不变：

```java
public void reOrderArray(int [] array) {
    if(array==null || array.length<=1){
        return;
    }
    int[] temp1 = new int[array.length];
    int[] temp2 = new int[array.length];
    int index1 = 0;
    int index2 = 0;
    for(int i=0;i<array.length;i++){
        if(isEven(array[i])){
            temp2[index2++] = array[i];
        }else{
            temp1[index1++] = array[i];
        }
    }
    for(int i=0;i<index1;i++){
        array[i] = temp1[i];
    }
    for (int i=0;i<index2;i++){
        array[i+index1] = temp2[i];
    }
}

private boolean isEven(int n){
    return (n&1)==0;
}
```

在剑指offer中提到，使用函数指针来提高程序的可重用性，在java中没有函数指针，但使用回调可以达到相同的效果（参数类型使用抽象接口，然后传入具体的实现对象即可）。