---
title: vue.js响应系统的实现
date: 2022-11-06
categories: [JavaScript]
comments: true
---

## 什么是副作用函数？

如果一个函数只是接收输入，然后输出，没有影响外部（比如修改外部变量），那么我们就说这个函数没有副作用，反之就是有副作用。理想的情况下，我们希望所有的函数都很纯粹，没有副作用。

举个例子：

```javascript
function effect() {
  document.body.innerText = "hello vue3";
}
```

## Proxy

我们都知道 vue.js 这类框架是声明式的，当数据发生变化，它可以监听到并重新渲染，那么这种响应系统是如何实现的呢？首先一个问题就是怎么监听到数据的变化。答案是 Proxy，vue2 用了`Object.defineProperty()`函数，这是 es2015 之前的做法，vue3 则是用了 es2015 带来的新特性：`Proxy`。

通过 Proxy 我们可以监听到数据的变化（set），那就可以调用副作用函数更新 dom 了。

最简单的响应系统设计如下：

```javascript
function effect(data) {
  document.body.innerText = data.text;
}
const data = { text: "hello vue3" };
const obj = new Proxy(data, {
  get(target, key) {
    return target[key];
  },
  set(target, key, value) {
    target[key] = value;
    effect(target);
    return true;
  },
});
// 首次渲染
effect(data);
// set操作，触发重新渲染
obj.text = "11"; // 这里必须要修改obj对象（改data是监听不到的）
```

下面开始，都是需求变化产生的代码变化了。

1. 如果有多个副作用函数需要注册，怎么办？
2. 如果这些多个副作用函数，监听的是这个对象的不同 key，怎么办？
3. 如果这些多个副作用函数，监听的是多个对象的不同 key，怎么办？

## 如果有多个副作用函数需要注册，怎么办？

代码如下：

```javascript
function effect1(data) {
  document.body.innerText = data.text;
}
function effect2(data) {
  document.body.setAttribute(data.text);
}
const data = { text: "hello vue3" };
const obj = new Proxy(data, {
  get(target, key) {
    return target[key];
  },
  set(target, key, value) {
    target[key] = value;
    effect1(target);
    effect2(target);
    return true;
  },
});
// 首次渲染
effect1(obj);
effect2(obj);
// set操作，触发重新渲染
obj.text = "11"; // 这里必须要修改obj对象（改data是监听不到的）
```

这样写，显然很不灵活（因为要去修改已经写好的代码），那么怎么设计才能不去动已经写好的代码呢？答案是传回调函数：

```javascript
const bucket = new Set();
function useEffect(fn, data) {
  bucket.add(fn);
  return fn(data);
}

const data = { text: "hello vue3" };
const obj = new Proxy(data, {
  get(target, key) {
    return target[key];
  },
  set(target, key, value) {
    target[key] = value;
    bucket.forEach((fn) => fn(target));
    return true;
  },
});
// 首次渲染
useEffect((data) => {
  document.body.innerText = data.text;
}, data);
useEffect((data) => {
  document.body.setAttribute("a", data.text);
}, data);
// set操作，触发重新渲染
obj.text = "11"; // 这里必须要修改obj对象（改data是监听不到的）
```

这样的写法，是不是很像 react 的 useEffect()了。

## 如果这些多个副作用函数，监听的是这个对象的不同 key，怎么办？

用个 Map，让 key 和回调函数一一对应即可，但如何知道副作用函数用了哪个 key 呢？如果是在 useEffect 里面显然是不知道的，但用没用 key，用了哪个 key，Proxy 里面的 get 拦截函数是一清二楚的，所以我们应该在这里添加副作用函数！但 get 拦截函数里面又不知道，当前获取数据的函数是哪个，很简单，我们设置一个 activeEffect 来记录当前的函数。

```javascript
let activeEffect;
const bucket = new Map();
function useEffect(fn, data) {
  activeEffect = fn;
  return fn(data);
}

const data = { text: "hello vue3", a: "11" };
const obj = new Proxy(data, {
  get(target, key) {
    if (activeEffect) {
      const effects = bucket.get(key);
      if (!effects) {
        bucket.set(key, new Set([activeEffect]));
      } else {
        effects.add(activeEffect);
      }
    }
    return target[key];
  },
  set(target, key, value) {
    target[key] = value;
    const effects = bucket.get(key);
    effects && effects.forEach((fn) => fn(target));
    return true;
  },
});
// 首次渲染
useEffect((data) => {
  document.body.innerText = data.text;
}, obj); // 这里也要传obj了，不然get的时候，也是监听不到的
useEffect((data) => {
  document.body.setAttribute("a", data.a);
}, obj);
// set操作，触发重新渲染
obj.text = "hello aaaa"; // 这里必须要修改obj对象（改data是监听不到的）
obj.a = "222";
```

这样就实现了对单个对象的多个不同 key 注册多个副作用函数，进行响应式渲染。

而且，我们可以把其中处理副作用函数的逻辑抽出来：

```javascript
let activeEffect;
const bucket = new Map();
function useEffect(fn, data) {
  activeEffect = fn;
  return fn(data);
}

const data = { text: "hello vue3", a: "11" };
const obj = new Proxy(data, {
  get(target, key) {
    track(key);
    return target[key];
  },
  set(target, key, value) {
    target[key] = value;
    trigger(target, key);
    return true;
  },
});
function track(key) {
  if (activeEffect) {
    const effects = bucket.get(key);
    if (!effects) {
      bucket.set(key, new Set([activeEffect]));
    } else {
      effects.add(activeEffect);
    }
  }
}
function trigger(target, key) {
  const effects = bucket.get(key);
  effects && effects.forEach((fn) => fn(target));
}
// 首次渲染
useEffect((data) => {
  document.body.innerText = data.text;
}, obj); // 这里也要传obj了，不然get的时候，也是监听不到的
useEffect((data) => {
  document.body.setAttribute("a", data.a);
}, obj);
// set操作，触发重新渲染
obj.text = "hello aaaa"; // 这里必须要修改obj对象（改data是监听不到的）
obj.a = "222";
```
