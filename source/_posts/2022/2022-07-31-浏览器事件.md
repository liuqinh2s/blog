---
title: 浏览器事件
tags: [浏览器]
---

## 事件

事件编程是一种观察者模式，可以很好的解耦页面的表现和页面的行为。

## 事件流

事件冒泡 - IE 浏览器：从子节点到祖先节点
事件捕获 - Netscape 浏览器：从祖先节点到子节点
DOM 事件流 - DOM2 Event 规范 3 个阶段：事件捕获 -> 到达目标 -> 事件冒泡

事件冒泡：
![事件冒泡](../../../../images/2022/事件冒泡.png)

事件捕获：
![事件捕获](../../../../images/2022/事件捕获.png)

DOM 事件流：
![DOM 事件流](../../../../images/2022/DOM事件流.png)

## 事件处理程序

### HTML 事件处理程序

```JavaScript
<input type="button" value="Click Me" onclick="console.log('Clicked')"/>
```

也可以调用函数：

```JavaScript
<script>
  function showMessage() {
    console.log("Hello world!");
  }
</script>
<input type="button" value="Click Me" onclick="showMessage()"/>
```

用这种方式 HTML 和 JavaScript 强耦合，所以一般不用。

### DOM0 事件处理程序

```JavaScript
const btn = document.getElementById("myBtn");
btn.onclick = function(){
    console.log('Clicked')
}
```

注销：

```JavaScript
btn.onclick = null;
```

这种方式添加的事件处理程序是注册在事件流冒泡阶段

### DOM2 事件处理程序

```JavaScript
addEventListener();
removeEventListener();
```

这两个方法暴露在所有 DOM 节点上，它们接受 3 个参数：

1. 事件名
2. 事件处理函数
3. 布尔值，true 表示在捕获阶段调用事件处理函数，false（默认值）表示在冒泡阶段调用事件处理函数。（面试被问到过）

相比于 DOM0 事件处理程序，这种方式可以添加多个事件处理程序：

```JavaScript
let btn = document.getElementById("myBtn");
btn.addEventListener("click", () => {
    console.log(this.id);
}, false);
btn.addEventListener("click", () => {
    console.log("Hello world!");
}, false);
```

执行的顺序是按绑定的顺序来的。

> 注意：解绑必须针对同一个函数，不能对匿名函数解绑

### IE 事件处理程序

IE 实现了与 DOM 类似的方法，即 attachEvent()和 detachEvent()。这两个方法接收两个同样 的参数:事件处理程序的名字和事件处理函数。因为 IE8 及更早版本只支持事件冒泡，所以使用 attachEvent()添加的事件处理程序会添加到冒泡阶段。

```JavaScript
var btn = document.getElementById("myBtn");
btn.attachEvent("onclick", function() {
  console.log("Clicked");
});
btn.attachEvent("onclick", function() {
  console.log("Hello world!");
});
```

执行顺序和绑定顺序相反

### 跨浏览器事件处理程序

```JavaScript
var EventUtil = {
    addHandler: function (element, type, handler) {
      if (element.addEventListener) {
        element.addEventListener(type, handler, false);
      } else if (element.attachEvent) {
        element.attachEvent("on" + type, handler);
      } else {
        element["on" + type] = handler;
      }
    },
    removeHandler: function (element, type, handler) {
      if (element.removeEventListener) {
        element.removeEventListener(type, handler, false);
      } else if (element.detachEvent) {
        element.detachEvent("on" + type, handler);
      } else {
        element["on" + type] = null;
      }
    },
};
```

就是兼容这三种事件绑定方式而已。

## 事件对象

### DOM 事件对象

```JavaScript
let btn = document.getElementById("myBtn");
btn.onclick = function(event) {
 console.log(event.type); // "click"
};
btn.addEventListener("click", (event) => {
 console.log(event.type); // "click"
}, false);
```

不管以 DOM0 还是 DOM2 的方式，绑定事件处理程序，都会传入 event，事件对象。

#### this, currentTarget, target 的区别

this 是调用函数的对象，currentTarget 是事件函数注册的目标，而 target 是事件的实际目标。如果事件处理程序直接添加在了意图的目标，则 this、currentTarget 和 target 的值是一样的。下面的例子展示了这两个属性都等于 this 的情形：

```JavaScript
let btn = document.getElementById("myBtn");
btn.onclick = function(event) {
 console.log(event.currentTarget === this); // true
 console.log(event.target === this); // true
};
```

上面的代码检测了 currentTarget 和 target 的值是否等于 this。因为 click 事件的目标是按
钮，所以这 3 个值是相等的。如果这个事件处理程序是添加到按钮的父节点（如 document.body）上，
那么它们的值就不一样了。比如下面的例子在 document.body 上添加了单击处理程序：

```JavaScript
document.body.onclick = function(event) {
 console.log(event.currentTarget === document.body); // true
 console.log(this === document.body); // true
 console.log(event.target === document.getElementById("myBtn")); // true
};
```

这种情况下点击按钮，this 和 currentTarget 都等于 document.body，这是因为它是注册事件
处理程序的元素。而 target 属性等于按钮本身，这是因为那才是 click 事件真正的目标。由于按钮
本身并没有注册事件处理程序，因此 click 事件冒泡到 document.body，从而触发了在它上面注册的
处理程序。

#### preventDefault 和 stopPropagation

preventDefault()方法用于阻止特定事件的默认动作。比如，链接的默认行为就是在被单击时导
航到 href 属性指定的 URL。如果想阻止这个导航行为，可以在 onclick 事件处理程序中取消，如下
面的例子所示：

```JavaScript
let link = document.getElementById("myLink");
link.onclick = function(event) {
 event.preventDefault();
};
```

stopPropagation()方法用于立即阻止事件流在 DOM 结构中传播，取消后续的事件捕获或冒泡。
例如，直接添加到按钮的事件处理程序中调用 stopPropagation()，可以阻止 document.body 上注
册的事件处理程序执行。比如：

```JavaScript
let btn = document.getElementById("myBtn");
btn.onclick = function(event) {
 console.log("Clicked");
 event.stopPropagation();
};
document.body.onclick = function(event) {
 console.log("Body clicked");
};
```

#### eventPhase

```JavaScript
let btn = document.getElementById("myBtn");
btn.onclick = function(event) {
 console.log(event.eventPhase); // 2
};
document.body.addEventListener("click", (event) => {
 console.log(event.eventPhase); // 1
}, true);
document.body.onclick = (event) => {
 console.log(event.eventPhase); // 3
};
```

### IE 事件对象

```JavaScript
var btn = document.getElementById("myBtn");
btn.onclick = function() {
 let event = window.event;
 console.log(event.type); // "click"
};
```

```JavaScript
var btn = document.getElementById("myBtn");
btn.attachEvent("onclick", function(event) {
 console.log(event.type); // "click"
});
```

由于事件处理程序的作用域取决于指定它的方式，因此 this 值并不总是等于事件目标。为此，更
好的方式是使用事件对象的 srcElement 属性代替 this。下面的例子表明，不同事件对象上的
srcElement 属性中保存的都是事件目标：

```JavaScript
var btn = document.getElementById("myBtn");
btn.onclick = function() {
 console.log(window.event.srcElement === this); // true
};
btn.attachEvent("onclick", function(event) {
 console.log(event.srcElement === this); // false
});
```
