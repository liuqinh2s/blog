---
title: 数独游戏制作过程记录
date: { { date } }
categories: [项目]
tags: [项目]
comments: true
---

我打算自己做一个数独游戏，主要分为两步：

1. 生成一个数独
2. 验证玩家填入的数字是否正确

生成一个数独可以有很省事的办法，就是直接从数独库中随机选一个（甚至可以直接把空白都给你挖好）。也可以用暴力方法（回溯法），一行一行去填，进行不下去就回溯到上一步。

生成数独最高效的算法是：[**舞蹈链**](https://zh.wikipedia.org/wiki/%E8%88%9E%E8%B9%88%E9%93%BE)，实际上舞蹈链是一种数据结构，是为了[**X 算法**](https://zh.wikipedia.org/wiki/X%E7%AE%97%E6%B3%95)而产生的，而 X 算法是用来解决一类问题：[**精确覆盖问题**](https://zh.wikipedia.org/zh-hans/%E7%B2%BE%E7%A1%AE%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98)

> 插个题外话，我朋友说，东野圭吾的小说[《嫌疑犯 X 的献身》](https://zh.wikipedia.org/zh-hans/%E5%AB%8C%E7%96%91%E7%8A%AFX%E7%9A%84%E7%8D%BB%E8%BA%AB)，的凶手就在研究这个问题，有兴趣可以顺带看看，这小说挺有名的。

> 精确覆盖问题是一个 NP 完全问题，NP 问题的概念我差不多忘光了，得重新看看

<!-- more -->

## 精确覆盖问题

简单来说就是给定一个全集 X，和若干子集 S，从子集中选出 N 个，它们平凑起来恰好（没有多余的元素，比如某个元素出现过两次）等于全集 X。

## X 算法

维基百科的解说我看不懂，还好 OI-Wiki 上讲的足够详细：[X 算法](https://oi-wiki.org/search/dlx/#x-%E7%AE%97%E6%B3%95)

解决精确覆盖问题，简单来说分为以下几个步骤：

### 建模

针对问题建模，建模成一个 01 矩阵，每一行代表一个集合，1 代表包含了集合 X 的某个元素（1 的位置，就是该元素在集合 X 中的位置），0 代表没没包含

### 算法步骤

简化问题（缩小矩阵，删掉不再考虑的部分），递归解决子问题。

1. 随机选一行
2. 去掉这一行
3. 找到这一行的有 1 的那些列，去掉这些列
4. 找到与这一行有冲突的那些行（同一列上都有 1 即为冲突），去掉这些行
5. 现已经得到了一个缩小版的矩阵，继续以上这种删减操作
6. 结束标志：得到一个空矩阵。是否有解：最后一次删除的行全部是 1，则说明问题有解，否则问题无解

> 这个算法很好的缩小了问题规模，非常典型的技巧

### 算法含义

每选择一行，代表着打算用这一行去精确覆盖全集，那么相应的：

1. 每行只用一次，故删除选择的这一行
2. 这一行中出现的所有元素（每个 1 代表一个元素出现），后续都不用再考虑，故删除相关列
3. 跟它起冲突的行（同一列上有 1，代表有相同的元素，不符合精确覆盖），都要放弃，没法纳入解中，所以后续都不用再考虑，故删除这些行

以上三步可以保证每次选择的行，行之间是不会出现重复元素的。

结束标志也很好理解，最后一次删除的行，如果全部是 1，则标志着我们所有列都刚好填补上了元素。

这样我们就做到了全覆盖+精确覆盖，这两项要求。

### 算法的具体实现

具体代码实现，还有很多细节不清楚，参考资料：

- [跳跃的舞者，舞蹈链（Dancing Links）算法——求解精确覆盖问题](https://developer.aliyun.com/article/373709)

我自己实现了一份 TypeScript 写的代码：

https://github.com/liuqinh2s/Algorithm/blob/master/DancingLinksX/DancingLinksX.ts

与上面那个实现不同，我这个实现既有列头，又有行头，反正怎么方便怎么来。

![舞蹈链](../../../../images/2023/舞蹈链.png)

## 数独怎么转化为精确覆盖问题

在网上查阅了大量资料，但一开始都看不懂，且发现他们讲的基本上一模一样（天下文章一大抄），就跟前面舞蹈链一样，连配图都是一样的。

无非是说，列代表这约束，约束有四类：

1. 每个格子填或者不填数字
2. 每行有没有哪个数字
3. 每列有没有哪个数字
4. 每个宫格有没有哪个数字

我们拿 `4*4` 的数独来做例子（只用到 1 到 4 四个数，可以称之为 2 阶数独吧，比咱们常玩的三阶数独小一阶）：

```
2 4 0 0
1 0 2 0
0 0 0 2
4 0 0 0
```

这幅图转化成精确覆盖问题的矩阵是什么样呢？

```
1 1 0 0 1 0 1 0 0 0 0 1 1 0 0 0 | 0 1 0 1 1 1 0 0 0 1 0 0 0 0 0 1 | 1 1 0 1 0 0 0 1 0 1 0 0 0 1 0 0 | 1 1 0 1 0 1 0 0 0 0 0 1 0 1 0 0
```

上面用`|`划分了四个区域，每个区域的含义，详细说明如下：

```
第一个区域表示某一个格子里是否填了数字，1表示填了，0表示没填
1 1 0 0 1 0 1 0 0 0 0 1 1 0 0 0
```

其实理解的关键在于行：**每一行即一幅数独图**（完成的，未完成的，合法的，不合法的都可），例如下面两个数独图：

```
2 4 0 0
1 0 2 0
0 0 0 2
4 0 0 0
```

```
0 0 1 3
0 3 0 4
3 1 4 0
0 2 3 1
```

就分别是两行，且他们刚好可以拼凑出全集。那么随便给出一个图，也就是相当于给出了舞蹈链中的一行，我们以这一行为入口，即可进行精确覆盖问题的求解，最后就知道有没有解，解是什么。

以上只讲了如何解数独，那么如何生成数独呢：[数独的生成过程是怎样的？ - 单想的回答 - 知乎](https://www.zhihu.com/question/22043229/answer/44315364)

简单来说就是：随机放入 11 个数，求解出终盘，然后挖洞。
