---
title: 数独游戏制作过程记录
date: { { date } }
categories: [项目]
tags: [项目]
comments: true
---

我打算自己做一个数独游戏，主要分为两步：

1. 生成一个数独
2. 验证玩家填入的数字是否正确

生成一个数独可以有很省事的办法，就是直接从数独库中随机选一个（甚至可以直接把空白都给你挖好）。也可以用暴力方法（回溯法），一行一行去填，进行不下去就回溯到上一步。

生成数独最高效的算法是：[**舞蹈链**](https://zh.wikipedia.org/wiki/%E8%88%9E%E8%B9%88%E9%93%BE)，实际上舞蹈链是一种数据结构，是为了[**X 算法**](https://zh.wikipedia.org/wiki/X%E7%AE%97%E6%B3%95)而产生的，而 X 算法是用来解决一类问题：[**精确覆盖问题**](https://zh.wikipedia.org/zh-hans/%E7%B2%BE%E7%A1%AE%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98)

> 插个题外话，我朋友说，东野圭吾的小说[《嫌疑犯 X 的献身》](https://zh.wikipedia.org/zh-hans/%E5%AB%8C%E7%96%91%E7%8A%AFX%E7%9A%84%E7%8D%BB%E8%BA%AB)，的凶手就在研究这个问题，有兴趣可以顺带看看，这小说挺有名的。

> 精确覆盖问题是一个 NP 完全问题，NP 问题的概念我差不多忘光了，得重新看看

<!-- more -->

## 精确覆盖问题

简单来说就是给定一个全集 X，和若干子集 S，从子集中选出 N 个，它们平凑起来恰好（没有多余的元素，比如某个元素出现过两次）等于全集 X。

## X 算法

维基百科的解说我看不懂，还好 OI-Wiki 上讲的足够详细：[X 算法](https://oi-wiki.org/search/dlx/#x-%E7%AE%97%E6%B3%95)

解决精确覆盖问题，简单来说分为以下几个步骤：

### 建模

针对问题建模，建模成一个 01 矩阵，每一行代表一个集合，1 代表包含了集合 X 的某个元素（1 的位置，就是该元素在集合 X 中的位置），0 代表没没包含

### 算法步骤

简化问题（缩小矩阵，删掉不再考虑的部分），递归解决子问题。

1. 随机选一行
2. 去掉这一行
3. 找到这一行的有 1 的那些列，去掉这些列
4. 找到与这一行有冲突的那些行（同一列上都有 1 即为冲突），去掉这些行
5. 现已经得到了一个缩小版的矩阵，继续以上这种删减操作
6. 结束标志：得到一个空矩阵。是否有解：最后一次删除的行全部是 1，则说明问题有解，否则问题无解

> 这个算法很好的缩小了问题规模，非常典型的技巧

### 算法含义

每选择一行，代表着打算用这一行去精确覆盖全集，那么相应的：

1. 每行只用一次，故删除选择的这一行
2. 这一行中出现的所有元素（每个 1 代表一个元素出现），后续都不用再考虑，故删除相关列
3. 跟它起冲突的行（同一列上有 1，代表有相同的元素，不符合精确覆盖），都要放弃，没法纳入解中，所以后续都不用再考虑，故删除这些行

以上三步可以保证每次选择的行，行之间是不会出现重复元素的。

结束标志也很好理解，最后一次删除的行，如果全部是 1，则标志着我们所有列都刚好填补上了元素。

这样我们就做到了全覆盖+精确覆盖，这两项要求。

### 算法的具体实现

具体代码实现，还有很多细节不清楚，参考资料：

- [跳跃的舞者，舞蹈链（Dancing Links）算法——求解精确覆盖问题](https://developer.aliyun.com/article/373709)

我自己实现了一份 TypeScript 写的代码：

https://github.com/liuqinh2s/Algorithm/blob/master/DancingLinksX/DancingLinksX.ts

与上面那个实现不同，我这个实现既有列头，又有行头，反正怎么方便怎么来。

![舞蹈链](../../../../images/2023/舞蹈链.png)
