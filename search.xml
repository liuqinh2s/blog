<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[重庆旅游攻略]]></title>
    <url>%2F2023%2F10%2F12%2F%E9%87%8D%E5%BA%86%E6%97%85%E6%B8%B8%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[景点推荐游玩时间： 3 月-5 月以及 9 月~11 月（天气凉爽宜人） 推荐路线及景点： Day1：解放碑—长江索道-洪崖洞 Day2：磁器口—马房湾 66 号江湖菜-四川美术学院—南滨路 Day3：李子坝—鹅岭二厂—南山一棵树 住推荐住解放碑洪崖洞附近 景点洪崖洞建议下午 4 点去，白天和晚上的景色都能看的到。晚上夜景很漂亮，建议不要错过。白天人少，晚上人多。夜晚的洪崖洞，应该远观，从更高处拍下它的全貌；白天的洪崖洞，可以让人以更近的距离来接触，体验过两种不同场景下的它，才会是完整的。 山城步道山城步道因为从你的全世界路过而闻名。这里是老重庆的印记，漫步石板路的小巷，是体验山城韵味的最佳方式之一。对面便是滚滚长江，实是一处观江景的好去处。 步道从山城巷到通远门，全程 3 公里，慢行 1-2 小时。 南山一棵树观景台重庆的南山一棵树，可以看到媲美香港的夜景，一眼望去，美轮美奂 磁器口古镇——小重庆解放碑——小香港长江索道——体验空中走廊皇冠大扶梯连接了两路口和重庆火车菜园坝站，重庆的特色交通之一，是亚洲第二长的一级提升坡地大扶梯。 扶梯的速度比一般扶梯快很多，扶梯垂直高度 64 米，扶梯长度 150 米，30 度倾斜角度，在视觉上非常刺激。配套设施比较老旧，但值得一试。 位置：乘坐地铁 1、3 号线到两路口往菜园坝方向下行 门票：单程 2 元/人 开放时间：07:00-22:00 李子坝轻轨站鹅岭贰厂罗汉寺在闹市区重重高楼包围下，香火旺盛的古刹，也是《疯狂的石头》拍摄地 湖广会馆湖广会馆建于清朝，在重庆现代化的建筑中显得突兀但是又别具一格，很喜欢里面的建筑，大多使用木材建造的，浮雕都雕刻得很精美，在这里经常会遇见很多拍婚纱照的夫妻哈哈~ 地址：重庆市渝中区芭蕉园 1 号重庆湖广会馆 中山四路由于是中共重庆市委、重庆市政府所在地，所以流露出一份沉重的宁静，这条路上人流也比较少，建议前往。这条街上历史遗迹除了中国民主党派博物馆的特园外，还有桂园、周公馆、戴公馆、张骧公馆、国民政府总统府旧址等。除了古朴的建筑，中山四路最让人赏心悦目的还有两列枝叶繁茂的黄葛树，夏天来此凉爽又清新。 川美涂鸦街虽然涂鸦比较老旧了，但此地人少安静，可以随便凹造型拍照。拍出来的照片都超级好看，而且这个地方特别有文艺气息！ 金刚碑老街红色旅游景点：白公馆，渣滓洞文创区：喵儿石文创园喵儿石创艺特区前身为上世纪 70 年代的白猫日化老厂，厂区具有丰厚的历史底蕴，曾风靡重庆的白猫、蜀秀、鹅牌洗涤用品都出自本厂。 2010 年重庆未来之家置业有限公司从香港和记黄埔手里收购了白猫日化老厂，聘请了世界十大创新设计事务所之一——荷兰著名的 MVRDV 建筑设计事务所，在尊重原有建筑结构的基础上对建筑外观进行升级改造，既保留了老厂区的历史底蕴又注入了新的活力。 华生园金色蛋糕梦幻王国美食重庆火锅（南坪或者较场口），重庆小面，重庆酸辣粉，棒棒鸡，毛血旺，山城小汤圆，重庆烤鱼，鸡杂，辣子鸡，抄手，豆花（吴记豆花面，南坪万寿路中百仓储），板凳面（渝北区松石支路 108 号），芝麻小糍粑，烤脑花 马房湾 66 号江湖菜重庆必吃美食除了火锅，小面还有江湖菜，这个地方特别有意思，位置在半山腰上，有山城特色，店内是七八十年代的风格，是一个拍照打卡的好地方，当然味道也是非常棒的、天下第一蒸里面是粉蒸的三线肉、肥肠、排骨蒸得非常软糯，垫底的红苕甜甜的也很好吃、辣子鸡、水煮鱼麻辣鲜香，下酒又下饭，味道可以说是很正宗的啦！ 君之薇火锅在马房湾 66 号江湖菜旁边的火锅店，上过舌尖上的中国第一季，21 年的老品牌，还是老味道、重点是性价比还很高，这个年头还保持几块钱一份的菜也是很少了。 也是我经常去吃的一家火锅。 地址：沙坪坝区杨公桥地铁站 1B 出口旁的半坡上 费用机票从长沙飞重庆677*2(含了保险30*2块)，高铁票株洲西到长沙南 49 + 重庆西到深圳北 554.5 + 重庆到株洲高铁 448.5+24.5，住宿费三晚 850。路费+住宿费总共 3280.5]]></content>
      <categories>
        <category>旅游</category>
      </categories>
      <tags>
        <tag>攻略</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[手写优先队列]]></title>
    <url>%2F2023%2F10%2F09%2F%E6%89%8B%E5%86%99%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%2F</url>
    <content type="text"><![CDATA[优先队列一般是用堆来实现的，查询复杂度是O(1)，插入和删除的复杂度是O(logN)。堆结构就是一个完全二叉树，完全二叉树可以用数组实现。 测试场景：215. 数组中的第K个最大元素 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869class PriorityQueue1&lt;T&gt; &#123; arr: T[]; compare: (a: T, b: T)=&gt;number; constructor(props: &#123;compare: (a: T, b: T)=&gt;number&#125;) &#123; const &#123; compare &#125; = props; this.compare = compare; this.arr = []; &#125; swap(arr, index1, index2) &#123; const temp = arr[index1]; arr[index1] = arr[index2]; arr[index2] = temp; &#125; enqueue(a) &#123; this.arr.push(a); this.bubbleUp(this.arr.length - 1); &#125; dequeue() &#123; this.delete(0); &#125; bubbleUp(index) &#123; if (this.arr.length &lt;= 1 || index &lt;= 0) &#123; return; &#125; const pre = Math.floor((index - 1) / 2); if (this.compare(this.arr[index], this.arr[pre]) &gt; 0) &#123; this.swap(this.arr, pre, index); this.bubbleUp(pre); &#125; &#125; delete(index) &#123; this.swap(this.arr, index, this.arr.length - 1); this.arr.pop(); this.sinkDown(index); &#125; sinkDown(index) &#123; if (this.arr.length &lt;= 1 || index &gt;= this.arr.length - 1) &#123; return; &#125; if (index * 2 + 1&lt;this.arr.length &amp;&amp; this.compare(this.arr[index], this.arr[index * 2 + 1]) &lt; 0 || index * 2 + 2 &lt; this.arr.length &amp;&amp; this.compare(this.arr[index], this.arr[index * 2 + 2]) &lt; 0) &#123; if (index * 2 + 2 &gt;= this.arr.length || this.compare(this.arr[index * 2 + 1], this.arr[index * 2 + 2])&gt;0) &#123; this.swap(this.arr, index, index * 2 + 1); this.sinkDown(index * 2 + 1); &#125; else &#123; this.swap(this.arr, index, index * 2 + 2); this.sinkDown(index * 2 + 2); &#125; &#125; &#125; front() &#123; return this.arr[0]; &#125; size()&#123; return this.arr.length; &#125;&#125;function findKthLargest(nums: number[], k: number): number &#123; // PriorityQueue1 const pq = new PriorityQueue1(&#123;compare: (a: number, b: number) =&gt; a - b&#125;); for (let i = 0; i &lt; nums.length; i++) &#123; pq.enqueue(nums[i]) &#125; for(let i=k-1;i&gt;=1;i--)&#123; pq.dequeue(); &#125; return pq.front()&#125;; 测试场景2：2034. 股票价格波动 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106class PriorityQueue1&lt;T&gt; &#123; arr: T[]; compare: (a: T, b: T)=&gt;number; constructor(props: &#123;compare: (a: T, b: T)=&gt;number&#125;) &#123; const &#123; compare &#125; = props; this.compare = compare; this.arr = []; &#125; swap(arr, index1, index2) &#123; const temp = arr[index1]; arr[index1] = arr[index2]; arr[index2] = temp; &#125; enqueue(a) &#123; this.arr.push(a); this.bubbleUp(this.arr.length - 1); &#125; dequeue() &#123; this.delete(0); &#125; bubbleUp(index) &#123; if (this.arr.length &lt;= 1 || index &lt;= 0) &#123; return; &#125; const pre = Math.floor((index - 1) / 2); if (this.compare(this.arr[index], this.arr[pre]) &gt; 0) &#123; this.swap(this.arr, pre, index); this.bubbleUp(pre); &#125; &#125; delete(index) &#123; this.swap(this.arr, index, this.arr.length - 1); this.arr.pop(); this.sinkDown(index); &#125; sinkDown(index) &#123; if (this.arr.length &lt;= 1 || index &gt;= this.arr.length - 1) &#123; return; &#125; if (index * 2 + 1&lt;this.arr.length &amp;&amp; this.compare(this.arr[index], this.arr[index * 2 + 1]) &lt; 0 || index * 2 + 2 &lt; this.arr.length &amp;&amp; this.compare(this.arr[index], this.arr[index * 2 + 2]) &lt; 0) &#123; if (index * 2 + 2 &gt;= this.arr.length || this.compare(this.arr[index * 2 + 1], this.arr[index * 2 + 2])&gt;0) &#123; this.swap(this.arr, index, index * 2 + 1); this.sinkDown(index * 2 + 1); &#125; else &#123; this.swap(this.arr, index, index * 2 + 2); this.sinkDown(index * 2 + 2); &#125; &#125; &#125; front() &#123; return this.arr[0]; &#125; size()&#123; return this.arr.length; &#125;&#125;interface Data &#123; index: number; value: number;&#125;class StockPrice &#123; priceArr: number[]; maxPriorityQueue: PriorityQueue1&lt;&#123;index: number, value: number&#125;&gt;; minPriorityQueue: PriorityQueue1&lt;&#123;index: number, value: number&#125;&gt;; constructor() &#123; this.priceArr = []; this.maxPriorityQueue = new PriorityQueue1(&#123;compare: (a: Data,b: Data)=&gt;a.value-b.value&#125;); this.minPriorityQueue = new PriorityQueue1(&#123;compare: (a: Data,b: Data)=&gt;b.value-a.value&#125;); &#125; update(timestamp: number, price: number): void &#123; this.priceArr[timestamp] = price; this.maxPriorityQueue.enqueue(&#123;index: timestamp, value: price&#125;); this.minPriorityQueue.enqueue(&#123;index: timestamp, value: price&#125;); &#125; current(): number &#123; return this.priceArr[this.priceArr.length-1]; &#125; maximum(): number &#123; while(this.maxPriorityQueue.front().value !== this.priceArr[this.maxPriorityQueue.front().index])&#123; this.maxPriorityQueue.dequeue(); &#125; return this.maxPriorityQueue.front().value; &#125; minimum(): number &#123; while(this.minPriorityQueue.front().value !== this.priceArr[this.minPriorityQueue.front().index])&#123; this.minPriorityQueue.dequeue(); &#125; return this.minPriorityQueue.front().value; &#125;&#125;/** * Your StockPrice object will be instantiated and called as such: * var obj = new StockPrice() * obj.update(timestamp,price) * var param_2 = obj.current() * var param_3 = obj.maximum() * var param_4 = obj.minimum() */]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Promise详解]]></title>
    <url>%2F2023%2F07%2F19%2FPromise%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[官方文档Promise A+ 规范async 函数 常见问题 异步函数不一定就会异步执行，主要看里面有没有异步的地方，比如setTimeout，比如http请求，比如indexedDB请求 函数返回Promise对象，不一定就要写async，除非里面用了await async是Promise的等价简写，不必再多写一个return new Promise 12345678910111213141516function resolveAfter2Seconds() &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve('resolved'); &#125;, 2000); &#125;);&#125;async function asyncCall() &#123; console.log('calling'); const result = await resolveAfter2Seconds(); console.log(result); // Expected output: "resolved"&#125;asyncCall();]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux使用手册]]></title>
    <url>%2F2023%2F06%2F07%2Flinux%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[最近买了一台服务器，太多 linux 命令要上网查询了，已经不适合记在札记里面（札记里面一般是记录比较杂的东西，篇幅尚不能形成文章），所以专门开了一篇文章来讲我在使用 linux 服务器遇到的问题，以及解决办法。 首先要谈的是服务器安全问题 以前搭 wordpress 博客的时候，被盗过两次，跟同事讨论了之后，发现可能是因为我使用了 root 账号远程登录，要论安全性的话，最好的方式是： 禁止 root 账号远程登录（那么别人想要登录，就只能猜你的账号名+密码，如果你开放了 root 登录，别人就只需要猜 root 密码） 把 ssh 端口改为非 22 端口，那黑客想要破解，就需要猜端口 普通账号不给 root 权限，这样即便普通账号被盗，情况也不算严重 设置一个强的 root 密码 这样一套组合拳打下来，黑客想要获取你服务器的最高权限，首先要知道你的 ssh 端口，然后要知道一对普通账号密码，最后要知道 root 的密码，才能最终获得最高权限。相比于只靠 root 密码的强度，安全了许多许多。 发现一个问题是 FinalShell 不能直接编辑并保存文件了，应该是权限的问题。 以下是需要用到的 linux 命令： 新建用户：useradd &lt;yourname&gt; 修改用户密码：passwd &lt;yourname&gt; 修改 ssh 端口号：编辑/etc/ssh/sshd_config文件，修改#Port 22为：Port xxxx 禁止 root 账号远程登录：编辑/etc/ssh/sshd_config文件，修改#PermitRootLogin yes为：PermitRootLogin no 修改完/etc/ssh/sshd_config文件后，需要重启一下服务： 12setenforce 0sudo service sshd restart 修改完端口，还要让防火墙放行此端口： 123456// 放行指定端口firewall-cmd --zone=public --add-port=xxxx/tcp --permanent// 重启防火墙systemctl restart firewalld.service// 重新载入配置firewall-cmd --reload 前因买了国外的域名和服务器，这样就可以避免国内特别麻烦的备案了，话说国外的域名和服务器真是便宜啊： 服务器（VPS）：racknerd.com 域名：name.com 服务器购买参考了一篇文章：https://p3terx.com/archives/cheap-vps-racknerd.html，多亏这篇文章才买到了便宜的。 Windows 平台好用的远程 shell 工具：WindTermMac OS 平台好用的远程 shell 工具：FinalShell 现在 Windows 平台也有 FinalShell 了，体验终于又统一起来了 centos 安装 nginxyum install 没有可用软件包 nginx。 12345678已加载插件：fastestmirrorLoading mirror speeds from cached hostfile * base: mirror.lzu.edu.cn * extras: mirror.lzu.edu.cn * updates: mirror.lzu.edu.cn没有可用软件包 nginx。错误：无须任何处理 原因是 nginx 位于第三方的 yum 源里面，而不在 centos 官方 yum 源里面 解决方法： 安装 1sudo yum install epel-release 更新 1yum update 重新试一下： 1yum install -y nginx nginxnginx 的配置位置：/etc/nginx中，在该目录下，主要的配置文件是 nginx.conf 常见需求和解决办法： ssl 证书怎么搞：Let&#39;s Encrypt 提供的解决方案，按照这个操作：certbot instructions nginx 配置域名：修改 nginx.conf 里面的 server_name 字段 HTTP 跳转到 HTTPS：使用 301 重定向的方式将 http 的请求重定向到 https 上 123456789server &#123; listen 80; #填写绑定证书的域名 server_name www.xxx.com; #把http的域名请求转成https return 301 https://$host$request_uri;&#125; nginx 配置单页应用1234location / &#123; try_files $uri $uri/ /index.html?$args; index index.html;&#125; Shadowsocks 搭建1234567891011pip install https://github.com/shadowsocks/shadowsocks/archive/master.zip -Uvim /etc/shadowsocks.json&#123;"server":"0.0.0.0","server_port":"端口","local_port":1080,"password":"密码","timeout":300,"method":"aes-256-gcm"&#125;ssserver -c /etc/shadowsocks.json -d start 防火墙查看防火墙开放的端口：firewall-cmd --list-ports 把常用的程序做成服务，并开机启动新建服务脚本：/etc/systemd/system/shadowsocks.service 1234567891011[Unit]Description=Shadowsocks Server ServiceAfter=network.target[Service]Type=simpleUser=rootExecStart=/usr/bin/ssserver -c /etc/shadowsocks.json[Install]WantedBy=multi-user.target 常用命令 创建用户：useradd &lt;用户名&gt;，删除用户：userdel &lt;用户名&gt; 修改密码：passwd &lt;用户名&gt; 创建用户组：groupadd &lt;用户组名&gt;，删除用户组：groupdel &lt;用户组名&gt;，查看所有组：groups 查看端口占用 lsof -i :&lt;端口号&gt; 查看某些应用的端口占用情况，比如 ssh 的端口号：netstat -anp |grep ssh 给用户某个文件夹权限：chown -R liuhai:liuhai /opt # 将目录/opt 及其下面的所有文件、子目录的文件主改成 liuhai 常见文件位置 hosts 文件位置：/etc/hosts nginx 配置位置：/etc/nginx/nginx.conf vim 编辑常用技巧去除多行注释： 按 ctrl+v 进入 visual block 模式 按上下方向键选择多行 按 d 去掉# linux 基础知识ls 展示的权限的含义： linux drwxr-xr-x第一位表示文件类型。d 是目录文件，l 是链接文件，-是普通文件，p 是管道第 2-4 位表示这个文件的属主拥有的权限，r 是读，w 是写，x 是执行。第 5-7 位表示和这个文件属主所在同一个组的用户所具有的权限。第 8-10 位表示其他用户所具有的权限。]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>服务器运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AwesomeWeb项目]]></title>
    <url>%2F2023%2F05%2F22%2FAwesomeWeb%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[github 仓库：liuqinh2s/AwesomeWeb项目展示：replit - AwesomeWeb 最近想像洛雪音乐一样做一个免费的视频 app，主要学习对象是努努视频，说干就干，先看看努努用了哪些第三方 js 库，打开努努视频网站：nunuyy5.org，然后打开开发者工具，可以看到用了这些： hls.js jquery.js p2p-media-loader-core.min.js 和 p2p-media-loader-hlsjs.min.js 用hls.js就可以播放 m3u8 视频了，但是要怎么下载视频呢，在网上搜了一下，找到了一个下载器：Momo707577045/m3u8-downloader 他的源码还是值得学习的 电子书阅读器epubjs官方文档 官方简单 demo epub.js 核心类 Book 阅读器解析Rendition 阅读器渲染Locations 阅读器定位Navigation 存储目录信息View Manager 阅读器渲染出来的视图管理EpubCFI 利用 EpubCFI 标准进行文字级别定位（可以定位到电子书中任意一个字符）Theme 管理场景切换Spine 指定阅读顺序和管理 SectionSection 指向具体章节（全文检索、章节切换）Contents 管理章节资源内容（为某章节添加自定义字体）Hook 定义钩子函数、管理类的生命周期Annotations 管理标签（文字高亮显示） 这是我朋友做的一个基于 epubjs 的电子书阅读器:http://118.190.10.34/epub-z/#/ 由于 epubjs 在 react 中太难使用，翻页都没实现成功。最终还是采用了更为简单的库：React Reader - an easy way to embed a ePub into your webapp]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[水贝买黄金攻略]]></title>
    <url>%2F2023%2F04%2F07%2F%E6%B0%B4%E8%B4%9D%E4%B9%B0%E9%BB%84%E9%87%91%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[位置：坐地铁从田贝站出来，不要从水贝站出来，田贝站 F 口出来就是水贝万山 店：零售店和批发展厅，人气最旺金展负一楼，宝刀不老水贝万山，价格最便宜丽铂飞（也叫新一佳） 购物地点深圳水贝珠宝主要以批发为主，所以很多展厅是不接待零售客户的。所以如果您要来选购珠宝一定要认准以下几个地方。 金展珠宝广场负一层：黄金、K 金、铂金、钻石等都有，这里主要是针对微商，所有店铺都支持一件代发。最近网上被炒的很火，所以那边的柜台价格越来越高，连同行价都很高，价格不是很好。 水贝万山： 全品类批发点以批发为主，分 A、B、C 三座、A、B 座 1 楼基本是 18K 金、钻戒等东西；2 楼主要是翡翠类：3 楼主要是银饰；C 栋 1~3 楼基本都是卖彩宝的不过一些店铺是只做批发不零售的，要先消费一定金额“开户”才能拿货，比如某黄金店，要消费满 50G（大约 2 万多）才可以按批发价拿货。 丽铂飞珠宝批发广场：这里和其他批发广场一样，也是很多的柜台，黄金、珍珠、K 斤、钻石、彩宝都有，也有定制钻石、回收黄金之类的店铺。还是能找到蛮多好看的饰品有时间也可以来淘淘宝。三楼的银饰基本都是批发的(基本都是 925 银).3000 起批这样，想要摆地摊或者做微商的可以来，不过近年来附近开了不少新场柜台商家流失严重。 水贝国际负一楼：小柜台零售、各种品类都有，价格可砍价， 123 楼有全品类的珠宝：有黄金、K 金镶嵌类部分可零售，价格公道。 水贝壹号负一楼：小柜台的硬金、5G 黄金、小珠子都有，K 金镶嵌居多，年轻时尚，散客可以逛很久，还有自创设计师品牌，价格稍贵，但好看，123 楼 全品类，黄金钻石镶嵌玉石都有，但散客和批发价格差别大。 特力珠宝大厦负一楼：非常多的编绳柜台，还有黄金，K 金小柜台，比大型批发厅的工费略高但散卖一件也可以买。123 楼：有和田玉、翡翠、玉石、还有黄金回收、有黄金需要置换回收的可以来这里。 水贝银座负一楼：有一家钻石，价格比专柜低一些，但也不是同行拿货价最低，买钻石第二选择。 1234 楼：全品类，K 金钻石镶嵌银饰都有，平时逛的人比较少。 水贝金座负一楼：全品类、还有个黄金商专卖零点几克的小配件，喜欢小配件的可以来。123 三楼：有金镶玉展厅、钻石展厅、还有小型黄金展厅，楼上：黄金大型展厅，不接散客，只有开户了的老板或者线下实体店加盟商可以拿货，买金价格最低，工艺最好，工费最低，但是要起量。 兴龙黄金珠宝大厦负一层：黄金、玉石为主。123 楼：以翡翠玉石为主，买之前一定做好翡翠攻略，不然容易被坑，价格差别很大。 水贝国际、水贝壹号、金座、银座、兴龙、特力这六大商场的负一楼是连通的，大小商家无数，款式琳琅满目(黄金、钻石、镶嵌、k 金、铂金、翡翠等有)足够逛一整天了。 黄金知识（什么叫素金、硬金、5G 黄金、古法金)买金的技巧 千万别问真假，千万别问纯不纯，千万别问保不保真——典型的小白送命三连。 不要试图砍价，不可能的。小店老板可能给你抹个零，大店几块钱的尾数也不可能给你抹去的，10005 元就是 10005 元，一分也不会少的（但是比起你在周大福买的能省下大几千，香！真香！）。 没有发票，没有盖章，没有赠品，但要有收据（证明是这里买的）。不要带着去周大福买金的姿态来水贝买金，这里纯粹就是钱变货，没有微笑+轻声细语的介绍，没有端茶倒水，你也不要指望有其他服务。 正确的步骤是，找款，看到喜欢的，让小妹给你拿出来，检查看下做工如何（主要看有没有凹陷等大毛病，小划痕之类的吹毛求疵的就算了），然后问今天金价多少？这个有没有精品工费？上称，扫码付钱。然后拿货扭头就走。 一般都没有包装的，可以问小妹哪里卖包装，主要卖场都有卖包装，价格几块到几十块的都有。 很多都支持旧金换款，可以带上旧金过去换。 一定不要问商家黄金是不是真的，如果一开口问黄金是否真的，商家知道你是小白，价格自然不会给你很合适。 提问流程：今日金价多少？工费多少？有没有精品费？工费高可以砍工费，金价是透明的就不要砍了也砍不下来。预估实际到手的每克金价，用手机记录一下。因为每家店的实际到手每克金价略有不同，记录下来可以对比一下，选择合适的店铺购买。不同工艺工费和精品费不同，一般来说 5G 最高，3D 次高，古法次之，素金最低。买完首饰别忘了要收据。 水贝买了黄金不要指望 商家给你配盒子之类的，基本都是袋子装的，（在金展负一楼的两个礼盒档口就可以买）自己也可以去周围卖包装的自行采购包装礼盒 10 元左右一个。 检测 实在不放心需要做检测的，可以去万山 B 座二楼中金质检，推荐这家的理由是比较方便好找，而且散客的价格很便宜，贵金属一份 10 元。其他鉴定机构散客的价格太贵了。收样时间是 10:00-17:00，超过 17 点有时候就要多收加急费用了。 检测机构只负责检测，不给你估价。把东西交给前台，会问你是什么名字或者哪家的，你就说你是散客零售自己来的。确认好件数，拿回执单，扫码查询进度。 检测机构对你买的珠宝没兴趣，不要迫害妄想觉得会偷你的金。鉴定过程比较久，一般 2 小时，可以去周边再去逛逛其他珠宝（因为周边实在是没啥吃的喝的玩的） 对买到的黄金实在不放心的话可以再去做个检测，这里很多地方都有质检机构，就说需要做材质复检就好了，没有实体商家会冒险售假。 参考 【保姆级】2021 最新水贝买金零售攻略 散客逛水贝买黄金攻略]]></content>
      <categories>
        <category>攻略</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>理财</tag>
        <tag>攻略</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Canvas 入门笔记]]></title>
    <url>%2F2023%2F02%2F18%2FCanvas%20%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[基础知识 默认大小：如果不设置宽高，canvas 的默认宽高是：width: 300px; height: 150px;。 替换内容：与&lt;img&gt;元素不同，&lt;canvas&gt;元素需要结束标签&lt;/canvas&gt;，如果结束标签不存在，则文档的其余部分会被认为是替代内容，将不会显示出来。 什么是替换内容，就是在某些东西加载不出来的时候（原因可能多种多样，比如浏览器太老不支持这个东西，比如网络不好加载不出），那么就给这些东西替换成其他内容，比如&lt;img&gt;标签就有 alt 属性用于在图片加载不出的时候显示文本。canvas标签也有相应的措施，用法是： 1234567&lt;canvas id="stockGraph" width="150" height="150"&gt; current stock price: $3.15 +0.15&lt;/canvas&gt;&lt;canvas id="clock" width="150" height="150"&gt; &lt;img src="images/clock.png" width="150" height="150" alt="" /&gt;&lt;/canvas&gt; 渲染上下文（The rendering context）：常用的渲染上下文有 2D，3D。2d 写法如下: 1234567const canvas = document.getElementById("canvas");if (canvas.getContext) &#123; const context = canvas.getContext("2d"); // drawing code here&#125; else &#123; // canvas-unsupported code here&#125; 2D 绘图坐标系直角坐标系，原点在左上角，x 轴向右为正，y 轴向下为正。 绘制图形不同于 SVG，&lt;canvas&gt; 只支持两种形式的图形绘制：矩形和路径（由一系列点连成的线段）。所有其他类型的图形都是通过一条或者多条路径组合而成的。不过，我们拥有众多路径生成的方法让复杂图形的绘制成为了可能。 绘制矩形三种绘制矩形的方法： 绘制一个填充矩形：fillRect(x, y, width, height) 绘制一个矩形边框：strokeRect(x, y, width, height) 清除一个矩形区域，让清除部分完全透明：clearRect(x, y, width, height) 绘制路径核心命令 5 个： beginPath() // 开始绘制 moveTo() // 移动画笔 closePath() // 闭合曲线 fill() // 填充曲线 stroke() // 绘制轮廓 closePath()不是必须的，用 fill()就能自动闭合曲线，但 stroke()不会自动闭合曲线，所以在如果想闭合曲线就要在 stroke()之前 closePath()一下 举个例子：画三角形 常见的路径 直线：lineTo(x, y) 圆弧： arc(x, y, radius, startAngle, endAngle, anticlockwise) // startAngle 和 endAngle 单位是弧度 arcTo(x1, y1, x2, y2, radius) 贝塞尔曲线： 二次贝塞尔曲线：quadraticCurveTo(cp1x, cp1y, x, y) 三次贝塞尔曲线：bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) 矩形：rect(x, y, width, height) Path2D 对象Path2D 对象用来缓存绘画命令，有三种构造方式： new Path2D(); // 空对象 new Path2D(path); // 克隆一个 Path2D 对象 new Path2D(d); // 从 svg 建立 Path2D 对象，例如：new Path2D(&quot;M10 10 h 80 v 80 h -80 Z&quot;); 还可以拼接 path： Path2D.addPath(path, transform?) // 添加一条路径到当前路径，可以设置变换矩阵 代码示例 样式和颜色 fillStyle = color // 填充色 strokeStyle = color // 轮廓色 globalAlpha = transparencyValue // 透明度，取值范围：0.0（完全透明）到 1.0（完全不透明） 颜色取值的四种写法： 1234ctx.fillStyle = "orange";ctx.fillStyle = "#FFA500";ctx.fillStyle = "rgb(255, 165,0 )";ctx.fillStyle = "rgba(255, 165, 0, 1)";]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Canvas</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数独游戏制作过程记录]]></title>
    <url>%2F2023%2F02%2F10%2F%E6%95%B0%E7%8B%AC%E6%B8%B8%E6%88%8F%E5%88%B6%E4%BD%9C%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[我打算自己做一个数独游戏，主要分为两步： 生成一个数独 验证玩家填入的数字是否正确 生成一个数独可以有很省事的办法，就是直接从数独库中随机选一个（甚至可以直接把空白都给你挖好）。也可以用暴力方法（回溯法），一行一行去填，进行不下去就回溯到上一步。 生成数独最高效的算法是：舞蹈链，实际上舞蹈链是一种数据结构，是为了X 算法而产生的，而 X 算法是用来解决一类问题：精确覆盖问题 插个题外话，我朋友说，东野圭吾的小说《嫌疑犯 X 的献身》，的凶手就在研究这个问题，有兴趣可以顺带看看，这小说挺有名的。 精确覆盖问题是一个 NP 完全问题，NP 问题的概念我差不多忘光了，得重新看看 精确覆盖问题简单来说就是给定一个全集 X，和若干子集 S，从子集中选出 N 个，它们拼凑起来恰好（没有多余的元素，比如某个元素出现过两次）等于全集 X。 X 算法维基百科的解说我看不懂，还好 OI-Wiki 上讲的足够详细：X 算法 解决精确覆盖问题，简单来说分为以下几个步骤： 建模针对问题建模，建模成一个 01 矩阵，每一行代表一个集合，1 代表包含了集合 X 的某个元素（1 的位置，就是该元素在集合 X 中的位置），0 代表没包含 算法步骤简化问题（缩小矩阵，删掉不再考虑的部分），递归解决子问题。 选行：选 1 出现次数最少的一列，然后从这列有 1 的行中随便选一行 删减：找到这一行的有 1 的那些列，去掉这些列，找到这些列上是 1 的行，去掉这些行 现已经得到了一个缩小版的矩阵，继续以上这种删减操作 单次深度搜索结束标志：得到一个空矩阵。是否有解：最后一次删除的行全部是 1，则说明问题有解，否则问题无解。总程序结束标志：回溯完所有可能的分支 这个算法很好的缩小了问题规模，非常典型的技巧 算法含义每选择一行，代表着打算用这一行去精确覆盖全集，那么相应的： 每行只用一次，故删除选择的这一行 这一行中出现的所有元素（每个 1 代表一个元素出现），后续都不用再考虑，故删除相关列 跟它起冲突的行（同一列上有 1，代表有相同的元素，不符合精确覆盖），没法纳入解中，所以后续都不用再考虑，故删除这些行 以上三步可以保证每次选择的行，行之间是不会出现重复元素的。 结束标志也很好理解，最后一次删除的行，如果全部是 1，则标志着我们所有列都刚好填补上了元素。 这样我们就做到了全覆盖+精确覆盖，这两项要求。 算法的具体实现具体代码实现，还有很多细节不清楚，参考资料： 跳跃的舞者，舞蹈链（Dancing Links）算法——求解精确覆盖问题 经过两天的设计与辛苦调试，我自己实现了一份 TypeScript 写的代码： https://github.com/liuqinh2s/Algorithm/blob/master/DancingLinksX/DancingLinksX.ts 与上面那个实现不同，我这个实现既有列头，又有行头，反正怎么方便怎么来。 数独怎么转化为精确覆盖问题参考资料：https://zhuanlan.zhihu.com/p/67447747 在网上查阅了大量资料，但一开始都看不懂，且发现他们讲的基本上一模一样（天下文章一大抄），就跟前面舞蹈链一样，连配图都是一样的。 怎么把数独这个矩阵转化为精确覆盖问题的 01 矩阵，其实就是要想清楚，行和列的意义是什么？ 行的意义精确覆盖问题的核心要素是：一个全集 X，若干子集 S 那么我们先来想想全集是什么？ 全集肯定是一幅完整的正确的数独答案 那每个子集是什么？ 子集应该是单个格子的解，然后我们拿恰好 81 个子集，凑出全集。 每个格子有 9 种填法，81 个格子有 729 种填法，所以我们需要从 729 个子集中选 81 个出来。 列的意义首先思考一下要往一个数独的格子里填入一个数字受哪些条件约束： 首先，这个格子里不能有数字，即为空 其次，同一行不能有相同数字 再次，同一列不能有相同数字 最后，同一个九宫格不能有相同数字 每个格子都有 4 个约束，81 个格子有 324 个约束，所以有 324 列，具体的每一列的含义如下： 第 0 列表示数独（0,0）位置是否有数字 第 1 列表示（0,1）位置是否有数字 …… 第 8 列表示（0,8）是否有数字 第 9 列表示（1,0）是否有数字 …… 第 80 列表示（8,8）是否有数字 以上 81 列表示数独的格子里是否有数字的约束条件，接着 81 列表示第 0 行是否有数字 1 82 列表示第 0 行是否有数字 2 …… 89 列表示第 0 行是否有数字 9 90 列表示第 1 行是否有数字 1 91 列表示第 1 行是否有数字 2 …… 161 列表示第 8 行是否有数字 9 以上为行的约束条件 162 列表示第 0 列是否有数字 1 …… 242 列表示第 8 列是否有数字 9 最后，是九宫格的约束条件： 243 列表示第 0 个九宫格是否有数字 1 244 列表示第 0 个九宫格是否有数字 2 …… 323 列表示第 8 个九宫格是否有数字 9 具体例子我们拿 4*4 的数独来做例子（只用到 1 到 4 四个数，可以称之为 2 阶数独吧，比咱们常玩的三阶数独小一阶）： 12340 4 0 00 0 0 00 0 0 00 0 0 0 这幅图转化成精确覆盖问题的矩阵是什么样呢？ 12第二个格子里填了数，其他没填 | 第一行填了数字4 | 第2列填了数字4 | 第1个4宫格填了数字40 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 | 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 | 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 上面用|划分了四个区域，每个区域的含义都详细说明了 从上述 01 行也能直接推出数独图，它们是可以互相推出的！ 当然也可以用复合数独图，推出复合行，但是复合行可能无法推出单个具体数独图，因为存在一对多的情况，一个很简单的例子就是全 1 的行，对应的是抽象的数独解，而数独解是有 N 个的。 数独的全部解有多少个？ 数独的总个数是这么得出来的。9!×722×27× 27,704,267,971=6,670,903,752,021,072,936,960（约有 6.67×10 的 21 次方）种组合，2005 年由 Bertram Felgenhauer 和 Frazer Jarvis 计算出该数字，如果将重复（如数字交换、对称等）不计算，那么有 5,472,730,538 个组合。那么有趣的来了，有个 9!=362880，这个就等于 9 的全排列，是不是可以从这里做突破口呢？如果我可以随机的生成 362880 个完整的数独矩阵，然后随机的每行挖去 4 到 5 个那就是 362880/24/120*9*362880=411505920 个，这个数字够大家有生之年玩的了。--摘录自数独-- 一个高效率生成数独的算法 真实性有待进一步考证 数独求解随便给出一个数独图，也就是相当于给出了舞蹈链中的一行，我们以这一行为入口，即可进行精确覆盖问题的求解，解空间是 729，对应的 01 矩阵大小是：729*324，不过还好是个稀疏矩阵。 有一个优化必须要说一下：每次选行的时候，选 1 最少的列上的某一行。 选 1 最少的列的意义是：寻找出现在所有子集中次数最少的元素，既然大家都很缺这个元素，那么基本上意味着凑全集合，很需要这个元素，那么就要优先选择这些元素 没加这个优化的时候，我的回溯一直在搞排列组合，无头苍蝇，跑了 60 多万次 dance 都没结果（几分钟都过去了），加了这个优化直接起飞，1 秒钟不到就解出来了。 我的数独求解代码：https://github.com/liuqinh2s/Algorithm/blob/master/SudoKu/SudoKu.ts 能直接在浏览器上跑的代码：https://github.com/liuqinh2s/Algorithm/blob/master/SudoKu/bundle.js 数独生成以上只讲了如何解数独，那么如何生成数独呢：数独的生成过程是怎样的？ - 单想的回答 - 知乎 简单来说就是：随机放入 11 个数，求解出终盘，然后挖洞。 数独背景知识初级课堂（3）|数独比你还优美，还有个性！比较精美的数独网站：Sudoku.com 数独难易判定]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[border-radius详解]]></title>
    <url>%2F2023%2F02%2F09%2Fborder-radius%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[看《CSS 解密》的时候遇到 border-radius 不是很懂，有个例子如下： 12border-radius: 100% 100% 0 0 / 100% 0 0 0; /* 左上角椭圆半径是半宽高 */border-radius: 100% 0 0 0 / 100% 0 0 0; /* 左上角椭圆半径是全宽高 */ 差别挺大的对吧，原因就是角与角之间出现了挤兑（或者说重叠），如果遇到了重叠怎么办呢？怎么表现呢？原理是什么？ 查官方文档，发现讲的很粗糙，但官方文档给出了一个specification（详细说明），这里面有一条Overlapping Curves，专门讲了这种情况怎么处理。 简单来说就是找最大的一处重叠，然后所有的半径都等比例缩小，比例是：重叠处的总长度/原本长度。 假如最大重叠处的长度是宽的两倍，那么所有半径都要缩小一半。 实验链接 通过这件事，我再次感概，最有效，最可靠的信息来自于官方，还有就是一定要熟练英文，不然连答案在哪都找不到。 关于缩写缩写 1（一个值）： 这种最简单 123border-radius: 100%;/*等价于*/border-radius: 100% 100% 100% 100%; 缩写 2（两个值）： 重复自身一遍 123border-radius: 100% 0;/*等价于*/border-radius: 100% 0 100% 0; 缩写 3（三个值）： 把中间这个值重复一遍 123border-radius: 100% 50% 100%;/*等价于*/border-radius: 100% 50% 100% 50%; 跟 margin 和 padding 的缩写是一模一样的]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AI时代来临，有哪些机遇我可以抓住？]]></title>
    <url>%2F2023%2F02%2F06%2FAI%E6%97%B6%E4%BB%A3%E6%9D%A5%E4%B8%B4%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%E6%9C%BA%E9%81%87%E6%88%91%E5%8F%AF%E4%BB%A5%E6%8A%93%E4%BD%8F%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[首先什么是 AI 时代，我所认为的 AI 是可以让计算机产生的智力，像类似于人一样工作，做以前简单的逻辑无法完成的事情，比如： 识别图片里的文字 识别图片里有没有猫 自动驾驶，识别路况 下棋，国际象棋，围棋，击败人类冠军 AI 换脸，将图片和视频中的人脸换成另一个人的 根据关键词，作画，写小说 上网搜集资料整合出摘要 以上都是 AI 目前已经能完成的事情，传统的代码是无法完成以上这种复杂的工作的。我把传统代码无法完成，又有点类似人才能办到的混沌且复杂的事情（甚至带有一些创造力）称作 AI。AI 不是指像人一样能通用的处理任何智力问题，而是能一个一个攻克具体的智力问题，AI 能做到的事情已经越来越多。其产生的生产力是巨大的，并不比互联网时代低。 有哪些机遇首先从我自己的角度出发，我希望 AI 能完成哪些事？ 提醒我要做哪些事，比如：我经常牙膏用到没有，每次刷牙的时候才想起来要买，但是回家的时候都不记得买。我当然知道可以自己定个日程或者闹钟提醒，但我定过几个，还是觉得比较麻烦 外卖自动订餐，我有的时候在公司工作，上午干活太投入，忘记定外卖 自动订火车票，关于订火车票我都总结出一些小窍门了，比如买短区间（没人抢）的或者全区间的（放票多，且要亏一部分钱，抢的人少） 数据转换，从图片中读取 excel，word 等等 带伞提醒，我老是忘记看天气预报，虽然深圳很少下雨，但偶尔还是需要提醒带伞 以上大部分都是一些提醒类的小事，可以归为生活管家类的一种体验升级。]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css居中的最佳实践]]></title>
    <url>%2F2022%2F12%2F13%2Fcss%E5%B1%85%E4%B8%AD%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[居中是 css 中很重要的一个基础知识，主要分三个方向讨论： 水平居中 or 垂直居中 文本居中 or 容器居中（块级元素） 设置父容器 or 设置自身 or 都需要设置 最佳实践最佳实践，都是通过给父容器设置样式，来使内容达到居中效果。这个设计哲学也是非常正确的，我们确实应该通过操作父容器来让其内容居中，居中并非是子元素需要考虑的事（因为子元素可能有多个，且其自身可能比较复杂）。 文本居中水平居中文本水平居中使用text-align: center;： 12345.center&#123; text-align: center; border: 2px solid red;&#125;&lt;div class="center"&gt;我是文本&lt;/div&gt; 这个非常好使，单行和多行文本都可以处理。 text-align 文档 垂直居中使用 line-height 可以调节文本的垂直间距，从而达到垂直居中的效果，不过如果是多行文本的话，需要知道行数，但大多数情况下都是不知道行数的，所以一般用于单行文本的垂直居中场景。 实验地址：https://replit.com/@liuqinh2s1/cssTest3#src/App.css 实际上多行文本垂直居中可以用跟容器居中一样的方法：flex 布局： https://replit.com/@liuqinh2s1/css-center2#index.html 同样的也适用于单行，甚至单行文本水平居中也可以用 flex 布局，但多行文本水平居中不可以用 flex 布局 容器居中容器居中的最佳实践是 flex 布局。如果想看详细的教程，推荐这个：Flex 布局教程：语法篇 - 阮一峰的网络日志 实验地址：https://replit.com/@liuqinh2s1/css-center#index.html 水平居中如果是水平排布的，设置justify-content: center;： 12345678.center &#123; display: flex; justify-content: center;&#125;&lt;div class="center"&gt; &lt;div&gt;a&lt;/div&gt; &lt;div&gt;b&lt;/div&gt;&lt;/div&gt; 如果是垂直排布的，设置align-items: center;： 123456789.center &#123; display: flex; flex-direction: column; align-items: center;&#125;&lt;div class="center"&gt; &lt;div&gt;a&lt;/div&gt; &lt;div&gt;b&lt;/div&gt;&lt;/div&gt; 垂直居中与上面水平居中的写法正好相反 如果是水平排布的，设置align-items: center;： 12345678.center &#123; display: flex; align-items: center;&#125;&lt;div class="center"&gt; &lt;div&gt;a&lt;/div&gt; &lt;div&gt;b&lt;/div&gt;&lt;/div&gt; 如果是垂直排布的，设置justify-content: center;： 123456789.center &#123; display: flex; flex-direction: column; justify-content: center;&#125;&lt;div class="center"&gt; &lt;div&gt;a&lt;/div&gt; &lt;div&gt;b&lt;/div&gt;&lt;/div&gt; 所以总结如下：除多行文本水平居中必须用text-align: center;外，其余情况，全部可以用 flex 布局解决。 补充利用 position，50%和 transform 自身的一半高来达到居中： 123456789101112131415.parent&#123; height: 200px; border: 2px solid red; position: relative;&#125;.child&#123; height: 100px; border: 1px solid blue; position: absolute; top: 50%; transform: translate(0, -50%);&#125;&lt;div class="parent"&gt; &lt;div class="child"&gt;1&lt;/div&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>前端</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[行内元素和块级元素]]></title>
    <url>%2F2022%2F12%2F08%2F%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0%E5%92%8C%E5%9D%97%E7%BA%A7%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[行内元素和块级元素算是 css 中最基础，也是最重要的部分了。但我对这部分还没彻底研究透，需要彻底掌握才行。 比如，width 和 height 跟父节点和子节点的关系到底是什么，默认是什么？行内元素的 padding 和 margin 能设置吗？ 行内元素，也叫内联元素，inline-element 对比包含关系块级元素可以包含块级元素或者行内元素，行内元素只能包含行内元素。但这只是建议，并非强制，即便行内元素包含块级元素也不会报错。 换行块级元素独占一行，前后都不可以有块级元素或者行内元素（当然 display: flex;可以让几个块级元素放在同一行）。行内元素们可以排列在同一行里，直到这一行放不下才换行。 一个单词是不会换行的发现行内元素居然不会换行，原来是因为被当成一个单词了 实验：https://replit.com/@liuqinh2s1/cssTest2#src/App.tsx 用样式可以控制每个字母换行： 12word-break: break-all;word-wrap: break-word; 宽高块级元素可以设置宽高，行内元素不能设置宽高（即：width 和 height）。但行内元素可以设置 line-height（没有 line-width）。 默认宽高块级元素默认继承父盒子的宽度，但高度不会继承（想要继承可以设置成height: 100%;），由内容物撑开或者自己设置。行内元素不能设置宽高，也不继承宽高，宽高都由内容物撑开。 边距块级元素的 margin 和 padding 会对外产生边距效果，行内元素的 margin 和 padding 在水平方向上会对外产生效果，垂直方向上不会对外产生效果。实验：https://replit.com/@liuqinh2s1/css-test1#src/App.tsx display: inline，inline-block，block 的区别定义成 inline 就是行内元素，block 就是块级元素。它们的区别前面已经讲过了 inline-block 是它们二者的综合，本质上也是个 block，除了不会独占一行。 实验例子：https://www.w3school.com.cn/tiy/t.asp?f=css_inline-block_span 子元素怎么撑满剩余的空间？用 flex-grow 去撑满剩余的空间，具体怎么写： 用 display: flex，然后 flex: 1，即可。flex: 1 的含义是 flex: 1 1 auto。也就是 flex-grow: 1; flex-shrink: 1; flex-basis: auto。 flex，flex-grow，flex-shrink，flex-basis这个东西的计算公式官网没有公布，导致只能查别人写的资料，或者自己推导。经过多次实验后，结论如下： grow 的计算跟自身宽高无关，直接按比例分配剩余的空间，shrink 的计算是跟自身宽高有关的，需要根据自身宽高，按加权比例平摊（缩减）超出的空间。 假设计算的是水平方向的 flex： grow 的算法如下： 单个元素需要 grow 的量：(单个子元素 flex-grow/总的 flex-grow)\*(父容器宽度-子元素宽度之和) shrink 的算法如下： 假设 div1 是 100px, flex-shrink:1；div2 是 200px, flex-shrink:2；div3 是 300px, flex-shrink: 3。容器宽度 700px div1 元素需要 shrink 的量：(100*1)/(100*1+200*2+300*3)\*(700-100-200-300) 也就是加权比例，需要用到自身的宽高 flex-basis 就是宽高的意思，但比宽高优先级高，比如定义了 width: 100px; flex-basis: 0px;那么就是按 0 去进行 flex 的。 实验地址：https://replit.com/@liuqinh2s1/css-flex#src/App.tsx]]></content>
      <categories>
        <category>前端</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加密货币收藏网址]]></title>
    <url>%2F2022%2F11%2F30%2F%E5%8A%A0%E5%AF%86%E8%B4%A7%E5%B8%81%E6%94%B6%E8%97%8F%E7%BD%91%E5%9D%80%2F</url>
    <content type="text"><![CDATA[Getting started | Bitcoin Design 老币： 乌龟币(TRTL)矿池 门罗币(XMR)网页钱包 门罗币矿池 BSC 链项目： bunny 矿池 pancake beefy jetswap BNB Smart Chain Explorer LOWB LOWB 跨链桥 BSC 桥 KCC 链： 文档 区块查询 AxieInfinity： axie market 账号中心 白皮书 axie zone axie tech axie world axieinfinity github katana AXS Staking 快乐区块维基 【以太坊】深入理解 gas 机制 evm-opcode-gas-costs 空投： airdrops.io defi llama 智能合约： Provider Migration Guide | MetaMask Docs How to Become a Blockchain Engineer | by Patrick Collins | Better Programming HTMoon DOG 区块链技术-智能合约 Solidity 编程语言 代币 YELD 价格直接跳水归零：PolyYeld Finance 被攻击事件全解析 以太坊智能合约安全入门了解一下（上） 智能合约入门 1——Remix+合约调用 智能合约入门 智能合约入门 Ethernaut Security Innovation Blockchain CTF 智能合约安全入门:ETHERNAUT-WriteUp blockchain-ctf 靶场（0-12） Ethernaut 靶场刷题（上） 免费领取测试网络币：Rinkeby Authenticated Faucet CryptoZombies - 编游戏的同时学习以太坊的智能协议. Loom Network 产品。 remix]]></content>
      <categories>
        <category>加密货币</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode 902. 最大为 N 的数字组合]]></title>
    <url>%2F2022%2F11%2F29%2Fleetcode%20902.%20%E6%9C%80%E5%A4%A7%E4%B8%BA%20N%20%E7%9A%84%E6%95%B0%E5%AD%97%E7%BB%84%E5%90%88%2F</url>
    <content type="text"><![CDATA[这题是数位 dp 类型的题，遍历对象有两个： 遍历 N 的每一位 遍历 digits 问题规模是 N 的位数。 状态转移方程是这样思考得出： 在遍历 digits 时，设当前 digits 的值为 digits[i]： 如果 digits[i]比 N 的第 j 位的数字小，则低位的数字就可以任意，那么由 digits[i]开头所产生的组合数是：digits.length**(j-1)。 如果 digits[i]等于 N 的第 j 位数字，则还要继续对比第 j-1 位才知道能否凑出一个比 N 小的，也即递归，缩小问题规模。产生组合：dp[j-1] 如果 digits[i]大于 N 的第 j 位数字，则后面低位的数字不管是什么，都已经不能产生小于 N 的组合了。产生组合：0 把每个 digits[i]对应的结果加起来，就是当前问题规模（问题规模为：j）的答案。 状态转移方程： 12345if (digits[i] &lt; N[j]) &#123; dp[j] += digits.length ** (j - 1);&#125; else if (digits[i] == N[j]) &#123; dp[j] += dp[j - 1];&#125; 代码： 12345678910111213141516171819function atMostNGivenDigitSet(digits: string[], n: number): number &#123; const nStr = n.toString(); const dp = new Array(nStr.length).fill(0); const memo = []; for (let i = 1, res = 1; i &lt; nStr.length; i++) &#123; memo.push((res = res * digits.length)); &#125; for (let i = 0; i &lt; nStr.length; i++) &#123; for (let j = 0; j &lt; digits.length; j++) &#123; if (digits[j] &lt; nStr[nStr.length - 1 - i]) &#123; dp[i] += i &gt; 0 ? memo[i - 1] : 1; &#125; else if (digits[j] == nStr[nStr.length - 1 - i]) &#123; console.log(digits[j], nStr[nStr.length - 1 - i], dp); dp[i] += i &gt; 0 ? dp[i - 1] : 1; &#125; &#125; &#125; return memo.reduce((a, b) =&gt; a + b, 0) + dp[dp.length - 1];&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue.js响应系统的实现 第一篇]]></title>
    <url>%2F2022%2F11%2F06%2Fvue.js%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9E%E7%8E%B0%20%E7%AC%AC%E4%B8%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[什么是副作用函数？如果一个函数只是接收输入，然后输出，没有影响外部（比如修改外部变量），那么我们就说这个函数没有副作用，反之就是有副作用。理想的情况下，我们希望所有的函数都很纯粹，没有副作用。 举个例子： 123function effect() &#123; document.body.innerText = "hello vue3";&#125; Proxy我们都知道 vue.js 这类框架是声明式的，当数据发生变化，它可以监听到并重新渲染，那么这种响应系统是如何实现的呢？首先一个问题就是怎么监听到数据的变化。答案是 Proxy，vue2 用了Object.defineProperty()函数，这是 es2015 之前的做法，vue3 则是用了 es2015 带来的新特性：Proxy。 通过 Proxy 我们可以监听到数据的变化（set），那就可以调用副作用函数更新 dom 了。 最简单的响应系统设计如下： 123456789101112131415161718function effect(data) &#123; document.body.innerText = data.text;&#125;const data = &#123; text: "hello vue3" &#125;;const obj = new Proxy(data, &#123; get(target, key) &#123; return target[key]; &#125;, set(target, key, value) &#123; target[key] = value; effect(target); return true; &#125;,&#125;);// 首次渲染effect(data);// set操作，触发重新渲染obj.text = "11"; // 这里必须要修改obj对象（改data是监听不到的） 下面开始，都是需求变化产生的代码变化了。 如果有多个副作用函数需要注册，怎么办？ 如果这些多个副作用函数，监听的是这个对象的不同 key，怎么办？ 如果这些多个副作用函数，监听的是多个对象的不同 key，怎么办？ 分支切换 如果有多个副作用函数需要注册，怎么办？代码如下： 1234567891011121314151617181920212223function effect1(data) &#123; document.body.innerText = data.text;&#125;function effect2(data) &#123; document.body.setAttribute(data.text);&#125;const data = &#123; text: "hello vue3" &#125;;const obj = new Proxy(data, &#123; get(target, key) &#123; return target[key]; &#125;, set(target, key, value) &#123; target[key] = value; effect1(target); effect2(target); return true; &#125;,&#125;);// 首次渲染effect1(obj);effect2(obj);// set操作，触发重新渲染obj.text = "11"; // 这里必须要修改obj对象（改data是监听不到的） 这样写，显然很不灵活（因为要去修改已经写好的代码），那么怎么设计才能不去动已经写好的代码呢？答案是传回调函数： 1234567891011121314151617181920212223242526const bucket = new Set();function useEffect(fn, data) &#123; bucket.add(fn); return fn(data);&#125;const data = &#123; text: "hello vue3" &#125;;const obj = new Proxy(data, &#123; get(target, key) &#123; return target[key]; &#125;, set(target, key, value) &#123; target[key] = value; bucket.forEach((fn) =&gt; fn(target)); return true; &#125;,&#125;);// 首次渲染useEffect((data) =&gt; &#123; document.body.innerText = data.text;&#125;, data);useEffect((data) =&gt; &#123; document.body.setAttribute("a", data.text);&#125;, data);// set操作，触发重新渲染obj.text = "11"; // 这里必须要修改obj对象（改data是监听不到的） 这样的写法，是不是很像 react 的 useEffect()了。 如果这些多个副作用函数，监听的是这个对象的不同 key，怎么办？用个 Map，让 key 和回调函数一一对应即可，但如何知道副作用函数用了哪个 key 呢？如果是在 useEffect 里面显然是不知道的，但用没用 key，用了哪个 key，Proxy 里面的 get 拦截函数是一清二楚的，所以我们应该在这里添加副作用函数！但 get 拦截函数里面又不知道，当前获取数据的函数是哪个，很简单，我们设置一个 activeEffect 来记录当前的函数。但需要注意的是，一但我们开始在 get 里面注册响应，每次调用副作用函数就会调用注册响应，这个时候需要更新 activeEffect。 12345678910111213141516171819202122232425262728293031323334353637383940let activeEffect;const bucket = new Map();function useEffect(fn, data) &#123; function effectFn(data) &#123; activeEffect = effectFn; return fn(data); &#125; return effectFn(data);&#125;const data = &#123; text: "hello vue3", a: "11" &#125;;const obj = new Proxy(data, &#123; get(target, key) &#123; if (activeEffect) &#123; const effects = bucket.get(key); if (!effects) &#123; bucket.set(key, new Set([activeEffect])); &#125; else &#123; effects.add(activeEffect); &#125; &#125; return target[key]; &#125;, set(target, key, value) &#123; target[key] = value; const effects = bucket.get(key); effects &amp;&amp; effects.forEach((fn) =&gt; fn(target)); return true; &#125;,&#125;);// 首次渲染useEffect((data) =&gt; &#123; document.body.innerText = data.text;&#125;, obj); // 这里也要传obj了，不然get的时候，也是监听不到的useEffect((data) =&gt; &#123; document.body.setAttribute("a", data.a);&#125;, obj);// set操作，触发重新渲染obj.text = "hello aaaa"; // 这里必须要修改obj对象（改data是监听不到的）obj.a = "222"; 这样就实现了对单个对象的多个不同 key 注册多个副作用函数，进行响应式渲染。 而且，我们可以把其中处理副作用函数的逻辑抽出来： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546let activeEffect;const bucket = new Map();function useEffect(fn, data) &#123; function effectFn(data) &#123; activeEffect = effectFn; return fn(data); &#125; return effectFn(data);&#125;const data = &#123; text: "hello vue3", a: "11" &#125;;const obj = new Proxy(data, &#123; get(target, key) &#123; track(key); return target[key]; &#125;, set(target, key, value) &#123; target[key] = value; trigger(target, key); return true; &#125;,&#125;);function track(key) &#123; if (activeEffect) &#123; const effects = bucket.get(key); if (!effects) &#123; bucket.set(key, new Set([activeEffect])); &#125; else &#123; effects.add(activeEffect); &#125; &#125;&#125;function trigger(target, key) &#123; const effects = bucket.get(key); effects &amp;&amp; effects.forEach((fn) =&gt; fn(target));&#125;// 首次渲染useEffect((data) =&gt; &#123; document.body.innerText = data.text;&#125;, obj);useEffect((data) =&gt; &#123; document.body.setAttribute("a", data.a);&#125;, obj);// set操作，触发重新渲染obj.text = "hello aaaa";obj.a = "222"; 如果这些多个副作用函数，监听的是多个对象的不同 key，怎么办？再加一个 Map 即可，而且由于键是个对象，最好用 WeakMap： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758let activeEffect;const bucket = new WeakMap();function useEffect(fn, data) &#123; function effectFn(data) &#123; activeEffect = effectFn; return fn(data); &#125; return effectFn(data);&#125;const data1 = &#123; text: "hello vue3", a: "11" &#125;;const data2 = &#123; text2: "hello vue2", b: "22" &#125;;const obj1 = createProxyObj(data1);const obj2 = createProxyObj(data2);function createProxyObj(data) &#123; return new Proxy(data, &#123; get(target, key) &#123; track(target, key); return target[key]; &#125;, set(target, key, value) &#123; target[key] = value; trigger(target, key); return true; &#125;, &#125;);&#125;function track(target, key) &#123; if (activeEffect) &#123; let effectsOnTarget = bucket.get(target); if (!effectsOnTarget) &#123; bucket.set(target, (effectsOnTarget = new Map())); &#125; let effects = effectsOnTarget.get(key); if (!effects) &#123; effectsOnTarget.set(key, (effects = new Set())); &#125; effects.add(activeEffect); &#125;&#125;function trigger(target, key) &#123; const effectsOnTarget = bucket.get(target); if (effectsOnTarget) &#123; const effects = effectsOnTarget.get(key); effects &amp;&amp; effects.forEach((fn) =&gt; fn(target)); &#125;&#125;// 首次渲染useEffect((data) =&gt; &#123; document.body.innerText = data.text;&#125;, obj1);useEffect((data) =&gt; &#123; document.body.setAttribute("b", data.b);&#125;, obj2);// set操作，触发重新渲染obj1.text = "hello aaaa";obj2.b = "333"; 分支切换目前来说： 首次执行副作用函数会触发 get，get 会把副作用函数添加为响应函数。 然后更新值的时候会触发 set，set 会执行响应函数，执行响应函数又会触发 get，get 会把副作用函数添加为响应函数。 也就是说每次更新值都会重新添加响应函数，似乎很冗余，能否只执行一次呢？答案是不能，因为可能存在分支，例如： 12345678const data = &#123; ok: true, text: "hello world" &#125;;const obj = new Proxy(data, &#123; /* ... */&#125;);useEffect(function effectFn() &#123; document.body.innerText = obj.ok ? obj.text : "not";&#125;, obj); 当 obj.ok 为 true 的时候，obj.text 的响应函数会记录下副作用函数，但如果 obj.ok 为 false 的时候，修改 obj.text 其实不用执行副作用函数了，但由于之前添加过，所以还是会执行。 所以我们不仅要重新添加响应函数，还需要清理之前添加的。这样每次添加的响应函数才会是准确无误的。 为了清理响应函数，比较粗暴一点的是遍历 bucket 中的每个 target 的每个 key，然后对其 set 集合执行 delete()方法，但这样显然不太好，我们可以记录一下哪些集合存了当前副作用函数，只对这些集合执行 delete()方法。 代码如下： 12345678910111213141516171819202122232425262728293031function useEffect(fn, data) &#123; effectFn.records = []; return effectFn(data); function effectFn(data) &#123; cleanup(effectFn); activeEffect = effectFn; return fn(data); function cleanup(effectFn) &#123; for (let i = 0; i &lt; effectFn.records.length; i++) &#123; effectFn.records[i].delete(fn); &#125; &#125; &#125;&#125;function track(target, key) &#123; if (activeEffect) &#123; let effectsOnTarget = bucket.get(target); if (!effectsOnTarget) &#123; bucket.set(target, (effectsOnTarget = new Map())); &#125; let effects = effectsOnTarget.get(key); if (!effects) &#123; effectsOnTarget.set(key, (effects = new Set())); &#125; effects.add(activeEffect); activeEffect.records.push(effects); // 新增 &#125;&#125; 我们改写了 useEffect，增加了一个 records 来记录需要清理哪些集合，在每次重新添加响应之前，清理掉旧的响应。并在 track 函数里面对这个 records 进行填充。 但还存在一个问题，这个问题比较隐秘，那就是遍历的时候对遍历对象进行 add 和 delete 操作，trigger 中我们执行响应函数，响应函数会对桶先 cleanup 再重新添加，但这个时候我们还在遍历桶啊，所以就相当于这样： 1234567const set = new Set([1]);set.forEach((item) =&gt; &#123; set.delete(1); set.add(1); console.log("遍历中");&#125;); 这会造成死循环，解决的办法，自然是不对遍历的对象增删，新搞个对象进行增删。修改后的代码如下： 1234567function trigger(target, key) &#123; const effectsOnTarget = bucket.get(target); if (effectsOnTarget) &#123; const effects = effectsOnTarget.get(key); effects &amp;&amp; [...effects].forEach((fn) =&gt; fn(target)); // 修改，不对原集合进行一边遍历一边增删 &#125;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaScript执行上下文之作用域链]]></title>
    <url>%2F2022%2F07%2F14%2FJavaScript%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%2F</url>
    <content type="text"><![CDATA[执行上下文中有个作用域链，当查找一个变量时会顺着这个链找。 函数的作用域在函数定义的时候就决定了。这是因为函数对象有个内部属性[[scope]] 函数的生命周期分为：函数创建 和 函数调用。 函数创建的时候，会把其所处执行上下文的作用域链直接赋值给函数的内部属性[[scope]]（这就是词法作用域的原理了），函数调用的时候会创建自己的执行上下文，并把自己的AO和[[scope]]合并成新的作用域链： 假设要实现动态作用域的话，[[scope]]就得在调用时去执行上下文栈的上一帧去取。 1Scope = [AO].concat([[scope]]); 实例剖析123456var scope = "global scope";function checkscope() &#123; var scope2 = "local scope"; return scope2;&#125;checkscope(); 执行过程如下： 全局执行上下文创建，其作用域链就只有自身的 VO，然后将全局上下文压栈： 1234567ECStack = [];globalContext = &#123; VO, Scope: [VO], this: window,&#125;;ECStack.push(globalContext); checkscope 函数被创建，保存当前执行上下文的作用域链到 checkscope 函数的内部属性[[scope]]（这一步是词法作用域实现的关键） 1checkscope.[[scope]] = globalContext.Scope; 调用 checkscope 函数，函数并不立刻执行，开始做准备工作，生成执行上下文，并压入执行上下文栈： AO：用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明 Scope：复制函数[[scope]]属性创建作用域链，将活动对象压入 checkscope 作用域链顶端 this 12345678910checkscopeContext = &#123; AO: &#123; arguments: &#123; length: 0, &#125;, scope2: undefined, &#125;, Scope: [AO, [[Scope]]],&#125;;ECStack.push(checkscopeContext); 准备工作做完，开始执行函数，随着函数的执行，修改 AO 的属性值，查找到 scope2 的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出 12345678910checkscopeContext = &#123; AO: &#123; arguments: &#123; length: 0, &#125;, scope2: "local scope", &#125;, Scope: [AO, [[Scope]]],&#125;;ECStack.pop(); 每一步中具体的实现细节我们无法得知（因为可以有多种实现手法），但这 5 步却是真实存在的（因为可以通过例子验证）。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 闭包]]></title>
    <url>%2F2022%2F07%2F14%2FJavaScript%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[闭包是干什么用的本质上闭包就是为了拓展查找自由变量的范围 MDN 对闭包的定义为： A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment) 一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。 123456789function init() &#123; var name = 'Mozilla'; // name is a local variable created by init function displayName() &#123; // displayName() is the inner function, a closure console.log(name); // use variable declared in the parent function &#125; displayName();&#125;init(); name 是 displayName 函数所处环境中的变量，它们一起构成了闭包。而闭包的实现依赖于执行上下文中的作用域链。 上面这个例子有点平平无奇了，让我们看一个神奇一点的例子： 1234567891011var scope = "global scope";function checkscope()&#123; var scope = "local scope"; function f()&#123; return scope; &#125; return f;&#125;var foo = checkscope();foo(); 这里直接给出简要的执行过程： 进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈 全局执行上下文初始化 执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈 checkscope 执行上下文初始化，创建变量对象、作用域链、this 等 checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出 执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈 f 执行上下文初始化，创建变量对象、作用域链、this 等 f 函数执行完毕，f 函数上下文从执行上下文栈中弹出 了解到这个过程，我们应该思考一个问题，那就是： 当 f 函数执行的时候，checkscope 函数上下文已经被销毁了啊(即从执行上下文栈中被弹出)，怎么还会读取到 checkscope 作用域下的 scope 值呢？ 以上的代码，要是转换成 PHP，就会报错，因为在 PHP 中，f 函数只能读取到自己作用域和全局作用域里的值，所以读不到 checkscope 下的 scope 值。 然而 JavaScript 却是可以的！ 当我们了解了具体的执行过程后，我们知道 f 执行上下文维护了一个作用域链： 123fContext = &#123; Scope: [AO, checkscopeContext.AO, globalContext.VO],&#125;; 对的，就是因为这个作用域链，f 函数依然可以读取到 checkscopeContext.AO 的值，说明当 f 函数引用了 checkscopeContext.AO 中的值的时候，即使 checkscopeContext 被销毁了，但是 JavaScript 依然会让 checkscopeContext.AO 活在内存中（因为还有别的引用在，所以不会进行垃圾回收），f 函数依然可以通过 f 函数的作用域链找到它，正是因为 JavaScript 做到了这一点，从而实现了闭包这个概念。 所以，让我们再看一遍实践角度上闭包的定义： 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回） 在代码中引用了自由变量 在这里再补充一个《JavaScript 权威指南》英文原版对闭包的定义: This combination of a function object and a scope (a set of variable bindings) in which the function’s variables are resolved is called a closure in the computer science literature. 闭包在计算机科学中也只是一个普通的概念，大家不要去想得太复杂。 经典面试题1234567891011var data = [];for (var i = 0; i &lt; 3; i++) &#123; data[i] = function () &#123; console.log(i); &#125;;&#125;data[0]();data[1]();data[2](); 答案是全是 3，因为这里的 i 是直接从全局上下文中读取到的，让我们多加一层闭包： 12345678910111213var data = [];for (var i = 0; i &lt; 3; i++) &#123; data[i] = (function (i) &#123; return function () &#123; console.log(i); &#125;; &#125;)(i);&#125;data[0]();data[1]();data[2](); 这里写了个立即执行函数，由它创建了一个闭包：立即执行函数的 AO + 内层函数，这个闭包中有个自由变量 i，来自这个立即执行函数的形参，形参在每次立即执行后会被分别赋值 0,1,2。而内层函数被返回给这个 data 数组，当内层函数执行时，顺着作用域链查找 i，会先从立即执行函数的 AO 中读取到 i，就会分别读取到 0,1,2。 参考 JavaScript 深入之闭包 闭包 - mdn]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaScript执行上下文之变量对象]]></title>
    <url>%2F2022%2F07%2F13%2FJavaScript%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B9%8B%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[执行上下文中包含哪些东西对于每个执行上下文，都有三个重要属性： 变量对象(Variable object，VO) 作用域链(Scope chain) this 本篇就来讲讲第一个变量对象 全局上下文 在顶层 JavaScript 代码中，可以用关键字 this 引用全局对象。因为全局对象是作用域链的头，这意味着所有非限定性的变量和函数名都会作为该对象的属性来查询。 例如，当 JavaScript 代码引用 parseInt() 函数时，它引用的是全局对象的 parseInt 属性。全局对象是作用域链的头，还意味着在顶层 JavaScript 代码中声明的所有变量都将成为全局对象的属性。 在浏览器中，全局对象有 window 指向自身 也就是说在全局执行上下文中，所有未限定的变量都挂在全局对象上，从全局对象中读写。比如: 1234567var a = 1;console.log(a);console.log(this.a);console.log(window.a);console.log(this.window.a);// 但是不能写console.log(window.this.a); 执行过程JavaScript 代码在进入一段代码环境时，会分为两个阶段： 代码分析（进入执行上下文） 代码执行 进入执行上下文当进入执行上下文时，这时候还没有执行代码， 变量对象会包括三类： 函数的所有形参 (如果是函数上下文) 由名称和对应值组成的一个变量对象的属性被创建 没有实参，属性值设为 undefined 函数声明 由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建 如果变量对象已经存在相同名称的属性，则完全替换这个属性 变量声明 由名称和对应值（undefined）组成一个变量对象的属性被创建 如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性 12345678910function foo(a) &#123; var b = 2; function c() &#123;&#125; var d = function() &#123;&#125;; b = 3;&#125;foo(1); 在进入执行上下文后，这时候的 AO 是： 12345678910AO = &#123; arguments: &#123; 0: 1, length: 1 &#125;, a: 1, b: undefined, c: reference to function c()&#123;&#125;, d: undefined&#125; 代码执行还是上面的例子，当代码执行完后，这时候的 AO 是： 12345678910AO = &#123; arguments: &#123; 0: 1, length: 1 &#125;, a: 1, b: 3, c: reference to function c()&#123;&#125;, d: reference to FunctionExpression "d"&#125; 思考题第一题123456function foo() &#123; console.log(a); a = 1; // 相当于挂在全局对象上&#125;foo(); // ??? 会报错，Uncaught ReferenceError: a is not defined 这是因为函数中的 &quot;a&quot; 并没有通过 var 关键字声明，所有不会被存放在 AO 中。 第一段执行 console 的时候， AO 的值是： 12345AO = &#123; arguments: &#123; length: 0 &#125;&#125; 没有 a 的值，然后就会到全局去找，全局也没有，所以会报错。 123456function foo() &#123; console.log(a); var a = 1;&#125;foo(); // ??? 改成这样，有变量提升就不会报错了。打印 undefined 或者先挂在全局对象上 12345function bar() &#123; a = 1; console.log(a);&#125;bar(); // ??? 打印 1 第二题1234567console.log(foo);function foo()&#123; console.log("foo");&#125;var foo = 1; 会打印函数，而不是 undefined 。 这是因为在进入执行上下文时，首先会处理函数声明，其次会处理变量声明，如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。 参考 JavaScript 深入之变量对象]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaScript执行上下文栈]]></title>
    <url>%2F2022%2F07%2F12%2FJavaScript%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88%2F</url>
    <content type="text"><![CDATA[顺序执行？代码示例 1： 123456789101112131415var foo = function () &#123; console.log('foo1');&#125;foo(); // foo1var foo = function () &#123; console.log('foo2');&#125;foo(); // foo2 代码示例 2： 123456789101112131415function foo() &#123; console.log('foo1');&#125;foo(); // foo2function foo() &#123; console.log('foo2');&#125;foo(); // foo2 第一个例子中用到了变量提升，第二个例子中用到了函数提升。JavaScript 引擎并非一行一行地分析和执行程序，而是一段一段地分析执行。当执行一段代码的时候，会进行一个“准备工作”。到底 JavaScript 引擎遇到一段怎样的代码时才会做“准备工作”呢？ 可执行代码JavaScript 总共有三种可执行的代码： 全局代码 函数代码 eval 代码 执行上下文栈JavaScript 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文 123456789var scope = "global scope";function checkscope()&#123; var scope = "local scope"; function f()&#123; return scope; &#125; return f();&#125;checkscope(); 123456789var scope = "global scope";function checkscope()&#123; var scope = "local scope"; function f()&#123; return scope; &#125; return f;&#125;checkscope()(); 上面这个例子中，执行上下文栈的变化就不一样 让我们模拟第一段代码： 1234ECStack.push(&lt;checkscope&gt; functionContext);ECStack.push(&lt;f&gt; functionContext);ECStack.pop();ECStack.pop(); 让我们模拟第二段代码： 1234ECStack.push(&lt;checkscope&gt; functionContext);ECStack.pop();ECStack.push(&lt;f&gt; functionContext);ECStack.pop(); 执行上下文中包含哪些东西对于每个执行上下文，都有三个重要属性： 变量对象(Variable object，VO) 作用域链(Scope chain) this 参考 JavaScript 深入之执行上下文栈]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaScript词法作用域]]></title>
    <url>%2F2022%2F07%2F11%2FJavaScript%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[有两种作用域： 动态作用域 静态作用域（也叫：词法作用域，lexical scoping） JavaScript 采用的是词法作用域 什么是作用域作用域，顾名思义是用来表示一个变量作用的范围。 这两种作用域的区别是什么让我们看一个例子就能知道： 1234567891011121314var value = 1;function foo() &#123; console.log(value);&#125;function bar() &#123; var value = 2; foo();&#125;bar();// 结果是 ??? 如果是静态作用域，那么答案是 1，因为 value 这个变量在函数定义的时候就已经决定了。如果是动态作用域，那么答案是 2，value 这个变量要等函数执行的时候才定下来。 静态作用域执行过程执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据书写的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。而且如果去掉var value = 1;这一句，会报变量未定义错误。 动态作用域执行过程执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2。 前面我们已经说了，JavaScript 采用的是静态作用域，所以这个例子的结果是 1。 bash 脚本采用的是动态作用域: 123456789value=1function foo () &#123; echo $value;&#125;function bar () &#123; local value=2; foo;&#125;bar 这个例子会打印 2 思考题123456789var scope = "global scope";function checkscope()&#123; var scope = "local scope"; function f()&#123; return scope; &#125; return f();&#125;checkscope(); 123456789var scope = "global scope";function checkscope()&#123; var scope = "local scope"; function f()&#123; return scope; &#125; return f;&#125;checkscope()(); 这两个例子中，虽然函数执行的环境不一样，但打印的结果是一样的，因为还是那个原因，JavaScript 的作用域是静态作用域 引用犀牛书中的一段话 Like most modern programming languages, JavaScript uses lexical scoping. This means that functions are executed using the variable scope that was in effect when they were defined, not the variable scope that is in effect when they are invoked. In order to implement lexical scoping, the internal state of a JavaScript function object must in- clude not only the code of the function but also a reference to the current scope chain. (Before reading the rest of this section, you may want to review the material on variable scope and the scope chain in §3.10 and §3.10.3.) This combination of a function object and a scope (a set of variable bindings) in which the function’s variables are resolved is called a closure in the computer science literature. (This is an old term that refers to the fact that the function’s variables have bindings in the scope chain and that therefore the function is “closed over” its variables.) Technically, all JavaScript functions are closures: they are objects, and they have a scope chain associated with them. Most functions are invoked using the same scope chain that was in effect when the function was defined, and it doesn’t really matter that there is a closure involved. Closures become interesting when they are invoked under a different scope chain than the one that was in effect when they were defined. This happens most commonly when a nested function object is returned from the function within which it was defined. There are a number of powerful programming techniques that involve this kind of nested function closures, and their use has become relatively common in JavaScript programming. Closures may seem confusing when you first en- counter them, but it is important that you understand them well enough to use them comfortably. JavaScript, The Definite Guide JavaScript 是如何实现这种词法作用域的想要了解这种词法作用域是如何实现的，就要了解 JavaScript 的执行上下文栈，具体请看这篇文章：JavaScript 执行上下文栈 参考 JavaScript 深入之词法作用域和动态作用域]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[JavaScript原型和原型链]]></title>
    <url>%2F2022%2F07%2F10%2FJavaScript%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[原型链是干什么用的JavaScript 采用了原型和原型链来实现类和继承（就是查找属性用的）。 当 JavaScript 查找一个对象上的属性的时候，在该对象上找不到就会去它的原型链上查找。比如： 1234function Foo() &#123;&#125;var foo = new Foo();Foo.prototype.a = 1;console.log(foo.a); 原型和原型链主要由三个指针实现： prototype: 构造函数的prototype属性指向原型对象 __proto__: 实例对象的__proto__属性指向原型对象 constructor: 原型对象的constructor属性指向构造函数 所有对象都基于Object，是因为所有原型对象的__proto__最终都指向Object.prototype，而Object.prototype的__proto__为 null JavaScript 只要前面带 new 就是构造函数，箭头函数和异步函数不可以做构造函数，因为箭头函数没有 this，而异步函数返回的是 Promise 对象 当我们在实例对象上查找一个属性的时候，如果不存在，则会递归的去原型链上找。 所有对象都有__proto__属性，但只有函数对象才有prototype属性 实例对象没有constructor属性，该属性继承自原型对象。分别对实例对象和原型对象使用hasOwnProperty验证constructor属性即可证明 123var a = new Object();console.log(a.hasOwnProperty('constructor')); // falseconsole.log(a.__proto__.hasOwnProperty('constructor')); // true 参考资料 JavaScript 深入之从原型到原型链 Javascript Object Hierarchy]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[TCP和UDP的区别]]></title>
    <url>%2F2022%2F06%2F20%2FTCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[好久没回顾这个知识点了，我现在只记得 TCP 是有链接的，UDP 是无连接的；TCP 是可靠的，UDP 是不可靠的。技术细节已经全然忘光了，今天就来回顾一下。 先说几个几点结论，然后再说说细节： TCP 是有链接的，UDP 是无连接的 TCP 可靠（无差错，不丢失不重复，按序到达），UDP 不可靠 TCP 面向字节流，UDP 面向报文 TCP 是一对一全双工，UDP 是 n 对 n TCP 的首部较大为 20 字节，UDP 首部只有 8 字节 TCP 为什么要三次握手四次挥手三次握手是因为双方都要确认对方的发送和接收两种能力： 第一次客户端发送 SYN 报文段，服务器接收到了，从服务器的视角看，客户端具备了发送能力。 第二次服务器端发送 ACK+SYN 报文段，客户端接收到了，从客户端的角度看，服务器具备了接收和发送两种能力。 第三次客户端接收到了服务器的报文，再发一个 ACK 报文给服务器，服务器接收到这个 ACK 报文就能确认客户端的接受能力正常。 所以最少需要三次，才能确认双方的收发能力都是正常的。 四次挥手是因为 TCP 是双工信道，关闭了 A 到 B 的发送渠道，B 到 A 的还没关闭，所以需要四次： 客户端发送 FIN 报文段给服务器端，服务器收到后发送 ACK 给客户端，客户端收到 ACK 后就会不再发消息。也就是说客户端到服务器端这条信道关闭了。 服务器发送 FIN 报文段给客户端，客户端收到后发送 ACK 给服务器，服务器收到 ACK 后就不再发消息给客户端了。服务器发送给客户端这条信道就关闭了。 这里的问题就是为什么服务器不把 ACK 和 FIN 合在一起发，就像三次握手时候那样 ACK+SYN 一起发。因为服务器 → 客户端，客户端 → 服务器这两条信道是互相独立的，在关闭其中一条的时候，另一条可能还在工作，不应该一起关闭，需要设计成独立关闭。 面向报文和面向字节流的区别面向报文的传输方式是应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则 IP 层需要分片，降低效率。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。 面向字节流的话，虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序看成是一连串的无结构的字节流。TCP 有一个缓冲，当应用程序传送的数据块太长，TCP 就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP 也可以等待积累有足够多的字节后再构成报文段发送出去。]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[服务器重装系统]]></title>
    <url>%2F2022%2F06%2F11%2F%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[今天我的 wordpress 数据库被攻击了，目前还不知道黑客用了什么手段，所以打算给服务器重装系统。我用的是搬瓦工的服务器，打开管理界面，我选择的是 centos-7-x86_64-bbr BBR（Bottleneck Bandwidth and RTT）是一种新的拥塞控制算法，由 Google 贡献给 Linux 内核 TCP 堆栈。有了 BBR，Linux 服务器可以显着提高吞吐量并减少连接延迟。此外，部署 BBR 很容易，因为此算法只需要在发送方更新，而无需在网络或接收方更新。 搭建Shadowsocks然后首先想到的是要安装 shadowsocks，因为我这个服务器基本上就是用来干这个事的。 我不想使用网上那种一键安装脚本的方式来弄这个，因为怕不安全（真的怕了怕了）。所以最好要自己搞懂每一步都做了什么。 主要参考这篇文章：https://gist.github.com/3013216027/469e7b988edde7e5f806f55a993b9efa 发现安装 shadowsocks 之前先要安装 pip 安装 pip 则要安装 python3 安装python3我试了一下yum install python3居然真的能安装，终于不用像以前那样从 python 官网下载源码，自己编译，自己配环境变量了。 安装完后测一下版本python3 --version：Python 3.6.8，测一下安装位置：which python3：/usr/bin/python3 安装shadowsocks接下来就是安装 shadowsocks 了：python3 -m pip install shadowsocks 安装完后测一下 ssserver 看能不能用，直接输入这个命令看看效果，能用，定位一下位置： which ssserver：/usr/local/bin/ssserver。 卸载 shadowsocks 后就不能用了，所以能确定 ssserver 是跟 shadowsocks 有关的。 配置shadowsocks1234567891011&#123; &quot;server&quot;: &quot;0.0.0.0&quot;, &quot;local_port&quot;: 1080, &quot;port_password&quot;: &#123; &quot;10085&quot;: &quot;gagosdfger&quot;, &quot;10086&quot;: &quot;gagosdfger&quot;, &quot;10010&quot;: &quot;gagosdfger&quot; &#125;, &quot;method&quot;: &quot;aes-256-cfb&quot;, &quot;timeout&quot;: 600&#125; 发现加密方法不支持aes-256-gcm，有什么办法给它加一种加密方式呢]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[浏览器上的几种xy坐标]]></title>
    <url>%2F2022%2F06%2F09%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8A%E7%9A%84%E5%87%A0%E7%A7%8Dxy%E5%9D%90%E6%A0%87%2F</url>
    <content type="text"><![CDATA[首先分为两大类： 事件坐标 dom 坐标 事件坐标有如下几种： screenX, screenY clientX, clientY pageX, pageY offsetX, offsetY 下面这张图可以很好的对比展示这几种 xy 坐标： 那如果是在 iframe 中的 document，clientX 和 screenX 还是符合直觉的值吗？ 答案是 clientX 不是，screenX 是。 clientX 的值是从 document 的左起始位置算起的，不会考虑 iframe 距离浏览器左边距。screenX 则依然是距离屏幕左边的距离。 dom 坐标]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[生成固定长度的字符串]]></title>
    <url>%2F2022%2F06%2F09%2F%E7%94%9F%E6%88%90%E5%9B%BA%E5%AE%9A%E9%95%BF%E5%BA%A6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[前端一般都要应对各种各样的用户输入，比如限制用户输入的字符串长度不超过 255 个字符。那么我自己测试的时候，去哪里弄个 256 长度的字符串呢，作为一个程序员，当然是自己写代码生成。下面我就来罗列一下有哪些方法可以实现这个需求。 字符串方法：padStart()和 padEnd()ES6 的字符串新语法 padStart()和 padEnd()，可以很好的完成这个需求： 12''.padStart(256, 'a');''.padEnd(256, 'a'); 官方文档：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/padStart 数组方法： join()1new Array(256).fill('a').join(''); 字符串方法：repeat()1'a'.repeat(256);]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二分查找]]></title>
    <url>%2F2022%2F06%2F08%2F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[什么是二分查找：二分查找每次只查询 mid（数组最中间的数），如果没找到目标，就缩小区间，根据 mid 和目标数对比，只搜左半区间或右半区间。 二分查找的前提：数据有序 二分查找结束的条件：查找区间为空，或者找到元素 二分查找的条件分支： nums[mid]==target nums[mid]&lt;target nums[mid]&gt;target 二分查找的搜索区间表示形式： 左闭右开（区间为空的条件是 left==right） 左闭右闭（区间为空的条件是 left&gt;right） 二分查找有的时候我会写出死循环来，仔细思考了一下：必须每次收缩边界的时候，都排除掉 mid，完全避免 mid 被重复查的可能。 习题 leetcode 704. 二分查找 leetcode 34. 在排序数组中查找元素的第一个和最后一个位置（中等） 第一题答案：左闭右闭搜索区间的写法： 1234567891011121314151617181920/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number&#125; */var search = function(nums, target) &#123; let left = 0; let right = nums.length-1; while(left&lt;=right)&#123; const mid = left + Math.floor((right-left)/2); if(nums[mid]==target)&#123; return mid; &#125;else if(nums[mid]&gt;target)&#123; right = mid-1; &#125;else if(nums[mid]&lt;target)&#123; left = mid+1; &#125; &#125; return -1;&#125;; 左闭右开搜索区间的写法： 1234567891011121314151617181920/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number&#125; */var search = function(nums, target) &#123; let left = 0; let right = nums.length; while(left&lt;right)&#123; const mid = left + Math.floor((right-left)/2); if(nums[mid]==target)&#123; return mid; &#125;else if(nums[mid]&gt;target)&#123; right = mid; &#125;else if(nums[mid]&lt;target)&#123; left = mid+1; &#125; &#125; return -1;&#125;; 第二题答案：左闭右闭搜索区间的写法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number[]&#125; */var searchRange = function(nums, target) &#123; return [findLeft(nums, target), findRight(nums, target)]&#125;;var findLeft = function(nums, target)&#123; let left = 0; let right = nums.length; while(left&lt;right)&#123; let mid = left + Math.floor((right-left)/2); if(nums[mid]==target)&#123; right = mid; &#125;else if(nums[mid]&lt;target)&#123; left = mid+1; &#125;else if(nums[mid]&gt;target)&#123; right = mid; &#125; &#125; if(nums[left]==target)&#123; return left &#125; return -1;&#125;var findRight = function(nums, target)&#123; let left = 0; let right = nums.length; while(left&lt;right)&#123; let mid = left + Math.floor((right-left)/2); console.log(left, mid, right) if(nums[mid]==target)&#123; left = mid+1; &#125;else if(nums[mid]&lt;target)&#123; left = mid+1; &#125;else if(nums[mid]&gt;target)&#123; right = mid; &#125; &#125; if(nums[right-1]==target)&#123; return right-1; &#125; return -1;&#125; 左闭右闭搜索区间的写法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; target * @return &#123;number[]&#125; */var searchRange = function(nums, target) &#123; return [fundLeft(nums, target), fundRight(nums, target)]&#125;;var fundLeft = function(nums, target)&#123; let left = 0; let right = nums.length - 1; while(left&lt;=right)&#123; let mid = left + Math.floor((right-left)/2); if(nums[mid]==target)&#123; right = mid-1; &#125;else if(nums[mid]&lt;target)&#123; left = mid+1; &#125;else if(nums[mid]&gt;target)&#123; right = mid-1; &#125; &#125; if(nums[left]==target)&#123; return left; &#125; return -1;&#125;var fundRight = function(nums, target)&#123; let left = 0; let right = nums.length - 1; while(left&lt;=right)&#123; let mid = left + Math.floor((right-left)/2); if(nums[mid]==target)&#123; left = mid+1; &#125;else if(nums[mid]&lt;target)&#123; left = mid+1; &#125;else if(nums[mid]&gt;target)&#123; right = mid-1; &#125; &#125; if(nums[right]==target)&#123; return right; &#125; return -1;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[浏览器 storage 事件]]></title>
    <url>%2F2022%2F06%2F08%2F%E6%B5%8F%E8%A7%88%E5%99%A8storage%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[官方文档：https://developer.mozilla.org/zh-CN/docs/Web/API/Window/storage_event 在使用 storage 事件的时候，我发现了两个不符合我直觉的特性： 在本窗口修改存储区域（localStorage 或 sessionStorage）时，本窗口的监听无效 必须写入与旧值不同的值，才能监听到 我自己写代码测试了以上两个特点，但疑惑的是中文文档里面什么都没讲，原来英文文档里面说了这两点，MDN 的中文文档和英文文档并不是翻译关系，完全就是另写的。所以如果觉得文档有问题，还是切换到英文看吧。 英文文档的解释The storage event of the Window interface fires when a storage area (localStorage) has been modified in the context of another document. Note: This won&#39;t work on the same page that is making the changes — it is really a way for other pages on the domain using the storage to sync any changes that are made. Pages on other domains can&#39;t access the same storage objects. 测试代码123456// 设置监听window.addEventListener('storage', ()=&gt;&#123;console.log('监听storage', localStorage.getItem('abcd'))&#125;);// 查看dom有哪些监听事件getEventListeners(window);// 设置localStoragelocalStorage.setItem('abcd', '1111');]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何学习]]></title>
    <url>%2F2021%2F08%2F22%2F%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[这篇文章的思想来自于这位博主：bilibili-YJango，我觉得很受启发就将其简略写了下来。 什么是学习？学习 vs 记忆 记忆：容量有限、难以集齐 学习：从有限的例子中找出问题和答案的规律：知识 费曼说：如果你没有办法用简单的语言描述所学的知识，你就没有真正学会它。 因为学习是用知识来压缩原本无限的信息 学习：找出知识、压缩信息 如何学习找出问题和答案的规律，重塑大脑链接。学习的第一步就是明确：问题和答案。 很多人压根连要学的知识所描述的问题都不清楚就去学习，最后只是记住知识的描述而已。 然而知识不是信息，学习不是记忆。无法仅凭记住知识来学会知识。这也是人们在教和学的过程中最容易犯的错误，以为将知识告诉了某人，对方就可以学会了，以为听懂了知识，就以为自己学会了。然而知识的描述只是对学习起到引导的作用，最终的学习一定要通过例子来理清问题和答案的关系，来重塑大脑链接。这也就是为什么在讨论、写文章以及辩论时一定会伴随着例子，而不是单纯的对知识进行描述。因此在看书时也要注意区分，哪些是例子，哪些是对知识的描述。我个人在写文章时甚至常常会将例子和知识描述分开来写。华罗庚的：先把书读厚，再把书读薄。的学习方法就是指：先尽可能的搜集更多的例子来帮助体会问题和答案之间的关系。而当你真正学会的时候这些例子就会压缩成知识。最后由于学习是为了解决新问题，所以需要验证从现有例子中所提炼的知识，是否能描述问题和答案的真正规律，而不是仅仅记住了这些例子。 学习步骤： 明确问题和答案 用例子构建知识 验证知识有效性 学习的误区学习最重要的两步： 明确问题（输入）和答案（输出） 用例子构建知识 学习方式分为两大类： 思考类：数学、逻辑 运动类：语言、运动 区别在于是否依靠意识，因为意识是后进化出来的，擅长解决的是推断问题，速度缓慢，学不会的原因在于： 错误的输入输出 错误的学习方式：用思考类方式来学习所有知识，比如看书学游泳、学做菜 不通过例子仅记忆知识 以语言为例，四项能力的正确输入、输出分别是： 听（声音） 说（想法） 读（文字） 写（想法） 应试英语的误区是：输入、输出变成了完形填空，阅读选择等，这类从一些文字到另一些文字的思考类问题。用百词斩背单词时还容易产生另一种偏差：图片-&gt;中文。英语学习中最致命的是插入了中文思考这个中间输出，不仅输出错误，而且非常缓慢。若让很多懂外语，但未经训练的人同时翻译中文的话，他们会反应不过来，就是因为他的大脑在这个过程中其实并不思考中文。当出国后就会发现，所学英语的输入和真实英语的输入是不同的，根本用不了。不经过例子而直接记忆知识也是常见的误区，由于语言的输入从来不是一个单词而是一个句子，要想把握句子中某个单词的真正含义，需要通过大量体会不同的例句，但很多时候学生仅仅是记住了单词的中文描述。很多英语名师也犯同样的错误，不管他总结的再好，若仅仅是把他的总结告诉学生，学生永远都是在把他的总结当成信息记忆，而不是作为知识学习。十年学不会英语，不是因为没学会，而是因为搞错了输入输出，造成学到的是完全不同的知识。 我们可以同时应用多个应用类知识，譬如某人可以边走路边聊天。但意识在某一刻只能专注于一个思考类问题，无法并行。因此在某一刻，若无法从脑中搜索到能直接从输入得到输出的知识，问题就无法解决。然后我们所掌握的知识又是有限的，这种直接从输入得到输出的知识往往会超过我们的知识范围。应对办法可以是学习更多的知识，但还有一个简单，却又无比强大的方法就是分而治之。将问题拆分成脑中存有的，能直接从输入得到输出的小问题来解决。你一定听过这个办法，但恐怕你并不知道它为什么如此强大。原因在于，它可以将原本需要你掌握指数级知识才能解决的问题，变成用线性级知识就可以解决的问题。假设你掌握了三种知识，不考虑顺序，单从组合来看，就可以形成 $2^3$ 种知识，如果不拆分问题你需要掌握 8 种知识才能解决这些问题。而有 20 种知识的时候，二者的差别就是 20 vs 1048576。 应对方法： 多学知识 分而治之（$2^n \rightarrow n$，它直接决定了一个人解决问题的能力） 造成现象： 编程无头绪 写作不出字 解题没思路 工作难应对]]></content>
      <categories>
        <category>方法论</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[快速排序最坏的情况啥时候出现]]></title>
    <url>%2F2021%2F06%2F28%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%9C%80%E5%9D%8F%E7%9A%84%E6%83%85%E5%86%B5%E5%95%A5%E6%97%B6%E5%80%99%E5%87%BA%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[在面试富途的时候面试官问了这样一个问题：快速排序最坏的情况啥时候出现？当时没有答上来。实际上这个问题比较容易想清楚，思路如下，从快速排序的形式入手：$O(N*logN)$，N 代表单次排序的时间花销，logN 代表递归次数。我们知道最坏情况是$O(N^2)$，也就是说$logN$退化成了$N$。那么什么情况会退化成$logN$，当然是问题规模缩减得慢的时候，这与我们选中枢有直接的关系。假如我们选的中枢，每次都是最小或者最大，那么问题的缩小速度就会变成线性的了；而假如我们选的中枢，每次恰好是中间那个数，那么问题递归次数就是$log_2^N$了。 由于我们一般都是选第一个或者最后一个元素做中枢，那么最坏的情况对应就是：已经有序（这包括正序，逆序，以及全部元素相等） 由于快速排序的这个特征，所以我们一般的算法库中是结合了好几种排序算法：C++一道深坑面试题：STL 里 sort 算法用的是什么排序算法？ 同时我也在思考为啥快排这种最坏是$O(N^2)$的算法会被使用，而不直接使用最坏是$O(NlogN)$的算法，比如归并排序，堆排序。答案自然是这些排序也有各自的缺点，而且我估计是无法容忍的缺点。比如归并排序，它不是一个原地排序算法，需要额外的存储空间。堆排序，需要构建堆花费额外的时间。堆构建完毕后，借用堆这种结构，每次只能从堆顶取出最大或最小的数，而且取完还要进行堆维护，花费$logN$的时间。构建堆的过程和堆排序的过程类似，只不过构建堆是添加叶节点+上浮堆化的过程，而堆排序是取根节点+下沉堆化的过程，同样的构建堆也要花费$O(NlogN)$的时间。所以堆排序会花费双倍的时间。]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[智能合约入门]]></title>
    <url>%2F2021%2F06%2F28%2F%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[前言从 2017 年开始买比特币的时候，我就想学习智能合约相关的开发，也曾想过要投身区块链行业，这一拖就是 4 年。我认真开始学起智能合约，最主要的原因其实是因为我离它更近了。这一轮牛市，DEFI 火爆，让我学会了使用钱包和公链。而在去年，我还是个只会在 OTC 入金的傻子，库币的 OTC 定价那么不合理都只会用 OTC 入金，后来我才发现原来 USDT 可以随意在链上转，而且波场免手续费，由此打开了新世界的大门。 资料 Solidity 语言 Solidity 文档 Remix Remix 的使用 Remix 使用教程 发币 人生中第一段智能合约代码 12345678pragma solidity ^0.4.0;contract addressTest&#123; function getBalance(address addr) public view returns (uint)&#123; return addr.balance; &#125;&#125;]]></content>
      <categories>
        <category>币圈</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode每日一题：474. 一和零]]></title>
    <url>%2F2021%2F06%2F06%2Fleetcode-470-%E4%B8%80%E5%92%8C%E9%9B%B6%2F</url>
    <content type="text"><![CDATA[474. 一和零一道动态规划题目。 首先要明白这是一道背包问题，而且是双维度的，可以装0和1。 那么我们就需要一个三维数组dp来记录动态规划的子过程的结果，第一个维度代表遍历到第i个字符串，第二个维度代表第j个0的问题规模，第三个维度代表第k个1的问题规模，依次扩展到我们的目标字符串个数，目标问题规模。 状态转移方程： 如果加入当前字符串，导致背包溢出，则不加：dp[i][j][k] = dp[i-1][j][k] 如果不溢出，则有两种可能，取最优解：dp[i][j][k] = Math.max(dp[i-1][j][k], dp[i-1][j-zeros][k-ones]+1) 这里还需要考虑一些边界问题，比如i=0的时候，dp[0][any][any]应该是0，同理m=0和n=0也是如此。所以我们的数组空间需要每个维度上都加1来存放这些初始值。 JavaScript代码： 1234567891011121314151617181920212223242526272829/** * @param &#123;string[]&#125; strs * @param &#123;number&#125; m * @param &#123;number&#125; n * @return &#123;number&#125; */var findMaxForm = function(strs, m, n) &#123; let dp = new Array(strs.length+1).fill(0).map(()=&gt;new Array(m+1).fill(0).map(()=&gt;new Array(n+1).fill(0))) for(let i=1;i&lt;=strs.length;i++)&#123; let [zeros, ones] = getZeros(strs[i-1]) for(let j=0;j&lt;=m;j++)&#123; for(let k=0;k&lt;=n;k++)&#123; dp[i][j][k] = dp[i-1][j][k] if(j&gt;=zeros &amp;&amp; k&gt;=ones)&#123; dp[i][j][k] = Math.max(dp[i-1][j][k], dp[i-1][j-zeros][k-ones]+1) &#125; &#125; &#125; &#125; return dp[strs.length][m][n]&#125;;function getZeros(str)&#123; let zeros = [0, 0] for(let i=0;i&lt;str.length;i++)&#123; zeros[str[i]-'0']++; &#125; return zeros&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode每日一题：203. 移除链表元素]]></title>
    <url>%2F2021%2F06%2F05%2Fleetcode-230-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[203. 移除链表元素很简单的一道删除单链表节点题 JavaScript代码： 12345678910111213141516171819202122232425/** * Definition for singly-linked list. * function ListNode(val, next) &#123; * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * &#125; *//** * @param &#123;ListNode&#125; head * @param &#123;number&#125; val * @return &#123;ListNode&#125; */var removeElements = function(head, val) &#123; let h = new ListNode(0, head); index = h; while(index.next)&#123; if(index.next.val == val)&#123; let next = index.next.next; index.next = next; continue; &#125; index = index.next; &#125; return h.next;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode每日一题：160. 相交链表]]></title>
    <url>%2F2021%2F06%2F04%2Fleetcode-160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[160. 相交链表这题有两种解法： 哈希表记录指针 双指针 哈希表记录指针JavaScript代码： 123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; headA * @param &#123;ListNode&#125; headB * @return &#123;ListNode&#125; */var getIntersectionNode = function(headA, headB) &#123; let hashset = new Set([]); let index = headA while(index)&#123; hashset.add(index) index = index.next &#125; index = headB while(index)&#123; if(hashset.has(index))&#123; return index; &#125;else&#123; index = index.next; &#125; &#125; return null;&#125;; 双指针链表总共分为三部分： headA到公共节点 headB到公共节点 公共部分 所以如果我们利用双指针，把这三个部分走一遍，就能让双指针碰上。 index1走A链，走完A链，走B链 index2走B链，走完B链，走A链 两个指针同时等于null只有一种情况，就是两个链不相交。如果相交，想要都在链尾碰上，则两个链长度相等，若两个链长度相等且相交，则非公共部分长度一定相等，那么他们早就在第一次遍历的时候在公共节点遇上了。 12345678910111213141516171819202122/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; headA * @param &#123;ListNode&#125; headB * @return &#123;ListNode&#125; */var getIntersectionNode = function(headA, headB) &#123; let index1 = headA; let index2 = headB; while(index1!==index2)&#123; index1 = index1==null?headB:index1.next; index2 = index2==null?headA:index2.next; &#125; return index1;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode每日一题：525. 连续数组]]></title>
    <url>%2F2021%2F06%2F03%2Fleetcode-525-%E8%BF%9E%E7%BB%AD%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[凡是涉及到连续子数组的，都可以用前缀和+哈希表来解 525. 连续数组这题要注意的就是，因为要统计元素个数，所以要使用i+1。 哈希表的key的含义是：当前遍历到的1与符合标准（一半是1）之间的差距，而记录的位置则必须是最小位置。所以只在初始化的时候赋值。 JavaScript代码： 123456789101112131415161718192021222324/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var findMaxLength = function(nums) &#123; let sum = 0; let hashmap = &#123;&#125; let max = 0; for(let i=0;i&lt;nums.length;i++)&#123; sum += nums[i]; if(i+1==sum*2)&#123; max = i+1; continue; &#125; if(hashmap.hasOwnProperty(i+1-sum*2))&#123; if(max&lt;(i-hashmap[i+1-sum*2]))&#123; max = (i-hashmap[i+1-sum*2]) &#125; &#125;else&#123; hashmap[i+1-sum*2] = i; &#125; &#125; return max;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode每日一题： 342. 4的幂]]></title>
    <url>%2F2021%2F05%2F31%2Fleetcode-342-4%E7%9A%84%E5%B9%82%2F</url>
    <content type="text"><![CDATA[这个问题看起来是个简单题，其实可以从中学到位运算和一些数学知识。 342. 4的幂我自己的解法很简单易懂，但是不够高效： JavaScript代码： 1234567891011121314/** * @param &#123;number&#125; n * @return &#123;boolean&#125; */var isPowerOfFour = function(n) &#123; let i = 1; while(i&lt;n)&#123; i = i*4; &#125; if(i==n)&#123; return true; &#125; return false;&#125;; 这个解法的效率很差，只战胜了55%的选手。说明肯定有更优解，我翻了一下答案。主要是2种角度的解法： 位运算 数学 位运算如果是2的幂，那么位中只能出现一个1。如果是4的，那么肯定也只有一个1，且出现的位置是每隔一位出现。那么问题来了，怎么判断位上只有一个1呢？操作是：减去1，然后与。得到的结果必然应该是0。那如何判断1在哪一位上呢？好像只能遍历了。但其实我们不需要知道具体是哪一位，只需要知道是否分布在正确的位上，可以通过mask解决：mask=$(01010101010101010101010101010101)_2$，因为1分布在奇数位。也可以写成更简短的16进制形式：mask=$(55555555)_16$ JavaScript代码： 1234567/** * @param &#123;number&#125; n * @return &#123;boolean&#125; */var isPowerOfFour = function(n) &#123; return n&gt;0 &amp;&amp; (n &amp; (n-1)) == 0 &amp;&amp; (n &amp; 0x55555555)&#125;; 奇怪的是这个代码的运行时间居然比上面那个还长，感觉不科学。 数学角度首先依然是按照上面的两个条件： n&gt;0 n只有一个0 我们观察到所有偶数分为：$4^x \times 2 \times 2$也就是$4^x$，和$4^x \times 2 \times 1$。而4的幂次除以3的余数必然是1，而$4^x \times 2$这种除以3的余数必然是2。 我们增加这个条件筛选出$4^x$ JavaScript代码： 1234567/** * @param &#123;number&#125; n * @return &#123;boolean&#125; */var isPowerOfFour = function(n) &#123; return n&gt;0 &amp;&amp; (n &amp; (n-1)) == 0 &amp;&amp; (n % 3)==1&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode： 1074. 元素和为目标值的子矩阵数量]]></title>
    <url>%2F2021%2F05%2F29%2Fleetcode-1074-%E5%85%83%E7%B4%A0%E5%92%8C%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E5%AD%90%E7%9F%A9%E9%98%B5%E6%95%B0%E9%87%8F%2F</url>
    <content type="text"><![CDATA[这个问题需要拆分出子问题才好解决，要不然没有思路。它的子问题是：560. 和为K的子数组 1074. 元素和为目标值的子矩阵数量当你理解了子问题之后，我们来想想，怎么把这个问题转换到子问题上呢？也就是如何把二维问题变一维问题呢？ 我们想象把一个矩阵的列上的元素全部加起来，不就是一个一维数组了吗。这个一维数组可以等效的应用在这个问题上。 那这样的组合有哪些呢？通过简单的二次遍历，就能得出我们想要的组合： JavaScript代码： 12345for(let i=0;i&lt;n;i++)&#123; for(let j=i;j&lt;n;j++)&#123; &#125;&#125; 每次i到j之间的数就是我们想要的组合，拿这些数的和，组成新的一维数组，然后用一维数组的解法去解。这里有个小技巧是这个和也要避免重复计算，所以要把每次计算所得存下来，下次在这个基础上算，这样可以省下从头开始求和的时间。 JavaScript代码： 123456789101112131415161718192021222324252627282930313233343536/** * @param &#123;number[][]&#125; matrix * @param &#123;number&#125; target * @return &#123;number&#125; */var numSubmatrixSumTarget = function(matrix, target) &#123; let count = 0; for(let i=0;i&lt;matrix.length;i++)&#123; let sum = new Array(matrix[0].length).fill(0) for(let j=i;j&lt;matrix.length;j++)&#123; for(let k=0;k&lt;matrix[0].length;k++)&#123; sum[k] += matrix[j][k] &#125; count += subarraySum(sum, target) &#125; &#125; return count;&#125;;var subarraySum = function(nums, k) &#123; let pre = 0; let preRecord = &#123;0: 1&#125; let count=0; for(let i=0;i&lt;nums.length;i++)&#123; pre += nums[i]; if(preRecord[pre-k])&#123; count += preRecord[pre-k] &#125; if(preRecord[pre])&#123; preRecord[pre]++; &#125;else&#123; preRecord[pre]=1; &#125; &#125; return count;&#125;; 简化问题的办法有很多，比如降低问题规模，降低维度，二维 -&gt; 一维。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode： 560. 和为K的子数组]]></title>
    <url>%2F2021%2F05%2F29%2Fleetcode-560-%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[这题是在做每日一题中遇到的问题的子问题：1074. 元素和为目标值的子矩阵数量 560. 和为K的子数组遇到这类问题，首先想的是复杂度，然后复杂度天然是跟问题规模有关的。遍历一遍肯定是必要的，当我们遍历到第n这个位置，我们怎么判断从0到n中有多少个解，进一步的，我们还只要增量数据，n-1的解不应该去重复计算。第n这个位置上的数是一定要考虑进去的，所以我们从后往前寻找。具体代码如下： JavaScript代码： 1234567891011121314151617/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var subarraySum = function(nums, k) &#123; let count = 0; for (let start = 0; start &lt; nums.length; ++start) &#123; let sum = 0; for (let end = start; end &gt;= 0; --end) &#123; sum += nums[end]; if (sum == k) &#123; count++; &#125; &#125; &#125; return count;&#125;; 这样的话，算法的时间复杂度是O(n^2)。有没有重复计算的问题呢，似乎不太好说，但结果是：有，像此类问题有统一的规律，就是我们可以记录前缀和。如果我们知道前缀和，那么我们只需要用当前和减去k，看是否等于某个前缀和，如果有，我们不就正好找到一个子数组的和等于k了吗？所以基于前缀和，我们一次遍历即可解决问题。 JavaScript代码： 12345678910111213141516171819202122/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; k * @return &#123;number&#125; */var subarraySum = function(nums, k) &#123; let pre = 0; let preRecord = &#123;0: 1&#125; let count=0; for(let i=0;i&lt;nums.length;i++)&#123; pre += nums[i]; if(preRecord[pre-k])&#123; count += preRecord[pre-k] &#125; if(preRecord[pre])&#123; preRecord[pre]++; &#125;else&#123; preRecord[pre]=1; &#125; &#125; return count;&#125;; 前缀和对过往的遍历总结提取了信息，使我们不用再去进行重复的计算，是非常重要的技巧。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode每日一题： 477. 汉明距离总和]]></title>
    <url>%2F2021%2F05%2F28%2Fleetcode-477-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB%E6%80%BB%E5%92%8C%2F</url>
    <content type="text"><![CDATA[leetcode每日一题是leetcode中文版官方推出的活动，每日一题锻炼解决问题的思维能力。 477. 汉明距离总和这题初看上去特别简单，就是一个O(n^2)的遍历（组合），对每一组求汉明距离累加起来。不过我一开始就觉得可能会超时，提交后果然超时了。更优的做法是按位遍历，每一位上所有的数要么是0要么是1，把0和1的个数统计出来，相乘，就是这一位的汉明距离总和。 JavaScript代码： 123456789101112131415161718192021222324252627/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var totalHammingDistance = function(nums) &#123; let max = Math.max(...nums) let count=0; while(max&gt;0)&#123; count++; max&gt;&gt;=1; &#125; let res = 0; for(let i=0;i&lt;count;i++)&#123; let zero = 0; let one = 0; for(let j=0;j&lt;nums.length;j++)&#123; let temp = nums[j]&gt;&gt;i; if(temp%2)&#123; one++; &#125;else&#123; zero++; &#125; &#125; res += zero*one; &#125; return res;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[position sticky]]></title>
    <url>%2F2021%2F05%2F28%2Fposition-sticky%2F</url>
    <content type="text"><![CDATA[在做公司项目的过程中遇到一个问题：让表头固定，同时其宽度必须占满整个父元素。用 fixed，可以固定但是宽度无法撑开。最终用position: sticky解决了问题。 参考资料： 杀了个回马枪，还是说说 position:sticky 吧« 张鑫旭-鑫空间-鑫生活 position - CSS（层叠样式表） | MDN position: sticky 的作用这个坑先放着，等深入研究了再来填，放上 codepen 试验现场：https://codepen.io/liuqinh2s/pen/oNZWbeX]]></content>
      <categories>
        <category>css</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode每日一题： 1190. 反转每对括号间的子串]]></title>
    <url>%2F2021%2F05%2F27%2Fleetcode-1190-%E5%8F%8D%E8%BD%AC%E6%AF%8F%E5%AF%B9%E6%8B%AC%E5%8F%B7%E9%97%B4%E7%9A%84%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[写之前：2020年整整一年没有写过博客了，沉痛的一年。写博客还是继续下去吧，不管怎样。 1190. 反转每对括号间的子串这道题一看就知道用栈来解决，但具体到怎么做却依旧不容易想通。直到看过答案后，才发现，实际上真的只需要遍历一遍就能解决问题。 思路如下： 每遇到一个括号块，就需要把里面的字符串翻转（这是单步操作），然后递归翻转每一层。这是我们人的思维，但机器是看不到这种宏观信息的，我们需要安排具体到每一步的任务。代码在遍历的时候只会遇到左括号或者右括号，假如我们遇到左括号的时候开始记录字符串，那么在遇到右括号的时候，就有翻转的目标对象了。但如果连续遇到两个左括号呢？我们将记录的信息先入栈，然后继续上面的步骤即可。 具体步骤（单步）： 遇到左括号：入栈已记录的字符串，清空我们用于记录的变量 遇到普通字符：记录 遇到右括号：翻转记录的字符串，将栈顶字符串pop出来拼接上翻转好的字符串 JavaScript代码： 12345678910111213141516171819/** * @param &#123;string&#125; s * @return &#123;string&#125; */var reverseParentheses = function(s) &#123; let stack = [] let str = '' for(let i=0;i&lt;s.length;i++)&#123; if(s[i]=='(')&#123; stack.push(str) str = '' &#125;else if(s[i]==')')&#123; str = stack.pop() + Array.from(str).reverse().join('') &#125;else&#123; str += s[i] &#125; &#125; return str;&#125;; 后记：这是新年的第一篇博客，以后会做更多的记录，不管有没有人看。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[炒币的基本知识]]></title>
    <url>%2F2019%2F12%2F30%2F%E7%82%92%E5%B8%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[平台选择平台选择：选大平台，像火币、币安。这里有个排行供参考：https://coinmarketcap.com/zh/rankings/exchanges/ 我自己选的是火币，以前的火币体验是非常好的，买卖很方便，现在经常数据刷不出来。 k 线图K 线图（因为形状酷似蜡烛，也叫蜡烛图） k 线图是最常用和最基本的信息来源 k 线图是典型的笛卡尔坐标（也就是直角坐标系），横轴是时间，纵轴是价格。 横轴可以选择多种时间分片，比如一个月，1 周，1 天，4 小时，1 小时，15 分钟，1 分钟。上图中，我选择的就是 1 天的 k 线图。每一根蜡烛就代表一个时间片的基本信息，当蜡烛是红色的时候，就说明是 收盘价&lt;开盘价；是绿色的时候，就说明是 开盘价&gt;收盘价。而中间细长的线冒出头，就是在该时间片内价格曾今到过的位置。 什么是收盘价，什么是开盘价？开盘价是时间片开始的时候的价格，收盘价是时间片结束时候的价格。比如你如果选的是 1 天作为时间片，那么开盘时间就是 00:00:01，收盘时间就是 23:59:59。那什么又是价格呢？价格是上一笔成交的价格。 当然红色和绿色只是一种约定俗成，在中国股市，红色一般代表涨，绿色代表跌。而美股则恰好相反。 如果你能通过自己的观察发现以上这些信息，说明你已经具备了一定的洞察力。买了这么久比特币，我也是今年才了解了这些信息。 但借助于搜索引擎和维基百科我们可以更快的掌握这些知识。 我们可以看到还有黄、绿、紫三根曲线贯穿在蜡烛图中。这就是 均线。上图中 MA5 是黄色的，MA10 是绿色的，MA30 是紫色的。 MA 是 Moving Average 的意思，MA 线就是 移动平均线。 但要注意的是 MA5 并不一定是 5 日均线的意思，还要看你选择的是什么时间分片，如果是 1 小时，那就是 5 小时均线。另外均线采用的数据一般是收盘价。计算方法很简单，当前均线值=前面几根蜡烛的收盘价相加/蜡烛的根数。比如 MA5 = (前面四根蜡烛图的收盘价+当前价格)/5，由于还没收盘，计算当前的 MA5，最后一根 k 线的收盘价用的是当前价格，所以当前的 MA5 是波动的。 深度图 深度图就比较简单了。从图中我们可以得知，绿色这边是买入，红色是卖出。横轴是价格，纵轴是数量。 一般来说价格越低愿意买的人越多，价格越高愿意卖的人越多，所以会呈现出这种两个三角形尖尖角相对的感觉，中间是谷，两边是峰。 我们需要留意的是买盘和卖盘哪个更大，买盘大说明很多人想要买（一般情况下会导致供不应求，此时为卖方市场，价格可能会被推高），卖盘大说明很多人想要卖（一般情况下会导致供过于求，此时为买方市场，价格可能会被压低）。 另一个现象就是在某个价位形成一条比较明显的垂线，说明在这个价格的订单量突然非常多，这种线就是压力位，可以阻止暴涨暴跌。 但我们也要注意到，深度图只是挂单信息的一个全方位展示，挂单是可以随时取消的，除非挂单不可取消，否则深度图总是有一定的延迟性，有可能被庄家用来迷惑散户。 流动性目前比特币的每日交易量占整个加密货币的 60%以上，流动性最大。某些市值小的币种流动性很小，大资金进不来，也出不去。比特币的这个优势将不断的吸引大资金注入。 如果你手上有 1000 个比特币，甚至 10000 个比特币，不用担心出售不了，你挂个卖单，市场很快就能吃掉。而一些市值和交易量小的币种则不行，比如 BTS，巨蟹现在要甩卖 3 亿个 BTS，就很困难。 价格和市值加密货币暴涨暴跌，钱都进了谁的腰包？ 在市场中，价格主要是通过买卖过程直接决定的，当买方力量强于卖方，价格就涨；反之价格就跌（供需关系决定价格走势）。 但这其中也有不少猫腻，举个实际的例子： 假设比特币现在的价格是 10000 USDT，并且只有你一个人在交易，你想买 100 万 USDT 的 BTC，只能通过不断抬高价格，吃掉挂着的卖单，才能买到需要数量的 BTC。 假设买完之后，BTC 价格到了 10100 USDT，目前比特币的流通量为 1777.5 万，所以 BTC 的总市值增加了100*1777.5万=17.775亿。但实际流入的资金量为 100 万 USDT。比特币的实际交易量在100万/10000到100万/10100之间，100 个不到，和所有的比特币数量相比是很少的。这意味着价格和市值的波动其实只是一部分参与交易的比特币所导致的。 这告诉我们：市值是虚的，而交易量更为真实。如果某个币交易量过低，而市值过高，说明该加密货币被人所操控，那么将十分危险。]]></content>
      <categories>
        <category>币圈</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[自制json解析器]]></title>
    <url>%2F2019%2F10%2F01%2F%E8%87%AA%E5%88%B6json%E8%A7%A3%E6%9E%90%E5%99%A8%2F</url>
    <content type="text"><![CDATA[公司安排了一次新人技术分享，我分享的主题是：自制 json 解析器 json 官网介绍]]></content>
      <categories>
        <category>项目</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[图灵机]]></title>
    <url>%2F2019%2F04%2F26%2F%E5%9B%BE%E7%81%B5%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[图灵机图灵机（Turing Machine）是 英国数学家艾伦·图灵 在 1936 年发表的 &quot;On Computable Numbers, with an Application to the Entscheidungsproblem&quot;（《论可计算数及其在判定性问题上的应用》）中提出的数学模型。在文章中图灵描述了它是什么，并且证明了，只要图灵机可以被实现，就可以用来解决任何可计算问题。 历史 妈咪说：图灵 模仿游戏 图灵机的基本思想图灵机是一种 抽象计算模型，图灵机的构成： 一条无限长的纸带，纸带由很多个格子构成，用于输入输出信息。每个格子中包含一个来自有限字母表的符号，字母表中有一个特殊符号表示空白。纸带上一端的格子从 0 开始编号，另一端无限延伸一直到无穷大。 一个读写头，用于读写纸带 一个状态寄存器，用于保存机器状态。图灵机的状态个数有限，并且有一个特殊的状态：停机状态 一套控制规则，根据当前机器状态和纸带内容来确定下一步的动作： 写入或擦除当前格子内容 移动读写头，向左、向右、或不动 保持当前状态或转移到另一状态 图灵机的正式定义a (one-tape) Turing machine can be formally defined as a 7-tuple $M=\langle Q,\Gamma ,b,\Sigma ,\delta ,q_{0},F\rangle $ where $Q$ is a finite, non-empty set of states; $\Gamma$ is a finite, non-empty set of tape alphabet symbols; $b\in \Gamma$ is the blank symbol (the only symbol allowed to occur on the tape infinitely often at any step during the computation); $\Sigma \subseteq \Gamma \setminus {b}$ is the set of input symbols, that is, the set of symbols allowed to appear in the initial tape contents; $q_{0}\in Q$ is the initial state; $F\subseteq Q$ is the set of final states or accepting states. The initial tape contents is said to be accepted by $M$ if it eventually halts in a state from $F$. $\delta :(Q\setminus F)\times \Gamma \not \to Q\times \Gamma \times \{L,R\}$ is a partial function called the transition function, where L is left shift, R is right shift. (A relatively uncommon variant allows &quot;no shift&quot;, say N, as a third element of the latter set.) If $\delta$ is not defined on the current state and the current tape symbol, then the machine halts; 图灵机的实践 Brainfuck 图灵完备只要能模拟单带图灵机，就是图灵完备的。这也意味着其计算能力与通用图灵机等同。 不是图灵完备的的常见情况有； 递归或循环有限，无法写不终止的程序，如while(true){} 无法实现类似数组或列表这样的数据结构（不能模拟纸带） 图灵完备也有可能带来坏处，不图灵完备也不是完全没用，比如：有些场景我们需要限制语言的表达能力，如 限制无限循环和递归，保证我们的程序一定是可终止的。 停机问题停机问题（英语：halting problem）是逻辑数学中可计算性理论的一个问题。通俗地说，停机问题就是判断任意一个程序是否能在有限的时间之内结束运行的问题。该问题等价于如下的判定问题：是否存在一个程序 P，对于任意输入的程序 w，能够判断 w 会在有限时间内 结束或者死循环。 艾伦·图灵在 1936 年用 对角论证法 证明了，不存在解决停机问题的通用算法。 停机问题包含了 自我指涉，本质是 一阶逻辑 的不完备性，类似的命题有 理发师悖论、全能悖论 等。 证明很简单，构造G=~G命题（G 等于 G 非），让逻辑崩溃，无论 G 是真还是假，都是错的，最后推导出：不存在这样的 G。 停机问题证明过程（反证法）： 如果存在可以判定任意程序是否停机的程序，我们姑且称它为 上帝程序 那我们定义这样一个程序，它利用上帝程序判断自己是否停机，但如果上帝程序输出停机，它就不停；如果上帝程序输出不停机，它就停机（就是反着干）。这样一来无论上帝程序输出什么，上帝程序都是错的。那么我们只能说不存在这样的上帝程序。 123456789101112def is_halt(program, input): if program halts on input: return true else: return falsedef fuck_is_halt(): if is_halt(fuck_is_halt): while (1): pass else: pass Matrix67：停机问题、Chaitin 常数与万能证明方法 刘未鹏：康托尔、哥德尔、图灵——永恒的金色对角线(rev#2) 自我指涉 在数学中，对自指的研究最终导致了著名的 哥德尔不完备定理。 计算机程序中的自指主要是为 递归 德罗斯特效应： 我们经常可以在主播间看到类似的画面： 也可以用两面镜子自己做这个实验。 妈咪说：哥德尔]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[冯·诺依曼结构]]></title>
    <url>%2F2019%2F04%2F22%2F%E5%86%AF%C2%B7%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[冯·诺依曼结构冯·诺伊曼结构与 存储程序型计算机 是互相通用的名词 哈佛结构 是一种将程序数据与普通数据分开存储的设计概念，可以说是冯·诺依曼结构的一种。 存储程序计算机在体系结构上主要特点有： 以运算单元为中心 采用存储程序原理 存储器是按地址访问、线性编址的空间 控制流由指令流产生 指令由 操作码 和 地址码 组成 数据以二进制编码 五个组成部分： 存储器 控制器 运算器（算术逻辑单元） 输入 输出 历史 文明之光：电子计算机的发明－从图灵到冯诺依曼（上） 文明之光：冯诺依曼系统结构和电子计算机的发明（下） 妈咪说：过目不忘的天才——冯诺依曼的传奇人生 他为何被称作通用计算机之父？ 冯·诺依曼 冯·诺依曼由于在曼哈顿工程中需要大量的运算，从而使用了当时最先进的两台计算机 Mark I 和 ENIAC，在使用 Mark I 和 ENIAC 的过程中，他意识到了存储程序的重要性，从而提出了存储程序逻辑架构。 最早的计算机内含固定用途的程序，并非可编程，若想要改变此机器的程序，你必须更改线路、更改结构甚至重新设计机器。而存储程序型计算机的概念改变了这一切。借着将指令当成一种特别类型的静态数据，一台存储程序型计算机可轻易改变其程序，并在程序控制下改变其运算内容。 优势冯·诺依曼架构第一次 将存储器和运算器分开，指令和数据均放置于存储器中，为计算机的 通用性 奠定了基础。虽然在规范中计算单元依然是核心，但冯·诺依曼架构事实上导致了 以存储器为核心 的现代计算机的诞生。 注：请各位在心里明确一件事情：存储器指的是内存，即 RAM。磁盘理论上属于输入输出设备。 缺陷 程序可修改很可能是非常具伤害性的：在一个简单的存储程序型计算机上，一个设计不良的程序可能会伤害自己、其他程序甚或是操作系统，导致死机、缓存溢出就是一个典型例子。而创造或更改其他程序的能力也导致了恶意软件的出现。利用缓存溢出，一个恶意程序可以覆盖调用堆栈（Call stack）并改写代码，并且修改其他程序文件以造成连锁破坏。存储器保护机制及其他形式的访问控制可以保护意外或恶意的代码更动。 冯·诺伊曼瓶颈（von Neumann bottleneck）：在内存容量指数级提升以后，CPU 和内存之间的数据传输带宽成为了瓶颈。缓解的办法有： 在 CPU 和内存之间提供 cache（缓存，速度比内存快很多倍） 将数据和指令分开存储并能够做到同时访问（在一般的冯·诺依曼结构中数据和指令放在同一内存通过同一数据总线访问，取数据和取指令不能同时进行，而哈佛结构则是将数据和指令分开，可同时访问） 分支预测和流水线 实际上，绝大多数现代计算机使用的是所谓的“Modified Harvard Architecture”，指令和数据共享同一个 address space，但缓存是分开的。在内存里，指令和数据是在一起的。而在 CPU 内的缓存中，还是会区分指令缓存和数据缓存，最终执行的时候，指令和数据是从两个不同的地方出来的。你可以理解为在 CPU 外部，采用的是冯诺依曼模型，而在 CPU 内部用的是哈佛结构。 大部分的DSP都没有缓存，因而直接就是哈佛结构。 上图是 i9-7980XE 18 核 36 线程的民用最强 CPU，其配合超频过的 DDR4 3200MHz 的内存，测试出的内存读取速度为 90GB/S。看起来很快了是不是？看看图中的 L1 Cache，3.7TB/S。 我们再来算算时间。这颗 CPU 最大睿频 4.4GHz，就是说 CPU 执行一个指令需要的时间是 0.000000000227273 秒，即 0.22ns（纳秒），而内存的延迟是 68.1ns。换句话说，只要去内存里取一个字节，就需要 CPU 等待 300 个周期，何其的浪费 CPU 的时间啊。 CPU L1 L2 L3 三级缓存是使用和 CPU 同样的 14 纳米工艺制造的硅半导体，每一个 bit 都使用六个场效应管（通俗解释成三极管）构成，成本高昂且非常占用 CPU 核心面积，故不能做成很大容量。 除此之外，L1 L2 L3 三级缓存对计算机速度的提升来源于计算机内存的「局部性」，相关内容我们之后会专门讨论。 RAM（Random Access Memory，俗称 内存）：内存最大的特点是：掉电失去数据。程序是静态的文件存放在外存中，进程正在运行的程序，进程存放在内存中。我们之所以使用内存是因为内存的速度比外存快 100 倍左右。 ROM（Read-Only Memory，只读存储器）：ROM 掉电不失去数据。]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[什么是字符集和编码]]></title>
    <url>%2F2019%2F04%2F21%2F%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[文本文件中，为了让比特表示文字，我们发明了字符集，让特定的比特序列对应特定的字符。 常见的字符集有： ASCII EASCII GB2312 GBK Unicode UTF-8 （严格来说 UTF-8 只是 Unicode 的一种编码方式） ANSI 编码 ASCII计算机诞生于美国，因此最早的时候，人们只需要表示英文 26 个字符在内的少数字符，用半个字节就可以表示完这些字符。这就是 ASCII 字符集，最高位为 0，其余 7 位可以表示的范围是：0~127。总共 128 个字符。 ASCII 字符分为：控制字符（不可显示） 和 可显示字符 其中，0x20 以下为控制字符，不可显示。比如，0x10 表示换行，0x07 表示发声。另外还有个特殊的控制字符：0x7f 表示删除，所以总共是 33 个控制字符，95 个可显示字符。 EASCII欧洲国家使用计算机之后，也有了创建字符集的需求，于是对 ASCII 进行扩展，使用了剩下一半字节的空间，0x80 - 0xff的定义就被填充成了希腊字母，罗马字母等符号。 此时，编码依旧控制在 8 位以内，相安无事。 GB2312 GB 是国标的意思 中国开始使用计算机，于是有了这个字符集，由于中文是象形文字，如果每个字符一个键的话，肯定放不下： 但我们有拼音，所以直接用美国键盘就行了。 GB2312 共收录了 6763 个汉字，其中一级汉字 3755 个，二级汉字 3008 个。它所收录的汉字已经覆盖中国大陆 99.75%的使用频率。 GB2312 的基本思想很简单，如果一个字符值为 127 及以下，那它就是一个单字节字符，和 ASCII 兼容；如果一个字符值为 127 以上，那它和后面的那个字符组成一个汉字。（同时，后面那个字符也一定是 127 以上的） 通过这个方式，我们扩展出来了 7000+的简体汉字，同时还把日本假名，罗马希腊字母，数学符号也容纳了进来。 同时还产生了一个新的概念，全角字符：ASCII 码里本身有的字符，也被我们扩展成了双字节字符。为了区分，前者称为半角字符，后者称为全角字符。比如逗号、冒号、引号等等都有半角和全角之分。 至此，中文也可以在计算机上表示了。 GBK K 是扩展的意思 7000 个简体汉字并不能把汉字穷举了，一些生僻字并不包含在 GB2312 里。 GB2312 表示，我可能还可以抢救一下，我还有另一半的潜力没有发挥呢！ 这另一半的潜力就是，第二个字节的0x00 - 0x7f部分。这部分空出来，是由于 GB2312 表示汉字时，要求两个字节都是在0x80 - 0xff范围内的。 填上这部分的空档之后，再生僻的字也被表示出来了，同时，我们还考虑到港澳台同胞的感受，包含了繁体字，一共大概增加了 20k 的汉字和符号。 Unicode随着时间的推移，互联网的兴起，不止海峡两岸，全世界范围内共建一个字符集的呼声越来越高。 Unicode，统一了所有地区的字符，且还在不断扩充中。Unicode 编码系统可分为 编码方式 和 实现方式 两个层次。Unicode 的实现方式称为 Unicode 转换格式（Unicode Transformation Format，简称为 UTF） UTF-8 兼容 ASCII，UTF-16 不兼容 ASCII。 UTF-8前面说的都是字符集，UTF-8 却是一种编码方式，因为它并不是去做字符集的事情，而是为的便于 Unicode 码的传输和存储而生的。UTF-8 兼容 ASCII 编码，所以应用非常广泛，几乎已经是互联网标准。 与其他的编码方式（如哈夫曼编码）的思想一致，UTF-8 的原则就是，使用不定长字节（1-6 字节）来表达一个字符，使用频率越高的字符，字节数越少。这样就能最大程度上节约空间。具体的编码方式如下： 12345单字节字符： 以0开头，后面7位表示字符，事实上，UTF-8的单字节字符就是ASCII字符，完美兼容；n字节字符： 第一个字节的前n位为1，第n+1位为0。读到此字节时，可以方便的知道后续多少字节是用来表示一个字符； 其余字节，以10开头。 1234567Unicode符号范围 | UTF-8编码方式(十六进制) | （二进制）—————————————————————–0000 0000-0000 007F | 0xxxxxxx0000 0080-0000 07FF | 110xxxxx 10xxxxxx0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 实际上从第二行对照开始，就存在空间浪费，因为右边的 x 的位数足够用来表示 0 到左边的第二个数所表示范围内的所有数，每行浪费的空间大小是左边的第一个数。 UTF-8 和 Unicode 是一一对应的，对于常用汉字，基本上都是占用 3 个字节，生僻汉字可能占用到 6 个字节。对于 GB2312 和 GBK 来讲，UTF-8 无疑造成了浪费，所以，UTF-8 可以说是对英文友好，但对中文不友好的一种编码方式。所以在中文界，GB2312 与 GBK 依旧有自己的市场。 ANSI 编码ANSI 并不是确定的一种编码，在简体中文操作系统指的是 GB2312，在繁体操作系统指的是 BIG5。 Windows 里说的「ANSI」其实是 Windows code pages，这个模式根据当前 locale 选定具体的编码，比如简中 locale 下是 GBK。把自己这些 code page 称作「ANSI」是 Windows 的臭毛病。在 ASCII 范围内它们应该是和 ASCII 一致的。 字符集（character set）与编码（encoding）的区别对于 ASCII、GB 2312、Big5、GBK、GB 18030 之类的遗留方案来说，基本上一个字符集方案只使用一种编码方案。 比如 ASCII 这部标准本身就直接规定了字符和字符编码的方式，所以既是字符集又是编码方案；而 GB 2312 只是一个区位码形式的字符集标准，不过实际上基本都用 EUC-CN 来编码，所以提及「GB 2312」时也说的是一个字符集和编码连锁的方案；GBK 和 GB 18030 等向后兼容于 GB 2312 的方案也类似。 于是，很多人受这些遗留方案的影响而无法理解字符集和编码的关系。 对于 Unicode，字符集和编码是明确区分的。Unicode/UCS 标准首先是个统一的字符集标准。而 Unicode/UCS 标准同时也定义了几种可选的编码方案，在标准文档中称作「encoding form」，主要包括 UTF-8、UTF-16 和 UTF-32。 所以，对 Unicode 方案来说，同样的基于 Unicode 字符集的文本可以用多种编码来存储、传输。所以，用「Unicode」来称呼一个编码方案不合适，并且误导。 字节顺序标记（BOM）这里涉及到一个 字节序 的概念，请先了解这个概念。 BOM（Byte-Order Mark）:一种为了跨平台设计的文件起始标记，但很多程序没去处理这个，用了 BOM 反而常造成问题。 在 UTF-16 中，字节顺序标记被放置为文件或字符串流的第一个字符，以标示字节顺序。 大端：0xFEFF 小端：0xFFFE]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计算机中的信息]]></title>
    <url>%2F2019%2F04%2F20%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[信息的本质信息的本质是消除不确定性：我们抛掷一枚硬币，然后用手盖住，出现正面朝上和反面朝上的概率都是二分之一。当我们偷看了结果，确定了是正面还是反面朝上，也就获得了信息。在这个例子中，我们消除的不确定性是一个二分之一的概率。在 香农 划时代的论文 通信的数学原理 中，首次提出了信息是可量化的，以及如何量化信息。我们以 bit 为信息的度量单位，一个 bit 可以是 0 或者 1，我们每获得一个 bit 的信息，就会消除一个二分之一的不确定性。 小思考题：如果我们抛掷的是一个骰子呢，当我们确定了一次投掷结果，我们获得多少信息（用 bit 为单位衡量）？我们都知道，骰子有 6 个面，分别刻有 1~6，我们有六分之一的概率得到其中任意一个面朝上。那么我们获得的信息应该是：$\log_2 6$。 信息计量单位比特（bit）：我们现在所使用的计算机都是二进制的电子计算机，每个 bit 非 0 即 1。之所以使用二进制是因为物理上容易实现，高电压或低电压。 字节（byte）：在计算机中为了方便的管理内存，我们以 8 个比特为一个单位，这个单位叫做字节。 在你购买宽带的时候，比如 100M 宽带，指的是 100Mb/s，换算成字节为单位的速度：$\frac{100Mb/s}{8}=12.5MB/s$。所以我们发现下载速度通常没有听起来那么夸张，因为下载的文件通常是以字节为单位的，而运营商口中的 100M 指的是以比特为单位的速度。 K、M、G：这三个是最常见的倍数单位，可以用来搭配 b（bit）或者 B（Byte）。它们都是词根的缩写，K 是 Kilo，表示$2^{10}$ ；M 是 Mega，表示$2^{20}$ ；G 是 Giga，表示$2^{30}$ 。 其实在一般的场合中，K 表示$10^3$，M 表示$10^6$，G 表示$10^9$。而我们看到上面都是以1024倍递增（$2^{10}=1024$），是 1000 的近似。在你购买硬盘的时候，厂商却是使用 1000 这一套进率的。比如 100GB 的硬盘，其实际容量只有：$\frac{100\times1000^3}{1024^3}=93.13GB$。而内存则是用 1024 进率算的，1GB 的内存就是$2^{30}$个字节，因为采用地址总线寻址，寻址空间必须是$2^n$，否则就会造成内存浪费或者定位到一个不存在的内存。 T、P：这两个如果你是程序员的话会比较常见。T 是 Tera，$2^{40}$；P 是 Peta，$2^{50}$。 往上走还有几个单位，但几乎没机会碰到：1EB（Exabyte 百亿亿字节 艾字节）=1024PB，1ZB (Zettabyte 十万亿亿字节 泽字节)= 1024 EB,1YB (Yottabyte 一亿亿亿字节 尧字节)= 1024 ZB,1BB (Brontobyte 一千亿亿亿字节)= 1024 YB. 字符集信息是 bit 位+上下文（这里的信息可以理解为：人能读懂的有意义的信息），比特位中的信息可以根据上下文被任意地解读。举个例子，这里有一个hello.c文件，文件内容如下： 123456#include &lt;stdio.h&gt;int main()&#123; printf("hello, world\n");&#125; 如果以 ASCII 编码 的话，每个字节的内容如下： 文本文件：内容是文本，文本文件都会采用一种特定的编码方式 二进制文件：除去文本文件，其他的都是二进制文件 如果你碰到过乱码问题，那么可以尝试了解一下：什么是字符集和编码 Windows 记事本的 bug（具体原因可以自己上网查）： 新建一个文本文件，输入“写”，保存之后再打开，乱码д。 新建一个文本文件，输入“联通”，保存之后再打开，乱码��ͨ。 字节序计算机的内存地址是按字节编号，比如 4GB 的内存，它的内存地址从 0 到$2^{30}$，这里有个问题就是多字节的数据如何确定存放顺序。有的计算机采用 大端 有的则采用 小端。 假设我有一个 int 型数（4 字节）：0x29 16 10 57 29 是高位，57 是低位，如果高位存放的内存地址也是高地址，那么我们就称之为 大端 字节序。反之就是 小端 字节序。]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C++ map的remove函数实现]]></title>
    <url>%2F2019%2F04%2F15%2FC%2B%2B%E7%9A%84map%E7%9A%84remove%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[今天同学群里面讨论了这样一段代码，说是产品出了bug，现场急着修复。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;string&gt;int main()&#123; std::cout &lt;&lt; "hello world" &lt;&lt; std::endl; std::map&lt;int, std::string&gt; mapPeople; mapPeople[1] = "hexu1"; mapPeople[2] = "hexu2"; // mapPeople[3] = "hexu3"; // mapPeople[4] = "hexu4"; std::map&lt;int, std::string&gt;::iterator iter = mapPeople.begin(); for (; iter != mapPeople.end(); iter++) &#123; if (iter-&gt;first == 2) &#123; std::cout &lt;&lt; "id : " &lt;&lt; iter-&gt;first &lt;&lt; ", name : " &lt;&lt; iter-&gt;second &lt;&lt; std::endl; mapPeople.erase(iter++); std::cout &lt;&lt; (iter != mapPeople.end()) &lt;&lt; std::endl; &#125; &#125; //for (; iter != mapPeople.end();) //&#123; // if (iter-&gt;first == 2) // &#123; // std::cout &lt;&lt; "id : " &lt;&lt; iter-&gt;first &lt;&lt; ", name : " &lt;&lt; iter-&gt;second &lt;&lt; std::endl; // mapPeople.erase(iter++); // if (iter == mapPeople.end()) // break; // &#125; // iter++; //&#125;// getchar(); return 0;&#125; 说是第一个for循环会崩溃，第二个for循环可以通过。经过分析，主要问题其实是出在对迭代器和erase的不熟悉上，导致错误的使用，这个程序的错误很明显，就是在erase这条分支中，iter++了两次。那么如何写一个正确的remove函数呢？代码如下： 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;string&gt;int main()&#123; std::cout &lt;&lt; "hello world" &lt;&lt; std::endl; std::map&lt;int, std::string&gt; mapPeople; mapPeople[1] = "hexu1"; mapPeople[2] = "hexu2"; mapPeople[3] = "hexu3"; mapPeople[4] = "hexu4"; std::map&lt;int, std::string&gt;::iterator iter = mapPeople.begin(); while (iter != mapPeople.end()) &#123; if (iter-&gt;first == 2) &#123; std::cout &lt;&lt; "id : " &lt;&lt; iter-&gt;first &lt;&lt; ", name : " &lt;&lt; iter-&gt;second &lt;&lt; std::endl; iter = mapPeople.erase(iter); continue; &#125; iter++; &#125; return 0;&#125; 另外，碰到删除的时候，要小心，可以这么写：iter = mapPeople.erase(iter);，也可以这么写：mapPeople.erase(iter++);（必须在删除前给迭代器++，否则迭代器会失效，这个问题那位程序员倒是考虑到了）。 最后我想说的一点是，根据指定key删除map中的元素，这个功能在其他语言中都有库函数可以调用，而C++却没有，还要自己动手写，而且需要对map的原理有一定的了解。这就从侧面反映了C++可能并不是一个高效的生产工具。]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hexo把英文引号渲染成中文引号的问题]]></title>
    <url>%2F2019%2F04%2F15%2Fhexo%E6%8A%8A%E8%8B%B1%E6%96%87%E5%BC%95%E5%8F%B7%E6%B8%B2%E6%9F%93%E6%88%90%E4%B8%AD%E6%96%87%E5%BC%95%E5%8F%B7%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[其实这个问题我早就发现了，但一直没太在意，今天写博客的时候又看到这个难看的引号，终于忍不住想看看到底出了什么问题。 首先我试了中文的单引号和英文的单引号，发现渲染效果都一样，然后想看看当我分别打中文单引号和英文单引号的时候，hexo 的渲染结果到底是不是一样。 打开 chrome 开发工具，发现页面上的英文单引号统一被渲染成了中文的单引号。 然后我手动修改页面看了下英文单引号是什么样子，发现样式确实很不一样。 那么问题就确定了：hexo 把英文引号渲染成了中文引号。 谷歌搜了一下：hexo 渲染 单引号 中文单引号，得到几条不错的结果： 求助：单引号显示异常 #1981 6.4.0 版本之后的两个问题 #462 对于我所使用的kramed，只需要在_config.yml中配置： 12kramed: smartypants: false 问题的原因是 markdown 渲染器把英文引号渲染成了中文引号，但这其实是可以配置的，所以解决起来比较简单。 在解决这个问题的过程中，如果你想顺利的解决问题，你需要的知识点有： 字符集的知识 Chrome 开发工具使用经验 前端开发知识 好的搜索习惯 一定的英语水平 查阅文档的意识和习惯 如果你已经具备了以上前提，那么就能比较轻松愉快的解决这个问题了。]]></content>
      <categories>
        <category>debug</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[动态数组的分摊分析]]></title>
    <url>%2F2019%2F03%2F03%2F%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%86%E6%91%8A%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[介绍动态数组在每次容量用尽时，重新申请 2 倍于当前数组的空间，并将原数组中的内容拷贝到新的空间，然后释放原数组的内存空间。对于动态数组，每次插入的花费有两种情况： 容量够用，我们只需要存储新的元素 容量不够用，创建新的空间，拷贝原数组进新的空间，再存储这个新的元素 分析方法有许多，统称为：amortized analysis（分摊分析） Lecture 21: Amortized Analysis 统计分析（aggregate method）把 n 词操作花费求和，然后取平均值。 每次扩容时，后半部分元素统一进行第一次移动，而这些元素之后的所有移动操作也是一起发生的，因而我们发现元素是以组为单位，组内的元素移动次数相同。那么有多少个这种组呢？第一组是单个元素，第二组也是单个元素，第三组是两个元素，第四组是四个元素，第五组是 8 个元素，... ，以此类推。而： $$1 + 1 + 2+ 2^2 + \cdots + 2^i = n$$ $$i = \log_2 n -1$$ 而这些组的移动次数分别是多少呢？最后一组元素只移动一次，倒数第二组元素移动 2 次，以此类推。所以总的移动次数是： $$1\times 2^i+2\times 2^{i-1}+3\times 2^{i-2}+\cdots+k\times 1$$ $$k = \log_2n + 1$$ 这个式子挺有规律的，我们可以将其分为很多个组，第一组是： $$1 + 1 + 2+ 2^2 + \cdots + 2^i = n$$ 第二组是： $$1 + 1 + 2+ 2^2 + \cdots + 2^{i-1} = \frac{n}{2}$$ 以此类推。 于是我们得到上式的等价表示： $$n + \frac{n}{2} + \cdots + 1 = 2n-1$$ 所以移动的平均次数是：$\frac{2n-1}{n}$，也就是每个元素最多移动 2 次，加上插入操作，最多三个操作。 银行算法（banker method）对动态数组的插入来说，大部分（后半部分）插入操作是不需要重新分配内存的，是廉价的操作。而少部分操作是需要重新分配内存的，是复杂的操作。我们可以试着想象在每次廉价操作的时候存储额外的费用，相当于存款，来支付复杂操作的费用。 我们假设一次基本的操作费用是一个硬币，当我们插入了一个下标为 n 的元素时： 我们要花费第一个硬币，作为基本的插入操作花费 我们还要存储第二个硬币，作为新插入的 n 在重新分配内存时移动它的费用 最后我们要存储第三个硬币，作为数组的前半部分的某个对应元素重新分配内存时移动费用 这样来计算，每个插入操作最多需要付出三个硬币，而第一个元素是不需要第三个硬币的。所以费用总数是：3n-1。 势能算法（Potential Method）首先说明一下，目前我对这个方法还是无法直观的理解。先祭出这个势能函数： $$\Phi(h) = 2n-m$$ 其中 n 是当前数组元素的个数，m 是当前数组内存空间大小。 每次插入的费用函数定义为： $$c+\Phi(h&#39;)-\Phi(h)$$ c 表示当前插入操作的总的花费，$\Phi(h&#39;)$是插入后的势能函数，$\Phi(h)$是插入前的势能函数。 这里分为两种情况： 如果n&lt;m，不必扩容，c=1，势能函数相差 2，所以加起来是 3 如果n=m，那么就要扩容，c=n+1，$\Phi(h&#39;)=2(n+1)-2n$，$\Phi(h)=2n-n$，加起来还是 3 所以费用函数其实是一个等于 3 的常数函数。]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[快速排序]]></title>
    <url>%2F2019%2F02%2F19%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[快速排序算法是一个原理非常简单易懂的算法，但如果现场手写的话又有多少人能写得出来呢？我今天又试了一下，发现还是存在一些认知上的问题。首先我明白快排的核心操作是：选取一个中枢，然后把小于中枢的放到左边，大于中枢的放到右边。但我发现时隔仅仅一年多，我居然已经忘了这个操作的英文名字了。直到我在写这篇文章的时候才突然想起来：partition 操作。 在使用 partition 操作的前提下，递归解决问题就 OK 了。 partition 具体操作如下： 我选取的中枢是第一个元素，且从前往后遍历数组。遇到小于中枢的，我要交换当前结点和中枢。遇到大于中枢的，直接略过。 第一个分支也就是遇到小于中枢的结点，这里才是操作比较复杂的部分，仔细想想其实这里要交换两次。将小于中枢的结点与中枢交换之后，中枢跑到了最后面，此时的结构相当于：小小小..大大大..中枢。我们还要将中枢塞到中间去。 1234567891011121314151617181920212223242526public void qsort(int[] array, int begin, int end)&#123; if(begin&gt;=end-1)&#123; return; &#125; int pivotIndex = partition(array, begin, end); qsort(array, begin, pivotIndex); qsort(array, pivotIndex+1, end);&#125;private int partition(int[] array, int begin, int end)&#123; int pivot = array[begin]; int pivotIndex = begin; int index = begin+1; while(index&lt;end)&#123; if(array[index]&lt;pivot)&#123; int temp = array[index]; array[index] = array[pivotIndex]; array[pivotIndex++] = temp; temp = array[index]; array[index] = array[pivotIndex]; array[pivotIndex] = temp; &#125; index++; &#125; return pivotIndex;&#125; 还可以思考一下： 选第一个元素做中枢，从后往前遍历 选最后一个元素做中枢，从前往后遍历 选最后一个元素做中枢，从后往前遍历 所以最后我发现快速排序确实是一个简单易懂的算法，难点在于 partition 操作的具体问题具体分析。四类 partition 全部写一遍。应该差不多了。 上面的方法归根结底都是使用 一个中枢 来划分，实际上也可以用两个指针来划分：一个记录小部的末尾，一个记录大部的首部。这两个指针一个从前往后，一个从后往前，直到相遇，本轮划分操作就结束。 于是我又抽空写了一下这个两个指针往中间靠的，结果并没有一遍写对，原因是边界检查，居然要不停的检查： 123456789101112131415161718192021private int partition1(int[] array, int begin, int end)&#123; int pivot = array[begin]; int smallEnd = begin; int bigBegin = end-1; while(smallEnd&lt;bigBegin)&#123; while (smallEnd&lt;bigBegin &amp;&amp; array[bigBegin]&gt;pivot)&#123; bigBegin--; &#125; if(smallEnd&lt;bigBegin)&#123; array[smallEnd++] = array[bigBegin]; &#125; while(smallEnd&lt;bigBegin &amp;&amp; array[smallEnd]&lt;pivot)&#123; smallEnd++; &#125; if(smallEnd&lt;bigBegin)&#123; array[bigBegin--] = array[smallEnd]; &#125; &#125; array[smallEnd] = pivot; return smallEnd;&#125; 这样感觉就太不美了。]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[并查集]]></title>
    <url>%2F2019%2F01%2F19%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[并查集什么是并查集并查集的核心是parent指针，一个结点可以找到自己所属的结点。从而把结点归类。有两个核心操作： Union（用来合并两个并查集） Find（用于查找一个结点的parent） 所以并查集可以叫做：union-find data structure。 什么是路径压缩我们看两个结点是否属于同一个并查集，实际上只看最顶层的那个parent，如果这两个结点属于同一个最顶层parent，那么它们就在同一个并查集中。 所以我们实际上只需要两层的树结构，让所有其他结点的parent指针指向最顶层parent，这样就能达到扁平化并查集的目的，从而使Find操作从O(logN)的时间复杂度变成O(1)。这就叫：路径压缩 代码如下： 123456public void findParent(UnionFindSetNode node)&#123; if(node.parent!=node)&#123; node.parent = findParent(node.parent); &#125; return node.parent;&#125; 这段代码很巧妙，可以在查找本结点父亲的时候，将路径上的所有祖先扁平化。 合并操作核心目标是：尽可能减少深度。所以需要注意的点是：把深度小的并查集归并到深度大的并查集。我们给并查集多添加一个深度属性：rank，比如两层的并查集，parent 的 rank 就是 1，叶子节点们的 rank 就是 0。 代码如下： 1234567891011121314public void union(UnionFindSetNode node1, UnionFindSetNode node2)&#123; UnionFindSetNode parent1 = findParent(node1); UnionFindSetNode parent2 = findParent(node2); if(parent1!=parent2)&#123; if(parent1.rank&gt;parent2.rank)&#123; parent2.parent = parent1; &#125;else if(parent1.rank&lt;parent2.rank)&#123; parent1.parent = parent2; &#125;else&#123; parent1.parent = parent2; parent2.rank++; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[KMP算法]]></title>
    <url>%2F2019%2F01%2F17%2FKMP%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[KMP 算法KMP 算法用来在一个文本中查找模式串，如下图所示： 文本匹配例子： 我们把上面那个长字符串的称为文本，下面这个短的称为模式串。我们的目的是查看ABADABAD是否出现在文本中。 不必要的比较： 跳过不必要的比较： KMP 算法的核心作用在于帮助模式串顺利的跳过很多不必要的比较（模式串没有任何前缀与文本匹配），直接后移到一部分前缀已经匹配的位置，开始下一次的比较。更准确的讲是移动到：最长真前后缀匹配的位置，如上图所示的ABA。 什么是真前后缀前缀和后缀我们都不陌生，比如单词ABA，它有三个前缀：A、AB、ABA，和三个后缀：A、BA、ABA。 真前后缀的意思是，前后缀必须是单词的真子集，也就是说不能是单词本身。所以上面那个单词ABA的真前缀是：A、AB，真后缀是：A、BA。 那么单词ABA真前后缀的最长匹配是：A。 那么真前后缀是否匹配有什么用？我们仔细观察文章最开头的文本匹配例子。在不必要的比较中，我们拿BADABA和ABADAB比较。而这两个，前者是模式串ABADABA部分的后缀，后者则是前缀。如果我们算得了ABADABA的真前后缀的最长匹配，就已经知道了BADABA和ABADAB不相等。而且还知道ADABA和ABADA也不相等，等等。 只要我们知道了真前后缀的最长匹配是什么，我们可以直接跳过所有这些没必要的比较。 KMP 的核心就是：在每一次失配的时候，利用最长真前后缀匹配长度，直接跳过不必要的比较。 next 数组next 数组也就是：部分匹配表（Partial Match Table）。就是一个最长真前后缀匹配长度表。 首先 next 数组只需要用模式串得出，它是对模式串的解析，跟要匹配的文本没有半毛钱关系。其次 next 数组记录的其实就是最长真前后缀匹配长度，但错开了一位。 真前后缀的意思是，前后缀不能是字符串本身，只能是字符串的真子集 i 0 1 2 3 4 5 6 7 8 模式串 A B A D A B A D \0 next[i] -1 0 0 1 0 1 2 3 4 i = 0，next[0]，我们填-1； i = 1，前面的字符串为A，其最长相同真前后缀长度为 0，即next[1] = 0； i = 2，前面的字符串为AB，其最长相同真前后缀长度为 0，即next[2] = 0； i = 3，前面的字符串为ABA，其最长相同真前后缀为A，即next[3] = 1； i = 4，前面的字符串为ABAD，其最长相同真前后缀长度为 0，即next[4] = 0； i = 5，前面的字符串为ABADA，其最长相同真前后缀长度为A，即next[5] = 1； i = 6，前面的字符串为ABADAB，其最长相同真前后缀长度为AB，即next[6] = 2； i = 7，前面的字符串为ABADABA，其最长相同真前后缀为ABA，即next[7] = 3； i = 8，前面的字符串为ABADABAD，其最长相同真前后缀为ABAD，即next[8]=4； 这张 next 表极其有用，前面说了，在字符串匹配的每一次失配的时候，我们都可以用已经匹配上的这段字符串的最长真前后缀匹配长度来定位将要跳转的位置。还是拿最开始的文本匹配例子： 当图一失配的时候，我们查ABADABAD的失配位置的 next 数组，也就是next[7]，得到ABADABA的最长真前后缀匹配长度3，然后拿&quot;ABADABAD&quot;.charAt(3)也就是D跟文本中失配处的字符&#39; &#39;继续匹配。如果又失配，那么递归处理。递归的边界是什么？答案是next[0]。 代码这个代码并不难写，我简单讲一下。 首先我们需要构造 next 数组，需要的参数只有一个：模式串。 然后我们使用一个指针遍历模式串，另一个指针负责记录匹配深度。 生成 next 数组，也是一个匹配的过程，遇到不匹配也要跳过不必要的比较，所以这实际上是一个递归的问题。 分支只有两个，匹配的时候：i++，j++，next[i]=j。不匹配的时候，递归查找下一个必要的匹配：j=next[j]。 12345678910111213141516171819202122232425262728293031323334private int[] getNextArray(String pattern)&#123; int[] nextArray = new int[pattern.length()+1]; nextArray[0]=-1; int i=0; int j=-1; while(i&lt;pattern.length())&#123; if(j==-1 || pattern.charAt(i)==pattern.charAt(j))&#123; i++; j++; nextArray[i]=j; &#125;else&#123; j = nextArray[j]; &#125; &#125; return nextArray;&#125;public int KMP(String text, String pattern)&#123; int[] nextArray = getNextArray(pattern); int i=0; int j=0; while(i&lt;text.length() &amp;&amp; j&lt;pattern.length())&#123; if(j==-1 || text.charAt(i)==pattern.charAt(j))&#123; i++; j++; &#125;else&#123; j = nextArray[j]; &#125; &#125; if(j==pattern.length())&#123; return i-j; &#125; return -1;&#125; 当然这种错开，和next[0]=-1的设定，不那么自然。其实可以有更自然的设计： i 0 1 2 3 4 5 6 7 8 模式串 A B A D A B A D \0 next[i] 0 0 1 0 1 2 3 4 这样一一对应就行了，next 数组也与模式串等长。 这种 next 表的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839private int[] getNextArray(String pattern)&#123; int[] nextArray = new int[pattern.length()]; int i=1; int j=0; while(i&lt;pattern.length())&#123; while(j&gt;0 &amp;&amp; pattern.charAt(i)!=pattern.charAt(j))&#123; j = nextArray[j-1]; &#125; while(i&lt;pattern.length() &amp;&amp; pattern.charAt(i)==pattern.charAt(j))&#123; nextArray[i++] = ++j; &#125; if(j==0)&#123; nextArray[i++] = j; &#125; &#125; return nextArray;&#125;public int KMP(String text, String pattern)&#123; int[] nextArray = getNextArray(pattern); int i=0; int j=0; while(i&lt;text.length() &amp;&amp; j&lt;pattern.length())&#123; while(j&gt;0 &amp;&amp; text.charAt(i)!=pattern.charAt(j))&#123; j = nextArray[j-1]; &#125; while(i&lt;text.length() &amp;&amp; j&lt;pattern.length() &amp;&amp; text.charAt(i)==pattern.charAt(j))&#123; i++; j++; &#125; if(j==0)&#123; i++; &#125; &#125; if(j==pattern.length())&#123; return i-j; &#125; return -1;&#125; 这段代码看起来远不如上面第一种 next 表的代码简洁清晰。下面做一个简化，去掉内部的循环： 1234567891011121314151617181920212223242526272829303132333435private int[] getNextArray(String pattern)&#123; int[] nextArray = new int[pattern.length()]; int i=1; int j=0; while(i&lt;pattern.length())&#123; if(j&gt;0 &amp;&amp; pattern.charAt(i)!=pattern.charAt(j))&#123; j = nextArray[j-1]; &#125; else if(pattern.charAt(i)==pattern.charAt(j))&#123; nextArray[i++] = ++j; &#125; else if(j==0)&#123; nextArray[i++] = j; &#125; &#125; return nextArray;&#125;public int KMP(String text, String pattern)&#123; int[] nextArray = getNextArray(pattern); int i=0; int j=0; while(i&lt;text.length() &amp;&amp; j&lt;pattern.length())&#123; if(j&gt;0 &amp;&amp; text.charAt(i)!=pattern.charAt(j))&#123; j = nextArray[j-1]; &#125; else if(text.charAt(i)==pattern.charAt(j))&#123; i++; j++; &#125; else if(j==0)&#123; i++; &#125; &#125; if(j==pattern.length())&#123; return i-j; &#125; return -1;&#125; 看代码很容易知道，文本的指针是只增不减的，而且只在失配且匹配深度大于 0的时候递归处理失配情况。但如何精确分析算法复杂度呢？ 算法复杂度分析这个算法的分析属于平摊分析。引入一个变量 k，k=2*i-j。观察下面的代码： 1234567while(j&lt;m &amp;&amp; i&lt;n)&#123; if(0&gt;j || T[i]==P[j])&#123; i++;j++; // k加1 &#125;else&#123; j = next[j]; // j至少减一，i不变，那么k至少加1 &#125;&#125; 由上述注释分析得出：k 单调递增。k 的最大值是2*n+1，而 k 是迭代次数的上界，所以算法最坏时间是：2*n+1，所以这是一个O(n)的算法。同理可得算出next表的时间复杂度是O(m)。所以总的算法复杂度是O(m+n)。]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[蓄水池算法]]></title>
    <url>%2F2019%2F01%2F15%2F%E8%93%84%E6%B0%B4%E6%B1%A0%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[蓄水池算法(Reservoir Sampling)这个算法真的很奇妙，它的核心是一个数学证明。外延，或者说应用场景是： $C_n^k$，也就是从大小为 n 的样本集中随机取 k 个不同的样本 流式数据，或者说无法直接根据索引拿到数据（更加不可能一遍加载到内存） 算法描述算法的描述其实很简单：维基百科：水塘抽样 1234567问题描述：从包含n个不同的项目的集合S中随机选取k个不同的样本。算法：从S中取首k个放入[水塘]中对每个S[j]项（j&gt;=k，数组从0开始）：true随机产生一个范围从0到j的整数rtrue若r&lt;k则把水塘中的第r项换成S[j]项最后得到的水塘就是抽样结果 这个算法保证了每一项最后可能存在于水塘中的概率都是一样的。 单看算法，你肯定不知道为什么是等概率，其实数学证明并不难，请看下面的证明： 数学证明我们把样本分为两类： 一类是首 k 个，它们一开始就在水塘中 一类是其他，它们一开始并不在水塘中 我们发现两个简单的逻辑： 对于水塘中的样本，只要随机数不选到该样本，该样本就不会被替换 水塘的某个项一旦被替换，就不可能再回到水塘，不会出现被替换掉，然后再回到水塘的局面，这样就保证了问题不会进一步变得复杂。所以：某个项被保留的概率 = 被选中到水塘的概率 * 后续不被替换的概率 分类讨论，首 k 个样本最终存在于水塘中的概率，和其余样本最终存在于水塘中的概率： 首 k 个样本，随便选一个做研究对象。被选中到水塘的概率为：1。（数组从 1 开始）从 j=k+1 开始考虑替换，第一次不被替换的概率是$\frac{k}{k+1}$，第二次不被替换的概率是$\frac{k+1}{k+2}$，第三次...，一直到最后一次不被替换的概率是$\frac{n-1}{n}$。所以该项被保留的概率 = $1\times\frac{k}{k+1}\times\frac{k+1}{k+2}\times\frac{k+2}{k+3}\times\cdots\times\frac{n-1}{n}=\frac{k}{n}$ 一开始不在水塘中的那一部分，随便选一个做研究对象。被选中到水塘的概率为：$\frac{k}{j}$，后续不被替换的概率$\frac{j}{j+1}$，一直到$\frac{n-1}{n}$。所以该项被保留的概率 = $\frac{k}{j}\times\frac{j}{j+1}\times\cdots\frac{n-1}{n}=\frac{k}{n}$ 到此我们就证明了所以样本最终存在于水塘中的概率都是$\frac{k}{n}$，这也完全符合了我们的数学期望。 代码弄个流式数据我们这里没有条件，只能用伪代码模拟一下： 1234567891011121314151617181920public Data[] reservoirSampling(int k, DataStream dataStream)&#123; Data[] reservoir = new int[k]; // init pool for(int i=0;i&lt;reservoir.length;i++)&#123; reservoir[i] = dataStream.getCurrentData(); dataStream.toNext(); &#125; Random random = new Random(); for(int i=k;!dataStream.isFinish();i++)&#123; int d = random.nextInt(i+1); if(d&lt;k)&#123; reservoir[d] = dataStream.getCurrentData(); &#125; dataStream.toNext(); &#125; return reservoir;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[$\lim\limits_{x\rightarrow 0} \frac{\sin x}{x} = 1$的证明]]></title>
    <url>%2F2019%2F01%2F07%2F%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%9E%81%E9%99%90%E7%9A%84%E8%AF%81%E6%98%8E%2F</url>
    <content type="text"><![CDATA[高数中的第一个证明，可能就是这个$\lim\limits_{x\rightarrow 0} \frac{\sin x}{x} = 1$的证明了。下面给出这个极限的证明，用到了解析几何（作图法）。 作图工具 Geometry 如图我们可以看到，有一个单位圆，圆心为 $A$ ，线段 $CE$ 的长度等于 $\sin x$，线段 $CB$ 是 弦（我们令他等于 $a$），弧 $\overset{\frown} {CB}$ 的长度就是 $x$，线段 DB 的长度等于 $\tan x$。 它们的长度的大小关系我们很容易得出： $\sin x &lt; a$，因为三角形的直角边小于斜边 $a &lt; x$，因为两点之间线段最短 $x &lt; \tan x$，这个略微不那么直接，可以用面积法（通过比较面积继而得到表达式中两个未知数的大小关系），扇形 $CAB$ 的面积：$\frac{1}{2} \cdot 1 \cdot x$ ，三角形 $\triangle DAB$ 的面积：$\frac{1}{2} \cdot 1 \cdot \tan x$ 。而 $CAB$ 的面积小于 $DAB$ 的面积。所以得到 $x &lt; \tan x$ 由此我们得到不等式：$\sin x &lt; x &lt; \tan x$ (当 $x&gt;0$ )，同时除以 $\sin x$，得到：$1 &lt; \frac{x}{\sin x} &lt; \frac{1}{\cos x}$。 当 $x&lt;0$ 时，显然 $\sin x &gt; x &gt; \tan x$，同时除以 $\sin x$（除以负数要变号），得到：$1 &lt; \frac{x}{\sin x} &lt; \frac{1}{\cos x}$。 令 $x\rightarrow 0^{-}$，由夹逼定理得到左极限 $\lim\limits_{x\rightarrow 0^{-}} \frac{\sin x}{x} = 1$ 令 $x\rightarrow 0^{+}$，由夹逼定理得到右极限 $\lim\limits_{x\rightarrow 0^{+}} \frac{\sin x}{x} = 1$ 最终可以得到：$\lim\limits_{x\rightarrow 0} \frac{\sin x}{x} = 1$ （左右极限都等于 1）]]></content>
      <categories>
        <category>数学</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[熟练使用JetBrains家的IDE]]></title>
    <url>%2F2018%2F11%2F04%2F%E7%86%9F%E7%BB%83%E4%BD%BF%E7%94%A8JetBrains%E5%AE%B6%E7%9A%84IDE%2F</url>
    <content type="text"><![CDATA[通用快捷键 格式化代码（reformat code）:win: ctrl+alt+Lmac: command+option+L 在一行的任意位置使用： shift + enter，新建下一行并跳到下一行。 善用代码自动补全功能，变量名和方法名等可以用 enter 补全。导入包可以用 alt + enter。 上下移动代码，ctrl+shift+上下键 Android Studio 生成函数注释：你在方法前输入/**然后一回车，自动帮你生成方法和参数的注释。 Intellj Idea快速打出常用语句： sout：System.out.println(); psvm： 123public static void main(String[] args) &#123;&#125; 使用 IDE 的右键中的生成 Getter Setter 选项自动生成 Getter Setter，使用 toString 自动生成 toString。 跳转到接口：ctrl+b； 跳转到实现类：ctrl + alt +B 上面这个按钮可以快速的在目录树中定位到当前类所在的路径 ctrl+alt+t]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[精通一款编辑器之sublime text 3]]></title>
    <url>%2F2018%2F11%2F04%2F%E7%B2%BE%E9%80%9A%E4%B8%80%E6%AC%BE%E7%BC%96%E8%BE%91%E5%99%A8%E4%B9%8Bsublime%20text%203%2F</url>
    <content type="text"><![CDATA[编辑器常用功能 格式化代码：格式化代码可以让你不用管代码的格式，可以放肆的写程序，你可以少敲很多空格，不用关心代码的格式问题，机器给出的代码格式风格统一且漂亮，一键解决你的格式问题，真是提高码代码效率的非常重要的功能。 查找文件：查找文件是在集成开发的时候非常重要的功能，当文件多起来的时候，快速定位到文件可以节省很多时间，甚至有时候文件实在太多，你只能通过查找的方式找到那个文件。 正则全文件查找和替换：轻松让你更改全局变量和配置，这是一个必须的功能，没有它简直无法想象工作量有多大。 代码收缩和扩展：代码太长怎么办，收缩和扩展啊。 安装卸载插件 cmd+shift+p：打开命令板，输入install，点击：Package Control: Install Package选项，然后搜索你想要的插件。 卸载请在命令板输入：remove，点击：Package Control: Remove Package选项。其实卸载无非就是两个词：remove和uninstall，多试试就行了。 打开命令板之后什么都不想干，怎么关闭命令板呢？其实很简单，再按一次打开命令板的快捷键就行了，开关都用同一个键或者按钮（术语叫：toggle，可开可关），这是比较通用设计理念。 基本快捷键 显示隐藏菜单栏：alt，如果你不小心把菜单栏隐藏了，除了用快捷键唤出，还真不知道有什么其他办法。 显示隐藏目录树：ctrl+k+b，这个功能可以在菜单栏中的 view 中找到，所以我觉得记不记无所谓 vue 插件 vue-syntax-highlight：可以让.vue文件高亮。 HTML-CSS-JS Prettify：可以格式化这三种语言的代码，特别是单文件的 vue，非常需要这个来同时格式化三种语言。不过需要配置一下。工具栏路径：Sublime Text -&gt; Preferences -&gt; Package Settings -&gt; HTML/CSS/JS Prettify -&gt; Plugin Options - Default，然后搜索：allowed_file_extensions，给这个配置项添加一个vue即可，要注意的是有四处有这个配置项，分别是html、css、js、json，如果你想它们全都能格式化，自然是要全都添加vue，但实验证明只加 html 里面就行了，如果在其他几个里面加反而引起了冲突。然后格式化代码的快捷键是什么呢？同样也有配置文件的，工具栏路径：Sublime Text -&gt; Preferences -&gt; Package Settings -&gt; HTML/CSS/JS Prettify -&gt; Keyboard Shortcuts - Default，可以看到： 12345678910111213141516[&#123; &quot;keys&quot;: [&quot;super+shift+h&quot;], &quot;command&quot;: &quot;htmlprettify&quot;&#125;, &#123; &quot;keys&quot;: [&quot;super+alt+h&quot;, &quot;p&quot;], &quot;command&quot;: &quot;htmlprettify_set_prettify_prefs&quot;&#125;, &#123; &quot;keys&quot;: [&quot;super+alt+h&quot;, &quot;o&quot;], &quot;command&quot;: &quot;htmlprettify_set_plugin_options&quot;&#125;, &#123; &quot;keys&quot;: [&quot;super+alt+h&quot;, &quot;k&quot;], &quot;command&quot;: &quot;htmlprettify_set_keyboard_shortcuts&quot;&#125;, &#123; &quot;keys&quot;: [&quot;super+alt+h&quot;, &quot;n&quot;], &quot;command&quot;: &quot;htmlprettify_set_node_path&quot;&#125;] 第一项即为使用这个插件的快捷键，也就是格式化代码的快捷键。 底栏设置显示文件编码在 mac osx 上一不小心按了 cmd+shift+c，文件的存储格式现在变成了 GBK 格式，当我再按下 cmd+s 保存时，提示我 UTF-8 格式的文件不能用 GBK 格式来保存。怎么解决这个问题呢？首先我想查看这个文件是什么编码，Sublime Text 的默认设置是不开启显示编码的，如果想开启，可通过菜单 Perference → Settings – User，在打开的配置文件里 ，在大括号后面，增加以下内容： 1234// Display file encoding in the status bar&quot;show_encoding&quot;: true,// Display line endings in the status bar&quot;show_line_endings&quot;: true, 此时保存该配置文件，就能够看到 sublime 最底下一行会显示文件编码格式了。以上的配置内容在 Perference → Setting─Default 都是 false 的。 然后在底栏点击文件编码，点击 reopen with encoding，然后选择 utf-8，然后 cmd+w 关闭窗口，然后 cmd+shift+t 重新打开刚刚关闭的窗口，就一切恢复正常了。]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[《CSAPP》 -- 处理器体系结构]]></title>
    <url>%2F2018%2F10%2F13%2F%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[阅读这篇文章必须要对汇编码有足够的了解，如果你对 IA32 汇编码还不够了解，可以先看看这篇文章：程序的机器级表示 Y86 指令集体系结构Y86 指令集基本上是 IA32 指令集的一个子集。这个指令集就是我们处理器实现的目标。如下图： IA32 的 movl 指令分成了 4 个不同指令：irmovl、rrmovl、mrmovl 和 rmmovl，i 表示立即数 Immediate，r 表示寄存器 Register，m 表示存储器 Memmory。第一个字母表示源，第二个字母表示目的。 这里不实现的功能有： 存储器引用方式是简单的基址+偏移量形式，不支持变址寄存器（second index register）和任何寄存器伸缩（scaling）。如果对操作数的结构不太了解可以看看这个：操作数指示符 和 IA32 一样不允许从一个存储器直接传送到另一个存储器地址。 不允许立即数传送到存储器 4 个整数操作指令：addl、subl、andl、xorl 7 个跳转指令：jmp、jle、jl、je、jne、jge、jg。 6 个条件传送指令：cmovle、cmovl、cmove、cmovne、cmovge、cmovg。 另外还有：call、ret、pushl、popl，halt 指令停止指令执行。IA32 中有一个与之相当的指令 hlt，IA32 的应用程序不允许使用这条指令，因为它会导致整个系统暂停运行。对于 Y86 来说，执行 halt 指令会导致处理器停止，并将状态码设置为 HLT。 指令编码与 IA32 一样使用小端编码。 每条指令的第一个字节表明指令的类型，这个字节分为两部分，每部分 4 位：高 4 位是代码（code）部分，低 4 位是功能（function）部分。代码值为 0~0xB。可以观察到，rrmovl与条件传送指令有同样的代码部分，可以把它看作是一个无条件传送。 寄存器编码如下： 举个例子：用 16 进制表示指令 rmmvol %esp, 0x12345(%edx)的字节编码。 从上面图中可以看到，rmmovl 第一个字节为 40，由于%esp 是 4（占 4 位），%edx 是 2（占 4 位），所以第二个字节是 42，最后再加上偏移量 00 01 23 45，小端表示是：45 23 01 00，所以最后得到指令的编码是：404245230100。 指令集的一个重要性质是字节编码必须有唯一解释，任意一个字节序列要么是一个唯一的指令，要么是一个不合法的指令。 相比于 IA32，Y86 没那么紧凑，IA32 对寄存器只用了 3 位来编码，5 位表明指令类型，所以 IA32 能将出栈入栈放进一个字节里。另外 IA32 可以将常数值编码成 1、2、4 字节，Y86 总是编码成 4 字节。 RISC 和 CISC RISC: reduced instruction set computers，精简指令集 CISC: complex instruction set computers，复杂指令集 Y86 异常 对于 Y86，当遇到这些异常的时候，我们简单的让处理器停止执行指令。在更完善的设计中，处理器通常会调用一个 exception handler（异常处理程序），这个过程被指定用来处理遇到的某种类型的异常，例如放弃程序或调用一个用户自定义的 signal handler（信号处理程序）。 Y86 程序12345678910int Sum(int *Start, int Count)&#123; int sum = 0; while (Count) &#123; sum += *Start; Start++; Count--; &#125; return sum;&#125; 可以看到 Y86 有时候需要两条指令来完成 IA32 一条指令就能完成的事。然而如果用数组索引来写这个程序，要转换成 Y86 会很困难，因为 Y86 没有伸缩寻址。 完整代码如下： 以.开头的是 assembler directive（汇编器命令），命令.pos 0告诉汇编器应该从地址 0 处开始产生代码。第 3、4 行使用的 Stack 标签，在最后有声明，其位置是 0x100。第 9 到 13 行声明了一个数组，4 字节对齐，值分别是：0xd，0xc0，0xb00，0xa000，array 标签是起址。 细节问题，pushl %esp（这个指令只能用汇编语言写，C 语言无法产生）是先把%esp 的值转移到栈，还是先%esp 减 4 再将结果转移到栈，实际上不同版本的 intel 处理器都会产生不同的结果，所以一个很重要的教训是要保证细节上的一贯性。 逻辑设计和硬件控制语言 HCL（Hardware Control Language）逻辑门 组合电路和 HCL 语言构建一个组合电路有两条限制： 两个或多个逻辑门的输出不能连接在一起。这样会导致线上的信号矛盾，产生不合法的电压或电路故障。 必须是无环的，也就是不能形成回路。 下面是个简单的例子： 用 HCL 来写这个网的函数就是：bool eq = (a &amp;&amp; b) || (!a &amp;&amp; !b) HCL 是用来 C 语言风格的语法，但这里同 C 语言不一样，该语句的意思不是执行了一次计算并将结果放入存储器，而是使用一个名字 eq 来称谓一个表达式。 实际上上面的组合电路就是同或，异或的表达式是：bool eq = (!a &amp;&amp; b) || (a &amp;&amp; !b) 多路复用器（multiplexor，通常称为：MUX）： bool out = (s &amp;&amp; a) || (!s &amp;&amp; b) 字级的组合电路和 HCL 整数表达式通常我们设计能对字（word）进行操作的组合电路，字级电路中用到的就是 HCL 整数表达式了。 字级与电路： bool Eq = (A == B); 也可以用异或来实现： 在 HCL 中，多路复用函数是用情况表达式（case expression）来描述的。情况表达式的通用格式如下： 12345678[ select_1 : expr_1; select_2 : expr_2; . . . select_k : expr_k;] 同 C 语言的 switch 语句不同，我们不要求不同的选择表达式之间互斥。从逻辑上讲，这些选择表达式是顺序求值的，且第一个求值为 1 的情况就会被选中。 字级多路复用电路： 用 HCL 来描述就是： 1234int Out = [ s: A; 1: B;]; 大多数人第一眼是看不懂这个表达式的，其实里面有个暗含的条件：先执行 s: A; 如果失败（没有输出 A）才会再执行 1: B;。而1: B;实际上是!s&amp;&amp;1: B;的简写。没有输出 A 就已经代表 s 是 0 了，那么!s 就是 1。 四路复用器： 123456int Out4 = [ !s1 &amp;&amp; !s0: A; # 00 !s1 : B; # 01 !s0 : C; # 10 1 : D; # 11]; 第二个表达式可以写成!s1，而不用写的更完整!s1&amp;&amp;s0，是因为另一种可能s0=0已经出现在了第一个选择表达式了，若能到达第二个选择表达式，则s0=1。类似的，第三个表达式可以写成!s0，第四个表达式可以简单的写成 1。 来看最后一个例子，假设我们想设计一个逻辑电路来找一组字 A、B 和 C 中的最小值，如下图所示： 用 HCL 来表达： 12345int Min3 = [ A&lt;=B &amp;&amp; A&lt;=C : A; B&lt;=A &amp;&amp; B&lt;=C : B; 1 : C;] 算术逻辑单元（arithmetic/logic unit, ALU） 集合关系 在这个电路中，两位的信号 code 就可以用来控制对 4 个数据字 A、B、C 和 D 做选择。根据可能的 code 值，可以用相等测试来表示信号 s1 和 s0 的产生： 12bool s1= code==2 || code==3;bool s0= code==1 || code==3; 还有一种更简洁的方式来表示这样的属性：当 code 在集合{2,3}中 s1 为 1，而 code 在集合{1,3}中 s0 为 1： 12bool s1= code in &#123;2,3&#125;;bool s0= code in &#123;1,3&#125;; 判断集合关系的通用格式：iexpr in {iexpr1, iexpr2, ... , iexprk} 存储器和时钟组合电路从本质上讲，不存储任何信息，它们只是简单的根据输入信号产生一个输出信号。为了产生时序电路（sequential circuit），也就是有状态并且在这个状态上进行计算的系统，我们必须引入按位存储信息的设备。存储设备都是由同一个时钟控制，时钟是一个周期性信号，决定什么时候要把新值加载到设备中。考虑两类存储器设备： 时钟寄存器（简称寄存器）存储单个位或字。时钟信号控制寄存器加载输入值。 随机访问存储器（简称存储器）存储多个字，用地址来选择该读或该写哪个字。随机访问存储器的例子包括：1.处理器的虚拟存储器系统（由硬件和操作系统结合起来使处理器可以在一个很大的地址空间内访问任意的字，硬件上包括由缓存、内存、外存）。2.寄存器文件，在此，寄存器标识符作为地址。在 IA32 或 Y86 处理器中，寄存器文件有 8 个程序寄存器（%eax、%ecx 等）。 正如我们看到的那样，在说到硬件和机器级编程时，“寄存器”这个词是有两个不同的意思的。需要避免歧义的时候，我们分别称呼这两类寄存器为：硬件寄存器和程序寄存器。 下图说明了硬件寄存器是如何工作的： 寄存器是作为电路不同部分中的组合逻辑之间的屏障。我们的 Y86 处理器会用时钟寄存器保存程序计数器（PC），条件码（CC）和程序状态（Stat）。 下图展示了一个典型的寄存器文件： 寄存器文件有两个读端口，一个写端口。每个端口都有一个地址输入，地址是图 4-4 中的寄存器标识符。这样一个多端口随机访问存储器允许同时进行多个读和写操作。 虽然寄存器文件不是组合电路，因为它有内部存储。不过在我们的实现中，从寄存器文件中读数据就好像它是一个以地址为输入、数据为输出的一个组合逻辑块。当 srcA 或 srcB 被设成某个寄存器 ID 时，在一段延迟之后，存储在相应寄存器上的值就会出现在 valA 或 valB 上。 向寄存器文件写入字是由时钟信号控制的，控制方式类似于将值加载到时钟寄存器。每次时钟上升时，输入 valW 上的值会被写入 dstW 指明的寄存器上。当 dstW 设为特殊的 ID 值 0xF 时，不会写任何程序寄存器。 由于寄存器文件既可以读又可以写，一个很自然的问题就是：如果我们同时读和写一个程序寄存器会发生什么？答案简单明了：我们会看到一个旧值到新值的变化。所以在设计处理器的时候要把这个问题考虑进去。 我们的处理器有一个随机访问存储器，如下图所示： 同寄存器文件一样，从存储器中读的操作方式类似于组合逻辑：如果我们在输入 address 上提供一个地址，并将 write 控制信号设置为 0，那么经过一些延迟之后，存储在那个地址上的值会出现在输出 data 上。如果地址超出了范围，error 信号会置为 1，否则就是 0。 写存储器是由时钟控制的：我们将 address 设置为期望的地址，将 data in 设置为期望的值，而 write 设置为 1。然后我们控制时钟时，只要地址是合法的，就会更新相应的地址中的值，如果是非法地址，error 就会置为 1。 Y86 的顺序实现将处理组织成阶段 取指（fetch）：从存储器取指令，地址为 PC 所指的地址。从指令中抽取出指令指示符字节的两个四位部分，称为 icode（指令代码）和 ifun（指令功能）。 译码（decode）：译码阶段从寄存器文件最多读入两个操作数，得到值 valA 和 valB（如果是两个的话）。通常，它读入指令 rA 和 rB 字段指明的寄存器，不过有些指令是读寄存器%esp 的。 执行（execute） 访存（memory）：访存阶段可以将数据写入存储器，或者从存储器读出数据。读出的值为 valM。 写回（write back）：写回阶段最多可以写两个结果到寄存器文件。 更新 PC（PC update）：将 PC 设置成下一条指令的地址。 处理器无限循环，执行这些阶段。在我们简化的实现中，发生任何异常时，处理器就会停止。比如：它执行 halt 指令或非法指令，或者它试图读或者写非法地址。在更完整的设计中，处理器会进入异常处理模式，开始执行由异常的类型决定的特殊代码。 在硬件上复制逻辑块的成本比软件中有重复代码的成本要大得多。而且在硬件系统中处理许多特殊情况和特性要比用软件来处理困难得多。 我们面临的一个挑战是将每条不同指令所需要的计算放入到上述的通用框架中。我们会使用图 4-17 中所示的代码来描述不同的 Y86 指令的处理。图 4-18 到 4-21 描述了不同 Y86 指令在各阶段是怎样处理的。 让我们看一个具体的例子，图 4-17 中的第三条指令： 图 4-17 中第五条指令： 图 4-17 中第六条指令： 图 4-21 表明了三类控制转义指令的处理：各种跳转、call 和 ret。 图 4-17 中第 8 条指令： 图 4-17 中第 13 条指令： SEQ 硬件结构]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[《CSAPP》 -- 程序的机器级表示]]></title>
    <url>%2F2018%2F10%2F08%2F%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[从编译 C 语言文件说起1$ gcc -01 -o p p1.c p2.c 使用了 gcc 命令来编译，也可以简单写作：cc。 优化层级为 1，1 级是最低的，层级越高程序优化越好，但增加了编译时间，也使调试变得更难，且跟源程序差异很大不便于理解。 编译的流程是： 预处理器（preprocessor）把诸如：#include、#define、#if、#else、#elif、#ifdef、#endif等预编译指令替换掉。 编译器（compiler）把.c源文件编译成.s的汇编代码文件。 汇编器（assembler）把汇编代码文件转换成相应的二进制目标文件.o，目标文件已经是机器码了，只是没有填入全局变量的地址。 链接器（linker），把多目标文件和库函数链接在一起，形成可执行文件。 instruction set architecture，ISA，指令集体系结构，定义了处理器状态，指令的格式和行为。intel 的指令集包括 32 位的：IA32，以及 64 位的：x86-64。 编译器做了整个编译流程的大部分工作，汇编代码几乎就是机器码的供人阅读版。所以看懂汇编代码是关键。 IA32 程序代码和 C 语言很不相同，一些在 C 语言下看不到的处理器状态可以在这里看到： 程序计数器（program counter，PC，也叫：instructor pointer，IP）在 IA32 中叫：%eip，指出下一条指令在内存中的位置 整数寄存器，可以用来保存数据 状态码寄存器，可以用来实现条件控制代码如：if 和 while 浮点寄存器，用来计算浮点数 例子1234567int accum = 0;int sum(int x, int y)&#123; int t = x + y; accum += t; return t;&#125; 如果要看到编译出的汇编代码，可以使用-S选项： 1$ gcc -01 -S code.c 这样就会使编译流程停留在 预处理-&gt;编译 阶段，而不是继续进行接下来的汇编和链接，生成的文件是：.s汇编文件。编译后的汇编代码中会包含如下代码： 12345678sum: pushl %ebp movl %esp, %ebp movl 12(%ebp), %eax addl 8(%ebp), %eax addl %eax, accum popl %ebp ret 这段代码中的每一句都对应一个机器指令，比如 pushl 这句的意思就是把寄存器%ebp 的内容 push 到程序栈（内存中）上。在汇编代码里所有的局部变量都不见了，全局变量还可以看到，因为编译器还没有决定这个变量在内存中的存储位置。 如果我们使用-c选项，GCC 就会既编译又汇编： 1$ gcc -01 -c code.c 这样就生成了目标文件code.o，在 800bytes 的 code.o 文件中，有 17bytes 是对应上面的汇编代码的： 155 89 e5 8b 45 0c 03 45 08 01 05 00 00 00 00 5d c3 可以使用反汇编将难懂的目标文件代码转成汇编代码： 1$ objdump -d code.o IA32 指令的长度是 1 到 15 字节，越常用的，操作数越少的指令越短，反之则越长。 给定一个开始的位置，只对应一种机器指令，比如只有pushl %ebp指令是以 55 开头的 反汇编只需要根据目标文件就可以翻译出汇编文件 反汇编出来的文件跟直接编译的汇编文件有些不一样，比如所有指令都省略了后缀l。l是大小指示符，而大多数情况下是可以省略 l 的。 头两个属性跟哈夫曼编码的原理是一致的，可以说这是一种通用的编码原则，第一条用来保证节省字节空间，第二条则保证编码的唯一性。 生成真正可执行的文件还需要链接操作，而且必须包含 main 函数。假设我们的main.c文件如下： 123int main()&#123; return sum(1, 3);&#125; 我们可以使用如下指令生成可执行文件： 1$ gcc -01 -o prog code.o main.c prog 文件增长到了 9123bytes，因为它不仅包含我们写的代码，而且包含了用来开始和结束的程序，以及与操作系统进行交互的程序。 可以看到第 6 行，全局变量在链接的时候定址。 汇编代码的格式假设我们有一个 C 语言文件simple.c： 12345int simple(int *xp, int y) 2&#123; int t = *xp + y; *xp = t; return t;&#125; 可以得到如下汇编代码： 12345678910111213141516.file &quot;simple.c&quot; .text.globl simple .type simple, @functionsimple: pushl %ebp movl %esp, %ebp movl 8(%ebp), %edx movl 12(%ebp), %eax addl (%edx), %eax movl %eax, (%edx) popl %ebp ret .size simple, .-simple .ident &quot;GCC: (Ubuntu 4.3.2-1ubuntu11) 4.3.2&quot; .section .note.GNU-stack,&quot;&quot;,@progbits 所有以.开头的行都是用来指导汇编器和链接器的，我们不用去管。而这段代码的大概意思如下： 123456789simple: pushl %ebp 保存帧指针 movl %esp, %ebp 创建新的帧指针 movl 8(%ebp), %edx 从内存中读取xp movl 12(%ebp), %eax 从内存中读取y addl (%edx), %eax *xp+y=t movl %eax, (%edx) 把t存到xp指向的地址中 popl %ebp 重新获取帧指针 ret 返回 这段代码对%ebp 和%esp 的操作涉及到了程序栈模型，看不懂很正常，文章下面会有讲解的。 ATT 和 intel 汇编格式ATT 即 AT&amp;T，是贝尔实验室旗下的公司。 GCC 和 OBJDUMP 默认生成 ATT 格式的汇编代码，微软和因特尔的编程工具则默认生成 intel 格式的汇编代码。 使用如下命令可以让 GCC 生成 intel 格式的代码： 1$ gcc -01 -S -masm=intel code.c 两者的区别如下： intel 代码省略了用来指定大小的后缀，比如使用mov而不是movl intel 代码省略了寄存器前面的%，比如使用esp而不是%esp intel 代码用了不同的方式来描述内存地址，比如使用DWORD PTR [ebp+8]而不是8(%ebp) intel 代码多操作数指令的操作数顺序跟 ATT 相反 由于是由 16bit 架构扩展到 32bit 架构的，intel 管 16bit 数据类型叫：word，32bit 数据类型叫：double words，64bit 数据类型叫：quad words。 数据格式 访问数据IA32 CPU 包含了 8 个寄存器，每个有 32bit 存储空间，用来存储整形值以及指针。 x86-64 则进一步扩展了这些寄存器： 前六个寄存器称为通用寄存器，有其特定的用途： %rax(%eax) 用于做累加，过程调用返回值 %rcx(%ecx) 用于计数 %rdx(%edx) 用于保存数据 %rbx(%ebx) 用于做内存查找的基础地址 %rsi(%esi) 用于保存源索引值 %rdi(%edi) 用于保存目标索引值 操作数指示符 有三种类型的操作数，立即数(Imm)、寄存器值(Reg)、内存值(Mem)。 mov 指令 pushl %ebp指令等价于下面的指令： 12subl $4,%esp 减小栈指针movl %ebp,(%esp) 把%ebp中的数据写到%esp指向的内存中 popl %eax指令等价于下面的指令： 12movl (%esp), %ebp 把%esp指向的内存地址中的值读到%eax中addl $4, %esp 增加栈指针 算术和逻辑操作load effective address，leal 指令，实际上是一个 movl 指令。 多个操作数的指令，注意一下两个操作数的顺序即可 位移操作位移的值是用一个单字节来表示，且数值只能是 0 到 31，所以这个字节只有低五位才会被考虑。 扩展乘除指令 控制状态码使用单比特的状态码来描述算数和逻辑运算的状态。最常用的状态码如下： CF: carry flag 进位符，用来表示最高位的进位。通常用来检测无符号运算的溢出 ZF: zero flag，零标志符，最近的操作产生了 0 SF: sign flag，符号位，最近的操作产生了负数 OF: overflow flag，溢出符，补码溢出，正负都可以，表示有符号溢出 举个例子：t=a+b，a、b、t 都是整形数。 1234CF: (unsigned)t&lt;(unsigned)a 无符号溢出ZF: (t==0) 零SF: (t&lt;0) 负数OF: (a&lt;0 == b&lt;0) &amp;&amp; (t&lt;0 != a&lt;0) 有符号溢出 OF 的表达式也可以写作：(a&lt;0 &amp;&amp; b0) || (a&gt;0 &amp;&amp; b&gt;0 &amp;&amp; t&lt;0)，也就是说 a、b 都是负数相加却是正数，或者 a、b 都是正数相加却是负数，这两种情况就代表溢出了。 leal 操作不会改变状态码，因为这个指令只是用来计算地址。除此之外表 3.7 中的所有操作都可能改变状态码。例如逻辑操作：XOR，会使 CF 和 OF 置零，移位操作会使 CF 置为最后一个移位出去的 bit，但 OF 要置零。自增和自减指令会设置 OF 和 ZF，不设置 CF。 CMP 指令类似于 SUB 指令，但只修改状态码而不改变其他寄存器，如果两个操作数相等，ZF 就会被设置；TEST 指令类似于 AND 指令，但只修改状态码而不改变其他寄存器，如果两个操作数是重复的： testl %eax,%eax，作用是检测%eax 是 0，还是正数，还是负数。 访问状态码有三种常用的方式访问状态码： 根据几个状态码的逻辑组合，设置单个字节为 0 或 1，也就是 set 指令 根据状态码，跳转到程序的其他分支 根据状态码传送数据 举个例子：计算a&lt;b，a 和 b 都是 int 型 1234a is in %edx, b is in %eaxcmpl %eax, %edx Compare a:bsetl %al Set low order byte of %eax to 0 or 1movzbl %al, %eax Set remaining byte of %eax to 0 setl 指令是：D &lt;- SF^OF，也就是有两种情况代表 a-b&lt;0： OF=0（a-b 没有发生溢出），且 SF=1（a-b 结果为负） OF=1（a-b 发生了溢出），且 SF=0（a-b 结果为非负） 第二种情况比较复杂，需要简单分析一下。a-b 发生了溢出，有两种情况：正溢出和负溢出。负溢出：a 是负数，b 是正数，但 a-b 结果为正（结果小于了最小的负数，发生溢出）；正溢出：a 是正数，b 是负数，但 a-b 结果为负（结果大于了最大的正数，发生溢出）。 比如： 123-128： 1000 0000127: 0111 1111-127: 1000 0001 a=-128, b=127, a-b=-128-127= $(1 0000 0001)_2$ , 从结果上来看就变成了 1（正数），这就是负溢出 a=127, b=-127, a-b=127-(-127) = $(1111 1110)_2$ , 从结果上来看就变成了 -2（负数），这就是正溢出 OF=1, SF=0，就是负溢出，而负溢出代表着 a 是负数，b 是正数，也就是a&lt;b 其他三个有符号比较以此类推。 跳转指令 可以看到条件跳转必须是直接的，而无条件跳转可以使用操作数。 跳转位置的编码有两种： 借助 PC 使用相对定位 使用绝对定位 实例如下： 12345678910jle .L2 if &lt;=, goto dest2 .L5: dest1: movl %edx, %eax sarl %eax subl %eax, %edx leal (%edx,%edx,2), %edx testl %edx, %edxjg .L5 if &gt;, goto dest1 .L2: dest2: movl %edx, %eax 目标文件和汇编文件对应如下： 123456788: 7e 0d jle 17 &lt;silly+0x17&gt; Target = dest2a: 89 d0 mov %edx,%eax dest1:c: d1 f8 sar %eaxe: 29 c2 sub %eax,%edx10: 8d 14 52 lea (%edx,%edx,2),%edx13: 85 d2 test %edx,%edx15: 7f f3 jg a &lt;silly+0xa&gt; Target = dest117: 89 d0 mov %edx,%eax dest2: 对应的关系是：0xd+0xa=0x17，0xf3+0x17=0xa，为什么是加下一条指令的地址而不是当前指令呢？这个传统要追溯到计算机的早期实现，当时的处理器会在执行每一条指令之前先更新一下 PC（program counter）。 12345678804839c: 7e 0d jle 80483ab &lt;silly+0x17&gt;804839e: 89 d0 mov %edx,%eax80483a0: d1 f8 sar %eax80483a2: 29 c2 sub %eax,%edx80483a4: 8d 14 52 lea (%edx,%edx,2),%edx80483a7: 85 d2 test %edx,%edx80483a9: 7f f3 jg 804839e &lt;silly+0xa&gt;80483ab: 89 d0 mov %edx,%eax 从反汇编代码来看，跳转如果使用 PC 相对地址，则不管代码存储到内存中的哪个位置，跳转的地址都不需要修改，且需要的编码更短。 翻译条件分支1234if(test-expr) then-statementelse else-statement 先写成等价的 goto 版本，然后就可以很轻松的转成汇编了 12345678t=test-expr;if(!t) goto false; then-statement goto done;false: else-statementdone: 从汇编的角度看 &amp;&amp;短路 原理： 12345void cond(int a, int *p)&#123; if (p &amp;&amp; a &gt; 0) *p += a;&#125; 12345678910a %ebp +8, p at %ebp +12movl 8(%ebp), %edxmovl 12(%ebp), %eaxtestl %eax, %eaxje .L3testl %edx, %edxjle .L3addl %edx, (%eax).L3: 可以看到第一个条件通不过的时候就跳过了第二个条件判断。 循环do while123do body-statement while(test-expr) goto 版本： 12345loop: body-statement t = test-expr; if (t)goto loop; while12while (test-expr) body-statement 先转成 do while 形式： 123456if (!test-expr) goto done;do body-statement while (test-expr);done: 在把 do while 转成 goto 版： 123456789t = test-expr;if (!t) goto done;loop: body-statement t = test-expr; if (t) goto loop;done: for12for (init-expr; test-expr; update-expr) body-statement 先转成 while 形式： 12345init-expr;while (test-expr) &#123; body-statement update-expr;&#125; 然后转成 do while 形式： 12345678init-expr;if (!test-expr) goto done;do &#123; body-statement update-expr;&#125; while (test-expr);done: 最后转成 do while 的 goto 版本： 1234567891011init-expr;t = test-expr;if (!t) goto done;loop: body-statement update-expr; t = test-expr; if (t) goto loop;done: 状态转移指令 1v = test-expr ? then-expr : else-expr; goto 版： 1234567if (!test-expr) goto false;v = true-expr;goto done;false: v = else-expr;done: switchswitch 主要使用了跳转表： 123456789101112131415161718192021int switch_eg(int x, int n) &#123; int result = x; switch (n) &#123; case 100: result *= 13; break; case 102: result += 10; /* Fall through */ case 103: result += 11; break; case 104: case 106: result *= result; break; default: result = 0; &#125; return result;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142int switch_eg_impl(int x, int n) &#123; /* Table of code pointers */ static void *jt[7] = &#123; &amp;&amp;loc_A, &amp;&amp;loc_def, &amp;&amp;loc_B, &amp;&amp;loc_C, &amp;&amp;loc_D, &amp;&amp;loc_def, &amp;&amp;loc_D &#125;; unsigned index = n - 100; int result; if (index &gt; 6) goto loc_def; /* Multiway branch */ goto *jt[index]; loc_def: /* Default case*/ result = 0; goto done; loc_C: /* Case 103 */ result = x; goto rest; loc_A: /* Case 100 */ result = x * 13; goto done; loc_B: /* Case 102 */ result = x + 10; /* Fall through */ rest: /* Finish case 103 */ result += 11; goto done; loc_D: /* Cases 104, 106 */ result = x * x; /* Fall through */ done: return result;&#125; 汇编代码如下： 跳转表的步长是 4 .rodata 的意思是：read only data 过程调用 有以下几个要点： 栈是倒着长的 每个过程调用都有一个 stack frame，栈帧 栈顶帧用两个指针来维护，一个是帧起址：%ebp，一个是栈指针：%esp 指向栈顶。 %esp 在过程运行的时候可能会被抹掉，这时候可以通过%ebp 来定位。 可以看到返回地址在每一帧的最后。而每一帧的第一个位置存放着上一帧的帧起址%ebp。帧的中间则放置局部变量、过程参数等值。 有以下几种情况会将局部变量放到栈帧中： 局部变量多到寄存器放不下 局部变量是数组或者结构体，必须用到引用 局部变量使用了取址符&amp;，所以我们必须给它生成地址 转移控制 call 指令的效果是：把返回地址 push 到栈中，然后跳到调用程序的地址（也就是把 PC 设置一下）。返回地址是汇编代码中 call 指令后面那条指令的地址。 ret 指令把栈顶的返回地址 pop 出来，并跳转到这个地址。 寄存器使用传统%eax, %edx, %ecx 是调用者保存寄存器。也就是说当过程 Q 被过程 P 调用，过程 Q 可以随意的写这三个寄存器，因为在调用 Q 之前 P 必须保存这三个寄存器的值。 %ebx, %esi, %edi 是被调用者保存寄存器。也就是说在过程 Q 写这些寄存器之前，必须保存里面的值，并在 return 之前恢复原样。 过程调用例子12345678910111213141516171819int swap_add(int *xp, int *yp)&#123; int x = *xp; int y = *yp; *xp = y; *yp = x; return x + y;&#125;int caller()&#123; int arg1 = 534; int arg2 = 1057; int sum = swap_add(&amp;arg1, &amp;arg2); int diff = arg1 - arg2; return sum * diff;&#125; 一些编程语言，比如 Pascal，提供了值传参和引用传参。但 C 语言只有值传参，C++提供了引用传参。C 语言可以通过指针来实现引用传参。 总共申请了 24 字节的空间，8 字节用来存局部变量，8 字节用来存参数，还有 8 字节未使用。 为什么要浪费 8 字节，原因是：内存对齐。GCC 遵循一个 x86 编程方针：栈空间必须是 16 的整数倍，包括保存%ebp 的 4 字节和返回地址的 4 字节。这里总共加起来是 24 字节，所以需要额外的 8 字节填充成 32 字节。 swap_add 的汇编代码如下： 分为三个部分：setup、body、finish setup: 1234swap_add: pushl %ebp Save old %ebp movl %esp, %ebp Set %ebp as frame pointer pushl %ebx Save %ebx 首先要保存调用者的帧基指针，然后重新设置当前帧基指针，然后如果用到%ebx,%esi,%edi 等寄存器就需要保存。 body: 1234567movl 8(%ebp), %edx Get xpmovl 12(%ebp), %ecx Get ypmovl (%edx), %ebx Get xmovl (%ecx), %eax Get ymovl %eax, (%edx) Store y at xpmovl %ebx, (%ecx) Store x at ypaddl %ebx, %eax Return value = x+y 获取参数，进行计算。 finish: 123popl %ebx Restore %ebxpopl %ebp Restore %ebpret Return 恢复两个寄存器，同时%esp 回到了上一个帧的栈顶，指向了返回地址，然后 ret 指令就可以把 PC 置为返回地址了，这样就完成了控制权的转移。 然后执行调用完 swap_add 之后的代码： 12345movl -4(%ebp), %edxsubl -8(%ebp), %edximull %edx, %eaxleaveret leave 指令的作用是重置栈指针和帧指针，也可以使用 popl 来重置，很简单： 1234//使%esp指向%ebp的地址（也就是Saved %ebp那里）movl %ebp, %esp//popl指令会导致%esp+4，所以%esp之后会指向上一帧的帧尾（也就是Return Address那里），popl的内容则放到了%ebp里面popl %ebp 而之后的ret指令继续将Return Address pop 出来，并将Return Address放到 PC 中。 从这个例子我们可以看出，编译器遵循一组简单的惯例来管理栈结构。 通过%ebp 加偏移量（+8,+12,...）访问参数 通过 push 指令或者栈指针减偏移量来分配栈空间 在返回前恢复保存好的寄存器，并使栈指针指向调用者的返回地址（Return Address） 数组、多维数组、结构体、联合体这些都比较简单，这里略过。 要注意的点：只有 call 才会 push 一个返回地址，所以 swap_add 的栈帧中并没有返回地址，说明它没有调用其他函数 指针每种数据类型都有对应的指针类型，但指针类型不是机器码的一部分，只是 C 语言提供的一种抽象，帮助程序员避免犯错。 内存引用越界和缓冲区溢出我们可以看到 C 语言对数组引用没有任何边界检查，而且栈里面既保存了局部变量又保存了寄存器值以及返回地址。所以一旦数组越界写就会破坏整个程序的运行。 看下面这个例子： 1234567891011121314151617181920212223/* Sample implementation of library function gets() */char *gets(char *s)&#123; int c; char *dest = s; int gotchar = 0; /* Has at least one character been read? */ while ((c = getchar()) != '\n' &amp;&amp; c != EOF) &#123; *dest++ = c; /* No bounds checking! */ gotchar = 1; &#125; *dest++ = '\0'; /* Terminate string */ if (c == EOF &amp;&amp; !gotchar) return NULL; /* End of file or error */ return s;&#125;/* Read input line and write it back */void echo()&#123; char buf[8]; /* Way too small! */ gets(buf); puts(buf);&#125; 这段 C 语言代码对应的汇编代码如下： 分配数组空间的时候是直接固定了 8 字节，这里给 buf 分配的空间也是 8 字节：leal -12(%ebp), %ebx，并把 buf 作为参数放置于栈顶。 我们可以看到，当读写 buf[8]的时候，实际上是在读写Saved %ebx。 通常给被攻击的程序输入一个字符串，这个字符串包含了可执行代码的字节编码，如果我们通过缓冲区溢出修改了返回地址，那么 ret 指令就可以跳转到我们攻击代码的位置。 蠕虫（worms）和病毒（viruses）的区别：相同点：都可以复制和传播自身，不同点：蠕虫可以自己运行，病毒是把自己加入到其他程序中，包括操作系统代码，病毒是不能独立运行的。 对抗缓冲区溢出攻击的方法栈随机化攻击者需要插入攻击代码（一个字符串），并知道攻击代码的位置（也就是字符串存放的栈地址），而且指向这段字符串的指针也是这个字符串的一部分。如果栈的位置是固定的，那么就很容易猜到攻击代码的存放位置。用如下代码可以检测栈的位置： 12345int main() &#123; int local; printf("local at %p\n", &amp;local); return 0;&#125; 只需要打印一个局部变量的地址。 栈随机化的思想是程序每次运行时栈的位置都不一样，实现方式是：程序开始时，在栈上分配一段 0~n 字节之间的随机大小的空间，例如使用alloca可以在栈上分配空间。程序不使用这段空间，它的作用是使后续栈的位置发生变化。分配的 n 必须足够大，这样才能有足够多的变化，但又必须足够小，这样才不会浪费空间。 栈随机化是更大一类技术的一种，这类技术称为：Address-Space Layout Randomization，ASLR，地址空间布局随机化。但攻击者还是可以采取一定措施来增加攻击成功率，一种常见的手段就是在攻击代码前中插入很长一段的nop指令，这个指令只会使程序计数器（PC）加一，除此之外没有任何副作用。只要攻击者能够猜中这段序列中的某个地址，就可以顺利到达攻击代码。这个序列的常用术语是：nop sled 空操作雪橇。 栈破坏检测在局部缓冲区和栈状态之间插入一个随机的金丝雀值（也叫哨兵值），一旦发现这个值被改变，就说明缓冲区溢出了，那么就可以将程序异常中止。 攻击者只有输入局部缓冲区变量的权限，所以无从得知金丝雀值。 GCC 默认就会插入金丝雀值，如果不想要可以使用参数：-fno-stack-protector来阻止 GCC 产生这种代码。当不使用此参数时，产生代码如下： 指令参数%gs20, %eax指明金丝雀值使用 segmented addressing（段寻址）从存储器中读入。将段标志为只读，这样攻击者就不能同时修改段中的金丝雀值。最后使用xorl比较段和栈中的金丝雀值，如果不相等则call __stack_chk_fail。 这种做法可以带来很小的性能损失。 限制可执行代码区域在典型的程序中，只有保存编译器产生的代码的那一部分存储空间才需要是可执行的。其他部分可以被限制为只允许读写。虚拟存储器空间在逻辑上分成了页（page），典型的每页是 2048 或者 4096 字节。由硬件提供存储器保护。以前，x86 体系结构将读和执行访问控制合并成一个 1 位标志，所以任何被标记为可读的部分也是可执行的，当然也有很多机制可以限制一些页是可读的但是不可执行，然而这些机制都很消耗性能。最近，AMD（Advanced Micro Devices）为它的 64 位处理器的内存加入了 NX, No-eXecute，不可执行位，intel 也跟进了，检查页是否可执行由硬件来完成，效率上没有任何损失。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[浮点数原理]]></title>
    <url>%2F2018%2F09%2F27%2F%E6%B5%AE%E7%82%B9%E6%95%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[浮点数的作用：区别于整形数，用来表示小数。可以用来表示很大的数，或者非常接近 0 的小数，或者近似的做实数计算，浮点数的一般形式：$x\times 2^y$。 IEEE（pronounced “Eye-Triple-Eee”）浮点数标准 是行业内公认的标准。 rounding：when a number cannot be represented exactly in the format and hence must be adjusted upward or downward。可以翻译为：舍入。 十进制的小数表示：$d_m d_{m-1} \cdots d_1 d_0 . d_{-1} d_{-2} \cdots d_{-n}$，写成数学表达式： $$d = \sum_{i=-n}^m 10^i \times d_i$$ 相应的，二进制也可以写成这种形式： $$b = \sum_{i=-n}^m 2^i \times b_i$$ 浮点数的表示IEEE 浮点数的格式：$V = (-1)^s \times M \times 2^E$ s 是符号（Sign），s 为 0 时是正，s 为 1 时是负 M 是有效数字（Significand，即 尾数） E 是 指数，Exponent，也叫 幂数，阶码 隐含的 基数 是 2 下图是浮点数的内存分布模型，首先是符号域，然后是指数域，最后是分数域： 符号位 s 个，符号位只需要一位，s=1 指数位 k 个，指数域 $exp=e_{k-1}\cdots e_1 e_0$，用来计算指数 E 分数为 n 个，分数域 $frac=f_{n-1}\cdots f_1 f_0$，用来计算有效数字 M 32 位浮点数（单精度，float 型）中，s=1，k=8，n=23；64 位浮点数（双精度，double 型）中，s=1，k=11，n=52。 正常化值（Normalized Values）当 $exp$ 域既不是全 0，也不是全 1 的时候，就是正常化值。 $E = e - Bias$，其中 $e$ 就是 $exp$ 域：$e_{k-1}\cdots e_1e_0$ 的值（除去全 0 和全 1 之后，取值范围是 1 到$2^k-2$），$Bias=2^{k-1}-1$（单精度的时候是 127，双精度的时候是 1023），那么 $E$ 的取值范围，单精度的时候是：-126 ~ +127，双精度的时候是：-1022 ~ +1023，其实 $E$ 的算法就是 移码 的计算方法。 $M = 1+f$，$0\le f\lt 1$，内存里只记录 f，而 1 作为一个前导值计算时候再加上，所以 f 是分数域 $frac$ 的 $0.f_{n-1}\cdots f_1f_0$ 这种形式 非正常化值（Denormalized Values）当指数域全 0，就是非正常化格式。 在这种情况下，指数值是 $E = 1-Bias$，也就是固定了，有效数字值 $M = f$ 也就是没有前导 1 了。这个格式下可以表示 0，因为正常化值中，一定有： $M\ge 1$，所以我们无法在正常化值格式下表示 0。当符号位是 0，有效数字 $M=f=0$，我们得到的就是+0.0，当符号位是 1 的时候就是-0.0。 除了可以表示 0，这个格式的另一个作用就是用来表示非常接近 0 的数。 特殊值（Special Values）当指数域全 1 的时候，且分数域是全 0，就表示无穷大，如果符号域为 0，表示 $+\infty$，如果符号位是 1，则表示 $-\infty$。无穷大可以作为溢出的结果，当我们用两个很大的数相乘，或者除以 0； 当指数域全 1，且分数域并非全 0 的时候，结果可以叫做：NaN（Not a Number 的简写），这种值用来表示不能用实数或者无穷大表示的计算结果，比如计算：$\sqrt{-1}$ 或者 $\infty - \infty$。 综合理解下图是三类浮点数在数轴上的显示： 可以看到非正常化值集中在 0 附近，正常化值散布在整个数轴的空间，特殊值则只表示两个无穷值。 下图是浮点数三种类型的光滑衔接： 看完浮点数的设计和构造我们可以发现以下这些特点： 从编码上有效数字域采用了无符号整数编码，而指数域采用了移码编码 非正常化值均匀分布在 0 附近 正常化值的间隔随着 $2^E$ 变大而逐渐变大，也就是精度逐渐降低 精度是分组的，以 $2^E$ 增加 1 为一组，每组有 $2^n$ 个数（n 是有效数字域的位数） 最高精度就是两个非正常化值的间隔，最低精度是最大的一组正常化值的相邻两数的间隔。 非正常化值按照精度只占一组，正常化值的数量是非正常化值数量的 $2^{k}-2$ 倍 正常化值的第一组的精度和非正常化值的精度一样，也就是实现了无缝衔接 浮点数的计算舍入 Rounding 维基百科 各种 Rounding 合集图 浮点数中使用的是：舍入到最近的偶数，因为舍入结果放大和缩小各占 50%的概率，这样就可以防止最终结果偏大或者偏小。 下面是把浮点数舍入到小数点后两位数： $10.00011_2(2\frac{3}{32})$ -&gt; $10.00_2(2)$ 不到一半，正常四舍五入$10.00110_2(2\frac{3}{16})$ -&gt; $10.01_2(2\frac{1}{4})$ 超过一半，正常四舍五入$10.11100_2(2\frac{7}{8})$ -&gt; $11.00_2(3)$ 正好一半，保证最后一位是偶数，所以向上舍入$10.10100_2(2\frac{5}{8})$ -&gt; $10.10_2(2\frac{1}{2})$ 正好一半，保证最后一位是偶数，所以向下舍入 浮点数加减运算基本性质 相加可能产生 infinity 或者 NaN 不满足交换律，不满足结合律（因为舍入会造成精度上的损失） 加上 0 等于原来的数 除了 infinity 和 NaN，每个元素都有对应的相反数 除了 infinity 和 NaN，满足单调性，即 $a\ge b \rightarrow a+c\ge b+c$ 1234567891011121314#include &lt;iostream&gt;using namespace std;int main()&#123; // 浮点数加法不满足交换律 cout &lt;&lt; 3.14 + 1e20 - 1e20 &lt;&lt; endl; cout &lt;&lt; 1e20 - 1e20 + 3.14 &lt;&lt; endl; // 浮点数加法不满足结合律 cout &lt;&lt; (3.14 + 1e20) - 1e20 &lt;&lt; endl; cout &lt;&lt; 3.14 + (1e20 - 1e20) &lt;&lt; endl; return 0;&#125; 运行结果: 123403.1403.14 具体细节设两个浮点数 $x$ 和 $y$： $$\begin{cases}x=(-1)^{s_x} M_x 2^{E_x} \y=(-1)^{s_y} M_y 2^{E_y}\end{cases}$$ 则浮点数加减运算结果为： $$x\pm y = \left((-1)^{s_x}M_x 2^{E_x-E_y} \pm (-1)^{s_y}M_y \right)2^{E_y}$$ 对阶：首先要把指数位（阶码）调成一样，并相应的使 M 移位，由于有效域左移会引起最高有效位丢失，误差大，所以采用右移，此时阶码要增加。所以对阶原则是：小阶向大阶看齐。 有效数加减：简单的无符号数字相加减。 规格化：有效数求和结果可能大于 1，那么就向右规格化：尾数右移 1 位，阶码加 1。 舍入：对于右移出去的位，采取舍入 检查阶码是否溢出： 阶码下溢：运算结果为非规格化数 阶码上溢：置溢出标志 浮点数加减实例$x=3.14, y=2.718$ 求 $z=x+y$。 首先算出 $x$ 和 $y$ 的内存表示： $x = 3+0.14$，3 的二进制表示是11，0.14 的二进制要稍微计算一下，我们让 0.14 不断的乘以 2（也就是左移），得到的整数位部分就是其二进制值的一位： 12345670.14 * 2 = 0.28 00.28 * 2 = 0.56 00.56 * 2 = 1.12 10.12 * 2 = 0.24 0... 我们可以写个程序来完成这个计算工作： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;using namespace std;// 获取整形数的位数int getDigits(int num)&#123; int count = 1; while(num/10&gt;0)&#123; num %= 10; count++; &#125; return count;&#125;/** * 获取小数的二进制表示 * @params precision 二进制表示精确到多少位 * @params num 小数的整数表示 */char* getFloatBitset(int precision, int num)&#123; char* res = new char[precision]; int digits = getDigits(num); int mod = pow(10, digits); char printFormat[50]; sprintf(printFormat,"%%0.%df",2); // cout &lt;&lt; printFormat &lt;&lt;endl; for(int i=0;i&lt;precision;i++)&#123; printf(printFormat, num*1.0/mod); cout &lt;&lt; " * 2 = "; num &lt;&lt;= 1; if(num &gt;= mod)&#123; printf(printFormat, num*1.0/mod); cout &lt;&lt; " 1" &lt;&lt; endl; num %= mod; res[i] = '1'; &#125;else&#123; printf(printFormat, num*1.0/mod); cout &lt;&lt; " 0" &lt;&lt; endl; res[i] = '0'; &#125; &#125; return res;&#125;/** * 获取小数的二进制表示 * @params precision 二进制表示精确到多少位 * @params num 浮点型小数 * @params digits 输入的时候浮点型小数的位数 */char* getFloatBitset2(int precision, float num, int digits)&#123; char* res = new char[precision]; int mod = pow(10,digits); // cout&lt;&lt;mod&lt;&lt;endl; char printFormat[50]; sprintf(printFormat,"%%0.%df",2); for(int i=0;i&lt;precision;i++)&#123; printf(printFormat, num); cout &lt;&lt; " * 2 = "; num*=2; num = round(num*mod)/mod; if(num &gt;= 1)&#123; printf(printFormat, num); cout &lt;&lt; " 1" &lt;&lt; endl; num -= 1; res[i] = '1'; &#125;else&#123; printf(printFormat, num); cout &lt;&lt; " 0" &lt;&lt; endl; res[i] = '0'; &#125; &#125; return res;&#125;int main(int argc, char* argv[])&#123; // char* res = getFloatBitset(atoi(argv[1]), atoi(argv[2])); char* res = getFloatBitset2(atoi(argv[1]), atof(argv[2]), atoi(argv[3])); cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; 上面代码保存成：float2Bitset.cpp文件，然后编译，并使用： 12$ g++ -o float2Bitset float2Bitset.cpp$ ./float2Bitset 23 0.14 2 小数位精确到 23 位的话，3.14 的定点浮点数表示是：11.00100011110101110000101。 转成浮点数，首先规格化 M，那么整体要右移 1 位，指数是 1，由 $E = e-Bias$，$E=1$, $Bias=127$ 得 $e=128$，也就是：1000 0000。 最终 3.14 的内存表示是： $$\underbrace{0}_{Sign}~\underbrace{10000000}_{Exponent}~~\underbrace{10010001111010111000011}_{Significand}$$ 同样的方法得到 2.718 的内存表示： $$\underbrace{0}_{Sign}~\underbrace{10000000}_{Exponent}~~\underbrace{01011011111001110110110}_{Significand}$$ 这两个数恰好是同阶的，那么就不需要对阶操作了。将 M 相加，但这个数太长了看着眼花，我们写个加法程序： 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;// 将两个相同位数的二进制数相加char* addBitset(char num1[], char num2[], int length)&#123; char* res = new char[length+2]; res[length+1] = '\0'; int carry = 0; for(int i=length-1;i&gt;=0;i--)&#123; res[i+1] = num1[i]-'0'+num2[i]-'0'+carry+'0'; carry = 0; if(res[i+1]&gt;'1')&#123; res[i+1] -= 2; carry = 1; &#125; &#125; if(carry)&#123; res[0]='1'; &#125;else&#123; res[0]='0'; &#125; return res;&#125;int main(int argc, char* argv[])&#123; int i=0; while(argv[1][i]!='\0')&#123; i++; &#125; cout &lt;&lt; i &lt;&lt;endl; char* res = addBitset(argv[1], argv[2], i); cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; 上述代码保存成：addBitset.cpp，编译并使用该程序： 12$ g++ -o addBitset addBitset.cpp$ ./addBitset 10010001111010111000011 01011011111001110110110 相加结果等于：0 11101101110100101111001，最高位没有产生进位，这里用了一个 0 来代替，但两个前导 1 相加产生了进位，所以还需要对 M 右归一下，再对指数加 1。所以加法结果的浮点数表示是： $$\underbrace{0}_{Sign}~\underbrace{10000001}_{Exponent}~~\underbrace{01110110111010010111101}_{Significand}$$ 这个数的十进制表示的计算方法是：$$2^2 \times (1+0\times (\frac{1}{2})^1 + 1\times (\frac{1}{2})^2 + 1\times (\frac{1}{2})^3 +1\times (\frac{1}{2})^4+0\times(\frac{1}{2})^5+\cdots)$$ 我们依然采用程序来计算这一长串二进制对应的十进制小数： 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;using namespace std;double bitset2Float(char* num1, int length)&#123; double res = 0.0; int count=1; for(int i=0;i&lt;length;i++)&#123; double temp = (num1[i]-'0')/pow(2,count); // cout &lt;&lt; temp &lt;&lt; endl; res += temp; count++; &#125; return res;&#125;int main(int argc, char* argv[])&#123; int i=0; while(argv[1][i]!='\0')&#123; i++; &#125; double res = bitset2Float(argv[1],i); cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; 上述代码保存为：Bitset2float.cpp，编译并执行： 12$ g++ -o Bitset2float Bitset2float.cpp$ ./Bitset2float 01110110111010010111101 对得到结果：0.4645，$1.4645\times 2^2 = 5.858$，而 $3.14+2.718=5.858$，这就说明我们的计算无误。 算法流程图 这个流程图并不是完美的，真实的浮点数流程图和浮点数计算电路比这个复杂。另外我忘画了一个东西，这个图最后应该加上溢出处理模块，E 可能会上溢（当 E 加 1 的时候），也可能会下溢（当 E 减 1 的时候）。 最后这个流程图中没有对特殊值的判断，比如：$\infty - \infty = NaN$, $\infty + \infty = \infty$, $NaN + 任何数 = NaN$。 了解了浮点数加法的流程之后，最后我们回到最上面说的 浮点数加减法不满足交换律和结合律，从计算细节分析为什么不行。 首先 3.14 的浮点数表示我们已经计算过了，那么 1e20 的浮点数是多少呢？1e20 也就是 $10^{20}$，用辗转相除法可以得到其二进制表示。我们这里使用计算器工具 很遗憾的是 64bit 只能摆的下 $10^{19}$。我试了一下把源程序中的 1e20 换成 1e19 也是同样的结果。所以我们就使用 1e19 来分析这道题。 首先是 M 规格化，M 右移 63 位，E 加 63，舍入 M，那么 1e19 最终的双精度浮点数表示是：0 10000111110 0001010110001110010001100000100100010011110100000000 小阶向大阶看齐，3.14 的阶是 1，M 需要右移 62 位，而 M 的精度才 52，可想而知 M 就是 0 了。那么 3.14 + 1e19 的结果就是 1e19。1e20 就更加不用说了。 浮点数乘除基本性质 相乘可能产生 infinity 或者 NaN 不满足交换律，结合律，分配率（因为溢出会造成程序无法计算出正确的结果） 乘以 1 会等于原来的数 除了 infinity 和 NaN，满足单调性：$a\ge b \rightarrow a\times c \ge b \times c$ 具体细节设两个浮点数 $x$ 和 $y$ ： $$\begin{cases}x = \pm M_x 2^{E_x} \y = \pm M_y 2^{E_y}\end{cases}$$ 则浮点数乘除运算结果是： $$xy = \pm (M_x\times M_y)2^{E_x\pm E_y}$$ 计算阶码，判断是否溢出 求有效数的乘积 有效数舍入 计算符号位 浮点数还有相当多的细节，可以参考：IEEE 754]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[wsl oh my zsh 字符乱码问题]]></title>
    <url>%2F2018%2F09%2F20%2Fwsl-oh-my-zsh%E5%AD%97%E4%BD%93%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[安装 oh my zsh首先检查自己有没有 zsh： 1cat /etc/shells 如果有的话就下载oh my zsh 设置默认 shell1chsh -s /bin/zsh 有可能会遇到设置不成功的问题，那么我们可以手动修改/etc/passwd，找到自己那一条配置信息，把默认 shell 改成/bin/zsh就 OK 了。 字体问题-&gt;等一些其他字符可能显示不出来，这是字体导致的。google 一下：wsl oh my zsh font，找到：https://github.com/Microsoft/WSL/issues/1517，下载并设置字体为：DejaVuSansMono。 怎么设置字体右键标题栏，进入属性]]></content>
      <categories>
        <category>debug</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[wsl修改右键bash图标]]></title>
    <url>%2F2018%2F09%2F19%2Fwsl%E4%BF%AE%E6%94%B9%E5%8F%B3%E9%94%AEbash%E5%9B%BE%E6%A0%87%2F</url>
    <content type="text"><![CDATA[使用 windows subsystem for linux (简称：WSL) 的时候，遇到一个小问题，在文件管理器中右键，唤出 bash，发现图标不对： 点击之后可以看到调用的是哪个程序： google 一下：windows 右键图标，搜到百度经验：https://jingyan.baidu.com/article/7c6fb428321b4a80642c90fd.html，照着修改就行了。 如图： 那么改成什么呢？google 一下：wsl bash icon，搜到：https://github.com/Microsoft/WSL/issues/1269，然后又在这个页面找到了这个：https://github.com/cmderdev/cmder/issues/1063#issuecomment-401947209 把 icon 换成： 1C:\Program Files\WindowsApps\CanonicalGroupLimited.UbuntuonWindows_1804.2018.817.0_x64__79rhkp1fndgsc\ubuntu.exe 再点击右键，就能看到这个图标了。 除了修改右键显示的 icon，还可以修改右键显示的名字，以及运行的目标程序。 改为： 1C:\Program Files\WindowsApps\CanonicalGroupLimited.UbuntuonWindows_1804.2018.817.0_x64__79rhkp1fndgsc\ubuntu.exe 但发现无法把工作目录定到当前右键的目录，需要加一个run： 1C:\Program Files\WindowsApps\CanonicalGroupLimited.UbuntuonWindows_1804.2018.817.0_x64__79rhkp1fndgsc\ubuntu.exe run]]></content>
      <categories>
        <category>debug</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[编程珠玑系列笔记 -- 第二章 啊哈！算法]]></title>
    <url>%2F2018%2F06%2F28%2F%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91%E7%AC%AC%E4%BA%8C%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[本书的另一个中心思想显而易见：良好的算法是程序性能提升的关键。 下面还是通过探讨几个实例，来领会一下算法的重要性。 三个问题A. 给定一个最多包含40亿个随机排列的32位整数的顺序文件，找出一个不在文件中的32位整数(在文件中至少缺失一个这样的数 - - 为什么? )。在具有足够内存的情况下，如何解决该问题?如果有几个外部的“临时”文件可用，但是仅有几百字节的内存，又该如何解决该问题? 至少缺失一个这样的数是因为：32位无符号整数的表示范围是0 到 4,294,967,295，比40亿大：。如果有足够的内存，可以采用第一章的位图表示法，需要的内存是：4 000 000 000/8 = 500 000 000，500MB的内存。而且我们需要使用二分查找来加速查找过程，顺序遍历500MB的空间是很慢的。使用二分查找对这种量大的数据集是非常重要的手段，但 二分查找的基础是数据集有序。所以初看这里是没法直接使用二分法的，但是如果我们这样想：32位整数的每一位不是0就是1，我们按照第1位划分的话，就可以划分出两个集合（需要遍历全部数据一遍），如果某个集合小于 $2^{31}$ 个数就选中成为我们下一次划分的对象（如果两个集合都小于 $2^{31}$ 就随便选一个），直到我们得到一个空集，而这个空集中本来应该存在的那些数，就是缺失的数了。在划分集合的时候，我们实际上要把数据存到硬盘中，可以使用buffer来减少IO次数。最坏时间复杂度是一个等比数列：$$n+\frac{1}{2}n+\cdots+1 = 2n$$ 可见这里的二分法并没有起到logN的效果。需要遍历的二分法还算什么二分法呢？但庆幸的是，我们至少可以解决这一题。 B. 将一个n元一维向量左旋转i个位置。例如，当n=8且i=3时，向量abcdefgh旋转为defghabc。简单的代码使用一个n元的中间向量在n步内完成该工作。你能否仅使用数十个额外字节的存储空间，在正比于n的时间内完成向量的旋转？ 方法1：将前i个元素复制到一个临时空间，余下的n-i个元素向左移i个位置，最后将最初的i个元素从临时空间复制到x中余下的位置。时间复杂度：2i+(n-i)=n+i，也就是O(n)；空间复杂度：i，也就是O(n)。 方法2：使用类似方法1的办法，但只使用一个元素大小的临时空间，每次只移动一位，总共需要移动i次。时间复杂度：(n+1)*i，也就是O(n^2)；空间复杂度：O(1)。 方法3：杂技算法。第一步：移动x[0]到临时变量t，然后移动x[i]到x[0]，x[2i]到x[i]，依此类推（将x中的所有下标对n取模），直至返回到取x[0]中的元素，此时改为从t取值然后终止过程。第二步：如果该过程没有移动全部元素，就从x[1]开始再次进行移动（执行第一步的算法操作），直到所有的元素都已经移动为止。 这个算法的核心思想应该是这样的：将该数组序列看成是一个环状队列，每次执行第一步的算法都可以使一组元素落到它们最终的位置上，而又不影响到其它元素。 第二步执行的次数是GCD(n,i)（n和i的最大公约数）。这样一来我们就不用记录元素是否移动过这个状态了，直接就可以知道循环多少次。 该算法的时间复杂度：n+GCD(n,i)，也就是O(n)。空间复杂度：O(1)。 这个算法虽然表现不错，但是不便于理解。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;iostream&gt;using namespace std;int gcd(int a, int b)&#123; return a%b?gcd(b, a%b): b;&#125;int a[20];void acrobat()&#123; int n=20, i=6; int temp; for(int j=0;j&lt;gcd(n,i);j++)&#123; temp = a[j]; int count=0; while(1)&#123; if(i*(count+1)%n == 0)&#123; a[j+i*count%n] = temp; break; &#125;else&#123; a[j+i*count%n] = a[j+i*(count+1)%n]; count++; &#125; &#125; &#125;&#125;int main()&#123; for(int i=0;i&lt;20;i++)&#123; a[i] = i; &#125; acrobat(); cout &lt;&lt; "out" &lt;&lt; endl; for(int i=0;i&lt;20;i++)&#123; cout &lt;&lt; a[i] &lt;&lt; endl; &#125; return 0;&#125; 方法4：递归算法。旋转向量x其实就是交换向量ab的两段，得到向量ba。这里a代表x中的前i个元素。假设a比b短，将b分为$b_l$和$b_r$，使得$b_r$具有与a相同的长度。交换a和$b_r$，也就将$ab_l b_r$转换为$b_r b_l a$。序列a此时已处于其最终的位置，因此现在的问题就集中到交换b的部分。由于新的问题与原来的问题具有相同的形式，我们可以递归解决。 1234567891011121314151617181920212223//分别从i和j位置开始，交换k个元素inline void swap(int a[], int i, int j, int k)&#123; for(int p=0;p&lt;k;p++)&#123; int temp = a[i+p]; a[i+p] = a[j+p]; a[j+p] = temp; &#125;&#125;//从i位置开始，处理左leni，右lenj的旋转void first(int a[], int i, int leni, int lenj)&#123; if(leni == lenj)&#123; swap(a, i, i+leni, leni); return; &#125; if(leni&lt;lenj)&#123; swap(a, i, i+lenj, leni); first(a, i, leni, lenj-leni); &#125;else&#123; swap(a, i, i+leni, lenj); first(a, i+lenj, leni-lenj, lenj); &#125;&#125; 方法5：三次翻转: $(a^r b^r)^r = ba$。从ab开始，首先对a求逆，得到$a^r b$，然后对b求逆，得到$a^r b^r$。最后对整体求逆，得到$(a^r b^r)^r$，此时恰好就是ab。 123reverse(0, i-1) /* cbadefgh */reverse(i, n-1) /* cbahgfed */reverse(0, n-1) /* defghabc */ 123456789101112131415//从i位置开始，到j位置结束(包含j)，翻转这一段的a中的元素inline void reverse(int a[], int i, int j)&#123; for(int k=0;k&lt;(j+1-i)/2;k++)&#123; int temp = a[k+i]; a[k+i] = a[j-k]; a[j-k] = temp; &#125;&#125;//i位置是b段的开始，总长度nvoid res(int a[], int i, int n)&#123; reverse(a, 0, i-1); reverse(a, i, n-1); reverse(a, 0, n-1);&#125; C. 给定一个英语字典，找出其中的所有变位词集合。例如，“pots”、“stop”、“tops”互为变位词，因此每一个单词都可以通过改变其他单词中字母的顺序来得到。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[编程珠玑系列笔记 -- 第一章 开篇]]></title>
    <url>%2F2018%2F06%2F22%2F%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91%E7%AC%AC%E4%B8%80%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[本书的中心思想：对实例研究的深入思考不仅有趣，而且可以获得实际的益处。 规律和智慧都隐藏在实例之中，而我们通过实例来窥探它们。实例是道的载体。 开篇明确问题，一旦问题明确，这场战役就成功了 90%。 确定用户的真实需求是程序设计的根本。 简单的程序通常比具有相同功能的复杂程序更可靠、更安全、更健壮、更高效，而且易于实现和维护。因为简单的程序往往更具有概括性、更抽象、更能洞悉问题的本质。 具体问题具体分析A：怎样给一个磁盘文件排序？B：为什么非要自己写排序程序呢？为什么不用系统提供的排序程序呢？A：我需要在一个大系统中排序。由于不明的技术原因，我不能使用系统中的文件排序程序。B：需要排序的内容是什么？文件中有多少条记录？每条记录的格式是什么？A：文件最多包含 1 千万条记录，每条记录都是 7 位的整数。B：等一下，既然文件这么小，何必非要在非要在磁盘上进行排序呢？为什么不在内存里进行排序呢？A：尽管机器有许多兆字节的内存，但排序功能只是大系统中的一部分，所以估计到时候只有 1MB 的内存可用。B：你还能告诉我其他一些与记录相关的信息吗？A：每条记录都是 7 位的正整数，再无其他相关数据。每个整数最多出现一次。 实际上问了这么多，提问者都没有主动将自己的问题无保留的告诉被求助对象，反而是被求助对象耐心的一点一点询问。问题的真实背景是这样的： 在美国，电话号码由 3 位区号后再跟 7 位数字组成，拨打含免费区号 800（当时只有这一个号码）的电话是不收费的。这位程序员正在开发这类数据库处理系统的一小部分，需要排序的整数就是免费电话号码。输入文件是电话号码列表，号码重复出现算出错。期望的输出文件是以升序排列的电话号码列表。应用背景同时定义了相应的性能需求。当与系统的会话时间较长时，用户大约每小时请求一次有序文件，并且在排序未完成之前什么都做不了。因此，排序最多只允许执行几分钟，10 秒钟是比较理想的运行时间。 准确的问题描述输入： 一个最多包含 n 个正整数的文件，每个数都小于 n，其中 n=$10^7$。如果在输入文件中有任何整数重复出现就是致命错误。没有其他数据与该整数相关联。 输出： 按升序排列的输入整数的列表。 约束： 最多有（大约）1MB 的内存可用，有充足的磁盘存储空间。运行时间最多几分钟，运行时间为 10 秒钟就不需要再优化了。 程序设计传统的排序有归并排序、快速排序，一般人想到的都是使用一个 4 字节的 int 型来表示数据，但 1000 万的数据就需要 40MB 的内存，所以需要至少 40 趟排序，需要读取输入文件至少 40 次，这将会是非常大的开销。 很显然，我们真正要做的应该是压缩数据表示，如果能让所有数据一次读入内存（仅 1MB）就好了。考虑到这一题的特殊性，我们使用长度为 1000 万位的位图来表示所有数据，每个整数都只占 1bit，可以说是极限的数据表示法了。这样一来我们只需要 125 万个字节，也就是 1.25MB 内存。满足了一次读入内存的要求。 这种数据表示，利用了该问题的三个在排序问题中不常见的属性： 输入数据限制在相对较小的范围内 数据没有重复 对每条记录而言，除了单一整数外，没有任何其他关联数据 排序伪代码： 12345678910/* phase 1: initialize set to empty */for i = [0, n) bit[i]=0/* phase 2: insert present elements into the set */for each i in the input file bit[i]=1/* phase 3: write sorted output */for i = [0, n) if b[i]==1 write i on the output file 时间-空间折中与双赢： 随着现在存储器的空间越来越大，我们往往倾向于用空间换时间的算法，这种折中非常常见。但减少程序的运行空间需求也会减少其运行时间。空间需求的减少之所以会导致运行时间的减少，有两个原因：需要处理的数据变少了，意味着处理这些数据所需的时间也变少了。同时可以将这些数据保存在内存中而不是磁盘上，进一步避免了磁盘访问的时间（IO 是巨大的开销，网络传递数据是更大的开销）。当然了，只有在设计远非最优的时候，才有可能时空双赢。 折中在所有工程领域都存在。例如，汽车设计者可能会通过增加沉重的部件，用行驶里程的减少来换取更快的加速。但双赢是更好的结果。我对自己驾驶过的一辆小轿车做过一番研究，我观察到：“轿车基本结构重量的减少会使各底盘部件的重量进一步减少--甚至消除了对某些底盘部件的需求，例如转向助力系统。” 真实代码1234567891011121314151617181920212223242526272829303132#define BITSPERWORD 32#define SHIFT 5#define MASK 0x1F#define N 10000000int a[N/BITSPERWORD];void set(int i)&#123; a[i&gt;&gt;SHIFT] |= (1&lt;&lt;(i&amp;MASK));&#125;void clear(int i)&#123; a[i&gt;&gt;SHIFT] &amp;= ~(1&lt;&lt;(i&amp;MASK));&#125;void test(int i)&#123; return a[i&gt;&gt;SHIFT] &amp; (1&lt;&lt;(i&amp;MASK));&#125;int main()&#123; int i; for(i=0;i&lt;N;i++)&#123; clear(i); &#125; while(scanf("%d", &amp;i)!=EOF)&#123; set(i); &#125; for(i=0;i&lt;N;i++)&#123; if(test(i))&#123; printf("%d\n", i); &#125; &#125; return 0;&#125; 对移位操作熟悉的话就会知道，i&gt;&gt;SHIFT的意思就是i/32。a[i&gt;&gt;SHIFT]也就是定位到 i 所属的数组单元（每个数组单元 4 个字节）。而i&amp;MASK的意思是i%32，然后(1&lt;&lt;(i&amp;MASK))就定位了 i 在所属的数组单元中的具体位置。 但我们手上没有数据来测试我们的代码是否正确，测试数据可以用随机生成的办法产生，具体会在《编程珠玑第 12 章 取样问题》中讲解。 接下来我们来看看习题： 习题 如果不缺内存，如何使用一个具有库的语言来实现一种排序算法以表示和排序集合？ 使用 C 语言的标准库函数qsort: 1234567891011121314151617int intcompare(int *x, int *y)&#123; return *x - *y;&#125;int a[10000000];int main()&#123; int n=0; while(scanf("%d",&amp;a[n])!=EOF)&#123; n++; &#125; qsort(a, n, sizeof(int), intcompare); for(int i=0;i&lt;n;i++)&#123; printf("%d", a[i]); &#125; return 0;&#125; 使用 C++的标准模板库中的容器set来完成相同任务： 123456789101112int main()&#123; set&lt;int&gt; S; int i; set&lt;int&gt;::iterator j; while(cin &gt;&gt; i)&#123; S.insert(i); &#125; for(j=S.begin();j&lt;S.end();j++)&#123; cout &lt;&lt; *j &lt;&lt; endl; &#125; return 0;&#125; 如何使用位逻辑运算（例如与、或、移位）来实现位向量？ 代码上面已经给出：真实代码 运行时效率是设计目标的一个重要组成部分，所得到的程序需要足够高效。在你自己的系统上实现位图排序并度量其运行时间。该时间与系统排序的运行时间以及习题 1 中排序的运行时间相比如何？假设 n 为 10000000，且输入文件包含 10000000 个整数。 如果认真考虑了习题 3，你将会生成小于 n 且没有重复的 k 个整数的问题。最简单的方法就是使用前 k 个正整数。这个极端的数据集合将不会明显地改变位图方法的运行时间，但是可能会歪曲系统排序的运行时间。如何生成位于 0 至 n-1 之间的 k 个不同的随机顺序的随机整数？尽量使你的程序简短且高效。 那个程序员说他有 1MB 的内存空间可用，但是我们概要描述的代码需要 1.25MB 内存。他可以不费力的索取到额外的空间。如果 1MB 空间是严格的边界，你会推荐如何处理呢？你的算法的运行时间又是多少？ 使用位图表示 1 000 万个数需要 1000 万个位，或者说 125 万字节。考虑到没有以数字 0 或 1 打头的电话号码，我们可以将内存需求降低为 100 万字节。另一种做法是采用两趟算法，首先使用5 000 000/8=625 000 个字的存储空间来排序 0~4 999 999 之间的整数，然后在第二趟排序 5 000 000~9 999 999 的整数。k 趟算法可以在 kn 的时间开销和 n/k 的空间开销内完成对最多 n 个小于 n 的无重复正整数的排序。 如果那个程序员说的不是每个整数最多出现一次，而是每个整数最多出现 10 次，你又如何建议他呢？你的解决方案如何随着可用存储空间总量的变化而变化？ 如果每个整数最多出现 10 次，那么我们就可以使用 4 位的半字节来统计它出现的次数。利用习题 5 的答案，我们可以使用 10 000 000/2 个字节在 1 趟内完成对整个文件的排序，或使用 10 000 000/2k 个字节在 k 趟内完成对整个文件的排序。 使用更多的空间来换取更少的运行时间存在一个问题：初始化空间本身需要消耗大量的时间。说明如何设计一种技术，在第一次访问向量的项时将其初始化为 0。你的方案应该使用常量时间进行初始化和向量访问，使用的额外空间应正比于向量的大小。因为该方法通过进一步增加空间来减少减少初始化的时间，所以仅在空间很廉价、时间很宝贵且向量很稀疏的情况下才考虑使用。 借助于两个额外的 n 元向量 from、to 和一个整数 top，from 和 to 也都没有初始化过，top 初始化为 0。当我们访问索引为 i 的 data 元素，想要知道data[i]有没有初始化过。如果from[i]&lt;top且to[from[i]]=i，那么说明已经初始化过。to 数组就是用来记录已经访问过哪些 data 元素的，实际上 to 数组可以是一个动态数组&gt;)。 下面代码实现对 data[i]的首次访问： 1234from[i] = top;to[top] = i;data[i] = 0;top++; 在成本低廉的隔日送达时代之前，商店允许顾客通过电话订购商品，并在几天后上门自取。商店的数据库使用客户的电话号码作为其检索的主关键字（客户知道他们自己的电话号码，而且这些关键字几乎都是唯一的）。你如何组织商店的数据库，以允许高效的插入和检索操作？ 商店将纸质订单表格放在 10x10 的箱数组中，使用客户电话号码的最后两位作为散列索引。当客户打电话下订单时，将订单放到适当的箱中。当客户来取商品时，销售人员顺序搜索对应箱中的订单--这就是经典的“用顺序搜索来解决冲突的开放散列”。电话号码的最后两位数字非常接近于随机，因此是非常理想的散列函数，而最前面的两位数字则很不理想 - - 为什么?一些市政机关使用类似的方案在记事本中记录信息。 在 20 世纪 80 年代早期，洛克希德公司加利福尼亚州桑尼维尔市工厂的工程师每天都要将许多由计算机辅助设计（CAD）系统生成的图纸从工厂送到位于圣克鲁斯市的测试站。虽然仅有 40 公里远，但使用汽车快递服务每天都需要一个多小时的时间（由于交通阻塞和山路崎岖），花费 100 美元。请给出新的数据传输方案并估计每一种方案的费用。 两地的计算机原先是通过微波连接的，但是当时测试站打印图纸所需的打印机却非常昂贵。因此，该团队在主厂绘制图纸，然后拍摄下来并通过信鸽把 35 毫米的底片送到测试站，在测试站进行放大并打印成图片。鸽子来回一.次需要 45 分钟，是汽车所需时间的一半，并且每天只需要花费几美元。在项目开发的 16 个月中，信鸽传送了几百卷底片，仅丢失了两卷(当地有鹰，因此没有让信鸽传送机密数据)。由于现在打印机比较便宜，因此可以使用微波链路解决该问题。 载人航天的先驱们很快就意识到需要在外太空的极端环境下实现顺利书写。民间盛传美国国家宇航局(NASA)花费 100 万美元研发出了一种特殊的钢笔来解决这个问题。那么，前苏联又会如何解决相同的问题呢? 看过三傻大闹宝莱坞的都知道，前苏联用的是铅笔，但铅笔的碎屑由于失重漂浮在空中会是很麻烦的问题。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[《APUE-3rd》 读书笔记 -- File I/O]]></title>
    <url>%2F2018%2F05%2F28%2FAPUE-File-IO%2F</url>
    <content type="text"><![CDATA[前言这章讲的是文件 IO，其中有几个非常重要的概念： File Desriptors，文件描述符 current file offset，当前文件偏移量 File Sharing Data Structure，文件共享数据模型 file descriptor flags ，文件描述位 file status flags ，文件状态位 File Descriptors 对内核来说，所有 打开的文件 都使用 file descriptor 引用。 文件描述符是一个非负整数。当我们打开一个存在的文件或者创建一个新文件，内核返回一个文件描述符给进程。 当我们想要读或者写一个文件，我们通过文件描述符来确定这个文件，文件描述符是被 open 或者 creat 返回的，然后作为 read 或者 write 的一个参数。 文件描述符都使用尽可能小的非负整数，File descriptors range from 0 through OPEN_MAX−1. 有三个 magic number，0 代表 STDIN_FILENO，1 代表 STDOUT_FILENO，2 代表 STDERR_FILENO。虽然这已经是 POSIX.1 所定义的标准，但为了程序的可读性，还是不建议直接写数字。这三个常量定义在&lt;unistd.h&gt;中。 open and openat FunctionsA file is opened or created by calling either the open function or the openat function. 1234#include &lt;fcntl.h&gt;int open(const char *path, int oflag, ... /* mode_t mode */ );int openat(int fd, const char *path, int oflag, ... /* mode_t mode */ );// Both return: file descriptor if OK, −1 on error 最后一个参数是...，这是 ISO C 定义剩下的多个参数的方式。对这些函数来说，只有当新文件被创建时，最后一个参数才被使用，后面我们会讲。在这个原型中我们把这个参数写作一个注释。 path 这个参数是要打开或者要创建的文件的名字。这个函数有多种操作，定在在 oflag 参数里。这个参数由下列一个或者多个定义在&lt;fcntl.h&gt;头文件中的常量通过 或(一种逻辑操作) 操作构成： O_RDONLY Open for reading only O_WRONLY Open for writing only O_RDWR Open for reading and writing Most implementations define O_RDONLY as 0, O_WRONLY as 1, and O_RDWR as 2, for compatibility with older programs. 为了兼容老程序，许多实现定义 O_RDONLY as 0, O_WRONLY as 1, and O_RDWR as 2。 O_EXEC Open for execute only O_SEARCH Open for search only(applies to directories) The purpose of the O_SEARCH constant is to evaluate search permissions at the time a directory is opened. Further operations using the directory’s file descriptor will not reevaluate permission to search the directory. None of the versions of the operating systems covered in this book support O_SEARCH yet. One and only one of the previous five constants must be specified. The following constants are optional: 上面的五个常量有且只有一个必须被明确。接下来的是可选常量： O_APPEND Append to the end of file on each write. We describe this option in detail in Section 3.11. O_CLOEXEC Set the FD_CLOEXEC file descriptor flag. We discuss file descriptor flags in Section 3.14. O_CREAT Create the file if it doesn’t exist. This option requires a third argument to the open function (a fourth argument to the openat function) — the mode, which specifies the access permission bits of the new file. (When we describe a file’s access permission bits in Section 4.5, we’ll see how to specify the mode and how it can be modified by the umask value of a process.) 创建一个文件，如果不存在。这个操作需要 open 函数的第三个参数（openat 函数的第四个参数）— mode，它明确了这个新文件的访问权限位。（当我们在第 4.5 章节讨论文件的访问权限位，我们将看到如何明确 mode，以及它如何修改进程的 umask 值。） O_DIRECTORY Generate an error if path doesn’t refer to a directory. O_EXCL Generate an error if O_CREAT is also specified and the file already exists. This test for whether the file already exists and the creation of the file if it doesn’t exist is an atomic operation. We describe atomic operations in more detail in Section 3.11. 如果 O_CREAT 被使用了且文件已经存在就会生成一个错误。这个常量的作用是检测文件是否存在如果文件不存在就创建，这是一个原子操作。我们将在第 3.11 章节讨论更多原子操作的细节。 O_NOCTTY If path refers to a terminal device, do not allocate the device as the controlling terminal for this process. We talk about controlling terminals in Section 9.6. 如果这个路径指向的是终端设备，则不将这个设备分配为此进程的控制终端。 O_NONBLOCK If path refers to a FIFO, a block special file, or a character special file, this option sets the nonblocking mode for both the opening of the file and subsequent I/O. We describe this mode in Section 14.2. 如果 path 指向 FIFO（先进先出），一个块特殊文件，一个字符特殊文件，这个选项设置了非阻塞模式为本次的打开操作和后续的 I/O 操作。 In earlier releases of System V, the O_NDELAY (no delay) flag was introduced. This option is similar to the O_NONBLOCK (nonblocking) option, but an ambiguity was introduced in the return value from a read operation. The no-delay option causes a read operation to return 0 if there is no data to be read from a pipe, FIFO, or device, but this conflicts with a return value of 0, indicating an end of file. SVR4-based systems still support the no-delay option, with the old semantics, but new applications should use the nonblocking option instead. 在早期的 System V，有一个 O_NDELAY(no delay)符号。这个符号和 O_NONBLOCK(nonblocking)选项相似，但他的读操作返回值具有二义性。如果管道，先进先出，或者设备没有数据可读，no-delay 选项就会造成 read 操作返回 0，这与 end of file 造成的返回值 0 冲突了。虽然基于 SVR4 的系统还支持这个 no-delay 选项，但新的应用应该使用 nonblocking 选项。 O_SYNC Have each write wait for physical I/O to complete, including I/O necessary to update file attributes modified as a result of the write. We use this option in Section 3.14. 使每次 write 都等物理 I/O 完成，包括更新文件属性所需要的 I/O。 O_TTY_INIT When opening a terminal device that is not already open, set the nonstandard termios parameters to values that result in behavior that conforms to the Single UNIX Specification. We discuss the termios structure when we discuss terminal I/O in Chapter 18. 当打开一个新的终端设备的时候，设置非标准参数 termios。 The following two flags are also optional. They are part of the synchronized input and output option of the Single UNIX Specification (and thus POSIX.1). O_DSYNC Have each write wait for physical I/O to complete, but don’t wait for file attributes to be updated if they don’t affect the ability to read the data just written. 让所有 write 都等待物理 I/O 完成，但是不用等文件属性更新，如果不影响刚刚写完的数据的读操作的话。 O_RSYNC Have each read operation on the file descriptor wait until any pending writes for the same portion of the file are complete. 使每个使用文件描述符的的读操作等待，直到对文件的同一部分的所有写操作完成。 Solaris 10 supports all three synchronization flags. Historically, FreeBSD (and thus Mac OS X) have used the O_FSYNC flag, which has the same behavior as O_SYNC. Because the two flags are equivalent, they define the flags to have the same value. FreeBSD 8.0 doesn’t support the O_DSYNC or O_RSYNC flags. Mac OS X doesn’t support the O_RSYNC flag, but defines the O_DSYNC flag, treating it the same as the O_SYNC flag. Linux 3.2.0 supports the O_DSYNC flag, but treats the O_RSYNC flag the same as O_SYNC. The file descriptor returned by open and openat is guaranteed to be the lowest- numbered unused descriptor. This fact is used by some applications to open a new file on standard input, standard output, or standard error. For example, an application might close standard output—normally, file descriptor 1—and then open another file, knowing that it will be opened on file descriptor 1. We’ll see a better way to guarantee that a file is open on a given descriptor in Section 3.12, when we explore the dup2 function. The fd parameter distinguishes the openat function from the open function. There are three possibilities: The path parameter specifies an absolute pathname. In this case, the fd parameter is ignored and the openat function behaves like the open function. The path parameter specifies a relative pathname and the fd parameter is a file descriptor that specifies the starting location in the file system where the relative pathname is to be evaluated. The fd parameter is obtained by opening the directory where the relative pathname is to be evaluated. The path parameter specifies a relative pathname and the fd parameter has the special value AT_FDCWD. In this case, the pathname is evaluated starting in the current working directory and the openat function behaves like the open function. The openat function is one of a class of functions added to the latest version of POSIX.1 to address two problems. First, it gives threads a way to use relative pathnames to open files in directories other than the current working directory. As we’ll see in Chapter 11, all threads in the same process share the same current working directory, so this makes it difficult for multiple threads in the same process to work in different directories at the same time. Second, it provides a way to avoid time-of-check- to-time-of-use (TOCTTOU) errors. openat 函数是在最后一个版本的 POSIX.1 加入的，为了解决两个问题。首先，它给线程以相对路径而非当前路径。我们将在第 11 章看到，在同一进程中的所有线程共享同一个当前目录，所以要让同一进程中的多线程同时在不同的目录工作是非常困难的。第二，它提供了避免 time-of-check-to-time-of-use（TOCTTOU） 错误。 The basic idea behind TOCTTOU errors is that a program is vulnerable if it makes two file-based function calls where the second call depends on the results of the first call. Because the two calls are not atomic, the file can change between the two calls, thereby invalidating the results of the first call, leading to a program error. TOCTTOU errors in the file system namespace generally deal with attempts to subvert file system permissions by tricking a privileged program into either reducing permissions on a privileged file or modifying a privileged file to open up a security hole. Wei and Pu [2005] discuss TOCTTOU weaknesses in the UNIX file system interface. TOCTTOU 错误的意思是，一个调用横叉一脚影响了另一个调用，本来另一个调用应该是一个原子操作。 Filename and Pathname TruncationWhat happens if NAME_MAX is 14 and we try to create a new file in the current directory with a filename containing 15 characters? Traditionally, early releases of System V, such as SVR2, allowed this to happen, silently truncating the filename beyond the 14th character. BSD-derived systems, in contrast, returned an error status, with errno set to ENAMETOOLONG. Silently truncating the filename presents a problem that affects more than simply the creation of new files. If NAME_MAX is 14 and a file exists whose name is exactly 14 characters, any function that accepts a pathname argument, such as open or stat, has no way to determine what the original name of the file was, as the original name might have been truncated. 如果 NAME_MAX 是 14 怎么办？传统上，早期的 System V 系统，允许这发生，静默的将文件名截断成 14 字符。相反的，BSD 派生的系统，返回一个错误状态，并把 errno 设置成 ENAMETOOLONG。静默的截断文件名呈现的问题不仅仅是创建了一个新文件。如果 NAME_MAX 是 14 且文件存在，且它的名字就是 14 字符，任何接收一个路径名作为参数的函数，比如 open 或者 stat，没办法判断文件原来的名字是什么，因为原始文件名可能已经被截断。 With POSIX.1, the constant _POSIX_NO_TRUNC determines whether long filenames and long components of pathnames are truncated or an error is returned. As we saw in Chapter 2, this value can vary based on the type of the file system, and we can use fpathconf or pathconf to query a directory to see which behavior is supported. 在 POSIX.1 标准里，常量 _POSIX_NO_TRUNC 决定长文件名和路径名中长的组件是否被截断或者是否返回一个错误。正如我们在第二章中看到的，这个值在文件系统中是非常基本的，我们可以使用 fpathconf 或 pathconf查询一个目录看看它支持哪种行为。 Whether an error is returned is largely historical. For example, SVR4-based systems do not generate an error for the traditional System V file system, S5. For the BSD-style file system (known as UFS), however, SVR4-based systems do generate an error. Figure 2.20 illustrates another example: Solaris will return an error for UFS, but not for PCFS, the DOS-compatible file system, as DOS silently truncates filenames that don’t fit in an 8.3 format. BSD-derived systems and Linux always return an error. If _POSIX_NO_TRUNC is in effect, errno is set to ENAMETOOLONG, and an error status is returned if any filename component of the pathname exceeds NAME_MAX. Most modern file systems support a maximum of 255 characters for filenames. Because filenames are usually shorter than this limit, this constraint tends to not present problems for most applications. creat FunctionA new file can also be created by calling the creat function. 123#include &lt;fcntl.h&gt;int creat(const char *path, mode_t mode);// Returns: file descriptor opened for write-only if OK, −1 on error Note that this function is equivalent to 1open(path, O_WRONLY | O_CREAT | O_TRUNC, mode); Historically, in early versions of the UNIX System, the second argument to open could be only 0, 1, or 2. There was no way to open a file that didn’t already exist. Therefore, a separate system call, creat, was needed to create new files. With the O_CREAT and O_TRUNC options now provided by open, a separate creat function is no longer needed. 这个函数诞生的原因是：历史上 open 函数的第二个参数只支持 0，1，2 这三个值，也就是读，写，读写。没办法打开一个不存在的文件。而现在有了 O_CREAT and O_TRUNC options，creat 函数也就没有存在的必要了。 We’ll show how to specify mode in Section 4.5 when we describe a file’s access permissions in detail. One deficiency with creat is that the file is opened only for writing. Before the new version of open was provided, if we were creating a temporary file that we wanted to write and then read back, we had to call creat, close, and then open. A better way is to use the open function, as in 1open(path, O_RDWR | O_CREAT | O_TRUNC, mode); close FunctionAn open file is closed by calling the close function. 1234#include &lt;unistd.h&gt;// Returns: 0 if OK, −1 on errorint close(int fd); Closing a file also releases any record locks that the process may have on the file. We’ll discuss this point further in Section 14.3. 关闭一个文件同样会释放进程对该文件的所有锁。 When a process terminates, all of its open files are closed automatically by the kernel. Many programs take advantage of this fact and don’t explicitly close open files. See the program in Figure 1.4, for example. 当一个进程终止，所有它打开的文件都会被内核自动关闭。许多程序利用了这一点，不明确关闭文件。 lseek FunctionEvery open file has an associated “current file offset,” normally a non-negative integer that measures the number of bytes from the beginning of the file. (We describe some exceptions to the ‘‘non-negative’’ qualifier later in this section.) Read and write operations normally start at the current file offset and cause the offset to be incremented by the number of bytes read or written. By default, this offset is initialized to 0 when a file is opened, unless the O_APPEND option is specified. 每个打开的文件都与 &quot;current file offset&quot;关联，正常情况下它是一个非负整形数，表示从文件开始到目前位置的字节数。读和写操作都是从 current file offset 开始的，并且会让 offset 增加，随着读和写的进行。默认的，当文件被打开时，这个位移初始化时 0，除非指明了 O_APPEND 选项。 An open file’s offset can be set explicitly by calling lseek. 通过调用 lseek 函数，一个打开的文件的 offset 可以被设定。 123#include &lt;unistd.h&gt;off_t lseek(int fd, off_t offset, int whence);// Returns: new file offset if OK, −1 on error The interpretation of the offset depends on the value of the whence argument. If whence is SEEK_SET, the file’s offset is set to offset bytes from the beginning of the file. If whence is SEEK_CUR, the file’s offset is set to its current value plus the offset. The offset can be positive or negative. If whence is SEEK_END, the file’s offset is set to the size of the file plus the offset. The offset can be positive or negative. Because a successful call to lseek returns the new file offset, we can seek zero bytes from the current position to determine the current offset: 12off_t currpos;currpos = lseek(fd, 0, SEEK_CUR); This technique can also be used to determine if a file is capable of seeking. If the file descriptor refers to a pipe, FIFO, or socket, lseek sets errno to ESPIPE and returns −1. The three symbolic constants—SEEK_SET, SEEK_CUR, and SEEK_END—were introduced with System V. Prior to this, whence was specified as 0 (absolute), 1 (relative to the current offset), or 2 (relative to the end of file). Much software still exists with these numbers hard coded. The character l in the name lseek means ‘‘long integer.’’ Before the introduction of the off_t data type, the offset argument and the return value were long integers. lseek was introduced with Version 7 when long integers were added to C. (Similar functionality was provided in Version 6 by the functions seek and tell.) ExampleThe program in Figure 3.1 tests its standard input to see whether it is capable of seeking. Figure 3.1 Test whether standard input is capable of seeking 123456789#include "apue.h"int main(void)&#123; if (lseek(STDIN_FILENO, 0, SEEK_CUR) == -1) printf("cannot seek\n"); else printf("seek OK\n"); exit(0);&#125; Normally, a file’s current offset must be a non-negative integer. It is possible, however, that certain devices could allow negative offsets. But for regular files, the offset must be non-negative. Because negative offsets are possible, we should be careful to compare the return value from lseek as being equal to or not equal to −1, rather than testing whether it is less than 0. The /dev/kmem device on FreeBSD for the Intel x86 processor supports negative offsets. Because the offset (off_t) is a signed data type (Figure 2.21), we lose a factor of 2 in the maximum file size. If off_t is a 32-bit integer, the maximum file size is $2^{31}$−1 bytes. lseek only records the current file offset within the kernel — it does not cause any I/O to take place. This offset is then used by the next read or write operation. The file’s offset can be greater than the file’s current size, in which case the next write to the file will extend the file. This is referred to as creating a hole in a file and is allowed. Any bytes in a file that have not been written are read back as 0. 文件偏移量可以大于文件的目前大小，在这种情况下下一次写文件将扩展文件。也就是说在文件中创建一个空洞是被允许的。在文件中任何没被写入的部分都将被读作 0。 A hole in a file isn’t required to have storage backing it on disk. Depending on the file system implementation, when you write after seeking past the end of a file, new disk blocks might be allocated to store the data, but there is no need to allocate disk blocks for the data between the old end of file and the location where you start writing. 文件中的空洞并不需要存储到磁盘上。根据文件系统的实现，当你在 end of file 之后写，为了存储数据新的磁盘空间可能会分配，但没有必要分配磁盘块给 end of file 和你开始写的地方之间的这些数据。 ExampleThe program shown in Figure 3.2 creates a file with a hole in it. Figure 3.2 Create a file with a hole in it 1234567891011121314151617181920#include "apue.h"#include &lt;fcntl.h&gt;char buf1[] = "abcdefghij";char buf2[] = "ABCDEFGHIJ";int main(void)&#123; int fd; if ((fd = creat("file.hole", FILE_MODE)) &lt; 0) err_sys("creat error"); if (write(fd, buf1, 10) != 10) err_sys("buf1 write error"); /* offset now = 10 */ if (lseek(fd, 16384, SEEK_SET) == -1) err_sys("lseek error"); /* offset now = 16384 */ if (write(fd, buf2, 10) != 10) err_sys("buf2 write error"); /* offset now = 16394 */ exit(0);&#125; read FunctionData is read from an open file with the read function. 12#include &lt;unistd.h&gt;ssize_t read(int fd, void *buf, size_t nbytes); Returns: numbers of bytes read, 0 if end of file, -1 on error If the read is successful, the number of bytes read is returned. If the end of file is encountered, 0 is returned. There are several cases in which the number of bytes actually read is less than the amount requested: 有以下几种情况，read 读取的字节会比指定的字节数少 When reading from a regular file, if the end of file is reached before the requested number of bytes has been read. For example, if 30 bytes remain until the end of file and we try to read 100 bytes, read returns 30. The next time we call read, it will return 0 (end of file). When reading from a terminal device. Normally, up to one line is read at a time. (We’ll see how to change this default in Chapter 18.) When reading from a network. Buffering within the network may cause less than the requested amount to be returned. When reading from a pipe or FIFO. If the pipe contains fewer bytes than requested, read will return only what is available. When reading from a record-oriented device. Some record-oriented devices, such as magnetic tape, can return up to a single record at a time. When interrupted by a signal and a partial amount of data has already been read. We discuss this further in Section 10.5. The read operation starts at the file’s current offset. Before a successful return, the offset is incremented by the number of bytes actually read. read 操作是从文件的当前偏移量开始的。在成功返回前，偏移量会随读取的字节增加。 POSIX.1 changed the prototype for this function in several ways. The classic definition is 1int read(int fd, char *buf, unsigned nbytes); First, the second argument was changed from char _ to void _ to be consistentwith ISO C: the type void * is used for generic pointers. Next, the return value was required to be a signed integer (ssize_t) to return a positive byte count, 0 (for end of file), or −1 (for an error). Finally, the third argument historically has been an unsigned integer, to allow a 16-bit implementation to read or write up to 65,534 bytes at a time. With the 1990 POSIX.1 standard, the primitive system data type ssize_t was introduced to provide the signed return value, and the unsigned size_t was used for the third argument. (Recall the SSIZE_MAX constant from Section 2.5.2.) write FunctionData is written to an open file with the write function. 12#include &lt;unistd.h&gt;ssize_t write(int fd, const void *buf, size_t nbytes); The return value is usually equal to the nbytes argument; otherwise, an error has occurred. A common cause for a write error is either filling up a disk or exceeding the file size limit for a given process (Section 7.11 and Exercise 10.11). 返回值一般会等于nbytes这个参数的大小，否则就是出错了。一般导致写错误的原因是磁盘满了或者超出给定进程的文件大小限制。 For a regular file, the write operation starts at the file’s current offset. If the O_APPEND option was specified when the file was opened, the file’s offset is set to the current end of file before each write operation. After a successful write, the file’s offset is incremented by the number of bytes actually written. I/O EfficiencyThe program in Figure 3.5 copies a file, using only the read and write functions. Figure 3.5 Copy standard input to standard output 12345678910111213#include &quot;apue.h&quot;#define BUFFSIZE 4096int main(void)&#123; int n; char buf[BUFFSIZE]; while ((n = read(STDIN_FILENO, buf, BUFFSIZE)) &gt; 0) if (write(STDOUT_FILENO, buf, n) != n) err_sys(&quot;write error&quot;); if (n &lt; 0) err_sys(&quot;read error&quot;); exit(0);&#125; The following caveats apply to this program. It reads from standard input and writes to standard output, assuming that these have been set up by the shell before this program is executed. Indeed, all normal UNIX system shells provide a way to open a file for reading on standard input and to create (or rewrite) a file on standard output. This prevents the program from having to open the input and output files, and allows the user to take advantage of the shell’s I/O redirection facilities. The program doesn’t close the input file or output file. Instead, the program uses the feature of the UNIX kernel that closes all open file descriptors in a process when that process terminates. This example works for both text files and binary files, since there is no difference between the two to the UNIX kernel. One question we haven’t answered, however, is how we chose the BUFFSIZE value. Before answering that, let’s run the program using different values for BUFFSIZE. Figure 3.6 shows the results for reading a 516,581,760-byte file, using 20 different buffer sizes. The file was read using the program shown in Figure 3.5, with standard output redirected to /dev/null. The file system used for this test was the Linux ext4 file system with 4,096-byte blocks. (The st_blksize value, which we describe in Section 4.12, is 4,096.) This accounts for the minimum in the system time occurring at the few timing measurements starting around a BUFFSIZE of 4,096. Increasing the buffer size beyond this limit has little positive effect. Most file systems support some kind of read-ahead to improve performance. When sequential reads are detected, the system tries to read in more data than an application requests, assuming that the application will read it shortly. The effect of read-ahead can be seen in Figure 3.6, where the elapsed time for buffer sizes as small as 32 bytes is as good as the elapsed time for larger buffer sizes. We’ll return to this timing example later in the text. In Section 3.14, we show the effect of synchronous writes; in Section 5.8, we compare these unbuffered I/O times with the standard I/O library. Beware when trying to measure the performance of programs that read and write files. The operating system will try to cache the file incore, so if you measure the performance of the program repeatedly, the successive timings will likely be better than the first. This improvement occurs because the first run causes the file to be entered into the system’s cache, and successive runs access the file from the system’s cache instead of from the disk. (The term incore means in main memory. Back in the day, a computer’s main memory was built out of ferrite core. This is where the phrase ‘‘core dump’’ comes from: the main memory image of a program stored in a file on disk for diagnosis.) In the tests reported in Figure 3.6, each run with a different buffer size was made using a different copy of the file so that the current run didn’t find the data in the cache from the previous run. The files are large enough that they all don’t remain in the cache (the test system was configured with 6 GB of RAM). File SharingThe UNIX System supports the sharing of open files among different processes. Before describing the dup function, we need to describe this sharing. To do this, we’ll examine the data structures used by the kernel for all I/O. The following description is conceptual; it may or may not match a particular implementation. Refer to Bach [1986] for a discussion of these structures in System V. McKusick et al. [1996] describe these structures in 4.4BSD. McKusick and Neville-Neil [2005] cover FreeBSD 5.2. For a similar discussion of Solaris, see McDougall and Mauro [2007]. The Linux 2.6 kernel architecture is discussed in Bovet and Cesati [2006]. The kernel uses three data structures to represent an open file, and the relationships among them determine the effect one process has on another with regard to file sharing. Every process has an entry in the process table. Within each process table entry is a table of open file descriptors, which we can think of as a vector, with one entry per descriptor. Associated with each file descriptor are The file descriptor flags (close-on-exec; refer to Figure 3.7 and Section 3.14) A pointer to a file table entry The kernel maintains a file table for all open files. Each file table entry contains The file status flags for the file, such as read, write, append, sync, and nonblocking; more on these in Section 3.14 The current file offset A pointer to the v-node table entry for the file Each open file (or device) has a v-node structure that contains information about the type of file and pointers to functions that operate on the file. For most files, the v-node also contains the i-node for the file. This information is read from disk when the file is opened, so that all the pertinent information about the file is readily available. For example, the i-node contains the owner of the file, the size of the file, pointers to where the actual data blocks for the file are located on disk, and so on. (We talk more about i-nodes in Section 4.14 when we describe the typical UNIX file system in more detail.) Linux has no v-node. Instead, a generic i-node structure is used. Although the implementations differ, the v-node is conceptually the same as a generic i-node. Both point to an i-node structure specific to the file system. We’re ignoring some implementation details that don’t affect our discussion. For example, the table of open file descriptors can be stored in the user area (a separate per- process structure that can be paged out) instead of the process table. Also, these tables can be implemented in numerous ways—they need not be arrays; one alternate implementation is a linked lists of structures. Regardless of the implementation details, the general concepts remain the same. Figure 3.7 shows a pictorial arrangement of these three tables for a single process that has two different files open: one file is open on standard input (file descriptor 0), and the other is open on standard output (file descriptor 1). The arrangement of these three tables has existed since the early versions of the UNIX System [Thompson 1978]. This arrangement is critical to the way files are shared among processes. We’ll return to this figure in later chapters, when we describe additional ways that files are shared. The v-node was invented to provide support for multiple file system types on a single computer system. This work was done independently by Peter Weinberger (Bell Laboratories) and Bill Joy (Sun Microsystems). Sun called this the Virtual File System and called the file system–independent portion of the i-node the v-node [Kleiman 1986]. The v-node propagated through various vendor implementations as support for Sun’s Network File System (NFS) was added. The first release from Berkeley to provide v-nodes was the 4.3BSD Reno release, when NFS was added. In SVR4, the v-node replaced the file system–independent i-node of SVR3. Solaris is derived from SVR4 and, therefore, uses v-nodes. Instead of splitting the data structures into a v-node and an i-node, Linux uses a file system–independent i-node and a file system–dependent i-node. If two independent processes have the same file open, we could have the arrangement shown in Figure 3.8. We assume here that the first process has the file open on descriptor 3 and that the second process has that same file open on descriptor 4. Each process that opens the file gets its own file table entry, but only a single v-node table entry is required for a given file. One reason each process gets its own file table entry is so that each process has its own current offset for the file. Given these data structures, we now need to be more specific about what happens with certain operations that we’ve already described. After each write is complete, the current file offset in the file table entry is incremented by the number of bytes written. If this causes the current file offset to exceed the current file size, the current file size in the i-node table entry is set to the current file offset (for example, the file is extended). If a file is opened with the O_APPEND flag, a corresponding flag is set in the file status flags of the file table entry. Each time a write is performed for a file with this append flag set, the current file offset in the file table entry is first set to the current file size from the i-node table entry. This forces every write to be appended to the current end of file. 如果一个文件打开时使用O_APPEND标志，相应的标志会设置到文件表项的文件状态符。每次进行写操作时，文件表项就会首先将当前文件偏移量设置为 i 结点表项的当前文件大小。这样就可以强制每次都写到文件末尾了。 If a file is positioned to its current end of file using lseek, all that happens is the current file offset in the file table entry is set to the current file size from the i-node table entry. (Note that this is not the same as if the file was opened with the O_APPEND flag, as we will see in Section 3.11.) The lseek function modifies only the current file offset in the file table entry. No I/O takes place. It is possible for more than one file descriptor entry to point to the same file table entry, as we’ll see when we discuss the dup function in Section 3.12. This also happens after a fork when the parent and the child share the same file table entry for each open descriptor (Section 8.3). Note the difference in scope between the file descriptor flags and the file status flags. The former apply only to a single descriptor in a single process, whereas the latter apply to all descriptors in any process that point to the given file table entry. When we describe the fcntl function in Section 3.14, we’ll see how to fetch and modify both the file descriptor flags and the file status flags. Everything that we’ve described so far in this section works fine for multiple processes that are reading the same file. Each process has its own file table entry with its own current file offset. Unexpected results can arise, however, when multiple processes write to the same file. To see how to avoid some surprises, we need to understand the concept of atomic operations. Atomic OperationsAppending to a FileConsider a single process that wants to append to the end of a file. Older versions of the UNIX System didn’t support the O_APPEND option to open, so the program was coded as follows: 1234if (lseek(fd, 0L, 2) &lt; 0) /* position to EOF */ err_sys("lseek error");if (write(fd, buf, 100) != 100) /* and write */ err_sys("write error"); This works fine for a single process, but problems arise if multiple processes use this technique to append to the same file. (This scenario can arise if multiple instances of the same program are appending messages to a log file, for example.) Assume that two independent processes, A and B, are appending to the same file. Each has opened the file but without the O_APPEND flag. This gives us the same picture as Figure 3.8. Each process has its own file table entry, but they share a single v-node table entry. Assume that process A does the lseek and that this sets the current offset for the file for process A to byte offset 1,500 (the current end of file). Then the kernel switches processes, and B continues running. Process B then does the lseek, which sets the current offset for the file for process B to byte offset 1,500 also (the current end of file). Then B calls write, which increments B’s current file offset for the file to 1,600. Because the file’s size has been extended, the kernel also updates the current file size in the v-node to 1,600. Then the kernel switches processes and A resumes. When A calls write, the data is written starting at the current file offset for A, which is byte offset 1,500. This overwrites the data that B wrote to the file. The problem here is that our logical operation of ‘‘position to the end of file and write’’ requires two separate function calls (as we’ve shown it). The solution is to have the positioning to the current end of file and the write be an atomic operation with regard to other processes. Any operation that requires more than one function call cannot be atomic, as there is always the possibility that the kernel might temporarily suspend the process between the two function calls (as we assumed previously). The UNIX System provides an atomic way to do this operation if we set the O_APPEND flag when a file is opened. As we described in the previous section, this causes the kernel to position the file to its current end of file before each write. We no longer have to call lseek before each write. pread and pwrite FunctionsThe Single UNIX Specification includes two functions that allow applications to seek and perform I/O atomically: pread and pwrite. 1234567#include &lt;unistd.h&gt;// Returns: number of bytes read, 0 if end of file, −1 on errorssize_t pread(int fd, void *buf, size_t nbytes, off_t offset);// Returns: number of bytes written if OK, −1 on errorssize_t pwrite(int fd, const void *buf, size_t nbytes, off_t offset); Calling pread is equivalent to calling lseek followed by a call to read, with the following exceptions. There is no way to interrupt the two operations that occur when we call pread. The current file offset is not updated. Calling pwrite is equivalent to calling lseek followed by a call to write, with similar exceptions. Creating a FileWe saw another example of an atomic operation when we described the O_CREAT and O_EXCL options for the open function. When both of these options are specified, the open will fail if the file already exists. We also said that the check for the existence of the file and the creation of the file was performed as an atomic operation. If we didn’t have this atomic operation, we might try 1234567if ((fd = open(path, O_WRONLY)) &lt; 0) &#123; if (errno == ENOENT) &#123; if ((fd = creat(path, mode)) &lt; 0) err_sys("creat error"); &#125; else &#123; err_sys("open error");&#125; &#125; The problem occurs if the file is created by another process between the open and the creat. If the file is created by another process between these two function calls, and if that other process writes something to the file, that data is erased when this creat is executed. Combining the test for existence and the creation into a single atomic operation avoids this problem. In general, the term atomic operation refers to an operation that might be composed of multiple steps. If the operation is performed atomically, either all the steps are performed (on success) or none are performed (on failure). It must not be possible for only a subset of the steps to be performed. We’ll return to the topic of atomic operations when we describe the link function (Section 4.15) and record locking (Section 14.3). dup and dup2 FunctionsAn existing file descriptor is duplicated by either of the following functions: 12345#include &lt;unistd.h&gt;// Both return: new file descriptor if OK, −1 on errorint dup(int fd);int dup2(int fd, int fd2); The new file descriptor returned by dup is guaranteed to be the lowest-numbered available file descriptor. With dup2, we specify the value of the new descriptor with the fd2 argument. If fd2 is already open, it is first closed. If fd equals fd2, then dup2 returns fd2 without closing it. Otherwise, the FD_CLOEXEC file descriptor flag is cleared for fd2, so that fd2 is left open if the process calls exec. The new file descriptor that is returned as the value of the functions shares the same file table entry as the fd argument. We show this in Figure 3.9. In this figure, we assume that when it’s started, the process executes 1newfd = dup(1); We assume that the next available descriptor is 3 (which it probably is, since 0, 1, and 2 are opened by the shell). Because both descriptors point to the same file table entry, they share the same file status flags—read, write, append, and so on—and the same current file offset. Each descriptor has its own set of file descriptor flags. As we describe in Section 3.14, the close-on-exec file descriptor flag for the new descriptor is always cleared by the dup functions. Another way to duplicate a descriptor is with the fcntl function, which we describe in Section 3.14. Indeed, the call 1dup(fd); is equivalent to 1fcntl(fd, F_DUPFD, 0); Similarly, the call 1dup2(fd, fd2); is equivalent to 12close(fd2);fcntl(fd, F_DUPFD, fd2); In this last case, the dup2 is not exactly the same as a close followed by an fcntl. The differences are as follows: dup2 is an atomic operation, whereas the alternate form involves two function calls. It is possible in the latter case to have a signal catcher called between the close and the fcntl that could modify the file descriptors. (We describe signals in Chapter 10.) The same problem could occur if a different thread changes the file descriptors. (We describe threads in Chapter 11.) There are some errno differences between dup2 and fcntl. The dup2 system call originated with Version 7 and propagated through the BSD releases. The fcntl method for duplicating file descriptors appeared with System III and continued with SystemV. SVR3.2 picked up the dup2 function, and 4.2BSD picked up the fcntl function and the F_DUPFD functionality. POSIX.1 requires both dup2 and the F_DUPFD feature of fcntl. sync, fsync, and fdatasync FunctionsTraditional implementations of the UNIX System have a buffer cache or page cache in the kernel through which most disk I/O passes. When we write data to a file, the data is normally copied by the kernel into one of its buffers and queued for writing to disk at some later time. This is called delayed write. (Chapter 3 of Bach [1986] discusses this buffer cache in detail.) The kernel eventually writes all the delayed-write blocks to disk, normally when it needs to reuse the buffer for some other disk block. To ensure consistency of the file system on disk with the contents of the buffer cache, the sync, fsync, and fdatasync functions are provided. 1234567#include &lt;unistd.h&gt;// Both Returns: 0 if OK, −1 on errorint fsync(int fd);int fdatasync(int fd);void sync(void); The sync function simply queues all the modified block buffers for writing and returns; it does not wait for the disk writes to take place. The function sync is normally called periodically (usually every 30 seconds) from a system daemon, often called update. This guarantees regular flushing of the kernel’s block buffers. The command sync(1) also calls the sync function. The function fsync refers only to a single file, specified by the file descriptor fd, and waits for the disk writes to complete before returning. This function is used when an application, such as a database, needs to be sure that the modified blocks have been written to the disk. The fdatasync function is similar to fsync, but it affects only the data portions of a file. With fsync, the file’s attributes are also updated synchronously. All four of the platforms described in this book support sync and fsync. However, FreeBSD 8.0 does not support fdatasync. fcntl FunctionThe fcntl function can change the properties of a file that is already open. 1234#include &lt;fcntl.h&gt;// Returns: depends on cmd if OK (see following), −1 on errorint fcntl(int fd, int cmd, ... /* int arg */ ); In the examples in this section, the third argument is always an integer, corresponding to the comment in the function prototype just shown. When we describe record locking in Section 14.3, however, the third argument becomes a pointer to a structure. The fcntl function is used for five different purposes. Duplicate an existing descriptor (cmd = F_DUPFD or F_DUPFD_CLOEXEC) Get/set file descriptor flags (cmd = F_GETFD or F_SETFD) Get/set file status flags (cmd = F_GETFL or F_SETFL) Get/set asynchronous I/O ownership (cmd = F_GETOWN or F_SETOWN) Get/set record locks (cmd = F_GETLK, F_SETLK, or F_SETLKW) We’ll now describe the first 8 of these 11 cmd values. (We’ll wait until Section 14.3 to describe the last 3, which deal with record locking.) Refer to Figure 3.7, as we’ll discuss both the file descriptor flags associated with each file descriptor in the process table entry and the file status flags associated with each file table entry. F_DUPFD Duplicate the file descriptor fd. The new file descriptor is returned as the value of the function. It is the lowest-numbered descriptor that is not already open, and that is greater than or equal to the third argument (taken as an integer). The new descriptor shares the same file table entry as fd. (Refer to Figure 3.9.) But the new descriptor has its own set of file descriptor flags, and its FD_CLOEXEC file descriptor flag is cleared. (This means that the descriptor is left open across an exec, which we discuss in Chapter 8.) F_DUPFD_CLOEXEC Duplicate the file descriptor and set the FD_CLOEXEC file descriptor flag associated with the new descriptor. Returns the new file descriptor. F_GETFD Return the file descriptor flags for fd as the value of the function. Currently, only one file descriptor flag is defined: the FD_CLOEXEC flag. F_SETFD Set the file descriptor flags for fd. The new flag value is set from the third argument (taken as an integer). Be aware that some existing programs that deal with the file descriptor flags don’t use the constant FD_CLOEXEC. Instead, these programs set the flag to either 0 (don’t close-on-exec, the default) or 1 (do close-on-exec). F_GETFL Return the file status flags for fd as the value of the function. We described the file status flags when we described the open function. They are listed in Figure 3.10. Unfortunately, the five access-mode flags—O_RDONLY, O_WRONLY, O_RDWR, O_EXEC, and O_SEARCH—are not separate bits that can be tested. (As we mentioned earlier, the first three often have the values 0, 1, and 2, respectively, for historical reasons. Also, these five values are mutually exclusive; a file can have only one of them enabled.) Therefore, we must first use the O_ACCMODE mask to obtain the access-mode bits and then compare the result against any of the five values. F_SETFL Set the file status flags to the value of the third argument (taken as an integer). The only flags that can be changed are O_APPEND, O_NONBLOCK, O_SYNC, O_DSYNC, O_RSYNC, O_FSYNC, and O_ASYNC. F_GETOWN Get the process ID or process group ID currently receiving the SIGIO and SIGURG signals. We describe these asynchronous I/O signals in Section 14.5.2. F_SETOWN Set the process ID or process group ID to receive the SIGIO and SIGURG signals. A positive arg specifies a process ID. A negative arg implies a process group ID equal to the absolute value of arg. The return value from fcntl depends on the command. All commands return −1 on an error or some other value if OK. The following four commands have special return values: F_DUPFD, F_GETFD, F_GETFL, and F_GETOWN. The first command returns the new file descriptor, the next two return the corresponding flags, and the final command returns a positive process ID or a negative process group ID. ExampleThe program in Figure 3.11 takes a single command-line argument that specifies a file descriptor and prints a description of selected file flags for that descriptor. Figure 3.11 Print file flags for specified descriptor 1234567891011121314151617181920212223242526272829303132333435#include "include/apue.h"#include &lt;fcntl.h&gt;int main(int argc, char *argv[])&#123; int val; if (argc != 2) err_quit("usage: a.out &lt;descriptor#&gt;"); if ((val = fcntl(atoi(argv[1]), F_GETFL, 0)) &lt; 0) err_sys("fcntl error for fd %d", atoi(argv[1])); switch (val &amp; O_ACCMODE) &#123; case O_RDONLY: printf("read only"); break; case O_WRONLY: printf("write only"); break; case O_RDWR: printf("read write"); break; default: err_dump("unknown access mode"); &#125; if (val &amp; O_APPEND) printf(", append"); if (val &amp; O_NONBLOCK) printf(", nonblocking"); if (val &amp; O_SYNC) printf(", synchronous writes"); #if !defined(_POSIX_C_SOURCE) &amp;&amp; defined(O_FSYNC) &amp;&amp; (O_FSYNC != O_SYNC) if (val &amp; O_FSYNC) printf(", synchronous writes"); #endif putchar('\n'); exit(0);&#125; Note that we use the feature test macro _POSIX_C_SOURCE and conditionally compile the file access flags that are not part of POSIX.1. The following script shows the operation of the program, when invoked from bash (the Bourne-again shell). Results will vary, depending on which shell you use. 123456789➜ apue.3e ./fig3.11 0 &lt; /dev/ttyread only➜ apue.3e ./fig3.11 1 &gt; temp.foo➜ apue.3e cat temp.foowrite only➜ apue.3e ./fig3.11 2 2&gt;&gt;temp.foowrite only, append➜ apue.3e ./fig3.11 5 5&lt;&gt;temp.fooread write The clause 5&lt;&gt;temp.foo opens the file temp.foo for reading and writing on file descriptor 5. ExampleWhen we modify either the file descriptor flags or the file status flags, we must be careful to fetch the existing flag value, modify it as desired, and then set the new flag value. We can’t simply issue an F_SETFD or an F_SETFL command, as this could turn off flag bits that were previously set. Figure 3.12 shows a function that sets one or more of the file status flags for a descriptor. Figure 3.12 Turn on one or more of the file status flags for a descriptor 1234567891011#include "apue.h"#include &lt;fcntl.h&gt;void set_fl(int fd, int flags) /* flags are file status flags to turn on */&#123; int val; if ((val = fcntl(fd, F_GETFL, 0)) &lt; 0) err_sys("fcntl F_GETFL error"); val |= flags; /* turn on flags */ if (fcntl(fd, F_SETFL, val) &lt; 0) err_sys("fcntl F_SETFL error");&#125; If we change the middle statement to 1val &amp;= ̃flags; /* turn flags off */ we have a function named clr_fl, which we’ll use in some later examples. This statement logically ANDs the one’s complement of flags with the current val. If we add the line 1set_fl(STDOUT_FILENO, O_SYNC); to the beginning of the program shown in Figure 3.5, we’ll turn on the synchronous- write flag. This causes each write to wait for the data to be written to disk before returning. Normally in the UNIX System, a write only queues the data for writing; the actual disk write operation can take place sometime later. A database system is a likely candidate for using O_SYNC, so that it knows on return from a write that the data is actually on the disk, in case of an abnormal system failure. We expect the O_SYNC flag to increase the system and clock times when the program runs. To test this, we can run the program in Figure 3.5, copying 492.6 MB of data from one file on disk to another and compare this with a version that does the same thing with the O_SYNC flag set. The results from a Linux system using the ext4 file system are shown in Figure 3.13. The six rows in Figure 3.13 were all measured with a BUFFSIZE of 4,096 bytes. The results in Figure 3.6 were measured while reading a disk file and writing to /dev/null, so there was no disk output. The second row in Figure 3.13 corresponds to reading a disk file and writing to another disk file. This is why the first and second rows in Figure 3.13 are different. The system time increases when we write to a disk file, because the kernel now copies the data from our process and queues the data for writing by the disk driver. We expect the clock time to increase as well when we write to a disk file. When we enable synchronous writes, the system and clock times should increase significantly. As the third row shows, the system time for writing synchronously is not much more expensive than when we used delayed writes. This implies that the Linux operating system is doing the same amount of work for delayed and synchronous writes (which is unlikely), or else the O_SYNC flag isn’t having the desired effect. In this case, the Linux operating system isn’t allowing us to set the O_SYNC flag using fcntl, instead failing without returning an error (but it would have honored the flag if we were able to specify it when the file was opened). The clock time in the last three rows reflects the extra time needed to wait for all of the writes to be committed to disk. After writing a file synchronously, we expect that a call to fsync will have no effect. This case is supposed to be represented by the last row in Figure 3.13, but since the O_SYNC flag isn’t having the intended effect, the last row behaves the same way as the fifth row. Figure 3.14 shows timing results for the same tests run on Mac OS X 10.6.8, which uses the HFS file system. Note that the times match our expectations: synchronous writes are far more expensive than delayed writes, and using fsync with synchronous writes makes very little difference. Note also that adding a call to fsync at the end of the delayed writes makes little measurable difference. It is likely that the operating system flushed previously written data to disk as we were writing new data to the file, so by the time that we called fsync, very little work was left to be done. Compare fsync and fdatasync, both of which update a file’s contents when we say so, with the O_SYNC flag, which updates a file’s contents every time we write to the file. The performance of each alternative will depend on many factors, including the underlying operating system implementation, the speed of the disk drive, and the type of the file system. With this example, we see the need for fcntl. Our program operates on a descriptor (standard output), never knowing the name of the file that was opened on that descriptor. We can’t set the O_SYNC flag when the file is opened, since the shell opened the file. With fcntl, we can modify the properties of a descriptor, knowing only the descriptor for the open file. We’ll see another need for fcntl when we describe nonblocking pipes (Section 15.2), since all we have with a pipe is a descriptor. ioctl FunctionThe ioctl function has always been the catchall for I/O operations. Anything that couldn’t be expressed using one of the other functions in this chapter usually ended up being specified with an ioctl. Terminal I/O was the biggest user of this function. (When we get to Chapter 18, we’ll see that POSIX.1 has replaced the terminal I/O operations with separate functions.) 12345#include &lt;unistd.h&gt; /* System V */#include &lt;sys/ioctl.h&gt; /* BSD and Linux */// Returns: −1 on error, something else if OKint ioctl(int fd, int request, ...); The ioctl function was included in the Single UNIX Specification only as an extension for dealing with STREAMS devices [Rago 1993], but it was moved to obsolescent status in SUSv4. UNIX System implementations use ioctl for many miscellaneous device operations. Some implementations have even extended it for use with regular files. The prototype that we show corresponds to POSIX.1. FreeBSD 8.0 and Mac OS X 10.6.8 declare the second argument as an unsigned long. This detail doesn’t matter, since the second argument is always a #defined name from a header. For the ISO C prototype, an ellipsis is used for the remaining arguments. Normally, however, there is only one more argument, and it’s usually a pointer to a variable or a structure. In this prototype, we show only the headers required for the function itself. Normally, additional device-specific headers are required. For example, the ioctl commands for terminal I/O, beyond the basic operations specified by POSIX.1, all require the &lt;termios.h&gt; header. Each device driver can define its own set of ioctl commands. The system, however, provides generic ioctl commands for different classes of devices. Examples of some of the categories for these generic ioctl commands supported in FreeBSD are summarized in Figure 3.15. The mag tape operations allow us to write end-of-file marks on a tape, rewind a tape, space forward over a specified number of files or records, and the like. None of these operations is easily expressed in terms of the other functions in the chapter (read, write, lseek, and so on), so the easiest way to handle these devices has always been to access their operations using ioctl. We use the ioctl function in Section 18.12 to fetch and set the size of a terminal’s window, and in Section 19.7 when we access the advanced features of pseudo terminals. /dev/fdNewer systems provide a directory named /dev/fd whose entries are files named 0, 1, 2, and so on. Opening the file /dev/fd/n is equivalent to duplicating descriptor n, assuming that descriptor n is open. The /dev/fd feature was developed by Tom Duff and appeared in the 8th Edition of the Research UNIX System. It is supported by all of the systems described in this book: FreeBSD 8.0, Linux 3.2.0, Mac OS X 10.6.8, and Solaris 10. It is not part of POSIX.1. In the function call 1fd = open("/dev/fd/0", mode); most systems ignore the specified mode, whereas others require that it be a subset of the mode used when the referenced file (standard input, in this case) was originally opened. Because the previous open is equivalent to 1fd = dup(0); the descriptors 0 and fd share the same file table entry (Figure 3.9). For example, if descriptor 0 was opened read-only, we can only read on fd. Even if the system ignores the open mode and the call 1fd = open("/dev/fd/0", O_RDWR); succeeds, we still can’t write to fd. The Linux implementation of /dev/fd is an exception. It maps file descriptors into symbolic links pointing to the underlying physical files. When you open /dev/fd/0, for example, you are really opening the file associated with your standard input. Thus the mode of the new file descriptor returned is unrelated to the mode of the /dev/fd file descriptor. We can also call creat with a /dev/fd pathname argument as well as specify O_CREAT in a call to open. This allows a program that calls creat to still work if the pathname argument is /dev/fd/1, for example. Beware of doing this on Linux. Because the Linux implementation uses symbolic links to the real files, using creat on a /dev/fd file will result in the underlying file being truncated. Some systems provide the pathnames /dev/stdin, /dev/stdout, and /dev/stderr. These pathnames are equivalent to /dev/fd/0, /dev/fd/1, and /dev/fd/2, respectively. The main use of the /dev/fd files is from the shell. It allows programs that use pathname arguments to handle standard input and standard output in the same manner as other pathnames. For example, the cat(1) program specifically looks for an input filename of - and uses it to mean standard input. The command 1filter file2 | cat file1 - file3 | lpr is an example. First, cat reads file1, then its standard input (the output of the filter program on file2), and then file3. If /dev/fd is supported, the special handling of - can be removed from cat, and we can enter 1filter file2 | cat file1 /dev/fd/0 file3 | lpr The special meaning of - as a command-line argument to refer to the standard input or the standard output is a kludge that has crept into many programs. There are also problems if we specify - as the first file, as it looks like the start of another command-line option. Using /dev/fd is a step toward uniformity and cleanliness. SummaryThis chapter has described the basic I/O functions provided by the UNIX System. These are often called the unbuffered I/O functions because each read or write invokes a system call into the kernel. Using only read and write, we looked at the effect of various I/O sizes on the amount of time required to read a file. We also looked at several ways to flush written data to disk and their effect on application performance. Atomic operations were introduced when multiple processes append to the same file and when multiple processes create the same file. We also looked at the data structures used by the kernel to share information about open files. We’ll return to these data structures later in the text. We also described the ioctl and fcntl functions. We return to both of these functions later in the book. In Chapter 14, we’ll use fcntl for record locking. In Chapter 18 and Chapter 19, we’ll use ioctl when we deal with terminal devices. Exercises When reading or writing a disk file, are the functions described in this chapter really unbuffered? Explain. Write your own dup2 function that behaves the same way as the dup2 function described in Section 3.12, without calling the fcntl function. Be sure to handle errors correctly. Assume that a process executes the following three function calls: 123fd1 = open(path, oflags);fd2 = dup(fd1);fd3 = open(path, oflags); Draw the resulting picture, similar to Figure 3.9. Which descriptors are affected by an fcntl on fd1 with a command of F_SETFD? Which descriptors are affected by an fcntl on fd1 with a command of F_SETFL? The following sequence of code has been observed in various programs: 1234dup2(fd, 0);dup2(fd, 1);dup2(fd, 2);if (fd &gt; 2) close(fd); To see why the if test is needed, assume that fd is 1 and draw a picture of what happens to the three descriptor entries and the corresponding file table entry with each call to dup2. Then assume that fd is 3 and draw the same picture.]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[《APUE-3rd》 读书笔记 -- Unix System Overview]]></title>
    <url>%2F2018%2F05%2F22%2FAPUE-Unix-System-Overview%2F</url>
    <content type="text"><![CDATA[Preperation Before Classapue 编程环境搭建 Figure 1.3 List all the files in a directory 12345678910111213141516#include "apue.h"#include &lt;dirent.h&gt;int main(int argc, char *argv[])&#123; DIR *dp; struct dirent *dirp; if (argc != 2) err_quit("usage: ls directory_name"); if ((dp = opendir(argv[1])) == NULL) err_sys("can’t open %s", argv[1]); while ((dirp = readdir(dp)) != NULL) printf("%s\n", dirp-&gt;d_name); closedir(dp); exit(0);&#125; 这里简单说一下 apue 的编程环境搭建，实际上只需要用到一点点make、环境变量和gcc 命令的知识。 首先进入：http://www.apuebook.com/ 选择 2013 年出版的 apue3，然后点击 source code，然后根据提示点击 here 下载。 拿到编程环境的源码之后，解压进入目录，使用 make 命令编译得到 libapue.a，这是个静态库，生成在 lib 目录下。然后将 include 目录下的 apue.h 这个头文件和 libapue.a 这个静态库分别放置在/usr/include/和/usr/local/lib/下面（这两个路径就是写入环境变量的路径，gcc 命令会在编译的时候搜寻这两个路径）。 然后使用gcc -o main.o main.c -lapue编译得到 main.o，因为上一步我们将 apue.h 和 libapue.a 放入了环境变量路径下面，所以我们使用它们的时候都不用再指明其路径了。 然后运行 main.o：./main.o .，将当前目录下的所有文件名打印出来。 如果编译失败，使用 make clean 可以清空编译结果，然后就可以使用 make 重新编译了。不要将程序命名为.cpp 文件，这样的话即便你使用 gcc 编译 myls.cpp，也会出错，更不要使用 g++去编译 myls.cpp，因为库是用 gcc 编译的。 When the program is done, it calls the function exit with an argument of 0. The function exit terminates a program. By convention, an argument of 0 means OK, and an argument between 1 and 255 means that an error occurred. man 命令man 命令是 unix 系统中的一个非常重要的命令，它提供了所有命令的详细的使用方法。 Historically, UNIX systems lumped all eight sections together into what was called the UNIX Programmer&#39;s Manual. As the page count increased, the trend changed to distributing the sections among separate manuals: one for users, one for programmers, and one for system administrators, for example. Some UNIX systems further divide the manual pages within a given section, using an uppercase letter. For example, all the standard input/output (I/O) functions in AT&amp;T [1990e] are indicated as being in Section 3S, as in fopen(3S). Other systems have replaced the numeric sections with alphabetic ones, such as C for commands. Unix Architecture下图清晰的描述了 Unix 的架构： 图中最重要的两个概念是：内核和系统调用，下面是对这两个概念的简单介绍： kernel: In a strict sense, an operating system can be defined as the software that controls the hardware resources of the computer and provides an environment under which programs can run. system calls: The interface to the kernel is a layer of software called the system calls . ShellA shell is a command-line interpreter that reads user input and executes commands. The user input to a shell is normally from the terminal (an interactive shell) or sometimes from a file (called a shell script). The system knows which shell to execute for us based on the final field in our entry in the password file. bash: The Bourne-again shell is the GNU shell provided with all Linux systems. It was designed to be POSIX conformant, while still remaining compatible with the Bourne shell. It supports features from both the C shell and the Korn shell. Files and Directories文件系统是 Unix 系统中一个非常重要的部分，里面有许多很重要的设计。文件系统从逻辑层面上看是一个树状结构，所有文件和目录都从属于一个根目录。 root: Everything starts in the directory called root, whose name is the single character /. directory: A directory is a file that contains directory entries. Logically, we can think of each directory entry as containing a filename along with a structure of information describing the attributes of the file. The attributes of a file are such things as the type of file (regular file, directory), the size of the file, the owner of the file, permissions for the file (whether other users may access this file), and when the file was last modified. We make a distinction between the logical view of a directory entry and the way it is actually stored on disk. Most implementations of UNIX file systems don&#39;t store attributes in the directory entries themselves, because of the difficulty of keeping them in synch when a file has multiple hard links. 文件名和路径名这里面也有讲究： 文件名中不能包含斜杠和空字符: The only two characters that cannot appear in a filename are the slash character (/) and the null character. The slash separates the filenames that form a pathname (described next) and the null character terminates a pathname. dot 和 dot-dot: Two filenames are automatically created whenever a new directory is created: . (called dot) and .. (called dot-dot). Dot refers to the current directory, and dot-dot refers to the parent directory. In the root directory, dot-dot is the same as dot. 相对路径和绝对路径: A sequence of one or more filenames, separated by slashes and optionally starting with a slash, forms a pathname. A pathname that begins with a slash is called an absolute pathname; otherwise, it&#39;s called a relative pathname. Relative pathnames refer to files relative to the current directory. 我们不知道形如：/usr/local/lib/hello的路径中 hello 是目录还是普通文件，哈哈，我觉得 unix 当初在设计上应该强制目录必须以斜杠结尾。 还有两个比较特殊的目录： working directory: Every process has a working directory, sometimes called the current working directory. This is the directory from which all relative pathnames are interpreted. A process can change its working directory with the chdir function. home directory: When we log in, the working directory is set to our home directory. Our home directory is obtained from our entry in the password file. File Descriptorsfile descriptor: File descriptors are normally small non-negative integers that the kernel uses to identify the files accessed by a process. Whenever it opens an existing file or creates a new file, the kernel returns a file descriptor that we use when we want to read or write the file. Standard Input, Standard Output, and Standard Error: By convention, all shells open three descriptors whenever a new program is run: standard input, standard output, and standard error. If nothing special is done, as in the simple command 1ls then all three are connected to the terminal. Most shells provide a way to redirect any or all of these three descriptors to any file. For example, 1ls &gt; file.list executes the ls command with its standard output redirected to the file named file.list. stdin 的文件描述符是 0，stdout 的文件描述符是 1，stderr 的文件描述符是 2。all three are connected to the terminal，此 terminal 非彼 terminal，这里指的是硬件终端，stdin 的默认输入对象是 keyboard，stdout 和 stderr 的默认输出对象是 screen。 RedirectionTo redirect a file descriptor, we use N&gt;, where N is a file descriptor. If there&#39;s no file descriptor, then stdout is used, like in echo hello &gt; new-file. 将 stderr 重定向到文件： 1command1 2&gt; error.log 将 stderr 重定向到 stdout： 1command-name 2&gt;&amp;1 将 stdout 和 stderr 都重定向到文件： 1command-name &amp;&gt;file 或者这么写： 1command &gt; file-name 2&gt;&amp;1 不能调换顺序：command 2&gt;&amp;1 &gt; file-name，这样写就错了。 The wrong version points stderr at stdout (which outputs to the shell), then redirects stdout to the file. Thus only stdout is pointing at the file, because stderr is pointing to the “old” stdout. Figure 1.4 Copy standard input to standard output 12345678910111213#include "apue.h"#define BUFFSIZE 4096int main(void)&#123; int n; char buf[BUFFSIZE]; while ((n = read(STDIN_FILENO, buf, BUFFSIZE)) &gt; 0) if (write(STDOUT_FILENO, buf, n) != n) err_sys("write error"); if (n &lt; 0) err_sys("read error"); exit(0);&#125; The &lt;unistd.h&gt; header, included by apue.h, and the two constants STDIN_FILENO and STDOUT_FILENO are part of the POSIX standard (about which we’ll have a lot more to say in the next chapter). This header contains function prototypes for many of the UNIX system services, such as the read and write functions that we call. The constants STDIN_FILENO and STDOUT_FILENO are defined in &lt;unistd.h&gt; and specify the file descriptors for standard input and standard output. The read function returns the number of bytes that are read, and this value is used as the number of bytes to write. When the end of the input file is encountered, read returns 0 and the program stops. If a read error occurs, read returns −1. Most of the system functions return −1 when an error occurs. If we compile the program into the standard name (a.out) and execute it as 1./a.out &gt; data standard input is the terminal, standard output is redirected to the file data, and standard error is also the terminal. If this output file doesn’t exist, the shell creates it by default. The program copies lines that we type to the standard output until we type the end-of-file character (usually Control-D). The notation ˆD is used to indicate a control character. Control characters are special characters formed by holding down the control key—often labeled Control or Ctrl—on your keyboard and then pressing another key at the same time. Control-D, or ˆD, is the default end-of-file character. If we run 1./a.out &lt; infile &gt; outfile then the file named infile will be copied to the file named outfile. The standard I/O functions provide a buffered interface to the unbuffered I/O functions. Using standard I/O relieves us from having to choose optimal buffer sizes, such as the BUFFSIZE constant in Figure 1.4. The standard I/O functions also simplify dealing with lines of input (a common occurrence in UNIX applications). The fgets function, for example, reads an entire line. The read function, in contrast, reads a specified number of bytes. The most common standard I/O function is printf. In programs that call printf, we’ll always include &lt;stdio.h&gt; as this header contains the function prototypes for all the standard I/O functions. Figure 1.5 Copy standard input to standard output, using standard I/O 1234567891011#include "apue.h"int main(void)&#123; int c; while ((c = getc(stdin)) != EOF) if (putc(c, stdout) == EOF) err_sys("output error"); if (ferror(stdin)) err_sys("input error"); exit(0);&#125; The function getc reads one character at a time, and this character is written by putc. After the last byte of input has been read, getc returns the constant EOF (defined in &lt;stdio.h&gt;). The standard I/O constants stdin and stdout are also defined in the &lt;stdio.h&gt; header and refer to the standard input and standard output. Programs and Processesprogram: A program is an executable file residing on disk in a directory. A program is read into memory and is executed by the kernel as a result of one of the seven exec functions.process: An executing instance of a program is called a process, a term used on almost every page of this text. Some operating systems use the term task to refer to a program that is being executed. The UNIX System guarantees that every process has a unique numeric identifier called the process ID. The process ID is always a non-negative integer. Figure 1.6 Print the process ID 123456#include "apue.h"int main(void)&#123; printf("hello world from process ID %ld\n", (long)getpid()); exit(0);&#125; 输出结果： 1234➜ apue.3e ./fig1.6hello world from process ID 8080➜ apue.3e ./fig1.6hello world from process ID 8086 Process ControlThere are three primary functions for process control: fork, exec, and waitpid. (The exec function has seven variants, but we often refer to them collectively as simply the exec function.) Figure 1.7 Read commands from standard input and execute them 1234567891011121314151617181920212223242526272829#include "apue.h"#include &lt;sys/wait.h&gt;int main(void)&#123; char buf[MAXLINE]; /* from apue.h */ pid_t pid; int status; printf("%% "); /* print prompt (printf requires %% to print %) */ while (fgets(buf, MAXLINE, stdin) != NULL) &#123; if (buf[strlen(buf) - 1] == '\n') buf[strlen(buf) - 1] = 0; /* replace newline with null */ if ((pid = fork()) &lt; 0) &#123; err_sys("fork error"); &#125; else if (pid == 0) &#123; /* child */ execlp(buf, buf, (char *)0); // or // execlp(buf, buf, (char *)NULL); err_ret("couldn’t execute: %s", buf); exit(127); &#125; /* parent */ if ((pid = waitpid(pid, &amp;status, 0)) &lt; 0) err_sys("waitpid error"); printf("%% "); &#125; exit(0);&#125; There are several features to consider in this 30-line program. We use the standard I/O function fgets to read one line at a time from the standard input. When we type the end-of-file character (which is often Control-D) as the first character of a line, fgets returns a null pointer, the loop stops, and the process terminates. Because each line returned by fgets is terminated with a newline character, followed by a null byte, we use the standard C function strlen to calculate the length of the string, and then replace the newline with a null byte. We do this because the execlp function wants a null-terminated argument, not a newline-terminated argument. We call fork to create a new process, which is a copy of the caller. We say that the caller is the parent and that the newly created process is the child. Then fork returns the non-negative process ID of the new child process to the parent, and returns 0 to the child. Because fork creates a new process, we say that it is called once—by the parent—but returns twice—in the parent and in the child. In the child, we call execlp to execute the command that was read from the standard input. This replaces the child process with the new program file. The combination of fork followed by exec is called spawning a new process on some operating systems. In the UNIX System, the two parts are separated into individual functions Because the child calls execlp to execute the new program file, the parent wants to wait for the child to terminate. This is done by calling waitpid, specifying which process to wait for: the pid argument, which is the process ID of the child. The waitpid function also returns the termination status of the child—the status variable—but in this simple program, we don’t do anything with this value. We could examine it to determine how the child terminated. The most fundamental limitation of this program is that we can&#39;t pass arguments to the command we execute. We can&#39;t, for example, specify the name of a directory to list. We can execute ls only on the working directory. To allow arguments would require that we parse the input line, separating the arguments by some convention, probably spaces or tabs, and then pass each argument as a separate parameter to the execlp function. Nevertheless, this program is still a useful demonstration of the UNIX System&#39;s process control functions. If we run this program, we get the following result. Note that our program has a different prompt—the percent sign—to distinguish it from the shell&#39;s prompt. 12345678$ ./fig1.7% pwd/Users/liuqinh2s/Downloads/apue.3e% wholiuqinh2s console May 21 12:09liuqinh2s ttys000 May 21 12:10% date2018年 5月24日 星期四 15时26分59秒 CST ThreadsAll threads within a process share the same address space, file descriptors, stacks, and process-related attributes. Each thread executes on its own stack, although any thread can access the stacks of other threads in the same process. Because they can access the same memory, the threads need to synchronize access to shared data among themselves to avoid inconsistencies. Like processes, threads are identified by IDs. Thread IDs, however, are local to a process. A thread ID from one process has no meaning in another process. We use thread IDs to refer to specific threads as we manipulate the threads within a process. threads were added to the UNIX System long after the process model was established Error HandlingWhen an error occurs in one of the UNIX System functions, a negative value is often returned, and the integer errno is usually set to a value that tells why. For example, the open function returns either a non-negative file descriptor if all is OK or −1 if an error occurs. An error from open has about 15 possible errno values, such as file doesn’t exist, permission problem, and so on. Some functions use a convention other than returning a negative value. For example, most functions that return a pointer to an object return a null pointer to indicate an error. The file &lt;errno.h&gt; defines the symbol errno and constants for each value that errno can assume. Each of these constants begins with the character E. Also, the first page of Section 2 of the UNIX system manuals, named intro(2), usually lists all these error constants. For example, if errno is equal to the constant EACCES, this indicates a permission problem, such as insufficient permission to open the requested file. On Linux, the error constants are listed in the errno(3) manual page. POSIX and ISO C define errno as a symbol expanding into a modifiable lvalue of type integer. This can be either an integer that contains the error number or a function that returns a pointer to the error number. The historical definition is 1extern int errno; But in an environment that supports threads, the process address space is shared among multiple threads, and each thread needs its own local copy of errno to prevent one thread from interfering with another. Linux, for example, supports multithreaded access to errno by defining it as 12extern int *__errno_location(void);#define errno (*__errno_location()) There are two rules to be aware of with respect to errno. First, its value is never cleared by a routine if an error does not occur. Therefore, we should examine its value only when the return value from a function indicates that an error occurred. Second, the value of errno is never set to 0 by any of the functions, and none of the constants defined in &lt;errno.h&gt; has a value of 0. Two functions are defined by the C standard to help with printing error messages. 123#include &lt;string.h&gt;char *strerror(int errnum); //Returns: pointer to message string This function maps errnum, which is typically the errno value, into an error message string and returns a pointer to the string. The perror function produces an error message on the standard error, based on the current value of errno, and returns. 123#include &lt;stdio.h&gt;void perror(const char* msg); It outputs the string pointed to by msg, followed by a colon and a space, followed by the error message corresponding to the value of errno, followed by a newline. Figure 1.8 Demonstrate strerror and perror 123456789#include "apue.h"#include &lt;errno.h&gt;int main(int argc, char *argv[])&#123; fprintf(stderr, "EACCES: %s\n", strerror(EACCES)); errno = ENOENT; perror(argv[0]); exit(0);&#125; 输出结果： 123$ ./fig1.8EACCES: Permission denied./fig1.8: No such file or directory argv[0] 表示输入的第一个参数，也就是命令名 Error RecoveryThe errors defined in &lt;errno.h&gt; can be divided into two categories: fatal and nonfatal. A fatal error has no recovery action. The best we can do is print an error message on the user&#39;s screen or to a log file, and then exit. Nonfatal errors, on the other hand, can sometimes be dealt with more robustly. Most nonfatal errors are temporary, such as a resource shortage, and might not occur when there is less activity on the system. Resource-related nonfatal errors include EAGAIN, ENFILE, ENOBUFS, ENOLCK, ENOSPC, EWOULDBLOCK, and sometimes ENOMEM. EBUSY can be treated as nonfatal when it indicates that a shared resource is in use. Sometimes, EINTR can be treated as a nonfatal error when it interrupts a slow system call. The typical recovery action for a resource-related nonfatal error is to delay and retry later. This technique can be applied in other circumstances. For example, if an error indicates that a network connection is no longer functioning, it might be possible for the application to delay a short time and then reestablish the connection. Some applications use an exponential backoff algorithm, waiting a longer period of time in each subsequent iteration. User IdentificationPassword File/etc/passwd: When we log in to a UNIX system, we enter our login name, followed by our password. The system then looks up our login name in its password file, usually the file /etc/passwd. If we look at our entry in the password file, we see that it&#39;s composed of seven colon-separated fields: the login name, encrypted password, numeric user ID (205), numeric group ID (105), a comment field, home directory (/home/sar), and shell program (/bin/ksh). 密码文件的条目的格式如下： 1登录名:加密过的密码:user ID:group ID:注解:home目录:shell All contemporary systems have moved the encrypted password to a different file. 1sar:x:205:105:Stephen Rago:/home/sar:/bin/ksh 我们可以看到这个文件很关键，因为他配置了我们的很多信息，比如 home 目录，默认的 shell。 User IDThe user ID from our entry in the password file is a numeric value that identifies us to the system. This user ID is assigned by the system administrator when our login name is assigned, and we cannot change it. The user ID is normally assigned to be unique for every user. We&#39;ll see how the kernel uses the user ID to check whether we have the appropriate permissions to perform certain operations. We call the user whose user ID is 0 either root or the superuser. The entry in the password file normally has a login name of root, and we refer to the special privileges of this user as superuser privileges. As we&#39;ll see in Chapter 4, if a process has superuser privileges, most file permission checks are bypassed. Some operating system functions are restricted to the superuser. The superuser has free rein over the system. Client versions of Mac OS X ship with the superuser account disabled; server versions ship with the account already enabled. Instructions are available on Apple’s Web site describing how to enable it. See http://support.apple.com/kb/HT1528. Group IDOur entry in the password file also specifies our numeric group ID. This, too, is assigned by the system administrator when our login name is assigned. Typically, the password file contains multiple entries that specify the same group ID. Groups are normally used to collect users together into projects or departments. This allows the sharing of resources, such as files, among members of the same group. We’ll see in Section 4.5 that we can set the permissions on a file so that all members of a group can access the file, whereas others outside the group cannot. There is also a group file that maps group names into numeric group IDs. The group file is usually /etc/group. 为何使用数字型 ID，主要原因如下： The use of numeric user IDs and numeric group IDs for permissions is historical. With every file on disk, the file system stores both the user ID and the group ID of a file’s owner. Storing both of these values requires only four bytes, assuming that each is stored as a two-byte integer. If the full ASCII login name and group name were used instead, additional disk space would be required. In addition, comparing strings during permission checks is more expensive than comparing integers. Users, however, work better with names than with numbers, so the password file maintains the mapping between login names and user IDs, and the group file provides the mapping between group names and group IDs. The ls -l command, for example, prints the login name of the owner of a file, using the password file to map the numeric user ID into the corresponding login name. Early UNIX systems used 16-bit integers to represent user and group IDs. Contemporary UNIX systems use 32-bit integers. Figure 1.9 Print user ID and group ID 1234567#include "apue.h"int main(void)&#123; printf("uid = %d, gid = %d\n", getuid(), getgid()); exit(0);&#125; Supplementary Group IDssupplementary group：In addition to the group ID specified in the password file for a login name, most versions of the UNIX System allow a user to belong to other groups. This practice started with 4.2BSD, which allowed a user to belong to up to 16 additional groups. These supplementary group IDs are obtained at login time by reading the file /etc/group and finding the first 16 entries that list the user as a member. As we shall see in the next chapter, POSIX requires that a system support at least 8 supplementary groups per process, but most systems support at least 16. /etc/group格式如下： 12_analyticsusers:*:250:_analyticsd,_networkd,_timed_analyticsd:*:263:_analyticsd 解释： 1组名:口令:组ID:组内用户列表 SignalSignals are a technique used to notify a process that some condition has occurred. For example, if a process divides by zero, the signal whose name is SIGFPE (floating-point exception) is sent to the process. The process has three choices for dealing with the signal. Ignore the signal. This option isn&#39;t recommended for signals that denote a hardware exception, such as dividing by zero or referencing memory outside the address space of the process, as the results are undefined. Let the default action occur. For a divide-by-zero condition, the default is to terminate the process. Provide a function that is called when the signal occurs (this is called “catching” the signal). By providing a function of our own, we&#39;ll know when the signal occurs and we can handle it as we wish. Many conditions generate signals. Two terminal keys, called the interrupt key—often the DELETE key or Control-C—and the quit key—often Control-backslash—are used to interrupt the currently running process. Another way to generate a signal is by calling the kill function. We can call this function from a process to send a signal to another process. Naturally, there are limitations: we have to be the owner of the other process (or the superuser) to be able to send it a signal. Figure 1.10 Read commands from standard input and execute them 12345678910111213141516171819202122232425262728293031323334353637#include "apue.h"#include &lt;sys/wait.h&gt;static void sig_int(int); /* our signal-catching function */int main(void) &#123; char buf[MAXLINE]; /* from apue.h */ pid_t pid; int status; if (signal(SIGINT, sig_int) == SIG_ERR) err_sys("signal error"); printf("%% "); /* print prompt (printf requires %% to print %) */ while (fgets(buf, MAXLINE, stdin) != NULL) &#123; if (buf[strlen(buf) - 1] == '\n') buf[strlen(buf) - 1] = 0; /* replace newline with null */ if ((pid = fork()) &lt; 0) &#123; err_sys("fork error"); &#125; else if (pid == 0) &#123; /* child */ execlp(buf, buf, (char *) 0); // or // execlp(buf, buf, (char *)NULL); err_ret("couldn’t execute: %s", buf); exit(127); &#125; /* parent */ if ((pid = waitpid(pid, &amp;status, 0)) &lt; 0) err_sys("waitpid error"); printf("%% "); &#125; exit(0);&#125;void sig_int(int signo) &#123; printf("interrupt\n%% ");&#125; 这段代码使用自己定义的sig_int函数捕获 SIGINT 信号，但如果你按^C，代码依然会结束。原因是^C 也能像^D 一样让fgets函数返回一个 NULL。另外就算 while 是个死循环： 1234while(1)&#123; printf("开始休眠一秒钟...\n"); sleep(1);&#125; 当你按第二次^C 的时候，程序依然会退出，这就说明这个signal(SIGINT, sig_int)是一次性的。然后我将其写在了循环中， 123456while (1) &#123; if (signal(SIGINT, sig_int) == SIG_ERR) err_sys("signal error"); printf("开始休眠一秒钟...\n"); sleep(1);&#125; 无论你按多少次^C 都无法退出了，另外还有一个现象，每次按^C开始休眠一秒钟...会立马打印出来。 Time ValuesHistorically, UNIX systems have maintained two different time values: Calendar time. This value counts the number of seconds since the Epoch: 00:00:00 January 1, 1970,Coordinated Universal Time (UTC). (Older manuals refer to UTC as Greenwich Mean Time.) These time values are used to record the time when a file was last modified, for example. The primitive system data type time_t holds these time values. Process time. This is also called CPU time and measures the central processor resources used by a process. Process time is measured in clock ticks, which have historically been 50, 60, or 100 ticks per second. The primitive system data type clock_t holds these time values. (We’ll show how to obtain the number of clock ticks per second with the sysconf function in Section 2.5.4.) 有两种类型的时间：日历时间和进程时间，日历时间也就是 UTC。 When we measure the execution time of a process, as in Section 3.9, we’ll see that the UNIX System maintains three values for a process: Clock time User CPU time System CPU time The clock time, sometimes called wall clock time, is the amount of time the process takes to run, and its value depends on the number of other processes being run on the system. Whenever we report the clock time, the measurements are made with no other activities on the system. The user CPU time is the CPU time attributed to user instructions. The system CPU time is the CPU time attributed to the kernel when it executes on behalf of the process. For example, whenever a process executes a system service, such as read or write, the time spent within the kernel performing that system service is charged to the process. The sum of user CPU time and system CPU time is often called the CPU time. 度量进程执行时间，有三种： 墙上时钟，也就是进程执行花费的总时间。 用户 CPU 时间，是用户模式（非内核）下的 CPU 使用时间 系统 CPU 时间，是进程进入内核执行的 CPU 使用时间 It is easy to measure the clock time, user time, and system time of any process: simply execute the time(1) command, with the argument to the time command being the command we want to measure. For example: 12$ cd /usr/include$ time -p grep _POSIX_SOURCE */*.h &gt; /dev/null 结果： 123real 0m0.81suser 0m0.11ssys 0m0.07s The output format from the time command depends on the shell being used, because some shells don’t run /usr/bin/time, but instead have a separate built-in function to measure the time it takes commands to run. time 命令的输出格式取决于使用什么 shell，因为有些 shell 并不运行：/usr/bin/time，而是运行自己内置的一个 time 函数。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mathjax常用公式记录]]></title>
    <url>%2F2018%2F04%2F30%2Fmathjax%E5%B8%B8%E7%94%A8%E5%85%AC%E5%BC%8F%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[角度记法 度数：$60^\circ$，$60^\circ$ 度数分：$60^\prime$，$60^\prime$ 弧度：$\frac{\pi}{2}$，$\frac{\pi}{2}$ 角度记法：$\angle A$，$\angle A$ 三重环积分无法渲染的问题在网上找了半天资料最终解决了，参考这个答案：How do you render a closed surface double integral?，做法是直接使用 Unicode 编码：\unicode{x222F}，三重环积分的编码，参考这里：unicode-search.net，所以只要将$\oiiint$换成$\unicode{x2230}$即可正确显示三重环积分。如下： $$\unicode{x2230}$$ 行内 limit1$\lim\limits_&#123;x\rightarrow 0&#125; \frac&#123;\sin x&#125;&#123;x&#125; = 1$ 效果：$\lim\limits_{x\rightarrow 0} \frac{\sin x}{x} = 1$ 1$\lim_&#123;x\rightarrow 0&#125; \frac&#123;\sin x&#125;&#123;x&#125; = 1$ 效果：$\lim_{x\rightarrow 0} \frac{\sin x}{x} = 1$ 凭个人喜好，我就更喜欢第一种。 弧1$\overset&#123;\frown&#125; &#123;AB&#125;$ $\overset{\frown} {AB}$]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数学基础公式推导]]></title>
    <url>%2F2018%2F04%2F25%2F%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC%2F</url>
    <content type="text"><![CDATA[今天看到下面这个公式，突然想我好像不会推导啊： $\sin(\beta-\alpha) = \sin\beta\cos\alpha - \cos\beta\sin\alpha$ 遂想如何推导，在 youtube 上找了一个视频：三角函数正余弦和角公式推导 思路是先推导出：$\cos(\beta-\alpha) = \cos\alpha\cos\beta + \sin\alpha\sin\beta$ 然后根据这个再结合正弦余弦之间的关系就很容易推 $\sin(\beta-\alpha) = \sin\beta\cos\alpha - \cos\beta\sin\alpha$ 那么怎么推导上面这个公式呢？ 需要用到解析几何： 结合 勾股定理 和 余弦定理 可以推导出。 这里不给出勾股定理和余弦定理的证明，感兴趣的可以自己证。 根据勾股定理： $$\begin{align}\overline{PQ}^2&amp;= (\sin\alpha - \sin\beta)^2 + (\cos\beta - \cos\alpha)^2 \newline&amp;= 2 - 2(\cos\alpha\cos\beta + \sin\alpha\sin\beta) \newline\end{align}$$ 根据余弦定理（$a^2 = b^2 + c^2 -2ab\cos A$）： $$\begin{align}\overline{PQ}^2&amp; = 1^2 + 1^2 - 2\cdot1\cdot1\cdot\cos(\alpha-\beta)\end{align}$$ 由此推出： $$\cos(\alpha-\beta) = \sin\alpha\sin\beta+\cos\alpha\cos\beta$$ 也即： $$\cos(\beta-\alpha) = \sin\alpha\sin\beta+\cos\alpha\cos\beta$$ 然后： $$\begin{align}\sin(\beta-\alpha)&amp;= \cos(\frac{\pi}{2}-(\beta-\alpha)) \newline&amp;= \cos((\frac{\pi}{2}+\alpha) - \beta) \newline&amp;= \sin(\frac{\pi}{2}+\alpha)\sin\beta + \cos(\frac{\pi}{2}+\alpha)\cos\beta \newline&amp;= \cos\alpha\sin\beta - \sin\alpha\cos\beta \newline&amp;= \sin\beta\cos\alpha - \cos\beta\sin\alpha\end{align}$$]]></content>
      <categories>
        <category>数学</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Override Overload Overwrite]]></title>
    <url>%2F2017%2F11%2F14%2FOverride-Overload-Overwrite%2F</url>
    <content type="text"><![CDATA[我们都知道有些东西容易混淆，在加上中文翻译得乱七八糟，更加让人困惑。今天我要讲的这三位可就真是绝了。 它们是：Override、Overload、Overwrite。 这是我查有道词典时候看到的可怕一幕： Override 一个把三个名字都占了，你怕不怕？反正我是看的心里一紧。 如果把概念都煮成了一锅粥，那还不如不要记这些概念，你应该向更深层次去探寻。就这三个的区别来说，我觉得主要理解两个概念就行了： 函数签名（signature） 多态（polymorphism、polymorphic） 函数签名函数签名是什么，其实就是用来区别函数的，两个函数怎么样认定是不同的两个函数呢，只有两个方面： 函数名 参数 有人说还有返回值啊，不行，返回值不能作为函数签名的一部分，因为你调用一个函数的时候，返回值根本不能帮助编译器来识别你用的是哪个函数，比如： 1234int func(int a, int b);float func(int a, int b);func(); 请问我使用的是哪个函数？你看返回值确实不行吧。 多态多态是面向对象编程的概念，你可以看看它的准确定义： Polymorphism，定义很简短：polymorphism is the provision of a single interface to entities of different types. 如果父类有一个函数，子类也定义了一个完全相同的函数（函数签名相同），那么你可以用父类指针（或者说父类对象）作为统一的接口，来调用子类的方法。比如： 123456789101112131415161718192021222324252627class Vehicle&#123; public void move()&#123; System.out.println(“Vehicles can move!!”); &#125;&#125;class MotorBike extends Vehicle&#123; public void move()&#123; System.out.println(“MotorBike can move and accelerate too!!”); &#125;&#125;class Car extends Vehicle&#123; public void move()&#123; System.out.println(“Hi! I am a car!”); &#125;&#125;class Test&#123; public static void main(String[] args)&#123; Vehicle vh = new MotorBike(); vh.move(); // prints MotorBike can move and accelerate too!! vh = new Vehicle(); vh.move(); // prints Vehicles can move!! vh = new Car(); vh.move(); // prints Hi! I am a car! &#125;&#125; 多态的好处是可以扩展啊，比如我后来又多了个 truck 类，我不需要去动已经写好的代码，只要把 truck 模块写好，加进去就行了。 Override、Overload、Overwrite 的区别好了，知道了这两个概念，我们再来看看上面的那三个混在一起的东西： Override（推翻，对英文意思就是这个）subclass method overrides base class method means: in different range (in derived class and base class) the same function signature the base class method is virtual（if in C++） overload（超载）function overloading means: the same range (in the same class) the same function name but different function signature overwrite（重写）subclass method hides base class method means: in different range (in derived class and base class) the same function name 我们应该记住只有 Override 才跟多态有关。 Overload 是本 class 里面的不同函数（只不过函数名一样罢了，其实是两个不同的函数，看两个函数是否是同一个函数就看函数签名就行了），其实没啥稀奇的，不就是函数名一样嘛。函数签名一样，区分出是用父类还是子类的函数，这才是面向对象和多态要解决的问题。 Override 和 Overwrite 的区别 比较容易混淆的其实是 Override 和 Overwrite，但你只要死记住：Override 必须函数签名要一样，而 Overwrite 只需函数名一样即可。另外 C++ 中一定要用 virtual 才算 Override，而 Java 默认就是 Override，不需要修饰词。 这里关于 Java 和 C++ 面向对象的细节区别可以写一大堆，比如：C++ class 后面是要加分号的，而 Java 不需要；但 Java 的类名是和文件名要一致的，而且只能有一个 public 类，而 C++不需要；Java 直接就能用 Override，而 C++必须要使用 virtual 关键字才能使用 Override（虚函数）；Java 的抽象方法跟 C++的纯虚函数对应。Java 是单继承，由接口来实现“多继承”，C++是多继承，没有接口，只有抽象类。C++还有个虚基类的概念。具体的写法上还有很多的不同，多用这两种语言写面向对象的代码，就慢慢会知道了。 C++ 有一个 virtual 关键字和 virtual table 这个概念，没有加 virtual 的父类函数是不可能形成多态的，如果这时候你碰到父类和子类两个里面有同名的函数，那么就属于 Overwrite 这个概念了，你其实也可以称这种覆盖掉父类函数的行为为：hide 隐藏。Java 这种语言里面没有 virtual 这一套，Java 也可以表现出 Overwrite，但要注意函数签名如果一样的话，那又不叫 Overwrite 了，应该叫 Override 了（Java 如果要在子类中使用父类的同函数签名方法，则必须使用 super 关键字）。而 C++ 不一样，即便是函数签名一样，如果前面不加 virtual 是不能叫 Override 的，仍然属于 Overwrite 的概念。请看下面的例子： 用 C++ 写的话： 12345678910111213141516171819202122232425#include &lt;iostream&gt;using std::cout;using std::endl;class A&#123;public: void func(int a)&#123; cout &lt;&lt; "A" &lt;&lt; endl; &#125;&#125;;class B:public A&#123;public: void func(int a)&#123; cout &lt;&lt; "B" &lt;&lt; endl; &#125;&#125;;int main()&#123; A *a = new B(); a-&gt;func(1); ((B*)a)-&gt;func(1); return 0;&#125; 结果输出： 12AB 可以看到，C++必须要用子类类型的指针才能访问到子类的部分（建议看一本书，叫：Inside the C++ Object Model，中文叫：深入 C++对象模型，里面讲对象的内存布局讲的很清楚），java 也一样，必须转成子类型的指针才能访问，否则 IDE 会报错提示你。 Java 代码： 1234567891011121314151617181920public class test &#123; class A&#123; void func(int a)&#123; System.out.println("A"); &#125; &#125; class B extends A&#123; void func(int a, int b)&#123; System.out.println("B"); &#125; &#125; public static void main(String[] args)&#123; test t = new test(); A a = t.new B(); a.fun(1); ((B)a).func(1,2); &#125;&#125; 结果输出： 12AB 为什么 Java 代码里不像 C++ 代码里面那样，使用两个函数签名相同的函数？因为前面说过了，那样的话就变成 Override 了，只有在 C++ 里才能实现函数签名相同的 Overwrite（不使用 virtual 即可）。]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Inside the C++ Object Model 系列笔记 四 -- The Semantics of Function]]></title>
    <url>%2F2017%2F10%2F23%2FThe-Semantics-of-Function%2F</url>
    <content type="text"><![CDATA[c++支持三种类型的成员函数，分别为 static,nostatic,virtual。每一种调用方式都不尽相同。 nonstatic member functionC++的设计准则之一就是:nonstatic member function 至少必须和一般的 nonmember function 有相同的效率。实际上，nonstatic member function 会被编译器进行如下的转换，变成一个普通函数: Type1 X::foo(Type2 arg1) { ... } 会被转换为如下的普通函数: void foo(X *const this, Type1 &amp;__result, Type2 arg1) { ... } 改写函数原型，在参数中增加 this 指针，对每一个”nonstatic data member 的存取操作”改为由 this 指针来存取 将 member function 重写为一个外部函数，经过”mangling”处理（不需要处理的加上 extern “C”） 实际上，普通函数、普通成员函数、静态成员函数到最后都会变成与 C 语言函数类似的普通函数，只是编译器在这些不同类型的函数身上做了不同的扩展，并放在不同的 scope 里面而已。 编译器内部会将成员函数等价转换为非成员函数，具体是这样做的: 1.改写成员函数的签名，使得其可以接受一个额外参数，这个额外参数即是 this 指针： 123float Point::X();//成员函数X被插入额外参数thisfloat Point:: X(Point* this ); 当然如果成员函数是 const 的，插入的参数类型将为 const Point* 类型。 2.将每一个对非静态数据成员的操作都改写为经过 this 操作。 3.将成员函数写成一个外部函数，对函数名进行“mangling”处理，使之成为独一无二的名称。 可以看出，将一个成员函数改写成一个外部函数的关键在于两点，一是给函数提供一个可以直接读写成员数据的通道；二是解决好有可能带来的名字冲突。第一点通过给函数提供一个额外的指针参数来解决，第二点则是通过一定的规则将名字转换，使之独一无二。 于是在 VC 中对于上面的例子中的成员函数的调用将发生如下的转换： 1234//p-&gt;X();被转化为?X@Point@@QAEMXZ(p);//obj.X();被转化为?X@Point@@QAEMXZ(&amp;obj); 覆盖（override）、重载（overload）、隐藏（hide, overwrite）的区别： 覆盖（也叫重写）是指在派生类中重新对基类中的虚函数（注意是虚函数）重新实现。即函数名和参数都一样（函数签名一样），只是函数的实现体不一样。 重载是指 在同一个类中 不同的函数使用相同的函数名，但是函数的参数个数或类型不同。调用的时候根据函数的参数来区别不同的函数。 隐藏是指派生类中的函数把基类中相同名字的函数屏蔽掉了。隐藏与另外两个概念表面上看来很像，很难区分，其实他们的关键区别就是在多态的实现上。 C++多态（polymorphism）表示”以一个 public base class 的指针（或者 reference），寻址出一个 derived class object” 我专门写了一篇关于这些容易弄混的概念的文章：Override Overload Overwrite Virtual Member Function如果 function()是一个虚拟函数，那么用指针或引用进行的调用将发生一点特别的转换——一个中间层被引入进来。例如： 123// p-&gt;function()//将转化为(*p-&gt;vptr[1])(p); 其中 vptr 为指向虚函数表的指针，它由编译器产生。vptr 也要进行名字处理，因为一个继承体系可能有多个 vptr。 1 是虚函数在虚函数表中的索引，通过它关联到虚函数 function(). 何时发生这种转换？答案是在必需的时候 -- 一个再熟悉不过的答案。当通过指针调用的时候，要调用的函数实体无法在编译期决定，必需待到执行期才能获得，所以上面引入一个间接层的转换必不可少。但是当我们通过对象（不是引用，也不是指针）来调用的时候，进行上面的转换就显得多余了，因为在编译器要调用的函数实体已经被决定。此时调用发生的转换，与一个非静态成员函数(Nonstatic Member Functions)调用发生的转换一致。p.function()的处理就跟非静态成员函数一样了。 Static Member Function 不能够直接存取其类中的非静态成员（nostatic members），包括不能调用非静态成员函数(Nonstatic Member Functions)。 不能声明为 const、volatile 或 virtual 参数没有 this 可以不用对象访问，直接 类名::静态成员函数 访问，当然，通过对象调用也被允许 需要注意的是通过一个表达式或函数对静态成员函数进行调用，被 C++ Standard 要求对表达式进行求值。如： 12(a+=b).static_fuc();func().static_fuc(); 虽然省去对 a+b 求值对于 static_fuc()的调用并没有影响，但是程序员肯定会认为表达式 a+=b 已经执行，一旦编译器为了效率省去了这一步，很难说会浪费多少程序员多少时间去查找这个 bug。这无疑是一个明智的规定。func()返回一个对象。 vtable 的内容： virtual class offset（有虚基类才有） topoffset typeinfo 继承基类所声明的虚函数实例，或者是覆盖（override）基类的虚函数 新的虚函数（或者是纯虚函数占位） 虚函数表的构造挺简单的： 从内存布局的角度看，类对象继承基类的时候只把基类的 nonstatic data member 和 member function（函数入口，也可以说是函数指针） 放进自己内存里，static data member 和 static function 都在 global address 里面。然后就是虚函数表是复制了一份基类的虚函数表，然后把 virtual 实现了的部分替换掉，没实现的就不改，依然用父类的。然后虚函数表指针自然也要不一样，毕竟指向的内存地址不一样，对吧。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Inside the C++ Object Model 系列笔记 三 -- The Semantics of Data]]></title>
    <url>%2F2017%2F10%2F21%2FThe-Semantics-of-Data%2F</url>
    <content type="text"><![CDATA[C++对象模型的细节，讨论了 data members 的处理。 空类在内存中有空间吗 一个实例引出的思考： 1234class X&#123;&#125;;class Y:virtual public X&#123;&#125;;class Z:virtual public X&#123;&#125;;class A:public Y, public Z&#123;&#125;; 猜猜 sizeof 上面各个类都为多少？ Lippman 的一个法国读者的结果是： 1234sizeof X yielded 1sizeof Y yielded 8sizeof Z yielded 8sizeof A yielded 12 Lippman 自己的结果是： 1234sizeof X yielded 1sizeof Y yielded 4sizeof Z yielded 4sizeof A yielded 8 事实上，对于像 X 这样的一个空类，编译器会对其动点手脚——隐晦的插入一个字节。为什么要这样做呢？插入了这一个字节，那么 X 的每一个对象都将有一个独一无二的地址。如果不插入这一个字节呢？哼哼，那对 X 的对象取地址的结果是什么？两个不同的 X 对象间地址的比较怎么办？ 我们再来看 Y 和 Z。首先我们要明白的是实现虚继承，将要带来一些额外的负担——额外需要一个某种形式的指针。到目前为止，对于一个 32 位的机器来说 Y、Z 的大小应该为 5，而不是 8 或者 4。我们需要再考虑两点因素：内存对齐（alignment—）和编译器的优化。 空类也有 1Byte 的大小，因为这样才能使得这个 class 的 2 个 objects 在内存中有独一无二的地址。 The Binding of a Data Member考虑下面这样的代码： 1234567891011extern float x;class Point3d&#123;public: Point3d(float, float, float); //问题是 x 到底是哪个 x 呢 float X() const &#123;return x;&#125; void X(float new_x) const&#123;x = new_x;&#125;private: float x;&#125; 对 member functions 本身的分析会直到整个 class 的声明都出现了才开始（直到看到代表 class 结束的}右大括号）。所以 class 的 member functions 可以引用声明在后面的成员，C 语言就做不到。 和 member functions 对比，需要十分注意的一点是:class 中的 typedef 并不具备这个性质。因此，类中的 typedef 的影响会受到函数与 typedef 的先后顺序的影响。 1234567typedef int length;class Point3d&#123;public: void f1(length l)&#123; cout &lt;&lt; l &lt;&lt; endl; &#125; typedef string length; void f2(length l)&#123; cout &lt;&lt; l &lt;&lt; endl; &#125;&#125;; 这样 f1 绑定的 length 类型是 int;而 f2 绑定的 length 类型才是 string。 所以，对于 typedef 需要防御性的程序风格:始终把 nested type 声明(即 typedef)放在 class 起始处! Data Member LayoutC++只保证处于同一个 access section（也就是 private,public,protected 片段）的数据，一定会以声明的次序出现在内存布局当中(要求较晚出现的数据成员处在较大的内存地址中)。C++标准只提供了这一点点的保证。允许编译器将多个 Acess Section 的顺序自由排列，而不必在乎它们的声明次序。但似乎没有编译器这样做。对于继承类，C++标准并未指定是其基类成员在前还是自己的成员在前。 12345678class X &#123;public: int i; int j;private: int k; int n;&#125; 数据 i 一定在 j 之前，k 一定在 n 之前。具体什么顺序就看编译器了。 传统上，vptr 被安放在所有被明确声明的 member 的最后，不过也有些编译器把 vptr 放在最前面(MSVC++就是把 vptr 放在最前面，而 G++ 是把 vptr 放在最后面)。 Access of a Data Member在 C++中，直观上来说，由一个对象存取一个 member 会比由一个指针存取一个 member 更快捷。但是对于经由一个对象来存取和由一个指针来存取一个静态的 member 来说，是完全一样的，都会被编译器所扩展。 经由 member selection operators（也就是 “.” 运算符）对一个 static data member 进行存取操作只是一种语法上的便宜行事而已。member 其实并不在 class object 中，因此存取并不需要通过 class object。 经由一个函数调用的结果来存取静态成员，C++标准要求编译器必须对这个函数进行求值，虽然这个求值的结果并无用处。 foo().static_member = 100; foo()返回一个类型为 X 的对象，含有一个 static_member，foo()其实可以不用求值而直接访 问这个静态成员，但是 C++标准保证了 foo()会被求值，可能的代码扩展为: 12(void) foo();X::static_member = 100; static data members如果有两个 class ，每个都声明了一个 static member freelist，那么当他们都被放在程序的 data segment 时，就会导致名称冲突。编译器的解决方法是暗中对每一个 static data member 编码（这种手法有个很美的名称：name-mangling），以获得一个独一无二的程序识别代码。有多少种编译器就有多少种 name-mangling 做法！通常不外乎是表格啦，语法措辞啦等等。任何 name-mangling 都有两个要点： 一种算法，推导出独一无二的名称。 万一编译系统（或环境工具）必须和使用者交谈，那些独一无二的名称可以轻易被推导回原来的名称。 nonstatic data membersNonstatic data members are stored directly within each class object and cannot be accessed except through an explicit or implicit class object. An implicit class object is present whenever the programmer directly accesses a nonstatic data member within a member function. For example, in the following code: 123456Point3dPoint3d::translate( const Point3d &amp;pt ) &#123; x += pt.x; y += pt.y; z += pt.z;&#125; the seemingly direct access of x, y, and z is actually carried out through an implicit class object representedby the this pointer. Internally, the function is augmented as follows: 1234567// internal augmentation of member function Point3d Point3d::translate( const Point3d* this, const Point3d &amp;pt ) &#123; this-&gt;x += pt.x; this-&gt;y += pt.y; this-&gt;z += pt.z;&#125; 地址：&amp;origin._y;和&amp;origin + ( &amp;Point3d::_y - 1 );是一样的。指向 data member 的指针，其 offset 值总是被加上 1。这样可以使编译系统区分出 “一个指针 data member 的指针，用以指向 class 的第一个 member”和“一个指向 data member 的指针，但是没有指向任何 member”两种情况(成员指针也需要有个表示 NULL 的方式，0 相当于用来表示 NULL 了，其它的就都要加上 1 了)。 Inheritance and the Data MemberC++ Standard 保证:“出现在派生类中的 base class subobject 有其完整原样性!” 子类会被放在父类的对齐空白字节之后，因为父类的完整性必须得以保证，父类的对齐空白字节 也是父类的一部分，也是不可分割的。 请看下面例子： 12345678910class X&#123;public: int x; char c;&#125;;class X2:public X&#123;public: char c2;&#125;; X2 的布局应当是 x(4),c(1),c2(1),这么说来 sizeof(X2)的值应该是 8？错了，实际上是 12。原因在于 X 后面的三个字节的填充空白不能为 c2 所用。也就是说 X2 的大小实际上为：X(8)+c2(1)+填补（3）=12。这样看来编译器似乎是那么的呆板，其实不然，看一下下面的语句会发生什么？ 123X2 x2;X x;x2=x; 如果 X 后面的填充空白可以被 c2 使用的话，那么 X2 和 X 都将是 8 字节。上面的语句执行后 x2.c2 的值会是多少？一个不确定的值！这样的结果肯定不是我们想要的。 在多重继承的派生体系中，将派生类的地址转换为第 1 基类时成本与单继承是相同的，只需要改换地址的解释方式而已；而对于转换为非第 1 基类的情况，则需要对地址进行一定的 offset 操作 才行。C++ Standard 并未明确 base classes 的特定排列次序，但是目前的编译器都是按照声明的次序来安放他们的。(有一个优化:如果第 1 基类没有 vtable 而后继基类有，则可能把它们调 个位置)。多重继承中，可能会有多个 vptr 指针，视其继承体系而定:派生类中 vptr 的数目最多等于所有基类的 vptr 数目的总和。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Inside the C++ Object Model 系列笔记 二 -- The Semantics of constructors]]></title>
    <url>%2F2017%2F10%2F20%2FThe-Semantics-of-constructors%2F</url>
    <content type="text"><![CDATA[这一章详细的讨论了 constructor 如何工作，讨论构造一个对象的过程以及构造一个对象给程序带来的影响。 区分 trivial 和 notrivial 只有编译器需要的时候(为什么会需要?后面讲的很清楚)，合成操作才是 nontrivial 的， 这样的构造函数才会被真正的合成出来; 如果编译器不需要，而程序员又没有提供，这时的默认构造函数就是 trivial 的。虽然它在概念上存在，但是编译器实际上根本不会去合成出来，因为他不做任何没有意义的事情，所以当然可以忽略它不去合成。trivial 的函数只存在于概念上，实际上不存在这个函数。 default constructorA default constructor is a constructor which can be called with no arguments (either defined with an empty parameter list, or with default arguments provided for every parameter). 通常很多 C++程序员存在两种误解 没有定义默认构造函数的类都会被编译器生成一个默认构造函数。 编译器生成的默认构造函数会明确初始化类中每一个数据成员。 被声明：declared，被定义：defined。声明代表分配内存空间，定义代表初始化，也就是分配具体的值。 注意如果声明的是一个指针（或者在其他语言里声明了一个对象或者数组的引用），那么只会开辟一个指针的空间，真正的对象要到定义的时候，也就是初始化的时候，分配内存并初始化。 所以所有成员都在声明的时候被分配内存，构造函数的作用是初始化它们，non-object 成员需要程序员自己初始化，编译器不帮忙。 C++中对于默认构造函数的解释是:默认的构造函数会在需要的时候被编译器产生出来。这里非常重要的一点是:谁需要?是程序的需要还是编译器的需要?如果是程序的需要，那是程序员的责任;只有在是编译器的需要时，默认构造函数才会被编译器产生出来，而且被产生出来的默认构造函数只会执行编译器所需要的行动，而且这个产生操作只有在默认构造函数真正被调用时才会进行合成。 例如:成员变量初始化为 0 操作，这个操作就是程序的需要，而不是编译器的需要。 总结变量的初始化: Global objects are guaranteed to have their associated memory “zeroed out” at program start-up. Local objects allocated on the program stack and heap objects allocated on the free-store do not have their associated memory zeroed out; rather, the memory retains the arbitrary bit pattern of its previous use. 只有全局变量和静态变量才会保证初始化，其中静态变量可以视为全局变量的一种，因为静态变量也是保存在全局变量的存储空间上的。Golbal objects 的内存保证会在程序激活的时候被清 0；Local objects 配置于程序的堆栈中，Heap objects 配置于自由空间中，都不一定会被清为 0,它们的内容将是内存上次被使用后的痕迹! 全局变量和静态变量都放在 global data Segment 上，且在类被声明的时候就已经分配内存和初始化，也就是 在任何对象被定义之前静态变量就已经存在了（即使该 class 没有任何 object 实体，static data members 也已经存在）。 123456789class Foo &#123; public: int val; Foo *pnext; &#125;;void foo_bar()&#123; // Oops: program needs bar's members zeroed out Foo bar; if ( bar.val || bar.pnext ) // ... do something // ...&#125; When is a default constructor synthesized, then? Only when the implementation needs it. Moreover, the synthesized constructor performs only those activities required by the implementation. That is, even if there were a need to synthesize a default constructor for class Foo, that constructor would not include code to zero out the two data members val and pnext. For the previous program fragment to execute correctly, the designer of class Foo needs to provide an explicit default constructor that properly initializes the class’s two members. 意思是初始化 val 和 pnext 是程序员的责任，编译器不负责，所以你这里不初始化它们，它们存储的结果就是内存遗留的痕迹。 什么时候编译器会给你生成默认构造函数首先你得没有写默认构造函数，编译器才会给你生成。有四类情况，编译器会给你加代码： 类中有一个对象（成员变量），这个对象包含了默认构造函数 继承自带有默认构造函数的基类的类 带有虚函数的类 继承自虚基类的类 如果 class A 内含一个或以上的 member objects，那么 A 的 constructor 必须调用每一个 member class 的默认构造函数。具体方法是:编译器会扩张 constructors（注意：是所有的构造函数，不仅仅是默认构造函数会被扩张），在其中安插代码使得在 user code 被调用之前先调 用 member objects 的默认构造函数(当然如果需要调用基类的默认构造函数，则放在基类的 默认构造函数调用之后:基类构造函数-&gt;成员构造函数-&gt;user code)。C++要求以“member objects 在 class 中的声明次序”来调用各个 construtors。这就是声明的次序决定了初始化次序(构造函数初始化列表一直要求以声明顺序来初始化)的根本原因!所以你打乱 member initialization list 的顺序根本没有用哦~ 理解了初始化列表中的实际执行顺序中“以 member 声明的次序”来决定的，就可以理解一些很 微妙的错误了。比如: 12A() : i(99), j(66), value(foo()) &#123;... &#125;int i, value, j; 这会不会产生错误取决于成员函数 foo()是依赖于 i 还是 j:如果 foo 依赖于 i，由于 i 声明在 value 之前，所以不会产生错误;如果 foo 依赖于 j，由于 j 声明在 value 之后，就产生了使用未初始化成员的错误。 带有 virtual functions 的类的默认构造函数毫无疑问是 nontrivial 的，需要编译器安插额外的成员 vptr 并在构造函数中正确的设置好 vptr，这是编译器的重要职责之一。继承自 virtual base class 的类的默认构造函数同样也毫无疑问的 nontrivial，编译器需要正确设置相关的信息以使得这些虚基类的信息能够在执行时准备妥当，这些设置取决于编译器实现虚基类的手法。 编译器有 4 种情况会使得编译器真正的为 class 生成 nontrivial 的默认构造函数，这个 nontrivial 的默认构造函数只满足编译器的需要(调用 member objects 或 base class 的默认构造函数、初始化 virtual function 或 virutal base class 机制)。其它情况时，类在概念上拥有默认构造函数，但是实际上根本不会被产生出来(前面的区分 trivial 和 nontrivial)。 对于一个 trivial 默认构造函数，编译器的态度是，既然它全无用处，干脆就不合成它。在这儿要厘清的是概念与实现的差别，概念上追求缜密完善，在实现上则追求效率，可以不要的东西就不要。 copy constructor有一个参数的类型是其类类型的构造函数是为拷贝构造函数。如下： 123X::X( const X&amp; x);Y::Y( const Y&amp; y, int =0 );//可以是多参数形式，但其第二个即后继参数都有一个默认值 什么时候编译器会给你生成拷贝构造函数 其实和前面默认构造函数一样，四种情况 如果一个类没有定义拷贝构造函数，通常按照“成员逐一初始化(Default Memberwise Initialization)”的手法来解决“一个类对象以另一个同类实体作为初值”——也就是说把内建或派生的数据成员从某一个对象拷贝到另一个对象身上，如果数据成员是一个对象，则递归使用“成员逐一初始化(Default Memberwise Initialization)”的手法。 成员逐一初始化(Default Memberwise Initialization)具体的实现方式则是位逐次拷贝（Bitwise copy semantics） Copy constructors 和默认构造函数一样，只有在必须的时候才会被产生出来，对于大部分的 class 来说，拷贝构造函数仅仅需要按位拷贝就可以。满足 bitwise copy semantics 的拷贝构造函数是 trivial 的，就不会真正被合成出来(与默认构造函数一样，只有 nontrivial 的拷贝构 造函数才会被真正合成出来)。对大多数类按位拷贝就够了，什么时候一个 class 不展现出 bitwise copy semantics 呢? 分为 4 种情况，前 2 种很明显，后 2 种是由于编译器必须保证正确设置虚机制而引起的。 当 class 内含一个 member object 而后者声明了(也可能由于 nontrivial 语意从而编译器 真正合成出来的)一个 copy constructor 时; 当 class 继承自一个存在有 copy constructor 的 base class(同样也可能是合成)时; 当 class 声明了一个或多个 virtual functions 时;(vf 影响了位语意，进而影响效率) 当 class 派生自一个继承串链，其中一个或多个 virtual base classes 时。 对于前两种情况，不论是基类还是对象成员，既然后者声明有拷贝构造函数时，就表明其类的设计者或者编译器希望以其声明的拷贝构造函数来完成“一个类对象以另一个同类实体作为初值”的工作，而设计者或编译器这样做——声明拷贝构造函数，总有它们的理由，而通常最直接的原因莫过于因为他们想要做一些额外的工作或“位逐次拷贝”无法胜任。 对于有虚函数的类，如果两个对象的类型相同那么位逐次拷贝其实是可以胜任的。但问题将出现在，如果基类由其继承类进行初始化时，此时若按照位逐次拷贝来完成这个工作，那么基类的 vptr 将指向其继承类的虚函数表，这将导致无法预料的后果——调用一个错误的虚函数实体是无法避免的，轻则带来程序崩溃，更糟糕的问题可能是这个错误被隐藏了。所以对于有虚函数的类编译器将会明确的使被初始化的对象的 vptr 指向正确的虚函数表。因此有虚函数的类没有声明拷贝构造函数，编译将为之合成一个，来完成上述工作，以及初始化各数据成员，声明有拷贝构造函数的话也会被插入完成上述工作的代码。 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;class A &#123;public: virtual void f() &#123; cout &lt;&lt; "A::f()" &lt;&lt; endl; &#125; int i;&#125;;class B : public A &#123;public: void f()&#123; cout &lt;&lt; "B::f()" &lt;&lt; endl; &#125;&#125;;int main(int argc, char const *argv[])&#123; B b; b.i=1; A a = b; A *p = &amp;a; p-&gt;f(); cout &lt;&lt; p-&gt;i &lt;&lt; endl; return 0;&#125; 上面例子可以看出，如果 A a = b;是 bitwise copy semantics 的话，a 内放置的就是 b 的 vptr。但其实不是，编译器给 a 生成了拷贝构造函数，初始化了 a 的 vptr。b 的 vptr 是由编译器给 b 生成的默认构造函数初始化的。但对于其他成员变量 bitwise copy semantics 依然有效，所以 i 的结果是 1。我在做这个试验的时候发现了一个有趣的现象： 123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;class A &#123;public: virtual void f() &#123; cout &lt;&lt; "A::f()" &lt;&lt; endl; &#125; int i;&#125;;class B : public A &#123;public: void f()&#123; cout &lt;&lt; "B::f()" &lt;&lt; endl; &#125; int i;&#125;;int main(int argc, char const *argv[])&#123; B b; b.i=1; A a = b; A *p = &amp;a; p-&gt;f(); cout &lt;&lt; p-&gt;i &lt;&lt; endl; return 0;&#125; 两个 i 不是同一个 i，b.i=1;优先给 b 中的同名变量赋值了。这样的代码简直可怕。那么怎么访问到从 A 继承来的成员变量 i 呢，请看： 123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;class A &#123;public: virtual void f() &#123; cout &lt;&lt; "A::f()" &lt;&lt; endl; &#125; int i;&#125;;class B : public A &#123;public: void f()&#123; cout &lt;&lt; "B::f()" &lt;&lt; endl; &#125; int i;&#125;;int main(int argc, char const *argv[])&#123; B b; b.A::i=6; b.B::i=1; A a = b; A *p = &amp;a; cout &lt;&lt; p-&gt;i &lt;&lt; endl; return 0;&#125; 命名返回值优化对于一个如 foo()这样的函数，它的每一个返回分支都返回相同的对象，编译器有可能对其做 Named return Value 优化（下文都简称 NRV 优化），方法是以一个参数 result 取代返回对象。 foo()的原型： 12345678X foo()&#123; X xx; if(...) return xx; else return xx;&#125; 优化后的 foo()以 result 取代 xx： 1234567891011121314void foo(X &amp;result)&#123; result.X::X(); if(...) &#123; //直接处理result return; &#125; else &#123; //直接处理result return; &#125;&#125; 对比优化前与优化后的代码可以看出，对于一句类似于 X a = foo()这样的代码，NRV 优化后的代码相较于原代码节省了一个临时对象的空间（省略了 xx）,同时减少了两次函数调用（减少 xx 对象的默认构造函数和析构函数，以及一次拷贝构造函数的调用，增加了一次对 a 的默认构造函数的调用）。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Inside the C++ Object Model 系列笔记 一 -- Object Lessons]]></title>
    <url>%2F2017%2F10%2F19%2FObject-Lessons%2F</url>
    <content type="text"><![CDATA[多态：统一的接口，不同的实现 C++多态（polymorphism） 表示“以一个 public base class 的指针（或者 reference），寻址出一个 derived class object” Layout Costs for Adding Encapsulation(封装) 意思是：为了添加封装所需要付出的内存布局花销 第一章 Object Lessons 介绍了 C++如何在背后实现一个对象，内存中的布局以及空间上的关系。 在计算机的原理中，要实现某个机制，我们总能找到很多种实现方式（对比着学习，多思考每种实现方法的利弊），C++的类的实现也不例外，让我们对比以下三种实现方式： 三种对象实现模式A Simple Object Model 可以看到，简单对象模型把所有的 data member 和 member function（函数指针）都放在对象里了。 A Table-driven Object Model 表驱动模型把 member 分为 data 和 function 两类，用两个指针分别指向两个表，一个存放所有的 data member，一个存放所有的 function 指针。 The C++ Object Model 12345678template&lt;class Type&gt;class Point3d&#123;public: Point3d(Type x, Type y, Type z) : x_(x), y_(y), z_(z) &#123;&#125; Type x() &#123; return x_; &#125;private: Type x_, y_, z_;&#125; 上面的 C++ 类并不会比 C 语言 的 struct 耗费更多的内存空间，三个 data members 直接内含于 Object 中，member functions 则放在 Object 外。 C++的 data members 有两种：static 和 nonstatic C++的 member functions 有三种：static 、nonstatic 、virtual 放在 Object 中的只有 nonstatic data members，其他的统统是放在 Object 外。 一个对象的内存布局大小(通常由 3 部分组成): 其 nonstatic data member 的总和大小; 任何由于位对齐所需要的填补上去的空间;(关于内存对齐，自己查) 为了支持 virtual 机制而引起的额外负担。 data members 在内存中的布局C++只保证处于同一个 access section（也就是 private,public,protected 片段）的数据，一定会以声明的次序出现在内存布局当中(要求较晚出现的数据成员处在较大的内存地址中)。C++标准只提供了这一点点的保证。允许编译器将多个 Acess Section 的顺序自由排列，而不必在乎它们的声明次序。但似乎没有编译器这样做。对于继承类，C++标准并未指定是其基类成员在前还是自己的成员在前。 12345678class X &#123;public: int i; int j;private: int k; int n;&#125; 数据 i 一定在 j 之前，k 一定在 n 之前。其他顺序就看编译器了。 Virtual Table(vtbl, vtable) 和 vptrVirtual function 机制由以下 2 个步骤来支持： 每个 class 产生的 Virtual function 的指针放在 Virtual Table 中 编译器给每个 class object 添加一个指针 vptr，指向相应的 vtable 一个 vtable 对应一个 class，一个 vptr 才对应一个 class object，必须区分开这 2 个概念。vtable 独立于对象，就跟函数独立于对象一样。这样所有对象才能共享它们，就像 static data members 被共享一样。 nonstatic data member是对象独有的，每个对象都有自己的一份。而其他的 member 全都是公用的。其实这里可以顺便学一下序列化这个概念，思考一下序列化对象的时候哪些东西需要存储。 RTTI(run-time type identification):一般来说，每一个 class 相关联的 type_info 对象的指针通常也保存在 vtable 的第一个 slot 中。关于 type_info 是什么，可以自己查。 引入继承后的对象模型成本 如果是普通继承，父对象被直接包含在子对象里面，这样父对象的存取也是直接进行的，没有额外的指针成本。 如果是虚拟继承，父对象由一个指针指出来，这样父对象的存取就必须由指针访问，添加了一层间接性。 virtual base class，用以实现 “多次出现在继承体系中的 base class，有一个单一而被共享的实例” 1234class A &#123; public: void Foo() &#123;&#125; &#125;;class B : public virtual A &#123;&#125;;class C : public virtual A &#123;&#125;;class D : public B, public C &#123;&#125;; 我觉得这里有个问题，class D 继承 class B 和 class C 的时候并不是虚继承，所以何不将 B 和 C 直接放在 D 中呢？这样就省了两次指针。 这是我看到的一个讲的很不错的博客：虚拟继承 struct 和 class 关键字的区别总共就两个区别： struct defaults to public access and class defaults to private access. When inheriting, struct defaults to public inheritance and class defaults to private inheritance. (Ironically, as with so many things in C++, the default is backwards: public inheritance is by far the more common choice, but people rarely declare structs just to save on typing the “public” keyword). 哈哈，我觉得这么做的目的无非就是提醒你注意封装，不要给外部暴露没必要的东西，所以才把默认搞成 private。 除此之外 struct 和 class 一样。 struct 用来表现那些只有数据的集合体 POD(Plain Old Data)、而 class 则希望表达的是ADT(abstract data type)的思想。 POD stands for Plain Old Data - that is, a class (whether defined with the keyword struct or the keyword class) without constructors, destructors and virtual members functions. 由于这 2 个关键字在本质上无区别，所以 class 并没有必须要引入，但是引入它的确非常令人满意，因为这个语言所引入的不止是这个关键字，还有它所支持的封装和继承的哲学。可以这样想象：struct 只剩下方便 C 程序员迁徙到 C++的用途了。 programming paradigmsC++支持三种形式的编程风格(或称典范 paradigm): 面向过程的风格（procedural model）: 就像 C 一样，一条语句接一条语句的执行或者函数跳转; 抽象数据类型模型(abstract data type model，ADT): 仅仅使用了 class 的封装，很多人都是 在用基于对象的风格却误以为自己在使用面向对象的风格; 面向对象的风格(object-oriented): 使用了 class 的封装和多态的编程思维(多态才是 真正的面向对象的特征)。 纯粹以一种 paradigm 写程序，有助于整体行为的良好稳固。 一个 reference 通常是以一个指针来实现的，所以 point 和 reference 并没有本质的区别，reference 和 const 指针的区别就是，你取 reference 指针的地址的时候，取到的是数据的地址，const 指针取地址取到的是指针的地址。下面的程序说明了这一点： 123456789101112#include &lt;iostream&gt;using namespace std;int main()&#123; int a=1; int &amp;b=a; const int *p = &amp;a; cout &lt;&lt; &amp;b &lt;&lt; endl; cout &lt;&lt; p &lt;&lt; endl; cout &lt;&lt; &amp;p &lt;&lt; endl;&#125; 也就是说你取不到 b 的地址。所以说引用相当于一个 别名。引用常用在函数调用里，可以直接操作原有对象，这样就可以不用写指针的指针这种绕弯的东西了。 函数的实参传递给形参是值传递，也就是一个 copy，形参在函数里将是一个局部变量。这个特性是许多新手面临的大坑。一道经典的考察题目便是，实现一个 C 语言的 swap 函数，由于 C 语言没有引用，你就只能用指针来操作原有对象了。java 更坑，java 没有指针，所以需要用引用，但基础数据类型没有引用，所以你如果要交换基础数据类型的话，根本没办法写 swap 函数。 如果你对 C 语言的程序栈很了解的话，就会知道形参实际上是不存在的，实参直接拷贝到了寄存器中，所以底层上来说参数都是值拷贝，而且操作结果无法写回到实参，实参稳稳的放在上一个栈帧中从未发生任何变化。具体的细节可以看：《CSAPP》读书笔记 -- 第 3 章：程序的机器级表示 指针的类型 对于内存来说，不同类型的指针并没有什么不同。它们都是占用一个 word 的大小（所以 word 的大小决定了内存可访问空间的大小，32 位系统是 4 字节，64 位系统是 8 字节），包含一个数字，这个数字代表内存中的一个地址; 指针的类型是编译器的概念，对于硬件来说，并没有什么指针类型的概念; 转型操作也只是一种编译器的指令，它改变的是编译器对被指内存的解释方式而已! void*指针只能够持有一个地址（一个字节），而不能通过它操作所指向的 object]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[值传递和引用传递]]></title>
    <url>%2F2017%2F03%2F29%2F%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%2F</url>
    <content type="text"><![CDATA[Java 没有引用传递，本质上都是值传递，只不过如果传递的值可以是指针（Java 没有指针，所以你也可以理解为对象，其实本质上还是指针）。 12345678910111213public class Solution &#123; private void getString(String text)&#123; text = "hello"; &#125; public static void main(String[] args) &#123; Solution solution = new Solution(); String text = "world"; solution.getString(text); System.out.println(text); &#125;&#125; text 本质上是一个指针，而 getString 中的 text 则是另一个指针（一个局部变量），所以这里实际上有两个不同的 text，而我们实际上改变的就是一个局部变量。所以输出结果是：world。也可以理解为形参和实参不是同一个对象，形参是一个局部变量，存在于寄存器或者当前栈帧，实参存在于上一级栈帧，和而被调用的函数，在它的执行过程中不会改变上一层栈帧的实参。 如果深入了解了 C 语言程序栈的构造，就能彻底明白函数调用的细节：过程调用 值传递和引用传递是每个刚开始写代码的程序员的必经之坑，比如经典的 swap 函数交换，就是一个大坑： 12345678910111213141516public class Solution &#123; private void swap(String text1, String text2)&#123; String temp = text1; text1 = text2; text2 = temp; &#125; public static void main(String[] args) &#123; Solution solution = new Solution(); String text1 = "world"; String text2 = "hello"; solution.swap(text1, text2); System.out.println(text1+" "+text2); &#125;&#125; 输出是：world hello 实际上我觉得这应该算得上是编程语言底层设计影响到上层使用的一个例子，不是那么自然，比较容易让人困惑。可以算作是一种封装的失败吧。补救方法在 C 中是使用指针，C++中是使用引用，Java 中是使用对象包装一层。]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[常量池]]></title>
    <url>%2F2017%2F03%2F28%2F%E5%B8%B8%E9%87%8F%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[字符串由 char 数组实现，字符串以\0结尾，\0是 ASCII 的第一个字符，用 bit 表示也就是：0000 0000，这可以方便我们找到字符串的结尾。 ASCII 字符由一个字节表示，实际上第一版的 ASCII 字符只用到了 7 个 bit，128 个字符，扩展版的 ASCII 使用了 8 个 bit。 12char str[11];strcpy(str, "0123456789\0"); 为了节省内存，C/C++把常量字符串放到常量池中，当几个指针被赋值了相同的字符串常量时，实际上它们会指向相同的内存地址。但用常量字符串初始化数组，情况却不同。 1234567891011121314151617181920int _tmain(int argc, _TCHAR* argv[])&#123; char str1[] = "hello world"; char str2[] = "hello world"; char* str3 = "hello world"; char* str4 = "hello world"; if(str1==str2)&#123; printf("str1 and str2 are same.\n"); &#125;else&#123; printf("str1 and str2 are not same.\n"); &#125; if(str3==str4)&#123; printf("str3 and str4 are same.\n"); &#125;else&#123; printf("str3 and str4 are not same.\n"); &#125; return 0;&#125; 输出：str1 and str2 are not same.str3 and str4 are same. 常量池虽然好用，但这样会造成一个问题，就是我们拿其中一个指针改了字符串内容，就会造成另一个指针指向的字符串也变了。为此像 C#和 Java 等语言都将字符串类型设为不可变对象，改变字符串实际上是新建了一个字符串，这样就不会引起冲突了。但如果需要不停的改变就要不停的新建，这样就太影响效率，所以又提供了StringBuilder类，这个类是支持在原字符串上改动的。]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数组和指针的区别]]></title>
    <url>%2F2017%2F03%2F27%2F%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[数组和指针的区别： 123456789101112131415int GetSize(int data[])&#123; return sizeof(data);&#125;int _tmain(int argc, _TCHAR* argv[])&#123; int data1[] = &#123;1, 2, 3, 4, 5&#125;; int size1 = sizeof(data1); int* data2 = data1; int size2 = sizeof(data2); int size3 = GetSize(data1); printf("%d, %d, %d\n", size1, size2, size3);&#125; 答案是输出：20, 4, 4 sizeof是个关键字而不是函数，sizeof(data1)是求数组的大小，这里有5个int型元素，所以总共20个字节，data2声明为指针，尽管指向了一个数组，但本质上只是一个指针，所以sizeof(data2)的语义范围收缩了，无法仅通过一个指针得知其所指范围。在32位系统上一个指针是4字节，所以结果就是4。在C/C++中，当数组作为函数的参数进行传递时，数组就自动退化为同类型的指针，因此size3的结果也是4。]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MacbookPro使用总结]]></title>
    <url>%2F2017%2F01%2F01%2FMacbookPro%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[简单分析我使用 mac 15 pro retina 已经一年了，于是写篇总结吧。我们不装逼，不盲从，要理性。 mac 机器的亮点：轻薄，另外触摸板真的很好用，我已经很久没用过鼠标了，retina 屏也是非常养眼，立体声也十分不错，细节做得很好，充电口是磁性的，正反两面都能充，指示灯是能显示是否充满的（用过 surface pro 4 的对比一下就知道，什么叫做细心），键盘背光，铝制机身，最后外观简洁美观。 OS X 的最大亮点：GUI 和 CLI 的完美结合，优化的很好，系统耗电少。 可以说这是一个不错的工具，无论是对普通用户来说，还是对程序员来说。 接下来的全是干货！！！ 文件管理器 Finder首先讲 Finder，这是 mac 系统，也就是 OS X 系统的文件管理器，和 windows 的文件管理器对比有有点不同，最不方便的地方在于点击右键没有新建文件选项，如果你会 Linux，可以用命令touch 文件名来新建文件，如果你不会命令，可以先打开文本编辑器，再新建文本文件，它的设计哲学是，你要新建什么文件，就先打开与这个文件相关的软件，再在这个软件里新建这个类型的文件，不过不方便就是不方便。再讲讲优秀的地方，Finder 可以打开多及目录 另外可以 按空格键预览。Finder 还有 tag 系统，你可以通过 tag 来访问同一 tag 的文件 快捷键然后讲讲快捷键设计，我在 windows 下已经有了些使用快捷键的习惯，比如： win+E 是打开文件管理器 win+D 是显示桌面（也就是将所有窗口最小化） win+L 锁屏 ctrl+S 保存 ctrl+A 全 ctrl+C 复制 ctrl+X 剪切 ctrl+V 粘贴 ctrl+F 查找 当我来到 OS X 下的时候，我同样先摸索了一番快捷键。设计快捷键的哲学就是通用，这样就可以节省记忆成本，mac 上的 cmd 基本上承担了 windows 上 ctrl 的职能，常用的快捷键有： cmd+S 保存 cmd+A 全选 cmd+C 复制 cmd+X 剪切 cmd+V 粘贴 cmd+F 查找 cmd+,打开 preferance 也就是打开设置界面 cmd+N 打开新窗口 cmd+W 关闭窗口 cmd+H 隐藏窗口 cmd+Q 退出程序 cmd+ctrl+F 全屏 cmd+Tab 切换程序 你用了 Finder 之后可能会恼火没有剪切文件的功能，但其实是有的，只是快捷键不一样，剪切文件的快捷键是，先 cmd+C 复制，然后 cmd+option+V 粘贴。 这是我常用的几个快捷键。总之快捷键不用记很多，按你自己的需要，记住常用的就行。另外对于乐于摸索的孩子，我觉得一些小 trick 可以增加趣味性，从而激发兴趣。下面再讲些不常用但是有意思的： 除了 cmd 是常用的，option 键也值得我们关注，下面再讲几个 option 的妙用： 按住 option+shift 可以微调（1/4 微调）音量、键盘背光亮度和屏幕亮度，按住 option 再按其他字母键等，会出现奇怪的字符 ¥©©œ∑®†¥åß©≈ç。 按住 option 再把鼠标移到 Dock 上的 APP 上，你会发现退出变成了强制退出。 Command+Option+D 控制 Dock 的显示与隐藏 Command+Shift+H 隐藏所有其他窗口 Shift+音量 会有声音，直接按音量默认是不出声 Command+I 显示简介（在 Finder 中），可以修改打开一个文件的默认 APP Command+Control+N 新建一个文件夹，并归类你选中的所有文件 编辑文本的快捷键Command+Space 切换输入法 Command+left 让光标跳到最前面，相当于 windows 下的 home 键 Command+right 让光标跳到最后，相当于 windows 下的 end 键 Command+up 让光标跳到整个文本的最开头 Command+down 让光标跳到整个文本的最后 Command+delete 删除当前行，相当于 windows 下的 home，shift+end（选中，从行头到行尾），backspace，这三个操作的组合。这个快捷键会让你相当爽的。 截图快捷键Command+Shift+3 截取整个桌面，并把截图作为一个文件存储在桌面上 Command+Shift+4 截取一个区域，并把截图作为一个文件存储在桌面上 Command+Shift+Ctrl+3 截取整个桌面，并复制到剪切板 Command+Shift+Ctrl+4 截取一个区域，并复制到剪切板 Command+Shift+4 然后按 Space 就会截取一个窗口。这样截图会自带阴影效果。如果不想自带阴影效果，可以按住 option 再点触摸板。 Command+Ctrl+A mac QQ 截图快捷键，由于屏幕分辨率太高，mac 系统快捷键截出来的图都太大了，而 macQQ 截出来的图大小正合适。 Chrome 浏览器快捷键这个应该是与操作系统无关的，但在 Mac 下养成了用快捷键的习惯，所以 Chrome 的快捷键都是在 Mac 上学的，在 windows 下注意用Ctrl替换Command键就行了。 Command+R 刷新 Command+L 将窗口焦点锁定到浏览器的地址栏，不用移动鼠标哦 Command+T 打开一个新 Tab Command+Shift+T 打开一个之前被关闭的 Tab Command+Shift+J 打开下载页面 Command+Shift+C 打开“检查(spectator)”，鼠标右键可以看到这个选项，一般是程序员使用的高级功能，但不能再次使用快捷键关闭。 Command+Shift+I 同样是打开 spectator，使用开发人员工具，但可以再次使用快捷键关闭。 Command+Shift+B 打开或关闭书签栏 Command+Option+B 打开书签管理器 Command+Y 打开历史记录 Command+Option+左右方向键 切换标签页 Command+D 收藏此页为书签 Command+Shift+D 将所有标签页加书签 Command+上下方向键 跳到页面顶部或底部 Command+Option+J 打开 javascript 控制台 按住 Command 后点击链接，在新 Tab（标签页）中打开这条链接。 Command+Shift 再点击链接，在新标签页中打开并切换到新标签页 Command+Shift+N 用隐身模式打开新窗口 Command+Shift+W 关闭当前窗口 Command+[ 或者 ] 前进或者回退 Command+左右方向键 前进或者后退 Command+Option+U 查看网页源代码 iTerm2 快捷键iTerm2 中的文本，选中即复制 Command+D 水平分隔出一个终端 Command+Shift+D 垂直分割出一个终端 可以配置透明度，Command+U 快速切换透明与否 可以配置全局唤出快捷键，我自己配置的是 Command+T 可以配置快捷悬浮，Hotkey window Command+Shift+H 查看复制历史 Command+Enter 快速切换全屏与否 CLI(命令行)快捷键本来这里应该放到 Linux 里面讲的，但 Mac 本身的特点就是 GUI 和 CLI 的完美结合（很多 Linux 的爱好者，有不想被 Linux 的桌面、各种驱动、不兼容等等杂七杂八的问题折腾的，大可选择 Mac）。 首先教一个最重要的东西记住按 Tab 补全，这是命令行用的爽的根源。 Ctrl+A 回到行首 Ctrl+E 到行末 Ctrl+U 删除一行 然后基本的 Linux 命令来了 cd / 到根目录 open / 用 Finder 打开根目录 格式转换有时候需要把 png 等格式的图片转成 jpg 的格式，于是有同学就去到处找格式转换软件了。其实在 Mac 中直接更改图片的扩展名，即可自动转成相应地格式~试试吧，如果你改格式前看了文件修改日期，改完格式后你会发现修改日期依然没变，这是我的一个好朋友告诉我的（他刚买了 mac），至于原因是什么，需要你有图片的文件格式的相关知识（这里挖个坑，以后再补上）。 Launchpad 与 DockLaunchpad 是指，你在触摸板上用五指向中间收拢，出现的全是 APP 的页面，半透明的。Dock 是指，最下方的摆满 APP 的一栏，在 Dock 上你可以放上最常用的 APP。 调整 launchpad 的图标大小： 12345defaults write com.apple.dock springboard-rows Defaultdefaults write com.apple.dock springboard-columns Defaultkillall Dock 在 appstore 下载一个软件到一半，然后在 Application 删除了该软件，结果在 launchpad 中留下了一个垃圾残留空图标。删除 launchpad 中的垃圾残留图标，只需拖拽到下载文件夹。其他方法都试过（无效），比如按住图标几秒，出现一个叉，点击叉，删除，没用。在 Application 找到相应项删除没用。 数学符号： 约等于: Option + X = ≈度数: Shift + Option + 8 = °除号: Option + / = ÷无穷: Option + 5 = ∞大于等于和小于等于: Option + , 和 Option + . = ≤ 和 ≥不等于: Option + = = ≠圆周率: Option + P = π加减: Shift + Option + = = ±开方: Option + V = √求和符号: Option + W = ∑快捷键：ctrl + a 移动至行首 ctrl + e 移动至行尾option + right 向右移动一个单词 option + left 向左移动一个单词，同时按住 shift 可以选定一个单词Fn + delete 可以删除后面一个字符Fn + Up 相当于 Page Up Fn + Down 相当于 Page DownCtrl + Command + F 全屏，并不支持所有程序，仅仅支持右上角右双箭头的程序 输入特殊符号：版权符号: Option + G = ©人民币符号: Option + Y = ¥ 双指双击，放大 在应用窗口顶栏双击，缩放窗口 工具篇好的工具可以使人事半功倍，回顾整个人类史，又何尝不是一个工具史呢，从用石器到用火，从铁器到火药，从蒸汽机到内燃机，从汽车到电脑，我们在使用工具、利用自然规律，从而让自身变得越来越强大。 工具列表国内的常用娱乐软件： Mac QQ，社交 网易云音乐 新浪微博 百度云 迅雷 leanote（蚂蚁笔记） 有道词典 优酷客户端 爱奇艺客户端 阿里旺旺 每日英语听力 爱壁纸 HD xx-net 国外产的： Chrome Atom calibre LICEcap Pocket iStat Menus TeamViewer Blu-ray Player Irvue Sip VMware Fusion The unarchiver Keka OmniDiskSweeper Bartender 2 程序员使用的： Xcode iTerm2 oh-my-zsh dash FileZilla github desktop Pycharm Intellj IDEA Android Studio]]></content>
      <categories>
        <category>工具</category>
      </categories>
  </entry>
</search>
