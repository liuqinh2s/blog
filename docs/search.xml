<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[智能合约入门]]></title>
    <url>%2Fblog%2F2021%2F06%2F28%2F%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[前言从2017年开始买比特币的时候，我就想学习智能合约相关的开发，也曾想过要投身区块链行业，这一拖就是4年。我认真开始学起智能合约，最主要的原因其实是因为我离它更近了。这一轮牛市，DEFI火爆，让我学会了使用钱包和公链。而在去年，我还是个只会在OTC入金的傻子，库币的OTC定价那么不合理都只会用OTC入金，后来我才发现原来USDT可以随意在链上转，而且波场免手续费，由此打开了新世界的大门。 资料 Solidity语言 Solidity文档 Remix Remix的使用 Remix使用教程 发币 人生中第一段智能合约代码 12345678pragma solidity ^0.4.0;contract addressTest&#123; function getBalance(address addr) public view returns (uint)&#123; return addr.balance; &#125;&#125;]]></content>
      <categories>
        <category>区块链</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode每日一题：474. 一和零]]></title>
    <url>%2Fblog%2F2021%2F06%2F06%2Fleetcode-470-%E4%B8%80%E5%92%8C%E9%9B%B6%2F</url>
    <content type="text"><![CDATA[474. 一和零一道动态规划题目。 首先要明白这是一道背包问题，而且是双维度的，可以装0和1。 那么我们就需要一个三维数组dp来记录动态规划的子过程的结果，第一个维度代表遍历到第i个字符串，第二个维度代表第j个0的问题规模，第三个维度代表第k个1的问题规模，依次扩展到我们的目标字符串个数，目标问题规模。 状态转移方程： 如果加入当前字符串，导致背包溢出，则不加：dp[i][j][k] = dp[i-1][j][k] 如果不溢出，则有两种可能，取最优解：dp[i][j][k] = Math.max(dp[i-1][j][k], dp[i-1][j-zeros][k-ones]+1) 这里还需要考虑一些边界问题，比如i=0的时候，dp[0][any][any]应该是0，同理m=0和n=0也是如此。所以我们的数组空间需要每个维度上都加1来存放这些初始值。 JavaScript代码： 1234567891011121314151617181920212223242526272829/** * @param &#123;string[]&#125; strs * @param &#123;number&#125; m * @param &#123;number&#125; n * @return &#123;number&#125; */var findMaxForm = function(strs, m, n) &#123; let dp = new Array(strs.length+1).fill(0).map(()=&gt;new Array(m+1).fill(0).map(()=&gt;new Array(n+1).fill(0))) for(let i=1;i&lt;=strs.length;i++)&#123; let [zeros, ones] = getZeros(strs[i-1]) for(let j=0;j&lt;=m;j++)&#123; for(let k=0;k&lt;=n;k++)&#123; dp[i][j][k] = dp[i-1][j][k] if(j&gt;=zeros &amp;&amp; k&gt;=ones)&#123; dp[i][j][k] = Math.max(dp[i-1][j][k], dp[i-1][j-zeros][k-ones]+1) &#125; &#125; &#125; &#125; return dp[strs.length][m][n]&#125;;function getZeros(str)&#123; let zeros = [0, 0] for(let i=0;i&lt;str.length;i++)&#123; zeros[str[i]-'0']++; &#125; return zeros&#125;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode每日一题：203. 移除链表元素]]></title>
    <url>%2Fblog%2F2021%2F06%2F05%2Fleetcode-230-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[203. 移除链表元素很简单的一道删除单链表节点题 JavaScript代码： 12345678910111213141516171819202122232425/** * Definition for singly-linked list. * function ListNode(val, next) &#123; * this.val = (val===undefined ? 0 : val) * this.next = (next===undefined ? null : next) * &#125; *//** * @param &#123;ListNode&#125; head * @param &#123;number&#125; val * @return &#123;ListNode&#125; */var removeElements = function(head, val) &#123; let h = new ListNode(0, head); index = h; while(index.next)&#123; if(index.next.val == val)&#123; let next = index.next.next; index.next = next; continue; &#125; index = index.next; &#125; return h.next;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode每日一题：160. 相交链表]]></title>
    <url>%2Fblog%2F2021%2F06%2F04%2Fleetcode-160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[160. 相交链表这题有两种解法： 哈希表记录指针 双指针 哈希表记录指针JavaScript代码： 123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; headA * @param &#123;ListNode&#125; headB * @return &#123;ListNode&#125; */var getIntersectionNode = function(headA, headB) &#123; let hashset = new Set([]); let index = headA while(index)&#123; hashset.add(index) index = index.next &#125; index = headB while(index)&#123; if(hashset.has(index))&#123; return index; &#125;else&#123; index = index.next; &#125; &#125; return null;&#125;; 双指针链表总共分为三部分： headA到公共节点 headB到公共节点 公共部分 所以如果我们利用双指针，把这三个部分走一遍，就能让双指针碰上。 index1走A链，走完A链，走B链 index2走B链，走完B链，走A链 两个指针同时等于null只有一种情况，就是两个链不相交。如果相交，想要都在链尾碰上，则两个链长度相等，若两个链长度相等且相交，则非公共部分长度一定相等，那么他们早就在第一次遍历的时候在公共节点遇上了。 12345678910111213141516171819202122/** * Definition for singly-linked list. * function ListNode(val) &#123; * this.val = val; * this.next = null; * &#125; *//** * @param &#123;ListNode&#125; headA * @param &#123;ListNode&#125; headB * @return &#123;ListNode&#125; */var getIntersectionNode = function(headA, headB) &#123; let index1 = headA; let index2 = headB; while(index1!==index2)&#123; index1 = index1==null?headB:index1.next; index2 = index2==null?headA:index2.next; &#125; return index1;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode每日一题：525. 连续数组]]></title>
    <url>%2Fblog%2F2021%2F06%2F03%2Fleetcode-525-%E8%BF%9E%E7%BB%AD%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[凡是涉及到连续子数组的，都可以用前缀和+哈希表来解 525. 连续数组这题要注意的就是，因为要统计元素个数，所以要使用i+1。 哈希表的key的含义是：当前遍历到的1与符合标准（一半是1）之间的差距，而记录的位置则必须是最小位置。所以只在初始化的时候赋值。 JavaScript代码： 123456789101112131415161718192021222324/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var findMaxLength = function(nums) &#123; let sum = 0; let hashmap = &#123;&#125; let max = 0; for(let i=0;i&lt;nums.length;i++)&#123; sum += nums[i]; if(i+1==sum*2)&#123; max = i+1; continue; &#125; if(hashmap.hasOwnProperty(i+1-sum*2))&#123; if(max&lt;(i-hashmap[i+1-sum*2]))&#123; max = (i-hashmap[i+1-sum*2]) &#125; &#125;else&#123; hashmap[i+1-sum*2] = i; &#125; &#125; return max;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode每日一题： 342. 4的幂]]></title>
    <url>%2Fblog%2F2021%2F05%2F31%2Fleetcode-342-4%E7%9A%84%E5%B9%82%2F</url>
    <content type="text"><![CDATA[这个问题看起来是个简单题，其实可以从中学到位运算和一些数学知识。 342. 4的幂我自己的解法很简单易懂，但是不够高效： JavaScript代码： 1234567891011121314/** * @param &#123;number&#125; n * @return &#123;boolean&#125; */var isPowerOfFour = function(n) &#123; let i = 1; while(i&lt;n)&#123; i = i*4; &#125; if(i==n)&#123; return true; &#125; return false;&#125;; 这个解法的效率很差，只战胜了55%的选手。说明肯定有更优解，我翻了一下答案。主要是2种角度的解法： 位运算 数学 位运算如果是2的幂，那么位中只能出现一个1。如果是4的，那么肯定也只有一个1，且出现的位置是每隔一位出现。那么问题来了，怎么判断位上只有一个1呢？操作是：减去1，然后与。得到的结果必然应该是0。那如何判断1在哪一位上呢？好像只能遍历了。但其实我们不需要知道具体是哪一位，只需要知道是否分布在正确的位上，可以通过mask解决：mask=$(01010101010101010101010101010101)_2$，因为1分布在奇数位。也可以写成更简短的16进制形式：mask=$(55555555)_16$ JavaScript代码： 1234567/** * @param &#123;number&#125; n * @return &#123;boolean&#125; */var isPowerOfFour = function(n) &#123; return n&gt;0 &amp;&amp; (n &amp; (n-1)) == 0 &amp;&amp; (n &amp; 0x55555555)&#125;; 奇怪的是这个代码的运行时间居然比上面那个还长，感觉不科学。 数学角度首先依然是按照上面的两个条件： n&gt;0 n只有一个0 我们观察到所有偶数分为：$4^x \times 2 \times 2$也就是$4^x$，和$4^x \times 2 \times 1$。而4的幂次除以3的余数必然是1，而$4^x \times 2$这种除以3的余数必然是2。 我们增加这个条件筛选出$4^x$ JavaScript代码： 1234567/** * @param &#123;number&#125; n * @return &#123;boolean&#125; */var isPowerOfFour = function(n) &#123; return n&gt;0 &amp;&amp; (n &amp; (n-1)) == 0 &amp;&amp; (n % 3)==1&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode： 1074. 元素和为目标值的子矩阵数量]]></title>
    <url>%2Fblog%2F2021%2F05%2F29%2Fleetcode-1074-%E5%85%83%E7%B4%A0%E5%92%8C%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E5%AD%90%E7%9F%A9%E9%98%B5%E6%95%B0%E9%87%8F%2F</url>
    <content type="text"><![CDATA[这个问题需要拆分出子问题才好解决，要不然没有思路。它的子问题是：560. 和为K的子数组 1074. 元素和为目标值的子矩阵数量当你理解了子问题之后，我们来想想，怎么把这个问题转换到子问题上呢？也就是如何把二维问题变一维问题呢？ 我们想象把一个矩阵的列上的元素全部加起来，不就是一个一维数组了吗。这个一维数组可以等效的应用在这个问题上。 那这样的组合有哪些呢？通过简单的二次遍历，就能得出我们想要的组合： JavaScript代码： 12345for(let i=0;i&lt;n;i++)&#123; for(let j=i;j&lt;n;j++)&#123; &#125;&#125; 每次i到j之间的数就是我们想要的组合，拿这些数的和，组成新的一维数组，然后用一维数组的解法去解。这里有个小技巧是这个和也要避免重复计算，所以要把每次计算所得存下来，下次在这个基础上算，这样可以省下从头开始求和的时间。 JavaScript代码： 123456789101112131415161718192021222324252627282930313233343536/** * @param &#123;number[][]&#125; matrix * @param &#123;number&#125; target * @return &#123;number&#125; */var numSubmatrixSumTarget = function(matrix, target) &#123; let count = 0; for(let i=0;i&lt;matrix.length;i++)&#123; let sum = new Array(matrix[0].length).fill(0) for(let j=i;j&lt;matrix.length;j++)&#123; for(let k=0;k&lt;matrix[0].length;k++)&#123; sum[k] += matrix[j][k] &#125; count += subarraySum(sum, target) &#125; &#125; return count;&#125;;var subarraySum = function(nums, k) &#123; let pre = 0; let preRecord = &#123;0: 1&#125; let count=0; for(let i=0;i&lt;nums.length;i++)&#123; pre += nums[i]; if(preRecord[pre-k])&#123; count += preRecord[pre-k] &#125; if(preRecord[pre])&#123; preRecord[pre]++; &#125;else&#123; preRecord[pre]=1; &#125; &#125; return count;&#125;; 简化问题的办法有很多，比如降低问题规模，降低维度，二维 -&gt; 一维。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode： 560. 和为K的子数组]]></title>
    <url>%2Fblog%2F2021%2F05%2F29%2Fleetcode-560-%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[这题是在做每日一题中遇到的问题的子问题：1074. 元素和为目标值的子矩阵数量 560. 和为K的子数组遇到这类问题，首先想的是复杂度，然后复杂度天然是跟问题规模有关的。遍历一遍肯定是必要的，当我们遍历到第n这个位置，我们怎么判断从0到n中有多少个解，进一步的，我们还只要增量数据，n-1的解不应该去重复计算。第n这个位置上的数是一定要考虑进去的，所以我们从后往前寻找。具体代码如下： JavaScript代码： 1234567891011121314151617/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var subarraySum = function(nums, k) &#123; let count = 0; for (let start = 0; start &lt; nums.length; ++start) &#123; let sum = 0; for (let end = start; end &gt;= 0; --end) &#123; sum += nums[end]; if (sum == k) &#123; count++; &#125; &#125; &#125; return count;&#125;; 这样的话，算法的时间复杂度是O(n^2)。有没有重复计算的问题呢，似乎不太好说，但结果是：有，像此类问题有统一的规律，就是我们可以记录前缀和。如果我们知道前缀和，那么我们只需要用当前和减去k，看是否等于某个前缀和，如果有，我们不就正好找到一个子数组的和等于k了吗？所以基于前缀和，我们一次遍历即可解决问题。 JavaScript代码： 12345678910111213141516171819202122/** * @param &#123;number[]&#125; nums * @param &#123;number&#125; k * @return &#123;number&#125; */var subarraySum = function(nums, k) &#123; let pre = 0; let preRecord = &#123;0: 1&#125; let count=0; for(let i=0;i&lt;nums.length;i++)&#123; pre += nums[i]; if(preRecord[pre-k])&#123; count += preRecord[pre-k] &#125; if(preRecord[pre])&#123; preRecord[pre]++; &#125;else&#123; preRecord[pre]=1; &#125; &#125; return count;&#125;; 前缀和对过往的遍历总结提取了信息，使我们不用再去进行重复的计算，是非常重要的技巧。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode每日一题： 477. 汉明距离总和]]></title>
    <url>%2Fblog%2F2021%2F05%2F28%2Fleetcode-477-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB%E6%80%BB%E5%92%8C%2F</url>
    <content type="text"><![CDATA[leetcode每日一题是leetcode中文版官方推出的活动，每日一题锻炼解决问题的思维能力。 477. 汉明距离总和这题初看上去特别简单，就是一个O(n^2)的遍历（组合），对每一组求汉明距离累加起来。不过我一开始就觉得可能会超时，提交后果然超时了。更优的做法是按位遍历，每一位上所有的数要么是0要么是1，把0和1的个数统计出来，相乘，就是这一位的汉明距离总和。 JavaScript代码： 123456789101112131415161718192021222324252627/** * @param &#123;number[]&#125; nums * @return &#123;number&#125; */var totalHammingDistance = function(nums) &#123; let max = Math.max(...nums) let count=0; while(max&gt;0)&#123; count++; max&gt;&gt;=1; &#125; let res = 0; for(let i=0;i&lt;count;i++)&#123; let zero = 0; let one = 0; for(let j=0;j&lt;nums.length;j++)&#123; let temp = nums[j]&gt;&gt;i; if(temp%2)&#123; one++; &#125;else&#123; zero++; &#125; &#125; res += zero*one; &#125; return res;&#125;;]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[position sticky]]></title>
    <url>%2Fblog%2F2021%2F05%2F28%2Fposition-sticky%2F</url>
    <content type="text"><![CDATA[在做公司项目的过程中遇到一个问题：让表头固定，同时其宽度必须占满整个父元素。用fixed，可以固定但是宽度无法撑开。最终用position: sticky解决了问题。 参考资料： 杀了个回马枪，还是说说position:sticky吧« 张鑫旭-鑫空间-鑫生活 position - CSS（层叠样式表） | MDN position: sticky 的作用这个坑先放着，等深入研究了再来填，放上codepen试验现场：https://codepen.io/liuqinh2s/pen/oNZWbeX]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[leetcode每日一题： 1190. 反转每对括号间的子串]]></title>
    <url>%2Fblog%2F2021%2F05%2F27%2Fleetcode-1190-%E5%8F%8D%E8%BD%AC%E6%AF%8F%E5%AF%B9%E6%8B%AC%E5%8F%B7%E9%97%B4%E7%9A%84%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[写之前：2020年整整一年没有写过博客了，沉痛的一年。写博客还是继续下去吧，不管怎样。 1190. 反转每对括号间的子串这道题一看就知道用栈来解决，但具体到怎么做却依旧不容易想通。直到看过答案后，才发现，实际上真的只需要遍历一遍就能解决问题。 思路如下： 每遇到一个括号块，就需要把里面的字符串翻转（这是单步操作），然后递归翻转每一层。这是我们人的思维，但机器是看不到这种宏观信息的，我们需要安排具体到每一步的任务。代码在遍历的时候只会遇到左括号或者右括号，假如我们遇到左括号的时候开始记录字符串，那么在遇到右括号的时候，就有翻转的目标对象了。但如果连续遇到两个左括号呢？我们将记录的信息先入栈，然后继续上面的步骤即可。 具体步骤（单步）： 遇到左括号：入栈已记录的字符串，清空我们用于记录的变量 遇到普通字符：记录 遇到右括号：翻转记录的字符串，将栈顶字符串pop出来拼接上翻转好的字符串 JavaScript代码： 12345678910111213141516171819/** * @param &#123;string&#125; s * @return &#123;string&#125; */var reverseParentheses = function(s) &#123; let stack = [] let str = '' for(let i=0;i&lt;s.length;i++)&#123; if(s[i]=='(')&#123; stack.push(str) str = '' &#125;else if(s[i]==')')&#123; str = stack.pop() + Array.from(str).reverse().join('') &#125;else&#123; str += s[i] &#125; &#125; return str;&#125;; 后记：这是新年的第一篇博客，以后会做更多的记录，不管有没有人看。]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[图灵机]]></title>
    <url>%2Fblog%2F2019%2F04%2F26%2F%E5%9B%BE%E7%81%B5%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[图灵机图灵机（Turing Machine）是 英国数学家艾伦·图灵 在1936年发表的 &quot;On Computable Numbers, with an Application to the Entscheidungsproblem&quot;（《论可计算数及其在判定性问题上的应用》）中提出的数学模型。在文章中图灵描述了它是什么，并且证明了，只要图灵机可以被实现，就可以用来解决任何可计算问题。 历史 妈咪说：图灵 模仿游戏 图灵机的基本思想图灵机是一种 抽象计算模型，图灵机的构成： 一条无限长的纸带，纸带由很多个格子构成，用于输入输出信息。每个格子中包含一个来自有限字母表的符号，字母表中有一个特殊符号表示空白。纸带上一端的格子从0开始编号，另一端无限延伸一直到无穷大。 一个读写头，用于读写纸带 一个状态寄存器，用于保存机器状态。图灵机的状态个数有限，并且有一个特殊的状态：停机状态 一套控制规则，根据当前机器状态和纸带内容来确定下一步的动作： 写入或擦除当前格子内容 移动读写头，向左、向右、或不动 保持当前状态或转移到另一状态 图灵机的正式定义a (one-tape) Turing machine can be formally defined as a 7-tuple $M=\langle Q,\Gamma ,b,\Sigma ,\delta ,q_{0},F\rangle $ where $Q$ is a finite, non-empty set of states; $\Gamma$ is a finite, non-empty set of tape alphabet symbols; $b\in \Gamma$ is the blank symbol (the only symbol allowed to occur on the tape infinitely often at any step during the computation); $\Sigma \subseteq \Gamma \setminus {b}$ is the set of input symbols, that is, the set of symbols allowed to appear in the initial tape contents; $q_{0}\in Q$ is the initial state; $F\subseteq Q$ is the set of final states or accepting states. The initial tape contents is said to be accepted by $M$ if it eventually halts in a state from $F$. $\delta :(Q\setminus F)\times \Gamma \not \to Q\times \Gamma \times \{L,R\}$ is a partial function called the transition function, where L is left shift, R is right shift. (A relatively uncommon variant allows &quot;no shift&quot;, say N, as a third element of the latter set.) If $\delta$ is not defined on the current state and the current tape symbol, then the machine halts; 图灵机的实践 Brainfuck 图灵完备只要能模拟单带图灵机，就是图灵完备的。这也意味着其计算能力与通用图灵机等同。 不是图灵完备的的常见情况有； 递归或循环有限，无法写不终止的程序，如while(true){} 无法实现类似数组或列表这样的数据结构（不能模拟纸带） 图灵完备也有可能带来坏处，不图灵完备也不是完全没用，比如：有些场景我们需要限制语言的表达能力，如 限制无限循环和递归，保证我们的程序一定是可终止的。 停机问题停机问题（英语：halting problem）是逻辑数学中可计算性理论的一个问题。通俗地说，停机问题就是判断任意一个程序是否能在有限的时间之内结束运行的问题。该问题等价于如下的判定问题：是否存在一个程序P，对于任意输入的程序w，能够判断w会在有限时间内 结束或者死循环。 艾伦·图灵在1936年用 对角论证法 证明了，不存在解决停机问题的通用算法。 停机问题包含了 自我指涉，本质是 一阶逻辑 的不完备性，类似的命题有 理发师悖论、全能悖论 等。 证明很简单，构造G=~G命题（G等于G非），让逻辑崩溃，无论G是真还是假，都是错的，最后推导出：不存在这样的G。 停机问题证明过程（反证法）： 如果存在可以判定任意程序是否停机的程序，我们姑且称它为 上帝程序 那我们定义这样一个程序，它利用上帝程序判断自己是否停机，但如果上帝程序输出停机，它就不停；如果上帝程序输出不停机，它就停机（就是反着干）。这样一来无论上帝程序输出什么，上帝程序都是错的。那么我们只能说不存在这样的上帝程序。 123456789101112def is_halt(program, input): if program halts on input: return true else: return falsedef fuck_is_halt(): if is_halt(fuck_is_halt): while (1): pass else: pass Matrix67：停机问题、Chaitin常数与万能证明方法 刘未鹏：康托尔、哥德尔、图灵——永恒的金色对角线(rev#2) 自我指涉 在数学中，对自指的研究最终导致了著名的 哥德尔不完备定理。 计算机程序中的自指主要是为 递归 德罗斯特效应： 我们经常可以在主播间看到类似的画面： 也可以用两面镜子自己做这个实验。 妈咪说：哥德尔]]></content>
      <categories>
        <category>Knowledge of CS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[冯·诺依曼结构]]></title>
    <url>%2Fblog%2F2019%2F04%2F22%2F%E5%86%AF%C2%B7%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[冯·诺依曼结构冯·诺伊曼结构与 存储程序型计算机 是互相通用的名词 哈佛结构 是一种将程序数据与普通数据分开存储的设计概念，可以说是冯·诺依曼结构的一种。 存储程序计算机在体系结构上主要特点有： 以运算单元为中心 采用存储程序原理 存储器是按地址访问、线性编址的空间 控制流由指令流产生 指令由 操作码 和 地址码 组成 数据以二进制编码 五个组成部分： 存储器 控制器 运算器（算术逻辑单元） 输入 输出 历史 文明之光：电子计算机的发明－从图灵到冯诺依曼（上） 文明之光：冯诺依曼系统结构和电子计算机的发明（下） 妈咪说：过目不忘的天才——冯诺依曼的传奇人生 他为何被称作通用计算机之父？ 冯·诺依曼 冯·诺依曼由于在曼哈顿工程中需要大量的运算，从而使用了当时最先进的两台计算机 Mark I 和 ENIAC，在使用 Mark I 和 ENIAC 的过程中，他意识到了存储程序的重要性，从而提出了存储程序逻辑架构。 最早的计算机内含固定用途的程序，并非可编程，若想要改变此机器的程序，你必须更改线路、更改结构甚至重新设计机器。而存储程序型计算机的概念改变了这一切。借着将指令当成一种特别类型的静态数据，一台存储程序型计算机可轻易改变其程序，并在程序控制下改变其运算内容。 优势冯·诺依曼架构第一次 将存储器和运算器分开，指令和数据均放置于存储器中，为计算机的 通用性 奠定了基础。虽然在规范中计算单元依然是核心，但冯·诺依曼架构事实上导致了 以存储器为核心 的现代计算机的诞生。 注：请各位在心里明确一件事情：存储器指的是内存，即 RAM。磁盘理论上属于输入输出设备。 缺陷 程序可修改很可能是非常具伤害性的：在一个简单的存储程序型计算机上，一个设计不良的程序可能会伤害自己、其他程序甚或是操作系统，导致死机、缓存溢出就是一个典型例子。而创造或更改其他程序的能力也导致了恶意软件的出现。利用缓存溢出，一个恶意程序可以覆盖调用堆栈（Call stack）并改写代码，并且修改其他程序文件以造成连锁破坏。存储器保护机制及其他形式的访问控制可以保护意外或恶意的代码更动。 冯·诺伊曼瓶颈（von Neumann bottleneck）：在内存容量指数级提升以后，CPU 和内存之间的数据传输带宽成为了瓶颈。缓解的办法有： 在CPU和内存之间提供cache（缓存，速度比内存快很多倍） 将数据和指令分开存储并能够做到同时访问（在一般的冯·诺依曼结构中数据和指令放在同一内存通过同一数据总线访问，取数据和取指令不能同时进行，而哈佛结构则是将数据和指令分开，可同时访问） 分支预测和流水线 实际上，绝大多数现代计算机使用的是所谓的“Modified Harvard Architecture”，指令和数据共享同一个 address space，但缓存是分开的。在内存里，指令和数据是在一起的。而在CPU内的缓存中，还是会区分指令缓存和数据缓存，最终执行的时候，指令和数据是从两个不同的地方出来的。你可以理解为在CPU外部，采用的是冯诺依曼模型，而在CPU内部用的是哈佛结构。 大部分的DSP都没有缓存，因而直接就是哈佛结构。 上图是 i9-7980XE 18 核 36 线程的民用最强 CPU，其配合超频过的 DDR4 3200MHz 的内存，测试出的内存读取速度为 90GB/S。看起来很快了是不是？看看图中的 L1 Cache，3.7TB/S。 我们再来算算时间。这颗 CPU 最大睿频 4.4GHz，就是说 CPU 执行一个指令需要的时间是 0.000000000227273 秒，即 0.22ns（纳秒），而内存的延迟是 68.1ns。换句话说，只要去内存里取一个字节，就需要 CPU 等待 300 个周期，何其的浪费 CPU 的时间啊。 CPU L1 L2 L3 三级缓存是使用和 CPU 同样的 14 纳米工艺制造的硅半导体，每一个 bit 都使用六个场效应管（通俗解释成三极管）构成，成本高昂且非常占用 CPU 核心面积，故不能做成很大容量。 除此之外，L1 L2 L3 三级缓存对计算机速度的提升来源于计算机内存的「局部性」，相关内容我们之后会专门讨论。 RAM（Random Access Memory，俗称 内存）：内存最大的特点是：掉电失去数据。程序是静态的文件存放在外存中，进程正在运行的程序，进程存放在内存中。我们之所以使用内存是因为内存的速度比外存快100倍左右。 ROM（Read-Only Memory，只读存储器）：ROM掉电不失去数据。]]></content>
      <categories>
        <category>Knowledge of CS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[什么是字符集和编码]]></title>
    <url>%2Fblog%2F2019%2F04%2F21%2F%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[文本文件中，为了让比特表示文字，我们发明了字符集，让特定的比特序列对应特定的字符。 常见的字符集有： ASCII EASCII GB2312 GBK Unicode UTF-8 （严格来说UTF-8只是Unicode的一种编码方式） ANSI编码 ASCII计算机诞生于美国，因此最早的时候，人们只需要表示英文26个字符在内的少数字符，用半个字节就可以表示完这些字符。这就是ASCII字符集，最高位为0，其余7位可以表示的范围是：0~127。总共128个字符。 ASCII字符分为：控制字符（不可显示） 和 可显示字符 其中，0x20以下为控制字符，不可显示。比如，0x10表示换行，0x07表示发声。另外还有个特殊的控制字符：0x7f表示删除，所以总共是33个控制字符，95个可显示字符。 EASCII欧洲国家使用计算机之后，也有了创建字符集的需求，于是对ASCII进行扩展，使用了剩下一半字节的空间，0x80 - 0xff的定义就被填充成了希腊字母，罗马字母等符号。 此时，编码依旧控制在8位以内，相安无事。 GB2312 GB是国标的意思 中国开始使用计算机，于是有了这个字符集，由于中文是象形文字，如果每个字符一个键的话，肯定放不下： 但我们有拼音，所以直接用美国键盘就行了。 GB2312共收录了6763个汉字，其中一级汉字3755个，二级汉字3008个。它所收录的汉字已经覆盖中国大陆99.75%的使用频率。 GB2312的基本思想很简单，如果一个字符值为127及以下，那它就是一个单字节字符，和ASCII兼容；如果一个字符值为127以上，那它和后面的那个字符组成一个汉字。（同时，后面那个字符也一定是127以上的） 通过这个方式，我们扩展出来了7000+的简体汉字，同时还把日本假名，罗马希腊字母，数学符号也容纳了进来。 同时还产生了一个新的概念，全角字符：ASCII码里本身有的字符，也被我们扩展成了双字节字符。为了区分，前者称为半角字符，后者称为全角字符。比如逗号、冒号、引号等等都有半角和全角之分。 至此，中文也可以在计算机上表示了。 GBK K是扩展的意思 7000个简体汉字并不能把汉字穷举了，一些生僻字并不包含在GB2312里。 GB2312表示，我可能还可以抢救一下，我还有另一半的潜力没有发挥呢！ 这另一半的潜力就是，第二个字节的0x00 - 0x7f部分。这部分空出来，是由于GB2312表示汉字时，要求两个字节都是在0x80 - 0xff范围内的。 填上这部分的空档之后，再生僻的字也被表示出来了，同时，我们还考虑到港澳台同胞的感受，包含了繁体字，一共大概增加了20k的汉字和符号。 Unicode随着时间的推移，互联网的兴起，不止海峡两岸，全世界范围内共建一个字符集的呼声越来越高。 Unicode，统一了所有地区的字符，且还在不断扩充中。Unicode编码系统可分为 编码方式 和 实现方式 两个层次。Unicode的实现方式称为Unicode转换格式（Unicode Transformation Format，简称为UTF） UTF-8兼容ASCII，UTF-16不兼容ASCII。 UTF-8前面说的都是字符集，UTF-8却是一种编码方式，因为它并不是去做字符集的事情，而是为的便于Unicode码的传输和存储而生的。UTF-8兼容ASCII编码，所以应用非常广泛，几乎已经是互联网标准。 与其他的编码方式（如哈夫曼编码）的思想一致，UTF-8的原则就是，使用不定长字节（1-6字节）来表达一个字符，使用频率越高的字符，字节数越少。这样就能最大程度上节约空间。具体的编码方式如下： 12345单字节字符： 以0开头，后面7位表示字符，事实上，UTF-8的单字节字符就是ASCII字符，完美兼容；n字节字符： 第一个字节的前n位为1，第n+1位为0。读到此字节时，可以方便的知道后续多少字节是用来表示一个字符； 其余字节，以10开头。 1234567Unicode符号范围 | UTF-8编码方式(十六进制) | （二进制） —————————————————————– 0000 0000-0000 007F | 0xxxxxxx 0000 0080-0000 07FF | 110xxxxx 10xxxxxx 0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx 0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 实际上从第二行对照开始，就存在空间浪费，因为右边的x的位数足够用来表示0到左边的第二个数所表示范围内的所有数，每行浪费的空间大小是左边的第一个数。 UTF-8和Unicode是一一对应的，对于常用汉字，基本上都是占用3个字节，生僻汉字可能占用到6个字节。对于GB2312和GBK来讲，UTF-8无疑造成了浪费，所以，UTF-8可以说是对英文友好，但对中文不友好的一种编码方式。所以在中文界，GB2312与GBK依旧有自己的市场。 ANSI编码ANSI 并不是确定的一种编码，在简体中文操作系统指的是 GB2312，在繁体操作系统指的是 BIG5。 Windows 里说的「ANSI」其实是 Windows code pages，这个模式根据当前 locale 选定具体的编码，比如简中 locale 下是 GBK。把自己这些 code page 称作「ANSI」是 Windows 的臭毛病。在 ASCII 范围内它们应该是和 ASCII 一致的。 字符集（character set）与编码（encoding）的区别对于 ASCII、GB 2312、Big5、GBK、GB 18030 之类的遗留方案来说，基本上一个字符集方案只使用一种编码方案。 比如 ASCII 这部标准本身就直接规定了字符和字符编码的方式，所以既是字符集又是编码方案；而 GB 2312 只是一个区位码形式的字符集标准，不过实际上基本都用 EUC-CN 来编码，所以提及「GB 2312」时也说的是一个字符集和编码连锁的方案；GBK 和 GB 18030 等向后兼容于 GB 2312 的方案也类似。 于是，很多人受这些遗留方案的影响而无法理解字符集和编码的关系。 对于 Unicode，字符集和编码是明确区分的。Unicode/UCS 标准首先是个统一的字符集标准。而 Unicode/UCS 标准同时也定义了几种可选的编码方案，在标准文档中称作「encoding form」，主要包括 UTF-8、UTF-16 和 UTF-32。 所以，对 Unicode 方案来说，同样的基于 Unicode 字符集的文本可以用多种编码来存储、传输。所以，用「Unicode」来称呼一个编码方案不合适，并且误导。 字节顺序标记（BOM）这里涉及到一个 字节序 的概念，请先了解这个概念。 BOM（Byte-Order Mark）:一种为了跨平台设计的文件起始标记，但很多程序没去处理这个，用了BOM反而常造成问题。 在UTF-16中，字节顺序标记被放置为文件或字符串流的第一个字符，以标示字节顺序。 大端：0xFEFF 小端：0xFFFE]]></content>
      <categories>
        <category>Knowledge of CS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[计算机中的信息]]></title>
    <url>%2Fblog%2F2019%2F04%2F20%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF%2F</url>
    <content type="text"><![CDATA[信息的本质信息的本质是消除不确定性：我们抛掷一枚硬币，然后用手盖住，出现正面朝上和反面朝上的概率都是二分之一。当我们偷看了结果，确定了是正面还是反面朝上，也就获得了信息。在这个例子中，我们消除的不确定性是一个二分之一的概率。在 香农 划时代的论文 通信的数学原理 中，首次提出了信息是可量化的，以及如何量化信息。我们以bit为信息的度量单位，一个bit可以是0或者1，我们每获得一个bit的信息，就会消除一个二分之一的不确定性。 小思考题：如果我们抛掷的是一个骰子呢，当我们确定了一次投掷结果，我们获得多少信息（用bit为单位衡量）？我们都知道，骰子有6个面，分别刻有1~6，我们有六分之一的概率得到其中任意一个面朝上。那么我们获得的信息应该是：$\log_2 6$。 信息计量单位比特（bit）：我们现在所使用的计算机都是二进制的电子计算机，每个bit非0即1。之所以使用二进制是因为物理上容易实现，高电压或低电压。 字节（byte）：在计算机中为了方便的管理内存，我们以8个比特为一个单位，这个单位叫做字节。 在你购买宽带的时候，比如100M宽带，指的是100Mb/s，换算成字节为单位的速度：$\frac{100Mb/s}{8}=12.5MB/s$。所以我们发现下载速度通常没有听起来那么夸张，因为下载的文件通常是以字节为单位的，而运营商口中的100M指的是以比特为单位的速度。 K、M、G：这三个是最常见的倍数单位，可以用来搭配b（bit）或者B（Byte）。它们都是词根的缩写，K是Kilo，表示$2^{10}$ ；M是Mega，表示$2^{20}$ ；G是Giga，表示$2^{30}$ 。 其实在一般的场合中，K表示$10^3$，M表示$10^6$，G表示$10^9$。而我们看到上面都是以1024倍递增（$2^{10}=1024$），是1000的近似。在你购买硬盘的时候，厂商却是使用1000这一套进率的。比如100GB的硬盘，其实际容量只有：$\frac{100\times1000^3}{1024^3}=93.13GB$。而内存则是用1024进率算的，1GB的内存就是$2^{30}$个字节，因为采用地址总线寻址，寻址空间必须是$2^n$，否则就会造成内存浪费或者定位到一个不存在的内存。 T、P：这两个如果你是程序员的话会比较常见。T是Tera，$2^{40}$；P是Peta，$2^{50}$。 往上走还有几个单位，但几乎没机会碰到：1EB（Exabyte 百亿亿字节 艾字节）=1024PB，1ZB (Zettabyte 十万亿亿字节 泽字节)= 1024 EB,1YB (Yottabyte 一亿亿亿字节 尧字节)= 1024 ZB,1BB (Brontobyte 一千亿亿亿字节)= 1024 YB. 字符集信息是bit位+上下文（这里的信息可以理解为：人能读懂的有意义的信息），比特位中的信息可以根据上下文被任意地解读。举个例子，这里有一个hello.c文件，文件内容如下： 123456#include &lt;stdio.h&gt;int main()&#123; printf("hello, world\n");&#125; 如果以 ASCII编码 的话，每个字节的内容如下： 文本文件：内容是文本，文本文件都会采用一种特定的编码方式 二进制文件：除去文本文件，其他的都是二进制文件 如果你碰到过乱码问题，那么可以尝试了解一下：什么是字符集和编码 Windows记事本的bug（具体原因可以自己上网查）： 新建一个文本文件，输入“写”，保存之后再打开，乱码д。 新建一个文本文件，输入“联通”，保存之后再打开，乱码��ͨ。 字节序计算机的内存地址是按字节编号，比如4GB的内存，它的内存地址从0到$2^{30}$，这里有个问题就是多字节的数据如何确定存放顺序。有的计算机采用 大端 有的则采用 小端。 假设我有一个int型数（4字节）：0x29 16 10 57 29是高位，57是低位，如果高位存放的内存地址也是高地址，那么我们就称之为 大端 字节序。反之就是 小端 字节序。]]></content>
      <categories>
        <category>Knowledge of CS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C++ map的remove函数实现]]></title>
    <url>%2Fblog%2F2019%2F04%2F15%2FC%2B%2B%20map%E7%9A%84remove%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[今天同学群里面讨论了这样一段代码，说是产品出了bug，现场急着修复。 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;string&gt;int main()&#123; std::cout &lt;&lt; "hello world" &lt;&lt; std::endl; std::map&lt;int, std::string&gt; mapPeople; mapPeople[1] = "hexu1"; mapPeople[2] = "hexu2"; // mapPeople[3] = "hexu3"; // mapPeople[4] = "hexu4"; std::map&lt;int, std::string&gt;::iterator iter = mapPeople.begin(); for (; iter != mapPeople.end(); iter++) &#123; if (iter-&gt;first == 2) &#123; std::cout &lt;&lt; "id : " &lt;&lt; iter-&gt;first &lt;&lt; ", name : " &lt;&lt; iter-&gt;second &lt;&lt; std::endl; mapPeople.erase(iter++); std::cout &lt;&lt; (iter != mapPeople.end()) &lt;&lt; std::endl; &#125; &#125; //for (; iter != mapPeople.end();) //&#123; // if (iter-&gt;first == 2) // &#123; // std::cout &lt;&lt; "id : " &lt;&lt; iter-&gt;first &lt;&lt; ", name : " &lt;&lt; iter-&gt;second &lt;&lt; std::endl; // mapPeople.erase(iter++); // if (iter == mapPeople.end()) // break; // &#125; // iter++; //&#125;// getchar(); return 0;&#125; 说是第一个for循环会崩溃，第二个for循环可以通过。经过分析，主要问题其实是出在对迭代器和erase的不熟悉上，导致错误的使用，这个程序的错误很明显，就是在erase这条分支中，iter++了两次。那么如何写一个正确的remove函数呢？代码如下： 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;string&gt;int main()&#123; std::cout &lt;&lt; "hello world" &lt;&lt; std::endl; std::map&lt;int, std::string&gt; mapPeople; mapPeople[1] = "hexu1"; mapPeople[2] = "hexu2"; mapPeople[3] = "hexu3"; mapPeople[4] = "hexu4"; std::map&lt;int, std::string&gt;::iterator iter = mapPeople.begin(); while (iter != mapPeople.end()) &#123; if (iter-&gt;first == 2) &#123; std::cout &lt;&lt; "id : " &lt;&lt; iter-&gt;first &lt;&lt; ", name : " &lt;&lt; iter-&gt;second &lt;&lt; std::endl; iter = mapPeople.erase(iter); continue; &#125; iter++; &#125; return 0;&#125; 另外，碰到删除的时候，要小心，可以这么写：iter = mapPeople.erase(iter);，也可以这么写：mapPeople.erase(iter++);（必须在删除前给迭代器++，否则迭代器会失效，这个问题那位程序员倒是考虑到了）。 最后我想说的一点是，根据指定key删除map中的元素，这个功能在其他语言中都有库函数可以调用，而C++却没有，还要自己动手写，而且需要对map的原理有一定的了解。这就从侧面反映了C++可能并不是一个高效的生产工具。]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[hexo把英文引号渲染成中文引号的问题]]></title>
    <url>%2Fblog%2F2019%2F04%2F15%2Fhexo%E6%8A%8A%E8%8B%B1%E6%96%87%E5%BC%95%E5%8F%B7%E6%B8%B2%E6%9F%93%E6%88%90%E4%B8%AD%E6%96%87%E5%BC%95%E5%8F%B7%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[其实这个问题我早就发现了，但一直没太在意，今天写博客的时候又看到这个难看的引号，终于忍不住想看看到底出了什么问题。 首先我试了中文的单引号和英文的单引号，发现渲染效果都一样，然后想看看当我分别打中文单引号和英文单引号的时候，hexo的渲染结果到底是不是一样。 打开chrome开发工具，发现页面上的英文单引号统一被渲染成了中文的单引号。 然后我手动修改页面看了下英文单引号是什么样子，发现样式确实很不一样。 那么问题就确定了：hexo把英文引号渲染成了中文引号。 谷歌搜了一下：hexo 渲染 单引号 中文单引号，得到几条不错的结果： 求助：单引号显示异常 #1981 6.4.0版本之后的两个问题 #462 对于我所使用的kramed，只需要在_config.yml中配置： 12kramed: smartypants: false 问题的原因是markdown渲染器把英文引号渲染成了中文引号，但这其实是可以配置的，所以解决起来比较简单。 在解决这个问题的过程中，如果你想顺利的解决问题，你需要的知识点有： 字符集的知识 Chrome开发工具使用经验 前端开发知识 好的搜索习惯 一定的英语水平 查阅文档的意识和习惯 如果你已经具备了以上前提，那么就能比较轻松愉快的解决这个问题了。]]></content>
      <categories>
        <category>Fixed Issues</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[动态数组的分摊分析]]></title>
    <url>%2Fblog%2F2019%2F03%2F03%2F%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%86%E6%91%8A%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[介绍动态数组在每次容量用尽时，重新申请2倍于当前数组的空间，并将原数组中的内容拷贝到新的空间，然后释放原数组的内存空间。对于动态数组，每次插入的花费有两种情况： 容量够用，我们只需要存储新的元素 容量不够用，创建新的空间，拷贝原数组进新的空间，再存储这个新的元素 分析方法有许多，统称为：amortized analysis（分摊分析） Lecture 21: Amortized Analysis 统计分析（aggregate method）把n词操作花费求和，然后取平均值。 每次扩容时，后半部分元素统一进行第一次移动，而这些元素之后的所有移动操作也是一起发生的，因而我们发现元素是以组为单位，组内的元素移动次数相同。那么有多少个这种组呢？第一组是单个元素，第二组也是单个元素，第三组是两个元素，第四组是四个元素，第五组是8个元素，... ，以此类推。而： $$1 + 1 + 2+ 2^2 + \cdots + 2^i = n$$ $$i = \log_2 n -1$$ 而这些组的移动次数分别是多少呢？最后一组元素只移动一次，倒数第二组元素移动2次，以此类推。所以总的移动次数是： $$1\times 2^i+2\times 2^{i-1}+3\times 2^{i-2}+\cdots+k\times 1$$ $$k = \log_2n + 1$$ 这个式子挺有规律的，我们可以将其分为很多个组，第一组是： $$1 + 1 + 2+ 2^2 + \cdots + 2^i = n$$ 第二组是： $$1 + 1 + 2+ 2^2 + \cdots + 2^{i-1} = \frac{n}{2}$$ 以此类推。 于是我们得到上式的等价表示： $$n + \frac{n}{2} + \cdots + 1 = 2n-1$$ 所以移动的平均次数是：$\frac{2n-1}{n}$，也就是每个元素最多移动2次，加上插入操作，最多三个操作。 银行算法（banker method）对动态数组的插入来说，大部分（后半部分）插入操作是不需要重新分配内存的，是廉价的操作。而少部分操作是需要重新分配内存的，是复杂的操作。我们可以试着想象在每次廉价操作的时候存储额外的费用，相当于存款，来支付复杂操作的费用。 我们假设一次基本的操作费用是一个硬币，当我们插入了一个下标为n的元素时： 我们要花费第一个硬币，作为基本的插入操作花费 我们还要存储第二个硬币，作为新插入的n在重新分配内存时移动它的费用 最后我们要存储第三个硬币，作为数组的前半部分的某个对应元素重新分配内存时移动费用 这样来计算，每个插入操作最多需要付出三个硬币，而第一个元素是不需要第三个硬币的。所以费用总数是：3n-1。 势能算法（Potential Method）首先说明一下，目前我对这个方法还是无法直观的理解。先祭出这个势能函数： $$\Phi(h) = 2n-m$$ 其中n是当前数组元素的个数，m是当前数组内存空间大小。 每次插入的费用函数定义为： $$c+\Phi(h&#39;)-\Phi(h)$$ c表示当前插入操作的总的花费，$\Phi(h&#39;)$是插入后的势能函数，$\Phi(h)$是插入前的势能函数。 这里分为两种情况： 如果n&lt;m，不必扩容，c=1，势能函数相差2，所以加起来是3 如果n=m，那么就要扩容，c=n+1，$\Phi(h&#39;)=2(n+1)-2n$，$\Phi(h)=2n-n$，加起来还是3 所以费用函数其实是一个等于3的常数函数。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[快速排序]]></title>
    <url>%2Fblog%2F2019%2F02%2F19%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[快速排序算法是一个原理非常简单易懂的算法，但如果现场手写的话又有多少人能写得出来呢？我今天又试了一下，发现还是存在一些认知上的问题。首先我明白快排的核心操作是：选取一个中枢，然后把小于中枢的放到左边，大于中枢的放到右边。但我发现时隔仅仅一年多，我居然已经忘了这个操作的英文名字了。直到我在写这篇文章的时候才突然想起来：partition操作。 在使用partition操作的前提下，递归解决问题就OK了。 partition具体操作如下： 我选取的中枢是第一个元素，且从前往后遍历数组。遇到小于中枢的，我要交换当前结点和中枢。遇到大于中枢的，直接略过。 第一个分支也就是遇到小于中枢的结点，这里才是操作比较复杂的部分，仔细想想其实这里要交换两次。将小于中枢的结点与中枢交换之后，中枢跑到了最后面，此时的结构相当于：小小小..大大大..中枢。我们还要将中枢塞到中间去。 1234567891011121314151617181920212223242526public void qsort(int[] array, int begin, int end)&#123; if(begin&gt;=end-1)&#123; return; &#125; int pivotIndex = partition(array, begin, end); qsort(array, begin, pivotIndex); qsort(array, pivotIndex+1, end);&#125;private int partition(int[] array, int begin, int end)&#123; int pivot = array[begin]; int pivotIndex = begin; int index = begin+1; while(index&lt;end)&#123; if(array[index]&lt;pivot)&#123; int temp = array[index]; array[index] = array[pivotIndex]; array[pivotIndex++] = temp; temp = array[index]; array[index] = array[pivotIndex]; array[pivotIndex] = temp; &#125; index++; &#125; return pivotIndex;&#125; 还可以思考一下： 选第一个元素做中枢，从后往前遍历 选最后一个元素做中枢，从前往后遍历 选最后一个元素做中枢，从后往前遍历 所以最后我发现快速排序确实是一个简单易懂的算法，难点在于partition操作的具体问题具体分析。四类partition全部写一遍。应该差不多了。 上面的方法归根结底都是使用 一个中枢 来划分，实际上也可以用两个指针来划分：一个记录小部的末尾，一个记录大部的首部。这两个指针一个从前往后，一个从后往前，直到相遇，本轮划分操作就结束。 于是我又抽空写了一下这个两个指针往中间靠的，结果并没有一遍写对，原因是边界检查，居然要不停的检查： 123456789101112131415161718192021private int partition1(int[] array, int begin, int end)&#123; int pivot = array[begin]; int smallEnd = begin; int bigBegin = end-1; while(smallEnd&lt;bigBegin)&#123; while (smallEnd&lt;bigBegin &amp;&amp; array[bigBegin]&gt;pivot)&#123; bigBegin--; &#125; if(smallEnd&lt;bigBegin)&#123; array[smallEnd++] = array[bigBegin]; &#125; while(smallEnd&lt;bigBegin &amp;&amp; array[smallEnd]&lt;pivot)&#123; smallEnd++; &#125; if(smallEnd&lt;bigBegin)&#123; array[bigBegin--] = array[smallEnd]; &#125; &#125; array[smallEnd] = pivot; return smallEnd;&#125; 这样感觉就太不美了。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[并查集]]></title>
    <url>%2Fblog%2F2019%2F01%2F19%2F%E5%B9%B6%E6%9F%A5%E9%9B%86%2F</url>
    <content type="text"><![CDATA[并查集什么是并查集并查集的核心是parent指针，一个结点可以找到自己所属的结点。从而把结点归类。有两个核心操作： Union（用来合并两个并查集） Find（用于查找一个结点的parent） 所以并查集可以叫做：union-find data structure。 什么是路径压缩我们看两个结点是否属于同一个并查集，实际上只看最顶层的那个parent，如果这两个结点属于同一个最顶层parent，那么它们就在同一个并查集中。 所以我们实际上只需要两层的树结构，让所有其他结点的parent指针指向最顶层parent，这样就能达到扁平化并查集的目的，从而使Find操作从O(logN)的时间复杂度变成O(1)。这就叫：路径压缩 代码如下： 123456public void findParent(UnionFindSetNode node)&#123; if(node.parent!=node)&#123; node.parent = findParent(node.parent); &#125; return node.parent;&#125; 这段代码很巧妙，可以在查找本结点父亲的时候，将路径上的所有祖先扁平化。 合并操作核心目标是：尽可能减少深度。所以需要注意的点是：把深度小的并查集归并到深度大的并查集。我们给并查集多添加一个深度属性：rank，比如两层的并查集，parent的rank就是1，叶子节点们的rank就是0。 代码如下： 1234567891011121314public void union(UnionFindSetNode node1, UnionFindSetNode node2)&#123; UnionFindSetNode parent1 = findParent(node1); UnionFindSetNode parent2 = findParent(node2); if(parent1!=parent2)&#123; if(parent1.rank&gt;parent2.rank)&#123; parent2.parent = parent1; &#125;else if(parent1.rank&lt;parent2.rank)&#123; parent1.parent = parent2; &#125;else&#123; parent1.parent = parent2; parent2.rank++; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[KMP算法]]></title>
    <url>%2Fblog%2F2019%2F01%2F17%2FKMP%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[KMP算法KMP算法用来在一个文本中查找模式串，如下图所示： 文本匹配例子： 我们把上面那个长字符串的称为文本，下面这个短的称为模式串。我们的目的是查看ABADABAD是否出现在文本中。 不必要的比较： 跳过不必要的比较： KMP算法的核心作用在于帮助模式串顺利的跳过很多不必要的比较（模式串没有任何前缀与文本匹配），直接后移到一部分前缀已经匹配的位置，开始下一次的比较。更准确的讲是移动到：最长真前后缀匹配的位置，如上图所示的ABA。 什么是真前后缀前缀和后缀我们都不陌生，比如单词ABA，它有三个前缀：A、AB、ABA，和三个后缀：A、BA、ABA。 真前后缀的意思是，前后缀必须是单词的真子集，也就是说不能是单词本身。所以上面那个单词ABA的真前缀是：A、AB，真后缀是：A、BA。 那么单词ABA真前后缀的最长匹配是：A。 那么真前后缀是否匹配有什么用？我们仔细观察文章最开头的文本匹配例子。在不必要的比较中，我们拿BADABA和ABADAB比较。而这两个，前者是模式串ABADABA部分的后缀，后者则是前缀。如果我们算得了ABADABA的真前后缀的最长匹配，就已经知道了BADABA和ABADAB不相等。而且还知道ADABA和ABADA也不相等，等等。 只要我们知道了真前后缀的最长匹配是什么，我们可以直接跳过所有这些没必要的比较。 KMP的核心就是：在每一次失配的时候，利用最长真前后缀匹配长度，直接跳过不必要的比较。 next数组next数组也就是：部分匹配表（Partial Match Table）。就是一个最长真前后缀匹配长度表。 首先next数组只需要用模式串得出，它是对模式串的解析，跟要匹配的文本没有半毛钱关系。其次next数组记录的其实就是最长真前后缀匹配长度，但错开了一位。 真前后缀的意思是，前后缀不能是字符串本身，只能是字符串的真子集 i 0 1 2 3 4 5 6 7 8 模式串 A B A D A B A D \0 next[i] -1 0 0 1 0 1 2 3 4 i = 0，next[0]，我们填-1； i = 1，前面的字符串为A，其最长相同真前后缀长度为0，即next[1] = 0； i = 2，前面的字符串为AB，其最长相同真前后缀长度为0，即next[2] = 0； i = 3，前面的字符串为ABA，其最长相同真前后缀为A，即next[3] = 1； i = 4，前面的字符串为ABAD，其最长相同真前后缀长度为0，即next[4] = 0； i = 5，前面的字符串为ABADA，其最长相同真前后缀长度为A，即next[5] = 1； i = 6，前面的字符串为ABADAB，其最长相同真前后缀长度为AB，即next[6] = 2； i = 7，前面的字符串为ABADABA，其最长相同真前后缀为ABA，即next[7] = 3； i = 8，前面的字符串为ABADABAD，其最长相同真前后缀为ABAD，即next[8]=4； 这张next表及其有用，前面说了，在字符串匹配的每一次失配的时候，我们都可以用已经匹配上的这段字符串的最长真前后缀匹配长度来定位将要跳转的位置。还是拿最开始的文本匹配例子： 当图一失配的时候，我们查ABADABAD的失配位置的next数组，也就是next[7]，得到ABADABA的最长真前后缀匹配长度3，然后拿&quot;ABADABAD&quot;.charAt(3)也就是D跟文本中失配处的字符&#39; &#39;继续匹配。如果又失配，那么递归处理。递归的边界是什么？答案是next[0]。 代码这个代码并不难写，我简单讲一下。 首先我们需要构造next数组，需要的参数只有一个：模式串。 然后我们使用一个指针遍历模式串，另一个指针负责记录匹配深度。 分支只有两个，一个是递归的边界或者匹配的时候：i++，j++，next[i]=j。一个是非递归边界且不匹配的时候，递归查找下一个必要的匹配：j=next[j]。 12345678910111213141516171819202122232425262728293031323334private int[] getNextArray(String pattern)&#123; int[] nextArray = new int[pattern.length()+1]; nextArray[0]=-1; int i=0; int j=-1; while(i&lt;pattern.length())&#123; if(j==-1 || pattern.charAt(i)==pattern.charAt(j))&#123; i++; j++; nextArray[i]=j; &#125;else&#123; j = nextArray[j]; &#125; &#125; return nextArray;&#125;public int KMP(String text, String pattern)&#123; int[] nextArray = getNextArray(pattern); int i=0; int j=-1; while(i&lt;text.length() &amp;&amp; j&lt;pattern.length())&#123; if(j==-1 || text.charAt(i)==pattern.charAt(j))&#123; i++; j++; &#125;else&#123; j = nextArray[j]; &#125; &#125; if(j==pattern.length())&#123; return i-j; &#125; return -1;&#125; 当然这种错开，和next[0]=-1的设定，不那么自然。其实可以有更自然的设计： i 0 1 2 3 4 5 6 7 8 模式串 A B A D A B A D \0 next[i] 0 0 1 0 1 2 3 4 这样一一对应就行了，next数组也与模式串等长。 这种next表的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839private int[] getNextArray(String pattern)&#123; int[] nextArray = new int[pattern.length()]; int i=1; int j=0; while(i&lt;pattern.length())&#123; while(j&gt;0 &amp;&amp; pattern.charAt(i)!=pattern.charAt(j))&#123; j = nextArray[j-1]; &#125; while(i&lt;pattern.length() &amp;&amp; pattern.charAt(i)==pattern.charAt(j))&#123; nextArray[i++] = ++j; &#125; if(j==0)&#123; nextArray[i++] = j; &#125; &#125; return nextArray;&#125;public int KMP(String text, String pattern)&#123; int[] nextArray = getNextArray(pattern); int i=0; int j=0; while(i&lt;text.length() &amp;&amp; j&lt;pattern.length())&#123; while(j&gt;0 &amp;&amp; text.charAt(i)!=pattern.charAt(j))&#123; j = nextArray[j-1]; &#125; while(i&lt;text.length() &amp;&amp; j&lt;pattern.length() &amp;&amp; text.charAt(i)==pattern.charAt(j))&#123; i++; j++; &#125; if(j==0)&#123; i++; &#125; &#125; if(j==pattern.length())&#123; return i-j; &#125; return -1;&#125; 这段代码看起来远不如上面第一种next表的代码简洁清晰。下面做一个简化，去掉内部的循环： 1234567891011121314151617181920212223242526272829303132333435private int[] getNextArray(String pattern)&#123; int[] nextArray = new int[pattern.length()]; int i=1; int j=0; while(i&lt;pattern.length())&#123; if(j&gt;0 &amp;&amp; pattern.charAt(i)!=pattern.charAt(j))&#123; j = nextArray[j-1]; &#125; else if(pattern.charAt(i)==pattern.charAt(j))&#123; nextArray[i++] = ++j; &#125; else if(j==0)&#123; nextArray[i++] = j; &#125; &#125; return nextArray;&#125;public int KMP(String text, String pattern)&#123; int[] nextArray = getNextArray(pattern); int i=0; int j=0; while(i&lt;text.length() &amp;&amp; j&lt;pattern.length())&#123; if(j&gt;0 &amp;&amp; text.charAt(i)!=pattern.charAt(j))&#123; j = nextArray[j-1]; &#125; else if(text.charAt(i)==pattern.charAt(j))&#123; i++; j++; &#125; else if(j==0)&#123; i++; &#125; &#125; if(j==pattern.length())&#123; return i-j; &#125; return -1;&#125; 看代码很容易知道，文本的指针是只增不减的，而且只在失配且匹配深度大于0的时候递归处理失配情况。但如何精确分析算法复杂度呢？ 算法复杂度分析这个算法的分析属于平摊分析。引入一个变量k，k=2*i-j。观察下面的代码： 1234567while(j&lt;m &amp;&amp; i&lt;n)&#123; if(0&gt;j || T[i]==P[j])&#123; i++;j++; // k加1 &#125;else&#123; j = next[j]; // j至少减一，i不变，那么k至少加1 &#125;&#125; 由上述注释分析得出：k单调递增。k的最大值是2*n+1，而k是迭代次数的上界，所以算法最坏时间是：2*n+1，所以这是一个O(n)的算法。同理可得算出next表的时间复杂度是O(m)。所以总的算法复杂度是O(m+n)。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[蓄水池算法]]></title>
    <url>%2Fblog%2F2019%2F01%2F15%2F%E8%93%84%E6%B0%B4%E6%B1%A0%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[蓄水池算法(Reservoir Sampling)这个算法真的很奇妙，它的核心是一个数学证明。外延，或者说应用场景是： $C_n^k$，也就是从大小为n的样本集中随机取k个不同的样本 流式数据，或者说无法直接根据索引拿到数据（更加不可能一遍加载到内存） 算法描述算法的描述其实很简单：维基百科：水塘抽样 1234567问题描述：从包含n个不同的项目的集合S中随机选取k个不同的样本。算法：从S中取首k个放入[水塘]中对每个S[j]项（j&gt;=k，数组从0开始）：true随机产生一个范围从0到j的整数rtrue若r&lt;k则把水塘中的第r项换成S[j]项最后得到的水塘就是抽样结果 这个算法保证了每一项最后可能存在于水塘中的概率都是一样的。 单看算法，你肯定不知道为什么是等概率，其实数学证明并不难，请看下面的证明： 数学证明我们把样本分为两类： 一类是首k个，它们一开始就在水塘中 一类是其他，它们一开始并不在水塘中 我们发现两个简单的逻辑： 对于水塘中的样本，只要随机数不选到该样本，该样本就不会被替换 水塘的某个项一旦被替换，就不可能再回到水塘，不会出现被替换掉，然后再回到水塘的局面，这样就保证了问题不会进一步变得复杂。所以：某个项被保留的概率 = 被选中到水塘的概率 * 后续不被替换的概率 分类讨论，首k个样本最终存在于水塘中的概率，和其余样本最终存在于水塘中的概率： 首k个样本，随便选一个做研究对象。被选中到水塘的概率为：1。（数组从1开始）从j=k+1开始考虑替换，第一次不被替换的概率是$\frac{k}{k+1}$，第二次不被替换的概率是$\frac{k+1}{k+2}$，第三次...，一直到最后一次不被替换的概率是$\frac{n-1}{n}$。所以该项被保留的概率 = $1\times\frac{k}{k+1}\times\frac{k+1}{k+2}\times\frac{k+2}{k+3}\times\cdots\times\frac{n-1}{n}=\frac{k}{n}$ 一开始不在水塘中的那一部分，随便选一个做研究对象。被选中到水塘的概率为：$\frac{k}{j}$，后续不被替换的概率$\frac{j}{j+1}$，一直到$\frac{n-1}{n}$。所以该项被保留的概率 = $\frac{k}{j}\times\frac{j}{j+1}\times\cdots\frac{n-1}{n}=\frac{k}{n}$ 到此我们就证明了所以样本最终存在于水塘中的概率都是$\frac{k}{n}$，这也完全符合了我们的数学期望。 代码弄个流式数据我们这里没有条件，只能用伪代码模拟一下： 1234567891011121314151617181920public Data[] reservoirSampling(int k, DataStream dataStream)&#123; Data[] reservoir = new int[k]; // init pool for(int i=0;i&lt;reservoir.length;i++)&#123; reservoir[i] = dataStream.getCurrentData(); dataStream.toNext(); &#125; Random random = new Random(); for(int i=k;!dataStream.isFinish();i++)&#123; int d = random.nextInt(i+1); if(d&lt;k)&#123; reservoir[d] = dataStream.getCurrentData(); &#125; dataStream.toNext(); &#125; return reservoir;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[$\lim\limits_{x\rightarrow 0} \frac{\sin x}{x} = 1$的证明]]></title>
    <url>%2Fblog%2F2019%2F01%2F07%2F%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%9E%81%E9%99%90%E7%9A%84%E8%AF%81%E6%98%8E%2F</url>
    <content type="text"><![CDATA[高数中的第一个证明，可能就是这个$\lim\limits_{x\rightarrow 0} \frac{\sin x}{x} = 1$的证明了。下面给出这个极限的证明，用到了解析几何（作图法）。 作图工具 Geometry 如图我们可以看到，有一个单位圆，圆心为 $A$ ，线段 $CE$ 的长度等于 $\sin x$，线段 $CB$ 是 弦（我们令他等于 $a$），弧 $\overset{\frown} {CB}$ 的长度就是 $x$，线段DB的长度等于 $\tan x$。 它们的长度的大小关系我们很容易得出： $\sin x &lt; a$，因为三角形的直角边小于斜边 $a &lt; x$，因为两点之间线段最短 $x &lt; \tan x$，这个略微不那么直接，可以用面积法（通过比较面积继而得到表达式中两个未知数的大小关系），扇形 $CAB$ 的面积：$\frac{1}{2} \cdot 1 \cdot x$ ，三角形 $\triangle DAB$ 的面积：$\frac{1}{2} \cdot 1 \cdot \tan x$ 。而 $CAB$ 的面积小于 $DAB$ 的面积。所以得到 $x &lt; \tan x$ 由此我们得到不等式：$\sin x &lt; x &lt; \tan x$ (当 $x&gt;0$ )，同时除以 $\sin x$，得到：$1 &lt; \frac{x}{\sin x} &lt; \frac{1}{\cos x}$。 当 $x&lt;0$ 时，显然 $\sin x &gt; x &gt; \tan x$，同时除以 $\sin x$（除以负数要变号），得到：$1 &lt; \frac{x}{\sin x} &lt; \frac{1}{\cos x}$。 令 $x\rightarrow 0^{-}$，由夹逼定理得到左极限 $\lim\limits_{x\rightarrow 0^{-}} \frac{\sin x}{x} = 1$ 令 $x\rightarrow 0^{+}$，由夹逼定理得到右极限 $\lim\limits_{x\rightarrow 0^{+}} \frac{\sin x}{x} = 1$ 最终可以得到：$\lim\limits_{x\rightarrow 0} \frac{\sin x}{x} = 1$ （左右极限都等于1）]]></content>
      <categories>
        <category>Math</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[熟练使用JetBrains家的IDE]]></title>
    <url>%2Fblog%2F2018%2F11%2F04%2F%E7%86%9F%E7%BB%83%E4%BD%BF%E7%94%A8JetBrains%E5%AE%B6%E7%9A%84IDE%2F</url>
    <content type="text"><![CDATA[通用快捷键 格式化代码（reformat code）:win: ctrl+alt+Lmac: command+option+L 在一行的任意位置使用： shift + enter，新建下一行并跳到下一行。 善用代码自动补全功能，变量名和方法名等可以用 enter 补全。导入包可以用 alt + enter。 上下移动代码，ctrl+shift+上下键 Android Studio 生成函数注释：你在方法前输入/**然后一回车，自动帮你生成方法和参数的注释。 Intellj Idea快速打出常用语句： sout：System.out.println(); psvm： 123public static void main(String[] args) &#123; &#125; 使用IDE的右键中的生成Getter Setter选项自动生成Getter Setter，使用toString自动生成toString。 跳转到接口：ctrl+b； 跳转到实现类：ctrl + alt +B 上面这个按钮可以快速的在目录树中定位到当前类所在的路径 ctrl+alt+t]]></content>
      <categories>
        <category>Tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[精通一款编辑器之sublime text 3]]></title>
    <url>%2Fblog%2F2018%2F11%2F04%2F%E7%B2%BE%E9%80%9A%E4%B8%80%E6%AC%BE%E7%BC%96%E8%BE%91%E5%99%A8%E4%B9%8Bsublime%20text%203%2F</url>
    <content type="text"><![CDATA[编辑器常用功能 格式化代码：格式化代码可以让你不用管代码的格式，可以放肆的写程序，你可以少敲很多空格，不用关心代码的格式问题，机器给出的代码格式风格统一且漂亮，一键解决你的格式问题，真是提高码代码效率的非常重要的功能。 查找文件：查找文件是在集成开发的时候非常重要的功能，当文件多起来的时候，快速定位到文件可以节省很多时间，甚至有时候文件实在太多，你只能通过查找的方式找到那个文件。 正则全文件查找和替换：轻松让你更改全局变量和配置，这是一个必须的功能，没有它简直无法想象工作量有多大。 代码收缩和扩展：代码太长怎么办，收缩和扩展啊。 安装卸载插件 cmd+shift+p：打开命令板，输入install，点击：Package Control: Install Package选项，然后搜索你想要的插件。 卸载请在命令板输入：remove，点击：Package Control: Remove Package选项。其实卸载无非就是两个词：remove和uninstall，多试试就行了。 打开命令板之后什么都不想干，怎么关闭命令板呢？其实很简单，再按一次打开命令板的快捷键就行了，开关都用同一个键或者按钮（术语叫：toggle，可开可关），这是比较通用设计理念。 基本快捷键 显示隐藏菜单栏：alt，如果你不小心把菜单栏隐藏了，除了用快捷键唤出，还真不知道有什么其他办法。 显示隐藏目录树：ctrl+k+b，这个功能可以在菜单栏中的view中找到，所以我觉得记不记无所谓 vue 插件 vue-syntax-highlight：可以让.vue文件高亮。 HTML-CSS-JS Prettify：可以格式化这三种语言的代码，特别是单文件的vue，非常需要这个来同时格式化三种语言。不过需要配置一下。工具栏路径：Sublime Text -&gt; Preferences -&gt; Package Settings -&gt; HTML/CSS/JS Prettify -&gt; Plugin Options - Default，然后搜索：allowed_file_extensions，给这个配置项添加一个vue即可，要注意的是有四处有这个配置项，分别是html、css、js、json，如果你想它们全都能格式化，自然是要全都添加vue，但实验证明只加html里面就行了，如果在其他几个里面加反而引起了冲突。然后格式化代码的快捷键是什么呢？同样也有配置文件的，工具栏路径：Sublime Text -&gt; Preferences -&gt; Package Settings -&gt; HTML/CSS/JS Prettify -&gt; Keyboard Shortcuts - Default，可以看到： 12345678910111213141516[&#123; &quot;keys&quot;: [&quot;super+shift+h&quot;], &quot;command&quot;: &quot;htmlprettify&quot;&#125;, &#123; &quot;keys&quot;: [&quot;super+alt+h&quot;, &quot;p&quot;], &quot;command&quot;: &quot;htmlprettify_set_prettify_prefs&quot;&#125;, &#123; &quot;keys&quot;: [&quot;super+alt+h&quot;, &quot;o&quot;], &quot;command&quot;: &quot;htmlprettify_set_plugin_options&quot;&#125;, &#123; &quot;keys&quot;: [&quot;super+alt+h&quot;, &quot;k&quot;], &quot;command&quot;: &quot;htmlprettify_set_keyboard_shortcuts&quot;&#125;, &#123; &quot;keys&quot;: [&quot;super+alt+h&quot;, &quot;n&quot;], &quot;command&quot;: &quot;htmlprettify_set_node_path&quot;&#125;] 第一项即为使用这个插件的快捷键，也就是格式化代码的快捷键。 底栏设置显示文件编码在mac osx上一不小心按了cmd+shift+c，文件的存储格式现在变成了GBK格式，当我再按下cmd+s保存时，提示我UTF-8格式的文件不能用GBK格式来保存。怎么解决这个问题呢？首先我想查看这个文件是什么编码，Sublime Text的默认设置是不开启显示编码的，如果想开启，可通过菜单Perference → Settings – User，在打开的配置文件里 ，在大括号后面，增加以下内容： 1234// Display file encoding in the status bar&quot;show_encoding&quot;: true,// Display line endings in the status bar&quot;show_line_endings&quot;: true, 此时保存该配置文件，就能够看到sublime最底下一行会显示文件编码格式了。以上的配置内容在Perference → Setting─Default都是false的。 然后在底栏点击文件编码，点击reopen with encoding，然后选择utf-8，然后cmd+w关闭窗口，然后cmd+shift+t重新打开刚刚关闭的窗口，就一切恢复正常了。]]></content>
      <categories>
        <category>Tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[处理器体系结构]]></title>
    <url>%2Fblog%2F2018%2F10%2F13%2F%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[阅读这篇文章必须要对汇编码有足够的了解，如果你对IA32汇编码还不够了解，可以先看看这篇文章：程序的机器级表示 Y86指令集体系结构Y86指令集基本上是IA32指令集的一个子集。这个指令集就是我们处理器实现的目标。如下图： IA32的movl指令分成了4个不同指令：irmovl、rrmovl、mrmovl和rmmovl，i表示立即数Immediate，r表示寄存器Register，m表示存储器Memmory。第一个字母表示源，第二个字母表示目的。 这里不实现的功能有： 存储器引用方式是简单的基址+偏移量形式，不支持变址寄存器（second index register）和任何寄存器伸缩（scaling）。如果对操作数的结构不太了解可以看看这个：操作数指示符 和IA32一样不允许从一个存储器直接传送到另一个存储器地址。 不允许立即数传送到存储器 4个整数操作指令：addl、subl、andl、xorl 7个跳转指令：jmp、jle、jl、je、jne、jge、jg。 6个条件传送指令：cmovle、cmovl、cmove、cmovne、cmovge、cmovg。 另外还有：call、ret、pushl、popl，halt指令停止指令执行。IA32中有一个与之相当的指令hlt，IA32的应用程序不允许使用这条指令，因为它会导致整个系统暂停运行。对于Y86来说，执行halt指令会导致处理器停止，并将状态码设置为HLT。 指令编码与IA32一样使用小端编码。 每条指令的第一个字节表明指令的类型，这个字节分为两部分，每部分4位：高4位是代码（code）部分，低4位是功能（function）部分。代码值为 0~0xB。可以观察到，rrmovl与条件传送指令有同样的代码部分，可以把它看作是一个无条件传送。 寄存器编码如下： 举个例子：用16进制表示指令 rmmvol %esp, 0x12345(%edx)的字节编码。 从上面图中可以看到，rmmovl第一个字节为40，由于%esp是4（占4位），%edx是2（占4位），所以第二个字节是42，最后再加上偏移量 00 01 23 45，小端表示是：45 23 01 00，所以最后得到指令的编码是：404245230100。 指令集的一个重要性质是字节编码必须有唯一解释，任意一个字节序列要么是一个唯一的指令，要么是一个不合法的指令。 相比于IA32，Y86没那么紧凑，IA32对寄存器只用了3位来编码，5位表明指令类型，所以IA32能将出栈入栈放进一个字节里。另外IA32可以将常数值编码成1、2、4字节，Y86总是编码成4字节。 RISC 和 CISC RISC: reduced instruction set computers，精简指令集 CISC: complex instruction set computers，复杂指令集 Y86异常 对于Y86，当遇到这些异常的时候，我们简单的让处理器停止执行指令。在更完善的设计中，处理器通常会调用一个 exception handler（异常处理程序），这个过程被指定用来处理遇到的某种类型的异常，例如放弃程序或调用一个用户自定义的 signal handler（信号处理程序）。 Y86程序12345678910int Sum(int *Start, int Count)&#123; int sum = 0; while (Count) &#123; sum += *Start; Start++; Count--; &#125; return sum; &#125; 可以看到Y86有时候需要两条指令来完成IA32一条指令就能完成的事。然而如果用数组索引来写这个程序，要转换成Y86会很困难，因为Y86没有伸缩寻址。 完整代码如下： 以.开头的是 assembler directive（汇编器命令），命令.pos 0告诉汇编器应该从地址0处开始产生代码。第3、4行使用的Stack标签，在最后有声明，其位置是0x100。第9到13行声明了一个数组，4字节对齐，值分别是：0xd，0xc0，0xb00，0xa000，array标签是起址。 细节问题，pushl %esp（这个指令只能用汇编语言写，C语言无法产生）是先把%esp的值转移到栈，还是先%esp减4再将结果转移到栈，实际上不同版本的intel处理器都会产生不同的结果，所以一个很重要的教训是要保证细节上的一贯性。 逻辑设计和硬件控制语言HCL（Hardware Control Language）逻辑门 组合电路和HCL语言构建一个组合电路有两条限制： 两个或多个逻辑门的输出不能连接在一起。这样会导致线上的信号矛盾，产生不合法的电压或电路故障。 必须是无环的，也就是不能形成回路。 下面是个简单的例子： 用HCL来写这个网的函数就是：bool eq = (a &amp;&amp; b) || (!a &amp;&amp; !b) HCL是用来C语言风格的语法，但这里同C语言不一样，该语句的意思不是执行了一次计算并将结果放入存储器，而是使用一个名字eq来称谓一个表达式。 实际上上面的组合电路就是同或，异或的表达式是：bool eq = (!a &amp;&amp; b) || (a &amp;&amp; !b) 多路复用器（multiplexor，通常称为：MUX）： bool out = (s &amp;&amp; a) || (!s &amp;&amp; b) 字级的组合电路和HCL整数表达式通常我们设计能对字（word）进行操作的组合电路，字级电路中用到的就是HCL整数表达式了。 字级与电路： bool Eq = (A == B); 也可以用异或来实现： 在HCL中，多路复用函数是用情况表达式（case expression）来描述的。情况表达式的通用格式如下： 12345678[ select_1 : expr_1; select_2 : expr_2; . . . select_k : expr_k;] 同C语言的switch语句不同，我们不要求不同的选择表达式之间互斥。从逻辑上讲，这些选择表达式是顺序求值的，且第一个求值为1的情况就会被选中。 字级多路复用电路： 用HCL来描述就是： 1234int Out = [ s: A; 1: B;]; 大多数人第一眼是看不懂这个表达式的，其实里面有个暗含的条件：先执行 s: A; 如果失败（没有输出A）才会再执行 1: B;。而1: B;实际上是!s&amp;&amp;1: B;的简写。没有输出A就已经代表s是0了，那么!s就是1。 四路复用器： 123456int Out4 = [ !s1 &amp;&amp; !s0: A; # 00 !s1 : B; # 01 !s0 : C; # 10 1 : D; # 11]; 第二个表达式可以写成!s1，而不用写的更完整!s1&amp;&amp;s0，是因为另一种可能s0=0已经出现在了第一个选择表达式了，若能到达第二个选择表达式，则s0=1。类似的，第三个表达式可以写成!s0，第四个表达式可以简单的写成1。 来看最后一个例子，假设我们想设计一个逻辑电路来找一组字A、B和C中的最小值，如下图所示： 用HCL来表达： 12345int Min3 = [ A&lt;=B &amp;&amp; A&lt;=C : A; B&lt;=A &amp;&amp; B&lt;=C : B; 1 : C;] 算术逻辑单元（arithmetic/logic unit, ALU） 集合关系 在这个电路中，两位的信号code就可以用来控制对4个数据字A、B、C和D做选择。根据可能的code值，可以用相等测试来表示信号s1和s0的产生： 12bool s1= code==2 || code==3;bool s0= code==1 || code==3; 还有一种更简洁的方式来表示这样的属性：当code在集合{2,3}中s1为1，而code在集合{1,3}中s0为1： 12bool s1= code in &#123;2,3&#125;;bool s0= code in &#123;1,3&#125;; 判断集合关系的通用格式：iexpr in {iexpr1, iexpr2, ... , iexprk} 存储器和时钟组合电路从本质上讲，不存储任何信息，它们只是简单的根据输入信号产生一个输出信号。为了产生时序电路（sequential circuit），也就是有状态并且在这个状态上进行计算的系统，我们必须引入按位存储信息的设备。存储设备都是由同一个时钟控制，时钟是一个周期性信号，决定什么时候要把新值加载到设备中。考虑两类存储器设备： 时钟寄存器（简称寄存器）存储单个位或字。时钟信号控制寄存器加载输入值。 随机访问存储器（简称存储器）存储多个字，用地址来选择该读或该写哪个字。随机访问存储器的例子包括：1.处理器的虚拟存储器系统（由硬件和操作系统结合起来使处理器可以在一个很大的地址空间内访问任意的字，硬件上包括由缓存、内存、外存）。2.寄存器文件，在此，寄存器标识符作为地址。在IA32或Y86处理器中，寄存器文件有8个程序寄存器（%eax、%ecx等）。 正如我们看到的那样，在说到硬件和机器级编程时，“寄存器”这个词是有两个不同的意思的。需要避免歧义的时候，我们分别称呼这两类寄存器为：硬件寄存器和程序寄存器。 下图说明了硬件寄存器是如何工作的： 寄存器是作为电路不同部分中的组合逻辑之间的屏障。我们的Y86处理器会用时钟寄存器保存程序计数器（PC），条件码（CC）和程序状态（Stat）。 下图展示了一个典型的寄存器文件： 寄存器文件有两个读端口，一个写端口。每个端口都有一个地址输入，地址是图4-4中的寄存器标识符。这样一个多端口随机访问存储器允许同时进行多个读和写操作。 虽然寄存器文件不是组合电路，因为它有内部存储。不过在我们的实现中，从寄存器文件中读数据就好像它是一个以地址为输入、数据为输出的一个组合逻辑块。当srcA或srcB被设成某个寄存器ID时，在一段延迟之后，存储在相应寄存器上的值就会出现在valA或valB上。 向寄存器文件写入字是由时钟信号控制的，控制方式类似于将值加载到时钟寄存器。每次时钟上升时，输入valW上的值会被写入dstW指明的寄存器上。当dstW设为特殊的ID值0xF时，不会写任何程序寄存器。 由于寄存器文件既可以读又可以写，一个很自然的问题就是：如果我们同时读和写一个程序寄存器会发生什么？答案简单明了：我们会看到一个旧值到新值的变化。所以在设计处理器的时候要把这个问题考虑进去。 我们的处理器有一个随机访问存储器，如下图所示： 同寄存器文件一样，从存储器中读的操作方式类似于组合逻辑：如果我们在输入address上提供一个地址，并将write控制信号设置为0，那么经过一些延迟之后，存储在那个地址上的值会出现在输出data上。如果地址超出了范围，error信号会置为1，否则就是0。 写存储器是由时钟控制的：我们将address设置为期望的地址，将data in设置为期望的值，而write设置为1。然后我们控制时钟时，只要地址是合法的，就会更新相应的地址中的值，如果是非法地址，error就会置为1。 Y86的顺序实现将处理组织成阶段 取指（fetch）：从存储器取指令，地址为PC所指的地址。从指令中抽取出指令指示符字节的两个四位部分，称为icode（指令代码）和ifun（指令功能）。 译码（decode）：译码阶段从寄存器文件最多读入两个操作数，得到值valA和valB（如果是两个的话）。通常，它读入指令rA和rB字段指明的寄存器，不过有些指令是读寄存器%esp的。 执行（execute） 访存（memory）：访存阶段可以将数据写入存储器，或者从存储器读出数据。读出的值为valM。 写回（write back）：写回阶段最多可以写两个结果到寄存器文件。 更新PC（PC update）：将PC设置成下一条指令的地址。 处理器无限循环，执行这些阶段。在我们简化的实现中，发生任何异常时，处理器就会停止。比如：它执行halt指令或非法指令，或者它试图读或者写非法地址。在更完整的设计中，处理器会进入异常处理模式，开始执行由异常的类型决定的特殊代码。 在硬件上复制逻辑块的成本比软件中有重复代码的成本要大得多。而且在硬件系统中处理许多特殊情况和特性要比用软件来处理困难得多。 我们面临的一个挑战是将每条不同指令所需要的计算放入到上述的通用框架中。我们会使用图4-17中所示的代码来描述不同的Y86指令的处理。图4-18到4-21描述了不同Y86指令在各阶段是怎样处理的。 让我们看一个具体的例子，图4-17中的第三条指令： 图4-17中第五条指令： 图4-17中第六条指令： 图4-21表明了三类控制转义指令的处理：各种跳转、call和ret。 图4-17中第8条指令： 图4-17中第13条指令： SEQ硬件结构]]></content>
      <categories>
        <category>Knowledge of CS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[程序的机器级表示]]></title>
    <url>%2Fblog%2F2018%2F10%2F08%2F%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[从编译C语言文件说起1$ gcc -01 -o p p1.c p2.c 使用了gcc命令来编译，也可以简单写作：cc。 优化层级为1，1级是最低的，层级越高程序优化越好，但增加了编译时间，也使调试变得更难，且跟源程序差异很大不便于理解。 编译的流程是： 预处理器（preprocessor）把诸如：#include、#define、#if、#else、#elif、#ifdef、#endif等预编译指令替换掉。 编译器（compiler）把.c源文件编译成.s的汇编代码文件。 汇编器（assembler）把汇编代码文件转换成相应的二进制目标文件.o，目标文件已经是机器码了，只是没有填入全局变量的地址。 链接器（linker），把多目标文件和库函数链接在一起，形成可执行文件。 instruction set architecture，ISA，指令集体系结构，定义了处理器状态，指令的格式和行为。intel的指令集包括32位的：IA32，以及64位的：x86-64。 编译器做了整个编译流程的大部分工作，汇编代码几乎就是机器码的供人阅读版。所以看懂汇编代码是关键。 IA32程序代码和C语言很不相同，一些在C语言下看不到的处理器状态可以在这里看到： 程序计数器（program counter，PC，也叫：instructor pointer，IP）在IA32中叫：%eip，指出下一条指令在内存中的位置 整数寄存器，可以用来保存数据 状态码寄存器，可以用来实现条件控制代码如：if和while 浮点寄存器，用来计算浮点数 例子1234567int accum = 0;int sum(int x, int y)&#123; int t = x + y; accum += t; return t;&#125; 如果要看到编译出的汇编代码，可以使用-S选项： 1$ gcc -01 -S code.c 这样就会使编译流程停留在 预处理-&gt;编译 阶段，而不是继续进行接下来的汇编和链接，生成的文件是：.s汇编文件。编译后的汇编代码中会包含如下代码： 12345678sum: pushl %ebp movl %esp, %ebp movl 12(%ebp), %eax addl 8(%ebp), %eax addl %eax, accum popl %ebp ret 这段代码中的每一句都对应一个机器指令，比如pushl这句的意思就是把寄存器%ebp的内容push到程序栈（内存中）上。在汇编代码里所有的局部变量都不见了，全局变量还可以看到，因为编译器还没有决定这个变量在内存中的存储位置。 如果我们使用-c选项，GCC就会既编译又汇编： 1$ gcc -01 -c code.c 这样就生成了目标文件code.o，在800bytes的code.o文件中，有17bytes是对应上面的汇编代码的： 155 89 e5 8b 45 0c 03 45 08 01 05 00 00 00 00 5d c3 可以使用反汇编将难懂的目标文件代码转成汇编代码： 1$ objdump -d code.o IA32指令的长度是1到15字节，越常用的，操作数越少的指令越短，反之则越长。 给定一个开始的位置，只对应一种机器指令，比如只有pushl %ebp指令是以55开头的 反汇编只需要根据目标文件就可以翻译出汇编文件 反汇编出来的文件跟直接编译的汇编文件有些不一样，比如所有指令都省略了后缀l。l是大小指示符，而大多数情况下是可以省略l的。 头两个属性跟哈夫曼编码的原理是一致的，可以说这是一种通用的编码原则，第一条用来保证节省字节空间，第二条则保证编码的唯一性。 生成真正可执行的文件还需要链接操作，而且必须包含main函数。假设我们的main.c文件如下： 123int main()&#123; return sum(1, 3);&#125; 我们可以使用如下指令生成可执行文件： 1$ gcc -01 -o prog code.o main.c prog文件增长到了9123bytes，因为它不仅包含我们写的代码，而且包含了用来开始和结束的程序，以及与操作系统进行交互的程序。 可以看到第6行，全局变量在链接的时候定址。 汇编代码的格式假设我们有一个C语言文件simple.c： 12345int simple(int *xp, int y) 2&#123; int t = *xp + y; *xp = t; return t;&#125; 可以得到如下汇编代码： 12345678910111213141516.file &quot;simple.c&quot; .text.globl simple .type simple, @functionsimple: pushl %ebp movl %esp, %ebp movl 8(%ebp), %edx movl 12(%ebp), %eax addl (%edx), %eax movl %eax, (%edx) popl %ebp ret .size simple, .-simple .ident &quot;GCC: (Ubuntu 4.3.2-1ubuntu11) 4.3.2&quot; .section .note.GNU-stack,&quot;&quot;,@progbits 所有以.开头的行都是用来指导汇编器和链接器的，我们不用去管。而这段代码的大概意思如下： 123456789simple: pushl %ebp 保存帧指针 movl %esp, %ebp 创建新的帧指针 movl 8(%ebp), %edx 从内存中读取xp movl 12(%ebp), %eax 从内存中读取y addl (%edx), %eax *xp+y=t movl %eax, (%edx) 把t存到xp指向的地址中 popl %ebp 重新获取帧指针 ret 返回 这段代码对%ebp和%esp的操作涉及到了程序栈模型，看不懂很正常，文章下面会有讲解的。 ATT和intel汇编格式ATT即AT&amp;T，是贝尔实验室旗下的公司。 GCC和OBJDUMP默认生成ATT格式的汇编代码，微软和因特尔的编程工具则默认生成intel格式的汇编代码。 使用如下命令可以让GCC生成intel格式的代码： 1$ gcc -01 -S -masm=intel code.c 两者的区别如下： intel代码省略了用来指定大小的后缀，比如使用mov而不是movl intel代码省略了寄存器前面的%，比如使用esp而不是%esp intel代码用了不同的方式来描述内存地址，比如使用DWORD PTR [ebp+8]而不是8(%ebp) intel代码多操作数指令的操作数顺序跟ATT相反 由于是由16bit架构扩展到32bit架构的，intel管16bit数据类型叫：word，32bit数据类型叫：double words，64bit数据类型叫：quad words。 数据格式 访问数据IA32 CPU 包含了8个寄存器，每个有32bit存储空间，用来存储整形值以及指针。 x86-64则进一步扩展了这些寄存器： 前六个寄存器称为通用寄存器，有其特定的用途： %rax(%eax) 用于做累加，过程调用返回值 %rcx(%ecx) 用于计数 %rdx(%edx) 用于保存数据 %rbx(%ebx) 用于做内存查找的基础地址 %rsi(%esi) 用于保存源索引值 %rdi(%edi) 用于保存目标索引值 操作数指示符 有三种类型的操作数，立即数(Imm)、寄存器值(Reg)、内存值(Mem)。 mov指令 pushl %ebp指令等价于下面的指令： 12subl $4,%esp 减小栈指针movl %ebp,(%esp) 把%ebp中的数据写到%esp指向的内存中 popl %eax指令等价于下面的指令： 12movl (%esp), %ebp 把%esp指向的内存地址中的值读到%eax中addl $4, %esp 增加栈指针 算术和逻辑操作load effective address，leal指令，实际上是一个movl指令。 多个操作数的指令，注意一下两个操作数的顺序即可 位移操作位移的值是用一个单字节来表示，且数值只能是0到31，所以这个字节只有低五位才会被考虑。 扩展乘除指令 控制状态码使用单比特的状态码来描述算数和逻辑运算的状态。最常用的状态码如下： CF: carry flag 进位符，用来表示最高位的进位。通常用来检测无符号运算的溢出 ZF: zero flag，零标志符，最近的操作产生了0 SF: sign flag，符号位，最近的操作产生了负数 OF: overflow flag，溢出符，补码溢出，正负都可以，表示有符号溢出 举个例子：t=a+b，a、b、t都是整形数。 1234CF: (unsigned)t&lt;(unsigned)a 无符号溢出ZF: (t==0) 零SF: (t&lt;0) 负数OF: (a&lt;0 == b&lt;0) &amp;&amp; (t&lt;0 != a&lt;0) 有符号溢出 OF的表达式也可以写作：(a&lt;0 &amp;&amp; b0) || (a&gt;0 &amp;&amp; b&gt;0 &amp;&amp; t&lt;0)，也就是说a、b都是负数相加却是正数，或者a、b都是正数相加却是负数，这两种情况就代表溢出了。 leal操作不会改变状态码，因为这个指令只是用来计算地址。除此之外表3.7中的所有操作都可能改变状态码。例如逻辑操作：XOR，会使CF和OF置零，移位操作会使CF置为最后一个移位出去的bit，但OF要置零。自增和自减指令会设置OF和ZF，不设置CF。 CMP指令类似于SUB指令，但只修改状态码而不改变其他寄存器，如果两个操作数相等，ZF就会被设置；TEST指令类似于AND指令，但只修改状态码而不改变其他寄存器，如果两个操作数是重复的： testl %eax,%eax，作用是检测%eax是0，还是正数，还是负数。 访问状态码有三种常用的方式访问状态码： 根据几个状态码的逻辑组合，设置单个字节为0或1，也就是set指令 根据状态码，跳转到程序的其他分支 根据状态码传送数据 举个例子：计算a&lt;b，a和b都是int型 1234a is in %edx, b is in %eaxcmpl %eax, %edx Compare a:bsetl %al Set low order byte of %eax to 0 or 1movzbl %al, %eax Set remaining byte of %eax to 0 setl 指令是：D &lt;- SF^OF，也就是有两种情况代表 a-b&lt;0： OF=0（a-b没有发生溢出），且SF=1（a-b结果为负） OF=1（a-b发生了溢出），且SF=0（a-b结果为非负） 第二种情况比较复杂，需要简单分析一下。a-b发生了溢出，有两种情况：正溢出和负溢出。负溢出：a是负数，b是正数，但a-b结果为正（结果小于了最小的负数，发生溢出）；正溢出：a是正数，b是负数，但a-b结果为负（结果大于了最大的正数，发生溢出）。 比如： 123-128： 1000 0000127: 0111 1111-127: 1000 0001 a=-128, b=127, a-b=-128-127= $(1 0000 0001)_2$ , 从结果上来看就变成了1（正数），这就是负溢出 a=127, b=-127, a-b=127-(-127) = $(1111 1110)_2$ , 从结果上来看就变成了 -2（负数），这就是正溢出 OF=1, SF=0，就是负溢出，而负溢出代表着a是负数，b是正数，也就是a&lt;b 其他三个有符号比较以此类推。 跳转指令 可以看到条件跳转必须是直接的，而无条件跳转可以使用操作数。 跳转位置的编码有两种： 借助PC使用相对定位 使用绝对定位 实例如下： 12345678910jle .L2 if &lt;=, goto dest2 .L5: dest1: movl %edx, %eax sarl %eax subl %eax, %edx leal (%edx,%edx,2), %edx testl %edx, %edxjg .L5 if &gt;, goto dest1 .L2: dest2: movl %edx, %eax 目标文件和汇编文件对应如下： 123456788: 7e 0d jle 17 &lt;silly+0x17&gt; Target = dest2a: 89 d0 mov %edx,%eax dest1:c: d1 f8 sar %eaxe: 29 c2 sub %eax,%edx10: 8d 14 52 lea (%edx,%edx,2),%edx13: 85 d2 test %edx,%edx15: 7f f3 jg a &lt;silly+0xa&gt; Target = dest117: 89 d0 mov %edx,%eax dest2: 对应的关系是：0xd+0xa=0x17，0xf3+0x17=0xa，为什么是加下一条指令的地址而不是当前指令呢？这个传统要追溯到计算机的早期实现，当时的处理器会在执行每一条指令之前先更新一下PC（program counter）。 12345678804839c: 7e 0d jle 80483ab &lt;silly+0x17&gt;804839e: 89 d0 mov %edx,%eax80483a0: d1 f8 sar %eax80483a2: 29 c2 sub %eax,%edx80483a4: 8d 14 52 lea (%edx,%edx,2),%edx80483a7: 85 d2 test %edx,%edx80483a9: 7f f3 jg 804839e &lt;silly+0xa&gt;80483ab: 89 d0 mov %edx,%eax 从反汇编代码来看，跳转如果使用PC相对地址，则不管代码存储到内存中的哪个位置，跳转的地址都不需要修改，且需要的编码更短。 翻译条件分支1234if(test-expr) then-statementelse else-statement 先写成等价的goto版本，然后就可以很轻松的转成汇编了 12345678t=test-expr;if(!t) goto false; then-statement goto done;false: else-statementdone: 从汇编的角度看 &amp;&amp;短路 原理： 12345void cond(int a, int *p)&#123; if (p &amp;&amp; a &gt; 0) *p += a;&#125; 12345678910a %ebp +8, p at %ebp +12movl 8(%ebp), %edxmovl 12(%ebp), %eaxtestl %eax, %eaxje .L3testl %edx, %edxjle .L3addl %edx, (%eax).L3: 可以看到第一个条件通不过的时候就跳过了第二个条件判断。 循环do while123do body-statement while(test-expr) goto版本： 12345loop: body-statement t = test-expr; if (t)goto loop; while12while (test-expr) body-statement 先转成do while形式： 123456if (!test-expr) goto done;do body-statement while (test-expr);done: 在把do while转成goto版： 123456789t = test-expr;if (!t) goto done;loop: body-statement t = test-expr; if (t) goto loop;done: for12for (init-expr; test-expr; update-expr) body-statement 先转成while形式： 12345init-expr;while (test-expr) &#123; body-statement update-expr;&#125; 然后转成do while形式： 12345678init-expr;if (!test-expr) goto done;do &#123; body-statement update-expr;&#125; while (test-expr);done: 最后转成do while的goto版本： 1234567891011init-expr;t = test-expr;if (!t) goto done;loop: body-statement update-expr; t = test-expr; if (t) goto loop;done: 状态转移指令 1v = test-expr ? then-expr : else-expr; goto版： 1234567if (!test-expr) goto false;v = true-expr;goto done;false: v = else-expr;done: switchswitch主要使用了跳转表： 123456789101112131415161718192021int switch_eg(int x, int n) &#123; int result = x; switch (n) &#123; case 100: result *= 13; break; case 102: result += 10; /* Fall through */ case 103: result += 11; break; case 104: case 106: result *= result; break; default: result = 0; &#125; return result;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142int switch_eg_impl(int x, int n) &#123; /* Table of code pointers */ static void *jt[7] = &#123; &amp;&amp;loc_A, &amp;&amp;loc_def, &amp;&amp;loc_B, &amp;&amp;loc_C, &amp;&amp;loc_D, &amp;&amp;loc_def, &amp;&amp;loc_D &#125;; unsigned index = n - 100; int result; if (index &gt; 6) goto loc_def; /* Multiway branch */ goto *jt[index]; loc_def: /* Default case*/ result = 0; goto done; loc_C: /* Case 103 */ result = x; goto rest; loc_A: /* Case 100 */ result = x * 13; goto done; loc_B: /* Case 102 */ result = x + 10; /* Fall through */ rest: /* Finish case 103 */ result += 11; goto done; loc_D: /* Cases 104, 106 */ result = x * x; /* Fall through */ done: return result;&#125; 汇编代码如下： 跳转表的步长是4 .rodata的意思是：read only data 过程调用 有以下几个要点： 栈是倒着长的 每个过程调用都有一个stack frame，栈帧 栈顶帧用两个指针来维护，一个是帧起址：%ebp，一个是栈指针：%esp指向栈顶。 %esp在过程运行的时候可能会被抹掉，这时候可以通过%ebp来定位。 可以看到返回地址在每一帧的最后。而每一帧的第一个位置存放着上一帧的帧起址%ebp。帧的中间则放置局部变量、过程参数等值。 有以下几种情况会将局部变量放到栈帧中： 局部变量多到寄存器放不下 局部变量是数组或者结构体，必须用到引用 局部变量使用了取址符&amp;，所以我们必须给它生成地址 转移控制 call指令的效果是：把返回地址push到栈中，然后跳到调用程序的地址（也就是把PC设置一下）。返回地址是汇编代码中call指令后面那条指令的地址。 ret指令把栈顶的返回地址pop出来，并跳转到这个地址。 寄存器使用传统%eax, %edx, %ecx是调用者保存寄存器。也就是说当过程Q被过程P调用，过程Q可以随意的写这三个寄存器，因为在调用Q之前P必须保存这三个寄存器的值。 %ebx, %esi, %edi是被调用者保存寄存器。也就是说在过程Q写这些寄存器之前，必须保存里面的值，并在return之前恢复原样。 过程调用例子12345678910111213141516171819int swap_add(int *xp, int *yp)&#123; int x = *xp; int y = *yp; *xp = y; *yp = x; return x + y;&#125;int caller()&#123; int arg1 = 534; int arg2 = 1057; int sum = swap_add(&amp;arg1, &amp;arg2); int diff = arg1 - arg2; return sum * diff;&#125; 一些编程语言，比如Pascal，提供了值传参和引用传参。但C语言只有值传参，C++提供了引用传参。C语言可以通过指针来实现引用传参。 总共申请了24字节的空间，8字节用来存局部变量，8字节用来存参数，还有8字节未使用。 为什么要浪费8字节，原因是：内存对齐。GCC遵循一个x86编程方针：栈空间必须是16的整数倍，包括保存%ebp的4字节和返回地址的4字节。这里总共加起来是24字节，所以需要额外的8字节填充成32字节。 swap_add的汇编代码如下： 分为三个部分：setup、body、finish setup: 1234swap_add: pushl %ebp Save old %ebp movl %esp, %ebp Set %ebp as frame pointer pushl %ebx Save %ebx 首先要保存调用者的帧基指针，然后重新设置当前帧基指针，然后如果用到%ebx,%esi,%edi等寄存器就需要保存。 body: 1234567movl 8(%ebp), %edx Get xpmovl 12(%ebp), %ecx Get ypmovl (%edx), %ebx Get xmovl (%ecx), %eax Get ymovl %eax, (%edx) Store y at xpmovl %ebx, (%ecx) Store x at ypaddl %ebx, %eax Return value = x+y 获取参数，进行计算。 finish: 123popl %ebx Restore %ebxpopl %ebp Restore %ebpret Return 恢复两个寄存器，同时%esp回到了上一个帧的栈顶，指向了返回地址，然后ret指令就可以把PC置为返回地址了，这样就完成了控制权的转移。 然后执行调用完swap_add之后的代码： 12345movl -4(%ebp), %edxsubl -8(%ebp), %edximull %edx, %eaxleaveret leave指令的作用是重置栈指针和帧指针，也可以使用popl来重置，很简单： 1234//使%esp指向%ebp的地址（也就是Saved %ebp那里）movl %ebp, %esp//popl指令会导致%esp+4，所以%esp之后会指向上一帧的帧尾（也就是Return Address那里），popl的内容则放到了%ebp里面popl %ebp 而之后的ret指令继续将Return Address pop出来，并将Return Address放到PC中。 从这个例子我们可以看出，编译器遵循一组简单的惯例来管理栈结构。 通过%ebp加偏移量（+8,+12,...）访问参数 通过push指令或者栈指针减偏移量来分配栈空间 在返回前恢复保存好的寄存器，并使栈指针指向调用者的返回地址（Return Address） 数组、多维数组、结构体、联合体这些都比较简单，这里略过。 要注意的点：只有call才会push一个返回地址，所以swap_add的栈帧中并没有返回地址，说明它没有调用其他函数 指针每种数据类型都有对应的指针类型，但指针类型不是机器码的一部分，只是C语言提供的一种抽象，帮助程序员避免犯错。 内存引用越界和缓冲区溢出我们可以看到C语言对数组引用没有任何边界检查，而且栈里面既保存了局部变量又保存了寄存器值以及返回地址。所以一旦数组越界写就会破坏整个程序的运行。 看下面这个例子： 1234567891011121314151617181920212223/* Sample implementation of library function gets() */char *gets(char *s)&#123; int c; char *dest = s; int gotchar = 0; /* Has at least one character been read? */ while ((c = getchar()) != '\n' &amp;&amp; c != EOF) &#123; *dest++ = c; /* No bounds checking! */ gotchar = 1; &#125; *dest++ = '\0'; /* Terminate string */ if (c == EOF &amp;&amp; !gotchar) return NULL; /* End of file or error */ return s;&#125;/* Read input line and write it back */void echo()&#123; char buf[8]; /* Way too small! */ gets(buf); puts(buf);&#125; 这段C语言代码对应的汇编代码如下： 分配数组空间的时候是直接固定了8字节，这里给buf分配的空间也是8字节：leal -12(%ebp), %ebx，并把buf作为参数放置于栈顶。 我们可以看到，当读写buf[8]的时候，实际上是在读写Saved %ebx。 通常给被攻击的程序输入一个字符串，这个字符串包含了可执行代码的字节编码，如果我们通过缓冲区溢出修改了返回地址，那么ret指令就可以跳转到我们攻击代码的位置。 蠕虫（worms）和病毒（viruses）的区别：相同点：都可以复制和传播自身，不同点：蠕虫可以自己运行，病毒是把自己加入到其他程序中，包括操作系统代码，病毒是不能独立运行的。 对抗缓冲区溢出攻击的方法栈随机化攻击者需要插入攻击代码（一个字符串），并知道攻击代码的位置（也就是字符串存放的栈地址），而且指向这段字符串的指针也是这个字符串的一部分。如果栈的位置是固定的，那么就很容易猜到攻击代码的存放位置。用如下代码可以检测栈的位置： 12345int main() &#123; int local; printf("local at %p\n", &amp;local); return 0;&#125; 只需要打印一个局部变量的地址。 栈随机化的思想是程序每次运行时栈的位置都不一样，实现方式是：程序开始时，在栈上分配一段0~n字节之间的随机大小的空间，例如使用alloca可以在栈上分配空间。程序不使用这段空间，它的作用是使后续栈的位置发生变化。分配的n必须足够大，这样才能有足够多的变化，但又必须足够小，这样才不会浪费空间。 栈随机化是更大一类技术的一种，这类技术称为：Address-Space Layout Randomization，ASLR，地址空间布局随机化。但攻击者还是可以采取一定措施来增加攻击成功率，一种常见的手段就是在攻击代码前中插入很长一段的nop指令，这个指令只会使程序计数器（PC）加一，除此之外没有任何副作用。只要攻击者能够猜中这段序列中的某个地址，就可以顺利到达攻击代码。这个序列的常用术语是：nop sled空操作雪橇。 栈破坏检测在局部缓冲区和栈状态之间插入一个随机的金丝雀值（也叫哨兵值），一旦发现这个值被改变，就说明缓冲区溢出了，那么就可以将程序异常中止。 攻击者只有输入局部缓冲区变量的权限，所以无从得知金丝雀值。 GCC默认就会插入金丝雀值，如果不想要可以使用参数：-fno-stack-protector来阻止GCC产生这种代码。当不使用此参数时，产生代码如下： 指令参数%gs20, %eax指明金丝雀值使用 segmented addressing（段寻址）从存储器中读入。将段标志为只读，这样攻击者就不能同时修改段中的金丝雀值。最后使用xorl比较段和栈中的金丝雀值，如果不相等则call __stack_chk_fail。 这种做法可以带来很小的性能损失。 限制可执行代码区域在典型的程序中，只有保存编译器产生的代码的那一部分存储空间才需要是可执行的。其他部分可以被限制为只允许读写。虚拟存储器空间在逻辑上分成了页（page），典型的每页是 2048 或者 4096 字节。由硬件提供存储器保护。以前，x86体系结构将读和执行访问控制合并成一个1位标志，所以任何被标记为可读的部分也是可执行的，当然也有很多机制可以限制一些页是可读的但是不可执行，然而这些机制都很消耗性能。最近，AMD（Advanced Micro Devices）为它的64位处理器的内存加入了 NX, No-eXecute，不可执行位，intel也跟进了，检查页是否可执行由硬件来完成，效率上没有任何损失。]]></content>
      <categories>
        <category>Knowledge of CS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[浮点数原理]]></title>
    <url>%2Fblog%2F2018%2F09%2F27%2F%E6%B5%AE%E7%82%B9%E6%95%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[浮点数的作用：区别于整形数，用来表示小数。可以用来表示很大的数，或者非常接近0的小数，或者近似的做实数计算，浮点数的一般形式：$x\times 2^y$。 IEEE（pronounced “Eye-Triple-Eee”）浮点数标准 是行业内公认的标准。 rounding：when a number cannot be represented exactly in the format and hence must be adjusted upward or downward。可以翻译为：舍入。 十进制的小数表示：$d_m d_{m-1} \cdots d_1 d_0 . d_{-1} d_{-2} \cdots d_{-n}$，写成数学表达式： $$d = \sum_{i=-n}^m 10^i \times d_i$$ 相应的，二进制也可以写成这种形式： $$b = \sum_{i=-n}^m 2^i \times b_i$$ 浮点数的表示IEEE浮点数的格式：$V = (-1)^s \times M \times 2^E$ s是符号（Sign），s为0时是正，s为1时是负 M是有效数字（Significand，即 尾数） E是 指数，Exponent，也叫 幂数，阶码 隐含的 基数 是 2 下图是浮点数的内存分布模型，首先是符号域，然后是指数域，最后是分数域： 符号位s个，符号位只需要一位，s=1 指数位k个，指数域 $exp=e_{k-1}\cdots e_1 e_0$，用来计算指数E 分数为n个，分数域 $frac=f_{n-1}\cdots f_1 f_0$，用来计算有效数字M 32位浮点数（单精度，float型）中，s=1，k=8，n=23；64位浮点数（双精度，double型）中，s=1，k=11，n=52。 正常化值（Normalized Values）当 $exp$ 域既不是全0，也不是全1的时候，就是正常化值。 $E = e - Bias$，其中 $e$ 就是 $exp$ 域：$e_{k-1}\cdots e_1e_0$ 的值（除去全0和全1之后，取值范围是1到$2^k-2$），$Bias=2^{k-1}-1$（单精度的时候是127，双精度的时候是1023），那么 $E$ 的取值范围，单精度的时候是：-126 ~ +127，双精度的时候是：-1022 ~ +1023，其实 $E$ 的算法就是 移码 的计算方法。 $M = 1+f$，$0\le f\lt 1$，内存里只记录f，而1作为一个前导值计算时候再加上，所以f是分数域 $frac$ 的 $0.f_{n-1}\cdots f_1f_0$ 这种形式 非正常化值（Denormalized Values）当指数域全0，就是非正常化格式。 在这种情况下，指数值是 $E = 1-Bias$，也就是固定了，有效数字值 $M = f$ 也就是没有前导1了。这个格式下可以表示0，因为正常化值中，一定有： $M\ge 1$，所以我们无法在正常化值格式下表示0。当符号位是0，有效数字 $M=f=0$，我们得到的就是+0.0，当符号位是1的时候就是-0.0。 除了可以表示0，这个格式的另一个作用就是用来表示非常接近0的数。 特殊值（Special Values）当指数域全1的时候，且分数域是全0，就表示无穷大，如果符号域为0，表示 $+\infty$，如果符号位是1，则表示 $-\infty$。无穷大可以作为溢出的结果，当我们用两个很大的数相乘，或者除以0； 当指数域全1，且分数域并非全0的时候，结果可以叫做：NaN（Not a Number的简写），这种值用来表示不能用实数或者无穷大表示的计算结果，比如计算：$\sqrt{-1}$ 或者 $\infty - \infty$。 综合理解下图是三类浮点数在数轴上的显示： 可以看到非正常化值集中在0附近，正常化值散布在整个数轴的空间，特殊值则只表示两个无穷值。 下图是浮点数三种类型的光滑衔接： 看完浮点数的设计和构造我们可以发现以下这些特点： 从编码上有效数字域采用了无符号整数编码，而指数域采用了移码编码 非正常化值均匀分布在0附近 正常化值的间隔随着 $2^E$ 变大而逐渐变大，也就是精度逐渐降低 精度是分组的，以 $2^E$ 增加1为一组，每组有 $2^n$ 个数（n是有效数字域的位数） 最高精度就是两个非正常化值的间隔，最低精度是最大的一组正常化值的相邻两数的间隔。 非正常化值按照精度只占一组，正常化值的数量是非正常化值数量的 $2^{k}-2$ 倍 正常化值的第一组的精度和非正常化值的精度一样，也就是实现了无缝衔接 浮点数的计算舍入 Rounding维基百科 各种Rounding合集图 浮点数中使用的是：舍入到最近的偶数，因为舍入结果放大和缩小各占50%的概率，这样就可以防止最终结果偏大或者偏小。 下面是把浮点数舍入到小数点后两位数： $10.00011_2(2\frac{3}{32})$ -&gt; $10.00_2(2)$ 不到一半，正常四舍五入$10.00110_2(2\frac{3}{16})$ -&gt; $10.01_2(2\frac{1}{4})$ 超过一半，正常四舍五入$10.11100_2(2\frac{7}{8})$ -&gt; $11.00_2(3)$ 正好一半，保证最后一位是偶数，所以向上舍入$10.10100_2(2\frac{5}{8})$ -&gt; $10.10_2(2\frac{1}{2})$ 正好一半，保证最后一位是偶数，所以向下舍入 浮点数加减运算基本性质 相加可能产生 infinity 或者 NaN 不满足交换律，不满足结合律（因为舍入会造成精度上的损失） 加上0等于原来的数 除了 infinity 和 NaN，每个元素都有对应的相反数 除了 infinity 和 NaN，满足单调性，即 $a\ge b \rightarrow a+c\ge b+c$ 1234567891011121314#include &lt;iostream&gt;using namespace std;int main()&#123; // 浮点数加法不满足交换律 cout &lt;&lt; 3.14 + 1e20 - 1e20 &lt;&lt; endl; cout &lt;&lt; 1e20 - 1e20 + 3.14 &lt;&lt; endl; // 浮点数加法不满足结合律 cout &lt;&lt; (3.14 + 1e20) - 1e20 &lt;&lt; endl; cout &lt;&lt; 3.14 + (1e20 - 1e20) &lt;&lt; endl; return 0;&#125; 运行结果: 123403.1403.14 具体细节设两个浮点数 $x$ 和 $y$： $$\begin{cases}x=(-1)^{s_x} M_x 2^{E_x} \y=(-1)^{s_y} M_y 2^{E_y}\end{cases}$$ 则浮点数加减运算结果为： $$x\pm y = \left((-1)^{s_x}M_x 2^{E_x-E_y} \pm (-1)^{s_y}M_y \right)2^{E_y}$$ 对阶：首先要把指数位（阶码）调成一样，并相应的使M移位，由于有效域左移会引起最高有效位丢失，误差大，所以采用右移，此时阶码要增加。所以对阶原则是：小阶向大阶看齐。 有效数加减：简单的无符号数字相加减。 规格化：有效数求和结果可能大于1，那么就向右规格化：尾数右移1位，阶码加1。 舍入：对于右移出去的位，采取舍入 检查阶码是否溢出： 阶码下溢：运算结果为非规格化数 阶码上溢：置溢出标志 浮点数加减实例$x=3.14, y=2.718$ 求 $z=x+y$。 首先算出 $x$ 和 $y$ 的内存表示： $x = 3+0.14$，3的二进制表示是11，0.14的二进制要稍微计算一下，我们让0.14不断的乘以2（也就是左移），得到的整数位部分就是其二进制值的一位： 12345670.14 * 2 = 0.28 00.28 * 2 = 0.56 00.56 * 2 = 1.12 10.12 * 2 = 0.24 0... 我们可以写个程序来完成这个计算工作： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;using namespace std;// 获取整形数的位数int getDigits(int num)&#123; int count = 1; while(num/10&gt;0)&#123; num %= 10; count++; &#125; return count;&#125;/** * 获取小数的二进制表示 * @params precision 二进制表示精确到多少位 * @params num 小数的整数表示 */char* getFloatBitset(int precision, int num)&#123; char* res = new char[precision]; int digits = getDigits(num); int mod = pow(10, digits); char printFormat[50]; sprintf(printFormat,"%%0.%df",2); // cout &lt;&lt; printFormat &lt;&lt;endl; for(int i=0;i&lt;precision;i++)&#123; printf(printFormat, num*1.0/mod); cout &lt;&lt; " * 2 = "; num &lt;&lt;= 1; if(num &gt;= mod)&#123; printf(printFormat, num*1.0/mod); cout &lt;&lt; " 1" &lt;&lt; endl; num %= mod; res[i] = '1'; &#125;else&#123; printf(printFormat, num*1.0/mod); cout &lt;&lt; " 0" &lt;&lt; endl; res[i] = '0'; &#125; &#125; return res;&#125;/** * 获取小数的二进制表示 * @params precision 二进制表示精确到多少位 * @params num 浮点型小数 * @params digits 输入的时候浮点型小数的位数 */char* getFloatBitset2(int precision, float num, int digits)&#123; char* res = new char[precision]; int mod = pow(10,digits); // cout&lt;&lt;mod&lt;&lt;endl; char printFormat[50]; sprintf(printFormat,"%%0.%df",2); for(int i=0;i&lt;precision;i++)&#123; printf(printFormat, num); cout &lt;&lt; " * 2 = "; num*=2; num = round(num*mod)/mod; if(num &gt;= 1)&#123; printf(printFormat, num); cout &lt;&lt; " 1" &lt;&lt; endl; num -= 1; res[i] = '1'; &#125;else&#123; printf(printFormat, num); cout &lt;&lt; " 0" &lt;&lt; endl; res[i] = '0'; &#125; &#125; return res;&#125;int main(int argc, char* argv[])&#123; // char* res = getFloatBitset(atoi(argv[1]), atoi(argv[2])); char* res = getFloatBitset2(atoi(argv[1]), atof(argv[2]), atoi(argv[3])); cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; 上面代码保存成：float2Bitset.cpp文件，然后编译，并使用： 12$ g++ -o float2Bitset float2Bitset.cpp$ ./float2Bitset 23 0.14 2 小数位精确到23位的话，3.14的定点浮点数表示是：11.00100011110101110000101。 转成浮点数，首先规格化M，那么整体要右移1位，指数是1，由 $E = e-Bias$，$E=1$, $Bias=127$ 得 $e=128$，也就是：1000 0000。 最终3.14的内存表示是：$$\underbrace{0}_{Sign}~\underbrace{10000000}_{Exponent}~~\underbrace{10010001111010111000011}_{Significand}$$ 同样的方法得到2.718的内存表示： $$\underbrace{0}_{Sign}~\underbrace{10000000}_{Exponent}~~\underbrace{01011011111001110110110}_{Significand}$$ 这两个数恰好是同阶的，那么就不需要对阶操作了。将M相加，但这个数太长了看着眼花，我们写个加法程序： 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;// 将两个相同位数的二进制数相加char* addBitset(char num1[], char num2[], int length)&#123; char* res = new char[length+2]; res[length+1] = '\0'; int carry = 0; for(int i=length-1;i&gt;=0;i--)&#123; res[i+1] = num1[i]-'0'+num2[i]-'0'+carry+'0'; carry = 0; if(res[i+1]&gt;'1')&#123; res[i+1] -= 2; carry = 1; &#125; &#125; if(carry)&#123; res[0]='1'; &#125;else&#123; res[0]='0'; &#125; return res;&#125;int main(int argc, char* argv[])&#123; int i=0; while(argv[1][i]!='\0')&#123; i++; &#125; cout &lt;&lt; i &lt;&lt;endl; char* res = addBitset(argv[1], argv[2], i); cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; 上述代码保存成：addBitset.cpp，编译并使用该程序： 12$ g++ -o addBitset addBitset.cpp$ ./addBitset 10010001111010111000011 01011011111001110110110 相加结果等于：0 11101101110100101111001，最高位没有产生进位，这里用了一个0来代替，但两个前导1相加产生了进位，所以还需要对M右归一下，再对指数加1。所以加法结果的浮点数表示是： $$\underbrace{0}_{Sign}~\underbrace{10000001}_{Exponent}~~\underbrace{01110110111010010111101}_{Significand}$$ 这个数的十进制表示的计算方法是：$$2^2 \times (1+0\times (\frac{1}{2})^1 + 1\times (\frac{1}{2})^2 + 1\times (\frac{1}{2})^3 +1\times (\frac{1}{2})^4+0\times(\frac{1}{2})^5+\cdots)$$ 我们依然采用程序来计算这一长串二进制对应的十进制小数： 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;using namespace std;double bitset2Float(char* num1, int length)&#123; double res = 0.0; int count=1; for(int i=0;i&lt;length;i++)&#123; double temp = (num1[i]-'0')/pow(2,count); // cout &lt;&lt; temp &lt;&lt; endl; res += temp; count++; &#125; return res;&#125;int main(int argc, char* argv[])&#123; int i=0; while(argv[1][i]!='\0')&#123; i++; &#125; double res = bitset2Float(argv[1],i); cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; 上述代码保存为：Bitset2float.cpp，编译并执行： 12$ g++ -o Bitset2float Bitset2float.cpp$ ./Bitset2float 01110110111010010111101 对得到结果：0.4645，$1.4645\times 2^2 = 5.858$，而 $3.14+2.718=5.858$，这就说明我们的计算无误。 算法流程图 这个流程图并不是完美的，真实的浮点数流程图和浮点数计算电路比这个复杂。另外我忘画了一个东西，这个图最后应该加上溢出处理模块，E可能会上溢（当E加1的时候），也可能会下溢（当E减1的时候）。 最后这个流程图中没有对特殊值的判断，比如：$\infty - \infty = NaN$, $\infty + \infty = \infty$, $NaN + 任何数 = NaN$。 了解了浮点数加法的流程之后，最后我们回到最上面说的 浮点数加减法不满足交换律和结合律，从计算细节分析为什么不行。 首先 3.14 的浮点数表示我们已经计算过了，那么 1e20 的浮点数是多少呢？1e20也就是 $10^{20}$，用辗转相除法可以得到其二进制表示。我们这里使用计算器工具 很遗憾的是64bit只能摆的下 $10^{19}$。我试了一下把源程序中的 1e20 换成 1e19 也是同样的结果。所以我们就使用 1e19 来分析这道题。 首先是M规格化，M右移63位，E加63，舍入M，那么 1e19 最终的双精度浮点数表示是：0 10000111110 0001010110001110010001100000100100010011110100000000 小阶向大阶看齐，3.14的阶是1，M需要右移62位，而M的精度才52，可想而知M就是0了。那么 3.14 + 1e19 的结果就是 1e19。1e20就更加不用说了。 浮点数乘除基本性质 相乘可能产生 infinity 或者 NaN 不满足交换律，结合律，分配率（因为溢出会造成程序无法计算出正确的结果） 乘以1会等于原来的数 除了 infinity 和 NaN，满足单调性：$a\ge b \rightarrow a\times c \ge b \times c$ 具体细节设两个浮点数 $x$ 和 $y$ ： $$\begin{cases}x = \pm M_x 2^{E_x} \y = \pm M_y 2^{E_y}\end{cases}$$ 则浮点数乘除运算结果是： $$xy = \pm (M_x\times M_y)2^{E_x\pm E_y}$$ 计算阶码，判断是否溢出 求有效数的乘积 有效数舍入 计算符号位 浮点数还有相当多的细节，可以参考：IEEE 754]]></content>
      <categories>
        <category>Knowledge of CS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[wsl oh my zsh 字符乱码问题]]></title>
    <url>%2Fblog%2F2018%2F09%2F20%2Fwsl%20oh%20my%20zsh%20%E5%AD%97%E4%BD%93%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[安装 oh my zsh首先检查自己有没有zsh： 1cat /etc/shells 如果有的话就下载oh my zsh 设置默认shell1chsh -s /bin/zsh 有可能会遇到设置不成功的问题，那么我们可以手动修改/etc/passwd，找到自己那一条配置信息，把默认shell改成/bin/zsh就OK了。 字体问题-&gt;等一些其他字符可能显示不出来，这是字体导致的。google一下：wsl oh my zsh font，找到：https://github.com/Microsoft/WSL/issues/1517，下载并设置字体为：DejaVuSansMono。 怎么设置字体右键标题栏，进入属性]]></content>
      <categories>
        <category>Fixed Issues</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[wsl修改右键bash图标]]></title>
    <url>%2Fblog%2F2018%2F09%2F19%2Fwsl%E4%BF%AE%E6%94%B9%E5%8F%B3%E9%94%AEbash%E5%9B%BE%E6%A0%87%2F</url>
    <content type="text"><![CDATA[使用 windows subsystem for linux (简称：WSL) 的时候，遇到一个小问题，在文件管理器中右键，唤出bash，发现图标不对： 点击之后可以看到调用的是哪个程序： google一下：windows 右键图标，搜到百度经验：https://jingyan.baidu.com/article/7c6fb428321b4a80642c90fd.html，照着修改就行了。 如图： 那么改成什么呢？google一下：wsl bash icon，搜到：https://github.com/Microsoft/WSL/issues/1269，然后又在这个页面找到了这个：https://github.com/cmderdev/cmder/issues/1063#issuecomment-401947209 把icon换成： 1C:\Program Files\WindowsApps\CanonicalGroupLimited.UbuntuonWindows_1804.2018.817.0_x64__79rhkp1fndgsc\ubuntu.exe 再点击右键，就能看到这个图标了。 除了修改右键显示的icon，还可以修改右键显示的名字，以及运行的目标程序。 改为： 1C:\Program Files\WindowsApps\CanonicalGroupLimited.UbuntuonWindows_1804.2018.817.0_x64__79rhkp1fndgsc\ubuntu.exe 但发现无法把工作目录定到当前右键的目录，需要加一个run： 1C:\Program Files\WindowsApps\CanonicalGroupLimited.UbuntuonWindows_1804.2018.817.0_x64__79rhkp1fndgsc\ubuntu.exe run]]></content>
      <categories>
        <category>Fixed Issues</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mathjax常用公式记录]]></title>
    <url>%2Fblog%2F2018%2F04%2F30%2Fmathjax%E5%B8%B8%E7%94%A8%E5%85%AC%E5%BC%8F%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[角度记法 度数：$60^\circ$，$60^\circ$ 度数分：$60^\prime$，$60^\prime$ 弧度：$\frac{\pi}{2}$，$\frac{\pi}{2}$ 角度记法：$\angle A$，$\angle A$ 三重环积分无法渲染的问题在网上找了半天资料最终解决了，参考这个答案：How do you render a closed surface double integral?，做法是直接使用Unicode编码：\unicode{x222F}，三重环积分的编码，参考这里：unicode-search.net，所以只要将$\oiiint$换成$\unicode{x2230}$即可正确显示三重环积分。如下： $$\unicode{x2230}$$ 行内limit1$\lim\limits_&#123;x\rightarrow 0&#125; \frac&#123;\sin x&#125;&#123;x&#125; = 1$ 效果：$\lim\limits_{x\rightarrow 0} \frac{\sin x}{x} = 1$ 1$\lim_&#123;x\rightarrow 0&#125; \frac&#123;\sin x&#125;&#123;x&#125; = 1$ 效果：$\lim_{x\rightarrow 0} \frac{\sin x}{x} = 1$ 凭个人喜好，我就更喜欢第一种。 弧1$\overset&#123;\frown&#125; &#123;AB&#125;$ $\overset{\frown} {AB}$]]></content>
      <categories>
        <category>Tools</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数学基础公式推导]]></title>
    <url>%2Fblog%2F2018%2F04%2F25%2F%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC%2F</url>
    <content type="text"><![CDATA[今天看到下面这个公式，突然想我好像不会推导啊： $\sin(\beta-\alpha) = \sin\beta\cos\alpha - \cos\beta\sin\alpha$ 遂想如何推导，在youtube上找了一个视频：三角函数正余弦和角公式推导 思路是先推导出：$\cos(\beta-\alpha) = \cos\alpha\cos\beta + \sin\alpha\sin\beta$ 然后根据这个再结合正弦余弦之间的关系就很容易推 $\sin(\beta-\alpha) = \sin\beta\cos\alpha - \cos\beta\sin\alpha$ 那么怎么推导上面这个公式呢？ 需要用到解析几何： 结合 勾股定理 和 余弦定理 可以推导出。 这里不给出勾股定理和余弦定理的证明，感兴趣的可以自己证。 根据勾股定理： $$\begin{align}\overline{PQ}^2&amp;= (\sin\alpha - \sin\beta)^2 + (\cos\beta - \cos\alpha)^2 \newline&amp;= 2 - 2(\cos\alpha\cos\beta + \sin\alpha\sin\beta) \newline\end{align}$$ 根据余弦定理（$a^2 = b^2 + c^2 -2ab\cos A$）： $$\begin{align}\overline{PQ}^2&amp; = 1^2 + 1^2 - 2\cdot1\cdot1\cdot\cos(\alpha-\beta)\end{align}$$ 由此推出： $$\cos(\alpha-\beta) = \sin\alpha\sin\beta+\cos\alpha\cos\beta$$ 也即： $$\cos(\beta-\alpha) = \sin\alpha\sin\beta+\cos\alpha\cos\beta$$ 然后： $$\begin{align}\sin(\beta-\alpha)&amp;= \cos(\frac{\pi}{2}-(\beta-\alpha)) \newline&amp;= \cos((\frac{\pi}{2}+\alpha) - \beta) \newline&amp;= \sin(\frac{\pi}{2}+\alpha)\sin\beta + \cos(\frac{\pi}{2}+\alpha)\cos\beta \newline&amp;= \cos\alpha\sin\beta - \sin\alpha\cos\beta \newline&amp;= \sin\beta\cos\alpha - \cos\beta\sin\alpha\end{align}$$]]></content>
      <categories>
        <category>Math</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Override Overload Overwrite]]></title>
    <url>%2Fblog%2F2017%2F11%2F14%2FOverride-Overload-Overwrite%2F</url>
    <content type="text"><![CDATA[我们都知道有些东西容易混淆，在加上中文翻译得乱七八糟，更加让人困惑。今天我要讲的这三位可就真是绝了。 它们是：Override、Overload、Overwrite。 这是我查有道词典时候看到的可怕一幕： Override 一个把三个名字都占了，你怕不怕？反正我是看的心里一紧。 如果把概念都煮成了一锅粥，那还不如不要记这些概念，你应该向更深层次去探寻。就这三个的区别来说，我觉得主要理解两个概念就行了： 函数签名（signature） 多态（polymorphism、polymorphic） 函数签名函数签名是什么，其实就是用来区别函数的，两个函数怎么样认定是不同的两个函数呢，只有两个方面： 函数名 参数 有人说还有返回值啊，不行，返回值不能作为函数签名的一部分，因为你调用一个函数的时候，返回值根本不能帮助编译器来识别你用的是哪个函数，比如： 1234int func(int a, int b);float func(int a, int b);func(); 请问我使用的是哪个函数？你看返回值确实不行吧。 多态多态是面向对象编程的概念，你可以看看它的准确定义： Polymorphism，定义很简短：polymorphism is the provision of a single interface to entities of different types. 如果父类有一个函数，子类也定义了一个完全相同的函数（函数签名相同），那么你可以用父类指针（或者说父类对象）作为统一的接口，来调用子类的方法。比如： 123456789101112131415161718192021222324252627class Vehicle&#123; public void move()&#123; System.out.println(“Vehicles can move!!”); &#125;&#125;class MotorBike extends Vehicle&#123; public void move()&#123; System.out.println(“MotorBike can move and accelerate too!!”); &#125;&#125;class Car extends Vehicle&#123; public void move()&#123; System.out.println(“Hi! I am a car!”); &#125;&#125;class Test&#123; public static void main(String[] args)&#123; Vehicle vh = new MotorBike(); vh.move(); // prints MotorBike can move and accelerate too!! vh = new Vehicle(); vh.move(); // prints Vehicles can move!! vh = new Car(); vh.move(); // prints Hi! I am a car! &#125;&#125; 多态的好处是可以扩展啊，比如我后来又多了个 truck 类，我不需要去动已经写好的代码，只要把 truck 模块写好，加进去就行了。 Override、Overload、Overwrite 的区别好了，知道了这两个概念，我们再来看看上面的那三个混在一起的东西： Override（推翻，对英文意思就是这个）subclass method overrides base class method means: in different range (in derived class and base class) the same function signature the base class method is virtual（if in C++） overload（超载）function overloading means: the same range (in the same class) the same function name but different function signature overwrite（重写）subclass method hides base class method means: in different range (in derived class and base class) the same function name 我们应该记住只有 Override 才跟多态有关。 Overload 是本class 里面的不同函数（只不过函数名一样罢了，其实是两个不同的函数，看两个函数是否是同一个函数就看函数签名就行了），其实没啥稀奇的，不就是函数名一样嘛。函数签名一样，区分出是用父类还是子类的函数，这才是面向对象和多态要解决的问题。 Override 和 Overwrite 的区别 比较容易混淆的其实是 Override 和 Overwrite，但你只要死记住：Override 必须函数签名要一样，而 Overwrite 只需函数名一样即可。另外 C++ 中一定要用virtual才算 Override，而 Java 默认就是 Override，不需要修饰词。 这里关于 Java 和 C++ 面向对象的细节区别可以写一大堆，比如：C++ class 后面是要加分号的，而 Java 不需要；但 Java 的类名是和文件名要一致的，而且只能有一个 public 类，而 C++不需要；Java 直接就能用 Override，而 C++必须要使用 virtual 关键字才能使用 Override（虚函数）；Java 的抽象方法跟 C++的纯虚函数对应。Java 是单继承，由接口来实现“多继承”，C++是多继承，没有接口，只有抽象类。C++还有个虚基类的概念。具体的写法上还有很多的不同，多用这两种语言写面向对象的代码，就慢慢会知道了。 C++ 有一个 virtual 关键字和 virtual table 这个概念，没有加 virtual 的父类函数是不可能形成多态的，如果这时候你碰到父类和子类两个里面有同名的函数，那么就属于 Overwrite 这个概念了，你其实也可以称这种覆盖掉父类函数的行为为：hide 隐藏。Java 这种语言里面没有 virtual 这一套，Java 也可以表现出 Overwrite，但要注意函数签名如果一样的话，那又不叫 Overwrite 了，应该叫 Override 了（Java 如果要在子类中使用父类的同函数签名方法，则必须使用 super 关键字）。而 C++ 不一样，即便是函数签名一样，如果前面不加 virtual 是不能叫 Override 的，仍然属于 Overwrite 的概念。请看下面的例子： 用 C++ 写的话： 12345678910111213141516171819202122232425#include &lt;iostream&gt;using std::cout;using std::endl;class A&#123;public: void func(int a)&#123; cout &lt;&lt; "A" &lt;&lt; endl; &#125;&#125;;class B:public A&#123;public: void func(int a)&#123; cout &lt;&lt; "B" &lt;&lt; endl; &#125;&#125;;int main()&#123; A *a = new B(); a-&gt;func(1); ((B*)a)-&gt;func(1); return 0;&#125; 结果输出： 12AB 可以看到，C++必须要用子类类型的指针才能访问到子类的部分（建议看一本书，叫：Inside the C++ Object Model，中文叫：深入C++对象模型，里面讲对象的内存布局讲的很清楚），java 也一样，必须转成子类型的指针才能访问，否则 IDE 会报错提示你。 Java 代码： 1234567891011121314151617181920public class test &#123; class A&#123; void func(int a)&#123; System.out.println("A"); &#125; &#125; class B extends A&#123; void func(int a, int b)&#123; System.out.println("B"); &#125; &#125; public static void main(String[] args)&#123; test t = new test(); A a = t.new B(); a.fun(1); ((B)a).func(1,2); &#125;&#125; 结果输出： 12AB 为什么 Java 代码里不像 C++ 代码里面那样，使用两个函数签名相同的函数？因为前面说过了，那样的话就变成 Override 了，只有在 C++ 里才能实现函数签名相同的 Overwrite（不使用virtual即可）。]]></content>
      <categories>
        <category>Knowledge of CS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[值传递和引用传递]]></title>
    <url>%2Fblog%2F2017%2F03%2F29%2F%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%2F</url>
    <content type="text"><![CDATA[Java没有引用传递，本质上都是值传递，只不过如果传递的值可以是指针（Java没有指针，所以你也可以理解为对象，其实本质上还是指针）。 12345678910111213public class Solution &#123; private void getString(String text)&#123; text = "hello"; &#125; public static void main(String[] args) &#123; Solution solution = new Solution(); String text = "world"; solution.getString(text); System.out.println(text); &#125;&#125; text本质上是一个指针，而getString中的text则是另一个指针（一个局部变量），所以这里实际上有两个不同的text，而我们实际上改变的就是一个局部变量。所以输出结果是：world。也可以理解为形参和实参不是同一个对象，形参是一个局部变量，存在于寄存器或者当前栈帧，实参存在于上一级栈帧，和而被调用的函数，在它的执行过程中不会改变上一层栈帧的实参。 如果深入了解了C语言程序栈的构造，就能彻底明白函数调用的细节：过程调用 值传递和引用传递是每个刚开始写代码的程序员的必经之坑，比如经典的swap函数交换，就是一个大坑： 12345678910111213141516public class Solution &#123; private void swap(String text1, String text2)&#123; String temp = text1; text1 = text2; text2 = temp; &#125; public static void main(String[] args) &#123; Solution solution = new Solution(); String text1 = "world"; String text2 = "hello"; solution.swap(text1, text2); System.out.println(text1+" "+text2); &#125;&#125; 输出是：world hello 实际上我觉得这应该算得上是编程语言底层设计影响到上层使用的一个例子，不是那么自然，比较容易让人困惑。可以算作是一种封装的失败吧。补救方法在C中是使用指针，C++中是使用引用，Java中是使用对象包装一层。]]></content>
      <categories>
        <category>Knowledge of CS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[常量池]]></title>
    <url>%2Fblog%2F2017%2F03%2F28%2F%E5%B8%B8%E9%87%8F%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[字符串由char数组实现，字符串以\0结尾，\0是ASCII的第一个字符，用bit表示也就是：0000 0000，这可以方便我们找到字符串的结尾。 ASCII字符由一个字节表示，实际上第一版的ASCII字符只用到了7个bit，128个字符，扩展版的ASCII使用了8个bit。 12char str[11];strcpy(str, "0123456789\0"); 为了节省内存，C/C++把常量字符串放到常量池中，当几个指针被赋值了相同的字符串常量时，实际上它们会指向相同的内存地址。但用常量字符串初始化数组，情况却不同。 1234567891011121314151617181920int _tmain(int argc, _TCHAR* argv[])&#123; char str1[] = "hello world"; char str2[] = "hello world"; char* str3 = "hello world"; char* str4 = "hello world"; if(str1==str2)&#123; printf("str1 and str2 are same.\n"); &#125;else&#123; printf("str1 and str2 are not same.\n"); &#125; if(str3==str4)&#123; printf("str3 and str4 are same.\n"); &#125;else&#123; printf("str3 and str4 are not same.\n"); &#125; return 0;&#125; 输出：str1 and str2 are not same.str3 and str4 are same. 常量池虽然好用，但这样会造成一个问题，就是我们拿其中一个指针改了字符串内容，就会造成另一个指针指向的字符串也变了。为此像C#和Java等语言都将字符串类型设为不可变对象，改变字符串实际上是新建了一个字符串，这样就不会引起冲突了。但如果需要不停的改变就要不停的新建，这样就太影响效率，所以又提供了StringBuilder类，这个类是支持在原字符串上改动的。]]></content>
      <categories>
        <category>Knowledge of CS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数组和指针的区别]]></title>
    <url>%2Fblog%2F2017%2F03%2F27%2F%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[数组和指针的区别： 123456789101112131415int GetSize(int data[])&#123; return sizeof(data);&#125;int _tmain(int argc, _TCHAR* argv[])&#123; int data1[] = &#123;1, 2, 3, 4, 5&#125;; int size1 = sizeof(data1); int* data2 = data1; int size2 = sizeof(data2); int size3 = GetSize(data1); printf("%d, %d, %d\n", size1, size2, size3);&#125; 答案是输出：20, 4, 4 sizeof是个关键字而不是函数，sizeof(data1)是求数组的大小，这里有5个int型元素，所以总共20个字节，data2声明为指针，尽管指向了一个数组，但本质上只是一个指针，所以sizeof(data2)的语义范围收缩了，无法仅通过一个指针得知其所指范围。在32位系统上一个指针是4字节，所以结果就是4。在C/C++中，当数组作为函数的参数进行传递时，数组就自动退化为同类型的指针，因此size3的结果也是4。]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
</search>
