<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>2018-09-19-wsl修改右键bash图标</title>
      <link href="/blog/2018/09/19/2018-09-19-wsl%E4%BF%AE%E6%94%B9%E5%8F%B3%E9%94%AEbash%E5%9B%BE%E6%A0%87/"/>
      <url>/blog/2018/09/19/2018-09-19-wsl%E4%BF%AE%E6%94%B9%E5%8F%B3%E9%94%AEbash%E5%9B%BE%E6%A0%87/</url>
      <content type="html"><![CDATA[<p>使用 windows subsystem for linux (简称：WSL) 的时候，遇到一个小问题，在文件管理器中右键，唤出bash，发现图标不对：</p><p><img src="https://i.loli.net/2018/09/19/5ba25208ca7de.png" alt="截图1"></p><p>点击之后可以看到调用的是哪个程序：</p><p><img src="https://i.loli.net/2018/09/19/5ba254dbe66ea.png" alt="截图2"></p><p>google一下：<code>windows 右键图标</code>，搜到百度经验：<code>https://jingyan.baidu.com/article/7c6fb428321b4a80642c90fd.html</code>，照着修改就行了。</p><p>如图：</p><p><img src="https://i.loli.net/2018/09/19/5ba255cbd964f.png" alt="截图3"></p>]]></content>
      
      
        <tags>
            
            <tag> windows环境 </tag>
            
            <tag> wsl </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Leetcode 804 Unique Morse Code Words</title>
      <link href="/blog/2018/09/19/2018-08-07-Leetcode-804-Unique-Morse-Code-Words/"/>
      <url>/blog/2018/09/19/2018-08-07-Leetcode-804-Unique-Morse-Code-Words/</url>
      <content type="html"><![CDATA[<h2 id="804-Unique-Morse-Code-Words"><a href="#804-Unique-Morse-Code-Words" class="headerlink" title="804. Unique Morse Code Words"></a>804. Unique Morse Code Words</h2><p>International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: <code>&quot;a&quot;</code> maps to <code>&quot;.-&quot;</code>, <code>&quot;b&quot;</code>maps to <code>&quot;-...&quot;</code>, <code>&quot;c&quot;</code> maps to <code>&quot;-.-.&quot;</code>, and so on.</p><p>For convenience, the full table for the 26 letters of the English alphabet is given below:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&quot;.-&quot;,&quot;-...&quot;,&quot;-.-.&quot;,&quot;-..&quot;,&quot;.&quot;,&quot;..-.&quot;,&quot;--.&quot;,&quot;....&quot;,&quot;..&quot;,&quot;.---&quot;,&quot;-.-&quot;,&quot;.-..&quot;,&quot;--&quot;,&quot;-.&quot;,&quot;---&quot;,&quot;.--.&quot;,&quot;--.-&quot;,&quot;.-.&quot;,&quot;...&quot;,&quot;-&quot;,&quot;..-&quot;,&quot;...-&quot;,&quot;.--&quot;,&quot;-..-&quot;,&quot;-.--&quot;,&quot;--..&quot;]</span><br></pre></td></tr></table></figure><p>Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, “cab” can be written as “-.-.-….-“, (which is the concatenation “-.-.” + “-…” + “.-“). We’ll call such a concatenation, the transformation of a word.</p><p>Return the number of different transformations among all words we have.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line">Input: words = [&quot;gin&quot;, &quot;zen&quot;, &quot;gig&quot;, &quot;msg&quot;]</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: </span><br><span class="line">The transformation of each word is:</span><br><span class="line">&quot;gin&quot; -&gt; &quot;--...-.&quot;</span><br><span class="line">&quot;zen&quot; -&gt; &quot;--...-.&quot;</span><br><span class="line">&quot;gig&quot; -&gt; &quot;--...--.&quot;</span><br><span class="line">&quot;msg&quot; -&gt; &quot;--...--.&quot;</span><br><span class="line"></span><br><span class="line">There are 2 different transformations, &quot;--...-.&quot; and &quot;--...--.&quot;.</span><br></pre></td></tr></table></figure><p>Note:</p><ul><li>The length of <code>words</code> will be at most <code>100</code>.</li><li>Each <code>words[i]</code> will have length in range <code>[1, 12]</code>.</li><li><code>words[i]</code> will only consist of lowercase letters.</li></ul><h2 id="Java-Code"><a href="#Java-Code" class="headerlink" title="Java Code"></a>Java Code</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniqueMorseRepresentations</span><span class="params">(String[] words)</span></span>&#123;</span><br><span class="line">        String[] Morse=&#123;<span class="string">".-"</span>,<span class="string">"-..."</span>,<span class="string">"-.-."</span>,<span class="string">"-.."</span>,<span class="string">"."</span>,<span class="string">"..-."</span>,<span class="string">"--."</span>,<span class="string">"...."</span>,<span class="string">".."</span>,<span class="string">".---"</span>,<span class="string">"-.-"</span>,<span class="string">".-.."</span>,<span class="string">"--"</span>,<span class="string">"-."</span>,<span class="string">"---"</span>,<span class="string">".--."</span>,<span class="string">"--.-"</span>,<span class="string">".-."</span>,<span class="string">"..."</span>,<span class="string">"-"</span>,<span class="string">"..-"</span>,<span class="string">"...-"</span>,<span class="string">".--"</span>,<span class="string">"-..-"</span>,<span class="string">"-.--"</span>,<span class="string">"--.."</span>&#125;;</span><br><span class="line">        Set&lt;String&gt; set = <span class="keyword">new</span> HashSet();</span><br><span class="line">        <span class="keyword">for</span>(String word : words)&#123;</span><br><span class="line">            StringBuilder code = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> c:word.toCharArray())&#123;</span><br><span class="line">                code.append(Morse[c-<span class="string">'a'</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(code.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> set.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用到的数据结构是<code>HashSet</code>，Set用来存放无序的、不重复的数据。</p>]]></content>
      
      <categories>
          
          <category> ACM </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>计算机专业修养</title>
      <link href="/blog/2018/09/19/2018-06-24-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E4%BF%AE%E5%85%BB/"/>
      <url>/blog/2018/09/19/2018-06-24-%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E4%BF%AE%E5%85%BB/</url>
      <content type="html"><![CDATA[]]></content>
      
      
    </entry>
    
    <entry>
      <title>《APUE》笔记--第二章：文件和目录</title>
      <link href="/blog/2018/09/19/2018-06-23-%E3%80%8AAPUE%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/"/>
      <url>/blog/2018/09/19/2018-06-23-%E3%80%8AAPUE%E3%80%8B%E7%AC%94%E8%AE%B0-%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95/</url>
      <content type="html"><![CDATA[<h2 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h2><ul><li>普通文件（regular file），包括文本文件和二进制文件。</li><li>目录文件（directory file），目录文件包含了其他文件的名字以及指向这些文件有关信息的指针，对一个目录文件具有读权限的任何进程都可以读该目录的内容，但只有内核才能写目录文件。</li><li>块特殊文件（block special file），块特殊文件提供对设备带缓冲的访问，每次访问以固定长度为单位进行。比如：磁盘。</li><li>字符特殊文件（character special file），字符特殊文件提供对设备不带缓冲的访问，每次访问长度可变。<strong>系统中的所有设备，要么是字符特殊文件，要么是块特殊文件</strong>。</li><li>FIFO（first in first out），FIFO用于进程间通信，有时也将其称为：命名管道（named pipe）。</li><li>套接字（socket），用于进程间的网络通信，也可用于在一台宿主机上进程之间的非网络通信。</li><li>符号链接（symbolic link），符号链接指向另一个文件。</li></ul><p>可以使用表4-1中的宏确定文件类型，m是<code>stat</code>结构体的<code>st_mode</code>成员变量，此变量存放文件类型信息，返回0表示假，返回非0表示真：</p><blockquote><p>表4-1    &lt;sys/stat.h&gt;中的文件类型宏</p></blockquote><table><thead><tr><th>宏</th><th>描述</th></tr></thead><tbody><tr><td>S_ISREG(m)</td><td>判断是否是普通文件</td></tr><tr><td>S_ISDIR(m)</td><td>判断是否是目录文件</td></tr><tr><td>S_ISCHR(m)</td><td>判断是否是字符特殊文件</td></tr><tr><td>S_ISBLK(m)</td><td>判断是否是块特殊文件</td></tr><tr><td>S_ISFIFO(m)</td><td>判断是否是FIFO</td></tr><tr><td>S_ISLNK(m)</td><td>判断是否是符号链接</td></tr><tr><td>S_ISSOCK(m)</td><td>判断是否是套接字</td></tr></tbody></table><p>POSIX.1允许实现将进程间通信（IPC，inter-process communication）对象（例如，消息队列和信号量等）表示为文件。表4-2中的宏可用来确定IPC对象的类型。这些宏的参数并非<code>st_mode</code>，而是指向<code>stat</code>结构体的指针。</p><blockquote><p>表4-2    &lt;sys/stat.h&gt;中的IPC类型宏</p></blockquote><table><thead><tr><th>宏</th><th>描述</th></tr></thead><tbody><tr><td>S_TYPEISMQ(buf)</td><td>判断是否是消息队列</td></tr><tr><td>S_TYPEISSEM(buf)</td><td>判断是否是信号量</td></tr><tr><td>S_TYPEISSHM(buf)</td><td>判断是否是共享存储对象</td></tr></tbody></table> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;apue.h&quot;</span><br><span class="line">int main(int argc, char *argv[])&#123;</span><br><span class="line">    int i;</span><br><span class="line">    struct stat buf;</span><br><span class="line">    char *ptr;</span><br><span class="line">    for(i=1;i&lt;argc;i++)&#123;</span><br><span class="line">        prinft(&quot;%s: &quot;,argv[i]);</span><br><span class="line">        if(lstat(argv[i], &amp;buf)&lt;0)&#123;</span><br><span class="line">            err_ret()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 《Advance Programming in the Unix Environment》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2018-06-12-《代码整洁之道》读书笔记-第3章-函数</title>
      <link href="/blog/2018/09/19/2018-06-12-%E3%80%8A%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0-%E5%87%BD%E6%95%B0/"/>
      <url>/blog/2018/09/19/2018-06-12-%E3%80%8A%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC3%E7%AB%A0-%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<p>在编程的早年岁月，系统由程序和子程序组成。后来，在Fortran和PL/1的年代，系统由程序、子程序和函数组成。如今，只有函数存活下来。函数是所有程序中的第一组代码。</p><blockquote><p>在计算机领域，很多问题都是历史原因引起的，比如千年虫。因为计算机的发展非常之迅速，特别是硬件行业的发展，使得原先的很多稀有资源：比如存储和算力变得越来越便宜。软件行业也就向着更平易近人、更大规模演进。</p></blockquote><p>看看下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">testableHtml</span><span class="params">(PageData pageData, <span class="keyword">boolean</span> includeSuiteSetup)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    WikiPage wikiPage = pageData.getWikiPage();</span><br><span class="line">    StringBuffer buffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    <span class="keyword">if</span> (pageData.hasAttribute(<span class="string">"Test"</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(includeSuiteSetup)&#123;</span><br><span class="line">            WikiPage suiteSetup = PageCrawlerImpl.getInheritedPage(SuiteResponder.SUITE_SETUP_NAME, wikiPage);</span><br><span class="line">            <span class="keyword">if</span>(suiteSetup != <span class="keyword">null</span>)&#123;</span><br><span class="line">                WikiPagePath pagePath = suiteSetup.getPageCrawler().getFullPath(suiteSetup);</span><br><span class="line">                String pagePathName = PathParser.render(pagePath);</span><br><span class="line">                buffer.append(<span class="string">"!include -setup ."</span>)</span><br><span class="line">                      .append(pagePathName)</span><br><span class="line">                      .append(<span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        WikiPage setup = PageCrawlerImpl.getInheritedPage(<span class="string">"SetUp"</span>, wikiPage);</span><br><span class="line">        <span class="keyword">if</span>(setup != <span class="keyword">null</span>)&#123;</span><br><span class="line">            WikiPagePath setupPath = wikiPage.getPageCrawler().getFullPath(setup);</span><br><span class="line">            String setupPathName = PathParser.render(setupPath);</span><br><span class="line">            buffer.append(<span class="string">"!include -setup ."</span>)</span><br><span class="line">                  .append(setupPathName)</span><br><span class="line">                  .append(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    buffer.append(pageData.getContent());</span><br><span class="line">    <span class="keyword">if</span>(pageData.hasAttribute(<span class="string">"Test"</span>))&#123;</span><br><span class="line">        WikiPage teardown = PageCrawlerImpl.getInheritedPage(<span class="string">"TearDown"</span>, wikiPage);</span><br><span class="line">        <span class="keyword">if</span>(teardown!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            WikiPagePath tearDownPath = wikiPage.getPageCrawler().getFullPath(teardown);</span><br><span class="line">            String tearDownPathName = PathParser.render(tearDownPath);</span><br><span class="line">            buffer.append(<span class="string">"!include -teardown ."</span>)</span><br><span class="line">                  .append(tearDownPathName)</span><br><span class="line">                  .append(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(includeSuiteSetup)&#123;</span><br><span class="line">            WikiPage suiteTeardown = PageCrawlerImpl.getInheritedPage(SuiteReponder.SUITE_TEARDOWN_NAME, wikiPage);</span><br><span class="line">            <span class="keyword">if</span>(suiteTeardown!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                WikiPagePath pagePath = suiteTeardown.getPageCrawler().getFullPath(suiteTeardown);</span><br><span class="line">                String pagePathName = PathParse.render(pagePath);</span><br><span class="line">                buffer.append(<span class="string">"!include -teardown ."</span>)</span><br><span class="line">                      .append(pagePathName)</span><br><span class="line">                      .append(<span class="string">"\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pageData.setContent(buffer.toString());</span><br><span class="line">    <span class="keyword">return</span> pageData.getHtml();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>搞懂这个函数了吗？大概没有。<strong>有太多事发生，有太多不懂层级的抽象。奇怪的字符串和函数调用，混以双重嵌套、用标识来控制的if语句等，不一而足。</strong></p><p>不过，只要做几个简单的方法抽离和重命名操作，加上一点点重构，就能在9行代码之内搞定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">renderPageWithSetupsAndTeardown</span><span class="params">(PageData pageData, <span class="keyword">boolean</span> isSuite)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isTestPage = pageData.hasAttribute(<span class="string">"Test"</span>);</span><br><span class="line">    <span class="keyword">if</span>(isTestPage)&#123;</span><br><span class="line">        WikiPage testPage = pageData.getWikiPage();</span><br><span class="line">        StringBuffer newPageContent = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        includeSetupPages(testPage, newPageContent, isSuite);</span><br><span class="line">        newPageContent.append(pageData.getContent());</span><br><span class="line">        includeTeardownPages(testPage, newPageContent, isSuite);</span><br><span class="line">        pageData.setContent(newPageContent.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pageData.getHtml();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除非你正在研究FitNesse，否则就理解不了所有细节。不过，你大概能明白，该函数包含把一些设置和拆解页放入一个测试页面，再渲染为HTML的操作。如果你熟悉JUnit，或许会想到，该函数归属于某个基于Web的测试框架。</p><h2 id="短小"><a href="#短小" class="headerlink" title="短小"></a>短小</h2><p><strong>函数的第一规则是要短小。第二条规则还要更短小</strong>。</p><h3 id="代码块和缩进"><a href="#代码块和缩进" class="headerlink" title="代码块和缩进"></a>代码块和缩进</h3><p>if语句、else语句、while语句等，其中的代码块应该只有一行。该行大抵应该是一个函数调用语句。这样不但能保持函数短小，而且，因为块内调用的函数拥有较具说明性的名称，从而增加了文档上的价值。</p><p>这也意味着函数不应该大到足以容纳嵌套结构。所以，函数的缩进层级不该多于一层或两层。当然，这样的函数易于阅读和理解。</p><h3 id="只做一件事"><a href="#只做一件事" class="headerlink" title="只做一件事"></a>只做一件事</h3><p>函数应该做一件事。做好这件事。只做这一件事。</p>]]></content>
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 《代码整洁之道》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码规范 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《代码整洁之道》读书笔记--第2章:有意义的命名</title>
      <link href="/blog/2018/06/10/%E3%80%8A%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC2%E7%AB%A0-%E6%9C%89%E6%84%8F%E4%B9%89%E7%9A%84%E5%91%BD%E5%90%8D/"/>
      <url>/blog/2018/06/10/%E3%80%8A%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC2%E7%AB%A0-%E6%9C%89%E6%84%8F%E4%B9%89%E7%9A%84%E5%91%BD%E5%90%8D/</url>
      <content type="html"><![CDATA[<p>我们写代码的时候需要不停的命名，项目、类、函数、变量 等等都要命名。而命名关乎程序的可读性，而程序的可读性又至关重要（代码是写给人看的）。</p><h2 id="名副其实"><a href="#名副其实" class="headerlink" title="名副其实"></a>名副其实</h2><p>一个很重要的原则是：<strong>如果命名需要注释来补充，那就不算名副其实。</strong></p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int d;  //消逝的时间，以日计</span><br></pre></td></tr></table></figure><p>名称<code>d</code>什么也没说，如果其他很多地方要用到这个变量那就十分糟糕了，因为用的人不一定想的起来<code>d</code>是什么意思（如果只是局部变量局部使用，那它的罪孽会轻一点，如果是全局变量或者类的成员变量那这简直就是大坑）。<strong>其实我们很容易发现，注释没法像好的命名一样方便，因为我们不会在写代码的时候看到一个不懂的命名就去找它的定义处的注释，这样会浪费很多时间。另外如果写成注释就还需要维护注释，如果注释和代码不一致的情况那就变成了一种误导。</strong>。所以好的命名就应该能自己说明自己是什么。</p><p>好的命名如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int elapsedTimeInDays;</span><br><span class="line">int daysSinceCreation;</span><br><span class="line">int daysSinceModification;</span><br><span class="line">int fileAgeInDays;</span><br></pre></td></tr></table></figure><p>下面我们看一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;<span class="keyword">int</span>[]&gt; getThem() &#123;</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; list1 = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] x : theList)&#123;</span><br><span class="line">        <span class="keyword">if</span> (x[<span class="number">0</span>] == <span class="number">4</span>)&#123;</span><br><span class="line">            list1.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码很糟糕，虽然里面没有复杂的表达式，空格和缩进中规中矩，只用到三个变量和两个常量，甚至没涉及到其他类或多态方法。但这段代码很难说清它在做什么。问题不在于代码的简洁度，而在于代码的 <strong>模糊度：即上下文在代码中未被明确体现的程度</strong>。比如随便提几个问题：</p><ol><li>theList 是什么类型的东西？</li><li>theList 零下标条目的意义是什么？</li><li>值4的意义是什么？</li><li>我们怎么使用返回的list1？</li></ol><p><strong>问题的答案没体现在代码段中，可那就是它们该在的地方！如果不是对上下文及其熟悉，我们根本无法知道这代码在做什么！</strong></p><p>比方说，我们在开发一种扫雷游戏，我们发现，盘面是名为 theList 的单元格列表，那就将其命名为：gameBoard。盘面上每个单元格都用一个简单数组表示。我们还发现，零下标条目是一种状态值，而这种状态值为4表示“已标记”。我们将代码修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;<span class="keyword">int</span>[]&gt; getFlaggedCells() &#123;</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; flaggedCells = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] cell : gameBoard)&#123;</span><br><span class="line">        <span class="keyword">if</span> (cell[STATE_VALUE] == FLAGGED)&#123;</span><br><span class="line">            flaggedCells.add(cell);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flaggedCells;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这下这段代码是什么功能，做了些什么工作简直一目了然。还可以进一步，不用int数组表示单元格，而是另写一个类。该类包括一个名副其实的函数（称为 isFlagged），从而掩盖住那个魔术数。</p><blockquote><p>魔术数，magic number：指使用不明其意的立即数，至少我们应该用一个常量来对这种立即数进行命名，赋予其意义。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Cell&gt; <span class="title">getFlaggedCells</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Cell&gt; flaggedCells = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Cell cell : gameBoard)&#123;</span><br><span class="line">        <span class="keyword">if</span> (cell.isFlagged())&#123;</span><br><span class="line">            flaggedCells.add(cell);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flaggedCells;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从int数组到Cell类，<strong>抽象程度又提高了，代码可重用性也就提高了</strong>。</p><h2 id="避免误导"><a href="#避免误导" class="headerlink" title="避免误导"></a>避免误导</h2><p>例如，hp、aix 和 sco 都不应该用作变量名，因为它们都是UNIX平台或类UNIX平台的专有名称。别用accountList来指称一组账号，除非它们真的是List类型，List一词对程序员来说有特殊的意义，如果包纳账号的容器并非是一个List，就会引起错误的判断（即便容器就是个List，最好也别在名称中写出容器的类型）。所以，用accountGroup或bunchOfAccounts，甚至直接用accounts都会好一些。</p><p><strong>提防使用不同之处较小的命名</strong>。想区分模块中某处的XYZControllerForEfficientHandlingOfStrings 和另一处的 XYZControllerForEfficentStorageOfStrings，会花多长时间呢？这两个词外形实在太相似了。我们很享受线代Java编程环境的自动代码完成特性，键入某个名称的前几个字母，就可以得到一列该名称的可能性，假如相似的名字依字母顺序放在一起，且差异很明显，那就会相当有助益。</p><blockquote><p>在某些字体里，1和l，0和O很难分清。要注意这种混淆。</p></blockquote><h2 id="做有意义的区分"><a href="#做有意义的区分" class="headerlink" title="做有意义的区分"></a>做有意义的区分</h2><p>如果程序员只是为满足编译器或解释器的需要而写代码，就会制造麻烦。例如，因为同一作用域内不能重名，你可能随手改掉其中一个命名，有时候干脆以错误的拼写充数，结果就是有人一不小心更正拼写错误，然后导致编译器出错。</p><p>例如class已经是关键字，就给变量命名为klass，clazz，还有this，命名成thiz。</p><p>以数字系列命名（a1, a2, …, aN）是以意义命名的对立面。试看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyChars</span><span class="params">(<span class="keyword">char</span> a1[], <span class="keyword">char</span> a2[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a1.length;i++)&#123;</span><br><span class="line">        a2[i] = a1[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果参数名改为 <code>source</code> 和 <code>destination</code>，这个函数就会像样许多。</p><p><strong>废话是另一种没意义的区分</strong>。假设你有一个 Product 类。如果还有一个 ProductInfo 或 ProductData 类，那它们的名称虽然不同，意思却并无区别。Info和Data就像a、an和the一样是意义含混的废话。<br>注意，只要体现出有意义的区分，使用a和the这样的前缀就没错。例如，你可能把a用在域内变量，而把the用于函数参数。但如果你已经有一个名为zork的变量，又想调用一个名为theZork的变量，麻烦就来了。</p><p>废话都是冗余。Variable一词永远不应当出现在变量名中。Table一词永远不应当出现在表名中。NameString会比Name好吗？难倒Name会是一个浮点数不成？如果是这样，就触犯了关于误导的规则。设想有个名为Customer的类，还有一个名为CustomerObject的类。区别何在呢？哪个是表示客户历史支付情况的最佳途径？</p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getActiveAccount();</span><br><span class="line">getActiveAccounts();</span><br><span class="line">getActiveAccountInfo();</span><br></pre></td></tr></table></figure><p>程序员怎么知道该调用哪个函数呢？</p><p>如果缺少明确约定，变量moneyAmount就与money没区别，customerInfo与custmoer没区别，accountData与account没区别，theMessage也与message没区别。<strong>要区分名称，就要以读者能鉴别不同之处的方式来区分</strong>。</p><h2 id="使用读的出来的名称"><a href="#使用读的出来的名称" class="headerlink" title="使用读的出来的名称"></a>使用读的出来的名称</h2><p>人类长于记忆和使用单词，若不善加利用，实在是种耻辱。</p><p><strong>如果名称读不出来，讨论的时候会像个傻鸟</strong>。“哎，这儿，鼻涕阿三喜摁踢（bee cee arr three cee enn tee， BCR3CNT的读音）上头，有个皮挨死极翘（pee ess zee kyew）整数，看见没？” <strong>这不是小事，因为编程本就是一种社会活动</strong>。</p><p>有家公司，程序里面写了个 genymdhms（生成日期，年、月、日、时、分、秒），他们一般读作：“gen why emm dee aich emm ess”，YMDHMS的读音。我有个见字照读的恶习，于是开口就念“gen-yah-mudda-hims”。后来好些设计师和分析师都有样学样，听起来傻乎乎。我们知道典故，所以觉得很搞笑。搞笑归搞笑，实际是在强忍糟糕的命名。在给新开发者解释变量的意义时，他们总是读出傻乎乎的自造词，而非恰当的英语词。比较：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DtaRcrd102</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Date genymdhms;</span><br><span class="line">    <span class="keyword">private</span> Date modymdhms;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String pszqint = <span class="string">"102"</span>;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> Date generationTimestamp;</span><br><span class="line">    <span class="keyword">private</span> Date modificationTimestamp;</span><br><span class="line">    <span class="keyword">private</span> final String recordId = <span class="string">"102"</span>;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在读起来就像人话了：“喂，Mikey，看看这条记录！生成时间戳（generation timestamp）被设置为明天了！不能这样吧？”</p><h2 id="使用可搜索的名称"><a href="#使用可搜索的名称" class="headerlink" title="使用可搜索的名称"></a>使用可搜索的名称</h2><p>单字母名称和数字常量有个问题，就是很难在一大篇文字中找出来。</p><h2 id="避免使用编码"><a href="#避免使用编码" class="headerlink" title="避免使用编码"></a>避免使用编码</h2><p>编码已经太多，无谓再自找麻烦。把类型或作用域编进名称里面，徒然增加了解码的负担。没理由要求每位新人都在弄清要应付的编码之外（那算是正常的），还要再搞懂另一套编码“语言”。这对于解决问题而言，纯属多余的负担。带编码的名称通常也不便发音，容易打错。</p><h3 id="匈牙利命名法"><a href="#匈牙利命名法" class="headerlink" title="匈牙利命名法"></a>匈牙利命名法</h3><p>在往昔名称长短很要命的时代，我们毫无必要的破坏了不编码的规矩，如今后悔不迭。Fortran语言要求首字母体现出类型，导致了编码的产生。BASIC早期版本只允许使用一个字母再加一位数字。匈牙利命名法（Hungarian Notation，HN）将这种态势愈演愈烈。</p><p>在Windows的C语言API的时代，HN相当重要，那时所有名称要么是个整数句柄，要么是个长指针或者void指针，要不然就是string的几种实现（有不同的用途和属性）之一。那时候编译器并不做类型检查，程序员需要匈牙利命名法来帮助自己记住类型。</p><p>现代编程语言具有更丰富的类型系统，编译器也记得并强制使用类型。而且，人们趋向于使用更小的类、更短的方法，好让每个变量的定义都在视野范围内。</p><p>Java程序员不需要类型编码。对象是强类型的，代码编辑环境已经先进到在编译开始前就侦测到类型错误的程度！所以，如今HN和其他类型编码形式都纯属多余。它们增加了修改变量、函数或类的名称或类型的难度。它们增加了阅读代码的难度。它们制造了让编码系统误导读者的可能性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PhoneNumber phoneString;    // 类型变化时，名称并不会自动变化，若名称中编码了类型，还要我们手动去改。</span><br></pre></td></tr></table></figure><h3 id="成员前缀"><a href="#成员前缀" class="headerlink" title="成员前缀"></a>成员前缀</h3><p>也不必用m_前缀来标明成员变量。应当把类和函数做得足够小，消除对成员前缀的需要。你应当使用某种可以高亮或用颜色标出成员的编辑环境。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Part &#123;</span><br><span class="line">    private String m_dsc;   // The textual description</span><br><span class="line">    void setName(String name) &#123;</span><br><span class="line">        m_dsc = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Part</span></span>&#123;</span><br><span class="line">    String description;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setDescription</span><span class="params">(String description)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，人们会很快就学会无视前缀（或后缀），只看到名称中有意义的部分。代码读的越多，眼中就越没有前缀。最终，前缀变作了不入法眼的废料，变作了旧代码的标志物。</p><h3 id="接口和实现"><a href="#接口和实现" class="headerlink" title="接口和实现"></a>接口和实现</h3><p>有时也会出现采用编码的特殊情形。比如，你在做一个创建形态用的抽象工厂（Abstract Factory）。该工厂是个接口，要用具体类来实现。你怎么 命名工厂和具体类呢？IShapeFactory和ShapeFactory吗？我喜欢不加修饰的接口。前导字母I被滥用到了说好听点是干扰，说难听点根本就是废话的程度。我不想让用户知道我给他们的是接口。我就想让他们知道那是个ShapeFactory。如果接口和实现必须选一个来编码的话，我宁肯选择实现。ShapeFactoryImp，甚至是丑陋的CShapeFactory，都比对接口名称编码来得好。</p><h2 id="避免思维映射"><a href="#避免思维映射" class="headerlink" title="避免思维映射"></a>避免思维映射</h2><p>不应当让读者在脑海中把你的名称翻译为他们熟知的名称。这种问题经常出现在选择是使用问题领域术语还是解决方案领域术语时。</p><p>单字母变量名就是个问题。在作用域较小，也没有名称冲突时，循环计数器自然有可能被命名为i或j或k（但千万别用字母l）。这是因为传统上惯用单字母名称做循环计数器。然而，在多数其他情况下，单字母名称不是个好选择，读者必须在脑海中将它映射为真实概念。仅仅是因为有了a和b，就要取名为c，实在并非像样的理由。</p><p>程序员通常都是聪明人。聪明人有时会借脑筋急转弯炫耀其聪明。总而言之，假使你记得r代表不包含主机和图式（scheme）的小写字母版url的话，那你真是太聪明了。</p><p>聪明程序员和专业程序员之间的区别在于，专业程序员了解，明确是王道。专业程序员善用其能，编写其他人能理解的代码。</p><h2 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h2><p>类名和对象名应该是名词或名词短语，如Customer、WikiPage、Account和AddressParser。避免使用Manager、Processor、Data或Info这样的类名。类名不应当是动词。</p><blockquote><p>这里没看懂，举的例子并不是动词啊</p></blockquote><h2 id="方法名"><a href="#方法名" class="headerlink" title="方法名"></a>方法名</h2><p>方法名应当是动词或动词短语，如 postPayment、deletePage或save。属性访问器、修改器和断言应该根据其值命名，并依Javabean标准加上get、set和is前缀。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String name = employee.getName();</span><br><span class="line">customer.setName(<span class="string">"mike"</span>);</span><br><span class="line"><span class="keyword">if</span>(paycheck.isPosted())...</span><br></pre></td></tr></table></figure><p>重载构造器时，使用描述了参数的静态工厂方法名。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Complex fulcrumPoint = Complex.FromRealNumber(<span class="number">23.0</span>);</span><br></pre></td></tr></table></figure><p>通常好于</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Complex fulcrumPoint = <span class="keyword">new</span> Complex(<span class="number">23.0</span>);</span><br></pre></td></tr></table></figure><p>可以考虑将相应的构造器设置为private，强制使用这种命名手段。</p><h2 id="别扮可爱"><a href="#别扮可爱" class="headerlink" title="别扮可爱"></a>别扮可爱</h2><p>如果名称太耍宝，那就只有同作者一般有幽默感的人才能记得住，而且还是在他们记得那个笑话的时候才行。谁会知道名为HolyHandGrenade的函数是用来做什么的呢？没错，这名字挺伶俐，不过DeleteItems或许是更好的名称。宁可明确，毋为好玩。</p><p>扮可爱的做法在代码中经常体现为使用俗语或俚语。例如，别用whack()来表示kill()。别用eatMyShorts()这类与文化紧密相关的笑话来表示abort()。</p><h2 id="每个概念对应一个词"><a href="#每个概念对应一个词" class="headerlink" title="每个概念对应一个词"></a>每个概念对应一个词</h2><p>给每个抽象概念选一个词，并且一以贯之。例如，使用fetch、retrieve和get来给在多个类中的同种方法命名。你怎么记得住哪个类中是哪个方法呢？</p><p>Eclipse和Intellj之类的线代编程环境提供了与环境相关的线索，比如某个对象能调用的方法列表。不过要注意，列表中通常不会给出你为函数名和参数列表编写的注释。如果参数名称来自函数声明，你就太幸运了。函数名称应当独一无二，而且要保持一致，这样你才能不借助多余的浏览就能找到正确的方法。</p><p>同样，在同一堆代码中有controller，又有manager，还有driver，就会令人困惑。DeviceManager和Protocal-Controller之间有何根本区别？为什么不全用controllers或managers？他们都是Drivers吗？这种名称，让人觉得这两个对象是不同类型的，也分属不同的类。</p><p>对于那些会用到你代码的程序员，一以贯之的命名法简直就是天降福音。</p><h2 id="别用双关语"><a href="#别用双关语" class="headerlink" title="别用双关语"></a>别用双关语</h2><p>避免将同一个单词用于不同目的。如果遵循“一词一意”的规则，可能在好多类里面都会有add方法。只要这些add方法的参数列表和返回值在语义上等价，就一切顺利。</p><p>但是，可能会有人决定为“保持一致”而使用add这个词来命名，即便并非真的想表示这种意思。比如，在多个类种都有add方法，该方法通过增加或连接两个现存值来获得新值。假设要写个新类，该类中有一个方法，把单个参数放到群集（collection）中。该把这个方法叫做add吗？这样做貌似和其他add方法保持了一致，但实际上语义却不同，应该用insert或append之类的词来命名才对。把该方法命名为add，就是双关语了。</p><h2 id="使用解决方案领域的名称"><a href="#使用解决方案领域的名称" class="headerlink" title="使用解决方案领域的名称"></a>使用解决方案领域的名称</h2><p>记住，只有程序员才会读你的代码。所以，尽管用那些计算机科学（Computer Science, CS）术语、算法名、模式名、数学术语吧。</p><p>对于熟悉访问者（VISITOR）模式的程序来说，名称AccountVisitor富有意义。那个程序员会不知道JobQueue的意思呢？</p><h2 id="使用源自所涉及问题领域的名称"><a href="#使用源自所涉及问题领域的名称" class="headerlink" title="使用源自所涉及问题领域的名称"></a>使用源自所涉及问题领域的名称</h2><p>如果不能用程序员熟悉的术语来给手头的工作命名，就采用从所涉及领域而来的名称吧。至少，负责维护代码的程序员就能去请教领域专家了。</p><h2 id="添加有意义的语境"><a href="#添加有意义的语境" class="headerlink" title="添加有意义的语境"></a>添加有意义的语境</h2><p>很少有名称是能自我说明的–多数都不能。反之，你需要用有良好命名的类、函数或名称空间来放置名称，给读者提供语境。如果没这么做，给名称添加前缀就是最后一招了。</p><p>设想你有名为firstName、lastName、street、houseNumber、city\state和zipcode的变量。当它们搁一块儿的时候，很明确是构成了一个地址。不过，假使只是在某个方法中看见孤零零的一个state变量呢？你会理所当然推断那是某个地址的一部分吗？</p><p>可以添加前缀addrFirstName、addrLastName、addrState等，以此提供语境。至少，读者会明白这些变量都是某个更大结构的一部分。当然，更好的方案是创建名为Address的类。这样，即便是编译器也会知道这些变量隶属某个更大的概念了。</p><p>看一个例子：</p><p>语境不明确的变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printGuessStatistics</span><span class="params">(<span class="keyword">char</span> candidate, <span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">    String number;</span><br><span class="line">    String verb;</span><br><span class="line">    String pluralModifier;</span><br><span class="line">    <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">        number=<span class="string">"no"</span>;</span><br><span class="line">        verb=<span class="string">"are"</span>;</span><br><span class="line">        pluralModifier=<span class="string">"s"</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count==<span class="number">1</span>)&#123;</span><br><span class="line">        number=<span class="string">"1"</span>;</span><br><span class="line">        verb=<span class="string">"is"</span>;</span><br><span class="line">        pluralModifier=<span class="string">""</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        number=Integer.toString(count);</span><br><span class="line">        verb=<span class="string">"are"</span>;</span><br><span class="line">        pluralModifier=<span class="string">"s"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String guessMessage = String.format(</span><br><span class="line">        <span class="string">"There %s %s %s%s"</span>, verb, number, candidate, pluralModifier);</span><br><span class="line">    print(guessMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上列函数有点过长，变量的使用贯穿始终。要分解这个函数，需要创建一个名为GuessStatisticsMessage的类，把三个变量做成该类的成员字段。这样它们就在定义上变作了GuessStatisticsMessage的一部分。语境的增强也让算法能够通过分解为更小的函数而变得更为干净利落。</p><p>有语境的变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuessStatisticsMessage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String number;</span><br><span class="line">    <span class="keyword">private</span> String verb;</span><br><span class="line">    <span class="keyword">private</span> String pluralModifier;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">make</span><span class="params">(<span class="keyword">char</span> candidate, <span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">        createPluralDependentMessageParts(count);</span><br><span class="line">        <span class="keyword">return</span> String.format(</span><br><span class="line">            <span class="string">"There %s %s %s%s"</span>, verb, number, candidate, pluralModifier);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createPluralDependentMessageParts</span><span class="params">(<span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">            thereAreNoLetters();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (count==<span class="number">1</span>)&#123;</span><br><span class="line">            thereIsOneLetter();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            thereAreManyLetters(count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">thereAreManyLetters</span><span class="params">(<span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">        number = Integer.toString(count);</span><br><span class="line">        verb = <span class="string">"are"</span>;</span><br><span class="line">        pluralModifier=<span class="string">"s"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">thereIsOneLetters</span><span class="params">()</span></span>&#123;</span><br><span class="line">        number=<span class="string">"1"</span>;</span><br><span class="line">        verb = <span class="string">"is"</span>;</span><br><span class="line">        pluralModifier = <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">thereAreNoLetters</span><span class="params">()</span></span>&#123;</span><br><span class="line">        number = <span class="string">"no"</span>;</span><br><span class="line">        verb = <span class="string">"are"</span>;</span><br><span class="line">        pluralModifier = <span class="string">"s"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不要添加没用的语境"><a href="#不要添加没用的语境" class="headerlink" title="不要添加没用的语境"></a>不要添加没用的语境</h2><p>设若有一个名为“加油站豪华版”（Gas Station Deluxe）的应用，在其中给每个类添加GSD前缀就不是什么好点子。说白了，你是在和自己在用的工具过不去。输入G，按下自动完成键，结果会得到系统中全部类的列表，列表恨不得有一英里那么长。这样做聪明吗？为什么要搞得IDE没法帮助你？</p><p>再比如，你在GSD应用程序中的记账模块创建了一个表示邮件地址的类，然后给该类命名为GSDAccountAddress。稍后，你的客户联络应用中需要用到邮件地址，你会用GSDAccountAddress吗？这名字听起来没问题吗？在这17个字母里面，有10个字母纯属多余，与当前语境毫无关联。</p><p>只要短名称足够清楚，就要比长名称好。别给名称添加不必要的语境。</p><p>对于Address类的实体来说，accountAddress和customerAddress都是不错的名称，不过用在类名上就不太好了。Address是个好类名。如果需要与MAC地址、端口地址和Web地址相区别，我会考虑使用PostalAddress、MAC和URI。这样的名称更为精确，而精确正是命名的要点。</p>]]></content>
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 《代码整洁之道》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码规范 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux Shell 配色</title>
      <link href="/blog/2018/05/08/Linux-Shell-%E9%85%8D%E8%89%B2/"/>
      <url>/blog/2018/05/08/Linux-Shell-%E9%85%8D%E8%89%B2/</url>
      <content type="html"><![CDATA[<p>早就想自己给bash配个色，但是一直没空学习这方面的知识，今天抽个空，搞了一点点。</p><h2 id="切换shell"><a href="#切换shell" class="headerlink" title="切换shell"></a>切换shell</h2><p>切换shell，分临时和永久。</p><p>临时：输入命令：<code>bash</code>或者<code>zsh</code>都行，shell调用shell，一层套一层，按<code>ctrl+d</code>或者输入<code>exit</code>可以退出。<br>永久：输入命令：<code>chsh -s /bin/bash</code></p><blockquote><p>chsh意思就是change shell，使用<code>man chsh</code>进行查看</p></blockquote><h2 id="修改prompt"><a href="#修改prompt" class="headerlink" title="修改prompt"></a>修改prompt</h2><p>prompt也就是提示符，首先就是要修改这个，什么样的提示符才是一个好的提示符呢？我觉得首要的是要短，太长的提示符占了命令的空间。其次提示符还必须显示用户名和机器名，因为只有这样才能在你远程登录的时候与远程shell区分开。机器名最好是缩写。然后我就得出了我自己的提示符的前缀：<code>liuqinh2s@mbp</code>，然后我觉得得加个短路径，不要求绝对路径，这样太占空间，只需要加个当前文件夹即可。这样进一步修改之后，我的提示符变成了：<code>liuqinh2s@mbp:~</code>，最后需要添加一个普通用户和超级用户的区分，普通用户用：<code>$</code>，超级用户用<code>#</code>，所以我的提示符最终的样子是：<code>liuqinh2s@mbp:~$</code>，注意<code>$</code>后面我加了一个空格，这样看起来比较舒服，提示符和命令的界限一目了然。</p><p>但其实还是不清晰，我就给prompt上了个颜色。</p><p>最后就变成这样啦：</p><p><img src="https://i.loli.net/2018/05/08/5af13dcea3fa6.png" alt="屏幕快照 2018-05-08 下午2.03.34.png" title="屏幕快照 2018-05-08 下午2.03.34.png" width="30%" height="30%"></p><p>配置代码：<code>PS1=&quot;\[\e[0;32m\]\u@\h:\[\e[0;34m\]\W\$\[\e[0m\] &quot;</code></p><blockquote><p>使用<code>export PS1=&quot;\[\e[0;32m\]\u@\h:\[\e[0;34m\]\W\$\[\e[0m\] &quot;</code>，这样的话，你输入<code>bash</code>的时候，也能用到你的配置</p></blockquote><blockquote><p>export in sh and related shells (such as bash), marks an environment variable to be exported to child-processes, so that the child inherits them.</p></blockquote><p>export的作用就是让子进程也继承环境变量</p><p>如果你用的是mac的话，在home目录的<code>.bash_profile</code>中修改就可以了</p><p>下面是配置代码的讲解：</p><h3 id="Bash转义序列"><a href="#Bash转义序列" class="headerlink" title="Bash转义序列"></a>Bash转义序列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">\a     an ASCII bell character (07)</span><br><span class="line">\d     the date in &quot;Weekday Month Date&quot; format (e.g., &quot;Tue May 26&quot;)</span><br><span class="line">\D&#123;format&#125;</span><br><span class="line">       the format is passed to strftime(3) and the result is inserted into the prompt string; an empty format results in a locale-</span><br><span class="line">       specific time representation.  The braces are required</span><br><span class="line">\e     an ASCII escape character (033)</span><br><span class="line">\h     the hostname up to the first `.&apos;</span><br><span class="line">\H     the hostname</span><br><span class="line">\j     the number of jobs currently managed by the shell</span><br><span class="line">\l     the basename of the shell&apos;s terminal device name</span><br><span class="line">\n     newline</span><br><span class="line">\r     carriage return</span><br><span class="line">\s     the name of the shell, the basename of $0 (the portion following the final slash)</span><br><span class="line">\t     the current time in 24-hour HH:MM:SS format</span><br><span class="line">\T     the current time in 12-hour HH:MM:SS format</span><br><span class="line">\@     the current time in 12-hour am/pm format</span><br><span class="line">\A     the current time in 24-hour HH:MM format</span><br><span class="line">\u     the username of the current user</span><br><span class="line">\v     the version of bash (e.g., 2.00)</span><br><span class="line">\V     the release of bash, version + patch level (e.g., 2.00.0)</span><br><span class="line">\w     the current working directory, with $HOME abbreviated with a tilde (uses the value of the PROMPT_DIRTRIM variable)</span><br><span class="line">\W     the basename of the current working directory, with $HOME abbreviated with a tilde</span><br><span class="line">\!     the history number of this command</span><br><span class="line">\#     the command number of this command</span><br><span class="line">\$     if the effective UID is 0, a #, otherwise a $</span><br><span class="line">\nnn   the character corresponding to the octal number nnn</span><br><span class="line">\\     a backslash</span><br><span class="line">\[     begin a sequence of non-printing characters, which could be used to embed a terminal control sequence into the prompt</span><br><span class="line">\]     end a sequence of non-printing characters</span><br></pre></td></tr></table></figure><h3 id="变更prompt颜色"><a href="#变更prompt颜色" class="headerlink" title="变更prompt颜色"></a>变更prompt颜色</h3><p>首先，大家必须以[与]作为色彩代码的描述范围。对于Bash，这代表两个括号间的字符为非输出字符。</p><p>Bash需要在此基础上估算字符数量，以备后续输出。如果不将色彩代码纳入[与]之间，那么Bash会将全部字符都计为文本字符并在下一行中进行打包。</p><p>另外，在括号内的非输出序列中，我们需要输入\e[或者\033[指定彩色prompt的起点。二者的作用相同，都负责指定该反义序列的起始位置。</p><p>在]之前，我们还需要使用“m”来表示即将提供一条色彩序列。</p><p>基本上，每次进行色彩修改时，我们都需要输入下面这种命令格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\[\e[color_informationm\]</span><br></pre></td></tr></table></figure><p>下面来看用于变更前景文本颜色的基本代码：</p><ul><li>30: Black</li><li>31: Red</li><li>32: Green</li><li>33: Yellow</li><li>34: Blue</li><li>35: Purple</li><li>36: Cyan</li><li>37: White</li></ul><p>大家也可以通过在以上设定前设置“属性”修改这些基础值，各值之间以分号分隔。</p><p>根据实际终端的不同，操作效果也有所区别。部分常见属性包括：</p><ul><li>0: 普通文本</li><li>1: 在不同终端中可能代表粗体或者浅色显示</li><li>4: 下划线文本</li></ul><p>因此如果大家希望使用下划线绿色文本，则：<code>\[\e[4;32m\]</code></p><p>接下来继续正常使用即可。另外，我们也可以随时将色彩重置为初始值。</p><p>重置命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\[\e[0m\]</span><br></pre></td></tr></table></figure><p>我们也可以指定背景颜色。背景颜色无法获取属性，具体包括：</p><ul><li>40: Black background</li><li>41: Red background</li><li>42: Green background</li><li>43: Yellow background</li><li>44: Blue background</li><li>45: Purple background</li><li>46: Cyan background</li><li>47: White background</li></ul><p>不过大家可以一次性指定背景颜色、属性与文本颜色：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\[\e[42;1;36m\]</span><br></pre></td></tr></table></figure><p>当然，这里建议各位将背景信息与其它信息分隔开来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\[\e[42m\]\[\e[1;36m\]</span><br></pre></td></tr></table></figure><p>在使用普通文本属性（0）时，终端中可能出现一些乱码。如果遇到这种问题，大家最好避免使用0值指定普通属性——由于属于默认值，我们无需额外指定。</p><h2 id="配置ls和grep的颜色"><a href="#配置ls和grep的颜色" class="headerlink" title="配置ls和grep的颜色"></a>配置ls和grep的颜色</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Tell ls to be colourful</span><br><span class="line"> export CLICOLOR=1</span><br><span class="line"> export LSCOLORS=Exfxcxdxbxegedabagacad</span><br><span class="line"></span><br><span class="line"> # Tell grep to highlight matches</span><br><span class="line"> export GREP_OPTIONS=&apos;--color=auto’</span><br></pre></td></tr></table></figure><ul><li><p>CLICOLOR是用来设置是否进行颜色的显示。CLI是Command Line Interface的缩写。</p></li><li><p>LSCOLORS是用来设置当CLICOLOR被启用后，各种文件类型的颜色。LSCOLORS的值中每两个字母为一组，分别设置某个文件类型的文字颜色和背景颜色。LSCOLORS中一共11组颜色设置，按照先后顺序，分别对以下的文件类型进行设置：</p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1233651-e586f58eae66c4ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="文件类型 - 文件颜色"></p><p>所以，如果我们想把目录显示成红色，就可以把LSCOLORS设置为fxfxaxdxcxegedabagacad就可以了</p>]]></content>
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>对区块链以及未来的一些思考</title>
      <link href="/blog/2018/05/07/%E5%AF%B9%E5%8C%BA%E5%9D%97%E9%93%BE%E4%BB%A5%E5%8F%8A%E6%9C%AA%E6%9D%A5%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
      <url>/blog/2018/05/07/%E5%AF%B9%E5%8C%BA%E5%9D%97%E9%93%BE%E4%BB%A5%E5%8F%8A%E6%9C%AA%E6%9D%A5%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</url>
      <content type="html"><![CDATA[<p>有个用户痛点，我来描述一下：当你更改了手机号，it’s a disaster! 你需要改无数绑定的东西，比如：银行预留手机号，各类APP的绑定手机号，还要通知所有人你改了手机号，当然我现在换手机号也懒得通知别人了，除了还给我打电话的那几个人，现在大家都是用QQ和微信沟通了。</p><p>我说个笑话，不，其实这是个真实的故事，我曾今在深圳用过摩拜共享单车，当时绑定了我的手机号，后来我在杭州，并且手机号也换了，另外摩拜也加了个身份证验证。我就再也使用不了摩拜了，好像是因为手机号和身份证绑定了，我无法通过其他手机号使用摩拜了。摩拜让我交了200块钱押金，让我充了10块钱车费，最后却告诉我，我不能骑车。我只好申诉，申诉没起效果，最后我直接申请退款了，退款理由我写上了：无法实名认证。我希望以此能够催促摩拜尽早改好这个BUG，从而帮助到其他人吧。</p><p>还有就是各种证，从身份证开始，学位证，毕业证，结婚证，团员证，党员证，房产证。。。</p><p>还有一些事是大家都知道的，三鹿奶粉，三聚氰胺，地沟油，等等。</p><p>那么这些事之间有什么联系呢？</p><p>有，当然有，那就是：信任。</p><p>如何让别人信任你，如何让我们信任那些企业，如何做到一个账号上网，或者说不用麻烦的认证，你上网，网就认识你，从这个网站到那个网站，不需要繁琐的注册登陆。</p><p>区块链貌似能解决这个问题，如果我们的信息都放在一起，需要的时候就去查看，而且有严格的权限限制，那么我们就建立了一个统一的信息源。</p>]]></content>
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>用ipfs发布博客</title>
      <link href="/blog/2018/05/04/%E7%94%A8ipfs%E5%8F%91%E5%B8%83%E5%8D%9A%E5%AE%A2/"/>
      <url>/blog/2018/05/04/%E7%94%A8ipfs%E5%8F%91%E5%B8%83%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p>ipfs是一个p2p的网络</p><h2 id="常用ipfs命令"><a href="#常用ipfs命令" class="headerlink" title="常用ipfs命令"></a>常用ipfs命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ipfs add -r mysite</span><br><span class="line">// 通过上一步可以得到很多个哈希值（每个目录和文件都有一个），把根目录对应的哈希值拿出来用</span><br><span class="line">ipfs name publish QmZyenFLZtm9rk2B98ZqRAFYRkzhqyUruKBSsdZUnKk9ek</span><br></pre></td></tr></table></figure><p>第二步实际上是把这个站点的根目录映射到了你的 <code>ipfs id</code> 上面，你的这个id是固定的。之后你每次更新这个站点下的内容都要 <code>ipfs add -r mysite</code> 一次，然后把根目录对应的哈希值重新映射到你的 ipfs id 上。</p><p>然后你访问ipfs站点的时候，可以这样访问：<code>https://ipfs.io/ipns/your_ipfs_id</code>，如果你的浏览器装了ipfs插件就可以自动解析这个网址，从而直接用ipfs协议来访问站点了。</p><blockquote><p>注意your_ipfs_id是指你的ipfs id，你可以用命令<code>ipfs id</code>查看你的id是什么，相信我的读者不会蠢到直接复制粘贴your_ipfs_id。</p></blockquote><h2 id="hexo生成的博客，缺失css和js的问题"><a href="#hexo生成的博客，缺失css和js的问题" class="headerlink" title="hexo生成的博客，缺失css和js的问题"></a>hexo生成的博客，缺失css和js的问题</h2><p>在hexo的config里面，有个root，这个root就是用来给css和js等资源指定目录的，所以你要改成：<code>/ipns/your_ipfs_id/</code></p><p>如果你想同时在git pages上面，和ipfs上面发布你的博客，那么root这个属性必定就冲突了，因为在git pages上面发布的时候，直接填<code>/</code>就行了（他是直接发布在像：<code>liuqinh2s.github.io</code>，这个域名后面，也就是子域名的根目录，不像ipfs那样会加个<code>/ipns/your_ipfs_id</code>这种目录）。那么你就只能搞两个博客工程了，新发布博客的时候，就要同时修改两个地方。</p><p>比如我是这样做的，我建了一个ipfs文件夹，里面存放我所有发布在ipfs上的资源，所以我会把我的博客复制一份到这个文件夹里面，更新博客的时候，复制一份博客文件到这边，git pages那边要发布一次，然后ipfs这边也要发布一次。</p><p>访问我的ipfs站点：<a href="https://ipfs.io/ipns/QmT7mga4wwTLNFCrtt1FbvLgmxTWZyKGRsrnFZNMoHdEJa/" target="_blank" rel="noopener">https://ipfs.io/ipns/QmT7mga4wwTLNFCrtt1FbvLgmxTWZyKGRsrnFZNMoHdEJa/</a></p><h2 id="使用脚本自动化push"><a href="#使用脚本自动化push" class="headerlink" title="使用脚本自动化push"></a>使用脚本自动化push</h2><p>为了实现自动push，我自己写了个脚本，可以同时把博客push到git pages和ipfs上：<a href="https://gist.github.com/liuqinh2s/0864ed7799b161bb2f048b4fab867d5a" target="_blank" rel="noopener">https://gist.github.com/liuqinh2s/0864ed7799b161bb2f048b4fab867d5a</a></p><p>在你的博客目录下新建一个<code>push.sh</code>，然后把代码复制粘贴，保存，以后每次push的时候执行：<code>bash push.sh</code></p>]]></content>
      
      <categories>
          
          <category> 区块链 </category>
          
          <category> ipfs </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Volley库StringRequest编码问题</title>
      <link href="/blog/2018/05/03/Volley%E5%BA%93StringRequest%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/"/>
      <url>/blog/2018/05/03/Volley%E5%BA%93StringRequest%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>最近在做的一个工作是：从一个URL地址读取一系列手机联系人资料，保持到手机通讯录里面。</p><p>项目使用了Volley库，FastJson库，遇到的一个bug是编码错误，FastJson在进行从String到bean的解析的时候，编码不正确导致的出错，这个时候，先检查了URL的编码是UTF-8的，然后Android Studio的程序源文件也是UTF-8的，那就只有一个可能了，网络传输过程中的编码错误。</p><p>google一下发现早就有人在stackoverflow上问过这个问题了：</p><blockquote><p>How to get Android Volley StringRequest GET to return responses in UTF-8 encoding</p></blockquote><p>How can I get Android Volley StringRequest GET to return responses in UTF-8 encoding? It only seems to return responses in ISO-8859-1.</p><p>Is it possible to get it to accept a UTF-8 string?</p><p>StringRequest call HttpHeaderParser.parseCharset(response.headers) to get charset from response headers, is ‘Content-Type’ in headers don`t contains ‘charset’ the default charset return as ‘ISO-8859-1’.</p><p>StringRequest.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Response&lt;String&gt; <span class="title">parseNetworkResponse</span><span class="params">(NetworkResponse response)</span> </span>&#123;</span><br><span class="line">    String parsed;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        parsed = <span class="keyword">new</span> String(response.data, HttpHeaderParser.parseCharset(response.headers));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException var4) &#123;</span><br><span class="line">        parsed = <span class="keyword">new</span> String(response.data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Response.success(parsed, HttpHeaderParser.parseCacheHeaders(response));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HttpHeaderParser.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">parseCharset</span><span class="params">(Map&lt;String, String&gt; headers, String defaultCharset)</span> </span>&#123;</span><br><span class="line">    String contentType = headers.get(HTTP.CONTENT_TYPE);</span><br><span class="line">    <span class="keyword">if</span> (contentType != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String[] params = contentType.split(<span class="string">";"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; params.length; i++) &#123;</span><br><span class="line">            String[] pair = params[i].trim().split(<span class="string">"="</span>);</span><br><span class="line">            <span class="keyword">if</span> (pair.length == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pair[<span class="number">0</span>].equals(<span class="string">"charset"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> pair[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> defaultCharset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the charset specified in the Content-Type of this header,</span></span><br><span class="line"><span class="comment"> * or the HTTP default (ISO-8859-1) if none can be found.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">parseCharset</span><span class="params">(Map&lt;String, String&gt; headers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> parseCharset(headers, HTTP.DEFAULT_CONTENT_CHARSET);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>so, you can parse to ‘UTF-8’ in 2 ways:</p><ol><li>tell your webServer to add ‘Content-Type’ with ‘charset=UTF-8’ in headers</li><li>Create a subclass of StringRequest and override parseNetworkResponse method</li></ol><p>意思是定制一个<code>MyStringRequest</code>类，继承<code>StringRequest</code>类，重载<code>parseNetworkResponse</code>即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Response&lt;String&gt; <span class="title">parseNetworkResponse</span><span class="params">(NetworkResponse response)</span> </span>&#123;</span><br><span class="line">    String parsed;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        parsed = <span class="keyword">new</span> String(response.data, <span class="string">"utf-8"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException var4) &#123;</span><br><span class="line">        parsed = <span class="keyword">new</span> String(response.data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Response.success(parsed, HttpHeaderParser.parseCacheHeaders(response));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Android </category>
          
          <category> Volley库 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Android通讯录深入研究</title>
      <link href="/blog/2018/05/03/Android%E9%80%9A%E8%AE%AF%E5%BD%95%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6/"/>
      <url>/blog/2018/05/03/Android%E9%80%9A%E8%AE%AF%E5%BD%95%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6/</url>
      <content type="html"><![CDATA[<p>The <code>DISPLAY_NAME</code> can be fetched either from Contacts <code>database/ContactsContract.Data&#39; OR &#39;database/ContactsContract.CommonDataKinds.StructuredName&#39; OR &#39;database/RawContactsEntity</code>. In the later 2 cases you will be able to fetch the <code>DISPLAY_NAME</code> using <code>RAW_CONTACT_ID</code></p><p>Couple of Key pointers:</p><ul><li>Contacts._ID = Data.CONTACT_ID</li><li>RawContacts._ID = Data.RAW_CONTACT_ID</li><li>RawContacts.CONTACT_ID = Contacts._ID</li><li>RawContactsEntity._ID = RawContacts._ID</li></ul><p>Sounds confusing?? Let me try…</p><ol><li>The Contacts database is divided into 3 tables <code>contacts</code>, <code>raw contacts</code>, and <code>data</code>.</li><li>Each table contains column (_ID) which is an auto incremented primary key.</li><li>data table contains all the contact info like phone number, mail id, address etc.</li><li>The raw contacts points to the actual contact created. Hence we use the raw contacts while adding a contact.</li><li>The user cannot add any data in the contacts table. The data in this table is populated internally due to aggregation of contacts.</li><li>The reason your logic worked for some of the contacts is: _ID for contacts, raw contacts remains same until there is any contact aggregation taking place. Lets say you add two contacts with same name abc. Here the _ID for raw contacts increments twice while _ID for contacts increments only once as these two contacts gets merged due to the aggregation of contacts</li></ol><p>The best approach to fetch the info in your case is by using <code>ContactsContract.RawContactsEntity</code> ( an outer join of the raw_contacts table with the data table)</p><p>这里还有一篇文章，写的比较详细：<a href="http://android-contact-id-vs-raw-contact-id.blogspot.jp/" target="_blank" rel="noopener">http://android-contact-id-vs-raw-contact-id.blogspot.jp/</a></p><p>官方文档：</p><ul><li><a href="https://developer.android.com/reference/android/provider/ContactsContract" target="_blank" rel="noopener">https://developer.android.com/reference/android/provider/ContactsContract</a></li><li><a href="https://developer.android.com/reference/android/provider/ContactsContract.Data" target="_blank" rel="noopener">https://developer.android.com/reference/android/provider/ContactsContract.Data</a></li></ul>]]></content>
      
      <categories>
          
          <category> Android </category>
          
          <category> 通讯录 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java Servlet 学习笔记</title>
      <link href="/blog/2018/05/01/Java-Servlet-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/blog/2018/05/01/Java-Servlet-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<blockquote><p>The difference between servlets and JSP is that servlets typically embed HTML inside Java code, while JSPs embed Java code in HTML.</p></blockquote><p>不过现在都是用MVC框架了。</p><h2 id="life-cycle-of-a-servlet"><a href="#life-cycle-of-a-servlet" class="headerlink" title="life cycle of a servlet"></a>life cycle of a servlet</h2><p>Three methods are central to the life cycle of a servlet. These are <code>init()</code>, <code>service()</code>, and <code>destroy()</code>. They are implemented by every servlet and are invoked at specific times by the server.</p><ul><li>the web container initializes the servlet instance by calling the init() method, passing an object implementing the <code>javax.servlet.ServletConfig</code> interface. This configuration object allows the servlet to access name-value initialization parameters from the web application.</li><li>Each request is serviced in its own separate thread. The web container calls the service() method of the servlet for every request. The developer of the servlet must provide an implementation for these methods.</li><li>Finally, the web container calls the destroy() method that takes the servlet out of service. The destroy() method, like init(), is called only once in the lifecycle of a servlet.</li></ul><p>The following is a typical user scenario of these methods.</p><ol><li>Assume that a user requests to visit a URL.<ul><li>The browser then generates an HTTP request for this URL.</li><li>This request is then sent to the appropriate server.</li></ul></li><li>The HTTP request is received by the web server and forwarded to the servlet container.<ul><li>The container maps this request to a particular servlet.</li><li>The servlet is dynamically retrieved and loaded into the address space of the container.</li></ul></li><li>The container invokes the <code>init()</code> method of the servlet.<ul><li><strong>This method is invoked only when the servlet is first loaded into memory.</strong></li><li>It is possible to pass initialization parameters to the servlet so that it may configure itself.</li></ul></li><li>The container invokes the <code>service()</code> method of the servlet.<ul><li>This method is called to process the HTTP request.</li><li>The servlet may read data that has been provided in the HTTP request.</li><li>The servlet may also formulate an HTTP response for the client.</li></ul></li><li>The servlet remains in the container’s address space and is available to process any other HTTP requests received from clients.<ul><li><strong>The service() method is called for each HTTP request.</strong></li></ul></li><li>The container may, at some point, decide to unload the servlet from its memory.<ul><li>The algorithms by which this decision is made are specific to each container.</li></ul></li><li>The container calls the servlet’s destroy() method to relinquish any resources such as file handles that are allocated for the servlet; important data may be saved to a persistent store.</li><li>The memory allocated for the servlet and its objects can then be garbage collected.</li></ol><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>The following example servlet prints how many times its <code>service()</code> method was called.</p><p>Note that <code>HttpServlet</code> is a subclass of <code>GenericServlet</code>, an implementation of the <code>Servlet</code> interface.</p><p>The <code>service()</code> method of <code>HttpServlet</code> class dispatches requests to the methods <code>doGet()</code>, <code>doPost()</code>, <code>doPut()</code>, <code>doDelete()</code>, and so on; according to the HTTP request. In the example below <code>service()</code> is overridden and does not distinguish which HTTP request method it serves.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletConfig;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletLifeCycleExample</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">final</span> ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.init(config);</span><br><span class="line">        getServletContext().log(<span class="string">"init() called"</span>);</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(<span class="keyword">final</span> HttpServletRequest request, <span class="keyword">final</span> HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        getServletContext().log(<span class="string">"service() called"</span>);</span><br><span class="line">        count++;</span><br><span class="line">        response.getWriter().write(<span class="string">"Incrementing the count to "</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        getServletContext().log(<span class="string">"destroy() called"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>javax是什么？</p></blockquote><p>java和javax都是Java的API(Application Programming Interface)包，java是核心包，<strong>javax的x是extension的意思，也就是扩展包</strong>。java类库是java发布之初就确定了的基础库，而javax类库则是在上面增加的一层东西，就是为了保持版本兼容要保存原来的，但有些东西有了更好的解决方案，所以，就加上些，典型的就是awt(Abstract Windowing ToolKit) 和swing。</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
          <category> Java web </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>mathjax常用公式记录</title>
      <link href="/blog/2018/04/30/mathjax%E5%B8%B8%E7%94%A8%E5%85%AC%E5%BC%8F%E8%AE%B0%E5%BD%95/"/>
      <url>/blog/2018/04/30/mathjax%E5%B8%B8%E7%94%A8%E5%85%AC%E5%BC%8F%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<h2 id="角度记法"><a href="#角度记法" class="headerlink" title="角度记法"></a>角度记法</h2><ul><li>度数：<code>$60^\circ$</code>，$60^\circ$</li><li>度数分：<code>$60^\prime$</code>，$60^\prime$</li><li>弧度：<code>$\frac{\pi}{2}$</code>，$\frac{\pi}{2}$</li><li>角度记法：<code>$\angle A$</code>，$\angle A$</li></ul>]]></content>
      
      <categories>
          
          <category> LaTex </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>椭圆规</title>
      <link href="/blog/2018/04/30/%E6%A4%AD%E5%9C%86%E8%A7%84/"/>
      <url>/blog/2018/04/30/%E6%A4%AD%E5%9C%86%E8%A7%84/</url>
      <content type="html"><![CDATA[<h2 id="利用简单定义的椭圆规"><a href="#利用简单定义的椭圆规" class="headerlink" title="利用简单定义的椭圆规"></a>利用简单定义的椭圆规</h2><p>椭圆大家高中的时候都学过，椭圆有两个中心，椭圆轨迹上的点到这两个中心的距离加起来就是长轴的长度。</p><p><img src="http://highscope.ch.ntu.edu.tw/wordpress/wp-content/uploads/2011/01/EasyCapture1105.bmp" alt="利用简单定义的椭圆规"></p><h2 id="利用参数式的椭圆规"><a href="#利用参数式的椭圆规" class="headerlink" title="利用参数式的椭圆规"></a>利用参数式的椭圆规</h2><p><img src="http://highscope.ch.ntu.edu.tw/wordpress/wp-content/uploads/2011/01/EasyCapture1101.bmp" alt="利用参数式的椭圆规"></p><p>$\overline{AP}=a$，$\overline{BP}=b$，P点所绘制的就是椭圆了。画圆规时先固定十字底座，旋转时A点保持在纵轴滑动，B点保持在横轴滑动，当规臂完成$360^\circ$时，P点的轨迹即为椭圆，且此椭圆的长半轴是 a，短半轴是 b。</p><p>下面讲讲原理：</p><p><img src="http://highscope.ch.ntu.edu.tw/wordpress/wp-content/uploads/2011/01/EasyCapture1102.bmp" alt="参数式椭圆规原理"></p><p>若以十字中心为原点，十字横向为x轴，纵向为y轴，设定一个直角坐标系，并设 $\theta$ 为以x轴为始边，规臂$\overline{AP}$为终边的广义角，不难看出来P点的坐标是 $(a\cos\theta, b\sin\theta)$，即方程式为：$\frac{x^2}{a^2}+\frac{y^2}{b^2}=1$ 的椭圆方程式。其中a为长半轴的长度，b为短半轴的长度。</p>]]></content>
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 解析几何 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Leetcode Algorithm 274. H-Index</title>
      <link href="/blog/2018/04/30/Leetcode-Algorithm-274.H-Index/"/>
      <url>/blog/2018/04/30/Leetcode-Algorithm-274.H-Index/</url>
      <content type="html"><![CDATA[<p>Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher’s h-index.</p><p>According to the <a href="https://en.wikipedia.org/wiki/H-index" target="_blank" rel="noopener">definition of h-index on Wikipedia</a>: “A scientist has index h if h of his/her N papers have <strong>at least</strong> h citations each, and the other N − h papers have <strong>no more than</strong> h citations each.”</p><p>For example, given <code>citations = [3, 0, 6, 1, 5]</code>, which means the researcher has <code>5</code> papers in total and each of them had received <code>3, 0, 6, 1, 5</code> citations respectively. Since the researcher has <code>3</code> papers with <strong>at least</strong> <code>3</code> citations each and the remaining two with <strong>no more than</strong> <code>3</code> citations each, his h-index is <code>3</code>.</p><p><strong>Note:</strong> If there are several possible values for <code>h</code>, the maximum one is taken as the h-index.</p><p><strong>Credits:</strong><br>Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.</p><p>看了维基百科的解说之后，我发现这题还是挺简单的，思路就是排序，如果用C++解这题，我就直接用std::sort了。</p><p>C++代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; citations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(citations.size()&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::sort(citations.begin(), citations.end(), compare);</span><br><span class="line">        <span class="keyword">int</span> result = citations[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;citations.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;citations[i])&#123;</span><br><span class="line">                result = i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i&gt;j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> ACM </category>
          
          <category> Leetcode </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>UML图</title>
      <link href="/blog/2018/04/28/UML%E5%9B%BE/"/>
      <url>/blog/2018/04/28/UML%E5%9B%BE/</url>
      <content type="html"><![CDATA[<h2 id="从一个示例开始看懂UML图"><a href="#从一个示例开始看懂UML图" class="headerlink" title="从一个示例开始看懂UML图"></a>从一个示例开始看懂UML图</h2><p>请看下面这个类图，类之间的关系是我们需要关注的：</p><p><img src="http://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_class_struct.jpg" alt=""></p><ul><li>车的类图结构为abstract，代表车是一个抽象类</li><li>它有两个继承类：小汽车和自行车，它们之间的关系为实现关系，使用带空心箭头的虚线表示</li><li>小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示</li><li>小汽车与发动机之间是组合关系，使用带实心箭头的实线表示</li><li>学生与班级之间是聚合关系，使用带空心箭头的实线表示</li><li>学生与身份证之间为关联关系，使用一根实线表示</li><li>学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示</li></ul><p>下面我们将介绍这六种关系：</p><h2 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h2><h3 id="泛化关系（generalization）"><a href="#泛化关系（generalization）" class="headerlink" title="泛化关系（generalization）"></a>泛化关系（generalization）</h3><p>类的继承结构表现在UML中为：泛化（generalize）与实现（realize）：</p><p>继承关系为 <code>is-a</code> 的关系，两个对象之间如果可以用 <code>is-a</code> 来表示，就是继承关系</p><p>eg: 自行车是车，猫是动物</p><p>泛化关系用一条带空心箭头的直接表示，如下图表示（A继承自B）</p><p><img src="http://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_generalization.jpg" alt=""></p><p>eg：汽车在现实中有实现，可用汽车定义具体的对象；汽车与SUV之间为泛化关系；</p><p><img src="http://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_generalize.jpg" alt=""></p><p>注：最终代码中，<strong>泛化关系表现为继承非抽象类</strong>；</p><h3 id="实现关系（realize）"><a href="#实现关系（realize）" class="headerlink" title="实现关系（realize）"></a>实现关系（realize）</h3><p>实现关系用一条带空心箭头的虚线表示；</p><p>eg: “车”为一个抽象的概念，在现实中并无法直接用来定义对象，只有指明具体的子类（汽车还是自行车），才可以用来定义对象（“车”这个类在C++中用抽象类表示，在Java中有接口这个概念，更容易理解）</p><p><img src="http://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_realize.jpg" alt=""></p><p>注：最终代码中，<strong>实现关系表现为继承抽象类</strong>；</p><h3 id="聚合关系（aggregation）"><a href="#聚合关系（aggregation）" class="headerlink" title="聚合关系（aggregation）"></a>聚合关系（aggregation）</h3><p>聚合关系用一条带空心菱形箭头的直线表示，如下图表示A聚合到B上，或者说B由A组成；</p><p><img src="http://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_aggregation.jpg" alt=""></p><p>聚合关系用于表示实体对象之间的关系，表示整体由部分构成的语义；例如一个部门由多个员工组成；</p><blockquote><p>与组合关系不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在；例如，部门撤销了，人员不会消失，他们依然存在；</p></blockquote><h3 id="组合关系（composition）"><a href="#组合关系（composition）" class="headerlink" title="组合关系（composition）"></a>组合关系（composition）</h3><p>组合关系用一条带实心菱形箭头直线表示，如下图表示A组成B，或者B由A组成；</p><p><img src="http://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_composition.jpg" alt=""></p><p>与聚合关系一样，组合关系同样表示整体由部分构成的语义；比如公司由多个部门组成；</p><blockquote><p>但组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在了；例如， 公司不存在了，部门也将不存在了；</p></blockquote><h3 id="关联关系（association）"><a href="#关联关系（association）" class="headerlink" title="关联关系（association）"></a>关联关系（association）</h3><p>关联关系是用一条直线表示的。它描述不同类的对象之间的结构关系，它是一种静态关系，通常与运行状态无关，一般由常识等因素决定的，它一般用来定义对象之间静态的、天然的结构，所以，关联关系是一种“强关联的关系”。</p><p>比如，乘车人和车票之间是一种关联关系；学生和学校是一种关联关系。</p><p>关联关系默认不强调方向，表示对象间相互知道，如果特别强调方向，如下图，表示A知道B，但B不知道A。</p><p><img src="http://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_association.jpg" alt=""></p><p>注：在最终代码中，<strong>关联对象通常是以成员变量的形式实现的</strong>；</p><h3 id="依赖关系（dependency）"><a href="#依赖关系（dependency）" class="headerlink" title="依赖关系（dependency）"></a>依赖关系（dependency）</h3><p>依赖关系是用一套带箭头的虚线表示的，如下图表示A依赖B，他描述一个对象在运行期间会用到另一个对象的关系：</p><p><img src="http://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_dependency.jpg" alt=""></p><p>与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化，依赖关系也可能发生变化</p><p>显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生。</p><p>注：在最终代码中，<strong>依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系，依赖关系除了临时知道对方外，还“使用”对方的方法和属性</strong>。</p>]]></content>
      
      <categories>
          
          <category> 编程范式 </category>
          
          <category> 面向对象编程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>数学基础公式推导</title>
      <link href="/blog/2018/04/25/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC/"/>
      <url>/blog/2018/04/25/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC/</url>
      <content type="html"><![CDATA[<p>今天看到下面这个公式，突然想我好像不会推导啊：</p><p>$\sin(\beta-\alpha) = \sin\beta\cos\alpha - \cos\beta\sin\alpha$</p><p>遂想如何推导，在youtube上找了一个视频：<a href="https://www.youtube.com/watch?v=uX6hxwW5BYM" target="_blank" rel="noopener">三角函数正余弦和角公式推导</a></p><p>思路是先推导出：$\cos(\beta-\alpha) = \cos\alpha\cos\beta + \sin\alpha\sin\beta$</p><blockquote><p>然后根据这个再结合正弦余弦之间的关系就很容易推 $\sin(\beta-\alpha) = \sin\beta\cos\alpha - \cos\beta\sin\alpha$</p></blockquote><p>那么怎么推导上面这个公式呢？</p><p>需要用到解析几何：</p><p><img src="https://i.loli.net/2018/04/27/5ae29c4bf121f.png" alt="Screen Shot 2018-04-27 at 11.42.48 AM.png"></p><p>结合 <code>勾股定理</code> 和 <code>余弦定理</code> 可以推导出。</p><p>根据勾股定理：</p><p>$$<br>\begin{align}<br>\overline{PQ}^2<br>&amp; = (\sin\alpha - \sin\beta)^2 + (\cos\beta - \cos\alpha)^2 \<br>&amp; = 2 - 2(\cos\alpha\cos\beta + \sin\alpha\sin\beta) \<br>\end{align}<br>$$</p><p>根据余弦定理（$a^2 = b^2 + c^2 -2ab\cos A$）：</p><p>$$<br>\begin{align}<br>\overline{PQ}^2<br>&amp; = 1^2 + 1^2 - 2\cdot1\cdot1\cdot\cos(\alpha-\beta)<br>\end{align}<br>$$</p><p>由此推出：</p><p>$$<br>\cos(\alpha-\beta) = \sin\alpha\sin\beta+\cos\alpha\cos\beta<br>$$</p><p>也即：</p><p>$$<br>\cos(\beta-\alpha) = \sin\alpha\sin\beta+\cos\alpha\cos\beta<br>$$</p><p>然后：</p><p>$$<br>\begin{align}<br>\sin(\beta-\alpha)<br>&amp;= \cos(\frac{\pi}{2}-(\beta-\alpha)) \<br>&amp;= \cos((\frac{\pi}{2}+\alpha) - \beta) \<br>&amp;= \sin(\frac{\pi}{2}+\alpha)\sin\beta + \cos(\frac{\pi}{2}+\alpha)\cos\beta \<br>&amp;= \cos\alpha\sin\beta - \sin\alpha\cos\beta \<br>&amp;= \sin\beta\cos\alpha - \cos\beta\sin\alpha<br>\end{align}<br>$$</p><blockquote><p>勾股定理和余弦定理的证明比较简单，读者可以试着自证。</p></blockquote>]]></content>
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Hexo+Markdown+MathJax搭建个人博客</title>
      <link href="/blog/2018/04/25/Hexo+Markdown+MathJax%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/blog/2018/04/25/Hexo+Markdown+MathJax%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<h2 id="为什么搭建个人博客"><a href="#为什么搭建个人博客" class="headerlink" title="为什么搭建个人博客"></a>为什么搭建个人博客</h2><p>其实有想过用简书写博客，但简书不支持 <code>mathjax</code>，而我写作的时候要用到不少数学公式。</p><p>以前也用过 leanote，也就是现在的 蚂蚁笔记，但蚂蚁笔记的博客中，[TOC] 是有 mathjax 渲染的，但右上角的目录导航却是没有加 mathjax 渲染的，这样看着会相当别扭。另外还有几个原因：</p><ol><li>leanote收费</li><li>无法彻底的自定义</li><li>博客不像使用静态网站引擎那样直观的以文件的形式展示在我面前</li></ol><h2 id="为什么选-hexo"><a href="#为什么选-hexo" class="headerlink" title="为什么选 hexo"></a>为什么选 hexo</h2><p>为什么选择 <code>hexo</code>，而不是 <code>jekyll</code>，或者 <code>hugo</code>。</p><p>其实我以前的博客是用的 jekyll，弃用 jekyll 是因为这东西实在是太慢了，我更新文章之后无法立即看到结果，要刷新很多次，或者说要等很久，git pages 上才会显示新的东西。听说 hexo 和 hugo 的速度都比较快，所以就换了 hexo，hexo 的主题比 hugo 多，另外 hugo 的官网和主题网站访问实在太慢了，成功恶心到了我。所以我最后选了 hexo，用上了经典主题 next。现在来说，主要是next主题吸引我，而hugo的next主题太简陋了。</p><blockquote><p>hexo 是用 nodejs 写的，jekyll 是用 ruby 写的，hugo 是用 go 语言写的，wordpress 是用 php 实现的。</p></blockquote><p>那为什么不用 wordpress 呢，因为我想用 git pages 这个平台，而这个平台只支持静态博客。</p><h2 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h2><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>首先你要安装 <code>git</code> 和 <code>npm</code>，git 是一种版本控制工具，npm 则是 nodejs 的包管理工具。</p><p>mac 上，使用 brew 和 brew cask 可以像许多 Linux 系统一样直接通过命令行安装软件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install git</span><br><span class="line">brew install node</span><br></pre></td></tr></table></figure><p>另外很不幸的是 git 和 npm 在国内都是无法愉快的使用的，虽然没有被墙，但是速度奇慢无比。于是我们需要做些工作：</p><p>给 git 挂代理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy https://127.0.0.1:1087</span><br><span class="line">git config --global https.proxy https://127.0.0.1:1087</span><br></pre></td></tr></table></figure><p>但为了实现上面的功能，首先你得有个翻墙代理。关于翻墙都可以额外写篇文章了。</p><p>想看详细的解决办法：</p><ul><li><a href="https://www.zhihu.com/question/27159393" target="_blank" rel="noopener">https://www.zhihu.com/question/27159393</a></li><li><a href="https://www.zhihu.com/question/27159393/answer/141047266" target="_blank" rel="noopener">https://www.zhihu.com/question/27159393/answer/141047266</a></li></ul><p>然后给 npm 换源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br><span class="line">npm info underscore （这个只是为了检验上面的设置命令是否成功，若成功，会返回[指定包]的信息）</span><br></pre></td></tr></table></figure><p>想看更详细的解决办法：</p><ul><li><a href="https://segmentfault.com/a/1190000007829080" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007829080</a></li></ul><p>好了，之后就是</p><ul><li>hexo 安装</li><li>初始化 blog 目录</li><li>然后 hexo server 开启本地服务器，一个 demo 就出现啦。</li></ul><p>命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init blog</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><h3 id="基本的建站过程"><a href="#基本的建站过程" class="headerlink" title="基本的建站过程"></a>基本的建站过程</h3><h4 id="从-jekyll-迁移到-hexo"><a href="#从-jekyll-迁移到-hexo" class="headerlink" title="从 jekyll 迁移到 hexo"></a>从 jekyll 迁移到 hexo</h4><p>我是从 jekyll 迁移过来的，所以先把文章全都拷贝进 <code>source/_posts</code> 目录下面，然后修改 <code>_config.yml</code>，把：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_post_name: :title.md</span><br></pre></td></tr></table></figure><p>变成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_post_name: :year-:month-:day-:title.md</span><br></pre></td></tr></table></figure><p>官网迁移教程：<a href="https://hexo.io/zh-cn/docs/migration.html" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/migration.html</a></p><h4 id="下载-next-主题并添加-mathjax"><a href="#下载-next-主题并添加-mathjax" class="headerlink" title="下载 next 主题并添加 mathjax"></a>下载 next 主题并添加 mathjax</h4><p>然后下载一个 <code>next</code> 主题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>然后修改 <code>_config.yml</code>，把：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: landscape</span><br></pre></td></tr></table></figure><p>变成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure><p>然后修改 <code>next</code> 的 <code>_config.yml</code>，把：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mathjax:</span><br><span class="line">  enable: false</span><br><span class="line">  per_page: false</span><br><span class="line">  cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config#TeX-AMS-MML_HTMLorMML</span><br></pre></td></tr></table></figure><p>变成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mathjax:</span><br><span class="line">  enable: true</span><br><span class="line">  per_page: false</span><br><span class="line">  cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config#TeX-AMS-MML_HTMLorMML</span><br></pre></td></tr></table></figure><blockquote><p>注意<code>per_page</code>不能是true，一定要是false。</p></blockquote><h4 id="解决-markdown-与-mathjax-的冲突"><a href="#解决-markdown-与-mathjax-的冲突" class="headerlink" title="解决 markdown 与 mathjax 的冲突"></a>解决 markdown 与 mathjax 的冲突</h4><p>为了解决 <code>markdown</code> 下划线转义成 <code>&lt;em&gt;</code> 标签（HTML标签），从而导致 <code>mathjax</code> 的下标无法使用，这个问题，我们修改 <code>marked.js</code> 文件，如果你使用的是 <code>sublime text</code> 或者 <code>Atom</code> 编辑器，<code>cmd+o</code>打开你的博客目录，然后 <code>cmd+p</code> 输入你要在此目录下找的文件名：<code>marked.js</code> 就可以找到这个文件。这个文件的是：<code>node_modules/marked/lib/marked.js</code>。把文件中的：</p><p>总共发现 mathjax 中的三处冲突：</p><ol><li><code>_</code>变成了<code>&lt;em&gt;</code></li><li><code>\\</code>变成了单个<code>\</code></li><li><code>&lt; xxx &gt;</code>大于号小于号之间会新增一个 <code>#&quot;&quot;</code></li></ol><p>将</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">escape: /^\\([\\`*&#123;&#125;\[\]()# +\-.!_&gt;])/,</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">escape: /^\\([`*&#123;&#125;\[\]()# +\-.!_&gt;])/,</span><br></pre></td></tr></table></figure><p>这样就去掉了，双斜杠转义。</p><p>把</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">em: /^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">em:/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span><br></pre></td></tr></table></figure><p>这样就禁掉了 <code>_</code> 变 <code>&lt;em&gt;</code>（斜体标记）。</p><p>最后，为了解决第三个冲突，我把 <code>&gt;</code> 写成了 HTML 实体形式：<code>&amp;gt;</code>，这样就无法组成一对尖括号了，终于不会冲突了。</p><p>我为什么不装个 <code>hexo-renderer-pandoc</code> + <code>pandoc</code> ，说出来都是泪啊，装了啊，一执行就报错，google 了一圈，没有有用的解答，遂作罢。</p><h4 id="解决语言不正确的问题"><a href="#解决语言不正确的问题" class="headerlink" title="解决语言不正确的问题"></a>解决语言不正确的问题</h4><p>我发现有些地方居然默认的是德语还是什么其他语言，反正不是英语，所以我们需要改：</p><ul><li>根目录下的 <code>_config.yml</code></li><li>next 主题的 <code>_config.yml</code></li></ul><p>两个都改成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">language: en</span><br></pre></td></tr></table></figure><h4 id="生成-public-静态网站目录-和-部署到-github"><a href="#生成-public-静态网站目录-和-部署到-github" class="headerlink" title="生成 public 静态网站目录 和 部署到 github"></a>生成 public 静态网站目录 和 部署到 github</h4><p>生成静态网站目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>下载 hexo-deployer-git 插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>再修改 <code>_config.yml</code>，把：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type:</span><br></pre></td></tr></table></figure><p>变成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/liuqinh2s/liuqinh2s.github.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>然后，用命令 <code>hexo d</code> 部署就行了，不过首先你得有个 github 账号，然后还得有个叫 <code>liuqinh2s.github.io</code> 的项目，然后你还得配置好 github 环境：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;Your Name Here&quot;</span><br><span class="line">git config --global user.email &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure><p>然后把公钥的内容传给 github 就行了。这里只说原理，具体的操作懒得贴了。</p><blockquote><p>只有多懂原理（哪怕只是基本的原理），你才能顺利解决遇到的诸多问题。</p></blockquote><p>官网的部署教程：<a href="https://hexo.io/zh-cn/docs/deployment.html" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/deployment.html</a></p><p>基本的建站就结束了，然后就是慢慢把博客进行个性化吧。</p><h3 id="hexo-个性化配置"><a href="#hexo-个性化配置" class="headerlink" title="hexo 个性化配置"></a>hexo 个性化配置</h3><ul><li>hexo-reference，用来支持 markdown 脚注的</li><li>hexo-generator-seo-friendly-sitemap，sitemap用来喂给搜索引擎的，更好的爬取网站</li><li>hexo-generator-search，博客内部搜索</li><li>hexo-wordcount，统计字数用的</li></ul><p>然后就是调 next 主题，把自己喜欢的特性用上。</p><p>然后就是加上 <code>不蒜子</code>，百度统计这类统计工具，和 disqus 评论等等。</p>]]></content>
      
      <categories>
          
          <category> projects </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java OutputStream flush</title>
      <link href="/blog/2018/02/27/Java-OutputStream-flush/"/>
      <url>/blog/2018/02/27/Java-OutputStream-flush/</url>
      <content type="html"><![CDATA[<p>FileOutPutStream继承OutputStream，并不提供flush()方法的重写，所以无论内容多少，write都会将二进制流直接传递给底层操作系统的I/O，flush无效果。而Buffered系列的输入输出流函数单从Buffered这个单词就可以看出他们是使用缓冲区的。</p><p>应用程序每次IO都要和设备进行通信，效率很低，因此缓冲区为了提高效率，当写入设备时，先写入缓冲区，每次等到缓冲区满了时，就将数据一次性整体写入设备，避免了每一个数据都和IO进行一次交互，IO交互消耗太大。</p><h2 id="使用flush-和不使用flush-效果对比"><a href="#使用flush-和不使用flush-效果对比" class="headerlink" title="使用flush()和不使用flush()效果对比"></a>使用flush()和不使用flush()效果对比</h2><h3 id="不使用flush"><a href="#不使用flush" class="headerlink" title="不使用flush()"></a>不使用flush()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"Hello World"</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// create a new stream at specified file</span></span><br><span class="line">    PrintWriter pw = <span class="keyword">new</span> PrintWriter(System.out);</span><br><span class="line">    <span class="comment">// write the string in the file</span></span><br><span class="line">    pw.write(s);</span><br><span class="line"><span class="comment">//            // flush the writer</span></span><br><span class="line"><span class="comment">//            pw.flush();</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    ex.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>buffer没有满，输出为空。</p><h3 id="使用flush"><a href="#使用flush" class="headerlink" title="使用flush()"></a>使用flush()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"Hello World"</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// create a new stream at specified file</span></span><br><span class="line">    PrintWriter pw = <span class="keyword">new</span> PrintWriter(System.out);</span><br><span class="line">    <span class="comment">// write the string in the file</span></span><br><span class="line">    pw.write(s);</span><br><span class="line">    <span class="comment">// flush the writer</span></span><br><span class="line">    pw.flush();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    ex.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到期望的输出结果。</p><h2 id="close-和flush-作用有交集！"><a href="#close-和flush-作用有交集！" class="headerlink" title="close()和flush()作用有交集！"></a>close()和flush()作用有交集！</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    BufferedWriter fw =<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fw =  <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"e:\\test.txt"</span>));</span><br><span class="line">        fw.write(<span class="string">"wo shi lucky girl."</span>);</span><br><span class="line">        <span class="comment">//fw.flush();</span></span><br><span class="line">        fw.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为close的时候，会把你没flush掉的一起flush掉。<br>缓冲区中的数据保存直到缓冲区满后才写出，也可以使用flush方法将缓冲区中的数据强制写出或使用close()方法关闭流，关闭流之前，缓冲输出流将缓冲区数据一次性写出。在这个例子中，flush()和close()都使数据强制写出，所以两种结果是一样的，如果都不写的话，会发现不能成功写出。</p><h2 id="Java默认缓冲区大小是多少？"><a href="#Java默认缓冲区大小是多少？" class="headerlink" title="Java默认缓冲区大小是多少？"></a>Java默认缓冲区大小是多少？</h2><p>默认缓冲去大小8192字节，也就是8k。</p><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] array  = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">8192</span>];</span><br><span class="line">Arrays.fill(array,<span class="string">'s'</span>);</span><br><span class="line">PrintWriter pw = <span class="keyword">new</span> PrintWriter(System.out);</span><br><span class="line">pw.write(array);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] array  = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">8193</span>];</span><br><span class="line">Arrays.fill(array,<span class="string">'s'</span>);</span><br><span class="line">PrintWriter pw = <span class="keyword">new</span> PrintWriter(System.out);</span><br><span class="line">pw.write(array);</span><br></pre></td></tr></table></figure><p>当设置数组长度为8192时没有输出，设置8193时有输出。</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>新概念英语四 lesson 03 Matterhorn Man</title>
      <link href="/blog/2018/02/25/%E6%96%B0%E6%A6%82%E5%BF%B5%E8%8B%B1%E8%AF%AD%E5%9B%9B-lesson-03-Matterhorn-Man/"/>
      <url>/blog/2018/02/25/%E6%96%B0%E6%A6%82%E5%BF%B5%E8%8B%B1%E8%AF%AD%E5%9B%9B-lesson-03-Matterhorn-Man/</url>
      <content type="html"><![CDATA[<p>生词：</p><ul><li>climber （这个单词要注意发音，b 是不发音的）</li><li>alpinist 登山运动员</li><li>route 路</li><li>summit 最高，顶点</li><li>sought seek 的过去式, seek sought sought</li><li>perilous 危险的</li><li>manner 方式</li><li>court 招致</li><li>solitary 孤独的</li><li>rapidly 快速的</li><li>Alpine 阿尔卑斯山的</li><li>impoverished 贫困</li><li>settlements 定居点</li><li>flea-ridden 跳蚤猖獗</li><li>coarse 粗糙的</li><li>boast 吹嘘</li><li>priest 牧师</li><li>parishioner 教徒</li><li>shepherd 牧羊人</li><li>Invariably 不变的</li><li>linen 亚麻的</li></ul><p>语言点：<br>alpinist 实际上是由 Alps 阿尔卑斯山演变来的。</p><p>What was the main objective of early mountain climbers?</p><p>语言用词的多样性：这里的目标用的是 objective，也可以用 aim，goal 等。</p><p>这个问题的答案是：to get to the top by the easiest route</p><p>Modern alpinists try to climb mountains by a route which will give them good sport, and the more difficult it is, the more highly it is regarded.</p><p>英语用词有时候非常简单，比如这里的 good sport 和 highly。</p><p>而翻译成汉语则是：</p><p>现代登山运动员总想找一条能够给他们带来运动乐趣的路线来攀登山峰。他们认为，道路愈艰险愈带劲儿。</p><p>汉语用的是 运动乐趣 和 带劲儿。也是相当地道的。</p><p>In the pioneering days however, this was not the case at all.</p><p>然而，在登山运动的初期，全然不是这种情况。</p><p>这里的 pioneering days 用法很新鲜，如果是我的话只会想到 early，this was not the case at all 又一次反映了英语用词的简洁。the case 用的很爽。</p><p>The early climbers were looking for the easiest way to the top because the summit was the prize they sought, especially if it had never been attained before.</p><p>早期登山者所寻找的是通往山顶的最方便的途径，这是他们追寻的目标，特别是前人未曾到达过的山顶。</p><p>这里的 early 呼应了前面的 pioneering，the summit was the prize they sought，时刻注意时态，英语就是如此，有不少的细节，需要严谨对待。另外 summit 用来表示山顶，如果是我的话只能想到 top，以后可以用 summit 来代替了。especially if it had never been attained before，我突然想到是不是也可以用 achieved。</p><p>It is true that during their explorations they often faced difficulties and dangers of the most perilous nature, equipped in a manner which would make a modern climber shudder at the thought, but they did not go out of their way to court such excitement.</p><p>确实，在探险中他们经常遇到惊心动魄的困难和危险，而他们的装备之简陋足以使现代登山者一想起来就胆战心惊。但是他们并非故意寻求这种刺激。</p><p>perilous险恶的，perilous nature 用来形容恶劣的自然环境。equipped in a manner which would make a modern climber shudder at the thought，这一句十分经典。court such excitement，这里的 court 表示招致，我以前只知道：法院、球场。</p><p>They had a single aim, a solitary goal – the top!</p><p>这个用了相同的词来描述同一个事，作为强调。而且语气上是递进的 single 和 solitary 比，solitary 语气更重，aim 和 goal 比，aim 表示一般的泛泛的目标，goal 则常用在体育竞赛方面。</p><p>It is hard for us to realize nowadays how difficult it was for the pioneers.</p><p>我们今天很难想象昔日的登山先驱是多么艰苦。</p><p>Except for one or two places such as Zermatt and Chamonix, which had rapidly become popular.</p><p>Alpine villages tended to be impoverished settlements cut off from civilization by the high mountains.</p><p>阿尔卑斯山山区的小村几乎全是高山环抱、与世隔绝的穷乡僻壤。</p><p>tended to be，几乎全是，用得好。cut off from civilization by the high mountains，简单词用的好，形象的描述了高山环抱、与世隔绝、穷乡僻壤。</p><p>Such inns as there were were generally dirty and flea-ridden;the food simply local cheese accompanied by bread often twelve months old, all washed down with coarse wine.</p><p>那里的小客栈一般都很脏，而且跳蚤猖獗。食物是当地的干酪和通常存放了一年之久的面包，人们就着劣酒吞下这种食物。</p><p>accompanied by 这里用的不错，bread often twelve months old，形容面包和形容人是一样的用法。washed down 用液体灌下。coarse 粗糙的，coarse wine 劣质的酒。</p><p>Often a valley boasted no inn at all, and climbers found shelter wherever they could sometimes with the local priest(who was usually as poor as his parishioners), sometimes with shepherds or cheese-makers. Invariably the background was the same: dirt and poverty, and very uncomfortable.</p><p>山谷里常常没有小客栈，登山者只好随遇而安。有时同当地牧师（他通常和他的教民一样穷）住在一起，有时同牧羊人或制乳酪的人住在一起。无论在哪儿，情况都一样：肮脏、贫穷，极其不舒适。</p><p>boast: to be lucky enough to own。这里不用 have 而是用 boast，表明作者不是在做客观的描述，而是带有感情色彩的。例子：The university boasts the highest number of first-rate teachers in China.</p><p>invariably 不变的。</p><p>For men accustomed to eating seven-course dinners and sleeping between fine linen sheets at home, the change to the Alps must have been very hard indeed.</p><p>对于过惯了一顿饭吃7道菜、睡亚麻细布床单的人来说，变换一下生活环境来到阿尔卑斯山山区，那一定是很艰难的。</p><p>seven-course dinners，七道菜的晚饭。sheet 薄片，纸张，床单。</p>]]></content>
      
      <categories>
          
          <category> 新概念英语四 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>POJ 1008 Maya Calendar</title>
      <link href="/blog/2018/02/24/POJ-1009-Edge-Detection/"/>
      <url>/blog/2018/02/24/POJ-1009-Edge-Detection/</url>
      <content type="html"><![CDATA[<p>这一题花了不少时间，首先是题目没看懂，然后搜了很久的资料，才看懂了。</p><p>边缘检测是图像处理里面的基础，这题用的边缘检测就是最简单的边缘检测，根据周边八个像素点和此像素点差值 来描绘图像中的物体的边缘。</p><p>比如第一个点15，它周围的三个点是100，100，15，得到的结果是85，再比如第4行第2列是175，它周边的点是100，100，100，175，25，175，175，25，得到的结果是150.</p><p>输入也是刚开始没看懂，其实也很简单，第一个数表示图的宽度，接下来是若干对数字，前面是像素的值，后面是个数。</p><p>最后贴上有注释的代码（C++）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Memory Time   </span></span><br><span class="line"><span class="comment">//332K   32MS   </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> size=<span class="number">1000</span>;  <span class="comment">//每幅图片的pair上限  </span></span><br><span class="line"><span class="keyword">int</span> width;  <span class="comment">//Map的宽  </span></span><br><span class="line"><span class="keyword">int</span> total=<span class="number">0</span>;  <span class="comment">//像素点总个数  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">class</span> <span class="title">OutMapPix</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    <span class="keyword">public</span>:  </span><br><span class="line">        <span class="keyword">int</span> pos;    <span class="comment">//OutMap中每个像素点的顺序位置，pos从1开始  </span></span><br><span class="line">        <span class="keyword">int</span> code;   <span class="comment">//OutMap中每个像素点对应InMap的编码  </span></span><br><span class="line">&#125;Pix;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> InMapPair[size][<span class="number">2</span>];  <span class="comment">//InMapPair[][0]为像素值，InMapPair[][1]为InMapPair[][0]连续出现的个数  </span></span><br><span class="line">Pix OutMap[size*<span class="number">9</span>];    <span class="comment">//每个pix都依赖其周围的8个点编码  </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* a,<span class="keyword">const</span> <span class="keyword">void</span>* b)</span></span>;  <span class="comment">//快排比较规则  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetValue</span><span class="params">(<span class="keyword">int</span> pos)</span></span>;  <span class="comment">//返回第pos个像素点的像素值  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetCode</span><span class="params">(<span class="keyword">int</span> pos)</span></span>;   <span class="comment">//返回第pos个像素点的编码  </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> k)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;width &amp;&amp; width)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">int</span> pairv,pairt;  </span><br><span class="line">        k=total=<span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;pairv&gt;&gt;pairt &amp;&amp; pairt)  </span><br><span class="line">        &#123;  </span><br><span class="line">            InMapPair[k][<span class="number">0</span>]=pairv;  </span><br><span class="line">            InMapPair[k++][<span class="number">1</span>]=pairt;  </span><br><span class="line">            total+=pairt;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">int</span> PairNum=k;  <span class="comment">//pair的个数  </span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;width&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pos=<span class="number">1</span>;  <span class="comment">//当前处理的像素点的位置  </span></span><br><span class="line">        k=<span class="number">0</span>; <span class="comment">//OutMap[]指针  </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">0</span>;p&lt;=PairNum;p++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">int</span> row=(pos<span class="number">-1</span>)/width;  <span class="comment">//得到pos在二维图对应的坐标  </span></span><br><span class="line">            <span class="keyword">int</span> col=(pos<span class="number">-1</span>)%width;  </span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=row<span class="number">-1</span>;i&lt;=row+<span class="number">1</span>;i++)        <span class="comment">//枚举(row,col)周围及其自身共9个点(x,y)  </span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=col<span class="number">-1</span>;j&lt;=col+<span class="number">1</span>;j++)  </span><br><span class="line">                &#123;  </span><br><span class="line">                    <span class="keyword">int</span> tpos=i*width+j;  <span class="comment">//得到(x,y)的顺序位置  </span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(i&lt;<span class="number">0</span> || j&lt;<span class="number">0</span> || j&gt;=width || tpos&gt;=total)  </span><br><span class="line">                        <span class="keyword">continue</span>;  </span><br><span class="line"></span><br><span class="line">                    OutMap[k].pos=tpos+<span class="number">1</span>;  </span><br><span class="line">                    OutMap[k++].code=GetCode(tpos+<span class="number">1</span>);  <span class="comment">//对发生变化的像素点的附近8个点和这一点本身编码（总共是9个点）</span></span><br><span class="line">                &#125;  </span><br><span class="line"></span><br><span class="line">            pos+=InMapPair[p][<span class="number">1</span>];  <span class="comment">//跳跃，确定下一个像素发生变化的点的位置  </span></span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        qsort(OutMap,k,<span class="keyword">sizeof</span>(Pix),cmp);  <span class="comment">//对OutMap根据顺序位置  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*OutPut*/</span>  </span><br><span class="line"></span><br><span class="line">        Pix temp=OutMap[<span class="number">0</span>];  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span>(temp.code==OutMap[i].code)  </span><br><span class="line">                <span class="keyword">continue</span>;  </span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;temp.code&lt;&lt;<span class="string">' '</span>&lt;&lt;OutMap[i].pos-temp.pos&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">            temp=OutMap[i];  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;temp.code&lt;&lt;<span class="string">' '</span>&lt;&lt;total-temp.pos+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"0 0"</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*快排比较规则*/</span>  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* a,<span class="keyword">const</span> <span class="keyword">void</span>* b)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    Pix* x=(Pix*)a;  </span><br><span class="line">    Pix* y=(Pix*)b;  </span><br><span class="line">    <span class="keyword">return</span> x-&gt;pos - y-&gt;pos;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回第pos个像素点的像素值*/</span>  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetValue</span><span class="params">(<span class="keyword">int</span> pos)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,p=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span>(p&lt;pos)  </span><br><span class="line">        p+=InMapPair[i++][<span class="number">1</span>];  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> InMapPair[i<span class="number">-1</span>][<span class="number">0</span>];  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回第pos个像素点的编码*/</span>  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetCode</span><span class="params">(<span class="keyword">int</span> pos)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> code=GetValue(pos);  </span><br><span class="line">    <span class="keyword">int</span> MaxAbs=<span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> row=(pos<span class="number">-1</span>)/width;  </span><br><span class="line">    <span class="keyword">int</span> col=(pos<span class="number">-1</span>)%width;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=row<span class="number">-1</span>;i&lt;=row+<span class="number">1</span>;i++)  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=col<span class="number">-1</span>;j&lt;=col+<span class="number">1</span>;j++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">int</span> tpos=i*width+j;  </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i&lt;<span class="number">0</span> || j&lt;<span class="number">0</span> || j&gt;=width || tpos&gt;=total || tpos==pos<span class="number">-1</span>)  <span class="comment">//tpos==pos-1为中心的像素点，即当前待编码的点  </span></span><br><span class="line">                <span class="keyword">continue</span>;  </span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> tcode=GetValue(tpos+<span class="number">1</span>);  </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(MaxAbs&lt;<span class="built_in">abs</span>(tcode-code))   <span class="comment">//注意取绝对值  </span></span><br><span class="line">                MaxAbs=<span class="built_in">abs</span>(tcode-code);  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> MaxAbs;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要注意的点：</p><ol><li>主要就是自加，这里面用了很多的右自加，右自加是先使用值，然后再自加。</li><li>GetValue函数 是一个典型的寻区间代码。</li><li>算法：只计算 RLE 起始点和其周围的点。这里不做证明。</li></ol>]]></content>
      
      <categories>
          
          <category> ACM </category>
          
          <category> POJ </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>POJ 1008 Maya Calendar</title>
      <link href="/blog/2018/02/22/POJ-1008-Maya-Calendar/"/>
      <url>/blog/2018/02/22/POJ-1008-Maya-Calendar/</url>
      <content type="html"><![CDATA[<p>这一题的话：</p><ol><li>要注意 C++ 的 switch 不能使用 string，所以只好写成 if 来判断了。</li><li>另外一个值得注意的地方是，空格会中断标准输入，所以不能使用一个 string 来装下一行输入，而是分别用 string Day，string str，int Year，装下 day, month, year。</li><li>注意 Day[i]-‘0’</li><li>可以使用分批输出，无需打包成一个 string。</li></ol><p>C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Haab 365</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Tzolkin 260</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">string</span> Day;</span><br><span class="line">    <span class="keyword">int</span> Year;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; Day;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;Day[i]!=<span class="string">'.'</span>;++i)&#123;</span><br><span class="line">            num = num*<span class="number">10</span>+Day[i]-<span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">"no"</span>)num += <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">"zip"</span>)num+=<span class="number">40</span>;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">"zotz"</span>)num+=<span class="number">60</span>;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">"tzec"</span>)num+=<span class="number">80</span>;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">"xul"</span>)num+=<span class="number">100</span>;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">"yoxkin"</span>)num+=<span class="number">120</span>;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">"mol"</span>)num+=<span class="number">140</span>;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">"chen"</span>)num+=<span class="number">160</span>;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">"yax"</span>)num+=<span class="number">180</span>;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">"zac"</span>)num+=<span class="number">200</span>;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">"ceh"</span>)num+=<span class="number">220</span>;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">"mac"</span>)num+=<span class="number">240</span>;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">"kankin"</span>)num+=<span class="number">260</span>;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">"muan"</span>)num+=<span class="number">280</span>;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">"pax"</span>)num+=<span class="number">300</span>;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">"koyab"</span>)num+=<span class="number">320</span>;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">"cumhu"</span>)num+=<span class="number">340</span>;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">"uayet"</span>)num+=<span class="number">360</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; Year;</span><br><span class="line">        num += Year*<span class="number">365</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; num%<span class="number">13</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> month = num%<span class="number">260</span>;</span><br><span class="line">        <span class="keyword">switch</span>(month%<span class="number">20</span>)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                str = <span class="string">"imix"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                str = <span class="string">"ik"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                str = <span class="string">"akbal"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                str = <span class="string">"kan"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                str = <span class="string">"chicchan"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                str = <span class="string">"cimi"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                str = <span class="string">"manik"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                str = <span class="string">"lamat"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                str = <span class="string">"muluk"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">                str = <span class="string">"ok"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">                str = <span class="string">"chuen"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">                str = <span class="string">"eb"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">                str = <span class="string">"ben"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">13</span>:</span><br><span class="line">                str = <span class="string">"ix"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">14</span>:</span><br><span class="line">                str = <span class="string">"mem"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">15</span>:</span><br><span class="line">                str = <span class="string">"cib"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">16</span>:</span><br><span class="line">                str = <span class="string">"caban"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">17</span>:</span><br><span class="line">                str = <span class="string">"eznab"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">18</span>:</span><br><span class="line">                str = <span class="string">"canac"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">19</span>:</span><br><span class="line">                str = <span class="string">"ahau"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> +str +<span class="string">" "</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; num/<span class="number">260</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> ACM </category>
          
          <category> POJ </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>POJ 1007 DNA sorting</title>
      <link href="/blog/2018/02/21/POJ-1007-DNA-sorting/"/>
      <url>/blog/2018/02/21/POJ-1007-DNA-sorting/</url>
      <content type="html"><![CDATA[<p>这道题有点尴尬，刚开始一直没看懂，主要是先入为主，以为是对每一串字符串做排序，最后发现居然是根据每一串 DNA 的逆序数，对串之间进行排序。</p><p>题目本身是简单的，第一步统计逆序数，第二步排序，这里使用C++标准库的sort。</p><p>C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dna</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> unorder;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">&#125;DNA[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inversionNumber</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> A, C, G;</span><br><span class="line">    A = C = G = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = s.length()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">        <span class="keyword">switch</span>(s[i])&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'A'</span>:</span><br><span class="line">                A++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'C'</span>:</span><br><span class="line">                C++;</span><br><span class="line">                result += A;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'G'</span>:</span><br><span class="line">                G++;</span><br><span class="line">                result += A;</span><br><span class="line">                result += C;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'T'</span>:</span><br><span class="line">                result += A;</span><br><span class="line">                result += C;</span><br><span class="line">                result += G;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(dna a, dna b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.unorder &lt; b.unorder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;m)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; DNA[i].s;</span><br><span class="line">        DNA[i].unorder = inversionNumber(DNA[i].s);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(DNA, DNA+m, compare);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; DNA[i].s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> ACM </category>
          
          <category> POJ </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>POJ 1006 Biorhythms</title>
      <link href="/blog/2018/02/15/POJ-1006-Biorhythms/"/>
      <url>/blog/2018/02/15/POJ-1006-Biorhythms/</url>
      <content type="html"><![CDATA[<h2 id="同余"><a href="#同余" class="headerlink" title="同余"></a>同余</h2><p>两个整数 a, b，若它们除以正整数 m所得的余数相等，则称 a,b对于模 m 同余，记作：$a \equiv b (mod\quad m)$。最先引用同余的概念与”$\equiv$”符号的是德国数学家 高斯。</p><h2 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h2><p>在《孙子算经》中有这样一个问题：“今有物不知其数，三三数之剩二（除以3余2），五五数之剩三（除以5余3），七七数之剩二（除以7余2），问物几何？”这个问题称为“孙子问题”，该问题的一般解法国际上称为“中国剩余定理”。具体解法分三步：</p><p>找出三个数：从3和5的公倍数中找出被7除余1的最小数15，从3和7的公倍数中找出被5除余1 的最小数21，最后从5和7的公倍数中找出除3余1的最小数70。<br>用15乘以2（2为最终结果除以7的余数），用21乘以3（3为最终结果除以5的余数），同理，用70乘以2（2为最终结果除以3的余数），然后把三个乘积相加（15<em>2+21</em>3+70*2）得到和233。<br>用233除以3，5，7三个数的最小公倍数105，得到余数23，即233%105=23。这个余数23就是符合条件的最小数。</p><p>为什么要这么做呢？</p><p>这就牵涉到一个最基本数学定理，如果有a%b=c,则有(a+kb)%b=c(k为非零整数)，换句话说，如果一个除法运算的余数为c，那么被除数与k倍的除数相加（或相减）的和（差）再与除数相除，余数不变。这就是上面提到的同余。</p><p>以此定理为依据，如果n2是3的倍数，n1+n2就依然满足除以3余2。同理，如果n3也是3的倍数，那么n1+n2+n3的和就满足除以3余2。这是从n1的角度考虑的，再从n2，n3的角度出发，我们可推导出以下三点：</p><ul><li>为使n1+n2+n3的和满足除以3余2，n2和n3必须是3的倍数。</li><li>为使n1+n2+n3的和满足除以5余3，n1和n3必须是5的倍数。</li><li>为使n1+n2+n3的和满足除以7余2，n1和n2必须是7的倍数。</li></ul><p>因此，为使n1+n2+n3的和作为“孙子问题”的一个最终解，需满足：</p><ul><li>n1除以3余2，且是5和7的公倍数。</li><li>n2除以5余3，且是3和7的公倍数。</li><li>n3除以7余2，且是3和5的公倍数。</li></ul><p>所以，孙子问题解法的本质是从5和7的公倍数中找一个除以3余2的数n1，从3和7的公倍数中找一个除以5余3的数n2，从3和5的公倍数中找一个除以7余2的数n3，再将三个数相加得到解。在求n1，n2，n3时又用了一个小技巧，以n1为例，并非从5和7的公倍数中直接找一个除以3余2的数，而是先找一个除以3余1的数，再乘以2。</p><p>最后，我们还要清楚一点，n1+n2+n3只是问题的一个解，并不是最小的解。如何得到最小解？我们只需要从中最大限度的减掉掉3，5，7的公倍数105即可。道理就是前面讲过的定理“如果a%b=c,则有(a-kb)%b=c”。所以（n1+n2+n3）%105就是最终的最小解。</p><p>总结就两个公式：</p><ul><li>如果 a%b=c , 则有 (a+kb)%b=c (k为非零整数)。</li><li>如果 a%b=c，那么 (a*k)%b=kc (k为大于零的整数)。</li></ul><h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><p>最后我们再来看看我们这道题，如何使用中国剩余定理来得到时间复杂度 O(1) 的解。</p><p>已知(n+d)%23=p; (n+d)%28=e; (n+d)%33=i</p><p>使33×28×a被23除余1，用33×28×8=5544；</p><p>使23×33×b被28除余1，用23×33×19=14421；</p><p>使23×28×c被33除余1，用23×28×2=1288。</p><p>因此有（5544×p+14421×e+1288×i）% lcm(23,28,33) =n+d</p><p>又23、28、33互质，即lcm(23,28,33)= 21252;</p><p>所以有n=（5544×p+14421×e+1288×i-d）%21252</p><p>本题所求的是最小整数解，避免n为负，因此最后结果为n= [n+21252]% 21252</p><p>那么最终求解n的表达式就是：<br>n=(5544p+14421e+1288*i-d+21252)%21252</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P 23</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> E 28</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I 33</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> C 21252</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p, e, i, d;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> J=E*I;</span><br><span class="line">    <span class="keyword">int</span> K=P*I;</span><br><span class="line">    <span class="keyword">int</span> H=P*E;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">for</span>(j=J;j%P!=<span class="number">1</span>;j+=J);</span><br><span class="line">    <span class="keyword">for</span>(k=K;k%E!=<span class="number">1</span>;k+=K);</span><br><span class="line">    <span class="keyword">for</span>(h=H;h%I!=<span class="number">1</span>;h+=H);</span><br><span class="line">    <span class="comment">// cout &lt;&lt; j &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; k &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; h &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; p &gt;&gt; e &gt;&gt; i &gt;&gt; d) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = (j*p+k*e+h*i-d+C)%C;</span><br><span class="line">        <span class="keyword">if</span>(result==<span class="number">0</span>)</span><br><span class="line">            result = C;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span>&lt;&lt; count &lt;&lt; <span class="string">": the next triple peak occurs in "</span> &lt;&lt; result &lt;&lt; <span class="string">" days."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> ACM </category>
          
          <category> POJ </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>POJ 1002 487 3279</title>
      <link href="/blog/2018/01/21/POJ-1002-487-3279/"/>
      <url>/blog/2018/01/21/POJ-1002-487-3279/</url>
      <content type="html"><![CDATA[<p>这一题看似很简单，却有着很多限制，我也是搞了很久。刚开始的时候我是用了很多 c++11 的东西，然后一直报 Compile Error，但我本地编译是不会有错的，查出几点：</p><p>vector&lt;vector<int>&gt;会报错，但 c++11可以这样写，以前的老编译器只能这么写：vector&lt;vector<int> &gt;<br>to_string()函数无法使用，这是 c++11 新出的。<br>for(int x:result)这种写法直到 c++11 才支持。<br>POJ 上的编译器是比较老的，所以无法使用 c++11 的新特性。</int></int></p><p>这还不算，后来一直报 Time Limit Exceeded，上网查资料发现，要把 cin 输入改成 getchar 接收输入，终于 AC。还有就是在勾选 language 的时候，一定要用 G++，不要用 C++，如果你选 C++，会报如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Compile Error</span><br><span class="line"></span><br><span class="line">Main.cpp</span><br><span class="line">F:\temp\18069972.33777\Main.cpp(16) : error C2057: expected constant expression</span><br><span class="line">F:\temp\18069972.33777\Main.cpp(16) : error C2466: cannot allocate an array of constant size 0</span><br><span class="line">F:\temp\18069972.33777\Main.cpp(16) : error C2133: &apos;data&apos; : unknown size</span><br></pre></td></tr></table></figure><p>C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> data[n];</span><br><span class="line">    <span class="keyword">int</span> size = n;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        ch = getchar();</span><br><span class="line">        <span class="comment">//过滤空行</span></span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">'\n'</span>)&#123;</span><br><span class="line">            n++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ch!=<span class="string">'\n'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ch&gt;=<span class="string">'0'</span> &amp;&amp; ch&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">                num = num*<span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch &gt;= <span class="string">'A'</span> &amp;&amp; ch &lt;= <span class="string">'P'</span>)&#123;</span><br><span class="line">                num = num*<span class="number">10</span> + (ch - <span class="string">'A'</span>)/<span class="number">3</span> + <span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch &gt;= <span class="string">'R'</span> &amp;&amp; ch &lt;= <span class="string">'Y'</span>)&#123;</span><br><span class="line">                num = num*<span class="number">10</span> + (ch - <span class="string">'Q'</span>)/<span class="number">3</span> + <span class="number">7</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        data[n]=num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// qsort(data, size, sizeof(int), compare);</span></span><br><span class="line">    sort(data, data+size);</span><br><span class="line">    <span class="comment">// for(int i=0;i&lt;size;i++)&#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; data[i] &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;size;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(data[i]==data[i<span class="number">-1</span>])&#123;</span><br><span class="line">            count++;</span><br><span class="line">            index=i;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(count!=<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%03d-%04d %d\n"</span>,data[i<span class="number">-1</span>]/<span class="number">10000</span>,data[i<span class="number">-1</span>]%<span class="number">10000</span>,count);</span><br><span class="line">                <span class="comment">// cout &lt;&lt; setfill('0') &lt;&lt; setw(3) &lt;&lt; data[i-1]/10000 &lt;&lt; '-' &lt;&lt; setfill('0') &lt;&lt; setw(4) &lt;&lt; data[i-1]%10000 &lt;&lt; ' ' &lt;&lt; count &lt;&lt; endl;</span></span><br><span class="line">                count=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i==size<span class="number">-1</span> &amp;&amp; count!=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%03d-%04d %d\n"</span>,data[i<span class="number">-1</span>]/<span class="number">10000</span>,data[i<span class="number">-1</span>]%<span class="number">10000</span>,count);</span><br><span class="line">            count=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(index==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"No duplicates."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> ACM </category>
          
          <category> POJ </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>POJ-1003-Hangover</title>
      <link href="/blog/2018/01/21/POJ-1003-Hangover/"/>
      <url>/blog/2018/01/21/POJ-1003-Hangover/</url>
      <content type="html"><![CDATA[<p>这一题 AC 的速度还是挺快的，题目本身也是很简单：</p><p>C++ 代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">double2Str</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> &amp;double_temp)</span></span>&#123;</span><br><span class="line">    <span class="built_in">stringstream</span> ss;</span><br><span class="line">    ss &lt;&lt; double_temp;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    ss &gt;&gt; str;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    <span class="comment">//对浮点数只能使用大于、小于号进行比较，不能使用等号和不等号，我这里直接把 double 转成字符串，就可以用不等号比较了</span></span><br><span class="line">    <span class="comment">//根据输入条件的限制，可以这样写：x&gt;0.01。</span></span><br><span class="line">    <span class="keyword">while</span>(double2Str(x)!=<span class="string">"0"</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">double</span> sum=<span class="number">1.0</span>/i;</span><br><span class="line">        <span class="keyword">while</span>(sum &lt; x)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            sum += <span class="number">1.0</span>/i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i<span class="number">-1</span> &lt;&lt; <span class="string">" card(s)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> ACM </category>
          
          <category> POJ </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>POJ 1003 Hangover</title>
      <link href="/blog/2018/01/21/POJ-1004-Financial-Management/"/>
      <url>/blog/2018/01/21/POJ-1004-Financial-Management/</url>
      <content type="html"><![CDATA[<p>这一题简单的有点过分了，一度让我有点怀疑，但当我直接提交 AC 的那一刻，才发现还真是就这么简单。</p><p>C++ 代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">double</span> sum;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; x)&#123;</span><br><span class="line">        sum += x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"$"</span> &lt;&lt; sum/<span class="number">12</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> ACM </category>
          
          <category> POJ </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>POJ 1005 I Think I Need a Houseboat</title>
      <link href="/blog/2018/01/21/POJ-1005-I-Think-I-Need-a-Houseboat/"/>
      <url>/blog/2018/01/21/POJ-1005-I-Think-I-Need-a-Houseboat/</url>
      <content type="html"><![CDATA[<p>这一题也很简单，直接上代码：</p><p>C++ 代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.141592653589793</span>;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">    <span class="keyword">double</span> area;</span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        area = PI*(x*x+y*y)/<span class="number">2</span>;</span><br><span class="line">        year = area/<span class="number">50</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Property "</span> &lt;&lt; i &lt;&lt; <span class="string">": This property will begin eroding in year "</span> &lt;&lt; year &lt;&lt; <span class="string">"."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"END OF OUTPUT."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> ACM </category>
          
          <category> POJ </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>POJ 1001 Exponentiation</title>
      <link href="/blog/2018/01/20/POJ-1001-Exponentiation/"/>
      <url>/blog/2018/01/20/POJ-1001-Exponentiation/</url>
      <content type="html"><![CDATA[<p>这是我第一次做 ACM，也是 POJ 上的第一题，本来以为这一题应该属于很简单的题，但没想到却花了不少时间。</p><p>本来我是想着用C++标准库的 pow 函数，但这一题显然是个大实数乘法，double 可能就不够用了，所以只能自己手动实现乘法。Java 有个 BigInteger 和 BigDecimal 分别用来处理大整数和大实数。</p><p>我的代码（已经 AC）：</p><p>C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 两数相乘，使用vector保存每一位数字，从低位到高位</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Multi(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v1.size() + v2.size() + <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        result.push_back(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v1.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; v2.size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            result[i + j] += v1[i] * v2[j];</span><br><span class="line">            result[i + j + <span class="number">1</span>] += result[i + j] / <span class="number">10</span>;</span><br><span class="line">            result[i + j] %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; str &gt;&gt; n)&#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; str &lt;&lt; " " &lt;&lt; n &lt;&lt; " ";</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numArray;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; resultArray;</span><br><span class="line">        <span class="keyword">int</span> dotPos = <span class="number">0</span>, begin = <span class="number">0</span>, end = str.length() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果全是0和. 就直接输出0</span></span><br><span class="line">        <span class="keyword">bool</span> isAllZero = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">bool</span> hasDot = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i]!=<span class="string">'0'</span> &amp;&amp; str[i]!=<span class="string">'.'</span>)&#123;</span><br><span class="line">                isAllZero = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(str[i]==<span class="string">'.'</span>)&#123;</span><br><span class="line">                hasDot = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isAllZero)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果没有小数点就不用删除后序零</span></span><br><span class="line">        <span class="keyword">if</span>(hasDot)&#123;</span><br><span class="line">            <span class="comment">//删除后序零（只删除小数点后的后序零，小数点之前的零保留，比如 10.0，变成10，而不是1）</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = str.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(str[i] != <span class="string">'0'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    end = i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测出小数位数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = end; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] == <span class="string">'.'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dotPos = end - i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除前序零（如果小数点被0包裹，那么也将小数点删除，比如：00.001，变成1）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] != <span class="string">'0'</span> &amp;&amp; str[i]!=<span class="string">'.'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                begin = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将浮点数按位保存为整型</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = end; i &gt;= begin; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i]!=<span class="string">'.'</span>)&#123;</span><br><span class="line">                numArray.push_back(str[i] - <span class="string">'0'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 复制数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numArray.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            resultArray.push_back(numArray[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算数组的n次方</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n<span class="number">-1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            resultArray = Multi(resultArray, numArray);</span><br><span class="line">            <span class="keyword">int</span> len = resultArray.size();</span><br><span class="line">            <span class="comment">// 移除前导零</span></span><br><span class="line">            <span class="keyword">while</span> (resultArray[len<span class="number">-1</span>] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                resultArray.pop_back();</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出结果，结果小于零时</span></span><br><span class="line">        <span class="keyword">if</span>(n * dotPos &gt;= resultArray.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"."</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n * dotPos - resultArray.size(); k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"0"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=resultArray.size()<span class="number">-1</span>;k&gt;=<span class="number">0</span>;k--)&#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; resultArray[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = resultArray.size() - <span class="number">1</span>; k &gt;= <span class="number">0</span>; k--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (k == n * dotPos - <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">"."</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; resultArray[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我自己写了一个测试用例的脚本：</p><p>input.cpp:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> buffer;</span><br><span class="line">    <span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">"hello.txt"</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (! in.is_open())  </span><br><span class="line">       &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Error opening file"</span>; <span class="built_in">exit</span> (<span class="number">1</span>); &#125;</span><br><span class="line">       <span class="keyword">while</span> (!in.eof() )  </span><br><span class="line">       &#123;  </span><br><span class="line">        getline(in,buffer);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; buffer &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hello.txt 内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">95.123 12</span><br><span class="line">0.4321 20</span><br><span class="line">5.1234 15</span><br><span class="line">6.7592  9</span><br><span class="line">98.999 10</span><br><span class="line">1.0100 12</span><br><span class="line">.00001  1</span><br><span class="line">.12345  1</span><br><span class="line">0001.1  1</span><br><span class="line">1.1000  1</span><br><span class="line">10.000  1</span><br><span class="line">000.10  1</span><br><span class="line">000000  1</span><br><span class="line">000.00  1</span><br><span class="line">.00000  0</span><br><span class="line">000010  1</span><br><span class="line">000.10  1</span><br><span class="line">0000.1  1</span><br><span class="line">00.111  1</span><br><span class="line"></span><br><span class="line">0.0001  1</span><br><span class="line">0.0001  3</span><br><span class="line">0.0010  1</span><br><span class="line">0.0010  3</span><br><span class="line">0.0100  1</span><br><span class="line">0.0100  3</span><br><span class="line">0.1000  1</span><br><span class="line">0.1000  3</span><br><span class="line">1.0000  1</span><br><span class="line">1.0000  3</span><br><span class="line">1.0001  1</span><br><span class="line">1.0001  3</span><br><span class="line">1.0010  1</span><br><span class="line">1.0010  3</span><br><span class="line">1.0100  1</span><br><span class="line">1.0100  3</span><br><span class="line">1.1000  1</span><br><span class="line">1.1000  3</span><br><span class="line">10.000  1</span><br><span class="line">10.000  3</span><br><span class="line">10.001  1</span><br><span class="line">10.001  3</span><br><span class="line">10.010  1</span><br><span class="line">10.010  3</span><br><span class="line">10.100  1</span><br><span class="line">10.100  3</span><br><span class="line">99.000  1</span><br><span class="line">99.000  3</span><br><span class="line">99.001  1</span><br><span class="line">99.001  3</span><br><span class="line">99.010  1</span><br><span class="line">99.010  3</span><br><span class="line">99.100  1</span><br><span class="line">99.100  3</span><br><span class="line">99.998  1</span><br><span class="line">99.998  3</span><br></pre></td></tr></table></figure><p>这些测试用例都是前辈们留下来的资料。链接在这里：<a href="http://poj.org/showmessage?message_id=76017" target="_blank" rel="noopener">测试用例</a></p><p>顺带讲一下怎么自动测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//打开命令行，先编译两个 C++ 文件：</span><br><span class="line">g++ -std=c++11 -o input input.cpp</span><br><span class="line">g++ -std=c++11 -o main main.cpp</span><br><span class="line">//然后用管道把输入输出串起来，把最终解输入到文件 output.txt 里</span><br><span class="line">./input | ./main &gt; output.txt</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> ACM </category>
          
          <category> POJ </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Override Overload Overwrite</title>
      <link href="/blog/2017/11/14/Override-Overload-Overwrite/"/>
      <url>/blog/2017/11/14/Override-Overload-Overwrite/</url>
      <content type="html"><![CDATA[<p>我们都知道有些东西容易混淆，在加上中文翻译得乱七八糟，更加让人困惑。今天我要讲的这三位可就真是绝了。</p><p>它们是：Override、Overload、Overwrite。</p><p>这是我查有道词典时候看到的可怕一幕：</p><p><img src="https://wx4.sinaimg.cn/mw690/006zFO3ggy1flhl8a9e69j312w0tatf9.jpg" alt=""></p><p>Override 一个把三个名字都占了，你怕不怕？反正我是看的心里一紧。</p><p>如果把概念都煮成了一锅粥，那还不如不要记这些概念，你应该向更深层次去探寻。就这三个的区别来说，我觉得主要理解两个概念就行了：</p><ol><li>函数签名（signature）</li><li>多态（polymorphism、polymorphic）</li></ol><h2 id="函数签名"><a href="#函数签名" class="headerlink" title="函数签名"></a>函数签名</h2><p>函数签名是什么，其实就是用来区别函数的，两个函数怎么样认定是不同的两个函数呢，只有两个方面：</p><ol><li>函数名</li><li>参数</li></ol><p>有人说还有返回值啊，不行，返回值不能作为函数签名的一部分，因为你调用一个函数的时候，返回值根本不能帮助编译器来识别你用的是哪个函数，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line">func();</span><br></pre></td></tr></table></figure><p>请问我使用的是哪个函数？你看返回值确实不行吧。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态是面向对象编程的概念，你可以看看它的准确定义：</p><p><a href="https://en.wikipedia.org/wiki/Polymorphism_(computer_science" target="_blank" rel="noopener">Polymorphism</a>)。</p><p>定义很简短：polymorphism is the provision of a single interface to entities of different types.</p><p><a href="https://docs.oracle.com/javase/tutorial/java/IandI/polymorphism.html" target="_blank" rel="noopener">The Java™ Tutorials</a></p><p>如果父类有一个函数，子类也定义了一个完全相同的函数（函数签名相同），那么你可以用父类指针（或者说父类对象）作为统一的接口，来调用子类的方法。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(“Vehicles can move!!”);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MotorBike</span> <span class="title">extends</span> <span class="title">Vehicle</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(“MotorBike can move <span class="keyword">and</span> accelerate too!!”);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="title">extends</span> <span class="title">Vehicle</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(“Hi! I am a car!”);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Vehicle vh = <span class="keyword">new</span> MotorBike();</span><br><span class="line">        vh.move();    <span class="comment">// prints MotorBike can move and accelerate too!!</span></span><br><span class="line">        vh = <span class="keyword">new</span> Vehicle();</span><br><span class="line">        vh.move();    <span class="comment">// prints Vehicles can move!!</span></span><br><span class="line">        vh = <span class="keyword">new</span> Car();</span><br><span class="line">        vh.move();   <span class="comment">// prints Hi! I am a car!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多态的好处是可以扩展啊，比如我后来又多了个 truck 类，我不需要去动已经写好的代码，只要把 truck 模块写好，加进去就行了。</p><h2 id="Override、Overload、Overwrite-的区别"><a href="#Override、Overload、Overwrite-的区别" class="headerlink" title="Override、Overload、Overwrite 的区别"></a>Override、Overload、Overwrite 的区别</h2><p>好了，知道了这两个概念，我们再来看看上面的那三个混在一起的东西：</p><ul><li>Override（推翻，对英文意思就是这个）subclass method overrides base class method means:<ul><li>in different range (in derived class and base class)</li><li>the same function signature</li><li>the base class method is virtual（if in C++）</li></ul></li><li>overload（超载）function overloading means:<ul><li>the same range (in the same class)</li><li>the same function name</li><li>but different function signature</li></ul></li><li>overwrite（重写）subclass method hides base class method means:<ul><li>in different range (in derived class and base class)</li><li>the same function name</li></ul></li></ul><p>我们应该记住只有 Override 才跟多态有关。</p><p>Overload 是本class 里面的不同函数（只不过函数名一样罢了，其实是两个不同的函数，看两个函数是否是同一个函数就看函数签名就行了），其实没啥稀奇的，不就是函数名一样嘛。函数签名一样，区分出是用父类还是子类的函数，这才是面向对象和多态要解决的问题。</p><h2 id="Override-和-Overwrite-的区别"><a href="#Override-和-Overwrite-的区别" class="headerlink" title="Override 和 Overwrite 的区别"></a>Override 和 Overwrite 的区别</h2><blockquote><p>比较容易混淆的其实是 Override 和 Overwrite，但你只要死记住：Override 必须函数签名要一样，而 Overwrite 只需函数名一样即可。另外 C++ 中一定要用virtual才算 Override，而 Java 默认就是 Override，不需要修饰词。</p></blockquote><blockquote><p>这里关于 Java 和 C++ 面向对象的细节区别可以写一大堆，比如：C++ class 后面是要加分号的，而 Java 不需要；但 Java 的类名是和文件名要一致的，而且只能有一个 public 类，而 C++不需要；Java 直接就能用 Override，而 C++必须要使用 virtual 关键字才能使用 Override（虚函数）；Java 的抽象方法跟 C++的纯虚函数对应。Java 是单继承，由接口来实现“多继承”，C++是多继承，没有接口，只有抽象类。C++还有个虚基类的概念。具体的写法上还有很多的不同，多用这两种语言写面向对象的代码，就慢慢会知道了。</p></blockquote><p>C++ 有一个 virtual 关键字和 virtual table 这个概念，没有加 virtual 的父类函数是不可能形成多态的，如果这时候你碰到父类和子类两个里面有同名的函数，那么就属于 Overwrite 这个概念了，你其实也可以称这种覆盖掉父类函数的行为为：hide 隐藏。Java 这种语言里面没有 virtual 这一套，Java 也可以表现出 Overwrite，但要注意函数签名如果一样的话，那又不叫 Overwrite 了，应该叫 Override 了（Java 如果要在子类中使用父类的同函数签名方法，则必须使用 super 关键字）。而 C++ 不一样，即便是函数签名一样，如果前面不加 virtual 是不能叫 Override 的，仍然属于 Overwrite 的概念。请看下面的例子：</p><p>用 C++ 写的话：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"A"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"B"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A *a = <span class="keyword">new</span> B();</span><br><span class="line">    a-&gt;func(<span class="number">1</span>);</span><br><span class="line">    ((B*)a)-&gt;func(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">B</span><br></pre></td></tr></table></figure><p>可以看到，C++必须要用子类类型的指针才能访问到子类的部分（建议看一本书，叫：Inside the C++ Object Model，中文叫：深入C++对象模型，里面讲对象的内存布局讲的很清楚），java 也一样，必须转成子类型的指针才能访问，否则 IDE 会报错提示你。</p><p>Java 代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"A"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="title">extends</span> <span class="title">A</span>&#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"B"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        test t = <span class="keyword">new</span> test();</span><br><span class="line">        A a = t.<span class="keyword">new</span> B();</span><br><span class="line">        a.fun(<span class="number">1</span>);</span><br><span class="line">        ((B)a).func(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">B</span><br></pre></td></tr></table></figure><p>为什么 Java 代码里不像 C++ 代码里面那样，使用两个函数签名相同的函数？因为前面说过了，那样的话就变成 Override 了，只有在 C++ 里才能实现函数签名相同的 Overwrite（不使用virtual即可）。</p>]]></content>
      
      <categories>
          
          <category> 编程范式 </category>
          
          <category> 面向对象编程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Inside the C++ Object Model 系列笔记 四 -- The Semantics of Function</title>
      <link href="/blog/2017/10/23/Inside-the-C++-Object-Model-%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0--The-Semantics-of-Function/"/>
      <url>/blog/2017/10/23/Inside-the-C++-Object-Model-%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0--The-Semantics-of-Function/</url>
      <content type="html"><![CDATA[<blockquote><p>c++支持三种类型的成员函数，分别为static,nostatic,virtual。每一种调用方式都不尽相同。</p></blockquote><h2 id="nonstatic-member-function"><a href="#nonstatic-member-function" class="headerlink" title="nonstatic member function"></a>nonstatic member function</h2><p>C++的设计准则之一就是:nonstatic member function至少必须和一般的nonmember function 有相同的效率。<br>实际上，nonstatic member function 会被编译器进行如下的转换，变成一个普通函数:</p><p>Type1 X::foo(Type2 arg1) { … }</p><p>会被转换为如下的普通函数:</p><p>void foo(X *const this, Type1 &amp;__result, Type2 arg1) { … }</p><p>改写函数原型，在参数中增加this指针，对每一个”nonstatic data member的存取操作”改为由this指针来存取</p><p>将member function重写为一个外部函数，经过”mangling”处理（不需要处理的加上 extern “C”）</p><p>实际上，普通函数、普通成员函数、静态成员函数到最后都会变成与C语言函数类似的普通函数，只是编译器在这些不同类型的函数身上做了不同的扩展，并放在不同的 scope 里面而已。</p><p>编译器内部会将成员函数等价转换为非成员函数，具体是这样做的:</p><p>1.改写成员函数的签名，使得其可以接受一个额外参数，这个额外参数即是this指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> Point::X();</span><br><span class="line"><span class="comment">//成员函数X被插入额外参数this</span></span><br><span class="line"><span class="keyword">float</span> Point:: X(Point* <span class="keyword">this</span> );</span><br></pre></td></tr></table></figure><p>当然如果成员函数是const的，插入的参数类型将为 const Point* 类型。</p><p>2.将每一个对非静态数据成员的操作都改写为经过this操作。</p><p>3.将成员函数写成一个外部函数，对函数名进行“mangling”处理，使之成为独一无二的名称。</p><p>可以看出，将一个成员函数改写成一个外部函数的关键在于两点，一是给函数提供一个可以直接读写成员数据的通道；<br>二是解决好有可能带来的名字冲突。第一点通过给函数提供一个额外的指针参数来解决，第二点则是通过一定的规则将名字转换，使之独一无二。</p><p>于是在VC中对于上面的例子中的成员函数的调用将发生如下的转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//p-&gt;X();被转化为</span></span><br><span class="line">?X@Point@@QAEMXZ(p);</span><br><span class="line"><span class="comment">//obj.X();被转化为</span></span><br><span class="line">?X@Point@@QAEMXZ(&amp;obj);</span><br></pre></td></tr></table></figure><p>覆盖（override）、重载（overload）、隐藏（hide, overwrite）的区别：</p><ul><li>覆盖（也叫重写）是指在派生类中重新对基类中的虚函数（注意是虚函数）重新实现。即函数名和参数都一样（函数签名一样），只是函数的实现体不一样。</li><li>重载是指 <strong>在同一个类中</strong> 不同的函数使用相同的函数名，但是函数的参数个数或类型不同。调用的时候根据函数的参数来区别不同的函数。</li><li>隐藏是指派生类中的函数把基类中相同名字的函数屏蔽掉了。隐藏与另外两个概念表面上看来很像，很难区分，其实他们的关键区别就是在多态的实现上。</li></ul><blockquote><p>C++多态（polymorphism）表示”以一个public base class的指针（或者reference），寻址出一个derived class object”</p></blockquote><p>我专门写了一篇关于这些容易弄混的概念的文章：<a href="../2017/11/14/Override-Overload-Overwrite">Override Overload Overwrite</a></p><h2 id="Virtual-Member-Function"><a href="#Virtual-Member-Function" class="headerlink" title="Virtual Member Function"></a>Virtual Member Function</h2><p>如果function()是一个虚拟函数，那么用指针或引用进行的调用将发生一点特别的转换——一个中间层被引入进来。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p-&gt;function()</span></span><br><span class="line"><span class="comment">//将转化为</span></span><br><span class="line">(*p-&gt;vptr[<span class="number">1</span>])(p);</span><br></pre></td></tr></table></figure><ul><li>其中vptr为指向虚函数表的指针，它由编译器产生。vptr也要进行名字处理，因为一个继承体系可能有多个vptr。</li><li>1是虚函数在虚函数表中的索引，通过它关联到虚函数function().</li></ul><p>何时发生这种转换？答案是在必需的时候 – 一个再熟悉不过的答案。当通过指针调用的时候，要调用的函数实体无法在编译期决定，必需待到执行期才能获得，所以上面引入一个间接层的转换必不可少。但是当我们通过对象（不是引用，也不是指针）来调用的时候，<br>进行上面的转换就显得多余了，因为在编译器要调用的函数实体已经被决定。此时调用发生的转换，与一个非静态成员函数(Nonstatic Member Functions)调用发生的转换一致。p.function()的处理就跟非静态成员函数一样了。</p><h2 id="Static-Member-Function"><a href="#Static-Member-Function" class="headerlink" title="Static Member Function"></a>Static Member Function</h2><ul><li>不能够直接存取其类中的非静态成员（nostatic members），包括不能调用非静态成员函数(Nonstatic Member Functions)。</li><li>不能声明为const、volatile或virtual</li><li>参数没有this</li><li>可以不用对象访问，直接 类名::静态成员函数 访问，当然，通过对象调用也被允许</li></ul><p>需要注意的是通过一个表达式或函数对静态成员函数进行调用，被C++ Standard要求对表达式进行求值。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(a+=b).static_fuc();</span><br><span class="line">func().static_fuc();</span><br></pre></td></tr></table></figure><p>虽然省去对a+b求值对于static_fuc()的调用并没有影响，但是程序员肯定会认为表达式a+=b已经执行，一旦编译器为了效率省去了这一步，很难说会浪费多少程序员多少时间去查找这个bug。这无疑是一个明智的规定。func()返回一个对象。</p><p>vtable的内容：</p><ul><li>virtual class offset（有虚基类才有）</li><li>topoffset</li><li>typeinfo</li><li>继承基类所声明的虚函数实例，或者是覆盖（override）基类的虚函数</li><li>新的虚函数（或者是纯虚函数占位）</li></ul><p>虚函数表的构造挺简单的：</p><p><img src="https://i.loli.net/2018/04/25/5ae01bb4b32a9.gif" alt="虚函数表的构造"></p><p>从内存布局的角度看，类对象继承基类的时候只把基类的 nonstatic data member和member function（函数入口，也可以说是函数指针） 放进自己内存里，static data member和static function都在global address里面。然后就是虚函数表是复制了一份基类的虚函数表，然后把virtual实现了的部分替换掉，没实现的就不改，依然用父类的。然后虚函数表指针自然也要不一样，毕竟指向的内存地址不一样，对吧。</p>]]></content>
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 《Inside the C++ Object Model》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Inside the C++ Object Model 系列笔记 三 -- The Semantics of Data</title>
      <link href="/blog/2017/10/21/Inside-the-C++-Object-Model-%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0--The-Semantics-of-Data/"/>
      <url>/blog/2017/10/21/Inside-the-C++-Object-Model-%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0--The-Semantics-of-Data/</url>
      <content type="html"><![CDATA[<p>C++对象模型的细节，讨论了 data members 的处理。</p><h2 id="空类在内存中有空间吗"><a href="#空类在内存中有空间吗" class="headerlink" title="空类在内存中有空间吗"></a>空类在内存中有空间吗</h2><p>一个实例引出的思考：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> X&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Z</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> X&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span><span class="keyword">public</span> Y, <span class="keyword">public</span> Z&#123;&#125;;</span><br></pre></td></tr></table></figure><p>猜猜sizeof上面各个类都为多少？</p><p>Lippman的一个法国读者的结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sizeof X yielded 1</span><br><span class="line">sizeof Y yielded 8</span><br><span class="line">sizeof Z yielded 8</span><br><span class="line">sizeof A yielded 12</span><br></pre></td></tr></table></figure><p>Lippman自己的结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sizeof X yielded 1</span><br><span class="line">sizeof Y yielded 4</span><br><span class="line">sizeof Z yielded 4</span><br><span class="line">sizeof A yielded 8</span><br></pre></td></tr></table></figure><p>事实上，对于像X这样的一个空类，编译器会对其动点手脚——隐晦的插入一个字节。为什么要这样做呢？插入了这一个字节，那么X的每一个对象都将有一个独一无二的地址。<br>如果不插入这一个字节呢？哼哼，那对X的对象取地址的结果是什么？两个不同的X对象间地址的比较怎么办？</p><p>我们再来看Y和Z。首先我们要明白的是实现虚继承，将要带来一些额外的负担——额外需要一个某种形式的指针。到目前为止，对于一个32位的机器来说Y、Z的大小应该为5，而不是8或者4。我们需要再考虑两点因素：内存对齐（alignment—）和编译器的优化。</p><p>空类也有1Byte的大小，因为这样才能使得这个class的2个objects在内存中有独一无二的地址。</p><h2 id="The-Binding-of-a-Data-Member"><a href="#The-Binding-of-a-Data-Member" class="headerlink" title="The Binding of a Data Member"></a>The Binding of a Data Member</h2><p>考虑下面这样的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">float</span> x;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">truePoint3d(<span class="keyword">float</span>, <span class="keyword">float</span>, <span class="keyword">float</span>);</span><br><span class="line">true<span class="comment">//问题是 x 到底是哪个 x 呢</span></span><br><span class="line">true<span class="function"><span class="keyword">float</span> <span class="title">X</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">true<span class="function"><span class="keyword">void</span> <span class="title">X</span><span class="params">(<span class="keyword">float</span> new_x)</span> <span class="keyword">const</span></span>&#123;x = new_x;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">true<span class="keyword">float</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对member functions本身的分析会直到整个class的声明都出现了才开始（直到看到代表 class 结束的}右大括号）。所以class的 member functions 可以引用声明在后面的成员，C 语言就做不到。</p><p>和member functions对比，需要十分注意的一点是:<br>class中的typedef并不具备这个性质。<br>因此，类中的 typedef 的影响会受到函数与 typedef 的先后顺序的影响。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> length;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">true<span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(length l)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; l &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">true<span class="keyword">typedef</span> <span class="built_in">string</span> length;</span><br><span class="line">true<span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(length l)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; l &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样 f1 绑定的 length 类型是 int;<br>而 f2 绑定的 length 类型才是 string。</p><p>所以，对于 typedef 需要防御性的程序风格:<br>始终把 nested type 声明(即 typedef)放在 class 起始处!</p><h2 id="Data-Member-Layout"><a href="#Data-Member-Layout" class="headerlink" title="Data Member Layout"></a>Data Member Layout</h2><p>C++只保证处于同一个 access section（也就是private,public,protected片段）的数据，一定会以声明的次序出现在内存布局当中(要求较晚出现的数据成员处在较大的内存地址中)。<br>C++标准只提供了这一点点的保证。<br>允许编译器将多个Acess Section的顺序自由排列，而不必在乎它们的声明次序。但似乎没有编译器这样做。<br>对于继承类，C++标准并未指定是其基类成员在前还是自己的成员在前。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="keyword">int</span> k;</span><br><span class="line">   <span class="keyword">int</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据 i 一定在 j 之前，k 一定在 n 之前。具体什么顺序就看编译器了。</p><p>传统上，vptr被安放在所有被明确声明的member的最后，不过也有些编译器把vptr放在最前面(MSVC++就是把 vptr 放在最前面，而 G++ 是把 vptr 放在最后面)。</p><h2 id="Access-of-a-Data-Member"><a href="#Access-of-a-Data-Member" class="headerlink" title="Access of a Data Member"></a>Access of a Data Member</h2><p>在C++中，直观上来说，由一个对象存取一个member会比由一个指针存取一个member更快捷。<br>但是对于经由一个对象来存取和由一个指针来存取一个静态的 member 来说，是完全一样的，都会被编译器所扩展。</p><p>经由 member selection operators（也就是 “.” 运算符）对一个 static data member 进行存取操作只是一种语法上的便宜行事而已。member 其实并不在 class object 中，因此存取并不需要通过 class object。</p><p>经由一个函数调用的结果来存取静态成员，C++标准要求编译器必须对这个函数进行求值，虽然这个求值的结果并无用处。</p><p>foo().static_member = 100;</p><p>foo()返回一个类型为 X 的对象，含有一个 static_member，foo()其实可以不用求值而直接访 问这个静态成员，但是 C++标准保证了 foo()会被求值，可能的代码扩展为:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">void</span>) foo();</span><br><span class="line">X::static_member = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><h2 id="static-data-members"><a href="#static-data-members" class="headerlink" title="static data members"></a>static data members</h2><p>如果有两个 class ，每个都声明了一个 static member freelist，那么当他们都被放在程序的 data segment时，就会导致名称冲突。编译器的解决方法是暗中对每一个 static data member 编码（这种手法有个很美的名称：name-mangling），以获得一个独一无二的程序识别代码。有多少种编译器就有多少种 name-mangling 做法！通常不外乎是表格啦，语法措辞啦等等。任何 name-mangling 都有两个要点：</p><ol><li>一种算法，推导出独一无二的名称。</li><li>万一编译系统（或环境工具）必须和使用者交谈，那些独一无二的名称可以轻易被推导回原来的名称。</li></ol><h2 id="nonstatic-data-members"><a href="#nonstatic-data-members" class="headerlink" title="nonstatic data members"></a>nonstatic data members</h2><p>Nonstatic data members are stored directly within each class object and cannot be accessed except through an explicit or implicit class object. An implicit class object is present whenever the programmer directly accesses a nonstatic data member within a member function. For example, in the following code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Point3d</span><br><span class="line">Point3d::translate( <span class="keyword">const</span> Point3d &amp;pt ) &#123;</span><br><span class="line">   x += pt.x;</span><br><span class="line">   y += pt.y;</span><br><span class="line">   z += pt.z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>the seemingly direct access of x, y, and z is actually carried out through an implicit class object represented<br>by the this pointer. Internally, the function is augmented as follows:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// internal augmentation of member function</span></span><br><span class="line">  Point3d</span><br><span class="line">  Point3d::translate( <span class="keyword">const</span> Point3d* <span class="keyword">this</span>, <span class="keyword">const</span> Point3d &amp;pt ) &#123;</span><br><span class="line">     <span class="keyword">this</span>-&gt;x += pt.x;</span><br><span class="line">     <span class="keyword">this</span>-&gt;y += pt.y;</span><br><span class="line">     <span class="keyword">this</span>-&gt;z += pt.z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>地址：&amp;origin._y;和&amp;origin + ( &amp;Point3d::_y - 1 );是一样的。指向 data member 的指针，其 offset 值总是被加上1。这样可以使编译系统区分出 “一个指针 data member 的指针，用以指向 class 的第一个 member”和“一个指向 data member 的指针，但是没有指向任何 member”两种情况(成员指针也需要有个表示 NULL 的方式，0 相当于用来表示 NULL 了，其它的就都要加上 1 了)。</p><h2 id="Inheritance-and-the-Data-Member"><a href="#Inheritance-and-the-Data-Member" class="headerlink" title="Inheritance and the Data Member"></a>Inheritance and the Data Member</h2><p>C++ Standard 保证:“出现在派生类中的 base class subobject 有其完整原样性!” 子类会被放在父类的对齐空白字节之后，因为父类的完整性必须得以保证，父类的对齐空白字节 也是父类的一部分，也是不可分割的。</p><p>请看下面例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X2</span>:</span><span class="keyword">public</span> X</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span>  c2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>X2的布局应当是x(4),c(1),c2(1),这么说来sizeof(X2)的值应该是8？错了，实际上是12。原因在于X后面的三个字节的填充空白不能为c2所用。也就是说X2的大小实际上为：X(8)+c2(1)+填补（3）=12。这样看来编译器似乎是那么的呆板，其实不然，看一下下面的语句会发生什么？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X2 x2;</span><br><span class="line">X x;</span><br><span class="line">x2=x;</span><br></pre></td></tr></table></figure><p>如果X后面的填充空白可以被c2使用的话，那么X2和X都将是8字节。上面的语句执行后x2.c2的值会是多少？一个不确定的值！这样的结果肯定不是我们想要的。</p><p>在多重继承的派生体系中，将派生类的地址转换为第 1 基类时成本与单继承是相同的，只需要改换地址的解释方式而已；而对于转换为非第 1 基类的情况，则需要对地址进行一定的 offset 操作 才行。<br>C++ Standard 并未明确 base classes 的特定排列次序，但是目前的编译器都是按照声明的次序来安放他们的。(有一个优化:如果第 1 基类没有 vtable 而后继基类有，则可能把它们调 个位置)。<br>多重继承中，可能会有多个 vptr 指针，视其继承体系而定:派生类中 vptr 的数目最多等于所有基<br>类的 vptr 数目的总和。</p>]]></content>
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 《Inside the C++ Object Model》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Inside the C++ Object Model 系列笔记 一 -- Object Lessons</title>
      <link href="/blog/2017/10/19/Inside-the-C++-Object-Model-%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0--Object-Lessons/"/>
      <url>/blog/2017/10/19/Inside-the-C++-Object-Model-%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0--Object-Lessons/</url>
      <content type="html"><![CDATA[<blockquote><p>多态：统一的接口，不同的实现</p></blockquote><p><strong>C++多态（polymorphism）</strong> 表示”以一个public base class的指针（或者reference），寻址出一个derived class object”</p><h2 id="Layout-Costs-for-Adding-Encapsulation-封装"><a href="#Layout-Costs-for-Adding-Encapsulation-封装" class="headerlink" title="Layout Costs for Adding Encapsulation(封装)"></a>Layout Costs for Adding Encapsulation(封装)</h2><p>第一章 Object Lessons 介绍了 C++如何在背后实现一个对象，内存中的布局以及空间上的关系。</p><p><strong>在计算机的原理中，要实现某个机制，我们总能找到很多种实现方式</strong>（对比着学习，多思考每种实现方法的利弊），C++的类的实现也不例外，让我们对比以下三种实现方式：</p><h3 id="三种对象实现模式"><a href="#三种对象实现模式" class="headerlink" title="三种对象实现模式"></a>三种对象实现模式</h3><h4 id="A-Simple-Object-Model"><a href="#A-Simple-Object-Model" class="headerlink" title="A Simple Object Model"></a>A Simple Object Model</h4><p><img src="https://wx4.sinaimg.cn/mw690/006zFO3ggy1fknaq5739jj30nu0l4jsy.jpg" alt="A Simple Object Model"></p><p>可以看到，简单对象模型把所有的data member和member function（函数指针）都放在对象里了。</p><h4 id="A-Table-driven-Object-Model"><a href="#A-Table-driven-Object-Model" class="headerlink" title="A Table-driven Object Model"></a>A Table-driven Object Model</h4><p><img src="https://wx4.sinaimg.cn/mw690/006zFO3ggy1fmxnb321f6j30n80kemzy.jpg" alt="A Table-driven Object Model"></p><p>表驱动模型把member分为data和function两类，用两个指针分别指向两个表，一个存放所有的data member，一个存放所有的function指针。</p><h4 id="The-C-Object-Model"><a href="#The-C-Object-Model" class="headerlink" title="The C++ Object Model"></a>The C++ Object Model</h4><p><img src="https://wx3.sinaimg.cn/mw690/006zFO3ggy1fmxnd1t7ucj30ua0ju0wu.jpg" alt="The C++ Object Model"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Point3d</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point3d(Type x, Type y, Type z) : x_(x), y_(y), z_(z) &#123;&#125;</span><br><span class="line">    <span class="function">Type <span class="title">x</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x_; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Type x_, y_, z_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 C++ 类并不会比 C 语言 的struct 耗费更多的内存空间，三个 data members 直接内含于 Object 中，member functions 则放在 Object 外。</p><p>C++的 data members 有两种：<strong>static 和 nonstatic</strong></p><p>C++的 member functions 有三种：<strong>static 、nonstatic 、virtual</strong></p><blockquote><p>放在 Object 中的只有 nonstatic data members，其他的统统是放在 Object 外。</p></blockquote><p>一个对象的内存布局大小(通常由 3 部分组成):</p><ul><li>其 nonstatic data member 的总和大小;</li><li>任何由于位对齐所需要的填补上去的空间;(关于内存对齐，自己查)</li><li>加上了为了支持virtual机制而引起的额外负担。</li></ul><h3 id="data-members-在内存中的布局"><a href="#data-members-在内存中的布局" class="headerlink" title="data members 在内存中的布局"></a>data members 在内存中的布局</h3><p>C++只保证处于同一个 access section（也就是private,public,protected片段）的数据，一定会以声明的次序出现在内存布局当中(要求较晚出现的数据成员处在较大的内存地址中)。<br>C++标准只提供了这一点点的保证。<br>允许编译器将多个Acess Section的顺序自由排列，而不必在乎它们的声明次序。但似乎没有编译器这样做。<br>对于继承类，C++标准并未指定是其基类成员在前还是自己的成员在前。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="keyword">int</span> k;</span><br><span class="line">   <span class="keyword">int</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据 i 一定在 j 之前，k 一定在 n 之前。具体什么顺序就看编译器了。</p><h3 id="Virtual-Table-vtbl-vtable-和-vptr"><a href="#Virtual-Table-vtbl-vtable-和-vptr" class="headerlink" title="Virtual Table(vtbl, vtable) 和 vptr"></a>Virtual Table(vtbl, vtable) 和 vptr</h3><p>Virtual function 机制由以下2个步骤来支持：</p><ol><li>每个 class 产生的 Virtual function 的指针放在 Virtual Table 中</li><li>编译器给每个 class object 添加一个指针 vptr，指向相应的 vtable</li></ol><p>一个 vtable 对应一个 class，一个 vptr 才对应一个 class object，必须区分开这 2 个概念。vtable 独立于对象，就跟函数独立于对象一样。<br>这样所有对象才能共享它们，就像 static data members 被共享一样。</p><p>RTTI(run-time type identification):一般来说，每一个 class 相关联的 type_info 对象的指针通常也保存在 vtable 的第一个 slot 中。关于 type_info 是什么，可以自己查。</p><h3 id="引入继承后的对象模型成本"><a href="#引入继承后的对象模型成本" class="headerlink" title="引入继承后的对象模型成本"></a>引入继承后的对象模型成本</h3><ul><li>如果是普通继承，父对象被直接包含在子对象里面，这样父对象的存取也是直接进行的，没有额外的指针成本。</li><li>如果是虚拟继承，父对象由一个指针指出来，这样父对象的存取就必须由指针访问，添加了一层间接性。</li></ul><p>virtual base class，用以实现 “多次出现在继承体系中的base class，有一个单一而被共享的实例”</p><p><img src="https://wx3.sinaimg.cn/mw690/006zFO3gly1fknlhzg45wj30bs0asq3w.jpg" alt="虚基类"></p><p><img src="https://wx1.sinaimg.cn/mw690/006zFO3gly1fknli0837fj317w0mmhao.jpg" alt="虚拟多重继承"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> <span class="keyword">public</span>: <span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123;&#125; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> A &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> A &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>我觉得这里有个问题，class D继承class B和class C的时候并不是虚继承，所以何不将B和C直接放在D中呢？这样就省了两次指针。</p></blockquote><h2 id="struct-和-class-关键字的区别"><a href="#struct-和-class-关键字的区别" class="headerlink" title="struct 和 class 关键字的区别"></a>struct 和 class 关键字的区别</h2><p>总共就两个区别：</p><ul><li>struct defaults to public access and class defaults to private access.</li><li>When inheriting, struct defaults to public inheritance and class defaults to private inheritance. (Ironically, as with so many things in C++, the default is backwards: public inheritance is by far the more common choice, but people rarely declare structs just to save on typing the “public” keyword). 哈哈，我觉得这么做的目的无非就是提醒你注意封装，不要给外部暴露没必要的东西，所以才把默认搞成private。</li></ul><p>除此之外 struct 和 class 一样。</p><p>struct 用来表现那些只有数据的集合体 POD(Plain Old Data)、而 class则希望表达的是<code>ADT(abstract data type)</code>的思想。</p><blockquote><p>POD stands for Plain Old Data - that is, a class (whether defined with the keyword struct or the keyword class) without constructors, destructors and virtual members functions.</p></blockquote><p>由于这2个关键字在本质上无区别，所以class并没有必须要引入，但是引入它的确非常令人满意，因为这个语言所引入的不止是这个关键字，还有它所支持的封装和继承的哲学。可以这样想象:struct只剩下方便C程序员迁徙到C++的用途了。</p><h2 id="programming-paradigms"><a href="#programming-paradigms" class="headerlink" title="programming paradigms"></a>programming paradigms</h2><p>C++支持三种形式的编程风格(或称典范 paradigm):</p><ul><li>面向过程的风格（procedural model）:就像C一样，一条语句接一条语句的执行或者函数跳转;</li><li>抽象数据类型模型(abstract data type model，ADT):仅仅使用了class的封装，很多人都是 在用基于对象的风格却误以为自己在使用面向对象的风格;</li><li>面向对象的风格(object-oriented):使用了class的封装和多态的编程思维(多态才是 真正的面向对象的特征)。</li></ul><p>纯粹以一种paradigm写程序，有助于整体行为的良好稳固。</p><blockquote><p>一个 reference 通常是以一个指针来实现的，所以 point 和 reference 并没有本质的区别，reference 和 const 指针的区别就是，你取 reference 指针的地址的时候，取到的是数据的地址，const 指针取地址取到的是指针的地址。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> &amp;b=a;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; &amp;b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; &amp;p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说你取不到 b 的地址。所以说引用相当于一个 <code>别名</code>。引用常用在函数调用里，可以直接操作原有对象，这样就可以不用写指针的指针这种绕弯的东西了。</p><blockquote><p>函数的实参传递给形参是值传递，也就是一个 copy，形参在函数里将是一个局部变量。这个特性是许多新手面临的大坑。一道经典的考察题目便是，实现一个 C 语言的 swap 函数，由于 C 语言没有引用，你就只能用指针来操作原有对象了。</p></blockquote><h2 id="指针的类型"><a href="#指针的类型" class="headerlink" title="指针的类型"></a>指针的类型</h2><ul><li>对于内存来说，不同类型的指针并没有什么不同。它们都是占用一个word的大小（所以word的大小决定了内存可访问空间的大小，32位系统是4字节，64位系统是8字节），包含一个数字，这个数字代表内存中的一个地址;</li><li>指针的类型是编译器的概念，对于硬件来说，并没有什么指针类型的概念;</li><li>转型操作也只是一种编译器的指令，它改变的是编译器对被指内存的解释方式而已!</li><li>void*指针只能够持有一个地址（一个字节），而不能通过它操作所指向的object</li></ul>]]></content>
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 《Inside the C++ Object Model》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Inside the C++ Object Model 系列笔记 二 -- The Semantics of constructors</title>
      <link href="/blog/2017/10/19/Inside-the-C++-Object-Model-%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0--The-Semantics-of-constructors/"/>
      <url>/blog/2017/10/19/Inside-the-C++-Object-Model-%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0--The-Semantics-of-constructors/</url>
      <content type="html"><![CDATA[<p>这一章详细的讨论了 constructor 如何工作，讨论构造一个对象的过程以及构造一个对象给程序带来的影响。</p><h2 id="区分trivial和notrivial"><a href="#区分trivial和notrivial" class="headerlink" title="区分trivial和notrivial"></a>区分trivial和notrivial</h2><ol><li>只有编译器需要的时候(为什么会需要?后面讲的很清楚)，合成操作才是nontrivial的， 这样的函数才会被真正的合成出来;</li><li>如果编译器不需要，而程序员又没有提供，这时的默认构造函数就是trivial的。虽然它在概念上存在，但是编译器实际上根本不会去合成出来，因为他不做任何没有意义的事情，所以当然可以忽略它不去合成。trivial 的函数只存在于概念上，实际上不存在这个函数。</li></ol><h2 id="default-constructor"><a href="#default-constructor" class="headerlink" title="default constructor"></a>default constructor</h2><p>A default constructor is a constructor which can be called with no arguments (either defined with an empty parameter list, or with default arguments provided for every parameter).</p><h3 id="通常很多C-程序员存在两种误解"><a href="#通常很多C-程序员存在两种误解" class="headerlink" title="通常很多C++程序员存在两种误解"></a>通常很多C++程序员存在两种误解</h3><ul><li>没有定义默认构造函数的类都会被编译器生成一个默认构造函数。</li><li>编译器生成的默认构造函数会明确初始化类中每一个数据成员。</li></ul><p><strong>被声明：declared，被定义：defined</strong>。声明代表分配内存空间，定义代表初始化，也就是分配具体的值。</p><p>所以所有成员都在声明的时候被分配内存，构造函数的作用是初始化它们，non-object 成员需要程序员自己初始化，编译器不帮忙。</p><p>C++中对于默认构造函数的解释是:<br><strong>默认的构造函数会在需要的时候被编译器产生出来。</strong><br>这里非常重要的一点是:<br>谁需要?是程序的需要还是编译器的需要?如果是程序的需要，那是程序员的责任;<br>只有在是编译器的需要时，默认构造函数才会被编译器产生出来，而且被产生出来的默认构造函数只会执行编译器所需要的行动，而且这个产生操作只有在默认构造函数真正被调用时才会进行合成。</p><p>例如:成员变量初始化为 0 操作，这个操作就是程序的需要，而不是编译器的需要。</p><p>总结变量的初始化:</p><p>Global objects are guaranteed to have their associated memory “zeroed out” at program start-up. Local objects allocated on the program stack and heap objects allocated on the free-store do not have their associated memory zeroed out; rather, the memory retains the arbitrary bit pattern of its previous use.</p><p>只有全局变量和静态变量才会保证初始化，其中静态变量可以视为全局变量的一种，因为静态变量也是保存在全局变量的存储空间上的。<br>Golbal objects 的内存保证会在程序激活的时候被清 0；Local objects 配置于程序的堆栈中，Heap objects 配置于自由空间中，都不一定会被清为 0,它们的内容将是内存上次被使用后的痕迹!</p><p>全局变量和静态变量都放在 global data Segment 上，且在类被声明的时候就已经分配内存和初始化，也就是 <strong>在任何对象被定义之前静态变量就已经存在了（即使该 class 没有任何 object 实体，static data members也已经存在）。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span> <span class="keyword">public</span>: <span class="keyword">int</span> val; Foo *pnext; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo_bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// Oops:  program needs bar's members zeroed out</span></span><br><span class="line">   Foo bar;</span><br><span class="line">   <span class="keyword">if</span> ( bar.val || bar.pnext )</span><br><span class="line">      <span class="comment">// ... do something</span></span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>When is a default constructor synthesized, then? Only when the implementation needs it. Moreover, the synthesized constructor performs only those activities required by the implementation. That is, even if there were a need to synthesize a default constructor for class Foo, that constructor would not include code to zero out the two data members val and pnext. For the previous program fragment to execute correctly, the designer of class Foo needs to provide an explicit default constructor that properly initializes the class’s two members.</p><p>意思是初始化 val 和 pnext 是程序员的责任，编译器不负责，所以你这里不初始化它们，它们存储的结果就是内存遗留的痕迹。</p><h3 id="什么时候编译器会给你生成默认构造函数"><a href="#什么时候编译器会给你生成默认构造函数" class="headerlink" title="什么时候编译器会给你生成默认构造函数"></a>什么时候编译器会给你生成默认构造函数</h3><p>首先你得没有写默认构造函数，编译器才会给你生成。有四类情况，编译器会给你加代码：</p><ol><li>类中有一个对象（成员变量），这个对象包含了默认构造函数</li><li>继承自带有默认构造函数的基类的类</li><li>带有虚函数的类</li><li>继承自虚基类的类</li></ol><p>如果class A内含一个或以上的member objects，那么A的constructor必须调用每一个 member class 的默认构造函数。<br>具体方法是:编译器会扩张 constructors（注意：是所有的构造函数，不仅仅是默认构造函数会被扩张），在其中安插代码使得在 user code 被调用之前先调 用 member objects 的默认构造函数(当然如果需要调用基类的默认构造函数，则放在基类的 默认构造函数调用之后:基类构造函数-&gt;成员构造函数-&gt;user code)。<br>C++要求以“member objects 在 class 中的声明次序”来调用各个 construtors。这就是声明的次序决定了初始化次序(构造函数初始化列表一直要求以声明顺序来初始化)的根本原因!<br>所以你打乱 member initialization list 的顺序根本没有用哦~</p><p>理解了初始化列表中的实际执行顺序中“以 member 声明的次序”来决定的，就可以理解一些很 微妙的错误了。比如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A() : i(<span class="number">99</span>), j(<span class="number">66</span>), value(foo()) &#123;... &#125;</span><br><span class="line"><span class="keyword">int</span> i, value, j;</span><br></pre></td></tr></table></figure><p>这会不会产生错误取决于成员函数 foo()是依赖于 i 还是 j:<br>如果 foo 依赖于 i，由于 i 声明在 value 之前，所以不会产生错误;<br>如果 foo 依赖于 j，由于 j 声明在 value 之后，就产生了使用未初始化成员的错误。</p><p>带有virtual functions的类的默认构造函数毫无疑问是nontrivial的，需要编译器安插额外的<br>成员 vptr 并在构造函数中正确的设置好 vptr，这是编译器的重要职责之一。<br>继承自 virtual base class 的类的默认构造函数同样也毫无疑问的 nontrivial，编译器需要正确设置相关的信息以使得这些虚基类的信息能够在执行时准备妥当，这些设置取决于编译器实现虚基类的手法。</p><p>编译器有4种情况会使得编译器真正的为class生成nontrivial的默认构造函数，这个 nontrivial 的默认构造函数只满足编译器的需要(调用 member objects 或 base class 的默认构造函数、初始化 virtual function 或 virutal base class 机制)。其它情况时，类在概念上拥有默认构造函数，但是实际上根本不会被产生出来(前面的区分 trivial 和 nontrivial)。</p><p>对于一个trivial默认构造函数，编译器的态度是，既然它全无用处，干脆就不合成它。在这儿要厘清的是概念与实现的差别，概念上追求缜密完善，在实现上则追求效率，可以不要的东西就不要。</p><h2 id="copy-constructor"><a href="#copy-constructor" class="headerlink" title="copy constructor"></a>copy constructor</h2><p>有一个参数的类型是其类类型的构造函数是为拷贝构造函数。如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X::X( <span class="keyword">const</span> X&amp; x);</span><br><span class="line">Y::Y( <span class="keyword">const</span> Y&amp; y, <span class="keyword">int</span> =<span class="number">0</span> );</span><br><span class="line"><span class="comment">//可以是多参数形式，但其第二个即后继参数都有一个默认值</span></span><br></pre></td></tr></table></figure><h3 id="什么时候编译器会给你生成拷贝构造函数"><a href="#什么时候编译器会给你生成拷贝构造函数" class="headerlink" title="什么时候编译器会给你生成拷贝构造函数"></a>什么时候编译器会给你生成拷贝构造函数</h3><blockquote><p>其实和前面默认构造函数一样，四种情况</p></blockquote><p>如果一个类没有定义拷贝构造函数，通常按照“成员逐一初始化(Default Memberwise Initialization)”的手法来解决“一个类对象以另一个同类实体作为初值”——也就是说把内建或派生的数据成员从某一个对象拷贝到另一个对象身上，如果数据成员是一个对象，则递归使用“成员逐一初始化(Default Memberwise Initialization)”的手法。</p><p>成员逐一初始化(Default Memberwise Initialization)具体的实现方式则是位逐次拷贝（Bitwise copy semantics）</p><p>Copy constructors和默认构造函数一样，只有在必须的时候才会被产生出来，对于大部分的class 来说，拷贝构造函数仅仅需要按位拷贝就可以。满足 bitwise copy semantics 的拷贝构造函数是 trivial 的，就不会真正被合成出来(与默认构造函数一样，只有 nontrivial 的拷贝构 造函数才会被真正合成出来)。对大多数类按位拷贝就够了，什么时候一个 class 不展现出 bitwise copy semantics 呢? 分为 4 种情况，前 2 种很明显，后 2 种是由于编译器必须保证正确设置虚机制而引起的。</p><ul><li>当class内含一个member object而后者声明了(也可能由于nontrivial语意从而编译器 真正合成出来的)一个 copy constructor 时;</li><li>当class继承自一个存在有copy constructor的base class(同样也可能是合成)时;</li><li>当class声明了一个或多个virtual functions时;(vf影响了位语意，进而影响效率)</li><li>当class派生自一个继承串链，其中一个或多个virtual base classes时。</li></ul><p>对于前两种情况，不论是基类还是对象成员，既然后者声明有拷贝构造函数时，就表明其类的设计者或者编译器希望以其声明的拷贝构造函数来完成“一个类对象以另一个同类实体作为初值”的工作，而设计者或编译器这样做——声明拷贝构造函数，总有它们的理由，而通常最直接的原因莫过于因为他们想要做一些额外的工作或“位逐次拷贝”无法胜任。</p><p>对于有虚函数的类，如果两个对象的类型相同那么位逐次拷贝其实是可以胜任的。但问题将出现在，如果基类由其继承类进行初始化时，此时若按照位逐次拷贝来完成这个工作，那么基类的vptr将指向其继承类的虚函数表，这将导致无法预料的后果——调用一个错误的虚函数实体是无法避免的，轻则带来程序崩溃，更糟糕的问题可能是这个错误被隐藏了。所以对于有虚函数的类编译器将会明确的使被初始化的对象的vptr指向正确的虚函数表。因此有虚函数的类没有声明拷贝构造函数，编译将为之合成一个，来完成上述工作，以及初始化各数据成员，声明有拷贝构造函数的话也会被插入完成上述工作的代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"A::f()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"B::f()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  B b;</span><br><span class="line">  b.i=<span class="number">1</span>;</span><br><span class="line">  A a = b;</span><br><span class="line">  A *p = &amp;a;</span><br><span class="line">  p-&gt;f();</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; p-&gt;i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子可以看出，如果 A a = b;是 bitwise copy semantics 的话，a 内放置的就是 b 的 vptr。但其实不是，编译器给 a 生成了拷贝构造函数，初始化了 a 的 vptr。b 的 vptr 是由编译器给 b 生成的默认构造函数初始化的。但对于其他成员变量 bitwise copy semantics依然有效，所以 i 的结果是1。我在做这个试验的时候发现了一个有趣的现象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"A::f()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"B::f()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  B b;</span><br><span class="line">  b.i=<span class="number">1</span>;</span><br><span class="line">  A a = b;</span><br><span class="line">  A *p = &amp;a;</span><br><span class="line">  p-&gt;f();</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; p-&gt;i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个 i 不是同一个 i，b.i=1;优先给 b 中的同名变量赋值了。这样的代码简直可怕。那么怎么访问到从 A 继承来的成员变量 i 呢，请看：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"A::f()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"B::f()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  B b;</span><br><span class="line">  b.A::i=<span class="number">6</span>;</span><br><span class="line">  b.B::i=<span class="number">1</span>;</span><br><span class="line">  A a = b;</span><br><span class="line">  A *p = &amp;a;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; p-&gt;i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="命名返回值优化"><a href="#命名返回值优化" class="headerlink" title="命名返回值优化"></a>命名返回值优化</h2><p>对于一个如foo()这样的函数，它的每一个返回分支都返回相同的对象，编译器有可能对其做Named return Value优化（下文都简称NRV优化），方法是以一个参数result取代返回对象。</p><p>foo()的原型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X xx;</span><br><span class="line">    <span class="keyword">if</span>(...)</span><br><span class="line">        <span class="keyword">return</span> xx;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化后的foo()以result取代xx：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">foo</span><span class="params">(X &amp;result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    result.X::X();</span><br><span class="line">    <span class="keyword">if</span>(...)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//直接处理result</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//直接处理result</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比优化前与优化后的代码可以看出，对于一句类似于X a = foo()这样的代码，NRV优化后的代码相较于原代码节省了一个临时对象的空间（省略了xx）,同时减少了两次函数调用（减少xx对象的默认构造函数和析构函数，以及一次拷贝构造函数的调用，增加了一次对a的默认构造函数的调用）。</p>]]></content>
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 《Inside the C++ Object Model》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我读大学时候的一些思考</title>
      <link href="/blog/2017/02/06/%E6%88%91%E8%AF%BB%E5%A4%A7%E5%AD%A6%E6%97%B6%E5%80%99%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
      <url>/blog/2017/02/06/%E6%88%91%E8%AF%BB%E5%A4%A7%E5%AD%A6%E6%97%B6%E5%80%99%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</url>
      <content type="html"><![CDATA[<p>我上大学之前一直是一个各科都学的很好的学生，文科成绩非常好，而且是个很感性的人，喜欢凭直觉，写一些无病呻吟的小文章，但是我之后毅然决然的选择了理科，并对理科产生了浓厚的兴趣，想去探究事物背后的原理，我高三时候经常问老师一些让老师都犯怵的难题（包括物理的、生物的），后来进大学学了计算机，编程思维对我产生了很大影响，我现在喜欢事事讲逻辑，讲原因，作总结，写东西也希望除了讲究文笔，同时也要言之有物，满满的思考和干货。</p><p>下面是我学生时期的一点思考，希望分享给大家，同时我也觉得需要提醒一下，人的成长多半靠经历和阅历，伟人不光是书读得多，他们的人生经历也是波澜壮阔（如果你觉得你的人生经历平平，那么就要警醒自己了），面对不确定的事要保持兴奋感，因为不确定代表着机遇（就像互联网上的超链接），一个人一生只要把握一个大机遇就非常好了，有时间我也要多出去走走，多接触些人和事物，行他个万里路，然而这需要一定的经济基础，不然只能出去要饭。</p><h2 id="读计算机专业给我带来的思考"><a href="#读计算机专业给我带来的思考" class="headerlink" title="读计算机专业给我带来的思考"></a>读计算机专业给我带来的思考</h2><h3 id="做事形式化，规范化"><a href="#做事形式化，规范化" class="headerlink" title="做事形式化，规范化"></a>做事形式化，规范化</h3><p>做事形式化其实并不是坏事，这个世界的运行体制就是形式化，也必须要形式化的，只有这样才可以高效稳定的运行起来。行有行规家有家法，做人做事都要有原则，与人与物打交道都要有协议有规定，所谓规章制度，并不是拿来消遣人的，出发点是更好的促进沟通交流。一个东西一旦规范起来，那么出漏子的情况就变得相当低了。比如出门前必定要学会检查自己要带哪些东西（都带上），要关掉哪些东西（都关掉，灯，窗，门等等。），这些都要养成习惯。而习惯的形成也正是为了减少大脑多余的思考，跟规章制度可以节约社会资源一样，不用每次都重新设计一遍。所以优秀的习惯是可以让人轻松的保持脑力体力，做好真正需要做的想的事，避免被小事琐事打搅，消耗脑力体力。一个人的习惯决定了一个人。这里引用一句名言：</p><p>播种一种思想（态度），收获一种行为；播种一种行为，收获一种习惯；播种一种习惯，收获一种性格；播种一种性格，收获一种人生。</p><p>其实习惯和性格是相辅相成的，性格反过来也会影响到习惯，加强习惯。而你的想法，也就是态度，会影响你的行为。所以总的来说态度（想法），行动力和习惯是最重要的三个东西。态度和行动力可以生成习惯，而习惯将决定你的未来，习惯是强大的，习惯就是力量。</p><h3 id="把事物信息化"><a href="#把事物信息化" class="headerlink" title="把事物信息化"></a>把事物信息化</h3><p>要想管理好事物，就要将其信息化。这并不是现代才有的思想，古已有之。譬如政府的户籍制度，一个产品的说明书，都是各成体系，规范（这又说到了第一点：规范化）。其实规范化，也就是信息化。把事物的属性抽象出来列出清单，把操作统一规范好，这样只要懂规则的人只需一点功夫就能把握某件事物，而且丝毫不落下什么。学信息技术，学计算机，给我带来的最大的收获其实就是这个。当我发现这个世界其实无非就是信息的堆叠，这个世界的本质就是信息，而信息所能创造的不仅仅是这个世界，它能创造任意世界，事物。我们生活的这个世界有可能是用计算机模拟出来的，而我们将来也许也有能力模拟出一个复杂的世界，其实某些游戏，譬如minecraft就已经是在模拟我们这个世界了，只是比较简单罢了。现在信息技术越来越发达，各行各业的信息壁垒也越来越高，如果你不懂规则，就无法理解。而信息化思维正是帮助人轻松消化这些规则，打破信息壁垒的。只要你有了信息化思维的习惯，还有大量信息化思维和做事的经验，在这个世界，在各个行业领域都能轻松遨游，游刃有余。譬如写协议，这是件很能锻炼信息化思维的事。写代码，写程序也有此类功效。还有在国家政府机关、法律部门工作也有此类功效。这些事都让你去读懂一个规则，或者创造一个规则，这个过程中各种边角条件（corner cases）情况都要考虑周全，这跟你写出无bug的程序不是异曲同工之妙吗。</p><p>这里说一下我个人对能力提升的理解，一个人能力的高低完全取决于他的经验。经验是成功之母，这是我一直以来信奉的观念。失败和成功都只是小插曲罢了，重要的是经验，成功有成功的经验，失败有失败的经验。另外，提一下我对人生的一点理解，人生由什么决定，很多人说由自己决定，也对，也不对，不对的地方是什么呢。人生下来其实就不是由自己决定的，什么样的环境造就什么样的人，当然同样的环境可能产出不同的结果，但不同的结果也是这个环境所造就出来的，这点我们谁也不能否认。所以环境是人生最重要的一个东西，除此之外就是决定，我们这个世界有确定的东西，也有不确定的因素，很明显这里环境所造成的个人决定是不确定的。</p><p>微观上有人想用量子的瞬间位置和速度来模拟这个世界，这样就能确定世界的下一个状态，但是量子力学中量子的速度和位置是不能同时确定的，只能确定其一，这个世界宏观上是连续的，微观上是离散的不连续的，连空间都有最小的普朗克常量。宏观上的连续是微观的不连续堆叠起来的，这一点跟计算机不能无限精确的表示一个无限不循环小数有异曲同工之妙，所以我们世界有可能是计算机模拟出来的因为这种相同的不连续性。学过多媒体之后，对于模拟数据和数字数据我有了更深的理解，数字化精确到一定程度可以取代模拟量！用人的感官更加容易实现这个，譬如视网膜屏的分辨率，其实像素点是不连续的，是有穷的，数字的，但在我们眼里是连续的，无穷的，模拟的。再回到世界的非确定性本质，我觉得微观的非确定性也是从本质上导致了宏观的非确定性</p><h2 id="环境决定一个人"><a href="#环境决定一个人" class="headerlink" title="环境决定一个人"></a>环境决定一个人</h2><p>虽然人各有决定，意外时常发生，但是这并不代表环境不重要，相反环境相当重要，因为不定性是有概率指标的，而环境是确定的，你不能过分指望在同样一个环境里产生跟别人不一样的决定（就像理论上你能用量子态穿过一堵墙，但那个概率就实在太低了），特别是从一出生以来，那时候人带的基本是人的自然反应和决定。而现在的你的状态也和这一路走来你的环境有着莫大的关系（基本是一个确定态），什么样的环境造就什么样的人，这并不是一句空话。记得以前看过一个真实故事（不信可以自己去观察）：几个背景不同的年轻人去同样一家公司实习，经理通过观察就能判断他们父母是做什么的。（因为父母对人的影响很大）。你看这里只是 选取了环境的主要因素就已经基本给一个人定型了。而回顾我自己，我也是大为吃惊，自己的性格，自己现在的状态都可以从以前的环境找到原因，就像一种无形的束缚和枷锁。</p><p>我现在正在努力根据我以前的家庭环境来核对自己的性格，并努力向不同环境背景的人学习，比如由公务员家庭所继承下来的做事谨慎，妥当的性格。我也努力改善自己的环境，因为在合适的环境中能迅速培养这种环境所产生的性格习惯，而对抗环境去形成相反的性格习惯是特别困难和低效的。有句名言叫：出淤泥而不染。其实这描述的是一种特殊的现象，大部分人是应验了这句：近朱者赤近墨者黑。而我现在深知这其中的道理，我也知道我并不能做到出淤泥而不染，那还是去改变或者选择自己想要的环境吧，那样离自己的梦想更近一些。</p><p>人生就像一场游戏，在这场游戏里你不能决定你的出生，而出生其实反而是最重要的，在一个没有女权的地方，女孩子生活的有多不容易，而如果你出生就是奴隶，这又会是怎样的一生。出生在山沟沟里的孩子，很可能永远看不到城里孩子的世界。很多人说视野决定人生的高低，我上面也说了经验是成功之母。其实这些都可以归为一句话来讲，环境决定一个人。我很庆幸在这么年轻的时候就深刻认识到了这个定理。（虽然很多人都知道这一点，但如同知识你学了不一定会用一样，其实是没有用的，你不能在绝大多数该用到这个知识的时候都能想起这个）。但是出生这种环境是不能改变的，我们也不能消极的看待这一点。相反在认识到这一点后我变得更加积极了，我知道哪些是能改变的，哪些是不能改变的。那么就努力去改变我们能改变的。</p><p>在这个信息时代，人的视野更加开阔了，以前信息不发达的时候你最大的梦想很可能就是像村里王大爷一样，家里20多亩地，几十头猪牛，但现在我们可以看到更远的，人的现实处境和梦想的沟壑变的更大了，（人的梦想总是跟最大欲望有关，最大欲望又局限于视野之内），这是一件好事，但也是个不幸的事，当我们发现原来还有人活的那么潇洒那么漂亮，而我们可以成为跟他们一样的人，拥有一样漂亮的人生，但却要为此付出无比艰辛的努力，有很多人选择了放弃，选择了自我安慰和自我麻醉，到生命的尽头时才后悔不已。人生而为了梦想。困难，险阻，恐惧这些虽然难克服，但是如果真的一辈子这么龟缩着在自己的角落里真的有意思吗，每当我有困难的时候，每当我恐惧不已，惴惴不安的时候，都应该用这句话激励自己，“如果真的一辈子这么龟缩着在自己的一片小角落里真的有意思吗！！”。</p><p>当然不要因此学会去抱怨环境，环境能改变就改变，不能改变就要靠自己努力去改变，人有主观能动性。</p><h3 id="心理学的一点小分析"><a href="#心理学的一点小分析" class="headerlink" title="心理学的一点小分析"></a>心理学的一点小分析</h3><p>所有的过度改变都是痛苦的，这是人的天性。一尘不变和太过简单是无趣的，一点点改变是有趣的，稍强一点的改变是累人的，过度的改变就是痛苦的了。当一个学渣励志要变成学霸，从原来的睡到中午12点到现在的早上6点起床，这是极为痛苦的。当一个学渣要去学一些虽然不是很难，对什么都不会，没有基础的他而言，很难的东西，他是痛苦的。而要克服这两类痛苦（改变的痛苦和复杂的痛苦）主要靠习惯和方法，当你是高三学生的时候，你不会觉得高三很辛苦，（人的忍耐，甚至人的所有情感都是有弹性的，不是个定值），反而觉得自己不够努力。而到了大学再要你像高三那样高强度的学习，你会觉得痛苦不堪。学霸并不觉得自己的生活很苦，他们觉得轻松自在，理所当然。这都是因为习惯了，习惯可以减轻很多负担。当你例行公事的去刷牙洗脸，你一点都不觉的难，人的习惯是人最大的助手。习惯一养成，一切都OK。当这种习惯一尘不变时可以稍作改变，变为有趣，例子：刷牙买新牙膏。习惯的养成刚开始都是痛苦的，巨大的改变所带来的痛苦要挺过去。长痛不如短痛，这是对付改变的痛苦的方法。对付复杂带来的痛苦的方法更简单，把复杂程度降到一点点的时候，痛苦变为有趣。这里我还写了点有关学习方法的建议：学习方法总结。</p><p>最后附上我喜欢的一张壁纸，愿每个人都如这个 月夜攀登者 一样执着：</p><p><img src="https://upload-images.jianshu.io/upload_images/3690260-23096abf961e2cfb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="月夜攀登者"></p><h2 id="曾今的思考笔记"><a href="#曾今的思考笔记" class="headerlink" title="曾今的思考笔记"></a>曾今的思考笔记</h2><h3 id="人生的动与静："><a href="#人生的动与静：" class="headerlink" title="人生的动与静："></a>人生的动与静：</h3><p>本来很早就想写这个话题了，这个想法是我在逛长沙市博物馆看画展的时候想到的，现在我连那个画家叫什么名字都忘了，但那一天出去走的时候去了很多地方，包括创客展，长沙市一中，烈士公园，等等。看完老先生的画作后我突然有一种感觉，就是人生不应该只呆在一个老地方过完这一辈子，那样当你回想起来的时候，发现每天都过得差不多，也就了无生趣了，生活应该是动态的有活力的，世界那么大，应该出去看看。人生那么长，应该多经历一些有趣的事。记得以前看过一篇文章，是讲什么叫有趣，什么叫舒适，有趣就是复杂，舒适就是简单，过于复杂让人渴望简单，过于简单，人又觉得无趣。所以生活就是在这两者之间取舍。累了就歇着，无聊了就找些稍复杂、有挑战性的事来做。</p><p>我的观点是人生在宏观上来看应该是动态的，在微观上是静态的。人需要不断的用新鲜事物来刺激自己，所谓生活每一天都很新鲜，就是这个道理。但过于奔波劳累，就又让人心生疲惫和厌倦。所以在动的过程中，也要让每一段经历沉下心去，过好那一段。这种感觉是很美好的。<br>每次出去走走，头脑都会清新好多，好像突然跳出了原来那个时空，以一种更宽广的视野看待现在的自己，人生的轨迹，想做的事仿佛又清晰了一些。所以要不时的出去走走，或者换一换环境，不要呆在寝室，一天下来只干了一堆琐事。</p><p>明白自己真正想要什么，然后动手去做。人生才会精彩。</p><p>参差多态乃幸福本源。去经历一些新奇的事，有趣的事。不要每天都一成不变。</p><h3 id="少收藏，多消化："><a href="#少收藏，多消化：" class="headerlink" title="少收藏，多消化："></a>少收藏，多消化：</h3><p>这个世界上所有的东西都是有生命周期的（有寿命的），那些好用的工具，美好的东西也是如此。<br>今天清理了一下手机，又想起了umano，突然感悟到这世界上所有的东西都是有自己的期限的。以前也想过这个问题，就是要趁着那些美好的事物还在的时候去好好体验一下，见证他们的存在，王小波说希望这一生经历一些有趣的事，懂得一些道理。我觉得很对。但是反过来，既然所有的东西都是有寿命的，那么我现在手机上用的这些应用，这些工具也许有一天也终将没落。有太多的例子了，天涯，猫扑，衰败何其快，这个世界发展的太快了。微信也是才出不久就如日中天了。我应该好好去利用这些工具，但同时又不被他们绑架。</p><p>不要在收着藏着了，那不是你自己的东西，也不会成为你自己的东西。我曾今非常喜欢在用chrome浏览网页的时候收藏网页，随着时间的推移我收藏的网页变得越来越多，心理负担也变得越来越重，我不断的想花个时间去给我的书签分个类，我后来确实做到了，为了尽可能的细分管理，分了很多类别。但总有感觉不对劲的地方，最终我放弃了书签，而是改用搜索，最开始的理由是为了锻炼自己的搜索能力（因为我觉得曾今找到过一次的网页，今后也应该有能力找到才对），后来我渐渐明白收藏癖对自己的压力有多大，尤其是你心里总是惦记着自己的收藏夹的时候，不是你的终究不是你的，收藏了不看和没收藏实际上是一样的，但留在那里却给自己造成了无形的压力，注重消化和吸收，并做好记录和总结吧。</p><h3 id="积极的人生态度："><a href="#积极的人生态度：" class="headerlink" title="积极的人生态度："></a>积极的人生态度：</h3><p>在这里我要强调，若想人生过得精彩，过得开心，一定要培养一种积极的人生态度。毛泽东就是一个典型的例子，豪气冲天，自信积极，人生无比精彩，会当击水三千里，自信人生二百年。这不是我以前所向往的生活吗，对，生活理当如此，一个人怎么能苟且的活着，那样还有什么意思呢。消极是失意人生之源。想想七龙珠里面的热血，火影，海贼王，莫不是有梦想之人的奋斗史。曾今的少年就真的被打败了吗，就真的甘于被生活和现实打败了吗，那这样下去接下来的人生可还有什么意义可言，无梦想，无热血，无积极的生活态度，可以去死矣。自卑是一种傻逼的生活方式，想想曾今电影王牌大贱谍2中的奥斯汀，人长得丑，矮，那又怎样，看看他的人生多精彩。人生唯爱情和美食不可辜负。爱情和美食你都经历过吗。<br>人生只有血凉与热的区别。火苗再小，也要反复点燃。</p><h3 id="做好规划："><a href="#做好规划：" class="headerlink" title="做好规划："></a>做好规划：</h3><p>今天晚上7点去参加深圳双选会，看宣传片的时候突然脑子里蹦出一个念头，而且感觉越来越强烈。一个人究竟能走多远？我曾今以为自己能走很远，走到天涯海角， 既去做研究，当教授，又去赚大钱，做老板，所有美好的事全都在我身上。可是现在呢？呵呵，现在的处境离想象实在太远了。现在连找工作都是个问题。我们都知道企业做项目要有规划，一个国家发展要有规划，很多事都要有规划，而且越重要的事规划就越是严密，漏洞很少，并且都一一实现了。人生这么重要的一趟旅程又怎能随波逐流呢？很多人说随心随性，到头来这旅程又真的是你想要的吗？大多数人都是被生活推着走，没有人生规划的人更是如行尸走肉，如随风飘荡的落叶不知去向何方。年轻时的壮志，梦想，或者幻想，最终都一一破灭，成为遥不可及的东西。回头看我的人生轨迹，可以说我自己从来没有规划过，小的时候基本上是父母，社会，学校在规划我的轨迹，现在到了大学，自己有了能力和权力规划自己的人生（其实小的时候就可以规划，可惜没有这种意识，就算是大学的前三年，也不依旧没这意识吗）。想追求什么，可能我现在还不明白自己真的想追求什么，我一无所长，没有热爱。想追求什么也并不是想想就可以实现的，必须对此作出规划，才知道原来人生，原来生命并不是有无限可能，无限可能说出来都是骗人的。当你真的着手去规划，你才发现，要达到目的是要付出多大的努力，耗费多大的时间。而人生区区几十年，又能完成多少你所想的壮志和梦想呢。恐怕不多。这提醒我们，再不规划，再随风飘荡，恐怕连一件想要做的事也完不成，人生留下的将尽是无奈和事与愿违。比如一件小事，复习操作系统，你是直接就开始拿起课本复习，还是有规划的复习。没有规划，你知道自己几时能看完吗？你知道自己能在多长时间内看到多少程度吗？恐怕到最后要花很长时间，但是你当初没想到，恐怕你没有计划地想什么时候看两眼就看两眼，不想看就扔一边，最后只看了一点点就放弃了。这就是随性的最可怕的地方。你根本没有去预计自己会到达什么地方，你的预算能力将变得很弱，你的生活和人生将失去控制不由你主宰。看了人生7年the up series，才知道人生何其短暂，要达成自己梦想的成就根本没多少时间可以用。如果不从现在开始规划，7年后的你是什么样子呢。</p><p>规划的关注点不应该是自己的时间，而应该是具体的任务，对于许多长期目标来说，花多少时间去做事不重要，做完你要做的事才重要，做的不好不要紧，坚持去做。</p><h3 id="注意自己的性格"><a href="#注意自己的性格" class="headerlink" title="注意自己的性格"></a>注意自己的性格</h3><p>今天中午2点去华为笔试，做了一个性格测试，这是我第一次认认真真做性格测试，我突然发现自己的性格很有问题，于我对自己的的期望，幻想中的自己区别很大。可以肯定的说，以我目前的性格，恐怕无法实现我的梦想，让自己的能力和地位达到想象中的高度。如果我想要做一个领导，我需要哪些品质，又需要怎样去培养？如果我要让自己更受欢迎，我需要哪些品质，又需要怎样去培养？这些都是很重要的问题，平时如果不注意，对自己的梦想只是想想罢了，那到时候就会发现自己也真的只是想想罢了。有句话很经典，播种一种思想，收获一种行为，播种一种行为，收获一种习惯，播种一种习惯，收获一种性格，播种一种性格，收获一种人生。性格决定一个人的行为，而行为习惯又在巩固性格，或者形成性格。性格决定人的取舍和行为方式的例子屡见不鲜。性格将决定一个人的命运。但这也是个顽固的东西，很难改变，需要坚持。我觉得自己应该多问问自己今天做的这类性格测试中的问题，这些都是一个人的基本性格，世界观和价值取向，一个人灵魂的体现。我发现自己的性格很差，基本像一张白纸，没有自己的主张，有的全是懦弱，老好人，这跟我从小的经历有关。关于性格的培养，今后要有详细的规划才行。</p><h2 id="你的迷茫值得吗？"><a href="#你的迷茫值得吗？" class="headerlink" title="你的迷茫值得吗？"></a>你的迷茫值得吗？</h2><p>我们都想让自己的人生达到最优解，对此我推荐贪心算法（动态规划不可取，因为你无法归因，人生是向前的，你无法回到过去重来），我相信只要人生的每个阶段都最优化，整个人生的解一定不会差（相反，你如果每个阶段都混得很差，怎么指望活出人生的最优）。</p><p>这是我学生时期写的一篇关于怎么找准努力方向，走对正确的路，以及高效的学习和进步的一点思考。当时我正为自己的专业学的不好而感到恐慌和自卑，为自己遇到各种不懂的问题而不得解感到烦躁，继而封闭自己，企图逃避。高中到大学的跨越始终太大，有些人四年之中一直是迷茫的，这种深深的不适是教育体制造成的，但是这种改变也是必要的，因为你的人生你要自己负责，带你高三的老师班主任不会为这负责，不要被桎梏久了就忘了外面精彩的世界和人生。</p><p>从被动到主动，也许只需要一个观念的转变，也许对于许多人来说却是千折百回、痛苦煎熬。愿你不要再做一个被动的人。</p><h3 id="学习不难，合适的路径获得难"><a href="#学习不难，合适的路径获得难" class="headerlink" title="学习不难，合适的路径获得难"></a>学习不难，合适的路径获得难</h3><p>（有时候是教材没有讲得浅显易懂，有时候是自己没有潜心去看。还有时候是根本没有教材，也就是根本没有人带，苦苦摸索耗费你巨大精力，有种要死的感觉，大学的学习难于高中大概也是这种感觉（在上大学之前所有的知识都是老师一口一口喂的，大学里我所有的专业知识都是自学的，老师无异于一个摆设）。其实这个道理十分广泛，可以改成前进不难，找对路子难。关于学习方法，可以参考我这篇：学习方法总结）</p><p>最近一直感慨没有前人带路，走的步履维艰，回头看看自己走过的路。最后悔的莫过于没有参加ACM，没有任何竞赛，也没有奖学金，还有很多原本能做到的东西都没有去做。没有人提醒自己，教自己，不管是技术上的还是生活规划等等。我知道是自己以前都被别人规划好了，小的时候有家人带路，九年义务教育的时候有老师带路，何况我妈还是我小学老师呢，使得我从小备受关注和提携。现在才发现以前的那种生活状态才是不合理的，现在过的是生活的本质的样子，想要回头看的时候不那么后悔一定要得到全局视角，要跳出来看。去主动争取，去联系前辈们， 去获得过来人的箴言和 第三视角的指导，不要把自己框在现时现地 当然不能只听一家之言，要做大数据统计分析，然后应对现在，应对未来。</p><h3 id="意识很重要"><a href="#意识很重要" class="headerlink" title="意识很重要"></a>意识很重要</h3><p>自己终于意识到了，摸着石头过河是愚蠢的，是不必要的，前人早就有了经验，这条路并不是新的。但是生活中又有多少的东西是我还没有意识到的呢？突然有点恐慌。仔细思考一下，发现。其实意识不到是很正常的，你没有处于那个环境之下，没有经历和经验，始终是意识不到的。换句话说，意识不能凭空产生。要么自己经历了，要么别人经历了，然后告诉你，然后你获得了新的思考，恍然大悟，如获新生。 对的，意识不能凭空产生。那么节省时间的方法就是，去跟别人交流吧，去获得别人的经历，经验。去不断增强自己的见识，拓宽自己的视野。意识，思考，思想会源源不断的产生。 把自己闷在自己的思考里，并不能获得多少新的东西。</p><h3 id="不要想当然，事情可能根本不是这样"><a href="#不要想当然，事情可能根本不是这样" class="headerlink" title="不要想当然，事情可能根本不是这样"></a>不要想当然，事情可能根本不是这样</h3><p>高中的时候以为成绩最重要，到了大学也继续这样认为，直到被现实打破，才知道了能力很重要（如果你在985大学，建议还是一定要刷好绩点，因为可以保研，而且还是保到很不错的学校，我自己就认为不注重成绩是我大学里做的最失败的一件事，因为相对考研来讲，平时的考试要拿高分确实简单不少）。可能到了工作中，我们还一直奉行能力很重要这一条，但是现实又会告诉我们关系很重要。可能我们觉得现在可以单身，不谈恋爱，到了工作后一定年纪觉得当时自己真的傻透了。就这样我们一直想当然，自以为是。现实会粉碎你的想当然，让你痛苦万分，后悔不已。可以大胆猜测，但是不要默默地就把它当成真理。 还是前面说的，我们应该去问问经历过的人，做大量数据统计分析。然后才能得出合乎事实的东西。补充：（大学里成绩同样很重要，保研和奖学金都靠成绩，即使考试很水，但判断学生的基本条件是成绩，而且认真的态度在哪都是最重要的，态度决定高度。我相信很多人身边都有这种人，他们就是凭着一股认真的劲儿，大学生活才如此丰富多彩。另外能力确实很重要，在中国并不是有关系就行，工作看的是业绩，那么能力就是重要的。可以说学习是学生的天职，那么成绩就是重要的，读研可能就是研究水平，就是发的paper的多少了，这些都是简单的就可以推理出来的，并不是想当然。而大学谈恋爱确实不怎么好，因为可能根本找不到我喜欢的女孩子也喜欢我的情况，将就自己会更加不快乐。要谈恋爱首先得正确的认识自己，然后看看自己的眼光和自己的水平是否匹配，眼光高水平低那就注孤生啊。）</p><h3 id="获得局外视角的途径"><a href="#获得局外视角的途径" class="headerlink" title="获得局外视角的途径"></a>获得局外视角的途径</h3><p>前面讲的三条都指向同一点：不要闭门造车，要找前辈，获得局外视角。所谓当局者迷，旁观者清。所谓经历过了才懂得。所以接下来我记下怎样去找。</p><p>找导师，导师再介绍师兄师姐。<br>进论坛，找工作多年的前辈。（因为即将步入工作，可以问问工作中什么最重要，怎样让这个最重要的方面成为自己的强项）<br>搜索各种群，进群找工作经验丰富的前辈。<br>这里补充一句，现在的话，学计算机专业的同学可以找我啊，我们可以一起进步，共同成长，人类一直都是以共同话题和爱好而相聚在一起的，我相信未来的互联网的社区化会越来越成熟。</p><h2 id="信息时代的一点思考"><a href="#信息时代的一点思考" class="headerlink" title="信息时代的一点思考"></a>信息时代的一点思考</h2><p>这个时代的最大特征就是信息爆炸，人类每天面临着海量的信息，但有多少是有用的呢，这还真不敢恭维，其实有意义的东西就那么多，人类所有的智慧加起来也就那么多，学个大部分完全是可以的。所以面对信息爆炸最好的方法就是不要去接触那些杂七杂八的信息，而是 转过头去学习最本质的人类智慧，看看新闻可以、一些基本的娱乐常识可以了解，但没必要懂那么多，只要算个融入社会的现代人就行了，网上流行的东西更迭那么快，没必要主动去接触，被动的去接受就行了，只要你处在那个环境中，只要一件事很火，你自然而然就从身边的人那里得知了，而且这些都是没有价值的信息，只是为了塑造一种圈内认同感，就是我们都是现代社会互联网八卦这个圈内人。要学习、要搜索，主动去接触有价值的信息，规避泛滥的没有价值的信息。 比如各种广告，软文，比如打开有道词典各种推荐，千万不要点进去啊，比如知乎各种垃圾提问，粗浅的回答，抖机灵的回答，大部分其实也都是些无意义的信息，比如QQ聊天其实都挺没意义的。只要自己往前，不要回头（志同道合的可以稍微聊聊）。什么破公众号其实也没啥意思。这么看来我以前自我提升那么慢，进步那么慢，甚至退步，这些的最根本原因就在于被信息爆炸炸到了，被很多无意义的信息淹没了，感觉每天都很忙，其实都在浪费时间，都在消耗自己，都在做没有价值的事。幸好现在终于幡然醒悟。好好把新概念英语看的滚瓜烂熟，不要看知乎了，想学人生经验，心理学，哲学，经济学，法律，摄影等等，完全应该主动的去学，而不是被动的去每天刷知乎，这种学法完全错误，也就是说知乎是用来搜的，不是用来每天被动接受信息。可以按领域和话题搜索学习，也可以按人来学习，比如大V，肥肥猫，轮子哥，公众号罗辑思维可以听，因为这是聚合信息，王小波全集可以看，这两个都是按人来划分学习的。所以要么按话题领域，要么按人，来进行有效学习。少听点歌，多学点乐理。少看点电视剧，多学点写故事，小说。即有目的地做事，而不是无目的的消遣。即便再好的材料，你囫囵吞枣能尝出什么味道出来，你只是消遣能学到什么，看完了什么收获都没有那跟没看有什么区别呢？不要消遣和漫无目的啊，人必须要成长，提升，否则虚耗光阴，人生也就平淡无奇。信息爆炸带来的后果，就是无意义的信息大大增加，占信息总比越来越大，新出的游戏层出不穷，新出的影视剧层出不穷，新出的小说层出不穷，新出的音乐层出不穷，人们的时间正在越来越多的被这些东西夺取，游戏无非是一些逻辑加循环，循环多一点，故事也无非是一些逻辑加循环，循环少一点，背后的原理才是有意义的信息，而故事和游戏本身并不是那么重要，因为它们本身都是千千万万，根本看不完。现代社会有一个词应用而生：娱乐至死，这其实是信息爆炸带来的结果之一，也是人类生产力提高的后果，越来越多的工作交给了机器和自然能源，人空闲下来就开始找乐子，娱乐的东西现在每天充斥着我们的生活，刺激着我们的神经，而且虚拟的东西制作的越来越好，我们就用虚拟的东西去完成自己的梦想，但虚拟的始终是虚拟的。</p><p>伴随着信息爆炸，应该要 更好的信息处理技术，处理海量数据，要更好的交互技术，来帮助人机之间无障碍的沟通，最后完全可以做到记录人们每天的所有信息，所有想法。</p>]]></content>
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Macbook</title>
      <link href="/blog/2017/02/03/Macbook/"/>
      <url>/blog/2017/02/03/Macbook/</url>
      <content type="html"><![CDATA[<p>好的工具可以使人事半功倍，回顾整个人类史，又何尝不是一个工具史呢，从用石器到用火，从铁器到火药，从蒸汽机到内燃机，从汽车到电脑，我们在使用工具、利用自然规律，从而让自身变得越来越强大。</p><h2 id="为什么推荐-Macbook"><a href="#为什么推荐-Macbook" class="headerlink" title="为什么推荐 Macbook"></a>为什么推荐 Macbook</h2><p>我使用macbook pro 15 retina 已经一年了，感觉非常好（之前用过惠普的一个笔记本，加过内存条，折腾过固态硬盘，但最后还是受不了那风扇呼呼转）。现在我手头上同时还有一个surface pro 4 m3，M3也就是不带风扇的那款，性能一般，当初买是为了那支笔，能在电脑上写写画画，结果现在买了之后很少用这个surface，但是转手卖了又觉得亏本了，可惜，只好留在家里，留着以后做古董吧。</p><p>mac机器的亮点：</p><ul><li>轻薄</li><li>另外触摸板真的很好用，我已经很久没用过鼠标了</li><li>retina屏也是非常养眼</li><li>立体声也十分不错</li><li>细节做得很好，充电口是磁性的，正反两面都能充，指示灯是能显示是否充满的（用过surface pro 4 的对比一下就知道，什么叫做细心），键盘背光，铝制机身，最后外观简洁美观。</li></ul><p>OS X的最大亮点：</p><ul><li>GUI(Graphical User Interface，图形用户界面)和CLI(Command-Line Interface，命令行界面)的完美结合</li><li>优化的很好，系统耗电少。</li><li>开机速度非常快，另外不用老是关机，我很多时候一个星期都不关机。</li></ul><p>缺点：</p><ol><li>冬天用MacBook寒气逼人啊，把手放上面就知道了（南方，没有暖气，一般也不怎么开空调）</li></ol><p>可以说这是一个不错的工具，无论是对普通用户来说，还是对程序员来说。最大的缺点无疑是：太贵啦。</p><p>所谓一分价钱一分货，3份价钱5分货，10分价钱7分货。意思就是，太便宜的东西往往质量很低，不便宜又不贵的往往性价比很高，特别贵的虽然确实质量非常好，但性价比却低了。</p><p>我秉承的一个观点是，如果一样东西属于易耗品，如：袜子，内衣裤。我们就应该买性价比高的，大众一点的，我还记得有一次傻逼的去优衣库买了双14块钱的船袜，结果穿了一次就起球了，气得要死啊，还不如买便宜的。如果是非易耗品，如：笔记本电脑，手机，西装，皮鞋，钱包，背包等等。我们就应该在能承担的价格内，尽可能的买质量好的（尤其是你注重这个东西的品质的时候）。我特别注重电脑和手机的流畅性，所以我选择了Macbook pro 和 iphone，我打算至少用个5、6年吧（现在的电子设备产品迭代这么快，能用5、6年真的相当不错了）。另外我的双肩背包一定会买非常结实的帆布的款式（而且功能要多），我现在这个背包就背了3年多了，看起来有点旧，但仍然很好用（有考虑换新的双肩背包了，但是还没找到满意的，这种东西还是不能随便买，就跟你闲置在柜子里的衣服一样，买了不喜欢，不穿，浪费钱，而且通常我们只有一个背包，这就更要精挑细选了）。</p><p>好了接下来就开始推荐MacBook的软件了：</p><h2 id="软件列表"><a href="#软件列表" class="headerlink" title="软件列表"></a>软件列表</h2><h3 id="国内的常用娱乐软件"><a href="#国内的常用娱乐软件" class="headerlink" title="国内的常用娱乐软件"></a>国内的常用娱乐软件</h3><ul><li>Mac QQ，社交</li><li>网易云音乐，真的做的不是一般好，相比于其他的什么酷狗、多米。网易云音乐还有Linux版哦，UWP版（Universal Windows Platform）做的也很不错。这里要批评一下网易云音乐，Mac 版的分享是没办法给其他社交网络上的好友贴链接的（连 Linux 版都有的功能），我每次想分享出去都要打开 Chrome 使用网页版的网易云音乐，那我要你客户端干啥？已经提了 issue，看看网易云音乐的 Mac 工作组能不能加上这个功能吧，对程序员来说这就是顺手的事，做产品关键还是要用心啊。</li><li>新浪微博，这个我很少用，微博也刷的少，于是就卸载了，等以后学会高效使用新浪微博了估计会装一个。</li><li>百度云，比起Windows版的不知道难用到哪里去了，好在一直在进步。</li><li>迅雷，没有广告，比Windows的迅雷爽多了，每次打开Windows的迅雷9都有种想哭的感觉，各种广告视频自动播放，好抢眼啊。</li><li>leanote（蚂蚁笔记），现在的笔记软件都开始收费了，如：印象笔记、为知笔记，还有这个蚂蚁笔记也收费了。庆幸的是我现在不写笔记了，我写博客，热衷分享，帮助新人，提高声望。</li><li>为知笔记，为知笔记总体来说是最棒的，现在也收费了，但也阻止不了我用它。</li><li>有道词典</li><li>优酷客户端</li><li>爱奇艺客户端，亲们，这两个客户端放视频没有广告！！！，真是太赞了。</li><li>腾讯视频客户端，这个是新出的，同样没有广告，还可以看蓝光</li><li>阿里旺旺</li><li>每日英语听力</li></ul><p>MacBook进阶软件：</p><ul><li>homebrew/brew cask（mac的软件源，让你可以像玩linux一样，用命令安装软件）</li><li>Chrome，Chrome和Firefox，最经典也是最好用的两个浏览器。不过在MacBook上，safari的性能确实比chrome要好，另外safari可以强制使用HTML5播放视频哦，这样MacBook在看视频的时候就不会发热啦。</li><li>Atom，github推出的指定码农编辑器，MacBook上很好用，Windows上开启有点慢。（温馨提示，码字的时候，开着markdown previewer，打字会很卡，刚开始的时候我差点因为这个莫名的卡顿，而放弃Atom了，后来找到了原因😄）</li><li>calibre，可以看各种电子书，转格式</li><li>LICEcap，使用gif格式录制你鼠标的操作。</li><li>Pocket，把文章收藏起来慢慢看的一个软件</li><li>iStat Menus，显示电脑的各种硬件状态</li><li>TeamViewer，跟QQ远程桌面控制类似，不过这个更专业。</li><li>Blu-ray Player，蓝光视频播放器，要收费，付不起钱只好在每次打开的时候把注册窗口叉掉。</li><li>Irvue，更换壁纸软件</li><li>Sip，取像素点的颜色软件</li><li>VMware Fusion，MacBook专用虚拟机</li><li>The unarchiver，解压缩软件</li><li>Keka，压缩和解压缩软件</li><li>OmniDiskSweeper，查找大文件</li><li>Bartender 2，把MacBook的顶层工具栏里的图标藏起来</li><li>Bartender 2效果截图</li></ul><p><img src="http://wx2.sinaimg.cn/mw690/006zFO3ggy1fcd4m7je0qj31kw0zk4ax.jpg" alt="Bartender 2效果截图"></p><p>程序员往这里看：</p><ul><li>Xcode，相当于Windows上的Visual Studio吧，主要用来开发苹果平台上的软件，平常可以用来写写C/C++</li><li>iTerm2，超好用的终端软件</li><li>oh-my-zsh，超好用的shell</li><li>dash，文档，内容相当丰富，连LaTeX和markdown的文档都有，不过有时候要等7秒钟才让你看文档。</li><li>FileZilla，FTP利器</li><li>github desktop，git的桌面版，很少用，程序员还是多用命令行吧，要不然让你搞Linux服务器，记不起git命令就显得low逼了。</li><li>Pycharm，jetbrains家的IDE个个都好用，这个是用来写Python的</li><li>Intellj IDEA，jetbrains家的IDE个个都好用，这个是用来写Java的</li><li>Android Studio，jetbrains家的IDE个个都好用，这个是用来写Android的</li><li>RubyMine，jetbrains家的IDE个个都好用，这个是用来写ruby的</li><li>CLion，jetbrains家的IDE个个都好用，这个是用来写C、C++的</li><li>jetbrains家的IDE</li></ul><p><img src="http://wx2.sinaimg.cn/mw690/006zFO3ggy1fcd4vbx60yj31kw0zkqez.jpg" alt="jetbrains家的IDE"></p><p>如何顺利的从Windows使用习惯迁移到macbook使用习惯，我写了一篇文章：<a href="../2017/01/01/从windows转用macOSX记录">从 Windows 转用 Mac OS X 记录</a></p><p>另外建议买东西不要贪小便宜，一定要买正版，我的 Macbook 是在淘宝上买的比较便宜的，结果屏幕涂层脱落了，商家也不给赔偿，送苹果 genius bar 查出我的机器不是正版，也不给修。最后换屏（非官方渠道，要1500人民币）</p>]]></content>
      
      <categories>
          
          <category> 数码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>游戏人生--探险者的人生手册</title>
      <link href="/blog/2017/01/26/%E6%B8%B8%E6%88%8F%E4%BA%BA%E7%94%9F--%E6%8E%A2%E9%99%A9%E8%80%85%E7%9A%84%E4%BA%BA%E7%94%9F%E6%89%8B%E5%86%8C/"/>
      <url>/blog/2017/01/26/%E6%B8%B8%E6%88%8F%E4%BA%BA%E7%94%9F--%E6%8E%A2%E9%99%A9%E8%80%85%E7%9A%84%E4%BA%BA%E7%94%9F%E6%89%8B%E5%86%8C/</url>
      <content type="html"><![CDATA[<h2 id="人生没有意义"><a href="#人生没有意义" class="headerlink" title="人生没有意义"></a>人生没有意义</h2><p>人喜欢讲意义，但似乎是件很可笑的事情，因为意义是人虚构出来的东西，这个世界上有些东西存在就是存在，不讲道理的存在，没有意义的存在。不信你去问问宇宙存在有什么意义？宇宙之外有没有意义？时间有什么意义？人生又有什么意义？哪怕你想破脑袋也没用。别拿意义去套你的人生了，百年之后终归尘土。就像泰戈尔写的诗：鸟在天空划过，不留下任何痕迹。马克思哲学也说：新事物终将取代旧事物，历史车轮曲折前进。这里是说你会死，就算你不会死又能怎样，永远活下去就能找到人生的意义？嗯，如果能做到同宇宙同岁也许可以，但别瞎想了，在你有生之年都不可能实现。</p><p>没有一个终极意义你会慌乱吗？</p><h2 id="游戏-vs-人生"><a href="#游戏-vs-人生" class="headerlink" title="游戏 vs. 人生"></a>游戏 vs. 人生</h2><p>人都是喜欢游戏的，人可以进行没有实际奖励的游戏，人甚至可以进行不为输赢的游戏。很奇怪吧，当你小时候和小伙伴玩泥巴，当你打着坦克，玩着超级玛丽，当你打着魔兽、DOTA、英雄联盟，炉石传说，当你在Minecraft、饥荒里面一玩就忘了时间。你想想你到底在干嘛？你有为了某个意义去玩游戏吗？你也许会抱怨，人生为什么这么枯燥，人生为什么不像游戏？</p><ul><li>简单可行</li><li>及时反馈</li><li>无限尝试</li><li>公平竞技</li></ul><p>发现没有，人生跟这四个属性一个都不挨边。 谁的人生是简单可行的？谁的人生是及时反馈的？谁的人生可以无限尝试，不服再来？谁的人生是生活在公平之中？</p><p>一个复杂无比、充满未知的人生，一个慢慢长途、平淡无奇的人生；一个只有一次、甚至其中的很多阶段、很多事都只有一次的人生；一个连公平都做不到无比艰辛的人生。你想不想说一句life is a shit! 同志啊，这句话我早就想说了。</p><p>来来来，对着上面这四条，你仔细想想：</p><ul><li>有多少人一辈子为生计奔走、迷茫、看不见未来、与机会擦肩而过？</li><li>有多少人不停焦虑、制定计划、却不能坚持、始终碌碌无为？</li><li>有多少事错了就不能再重来？</li><li>有多少人，生来就缺乏竞争力？</li></ul><p>想通了吗？想通了就OK，你要是不能忍上面这四条，却依然厚着脸皮说你喜欢人生、热爱生活，我要骂你：真他妈能装逼，真是厚脸皮！那你要说，不然呢？我生下来就已经是这个样了啊，怪我咯！其实你是正确的，如果你还有活着的欲望，没有急着去死，那么你就该热爱你的生活，罗素有句话叫做：只有一种英雄主义，就是在认清生活真相之后，依然热爱生活。因为这是你的生活，你别无选择。</p><p>大学的同学不用再抱怨大学了，不就迷茫了四年嘛，你没发现你其实上大学之前也只是在幻想人生的美事吗？你没发现你上大学之前一直是被安排着忙忙碌碌吗？大学打破了你的美梦，很好，大学让你迷茫，很好，大学让你又闲又焦虑不堪，这更好，大学让你有时间开始思考人生，简直完美！</p><p>其实你忘了，小学的时候你也被老师的抄写课文后的生字词这种作业，弄的死去活来，每讲到新的一课，就从第一课抄到这一课（PS：这就是我真实的童年）。其实你也忘了，上高中的时候，做不完的题，做题做到想吐，从此落下对做题的厌恶感这种奇怪的病根。</p><p>现在我们只关心一点，人生到底还有没有救。</p><p>简单可行？到底是否可以做到？在你学英语的时候，在你健身的时候，在你打工赚钱的时候。很显然这三件事都不简单，你不应该再过多的考虑这种复杂的事情了。生活中当然有简单的事情，只是你看不上它们罢了，或者你觉着它们的意义太低。比如背一篇新概念3的文章，不算太难，如果觉着太难，那就背一段好了，但是你会想一些看起来很合理，实际上很荒唐的事情，你会想：背了又怎样，有什么用呢？或者我知道背了有点小用，坚持下去背很多就更是有大用了，但这太漫长了，没人能坚持下去。这就牵涉到及时反馈了，你急需立竿见影的效果，否则会在一次又一次的考虑中丧失你的动机。</p><p>及时反馈？那你怎么及时反馈？背一篇新概念的文章的一段，对你学好英语的作用就是微乎其微，从这个角度来讲，你需要其他来源的反馈。</p><p>无限尝试是不可能了，但有限的 多次模拟 还是可以的。</p><p>公平竞技也是不可能的，这一点没有办法（很多英语国家的人不用死命学英语啊，长大成人了谁不会说母语？有些人出生就含着金钥匙啊，富二代官二代），我们只能靠自己，你也可以反过来想，起点很低，却靠自己的智慧变得很厉害，是不是更有成就感（强行安慰自己）。</p><h2 id="把人生游戏化的方法"><a href="#把人生游戏化的方法" class="headerlink" title="把人生游戏化的方法"></a>把人生游戏化的方法</h2><p>从上面的分析可以看出人生非常难以游戏化，但我们不能坐以待毙，下面我来讲讲我自己的一些想法吧。</p><p>我自己是学计算机的，在外行看来，计算机是非常神秘的领域，就像某种魔法一样，事实上即便是我们这种内行，如果不清楚具体的实现过程，那么被抽象封装的部分依然是很神秘的，魔幻的。所以我们不妨把计算机技术当成一种现代魔法，而我们学计算机的都是魔法师，像Linus Torvalds、吴恩达这样的则是大法师。我们人区别于动物的地方是什么呢？</p><ol><li>知识</li><li>合作</li></ol><p>我们能达成上百万人的合作（比如：波音飞机的整个生产过程，有人搞理论，有人设计，有人组装），我们能快速习得知识技能而不用依赖遗传和自然选择。知识+合作=文明。</p><p>怎样变成一个更优秀的人？</p><ol><li>习得更多的知识</li><li>拥有更强的合作技巧和能力</li></ol><p>我们接受教育，不停学习，就是习得更多的知识，我们和人交友，加入公司，获取财富和资本，创业，拉投资，就是拥有更强的合作能力。</p><p>游戏是没有一个确定目的的（很多游戏可以有多种玩法和目的），即便很多游戏有一个终极目标，有一个通关的路径，但游戏的意义却非仅此而已，如果仅有一个最终目标，达成目标之后就变得无趣了。游戏拥有一个有趣的过程，让人沉浸其中。所以你可以给你的人生设定一个伟大的目标，但不要忘了，生活的意义不仅在于此，生活的意义还在于你生活的每一年，每一个月，每一天。</p><p>把事情变得简单可行，就是要分割和量化目标，提供及时反馈就是要量化成果，得到激励。无限尝试，就是要不停模拟实践。公平竞技，算了吧，不谈这个(你可以从比你基础更差的人身上获取安慰，你想啊至少你的出身没有差到那个地步，是吧)。</p>]]></content>
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>百度贴吧ID挖掘机</title>
      <link href="/blog/2017/01/12/%E7%99%BE%E5%BA%A6%E8%B4%B4%E5%90%A7ID%E6%8C%96%E6%8E%98%E6%9C%BA/"/>
      <url>/blog/2017/01/12/%E7%99%BE%E5%BA%A6%E8%B4%B4%E5%90%A7ID%E6%8C%96%E6%8E%98%E6%9C%BA/</url>
      <content type="html"><![CDATA[<p>去年我开了一个minecraft服务器，想拉点人进去玩，就想到要出去打广告啊，怎么办呢，我的好朋友<code>lianera</code>就跟我说，他以前在贴吧里面批量@别人，嗯，这是个不错的方法，他当时还给我看了他写的一个百度贴吧ID挖掘机，但不是用python写的，<a href="https://github.com/lianera/archives/tree/master/tieba-digger" target="_blank" rel="noopener">第一版C语言</a>，<a href="https://github.com/lianera/archives/tree/master/tbot" target="_blank" rel="noopener">第二版java</a>。不过后来这件事没有做成，因为现在百度贴吧禁止批量@了。</p><p>后来我就想学点python，因为据说python代码特别简洁，这对于我这种极简主义者是很有诱惑力的，正所谓 – “人生苦短，我用python”（来源于：life is short, you need python）。另外python爬虫很有名啊，python玩数据很方便啊。数据时代怎么能不玩数据呢！于是我就一门心思想学python（其实还有一个原因，因为xx-net（一款翻墙软件）是用python写的，迟迟不出移动端的，我的手机也要翻墙啊，摔！我打算自己把xx-net移植到ios和安卓上，首先需要读懂代码啊，所以我还是需要学python，但后来lianera找了个便宜的VPS，并搭了shadowsocks服务，我们就一起用他搞的VPS翻墙了。。。）。</p><p>想着不能光看python语法而不做实事，我就重新造这个百度贴吧ID挖掘机轮子了。</p><p>先推荐<a href="https://github.com/liuqinh2s" target="_blank" rel="noopener">我的github</a>欢迎各位follow和指教，（程序员之间多多联系还是有必要的，大家可以讨论技术啊，除了技术还可以聊人生啊，电影啊，抱歉我以前是个文青，文科成绩一直很好，嗯，也爱科学）。</p><p>项目地址：<a href="https://github.com/liuqinh2s/Python" target="_blank" rel="noopener">https://github.com/liuqinh2s/Python</a></p><p>一开始我是用python2，然后想着python3才是未来，然后就想改点代码就升级了呗，但是python2和python3真的是有点不一样，改得有点蛋疼，不过最后还是弄好了。</p><p>代码写的不好的地方请指出来哈。</p><p>下面我讲讲思路：</p><ol><li>首先定义了一个BaiDuTieBa类，用来获取HTML源代码，然后用正则表达式匹配抽取出用户ID，然后我用了一个全局的dict变量存放ID，最后把dict中的ID全部写入文件就可以啦。其中必不可少的要用到urllib库，re（regex, regular expression，正则表达式）库。</li><li>然后我就想啊，单线程爬的这么慢简直不能忍，于是就搞个多线程吧，至少把我的网速和带宽占的满满的。这里我使用了任务队列和线程池，简单讲就是把任务都放进任务队列里面，然后线程放线程池里面，线程呢不断的去取任务，做完一个取一个，直到任务队列为空。线程池代码是从网上借鉴来的，管他呢自己改改能用就OK。这里用了threading库，queue库。</li></ol><p>然后爬的时候，你看看自己的网络，反正我的是瞬间飙升到几兆每秒了。</p><p>代码很初级，关键的地方都有注释哦，看不懂的地方私信我，我会在文章最后贴出常见的问题，并详细讲解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    这是python3版本的，看文件名，TieBaID3.py，这个3啊就是python3，懂了伐。</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">__author__ = <span class="string">'liuqin'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line">IDdict = &#123;&#125;</span><br><span class="line"><span class="comment">#百度贴吧爬取用户ID，以minecraft吧为例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaiDuTieBa</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, kw, pn)</span>:</span></span><br><span class="line">        self.baseurl = <span class="string">"http://tieba.baidu.com/f/like/manage/list?"</span></span><br><span class="line">        self.userAgent = <span class="string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36"</span></span><br><span class="line">        self.headers = &#123;<span class="string">'User-Agent'</span>: self.userAgent&#125;</span><br><span class="line">        self.kw = kw</span><br><span class="line">        self.pn = pn</span><br><span class="line">        self.IDdict = IDdict</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getHTML</span><span class="params">(self)</span>:</span></span><br><span class="line">        url = self.baseurl + <span class="string">'kw='</span> + self.kw + <span class="string">'&amp;'</span> + <span class="string">'pn='</span> + str(self.pn)</span><br><span class="line">        request = urllib.request.urlopen(url)</span><br><span class="line">        <span class="comment"># 注意这里网页源码编码是：GBK，用decode解码时要选择gbk</span></span><br><span class="line">        pageHTML = request.read().decode(<span class="string">'gbk'</span>)</span><br><span class="line">        <span class="keyword">return</span> pageHTML</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getUserID</span><span class="params">(self)</span>:</span></span><br><span class="line">        regex = re.compile(<span class="string">'.*?username="(.*?)".*?'</span>)</span><br><span class="line">        pageHTML = self.getHTML()</span><br><span class="line">        UserID = re.findall(regex, pageHTML)</span><br><span class="line">        <span class="keyword">return</span> UserID</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">writeIDinDict</span><span class="params">(self)</span>:</span></span><br><span class="line">        UserID = self.getUserID()</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> id <span class="keyword">in</span> UserID:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            self.IDdict[count + self.pn * <span class="number">20</span>] = id</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.getUserID()</span><br><span class="line">        self.writeIDinDict()</span><br><span class="line">        print(<span class="string">u'写入第%d页用户ID'</span> % (self.pn))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writeInFile</span><span class="params">()</span>:</span></span><br><span class="line">    file = open(<span class="string">u'./百度贴吧minecraft吧用户ID.txt'</span>, <span class="string">'a+'</span>, encoding=<span class="string">'UTF-8'</span>)</span><br><span class="line">    <span class="comment"># print(file.encoding)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> IDdict:</span><br><span class="line">        file.write(IDdict[i]+<span class="string">'\n'</span>)</span><br><span class="line">    file.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#具体要做的任务</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_job</span><span class="params">(kw, pn)</span>:</span></span><br><span class="line">    spider = BaiDuTieBa(kw, pn)</span><br><span class="line">    spider.start()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_job1</span><span class="params">(kw, pn)</span>:</span></span><br><span class="line">    spider = BaiDuTieBa(kw, pn)</span><br><span class="line">    <span class="keyword">return</span> spider</span><br><span class="line"></span><br><span class="line"><span class="comment"># 单线程爬虫</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">NoThreads</span><span class="params">(kw, pn)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, pn+<span class="number">1</span>):</span><br><span class="line">        do_job(kw, i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 有多少任务创建多少线程，每个任务执行完就销毁相应线程，这种有点太恐怖，哈哈，任务数太多就爆炸了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread_spider</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, kw, pn)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.pn = pn</span><br><span class="line">        self.kw = kw</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        do_job(self.kw, self.pn)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MultiThreads</span><span class="params">(kw, pn)</span>:</span></span><br><span class="line">    threads1 = [Thread_spider(kw, i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, pn+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> threads1:</span><br><span class="line">        i.start()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> threads1:</span><br><span class="line">        <span class="keyword">if</span> i.is_alive: i.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用线程池和任务队列</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkManager</span><span class="params">(object)</span>:</span><span class="comment"># 这是一个线程管理器</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, kw, work_num, thread_num)</span>:</span></span><br><span class="line">        self.task_queue = queue.Queue()</span><br><span class="line">        self.threads = []</span><br><span class="line">        self.kw = kw</span><br><span class="line">        self.__init_task_queue(work_num)</span><br><span class="line">        self.__init_thread_pool(thread_num)</span><br><span class="line">        self.start_task()</span><br><span class="line"></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        添加一项工作入队</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_job</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        self.task_queue.put(func)  <span class="comment"># 任务入队，Queue内部实现了同步机制</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        初始化任务队列</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init_task_queue</span><span class="params">(self, jobs_num)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, jobs_num + <span class="number">1</span>):</span><br><span class="line">            self.add_job(do_job1(self.kw, i))</span><br><span class="line"></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        初始化线程池</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init_thread_pool</span><span class="params">(self,thread_num)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,thread_num+<span class="number">1</span>):</span><br><span class="line">            self.threads.append(Work(self.task_queue))</span><br><span class="line"></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        开始执行任务</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_task</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.threads:</span><br><span class="line">            i.setDaemon(<span class="number">1</span>)</span><br><span class="line">            i.start()</span><br><span class="line"></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        等待所有线程运行完毕</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wait_allcomplete</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> self.threads:</span><br><span class="line">            item.join(<span class="number">1</span>)  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Work</span><span class="params">(threading.Thread)</span>:</span><span class="comment"># 这是线程类</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, task_queue)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.task_queue = task_queue</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> self.task_queue.empty():</span><br><span class="line">            self.task_queue.get().start()<span class="comment"># 任务异步出队，Queue内部实现了同步机制</span></span><br><span class="line">            self.task_queue.task_done()  <span class="comment"># 通知系统任务完成</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    kw = <span class="string">'minecraft'</span>  <span class="comment"># 贴吧名称</span></span><br><span class="line">    pn = <span class="number">1000</span> <span class="comment"># 页面数</span></span><br><span class="line">    <span class="comment"># 不用多线程模式</span></span><br><span class="line">    <span class="comment"># NoThreads(kw, pn)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 即时创建即时销毁，多线程模式</span></span><br><span class="line">    <span class="comment"># MultiThreads(kw, pn)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 任务队列线程池模式：（任务数：1000，线程：100）</span></span><br><span class="line">    threads_num = <span class="number">100</span></span><br><span class="line">    work_manager =  WorkManager(kw, pn, threads_num)</span><br><span class="line">    work_manager.wait_allcomplete()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"hello world"</span>)</span><br><span class="line">    writeInFile()</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> projects </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>那些年我读过的好故事</title>
      <link href="/blog/2017/01/10/%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E8%AF%BB%E8%BF%87%E7%9A%84%E5%A5%BD%E6%95%85%E4%BA%8B/"/>
      <url>/blog/2017/01/10/%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E8%AF%BB%E8%BF%87%E7%9A%84%E5%A5%BD%E6%95%85%E4%BA%8B/</url>
      <content type="html"><![CDATA[<p>现代人们每天接触的信息量太过庞大，我们都试图把自己的时间花在有意义的、美好的事上和有效的信息上。所以我打算总结一下自己看过的一些作品，无论是电影、小说、连续剧、游戏、音乐都一并算上吧。影视剧和小说都属于 故事 类，音乐属于 艺术，游戏则是带有 故事的艺术（循环元素越多，信息含量越低，越消磨人的时间，而遗憾的是大多数游戏中的循环元素太多，而且含有上瘾设计元素，毕竟人家要挣钱，让你上瘾是在许多游戏厂商考虑之内的事）。</p><blockquote><p>许多游戏其实有上瘾成分，所以含有上瘾设计元素的游戏，建议慎重考虑，不要入坑，这里点名：红色警戒、魔兽世界、魔兽争霸、英雄联盟、王者荣耀、炉石传说，这些游戏都非常容易上瘾，特别是跟小伙伴一起玩的时候，另外电子游戏跟传统游戏最大的区别就是：你随时都可以开始玩，这是很可怕的，如果你把所有时间都花在游戏上，那么就会耽误很多事。所以请相信下面我要说的这句话：如果你长时间沉浸式的玩游戏，游戏将抽空你所有的注意力，让你睡觉的时候脑子里都是这个东西，你甚至没有时间吃饭，拿衣服去洗衣机里洗。其实像：饥荒、我的世界这类游戏沉浸感也很强，玩游戏嘛就是等你玩出一种沉浸感，然后就开始轻度上瘾了，年轻人为啥喜欢玩游戏，这就跟老人下象棋是一样的，就是时间太多了，就用游戏消遣掉了，你听过中年人打游戏颓废掉的吗，应该很少吧，但我还是发现了一个游戏中的清流：纪念碑谷，这完全算艺术的范畴了，我通关后完全没有一点上瘾的感觉，只有过瘾的感觉，真是一场视觉和创意的盛宴，时间和钱都花的值了，我只玩了一遍，就像看电影一样，很多电影你也只会看一遍。</p></blockquote><p>我们人就是喜欢听故事，好的故事更是令人神往，同时也能卖到好价钱，这一篇重点说故事类的作品，书籍类的记录到一定数量就新开一篇推荐。</p><blockquote><p>好的作品可以陶冶人的性格，构建气质的最底层。</p></blockquote><p>这里我列出来的每一部都是我自己看过的，为了纪念那个时候的时光吧。</p><p>当你列出来这么多看过的东西的时候，真的有种惊讶的感觉，我们总说时间太短、太少，其实我们花在了其他空间，在这些作品中，我们把自己带入进去，从而度过了短暂而精彩的一生。人生和这些电影相比有太多的冗杂和琐事，太多的、太漫长的过程，而人都是短视的、急功近利的、我们浮躁、我们想要精炼的一辈子，其实我们都错了，人生不过是一个过程，谁都逃不过一死，把自己沉淀下来，享受过程，缓慢的生长。</p><blockquote><p>以过程为导向才是正确的人生态度，结果只是一瞬，你的人生应该也必须由过程组成。</p></blockquote><h2 id="电影"><a href="#电影" class="headerlink" title="电影"></a>电影</h2><h3 id="印度电影"><a href="#印度电影" class="headerlink" title="印度电影"></a>印度电影</h3><ul><li>三傻大闹宝莱坞 3 Idiots (2009)</li><li>小萝莉的猴神大叔 (2015)</li><li>外星醉汉PK地球神 (2014)</li><li>摔跤吧，爸爸（2017）</li></ul><p>然后是豆瓣上评出的经典影片：</p><p>经典永远不会老去</p><ul><li>海上钢琴师 La leggenda del pianista sull’oceano (1998)</li><li>肖申克的救赎 The Shawshank Redemption (1994)</li><li>盗梦空间 Inception (2010)</li><li>楚门的世界 The True man Show (1998)</li><li>阿甘正传 Forrest Gump (1994)</li><li>当幸福来敲门 The Pursuit of Happyness (2006)</li><li>V字仇杀队 V for Vendetta (2005)</li><li>黑客帝国 The Matrix (1999) 三部</li><li>布达佩斯大饭店 The Grand Budapest Hotel (2014)</li><li>霸王别姬 (1993)</li><li>这个杀手不太冷 Léon (1994)</li><li>罗马假日 Roman Holiday (1953)</li><li>泰坦尼克号 Titanic (1997)</li><li>辛德勒的名单 Schindler’s List (1993)</li><li>天堂电影院 Nuovo Cinema Paradiso (1988)</li></ul><p>然后是我最爱的科幻片、悬疑片类型：</p><ul><li>黑侠</li><li>这个男人来自地球 The Man from Earth (2007)</li><li>超时空接触 Contact (1997)</li><li>星际穿越 Interstellar (2014)</li><li>源代码 Source Code (2011)</li><li>蝴蝶效应 The Butterfly Effect (2004)</li><li>致命魔术 The Prestige (2006)</li><li>阿凡达 Avatar (2009)</li><li>恐怖游轮 Triangle (2009)</li><li>生化危机系列</li><li>异次元骇客 The thirteenth floor (1999)</li><li>异星战场</li><li>复仇者联盟 The Avengers (2012)</li><li>钢铁侠系列</li><li>绿巨人系列</li><li>大鱼</li><li>无姓之人</li><li>土拨鼠之日</li></ul><p>然后是反正好看系列：</p><ul><li>冰雪奇缘 Frozen (2013)</li><li>疯狂动物城</li><li>暮光之城系列</li><li>哈利波特系列</li><li>速度与激情系列</li><li>魔戒三部曲</li><li>驯龙高手1、2</li><li>疯狂的麦克斯4：狂暴之路 Mad Max: Fury Road (2015)</li><li>空中监狱 Con Air (1997)</li></ul><p>国产电影：</p><ul><li>翻滚吧！阿信 (2011)</li><li>夏日乐悠悠 (2011)</li><li>破风 (2015)</li></ul><p>没错，三部里面都有彭于晏</p><h2 id="连续剧"><a href="#连续剧" class="headerlink" title="连续剧"></a>连续剧</h2><h3 id="美剧-amp-amp-英剧"><a href="#美剧-amp-amp-英剧" class="headerlink" title="美剧 &amp;&amp; 英剧"></a>美剧 &amp;&amp; 英剧</h3><h4 id="美剧"><a href="#美剧" class="headerlink" title="美剧"></a>美剧</h4><ul><li>冰与火之歌，又名：权力的游戏，A Song of Ice and Fire: Game of Thrones</li><li>行尸走肉，the walking dead（刚开始看是新鲜，后来就没啥价值了，无非是讲人性罢了）</li><li>西部世界，westworld</li><li>硅谷</li><li>达芬奇密码</li></ul><h4 id="英剧"><a href="#英剧" class="headerlink" title="英剧"></a>英剧</h4><ul><li>神探夏洛克</li><li>黑镜</li></ul><h3 id="日剧"><a href="#日剧" class="headerlink" title="日剧"></a>日剧</h3><ul><li>legal high（胜者即正义）</li><li>半泽直树</li><li>逃避可耻但有用</li></ul><h3 id="国产电视剧"><a href="#国产电视剧" class="headerlink" title="国产电视剧"></a>国产电视剧</h3><ul><li>琅琊榜</li><li>大好时光（并不值得看，当时看这个完全是奔着胡歌去的，看这个剧有种白开水的味道，有种淡淡的生活味儿，另外这个剧传递给你一种极正的三观）</li><li>李小龙传奇</li><li>恰同学少年</li><li>仙剑1，3</li></ul><h4 id="偶像剧"><a href="#偶像剧" class="headerlink" title="偶像剧"></a>偶像剧</h4><p>微微一笑很倾城（并不值得看，除了让你羡慕嫉妒恨，或者活在梦里，没什么太大的意义，主角都太过完美了）</p><h4 id="网剧"><a href="#网剧" class="headerlink" title="网剧"></a>网剧</h4><ul><li>一起同过窗（并不值得看，大学过完了才看这个剧，对学生时代总有种意犹未尽的感觉，这个剧带你再次体验那些鸡毛蒜皮的青春时光）</li><li>白夜追凶</li><li>太子妃升职记（你要是想猎个奇，那就试试，其实没啥好看的，不推荐）</li></ul><h3 id="韩剧"><a href="#韩剧" class="headerlink" title="韩剧"></a>韩剧</h3><ul><li>爱在哈佛</li><li>太阳的后裔</li><li>W 两个世界</li></ul><h2 id="纪录片"><a href="#纪录片" class="headerlink" title="纪录片"></a>纪录片</h2><ul><li>人生7年，the up series</li><li>互联网时代（央视）(2014)</li><li>互联网之子 The Internet’s Own Boy: The Story of Aaron Swartz (2014)</li><li>史蒂夫·乔布斯：遗失的访谈 Steve Jobs: The Lost Interview (2012)</li><li>舌尖上的中国</li><li>wild China，美丽中国，BBC产的</li><li>小森林（春夏秋冬）</li></ul><h2 id="动漫"><a href="#动漫" class="headerlink" title="动漫"></a>动漫</h2><h3 id="国产"><a href="#国产" class="headerlink" title="国产"></a>国产</h3><ul><li>秦时明月</li><li>天行九歌</li><li>我是白小飞</li></ul><h3 id="日本动漫"><a href="#日本动漫" class="headerlink" title="日本动漫"></a>日本动漫</h3><ul><li>火影忍者</li><li>海贼王</li><li>东京食尸鬼</li><li>寄生兽</li><li>进击的巨人</li><li>宫崎骏系列</li><li>天空之城</li><li>龙猫</li><li>千与千寻</li><li>风之谷</li><li>哈尔的移动城堡</li><li>起风了</li><li>萤火之森</li></ul><h2 id="小说"><a href="#小说" class="headerlink" title="小说"></a>小说</h2><ul><li>三体</li><li>缥缈之旅（修真小说的鼻祖，在喜马拉雅上听完的，并没有看文字小说，另外很多时候听着睡着了，不停的打怪升级而已吧，太长了）</li><li>王小波全集（我主要关注的是他这个人，所以他的所有作品都值得看看，我主要看了《沉默的大多数》）</li><li>和空姐同居的日子、第一次亲密接触。这两个也是听的广播剧，男女双人广播剧，言情类型的，不过也是红极一时的作品。在夜里温暖单身狗的小心脏。</li><li>陈二狗的妖孽人生（YY小说，在喜马拉雅上听的，同时也看了点网剧）</li></ul><h2 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h2><p>时间管理的幸福学</p>]]></content>
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>学习方法总结</title>
      <link href="/blog/2017/01/02/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/blog/2017/01/02/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>我把自己以前的多个思考笔记综合成了这一篇，有关于学习的 方法论，怎么学英语，怎么背单词，怎么做笔记，以及自我管理</p><p>你要坚信做任何事都不能蛮干，做每件事有每件事的方法，不要在错误的道路上越走越远</p><p>我把学习分为三个境界：重复、理解性学习、教别人</p><h2 id="重复重复再重复"><a href="#重复重复再重复" class="headerlink" title="重复重复再重复"></a>重复重复再重复</h2><p>你可能知道条件反射，即便是动物也具备的一种学习方法，马戏团天天在证明这一点，通过不断的重复（训练、奖励、惩罚），猪都会钻火圈。无论是学母语，还是学英语，基石都是重复。</p><h2 id="构建认知网络"><a href="#构建认知网络" class="headerlink" title="构建认知网络"></a>构建认知网络</h2><p>人的认知是一张一直在不停编织的网络，很多知识，抽象出来的结论、认知，都是相通的（类似的），人通过联想来举一反三，并通过这种联系轻松的记忆学习。</p><p>所以死记硬背是低效的，因为你试图孤立你所学的知识，而孤立的东西难以被人记起，你可以回想一下自己是不是经常忘记熟人的名字，如果熟人的名字都能忘（你是不是仅靠重复使用来记忆别人的名字，而不是通过联系其他事物呢？），忘掉知识不是很正常吗。</p><p>所谓理解性学习，就是用原有的认知去解释新事物，以至于新的认知变得水到渠成，你可以从很多条路子记起这个知识，那么你就内化了这个认知，这才学到了位。</p><p>构建自己的认知网络，就是理解性学习，学习来不得半点生硬，重复重复再重复，固然有用，但时间久了依然会忘记，并且很多知识都是需要灵活应用的，你要把它跟其他东西联系，而且你必须这样做，否则一个孤立的知识，你记得或者不记得没有任何区别。在已经构建好的认知上添砖加瓦，并不断试图从多个不同角度去应用它，让它指导你的其他思维和行为，这样才能慢慢内化。</p><p>不要因此而有了不努力去重复的练习和学习的借口，认真在任何时候都是首要的精神</p><h3 id="理解性学习的不可跳跃"><a href="#理解性学习的不可跳跃" class="headerlink" title="理解性学习的不可跳跃"></a>理解性学习的不可跳跃</h3><p>学习其实不难，你觉得难，觉得不懂，原因只有一个：如果一个结论得出来你无法理解，那就是从前提到结论这个过程你无法理解，为什么无法理解，原因也很简单：这其中暗含着一些前提，而这些暗含的前提你是不知道的，或者还没理解，这造成了一个跳跃，而学习和理解是不能跳跃的，你在这里断了链条，那么就会无法继续前进，或者云里雾里，一处不懂处处不懂。</p><p>学习是有路径的，一个初学者你给他看高深的理论，中间越过很多步骤，他是根本无法学会的。你必须一步一个脚印，也只有一步一个脚印才能学的会，学的好，学的精通。很多人由于觉得难就很烦躁，产生畏难情绪，觉得累，想要放下或者放弃。其实就是因为没有找到属于你的学习路径。必须要把中间的那些暗含的前提找到弄懂，然后你就理解了，就可以继续上路。判断一个学习资料是否合适，就要看这份学习资料，对你是不是太难，太难肯定学不下去，太简单又浪费你的时间。</p><h2 id="费曼学习法"><a href="#费曼学习法" class="headerlink" title="费曼学习法"></a>费曼学习法</h2><p>费曼学习法的精髓就是通过教授来强化学习，在教别人的时候你对所学的东西的理解会进一步巩固加深。</p><p>其实你教别人的时候就是在解构理解的过程，也是在重复理解的过程，你讲的越是清晰明了，别人一听就懂，就证明你自己的理解过程越成功越细致，何况你自己还在重复，所以用这个方法来复习是非常棒的，效率很高。</p><h2 id="怎么学英语"><a href="#怎么学英语" class="headerlink" title="怎么学英语"></a>怎么学英语</h2><p>学英语应该是很多国人的痛点，因为学了很多年都没学好，有些从小学开始学，有些从初中开始学，但直到大学本科毕业，英语还是很差。我知道这种苦楚与恐惧，也曾想学好英语，但一直没成功，我在思考这里面的原因，又加上看了一些人的见解，我总结如下：没有环境，这是根源，记忆是靠重复加强，靠关联其他记忆来内化。学习语言尤其要重复，可能因为语言是人类表达的根基，主要是靠死记硬背和疯狂输出，你总不能靠推理来学习语言。所以我们学英语的强度还远远不够，我们没有环境，如果有语言环境，那你在无形之间就已经达到一个高强度的状态，所以我们只能靠自己去打造这种高强度的环境。至少你每天都在学英语用英语吗，如果你做到了，你的英语肯定稳步提升。问题就出在这儿。当你看到英文时是不是恐惧性的跳过不看，当你看到不认识的单词你是不是没有去查，就这还想学好英语，你自己内心里都不会相信吧。这还只是初步的，你有没有刻意去输出呢，输入还算有点环境，毕竟英语的资源一不小心就接触到，但输出好像还真没机会。模仿造句应该被当做像你打游戏中的做日常任务，每造一个句子你都该记录下来，作为游戏日志，累积财富，写文章应该当做下艰难副本，每写一篇你都该奖励自己。对语言的热爱是重要的一个环节，去了解英语文化是有好处的，但另一个重要的环节是坚持，坚持属于长期控制，跟你的短期利益其实没多大关系（所以没几个人能坚持做一件事，随时可能放弃），真正能控制你做一件事的就是 及时反馈，就像很多人打游戏会上瘾，这是人的先天特征，短期利益永远重要，及时的反馈才能刺激我们的神经，坚持学英语也应该建立短期目标，提供及时反馈。这和新东方英语老师朱伟所说的：”多一些不为什么的坚持，少一些功利主义的追求“，其实是一样的，说的就是 长期目标无法让人坚持，心怀大志的去做甚至还不如莫名其妙，毫无理由的去做，有句古话很伤人，叫：“小人常立志，君子立志长”，我曾经就被这句话伤过，因为一直是一个有抱负有理想的青年，曾今有过很多远大的理想，但现在依然没什么值得说的成就，而且我经常会遇到与自己对立起来的情况，想要坚持，但又坚持不了，这其实不应该怪自己，就像你饿了要吃饭，而不是怪自己要吃饭，人应该多多发现自己的本性，而不要去对抗，在进行意志力对抗赛中我们应该常打胜仗，而不是去打必定失败的仗，比如你可以定一个小目标，跑1万米，雨中登山，这种短期的较量，只要你肯对自己下狠心，一定可以做成（而不是制定一个过于长远的计划），而且事后会极大的提升自己的自信，而人一天不是每时每刻都斗志满满，在脆弱的时候支撑你的绝不会是你的意志力，而是习惯，我们所做的所谓坚持，往往毫无胜算，而且不断地一次又一次的伤害到自己，不断的消磨意志力而不是提升，最后只会自己和自己对立起来变成一个真正的屌丝，和loser，真的是会有自暴自弃的那一天，只是你现在还年轻，但你仍然会发现岁月不曾停一刻地磨平你的棱角和骄傲，这大概是很多人经历过的吧。我们不应该用自己不多的意志力去打一场不可能赢的仗，我们应该用习惯，用及时反馈，用短期利益，和短期突进训练计划（强迫自己在一个较短的时间内做完某件困难的事，比如跑1万米，看完某个难懂的书的一章，需要查阅大量资料补全理解过程）。初时，随心所欲，以至于放荡不羁，堕落而颓废；中时，勤于律己，结果自我对立，苦不堪言；末了，依旧随心所欲，而不逾矩，如列子乘奔御风，逍遥自在，内心合一。这大概就是看山依旧是山的境界吧。我们需要的只是一个系统的及时反馈方法，和一个一个短时间的小目标（把一个大的计划分解成小目标是有道理的，人可以在短时间内强迫自己，熬一熬就过去了，相信你的意志力）。我这里并没有谈具体的技巧，想看具体技巧可以看接下来的 背单词”。</p><h3 id="背单词"><a href="#背单词" class="headerlink" title="背单词"></a>背单词</h3><p>做一件事，首先要证明他是否对你有用，否则不去做（这里我想说说对于游戏的态度，大多数人生来都喜欢玩游戏，但很明显很多人玩游戏上了瘾耽误了不少事，导致生活过的很糟心，我指的是大多数大学生哦，其实你有没有想过不是你在玩游戏，而是游戏在玩你）。背单词是学习英语的一个重大话题。有人说不用去背单词，因为背了单词却不会使用这样的大有人在，应该去广泛的阅读，在文章中记住单词的意思；有人说应该去背句子，用句子串起单词，这样就知道单词的用法；也有人说在阅读中增长词汇量太费时间，背单词是增长词汇量的捷径。<br>我发表一下我自己总结出来的一套看法：</p><ol><li>做任何事都要有正确的方法才能事半功倍，英语学习也是一样，我们可以科学地把学习语言分为：输入和输出，听、读是输入，说、写是输出，输出是输入的巩固和保障，没有输出，英语很难学好，事倍功半。这就是为什么我们大多数中国人总是学不好英语的原因，没有输出环境，输入环境倒是还可以。解决办法就是补上这个输出环节，方法无非是：强迫自己写作，学习地道的写作，地道的英语表达，强迫自己去说，学习地道的口语。</li><li>做事情慢比做错好，背单词首先要保证至少背的是正确的意思（无论是中文还是英文释义），在这个对的基础上，背了总比没背要好。</li><li>其次关于对背了单词却不会使用的问题，背单词属于输入，使用单词属于输出，你只是背单词当然不一定会使用，使用还得靠说，靠写。而架起输入和输出的桥梁就是模仿，再粗陋一点就是背诵然后一字不改的输出来。多背好句子，长句也好，短句也好，当然这个句子必须有亮点，要不然你自己都能写出来，就没有意义，比如全世界人都会说：I love you.[^1]要明白自己的起点，少做一些无用功。然后就是模仿造句，就像小时候学习中文的时候的造句练习。写短文，然后同样是模仿练习。这里说的背诵并不是要求你过多久都还记得背了什么，而是作为一个模仿对象，帮助自己正确的输出自己想要表达的东西，请问你小时候背过的文章你还记得几篇？关键不在于记忆故事、内容，而在于内化英文表达，形成语感。所以这里的背诵也可以理解为熟读，模仿。</li><li>我最想说的一点就是，我们很多人的词汇其实也不算低，但说英语根本没词，没话可说，或者说出来一堆的中式英语表达。原因在于，一门语言背后往往承载着一个相应的文化，就像我们中国不同地方的方言的表达也是不一样的。普通话说：行，河南话说：中。中西方文化差异造成了，即便你认识很多单词，知道很多语法，你依然不知道怎么去描述一件事，表达一种意思。因为别人文化里的表达方式和你的不一样。我们说：毫无睡意，英文表示则是：wide awake。请问这个表达是你直接能想到的吗，我们大多数人可能喜欢从字面上，一字一字翻译，这完全是错的，真正的翻译应该是一个意思对应一个意思的翻译，假如英文中有个意思中文里没有怎么办，这就是极考验翻译水平的地方，你要用简单易懂的方式解释，甚至可以创造一个舶来词。记单词并不是全部，背表达方式才能真正的学会一门语言。</li><li>既然背单词是可以有的，那么背单词该怎么背，我推荐用词频[^2]，按照语言掌握的一般规律，先背最常见的，再背次常见的，以此类推。一般柯林斯的词频就行了，网上也是很容易找到，柯林斯选出了1万多的词，把这些词总共分了5类，用五角星标记，五颗星的是最常见的，比如词频排名第一的the，就在这里面，依此类推，一颗星的是词频最低的，当然还有不带星的，那种单词就更少用到了，所以也不用急着去背。按词频背单词可以让你精确定位常用单词，避免学了一堆不常用的，这种安排其实也发生在我们学英语的整个过程，比如小学单词比初中单词常见，初中的又比高中的常见，高考的又比大学四六级的常见，大学四六级的又比考研、托福、雅思、GRE新增的词汇常见。按词频背单词还有一个好处就是可以查漏补缺，你可以清楚的知道自己哪些单词还稍微陌生，还有哪些重要的单词还完全不认识，这是靠阅读学单词花费大量时间也无法办到的。这叫针对性。当然阅读中学单词是有用的，一般来说我们可以在阅读中巩固对单词的记忆，用法等等，用起来的单词更容易记住，因为“用”这个词，代表你在反复强化你脑中的那些相应的神经元路径[^3]，而且增添更多的应用场景（新的神经元路径），让你记得更牢，更生动。</li></ol><h2 id="结合互联网的现代化笔记法"><a href="#结合互联网的现代化笔记法" class="headerlink" title="结合互联网的现代化笔记法"></a>结合互联网的现代化笔记法</h2><p>今天对于记笔记又有了点新想法，结合以前的，总结如下：</p><ol><li>所有笔记都不可靠，最终要记在脑子里，内化成自己可以随时调用的资料，和意识。笔记只是为了便于复习回顾，没有内化它就不是你的，只是一团外在的信息，对你来说也就跟没有一样，你还是你，当笔记是身外之物的时候它是不可靠的，只有当知识、技巧和思维方法内化进你大脑的神经回路里，它才真正成为你身体的一部分，是自我意识的一部分，你也因此变得更加强大起来，然而很多人学的知识是死的，不能用于帮助自己解释和理解这个世界，和身边发生的各种事，那你学这些东西又有什么意义呢，你面对这个纷繁复杂的现象宇宙，鸟还是鸟，花草树木还是花草树木，月亮还是月亮，感性统治着你，所有知识和理性全都被封锁起来，你看不透这个世界，也没有借助自己所学去帮助自己看透这个世界，于是你忘了你学的东西。自始至终都没有用到它们，忘掉是很自然的。但其实它们就在你身边，无时无刻不在，只是你没发现它们，没有有意识地去看见它们。这样的学习学一辈子都是竹篮打水（漏的跟打的一样多），到头来一场空，白白虚耗了时光。少年，想获得力量吗，那就去做个有心人吧，把知识用起来，让它成为你大脑的一部分。</li><li>笔记一定要电子化，书籍也电子化，因为电子化便于携带，传输，查阅，搜索，检索。就算先写在纸上，但之后也要拍照整理成电子的（并附加上关键词，摘要），数据不应该流失，遇到半熟的知识，第一反应查笔记，第二反应上互联网搜，并把学到的用自己的语言记在笔记里。</li><li>善于找别人记下的笔记和总结，同时利用起像百度百科和维基百科和各种人的博客等等东西，前两者比较稳定，所以可以贴链接即可，后者不稳定一定要截图，或者复制粘贴。这样做是尽量保证笔记的持久性，其实这么久的持久性也没啥用，因为你势必要在相对较短的时间内消化知识，你不消化它就会淡忘，你不用起来它就相当于没有，你也就白学了。比如我一直想整理出一份完整的系统的数学笔记，但我其实没有必要一笔一笔写下这个笔记，而且我也没有这个时间去干这件事，而且说到底笔记只是用来协助内化记忆，本身就只是一个附带性工作（当然也不能潦草敷衍，否则难起到应有的作用），何必如此执着，真正要下功夫做的是记忆，运用（做题，解题中应用知识），并结合生活这本无字大书。别人的笔记不完整，这不要紧，你自己立好框架，然后以添加URL链接的方式把这些内容接入你的框架。比如今天我找柯西中值定理的证明，我忘了怎么推导这个定理，我去谷歌搜索了，维基百科里有完整的证明，我只需在笔记中柯西中值定理证明这一处添加一个链接，或做个注释。如上所说，我只添了：证明，维基百科，这么几个字，这是因为只要在有互联网和手机的时候我就可以立即查阅，互联网是一个非常便利的云端，增强了每一个现代人的移动性（这一重要属性在罗辑思维里，吴伯凡总结过，生物的一个基本属性就是移动性，越高等的生物移动属性越高），这就是结合网络的笔记法，整个网络都是你的笔记，你只需要做个标记就可迅速找到。</li><li>由此便可得出 只列框架和名词的高度精简笔记（甚至框架也可以在互联网上找到合适的，但每个人都有自己的知识树，另外框架是个索引性的东西，你自己必须非常熟悉，如果索引都依赖于外部，你自己还剩下些什么呢，特别是重要的索引，一定得是非常熟悉的）：</li></ol><ul><li>概念</li><li>应用场景</li><li>发现背景</li><li>证明推导过程</li><li>习题<br>等等都以树状链接开来，有本地的拓展也有互联网的拓展部分。</li></ul><ol start="5"><li>由于互联网上的许多内容不一定正确（甚至有的时候会误导你），不一定完整，而书籍和传统出版物相对来说靠谱，所以做笔记时强烈建议考虑内容的质量。</li></ol><p>[^1]:英语和汉语的共同点就是主谓宾的顺序是一致的，不同点在于修饰，英语的修饰习惯后置，汉语的修饰从不后置，一定是放在前面的 ↩<br>[^2]:词频号，代表词出现在词频排名中的位置，比如the的词频号是1，代表它在语料库中出现频率最高，排名第一。 ↩<br>[^3]:人脑记忆的物理特点：靠神经元的链接，电脑存储的特点：靠电子元件的电位固定地，精确地存储。有时候你忘了一样东西，并不是他消失了，而是它在你脑中的神经元连接路径太弱、太少，你搜索不到它。所以我们记忆有两个特点：一个是不断重复强化，加强这条路径；一个是把要记忆的东西跟很多已经在你脑海里最常用的记忆联系起来，也就是并入你的记忆主堡，那你将快速的找到它，这也是理解性记忆的根源，因为理解代表与你的已有认知不悖，也就是可以由已有定理推出要学习的定理，如果推导一个定理可以有很多方法，或者有一个非常容易想到的方法，那么这条定理顺理成章的就被你记下来了。死记硬背则是用的第一种方法，不断的重复强化，但效果不佳，原因很简单，我们的大脑天生喜欢第二种方法，这是大脑的物理结构决定的，物理基础决定上层建筑，只有把一个东西并入你的知识树，内化成自己的日常认知习惯，它就牢牢的钉在你的脑子里，成为你随时可以调取的记忆，而这也是世上不存在靠死记硬背能真正学透的原因，因为死记硬背没有使这个知识和其他东西联系起来，就像你是一个瓶子一个瓶子的装知识，其间泾渭分隔，发散性很差，那么你根本不会在很多要用的时候想起它来，也就无法学以致用。 ↩</p>]]></content>
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>从 windows 转用 mac OS X 记录</title>
      <link href="/blog/2017/01/01/%E4%BB%8Ewindows%E8%BD%AC%E7%94%A8macOSX%E8%AE%B0%E5%BD%95/"/>
      <url>/blog/2017/01/01/%E4%BB%8Ewindows%E8%BD%AC%E7%94%A8macOSX%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<p>这篇文章我想讲讲我从用 Windows 到用 mac OS X 的过程中遇到的困难和解决方法。</p><p>由于我本人是学计算机的，电脑用的多，喜欢用一些设计的好的快捷键，所以我分为两部分吧，第一部分讲给普通用户，第二部分讲给程序员。</p><p>先告诉你们一个通用小技巧，众所周知，flash视频非常让电脑发热，而看HTML5视频则一点都不热。safari有个伪装成iPad或者iPhone的功能，可以把视频强制用HTML5播放。你的MacBook就再也不会在看视频的时候发烫了。</p><p><img src="https://wx4.sinaimg.cn/mw690/006zFO3ggy1fcd4d2uzibj31kw0zkdug.jpg" alt="safari强制使用HTML5播放视频"></p><p>时至今日（2017.9.9），很多网站都可以使用 HTML5播放视频了，如：bilibili，中国大学MOOC，使用 HTML5播放视频是未来的方向。</p><h2 id="普通用户使用mac指南"><a href="#普通用户使用mac指南" class="headerlink" title="普通用户使用mac指南"></a>普通用户使用mac指南</h2><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p>找不到浏览器吗？点击像指南针图标的那个safari，那个应用就是浏览器。</p><h3 id="输入法"><a href="#输入法" class="headerlink" title="输入法"></a>输入法</h3><p>和初次使用Linux一样，一上来我们肯定就要碰到输入法的难题，mac切换输入法的快捷键是command+space（空格），一般的系统或者软件都是支持自定义快捷键的，你可以修改快捷键。对于用惯了搜狗输入法的同学，这里我推荐使用搜狗输入法，它可以记住用户习惯。</p><p><img src="https://wx4.sinaimg.cn/mw690/006zFO3ggy1fcceny2wsuj31kw0zkdku.jpg" alt="mac输入法截图"></p><p>搜狗默认的通用中英文切换键是 shift。</p><h3 id="触摸板"><a href="#触摸板" class="headerlink" title="触摸板"></a>触摸板</h3><p>mac的触摸板应该是所有笔记本电脑触摸板的宗师吧，而且也是最好用的触摸板。我用mac的时候，除了玩游戏，完全用不着鼠标。</p><p>没有鼠标，那么左右键怎么办？很简单：一指单击触摸板，就是左键，两指单击触摸板，就是右键。记得将轻触触摸板设置为点击，这样可以延长触摸板的寿命，而且点起来也舒服多了。</p><p>五指合拢，你可以看到你电脑上安装好的应用，这个界面叫做：launchpad。</p><p><img src="https://wx2.sinaimg.cn/mw690/006zFO3ggy1fccexd55wpj31kw0zktgg.jpg" alt="launchpad截图"></p><p>五指弹开，如果你处在launchpad界面，五指弹开就会回到原先五指合拢之前的那个界面，回到这个界面之后，再用一次五指弹开，就是弹开所有应用，让你看到桌面（如果你当前窗口是全屏模式，则此法失效）。</p><p><img src="https://wx3.sinaimg.cn/mw690/006zFO3ggy1fccf5tp4rpj31kw0zkjwj.jpg" alt="弹开应用看到桌面"></p><p>三指上推，可以看到所有打开的窗口的缩略图。</p><p><img src="https://wx4.sinaimg.cn/mw690/006zFO3ggy1fccf0mfcanj31kw0zkqcm.jpg" alt="窗口缩略图"></p><p>三指横扫，可以在全屏之间切换，这是我最喜欢的设计之一。</p><h3 id="安装应用"><a href="#安装应用" class="headerlink" title="安装应用"></a>安装应用</h3><p>去官网下好应用，通常是.dmg后缀的安装包，打开，拖拽到Applications文件夹就完成了安装，比Windows爽多了吧。</p><h3 id="文件管理器Finder"><a href="#文件管理器Finder" class="headerlink" title="文件管理器Finder"></a>文件管理器Finder</h3><p>调整默认Finder窗口大小，可以按住option，然后进行拖动，窗口的大小就可以保留下来了。</p><p>command+shift+.可以显示隐藏文件，关闭显示隐藏文件也是这个快捷键。</p><p>右键之后，没有新建文件选项。</p><p>你只能先打开应用，然后在应用中新建文件。</p><p>记住在Windows上用的很爽的ctrl+a、ctrl+s、ctrl+c、ctrl+v、ctrl+f等等，在mac上统统把ctrl换成command就OK了。</p><p>command+x不能剪切文件和文件夹是吧。</p><p>解决办法是：先command+c，然后command+option+v，成功的完成文件的剪切和粘贴。</p><p>普通用户的指南到此结束，如果有什么问题，请私信我的知乎，我博客头像下面有个知乎的知的图标，点击就能到我的知乎个人主页。</p><h2 id="程序员mac指南"><a href="#程序员mac指南" class="headerlink" title="程序员mac指南"></a>程序员mac指南</h2><p>先上几个零碎的小技巧：</p><p>触摸板双指双击，放大（我觉得其实没啥卵用）</p><p>在应用窗口顶栏双击，缩放窗口（这个Windows也有的）</p><h3 id="文件管理器Finder-1"><a href="#文件管理器Finder-1" class="headerlink" title="文件管理器Finder"></a>文件管理器Finder</h3><p>首先讲Finder，这是mac 系统，也就是OS X系统的文件管理器，和windows的文件管理器对比有点不同，最不方便的地方在于点击右键没有新建文件选项，如果你会Linux，可以用命令touch 文件名来新建文件，如果你不会命令，可以先打开文本编辑器，再新建文本文件，它的设计哲学是，你要新建什么文件，就先打开与这个文件相关的软件，再在这个软件里新建这个类型的文件，不过不方便就是不方便。再讲讲优秀的地方，Finder可以打开多级目录。</p><p><img src="https://ww4.sinaimg.cn/mw690/005DrjN1gw1fbgxqax4waj316s0o8n0e.jpg" alt="Finder多级目录"></p><p>另外可以 按空格键预览，这个预览功能现在 Windows 也有了。</p><p>Finder还有tag系统，你可以通过tag来访问属于同一个tag的文件</p><p><img src="https://ww3.sinaimg.cn/mw690/005DrjN1gw1fbgxwxxpobj316s0o8ad8.jpg" alt="Finder的tag功能"></p><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><blockquote><p>快捷键肯定是最重要的啦！</p></blockquote><p>然后讲讲快捷键设计，我在windows下已经有了些使用快捷键的习惯，比如：</p><p>win+E是打开文件管理器</p><p>win+D是显示桌面（也就是将所有窗口最小化）</p><p>win+L锁屏</p><p>ctrl+S保存</p><p>ctrl+A全选</p><p>ctrl+C复制</p><p>ctrl+X剪切</p><p>ctrl+V粘贴</p><p>ctrl+F查找</p><p>当我来到OS X下的时候，我同样先摸索了一番快捷键。设计快捷键的哲学就是通用，这样就可以节省记忆成本，mac上的cmd基本上承担了windows上ctrl的职能，常用的快捷键有：</p><p>cmd+S保存</p><p>cmd+A全选</p><p>cmd+C复制</p><p>cmd+X剪切</p><p>cmd+V粘贴</p><p>cmd+F查找</p><p>cmd+D制作副本</p><p>按住option+command，拖动文件，可以产生快捷方式，也就是链接。</p><p>cmd+, 打开preferance也就是打开设置界面，这个快捷键简直不要太爽，希望 Windows 上也弄一个</p><p>cmd+N 打开新窗口</p><p>cmd+W 关闭窗口</p><p>cmd+H 隐藏窗口</p><p>cmd+Q 退出程序</p><p>cmd+ctrl+F 全屏和退出全屏，播放视频时候退出全屏一般是 ESC 键</p><p>cmd+Tab切换程序</p><p>你用了Finder之后可能会恼火没有剪切文件的功能，但其实是有的，只是快捷键不一样，剪切文件的快捷键是，先cmd+C复制，然后cmd+option+V粘贴。</p><p>这是我常用的几个快捷键。总之快捷键不用记很多，按你自己的需要，记住常用的就行。</p><p>Command+Option+D 控制Dock的显示与隐藏，我还是喜欢留着 Dock。</p><p>Command+Option+H 隐藏所有其他窗口</p><p>Shift+音量 会有声音，直接按音量默认是不出声</p><p>Command+I 显示简介（在Finder中），然后就 可以修改打开一个文件的默认APP</p><p>Command+Control+N 新建一个文件夹，并归类你选中的所有文件</p><h4 id="编辑文本的快捷键"><a href="#编辑文本的快捷键" class="headerlink" title="编辑文本的快捷键"></a>编辑文本的快捷键</h4><p>Command+Space 切换输入法</p><p>Command+left 让光标跳到最前面，相当于windows下的home键</p><p>Command+right 让光标跳到最后，相当于windows下的end键</p><p>Command+up 让光标跳到整个文本的最开头</p><p>Command+down 让光标跳到整个文本的最后</p><p>Command+delete 删除当前行，相当于windows下的home，shift+end（选中，从行头到行尾），backspace，这三个操作的组合。这个快捷键会让你相当爽的。</p><h4 id="截图快捷键"><a href="#截图快捷键" class="headerlink" title="截图快捷键"></a>截图快捷键</h4><p>Command+Shift+3 截取整个桌面，并把截图作为一个文件存储在桌面上</p><p>Command+Shift+4 截取一个区域，并把截图作为一个文件存储在桌面上</p><p>Command+Shift+Ctrl+3 截取整个桌面，并复制到剪切板</p><p>Command+Shift+Ctrl+4 截取一个区域，并复制到剪切板</p><p>Command+Shift+4 然后按Space就会截取一个窗口。这样截图会自带阴影效果。如果不想自带阴影效果，可以按住option再点触摸板。</p><p>Command+Ctrl+A mac QQ 截图快捷键，由于屏幕分辨率太高，mac系统快捷键截出来的图都太大了，而macQQ截出来的图大小正合适。</p><h4 id="Chrome浏览器快捷键"><a href="#Chrome浏览器快捷键" class="headerlink" title="Chrome浏览器快捷键"></a>Chrome浏览器快捷键</h4><p>这个应该是与操作系统无关的（有些快捷键还是不一样的），但在Mac下养成了用快捷键的习惯，所以Chrome的快捷键都是在Mac上学的，在windows下注意用Ctrl替换Command键就行了。</p><p>Command+R 刷新</p><p>Command+L 将窗口焦点锁定到浏览器的地址栏，不用移动鼠标哦</p><p>Command+T 打开一个新Tab</p><p>Command+Shift+T 打开一个之前被关闭的Tab</p><p>Command+Shift+J 打开下载页面</p><p>Command+Shift+C 打开“检查(spectator)”，鼠标右键可以看到这个选项，一般是程序员使用的高级功能，但不能再次使用快捷键关闭。</p><p>Command+Shift+I 同样是打开spectator，使用开发人员工具，但可以再次使用快捷键关闭。</p><p>Command+Shift+B 打开或关闭书签栏</p><p>Command+Option+B 打开书签管理器</p><p>Command+Y 打开历史记录</p><p>Command+Option+左右方向键 切换标签页</p><p>Command+D 收藏此页为书签</p><p>Command+Shift+D 将所有标签页加书签</p><p>Command+上下方向键 跳到页面顶部或底部</p><p>Command+Option+J 打开javascript控制台</p><p>按住Command后点击链接，在新Tab（标签页）中打开这条链接。</p><p>Command+Shift再点击链接，在新标签页中打开并切换到新标签页</p><p>Command+Shift+N 用隐身模式打开新窗口</p><p>Command+Shift+W 关闭当前窗口</p><p>Command+[ 或者 ] 前进或者回退</p><p>Command+左右方向键 前进或者后退</p><p>Command+Option+U 查看网页源代码</p><h4 id="iTerm2快捷键"><a href="#iTerm2快捷键" class="headerlink" title="iTerm2快捷键"></a>iTerm2快捷键</h4><p>iTerm2中的文本，选中即复制，这个其实没必要，我现在都习惯了选中后 cmd+c，而且当你选择替换目标时候由于这个选中即复制，会覆盖掉你的剪切板</p><p>Command+D 水平分隔出一个终端</p><p>Command+Shift+D 垂直分割出一个终端</p><p>可以配置透明度，Command+U快速切换透明与否</p><p>可以配置全局唤出快捷键，我自己配置的是Command+U</p><p>可以配置快捷悬浮，Hotkey window</p><p>Command+Shift+H 查看复制历史</p><p>Command+Enter 快速切换全屏与否</p><h4 id="CLI-命令行-快捷键"><a href="#CLI-命令行-快捷键" class="headerlink" title="CLI(命令行)快捷键"></a>CLI(命令行)快捷键</h4><p>Mac本身的特点就是GUI和CLI的完美结合（很多Linux的爱好者，又不想被Linux的桌面、各种驱动、不兼容等等杂七杂八的问题折腾的，大可选择Mac）。</p><p>首先教一个最重要的东西<br>记住按Tab补全，这是命令行用的爽的根源。</p><p>Ctrl+A 回到行首</p><p>Ctrl+E 到行末</p><p>Ctrl+U 删除一行</p><h2 id="格式转换"><a href="#格式转换" class="headerlink" title="格式转换"></a>格式转换</h2><p>有时候需要把 png 等格式的图片转成 jpg 的格式，于是有同学就去到处找格式转换软件了。<br>其实在 Mac 中直接更改图片的扩展名，即可自动转成相应地格式~试试吧，如果你改格式前看了文件修改日期，改完格式后你会发现修改日期依然没变，至于原因是什么，需要你有图片的文件格式的相关知识。</p><h2 id="Launchpad与Dock"><a href="#Launchpad与Dock" class="headerlink" title="Launchpad与Dock"></a>Launchpad与Dock</h2><p>Launchpad是指，你在触摸板上用五指向中间收拢，出现的全是APP的页面，半透明的。</p><p>Dock是指，最下方的摆满APP的一栏，在Dock上你可以放上最常用的APP。</p><p>调整launchpad的图标大小：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//把行数重定义成6</span><br><span class="line">delete write com.apple.dock springboard-rows -int 6</span><br><span class="line">//把行数充定义成默认</span><br><span class="line">defaults write com.apple.dock springboard-rows Default</span><br><span class="line">//删除定义好的行数（恢复默认）</span><br><span class="line">defaults delete com.apple.dock springboard-rows</span><br><span class="line">//把列数定义成默认</span><br><span class="line">defaults write com.apple.dock springboard-columns Default</span><br><span class="line">//重置 Launchpad，效果就是 launchpad 的布局全给你打乱了，而第一页恢复默认，建议不要使用</span><br><span class="line">defaults write com.apple.dock ResetLaunchPad -bool TRUE</span><br><span class="line">//重启 Launchpad，并使你前面的设置生效</span><br><span class="line">killall Dock</span><br></pre></td></tr></table></figure><p>在appstore下载一个软件到一半，然后在Application删除了该软件，结果在launchpad中留下了一个垃圾残留空图标。<br>删除launchpad中的垃圾残留图标，只需拖拽到下载文件夹。其他方法都试过（无效），比如按住图标几秒，出现一个叉，点击叉，删除，没用。在Application找到相应项删除没用。</p><h2 id="Option的妙用"><a href="#Option的妙用" class="headerlink" title="Option的妙用"></a>Option的妙用</h2><p>下面再讲些不常用但是有意思的：</p><p>除了cmd是常用的，option键也值得我们关注，下面讲几个option的妙用：</p><p>按住option+shift可以微调（1/4微调）音量、键盘背光亮度和屏幕亮度，按住option再按其他字母键等，会出现奇怪的字符¥©<br>©œ∑®†¥åß©≈ç等等。</p><p>按住option再把鼠标移到Dock上的APP上，你会发现退出变成了强制退出，怎么样option键还是挺强大的吧。</p><h3 id="数学符号"><a href="#数学符号" class="headerlink" title="数学符号"></a>数学符号</h3><p>约等于: Option + X = ≈<br>度数: Shift + Option + 8 = °<br>除号: Option + / = ÷<br>无穷: Option + 5 = ∞<br>大于等于和小于等于: Option + , 和 Option + . = ≤ 和 ≥<br>不等于: Option + = = ≠<br>圆周率: Option + P = π<br>加减: Shift + Option + = = ±<br>开方: Option + V = √<br>求和符号: Option + W = ∑</p><h3 id="输入特殊符号"><a href="#输入特殊符号" class="headerlink" title="输入特殊符号"></a>输入特殊符号</h3><p>版权符号: Option + G = ©</p><p>人民币符号: Option + Y = ¥</p>]]></content>
      
      <categories>
          
          <category> 数码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线性代数笔记--线性代数复习核心思想</title>
      <link href="/blog/2016/09/30/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0--%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%A4%8D%E4%B9%A0%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3/"/>
      <url>/blog/2016/09/30/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0--%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%A4%8D%E4%B9%A0%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3/</url>
      <content type="html"><![CDATA[<p>线性代数是一个整体，各个模块之间联系密不可分。</p><p>一、行列式、矩阵</p><p>二、向量组、方程组</p><p>三、特征值、二次型</p><p>命题重点在二和三。</p><p>难点在矩阵和向量组<br>秩的等式和不等式的研究、分块矩阵</p><p>例题：设n阶矩阵A、B乘积可交换，$\xi_1,\xi_2,\cdots,\xi_{r_1}、\eta_1,\eta_2,\cdots,\eta_{r_2}$分别是AX=0,BX=0的一个基础解系，且对于n阶矩阵C、D，有r(CA+DB)=n,<br>（I）证明$r\begin{pmatrix}A\B\end{pmatrix}=n$，且$\xi_1,\cdots,\xi_{r_1},\eta_1,\cdots,\eta_{r_2}$无关；<br>（II）证明$\xi_1,\cdots,\xi_{r_2},\eta_1,\cdots,\eta_{r_2}$是ABX=0的一个基础解系。<br>1.是解，2.无关，3.<strong>S=n-r，S是基础解系的个数，是自由变量的个数，也就是总变量-秩（有效方程个数，也即约束的个数）</strong><br><strong>矩阵越乘秩越小</strong><br>（I）<br>$n=r(CA+DB)=r\left((C D)\begin{pmatrix}A\B\end{pmatrix}\right)\leq r\begin{pmatrix}A\B\end{pmatrix}\leq n\Rightarrow r\begin{pmatrix}A\B\end{pmatrix}=n列满秩$</p><p>$\Rightarrow \begin{pmatrix}A\B\end{pmatrix}X=0只有零解\Rightarrow AX=0与BX=0没有非零公共解\Rightarrow \xi_i(i=1,2,\cdots,r_1)均不可由\eta_1,\eta_2,\cdots,\eta_{r_2}表出，因若不然，\xi_i=k_1\eta_1+k_2\eta_2+\cdots+k_{r_2}\eta_{r_2}，则有公共非零解，矛盾，同理可得，\eta_i(i=1,2,\cdots,r_1)均不可由\xi_1,\xi_2,\cdots,\xi_{r_2}表出，故\xi_1,\cdots,\xi_{r_1},\eta_1,\cdots,\eta_{r_2}$无关<br>（II）<br>显然，$B\eta_j=0,j=1,2,\cdots,r_2\Rightarrow AB\eta_j=0\Rightarrow\eta_j是ABX=0的解；又AB=BA，A\xi_i=0\Rightarrow BA\xi_i=AB\xi_i=0\Rightarrow\xi_i也是ABX=0的解$<br>$r(AB)\geq r(A)+r(B)-n=n-r_1+n-r_2-n=n-(r_1+r_2)$<br>$ABX=0的S=n-r(AB)\leq r_1+r_2，基础解系中至多r_1+r_2个向量，又根据第一问的证明，显然S\geq r_1+r_2，至少r_1+r_2个，恰有r_1+r_2个解向量$</p>]]></content>
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>线性代数笔记--基础篇：行列式、矩阵的本质</title>
      <link href="/blog/2016/09/30/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0--%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%9A%E8%A1%8C%E5%88%97%E5%BC%8F%E3%80%81%E7%9F%A9%E9%98%B5%E7%9A%84%E6%9C%AC%E8%B4%A8/"/>
      <url>/blog/2016/09/30/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0--%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%9A%E8%A1%8C%E5%88%97%E5%BC%8F%E3%80%81%E7%9F%A9%E9%98%B5%E7%9A%84%E6%9C%AC%E8%B4%A8/</url>
      <content type="html"><![CDATA[<p>线性：量和量之间的关系是一次的<br>线性代数的核心研究对象：<strong>向量</strong></p><h2 id="行列式的本质定义"><a href="#行列式的本质定义" class="headerlink" title="行列式的本质定义"></a>行列式的本质定义</h2><p>（行列式的绝对值）是n维向量所构成的图形的面积或体积（面积和体积分别是二唯和三维的说法，更高维数依次类推）。<br>determinant（行列式）</p><h2 id="行列式的性质"><a href="#行列式的性质" class="headerlink" title="行列式的性质"></a>行列式的性质</h2><ol><li>$D_n=|A|中某行元素全为0\Rightarrow |A|=0$,因为有一个向量为0，所以构成的图形比n少一维，所以体积为0。</li><li>$D_n=|A|中某两行元素对应成比例\Rightarrow |A|=0$,因为有两个向量是平行的，所以构成的图形体积为0.</li><li>（互换）$|A|$中某两行元素互换$\Rightarrow|A|$变号(即得到$-|A|$),两向量的夹角变了，$\sin (\alpha-\beta)=-\sin (\beta-\alpha)$,所以体积变号。</li><li>（倍乘）乘k，就把k乘到任意一行或者列，同理如果某行或者列可以提出k倍也行。因为某向量乘k倍，体积变为k倍。<strong>这里要区别于矩阵的倍乘，矩阵是用来表达系统信息的数表，每个元素都要乘k倍。</strong></li><li>（倍加）某行乘k倍加到另一行上，行列式结果不变，几何表述：<strong>因为这两个向量构成的平行四边形同底同高，面积不变，所以体积也不变。</strong>可拆性表述：拆成两个行列式，其中一个行列式为0，因为它某两行对应成比例。</li><li>单行可拆（加）性</li><li>$|A|=|A^T|$，行列等价，前六个性质同样适用于列。</li></ol><h3 id="重要观点"><a href="#重要观点" class="headerlink" title="重要观点"></a>重要观点</h3><ol><li>$D_n=|A|\neq0\Rightarrow S\neq0\Rightarrow 组成行列式的向量全独立$</li><li>$D_n=|A|=0\Rightarrow 组成行列式的向量至少有一个多余$<br><strong>行列式=0还是$\neq$0才是关键，而不是管它等于多少</strong><br><strong>向量与向量之间要么独立要么多余</strong></li></ol><h2 id="矩阵的本质"><a href="#矩阵的本质" class="headerlink" title="矩阵的本质"></a>矩阵的本质</h2><ol><li>表面上，矩阵是表达系统信息的数表</li><li>本质上，矩阵也是由向量构成的，矩阵的核心是矩阵的<strong>秩</strong>，而秩的本质是组成矩阵的独立向量的个数；矩阵是一种<strong>运算</strong>，一种对应法则，把一个线性代数研究对象变换成另一个的手段；<strong>矩阵还是方程组的系数表</strong>，决定了初等变换的性质（可以行对调，可以行倍加倍减，可以行倍乘）。</li></ol><p><strong>秩的本质</strong>：r(A)=k，则矩阵中有k个独立的向量</p><p><strong>台阶数=秩</strong>，因为台阶之间（向量之间）是独立的。</p><p><strong>行阶梯形矩阵</strong>：1）若有0行，全在下方，2）从行上看，自左边起，出现连续0的个数，自上而下严格单增。若还满足3）台角位置元素为1，4）台角上方元素全为0，称为<strong>行最简阶梯形矩阵</strong>。</p><p><strong>初等变换法：互换、倍乘、倍加</strong></p><p>解释：互换不影响方程组的解，不影响向量的独立性，倍乘不影响方程组的解，不影响向量的独立性，倍加不影响方程组的解，不影响向量的独立性。<strong>矩阵进行初等变换不影响矩阵的秩，</strong>不影响矩阵的本质意义，所以初等变换是可以大量广泛使用的。<br><strong>任何可逆矩阵一定可以通过若干次初等变换化成同阶单位阵</strong></p><h3 id="矩阵的乘法"><a href="#矩阵的乘法" class="headerlink" title="矩阵的乘法"></a>矩阵的乘法</h3><p>AB=C</p><p>矩阵的乘法中，C中的每一个元素都是一个<strong>向量的内积</strong>，所以矩阵乘法可以看做向量内积的推广。另外矩阵的左乘代表行变换，矩阵的右乘代表列表换。矩阵的乘法也可以看做一种函数变换，因为矩阵乘法可以把一个线代对象，转换成另一个线代对象。</p><p><strong>乘法单位元素：</strong><br>1·a=a,a·1=a，其中1称为乘法单位元素，矩阵的乘法单位元素是E（单位矩阵）</p><p><strong>乘法反单位元素：</strong><br>$a\cdot\frac{1}{a}=1,\frac{1}{a}\cdot a=1$，其中$a$和$\frac{1}{a}$互称乘法反单位元素。矩阵$A$的乘法反单位元素是$A^{-1}$。<br>二阶逆矩阵，主对角线对调，次对角线取相反数。</p>]]></content>
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
    </entry>
    
  
  
</search>
