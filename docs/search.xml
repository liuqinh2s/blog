<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>加密货币收藏网址</title>
      <link href="/blog/2022/11/30/%E5%8A%A0%E5%AF%86%E8%B4%A7%E5%B8%81%E6%94%B6%E8%97%8F%E7%BD%91%E5%9D%80/"/>
      <url>/blog/2022/11/30/%E5%8A%A0%E5%AF%86%E8%B4%A7%E5%B8%81%E6%94%B6%E8%97%8F%E7%BD%91%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<ul><li><a href="https://bitcoin.design/guide/getting-started/introduction/" target="_blank" rel="noopener">Getting started | Bitcoin Design</a></li></ul><a id="more"></a><ul><li>老币：<ul><li><a href="https://turtlecoin.herominers.com/?lang=en#" target="_blank" rel="noopener">乌龟币(TRTL)矿池</a></li><li><a href="https://wallet.mymonero.com/" target="_blank" rel="noopener">门罗币(XMR)网页钱包</a></li><li><a href="https://monero.herominers.com/" target="_blank" rel="noopener">门罗币矿池</a></li></ul></li><li>BSC 链项目：<ul><li><a href="https://pancakebunny.finance/vault" target="_blank" rel="noopener">bunny 矿池</a></li><li><a href="https://pancakeswap.finance/" target="_blank" rel="noopener">pancake</a></li><li><a href="https://app.beefy.finance/?utm_source=tokenpocket" target="_blank" rel="noopener">beefy</a></li><li><a href="https://jetswap.finance/" target="_blank" rel="noopener">jetswap</a></li><li><a href="https://bscscan.com/" target="_blank" rel="noopener">BNB Smart Chain Explorer</a></li><li><a href="https://app.loserswap.com/" target="_blank" rel="noopener">LOWB</a></li><li><a href="https://loserbridge.org/erc20" target="_blank" rel="noopener">LOWB 跨链桥</a></li><li><a href="https://www.bnbchain.org/en/bridge" target="_blank" rel="noopener">BSC 桥</a></li></ul></li><li>KCC 链：<ul><li><a href="https://docs.kcc.io/#/zh-cn/?id=%e4%b8%bb%e7%bd%91" target="_blank" rel="noopener">文档</a></li><li><a href="https://explorer.kcc.io/cn/" target="_blank" rel="noopener">区块查询</a></li></ul></li><li>AxieInfinity：<ul><li><a href="https://marketplace.axieinfinity.com/axie" target="_blank" rel="noopener">axie market</a></li><li><a href="https://marketplace.axieinfinity.com/login/" target="_blank" rel="noopener">账号中心</a></li><li><a href="https://whitepaper.axieinfinity.com/axs" target="_blank" rel="noopener">白皮书</a></li><li><a href="https://axie.zone/" target="_blank" rel="noopener">axie zone</a></li><li><a href="https://www.axie.tech/" target="_blank" rel="noopener">axie tech</a></li><li><a href="https://www.axieworld.com/cn/guides" target="_blank" rel="noopener">axie world</a></li><li><a href="https://github.com/axieinfinity" target="_blank" rel="noopener">axieinfinity github</a></li><li><a href="https://katana.roninchain.com/#/farm" target="_blank" rel="noopener">katana</a></li><li><a href="https://stake.axieinfinity.com/" target="_blank" rel="noopener">AXS Staking</a></li></ul></li><li><a href="https://happypeter.github.io/binfo/" target="_blank" rel="noopener">快乐区块维基</a></li><li><a href="https://zhuanlan.zhihu.com/p/38333164" target="_blank" rel="noopener">【以太坊】深入理解 gas 机制</a></li><li><a href="https://github.com/djrtwo/evm-opcode-gas-costs/blob/master/opcode-gas-costs_EIP-150_revision-1e18248_2017-04-12.csv" target="_blank" rel="noopener">evm-opcode-gas-costs</a></li><li>空投：<ul><li><a href="https://airdrops.io/" target="_blank" rel="noopener">airdrops.io</a></li><li><a href="https://defillama.com/airdrops" target="_blank" rel="noopener">defi llama</a></li></ul></li><li>智能合约：<ul><li><a href="https://docs.metamask.io/guide/provider-migration.html#replacing-window-web3" target="_blank" rel="noopener">Provider Migration Guide | MetaMask Docs</a></li><li><a href="https://betterprogramming.pub/how-to-become-a-blockchain-engineer-fa4386a0504f" target="_blank" rel="noopener">How to Become a Blockchain Engineer | by Patrick Collins | Better Programming</a></li><li><a href="https://hecoinfo.com/address/0xb62e3b6a3866f5754fdefcf82e733310e2851043#code" target="_blank" rel="noopener">HTMoon</a></li><li><a href="https://hecoinfo.com/address/0xb3863e02d6930762933F672cA134C1CceCd0D413#code" target="_blank" rel="noopener">DOG</a></li><li><a href="https://solidity.tryblockchain.org/Solidity-Type-Integer-%E6%95%B4%E5%9E%8B.html" target="_blank" rel="noopener">区块链技术-智能合约 Solidity 编程语言</a></li><li><a href="https://m.jinse.com/blockchain/1135705.html?source=m" target="_blank" rel="noopener">代币 YELD 价格直接跳水归零：PolyYeld Finance 被攻击事件全解析</a></li><li><a href="https://paper.seebug.org/601/" target="_blank" rel="noopener">以太坊智能合约安全入门了解一下（上）</a></li><li><a href="https://zhuanlan.zhihu.com/p/261690742" target="_blank" rel="noopener">智能合约入门 1——Remix+合约调用</a></li><li><a href="https://happypeter.github.io/binfo/smart-c-intro" target="_blank" rel="noopener">智能合约入门</a></li><li><a href="https://learnblockchain.cn/docs/solidity/introduction-to-smart-contracts.html" target="_blank" rel="noopener">智能合约入门</a></li><li><a href="https://ethernaut.openzeppelin.com/" target="_blank" rel="noopener">Ethernaut</a></li><li><a href="https://blockchain-ctf.securityinnovation.com/#/" target="_blank" rel="noopener">Security Innovation Blockchain CTF</a></li><li><a href="https://xzlang.github.io/2020/05/12/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%AE%89%E5%85%A8%E5%85%A5%E9%97%A8-ETHERNAUT-WriteUp/" target="_blank" rel="noopener">智能合约安全入门:ETHERNAUT-WriteUp</a></li><li><a href="https://www.jianshu.com/p/a25e6b76dc62" target="_blank" rel="noopener">blockchain-ctf 靶场（0-12）</a></li><li><a href="https://blog.csdn.net/rfrder/article/details/115572137" target="_blank" rel="noopener">Ethernaut 靶场刷题（上）</a></li><li>免费领取测试网络币：<a href="https://faucet.rinkeby.io/" target="_blank" rel="noopener">Rinkeby Authenticated Faucet</a></li><li><a href="https://cryptozombies.io/zh/" target="_blank" rel="noopener">CryptoZombies - 编游戏的同时学习以太坊的智能协议. Loom Network 产品。</a></li><li><a href="https://remix.ethereum.org/" target="_blank" rel="noopener">remix</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 加密货币 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcode 902. 最大为 N 的数字组合</title>
      <link href="/blog/2022/11/29/leetcode%20902.%20%E6%9C%80%E5%A4%A7%E4%B8%BA%20N%20%E7%9A%84%E6%95%B0%E5%AD%97%E7%BB%84%E5%90%88/"/>
      <url>/blog/2022/11/29/leetcode%20902.%20%E6%9C%80%E5%A4%A7%E4%B8%BA%20N%20%E7%9A%84%E6%95%B0%E5%AD%97%E7%BB%84%E5%90%88/</url>
      
        <content type="html"><![CDATA[<p>这题是数位 dp 类型的题，遍历对象有两个：</p><ol><li>遍历 N 的每一位</li><li>遍历 digits</li></ol><p>问题规模是 N 的位数。</p><p>状态转移方程是这样思考得出：</p><p>在遍历 digits 时，设当前 digits 的值为 digits[i]：</p><ol><li>如果 digits[i]比 N 的第 j 位的数字小，则低位的数字就可以任意，那么由 digits[i]开头所产生的组合数是：<code>digits.length**(j-1)</code>。</li><li>如果 digits[i]等于 N 的第 j 位数字，则还要继续对比第 j-1 位才知道能否凑出一个比 N 小的，也即递归，缩小问题规模。产生组合：dp[j-1]</li><li>如果 digits[i]大于 N 的第 j 位数字，则后面低位的数字不管是什么，都已经不能产生小于 N 的组合了。产生组合：0</li></ol><p>把每个 digits[i]对应的结果加起来，就是当前问题规模（问题规模为：j）的答案。</p><p>状态转移方程：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (digits[i] &lt; N[j]) &#123;</span><br><span class="line">  dp[j] += digits.length ** (j - <span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (digits[i] == N[j]) &#123;</span><br><span class="line">  dp[j] += dp[j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">atMostNGivenDigitSet</span>(<span class="params">digits: string[], n: number</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> nStr = n.toString();</span><br><span class="line">  <span class="keyword">const</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(nStr.length).fill(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> memo = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>, res = <span class="number">1</span>; i &lt; nStr.length; i++) &#123;</span><br><span class="line">    memo.push((res = res * digits.length));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; nStr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; digits.length; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (digits[j] &lt; nStr[nStr.length - <span class="number">1</span> - i]) &#123;</span><br><span class="line">        dp[i] += i &gt; <span class="number">0</span> ? memo[i - <span class="number">1</span>] : <span class="number">1</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (digits[j] == nStr[nStr.length - <span class="number">1</span> - i]) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(digits[j], nStr[nStr.length - <span class="number">1</span> - i], dp);</span><br><span class="line">        dp[i] += i &gt; <span class="number">0</span> ? dp[i - <span class="number">1</span>] : <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> memo.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b, <span class="number">0</span>) + dp[dp.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>vue.js响应系统的实现 第一篇</title>
      <link href="/blog/2022/11/06/vue.js%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9E%E7%8E%B0%20%E7%AC%AC%E4%B8%80%E7%AF%87/"/>
      <url>/blog/2022/11/06/vue.js%E5%93%8D%E5%BA%94%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AE%9E%E7%8E%B0%20%E7%AC%AC%E4%B8%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是副作用函数？"><a href="#什么是副作用函数？" class="headerlink" title="什么是副作用函数？"></a>什么是副作用函数？</h2><p>如果一个函数只是接收输入，然后输出，没有影响外部（比如修改外部变量），那么我们就说这个函数没有副作用，反之就是有副作用。理想的情况下，我们希望所有的函数都很纯粹，没有副作用。</p><p>举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">effect</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.body.innerText = <span class="string">"hello vue3"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h2><p>我们都知道 vue.js 这类框架是声明式的，当数据发生变化，它可以监听到并重新渲染，那么这种响应系统是如何实现的呢？首先一个问题就是怎么监听到数据的变化。答案是 Proxy，vue2 用了<code>Object.defineProperty()</code>函数，这是 es2015 之前的做法，vue3 则是用了 es2015 带来的新特性：<code>Proxy</code>。</p><p>通过 Proxy 我们可以监听到数据的变化（set），那就可以调用副作用函数更新 dom 了。</p><p>最简单的响应系统设计如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">effect</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.body.innerText = data.text;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">text</span>: <span class="string">"hello vue3"</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(data, &#123;</span><br><span class="line">  <span class="keyword">get</span>(target, key) &#123;</span><br><span class="line">    <span class="keyword">return</span> target[key];</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>(target, key, value) &#123;</span><br><span class="line">    target[key] = value;</span><br><span class="line">    effect(target);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 首次渲染</span></span><br><span class="line">effect(data);</span><br><span class="line"><span class="comment">// set操作，触发重新渲染</span></span><br><span class="line">obj.text = <span class="string">"11"</span>; <span class="comment">// 这里必须要修改obj对象（改data是监听不到的）</span></span><br></pre></td></tr></table></figure><p>下面开始，都是需求变化产生的代码变化了。</p><ol><li>如果有多个副作用函数需要注册，怎么办？</li><li>如果这些多个副作用函数，监听的是这个对象的不同 key，怎么办？</li><li>如果这些多个副作用函数，监听的是多个对象的不同 key，怎么办？</li><li>分支切换</li></ol><h2 id="如果有多个副作用函数需要注册，怎么办？"><a href="#如果有多个副作用函数需要注册，怎么办？" class="headerlink" title="如果有多个副作用函数需要注册，怎么办？"></a>如果有多个副作用函数需要注册，怎么办？</h2><p>代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">effect1</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.body.innerText = data.text;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">effect2</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.body.setAttribute(data.text);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">text</span>: <span class="string">"hello vue3"</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(data, &#123;</span><br><span class="line">  <span class="keyword">get</span>(target, key) &#123;</span><br><span class="line">    <span class="keyword">return</span> target[key];</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>(target, key, value) &#123;</span><br><span class="line">    target[key] = value;</span><br><span class="line">    effect1(target);</span><br><span class="line">    effect2(target);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 首次渲染</span></span><br><span class="line">effect1(obj);</span><br><span class="line">effect2(obj);</span><br><span class="line"><span class="comment">// set操作，触发重新渲染</span></span><br><span class="line">obj.text = <span class="string">"11"</span>; <span class="comment">// 这里必须要修改obj对象（改data是监听不到的）</span></span><br></pre></td></tr></table></figure><p>这样写，显然很不灵活（因为要去修改已经写好的代码），那么怎么设计才能不去动已经写好的代码呢？答案是传回调函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bucket = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useEffect</span>(<span class="params">fn, data</span>) </span>&#123;</span><br><span class="line">  bucket.add(fn);</span><br><span class="line">  <span class="keyword">return</span> fn(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">text</span>: <span class="string">"hello vue3"</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(data, &#123;</span><br><span class="line">  <span class="keyword">get</span>(target, key) &#123;</span><br><span class="line">    <span class="keyword">return</span> target[key];</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>(target, key, value) &#123;</span><br><span class="line">    target[key] = value;</span><br><span class="line">    bucket.forEach(<span class="function">(<span class="params">fn</span>) =&gt;</span> fn(target));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 首次渲染</span></span><br><span class="line">useEffect(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">document</span>.body.innerText = data.text;</span><br><span class="line">&#125;, data);</span><br><span class="line">useEffect(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">document</span>.body.setAttribute(<span class="string">"a"</span>, data.text);</span><br><span class="line">&#125;, data);</span><br><span class="line"><span class="comment">// set操作，触发重新渲染</span></span><br><span class="line">obj.text = <span class="string">"11"</span>; <span class="comment">// 这里必须要修改obj对象（改data是监听不到的）</span></span><br></pre></td></tr></table></figure><p>这样的写法，是不是很像 react 的 useEffect()了。</p><h2 id="如果这些多个副作用函数，监听的是这个对象的不同-key，怎么办？"><a href="#如果这些多个副作用函数，监听的是这个对象的不同-key，怎么办？" class="headerlink" title="如果这些多个副作用函数，监听的是这个对象的不同 key，怎么办？"></a>如果这些多个副作用函数，监听的是这个对象的不同 key，怎么办？</h2><p>用个 Map，让 key 和回调函数一一对应即可，但如何知道副作用函数用了哪个 key 呢？如果是在 useEffect 里面显然是不知道的，但用没用 key，用了哪个 key，Proxy 里面的 get 拦截函数是一清二楚的，所以我们应该在这里添加副作用函数！但 get 拦截函数里面又不知道，当前获取数据的函数是哪个，很简单，我们设置一个 activeEffect 来记录当前的函数。但需要注意的是，一但我们开始在 get 里面注册响应，每次调用副作用函数就会调用注册响应，这个时候需要更新 activeEffect。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> activeEffect;</span><br><span class="line"><span class="keyword">const</span> bucket = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useEffect</span>(<span class="params">fn, data</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">effectFn</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    activeEffect = effectFn;</span><br><span class="line">    <span class="keyword">return</span> fn(data);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> effectFn(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">text</span>: <span class="string">"hello vue3"</span>, <span class="attr">a</span>: <span class="string">"11"</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(data, &#123;</span><br><span class="line">  <span class="keyword">get</span>(target, key) &#123;</span><br><span class="line">    <span class="keyword">if</span> (activeEffect) &#123;</span><br><span class="line">      <span class="keyword">const</span> effects = bucket.get(key);</span><br><span class="line">      <span class="keyword">if</span> (!effects) &#123;</span><br><span class="line">        bucket.set(key, <span class="keyword">new</span> <span class="built_in">Set</span>([activeEffect]));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        effects.add(activeEffect);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target[key];</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>(target, key, value) &#123;</span><br><span class="line">    target[key] = value;</span><br><span class="line">    <span class="keyword">const</span> effects = bucket.get(key);</span><br><span class="line">    effects &amp;&amp; effects.forEach(<span class="function">(<span class="params">fn</span>) =&gt;</span> fn(target));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 首次渲染</span></span><br><span class="line">useEffect(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">document</span>.body.innerText = data.text;</span><br><span class="line">&#125;, obj); <span class="comment">// 这里也要传obj了，不然get的时候，也是监听不到的</span></span><br><span class="line">useEffect(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">document</span>.body.setAttribute(<span class="string">"a"</span>, data.a);</span><br><span class="line">&#125;, obj);</span><br><span class="line"><span class="comment">// set操作，触发重新渲染</span></span><br><span class="line">obj.text = <span class="string">"hello aaaa"</span>; <span class="comment">// 这里必须要修改obj对象（改data是监听不到的）</span></span><br><span class="line">obj.a = <span class="string">"222"</span>;</span><br></pre></td></tr></table></figure><p>这样就实现了对单个对象的多个不同 key 注册多个副作用函数，进行响应式渲染。</p><p>而且，我们可以把其中处理副作用函数的逻辑抽出来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> activeEffect;</span><br><span class="line"><span class="keyword">const</span> bucket = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useEffect</span>(<span class="params">fn, data</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">effectFn</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    activeEffect = effectFn;</span><br><span class="line">    <span class="keyword">return</span> fn(data);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> effectFn(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">text</span>: <span class="string">"hello vue3"</span>, <span class="attr">a</span>: <span class="string">"11"</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(data, &#123;</span><br><span class="line">  <span class="keyword">get</span>(target, key) &#123;</span><br><span class="line">    track(key);</span><br><span class="line">    <span class="keyword">return</span> target[key];</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>(target, key, value) &#123;</span><br><span class="line">    target[key] = value;</span><br><span class="line">    trigger(target, key);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">track</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (activeEffect) &#123;</span><br><span class="line">    <span class="keyword">const</span> effects = bucket.get(key);</span><br><span class="line">    <span class="keyword">if</span> (!effects) &#123;</span><br><span class="line">      bucket.set(key, <span class="keyword">new</span> <span class="built_in">Set</span>([activeEffect]));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      effects.add(activeEffect);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trigger</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> effects = bucket.get(key);</span><br><span class="line">  effects &amp;&amp; effects.forEach(<span class="function">(<span class="params">fn</span>) =&gt;</span> fn(target));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 首次渲染</span></span><br><span class="line">useEffect(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">document</span>.body.innerText = data.text;</span><br><span class="line">&#125;, obj);</span><br><span class="line">useEffect(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">document</span>.body.setAttribute(<span class="string">"a"</span>, data.a);</span><br><span class="line">&#125;, obj);</span><br><span class="line"><span class="comment">// set操作，触发重新渲染</span></span><br><span class="line">obj.text = <span class="string">"hello aaaa"</span>;</span><br><span class="line">obj.a = <span class="string">"222"</span>;</span><br></pre></td></tr></table></figure><h2 id="如果这些多个副作用函数，监听的是多个对象的不同-key，怎么办？"><a href="#如果这些多个副作用函数，监听的是多个对象的不同-key，怎么办？" class="headerlink" title="如果这些多个副作用函数，监听的是多个对象的不同 key，怎么办？"></a>如果这些多个副作用函数，监听的是多个对象的不同 key，怎么办？</h2><p>再加一个 Map 即可，而且由于键是个对象，最好用 WeakMap：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> activeEffect;</span><br><span class="line"><span class="keyword">const</span> bucket = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useEffect</span>(<span class="params">fn, data</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">effectFn</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    activeEffect = effectFn;</span><br><span class="line">    <span class="keyword">return</span> fn(data);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> effectFn(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> data1 = &#123; <span class="attr">text</span>: <span class="string">"hello vue3"</span>, <span class="attr">a</span>: <span class="string">"11"</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> data2 = &#123; <span class="attr">text2</span>: <span class="string">"hello vue2"</span>, <span class="attr">b</span>: <span class="string">"22"</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> obj1 = createProxyObj(data1);</span><br><span class="line"><span class="keyword">const</span> obj2 = createProxyObj(data2);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createProxyObj</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(data, &#123;</span><br><span class="line">    <span class="keyword">get</span>(target, key) &#123;</span><br><span class="line">      track(target, key);</span><br><span class="line">      <span class="keyword">return</span> target[key];</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(target, key, value) &#123;</span><br><span class="line">      target[key] = value;</span><br><span class="line">      trigger(target, key);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">track</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (activeEffect) &#123;</span><br><span class="line">    <span class="keyword">let</span> effectsOnTarget = bucket.get(target);</span><br><span class="line">    <span class="keyword">if</span> (!effectsOnTarget) &#123;</span><br><span class="line">      bucket.set(target, (effectsOnTarget = <span class="keyword">new</span> <span class="built_in">Map</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> effects = effectsOnTarget.get(key);</span><br><span class="line">    <span class="keyword">if</span> (!effects) &#123;</span><br><span class="line">      effectsOnTarget.set(key, (effects = <span class="keyword">new</span> <span class="built_in">Set</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    effects.add(activeEffect);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trigger</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> effectsOnTarget = bucket.get(target);</span><br><span class="line">  <span class="keyword">if</span> (effectsOnTarget) &#123;</span><br><span class="line">    <span class="keyword">const</span> effects = effectsOnTarget.get(key);</span><br><span class="line">    effects &amp;&amp; effects.forEach(<span class="function">(<span class="params">fn</span>) =&gt;</span> fn(target));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 首次渲染</span></span><br><span class="line">useEffect(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">document</span>.body.innerText = data.text;</span><br><span class="line">&#125;, obj1);</span><br><span class="line">useEffect(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">document</span>.body.setAttribute(<span class="string">"b"</span>, data.b);</span><br><span class="line">&#125;, obj2);</span><br><span class="line"><span class="comment">// set操作，触发重新渲染</span></span><br><span class="line">obj1.text = <span class="string">"hello aaaa"</span>;</span><br><span class="line">obj2.b = <span class="string">"333"</span>;</span><br></pre></td></tr></table></figure><h2 id="分支切换"><a href="#分支切换" class="headerlink" title="分支切换"></a>分支切换</h2><p>目前来说：</p><ol><li>首次执行副作用函数会触发 get，get 会把副作用函数添加为响应函数。</li><li>然后更新值的时候会触发 set，set 会执行响应函数，执行响应函数又会触发 get，get 会把副作用函数添加为响应函数。</li></ol><p>也就是说每次更新值都会重新添加响应函数，似乎很冗余，能否只执行一次呢？答案是不能，因为可能存在分支，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">ok</span>: <span class="literal">true</span>, <span class="attr">text</span>: <span class="string">"hello world"</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(data, &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">useEffect(<span class="function"><span class="keyword">function</span> <span class="title">effectFn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">document</span>.body.innerText = obj.ok ? obj.text : <span class="string">"not"</span>;</span><br><span class="line">&#125;, obj);</span><br></pre></td></tr></table></figure><p>当 obj.ok 为 true 的时候，obj.text 的响应函数会记录下副作用函数，但如果 obj.ok 为 false 的时候，修改 obj.text 其实不用执行副作用函数了，但由于之前添加过，所以还是会执行。</p><p>所以我们不仅要重新添加响应函数，还需要清理之前添加的。这样每次添加的响应函数才会是准确无误的。</p><p>为了清理响应函数，比较粗暴一点的是遍历 bucket 中的每个 target 的每个 key，然后对其 set 集合执行 delete()方法，但这样显然不太好，我们可以记录一下哪些集合存了当前副作用函数，只对这些集合执行 delete()方法。</p><p>代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useEffect</span>(<span class="params">fn, data</span>) </span>&#123;</span><br><span class="line">  effectFn.records = [];</span><br><span class="line">  <span class="keyword">return</span> effectFn(data);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">effectFn</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    cleanup(effectFn);</span><br><span class="line">    activeEffect = effectFn;</span><br><span class="line">    <span class="keyword">return</span> fn(data);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">cleanup</span>(<span class="params">effectFn</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; effectFn.records.length; i++) &#123;</span><br><span class="line">        effectFn.records[i].delete(fn);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">track</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (activeEffect) &#123;</span><br><span class="line">    <span class="keyword">let</span> effectsOnTarget = bucket.get(target);</span><br><span class="line">    <span class="keyword">if</span> (!effectsOnTarget) &#123;</span><br><span class="line">      bucket.set(target, (effectsOnTarget = <span class="keyword">new</span> <span class="built_in">Map</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> effects = effectsOnTarget.get(key);</span><br><span class="line">    <span class="keyword">if</span> (!effects) &#123;</span><br><span class="line">      effectsOnTarget.set(key, (effects = <span class="keyword">new</span> <span class="built_in">Set</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    effects.add(activeEffect);</span><br><span class="line">    activeEffect.records.push(effects); <span class="comment">// 新增</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们改写了 useEffect，增加了一个 records 来记录需要清理哪些集合，在每次重新添加响应之前，清理掉旧的响应。并在 track 函数里面对这个 records 进行填充。</p><p>但还存在一个问题，这个问题比较隐秘，那就是遍历的时候对遍历对象进行 add 和 delete 操作，trigger 中我们执行响应函数，响应函数会对桶先 cleanup 再重新添加，但这个时候我们还在遍历桶啊，所以就相当于这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">set</span> = new Set([1]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>.forEach((item) =&gt; &#123;</span><br><span class="line">  <span class="keyword">set</span>.delete(1);</span><br><span class="line">  <span class="keyword">set</span>.add(1);</span><br><span class="line">  console.log("遍历中");</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这会造成死循环，解决的办法，自然是不对遍历的对象增删，新搞个对象进行增删。修改后的代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trigger</span>(<span class="params">target, key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> effectsOnTarget = bucket.get(target);</span><br><span class="line">  <span class="keyword">if</span> (effectsOnTarget) &#123;</span><br><span class="line">    <span class="keyword">const</span> effects = effectsOnTarget.get(key);</span><br><span class="line">    effects &amp;&amp; [...effects].forEach(<span class="function">(<span class="params">fn</span>) =&gt;</span> fn(target)); <span class="comment">// 修改，不对原集合进行一边遍历一边增删</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript执行上下文之作用域链</title>
      <link href="/blog/2022/07/14/JavaScript%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/"/>
      <url>/blog/2022/07/14/JavaScript%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B9%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<p>执行上下文中有个作用域链，当查找一个变量时会顺着这个链找。</p><p>函数的作用域在函数定义的时候就决定了。这是因为函数对象有个内部属性<code>[[scope]]</code></p><p>函数的生命周期分为：<strong>函数创建</strong> 和 <strong>函数调用</strong>。</p><p>函数创建的时候，会把其所处执行上下文的作用域链直接赋值给函数的内部属性<code>[[scope]]</code>（这就是词法作用域的原理了），函数调用的时候会创建自己的执行上下文，并把自己的<code>AO</code>和<code>[[scope]]</code>合并成新的作用域链：</p><blockquote><p>假设要实现动态作用域的话，<code>[[scope]]</code>就得在调用时去执行上下文栈的上一帧去取。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Scope = [AO].concat([[scope]]);</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="实例剖析"><a href="#实例剖析" class="headerlink" title="实例剖析"></a>实例剖析</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> scope2 = <span class="string">"local scope"</span>;</span><br><span class="line">  <span class="keyword">return</span> scope2;</span><br><span class="line">&#125;</span><br><span class="line">checkscope();</span><br></pre></td></tr></table></figure><p>执行过程如下：</p><ol><li>全局执行上下文创建，其作用域链就只有自身的 VO，然后将全局上下文压栈：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ECStack = [];</span><br><span class="line">globalContext = &#123;</span><br><span class="line">  VO,</span><br><span class="line">  Scope: [VO],</span><br><span class="line">  <span class="keyword">this</span>: <span class="built_in">window</span>,</span><br><span class="line">&#125;;</span><br><span class="line">ECStack.push(globalContext);</span><br></pre></td></tr></table></figure><ol start="2"><li>checkscope 函数被创建，保存当前执行上下文的作用域链到 checkscope 函数的内部属性<code>[[scope]]</code>（这一步是词法作用域实现的关键）</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">checkscope.[[scope]] = globalContext.Scope;</span><br></pre></td></tr></table></figure><ol start="4"><li>调用 checkscope 函数，函数并不立刻执行，开始做准备工作，生成执行上下文，并压入执行上下文栈：</li></ol><ul><li>AO：用 arguments 创建活动对象，随后初始化活动对象，加入形参、函数声明、变量声明</li><li>Scope：复制函数<code>[[scope]]</code>属性创建作用域链，将活动对象压入 checkscope 作用域链顶端</li><li>this</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">  AO: &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">      length: <span class="number">0</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    scope2: <span class="literal">undefined</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  Scope: [AO, [[Scope]]],</span><br><span class="line">&#125;;</span><br><span class="line">ECStack.push(checkscopeContext);</span><br></pre></td></tr></table></figure><ol start="5"><li>准备工作做完，开始执行函数，随着函数的执行，修改 AO 的属性值，查找到 scope2 的值，返回后函数执行完毕，函数上下文从执行上下文栈中弹出</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">checkscopeContext = &#123;</span><br><span class="line">  AO: &#123;</span><br><span class="line">    <span class="built_in">arguments</span>: &#123;</span><br><span class="line">      length: <span class="number">0</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    scope2: <span class="string">"local scope"</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  Scope: [AO, [[Scope]]],</span><br><span class="line">&#125;;</span><br><span class="line">ECStack.pop();</span><br></pre></td></tr></table></figure><p>每一步中具体的实现细节我们无法得知（因为可以有多种实现手法），但这 5 步却是真实存在的（因为可以通过例子验证）。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 闭包</title>
      <link href="/blog/2022/07/14/JavaScript%E9%97%AD%E5%8C%85/"/>
      <url>/blog/2022/07/14/JavaScript%E9%97%AD%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h1 id="闭包是干什么用的"><a href="#闭包是干什么用的" class="headerlink" title="闭包是干什么用的"></a>闭包是干什么用的</h1><p>本质上闭包就是为了拓展查找自由变量的范围</p><p>MDN 对闭包的定义为：</p><p>A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment)</p><p>一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'Mozilla'</span>; <span class="comment">// name is a local variable created by init</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">displayName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// displayName() is the inner function, a closure</span></span><br><span class="line">    <span class="built_in">console</span>.log(name); <span class="comment">// use variable declared in the parent function</span></span><br><span class="line">  &#125;</span><br><span class="line">  displayName();</span><br><span class="line">&#125;</span><br><span class="line">init();</span><br></pre></td></tr></table></figure><p>name 是 displayName 函数所处环境中的变量，它们一起构成了闭包。而闭包的实现依赖于执行上下文中的作用域链。</p><p>上面这个例子有点平平无奇了，让我们看一个神奇一点的例子：</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = checkscope();</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>这里直接给出简要的执行过程：</p><ol><li>进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈</li><li>全局执行上下文初始化</li><li>执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈</li><li>checkscope 执行上下文初始化，创建变量对象、作用域链、this 等</li><li>checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出</li><li>执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈</li><li>f 执行上下文初始化，创建变量对象、作用域链、this 等</li><li>f 函数执行完毕，f 函数上下文从执行上下文栈中弹出</li></ol><p>了解到这个过程，我们应该思考一个问题，那就是：</p><p>当 f 函数执行的时候，checkscope 函数上下文已经被销毁了啊(即从执行上下文栈中被弹出)，怎么还会读取到 checkscope 作用域下的 scope 值呢？</p><p>以上的代码，要是转换成 PHP，就会报错，因为在 PHP 中，f 函数只能读取到自己作用域和全局作用域里的值，所以读不到 checkscope 下的 scope 值。</p><p>然而 JavaScript 却是可以的！</p><p>当我们了解了具体的执行过程后，我们知道 f 执行上下文维护了一个作用域链：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fContext = &#123;</span><br><span class="line">  Scope: [AO, checkscopeContext.AO, globalContext.VO],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对的，就是因为这个作用域链，f 函数依然可以读取到 checkscopeContext.AO 的值，说明当 f 函数引用了 checkscopeContext.AO 中的值的时候，即使 checkscopeContext 被销毁了，但是 JavaScript 依然会让 checkscopeContext.AO 活在内存中（因为还有别的引用在，所以不会进行垃圾回收），f 函数依然可以通过 f 函数的作用域链找到它，正是因为 JavaScript 做到了这一点，从而实现了闭包这个概念。</p><p>所以，让我们再看一遍实践角度上闭包的定义：</p><ul><li>即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）</li><li>在代码中引用了自由变量</li></ul><p>在这里再补充一个《JavaScript 权威指南》英文原版对闭包的定义:</p><blockquote><p>This combination of a function object and a scope (a set of variable bindings) in which the function’s variables are resolved is called a closure in the computer science literature.</p></blockquote><p>闭包在计算机科学中也只是一个普通的概念，大家不要去想得太复杂。</p><h1 id="经典面试题"><a href="#经典面试题" class="headerlink" title="经典面试题"></a>经典面试题</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  data[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[<span class="number">0</span>]();</span><br><span class="line">data[<span class="number">1</span>]();</span><br><span class="line">data[<span class="number">2</span>]();</span><br></pre></td></tr></table></figure><p>答案是全是 3，因为这里的 i 是直接从全局上下文中读取到的，让我们多加一层闭包：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = [];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  data[i] = (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data[<span class="number">0</span>]();</span><br><span class="line">data[<span class="number">1</span>]();</span><br><span class="line">data[<span class="number">2</span>]();</span><br></pre></td></tr></table></figure><p>这里写了个立即执行函数，由它创建了一个闭包：立即执行函数的 AO + 内层函数，这个闭包中有个自由变量 i，来自这个立即执行函数的形参，形参在每次立即执行后会被分别赋值 0,1,2。而内层函数被返回给这个 data 数组，当内层函数执行时，顺着作用域链查找 i，会先从立即执行函数的 AO 中读取到 i，就会分别读取到 0,1,2。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://github.com/mqyqingfeng/Blog/issues/9" target="_blank" rel="noopener">JavaScript 深入之闭包</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures" target="_blank" rel="noopener">闭包 - mdn</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript执行上下文之变量对象</title>
      <link href="/blog/2022/07/13/JavaScript%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B9%8B%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/"/>
      <url>/blog/2022/07/13/JavaScript%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E4%B9%8B%E5%8F%98%E9%87%8F%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="执行上下文中包含哪些东西"><a href="#执行上下文中包含哪些东西" class="headerlink" title="执行上下文中包含哪些东西"></a>执行上下文中包含哪些东西</h1><p>对于每个执行上下文，都有三个重要属性：</p><ul><li>变量对象(Variable object，VO)</li><li>作用域链(Scope chain)</li><li>this</li></ul><p>本篇就来讲讲第一个变量对象</p><a id="more"></a><h1 id="全局上下文"><a href="#全局上下文" class="headerlink" title="全局上下文"></a>全局上下文</h1><ul><li>在顶层 JavaScript 代码中，可以用关键字 this 引用全局对象。因为全局对象是作用域链的头，这意味着<strong>所有非限定性的变量和函数名都会作为该对象的属性来查询</strong>。</li><li>例如，当 JavaScript 代码引用 parseInt() 函数时，它引用的是全局对象的 parseInt 属性。全局对象是作用域链的头，还意味着在顶层 JavaScript 代码中<strong>声明的所有变量都将成为全局对象的属性</strong>。</li><li>在浏览器中，全局对象有 window 指向自身</li></ul><p>也就是说在全局执行上下文中，所有未限定的变量都挂在全局对象上，从全局对象中读写。比如:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.window.a);</span><br><span class="line"><span class="comment">// 但是不能写</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.this.a);</span><br></pre></td></tr></table></figure><h1 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h1><p>JavaScript 代码在进入一段代码环境时，会分为两个阶段：</p><ol><li>代码分析（进入执行上下文）</li><li>代码执行</li></ol><h2 id="进入执行上下文"><a href="#进入执行上下文" class="headerlink" title="进入执行上下文"></a>进入执行上下文</h2><p>当进入执行上下文时，这时候还没有执行代码，</p><p>变量对象会包括三类：</p><ol><li>函数的所有形参 (如果是函数上下文)<ul><li>由名称和对应值组成的一个变量对象的属性被创建</li><li>没有实参，属性值设为 undefined</li></ul></li><li>函数声明<ul><li>由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建</li><li>如果变量对象已经存在相同名称的属性，则完全替换这个属性</li></ul></li><li>变量声明<ul><li>由名称和对应值（undefined）组成一个变量对象的属性被创建</li><li>如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性</li></ul></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> d = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  b = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>在进入执行上下文后，这时候的 AO 是：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    arguments: &#123;</span><br><span class="line">        0: 1,</span><br><span class="line">        length: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    a: 1,</span><br><span class="line">    b: undefined,</span><br><span class="line">    c: reference to function c()&#123;&#125;,</span><br><span class="line">    d: undefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h2><p>还是上面的例子，当代码执行完后，这时候的 AO 是：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    arguments: &#123;</span><br><span class="line">        0: 1,</span><br><span class="line">        length: 1</span><br><span class="line">    &#125;,</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 3,</span><br><span class="line">    c: reference to function c()&#123;&#125;,</span><br><span class="line">    d: reference to FunctionExpression "d"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    a = <span class="number">1</span>;  <span class="comment">// 相当于挂在全局对象上</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// ???</span></span><br></pre></td></tr></table></figure><p>会报错，<code>Uncaught ReferenceError: a is not defined</code></p><p>这是因为函数中的 &quot;a&quot; 并没有通过 var 关键字声明，所有不会被存放在 AO 中。</p><p>第一段执行 console 的时候， AO 的值是：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">    arguments: &#123;</span><br><span class="line">        length: 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有 a 的值，然后就会到全局去找，全局也没有，所以会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// ???</span></span><br></pre></td></tr></table></figure><p>改成这样，有变量提升就不会报错了。打印 undefined</p><p>或者先挂在全局对象上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line">bar(); <span class="comment">// ???</span></span><br></pre></td></tr></table></figure><p>打印 1</p><h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(foo);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>会打印函数，而不是 undefined 。</p><p>这是因为在进入执行上下文时，首先会处理函数声明，其次会处理变量声明，如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://github.com/mqyqingfeng/Blog/issues/5" target="_blank" rel="noopener">JavaScript 深入之变量对象</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript执行上下文栈</title>
      <link href="/blog/2022/07/12/JavaScript%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88/"/>
      <url>/blog/2022/07/12/JavaScript%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="顺序执行？"><a href="#顺序执行？" class="headerlink" title="顺序执行？"></a>顺序执行？</h1><p>代码示例 1：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'foo1'</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();  <span class="comment">// foo1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'foo2'</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// foo2</span></span><br></pre></td></tr></table></figure><p>代码示例 2：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'foo1'</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo();  <span class="comment">// foo2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'foo2'</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(); <span class="comment">// foo2</span></span><br></pre></td></tr></table></figure><p>第一个例子中用到了变量提升，第二个例子中用到了函数提升。JavaScript 引擎并非一行一行地分析和执行程序，而是一段一段地分析执行。当执行一段代码的时候，会进行一个“准备工作”。到底 JavaScript 引擎遇到一段怎样的代码时才会做“准备工作”呢？</p><a id="more"></a><h1 id="可执行代码"><a href="#可执行代码" class="headerlink" title="可执行代码"></a>可执行代码</h1><p>JavaScript 总共有三种可执行的代码：</p><ul><li>全局代码</li><li>函数代码</li><li>eval 代码</li></ul><h1 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h1><p>JavaScript 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f();</span><br><span class="line">&#125;</span><br><span class="line">checkscope();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line">checkscope()();</span><br></pre></td></tr></table></figure><p>上面这个例子中，执行上下文栈的变化就不一样</p><p>让我们模拟第一段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ECStack.push(&lt;checkscope&gt; functionContext);</span><br><span class="line">ECStack.push(&lt;f&gt; functionContext);</span><br><span class="line">ECStack.pop();</span><br><span class="line">ECStack.pop();</span><br></pre></td></tr></table></figure><p>让我们模拟第二段代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ECStack.push(&lt;checkscope&gt; functionContext);</span><br><span class="line">ECStack.pop();</span><br><span class="line">ECStack.push(&lt;f&gt; functionContext);</span><br><span class="line">ECStack.pop();</span><br></pre></td></tr></table></figure><h1 id="执行上下文中包含哪些东西"><a href="#执行上下文中包含哪些东西" class="headerlink" title="执行上下文中包含哪些东西"></a>执行上下文中包含哪些东西</h1><p>对于每个执行上下文，都有三个重要属性：</p><ul><li>变量对象(Variable object，VO)</li><li>作用域链(Scope chain)</li><li>this</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://github.com/mqyqingfeng/Blog/issues/4" target="_blank" rel="noopener">JavaScript 深入之执行上下文栈</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript词法作用域</title>
      <link href="/blog/2022/07/11/JavaScript%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
      <url>/blog/2022/07/11/JavaScript%E8%AF%8D%E6%B3%95%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<p>有两种作用域：</p><ul><li>动态作用域</li><li>静态作用域（也叫：词法作用域，lexical scoping）</li></ul><p>JavaScript 采用的是词法作用域</p><a id="more"></a><h1 id="什么是作用域"><a href="#什么是作用域" class="headerlink" title="什么是作用域"></a>什么是作用域</h1><p>作用域，顾名思义是用来表示一个变量作用的范围。</p><h1 id="这两种作用域的区别是什么"><a href="#这两种作用域的区别是什么" class="headerlink" title="这两种作用域的区别是什么"></a>这两种作用域的区别是什么</h1><p>让我们看一个例子就能知道：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line">    foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果是 ???</span></span><br></pre></td></tr></table></figure><p>如果是静态作用域，那么答案是 1，因为 value 这个变量在函数定义的时候就已经决定了。如果是动态作用域，那么答案是 2，value 这个变量要等函数执行的时候才定下来。</p><h2 id="静态作用域执行过程"><a href="#静态作用域执行过程" class="headerlink" title="静态作用域执行过程"></a>静态作用域执行过程</h2><p>执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据书写的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。而且如果去掉<code>var value = 1;</code>这一句，会报变量未定义错误。</p><h2 id="动态作用域执行过程"><a href="#动态作用域执行过程" class="headerlink" title="动态作用域执行过程"></a>动态作用域执行过程</h2><p>执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2。</p><p>前面我们已经说了，JavaScript 采用的是静态作用域，所以这个例子的结果是 1。</p><p>bash 脚本采用的是动态作用域:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">value=1</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">foo</span></span> () &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="variable">$value</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">bar</span></span> () &#123;</span><br><span class="line">    <span class="built_in">local</span> value=2;</span><br><span class="line">    foo;</span><br><span class="line">&#125;</span><br><span class="line">bar</span><br></pre></td></tr></table></figure><p>这个例子会打印 2</p><h1 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f();</span><br><span class="line">&#125;</span><br><span class="line">checkscope();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line">checkscope()();</span><br></pre></td></tr></table></figure><p>这两个例子中，虽然函数执行的环境不一样，但打印的结果是一样的，因为还是那个原因，JavaScript 的作用域是静态作用域</p><h1 id="引用犀牛书中的一段话"><a href="#引用犀牛书中的一段话" class="headerlink" title="引用犀牛书中的一段话"></a>引用犀牛书中的一段话</h1><blockquote><p>Like most modern programming languages, JavaScript uses lexical scoping. This means that functions are executed using the variable scope that was in effect when they were defined, not the variable scope that is in effect when they are invoked. In order to implement lexical scoping, the internal state of a JavaScript function object must in- clude not only the code of the function but also a reference to the current scope chain. (Before reading the rest of this section, you may want to review the material on variable scope and the scope chain in §3.10 and §3.10.3.) This combination of a function object and a scope (a set of variable bindings) in which the function’s variables are resolved is called a closure in the computer science literature. (This is an old term that refers to the fact that the function’s variables have bindings in the scope chain and that therefore the function is “closed over” its variables.)</p></blockquote><blockquote><p>Technically, all JavaScript functions are closures: they are objects, and they have a scope chain associated with them. Most functions are invoked using the same scope chain that was in effect when the function was defined, and it doesn’t really matter that there is a closure involved. Closures become interesting when they are invoked under a different scope chain than the one that was in effect when they were defined. This happens most commonly when a nested function object is returned from the function within which it was defined. There are a number of powerful programming techniques that involve this kind of nested function closures, and their use has become relatively common in JavaScript programming. Closures may seem confusing when you first en- counter them, but it is important that you understand them well enough to use them comfortably.</p></blockquote><blockquote><p>JavaScript, The Definite Guide</p></blockquote><h1 id="JavaScript-是如何实现这种词法作用域的"><a href="#JavaScript-是如何实现这种词法作用域的" class="headerlink" title="JavaScript 是如何实现这种词法作用域的"></a>JavaScript 是如何实现这种词法作用域的</h1><p>想要了解这种词法作用域是如何实现的，就要了解 JavaScript 的执行上下文栈，具体请看这篇文章：<a href="../../../07/12/JavaScript执行上下文栈/index.html">JavaScript 执行上下文栈</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://github.com/mqyqingfeng/Blog/issues/3" target="_blank" rel="noopener">JavaScript 深入之词法作用域和动态作用域</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript原型和原型链</title>
      <link href="/blog/2022/07/10/JavaScript%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
      <url>/blog/2022/07/10/JavaScript%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="原型链是干什么用的"><a href="#原型链是干什么用的" class="headerlink" title="原型链是干什么用的"></a>原型链是干什么用的</h1><p>JavaScript 采用了原型和原型链来实现类和继承（就是查找属性用的）。</p><p>当 JavaScript 查找一个对象上的属性的时候，在该对象上找不到就会去它的原型链上查找。比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line">Foo.prototype.a = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(foo.a);</span><br></pre></td></tr></table></figure><p>原型和原型链主要由三个指针实现：</p><ul><li><code>prototype</code>: 构造函数的<code>prototype</code>属性指向原型对象</li><li><code>__proto__</code>: 实例对象的<code>__proto__</code>属性指向原型对象</li><li><code>constructor</code>: 原型对象的<code>constructor</code>属性指向构造函数</li><li>所有对象都基于<code>Object</code>，是因为所有原型对象的<code>__proto__</code>最终都指向<code>Object.prototype</code>，而<code>Object.prototype</code>的<code>__proto__</code>为 null</li></ul><a id="more"></a><blockquote><p>JavaScript 只要前面带 new 就是构造函数，箭头函数和异步函数不可以做构造函数，因为箭头函数没有 this，而异步函数返回的是 Promise 对象</p></blockquote><p>当我们在实例对象上查找一个属性的时候，如果不存在，则会递归的去原型链上找。</p><p><img src="http://www.mollypages.org/tutorials/jsobj.jpg" alt="Javascript Object Hierarchy"></p><ul><li>所有对象都有<code>__proto__</code>属性，但只有函数对象才有<code>prototype</code>属性</li><li>实例对象没有<code>constructor</code>属性，该属性继承自原型对象。分别对实例对象和原型对象使用<code>hasOwnProperty</code>验证<code>constructor</code>属性即可证明</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="built_in">console</span>.log(a.hasOwnProperty(<span class="string">'constructor'</span>));   <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(a.__proto__.hasOwnProperty(<span class="string">'constructor'</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://github.com/mqyqingfeng/Blog/issues/2" target="_blank" rel="noopener">JavaScript 深入之从原型到原型链</a></li><li><a href="http://www.mollypages.org/tutorials/js.mp" target="_blank" rel="noopener">Javascript Object Hierarchy</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP和UDP的区别</title>
      <link href="/blog/2022/06/20/TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/blog/2022/06/20/TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>好久没回顾这个知识点了，我现在只记得 TCP 是有链接的，UDP 是无连接的；TCP 是可靠的，UDP 是不可靠的。技术细节已经全然忘光了，今天就来回顾一下。</p><p>先说几个几点结论，然后再说说细节：</p><ul><li>TCP 是有链接的，UDP 是无连接的</li><li>TCP 可靠（无差错，不丢失不重复，按序到达），UDP 不可靠</li><li>TCP 面向字节流，UDP 面向报文</li><li>TCP 是一对一全双工，UDP 是 n 对 n</li><li>TCP 的首部较大为 20 字节，UDP 首部只有 8 字节</li></ul><a id="more"></a><h1 id="TCP-为什么要三次握手四次挥手"><a href="#TCP-为什么要三次握手四次挥手" class="headerlink" title="TCP 为什么要三次握手四次挥手"></a>TCP 为什么要三次握手四次挥手</h1><p>三次握手是因为<strong>双方都要确认对方的发送和接收两种能力</strong>：</p><ol><li>第一次客户端发送 SYN 报文段，服务器接收到了，从服务器的视角看，客户端具备了发送能力。</li><li>第二次服务器端发送 ACK+SYN 报文段，客户端接收到了，从客户端的角度看，服务器具备了接收和发送两种能力。</li><li>第三次客户端接收到了服务器的报文，再发一个 ACK 报文给服务器，服务器接收到这个 ACK 报文就能确认客户端的接受能力正常。</li></ol><p>所以最少需要三次，才能确认双方的收发能力都是正常的。</p><p>四次挥手是因为 TCP 是双工信道，关闭了 A 到 B 的发送渠道，B 到 A 的还没关闭，所以需要四次：</p><ol><li>客户端发送 FIN 报文段给服务器端，服务器收到后发送 ACK 给客户端，客户端收到 ACK 后就会不再发消息。也就是说客户端到服务器端这条信道关闭了。</li><li>服务器发送 FIN 报文段给客户端，客户端收到后发送 ACK 给服务器，服务器收到 ACK 后就不再发消息给客户端了。服务器发送给客户端这条信道就关闭了。</li></ol><p>这里的问题就是为什么服务器不把 ACK 和 FIN 合在一起发，就像三次握手时候那样 ACK+SYN 一起发。因为服务器 → 客户端，客户端 → 服务器这两条信道是互相独立的，<strong>在关闭其中一条的时候，另一条可能还在工作，不应该一起关闭，需要设计成独立关闭</strong>。</p><h1 id="面向报文和面向字节流的区别"><a href="#面向报文和面向字节流的区别" class="headerlink" title="面向报文和面向字节流的区别"></a>面向报文和面向字节流的区别</h1><p>面向报文的传输方式是应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文。因此，应用程序必须选择合适大小的报文。若报文太长，则 IP 层需要分片，降低效率。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。</p><p>面向字节流的话，虽然应用程序和 TCP 的交互是一次一个数据块（大小不等），但 TCP 把应用程序看成是一连串的无结构的字节流。TCP 有一个缓冲，当应用程序传送的数据块太长，TCP 就可以把它划分短一些再传送。如果应用程序一次只发送一个字节，TCP 也可以等待积累有足够多的字节后再构成报文段发送出去。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>服务器重装系统</title>
      <link href="/blog/2022/06/11/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/"/>
      <url>/blog/2022/06/11/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>今天我的 wordpress 数据库被攻击了，目前还不知道黑客用了什么手段，所以打算给服务器重装系统。我用的是搬瓦工的服务器，打开管理界面，我选择的是 centos-7-x86_64-bbr</p><a id="more"></a><blockquote><p>BBR（Bottleneck Bandwidth and RTT）是一种新的拥塞控制算法，由 Google 贡献给 Linux 内核 TCP 堆栈。有了 BBR，Linux 服务器可以显着提高吞吐量并减少连接延迟。此外，部署 BBR 很容易，因为此算法只需要在发送方更新，而无需在网络或接收方更新。</p></blockquote><h1 id="搭建Shadowsocks"><a href="#搭建Shadowsocks" class="headerlink" title="搭建Shadowsocks"></a>搭建Shadowsocks</h1><p>然后首先想到的是要安装 shadowsocks，因为我这个服务器基本上就是用来干这个事的。</p><p>我不想使用网上那种一键安装脚本的方式来弄这个，因为怕不安全（真的怕了怕了）。所以最好要自己搞懂每一步都做了什么。</p><p>主要参考这篇文章：<a href="https://gist.github.com/3013216027/469e7b988edde7e5f806f55a993b9efa" target="_blank" rel="noopener">https://gist.github.com/3013216027/469e7b988edde7e5f806f55a993b9efa</a></p><p>发现安装 shadowsocks 之前先要安装 pip</p><p>安装 pip 则要安装 python3</p><h2 id="安装python3"><a href="#安装python3" class="headerlink" title="安装python3"></a>安装python3</h2><p>我试了一下<code>yum install python3</code>居然真的能安装，终于不用像以前那样从 python 官网下载源码，自己编译，自己配环境变量了。</p><p>安装完后测一下版本<code>python3 --version</code>：Python 3.6.8，测一下安装位置：<code>which python3</code>：/usr/bin/python3</p><h2 id="安装shadowsocks"><a href="#安装shadowsocks" class="headerlink" title="安装shadowsocks"></a>安装shadowsocks</h2><p>接下来就是安装 shadowsocks 了：<code>python3 -m pip install shadowsocks</code></p><p>安装完后测一下 ssserver 看能不能用，直接输入这个命令看看效果，能用，定位一下位置：</p><p><code>which ssserver</code>：/usr/local/bin/ssserver。</p><p>卸载 shadowsocks 后就不能用了，所以能确定 ssserver 是跟 shadowsocks 有关的。</p><h2 id="配置shadowsocks"><a href="#配置shadowsocks" class="headerlink" title="配置shadowsocks"></a>配置shadowsocks</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;server&quot;: &quot;0.0.0.0&quot;,</span><br><span class="line">    &quot;local_port&quot;: 1080,</span><br><span class="line">    &quot;port_password&quot;: &#123;</span><br><span class="line">        &quot;10085&quot;: &quot;gagosdfger&quot;,</span><br><span class="line">        &quot;10086&quot;: &quot;gagosdfger&quot;,</span><br><span class="line">        &quot;10010&quot;: &quot;gagosdfger&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;method&quot;: &quot;aes-256-cfb&quot;,</span><br><span class="line">    &quot;timeout&quot;: 600</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现加密方法不支持<code>aes-256-gcm</code>，有什么办法给它加一种加密方式呢</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>浏览器上的几种xy坐标</title>
      <link href="/blog/2022/06/09/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8A%E7%9A%84%E5%87%A0%E7%A7%8Dxy%E5%9D%90%E6%A0%87/"/>
      <url>/blog/2022/06/09/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8A%E7%9A%84%E5%87%A0%E7%A7%8Dxy%E5%9D%90%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<p>有如下几种：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/screenX" target="_blank" rel="noopener">screenX</a>, screenY</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/clientX" target="_blank" rel="noopener">clientX</a>, clientY</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/pageX" target="_blank" rel="noopener">pageX</a>, pageY</li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/offsetX" target="_blank" rel="noopener">offsetX</a>, offsetY</li></ul><a id="more"></a><p>下面这张图可以很好的对比展示这几种 xy 坐标：</p><p><img src="https://s2.loli.net/2022/06/09/CgevqWi37jV6TwZ.png" alt="image.png"></p><p>那如果是在 iframe 中的 document，clientX 和 screenX 还是符合直觉的值吗？</p><p>答案是 clientX 不是，screenX 是。</p><p>clientX 的值是从 document 的左起始位置算起的，不会考虑 iframe 距离浏览器左边距。screenX 则依然是距离屏幕左边的距离。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>生成固定长度的字符串</title>
      <link href="/blog/2022/06/09/%E7%94%9F%E6%88%90%E5%9B%BA%E5%AE%9A%E9%95%BF%E5%BA%A6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/blog/2022/06/09/%E7%94%9F%E6%88%90%E5%9B%BA%E5%AE%9A%E9%95%BF%E5%BA%A6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>前端一般都要应对各种各样的用户输入，比如限制用户输入的字符串长度不超过 255 个字符。那么我自己测试的时候，去哪里弄个 256 长度的字符串呢，作为一个程序员，当然是自己写代码生成。下面我就来罗列一下有哪些方法可以实现这个需求。</p><a id="more"></a><h1 id="字符串方法：padStart-和-padEnd"><a href="#字符串方法：padStart-和-padEnd" class="headerlink" title="字符串方法：padStart()和 padEnd()"></a>字符串方法：padStart()和 padEnd()</h1><p>ES6 的字符串新语法 padStart()和 padEnd()，可以很好的完成这个需求：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">''</span>.padStart(<span class="number">256</span>, <span class="string">'a'</span>);</span><br><span class="line"><span class="string">''</span>.padEnd(<span class="number">256</span>, <span class="string">'a'</span>);</span><br></pre></td></tr></table></figure><p>官方文档：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/padStart" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/padStart</a></p><h1 id="数组方法：-join"><a href="#数组方法：-join" class="headerlink" title="数组方法： join()"></a>数组方法： join()</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">256</span>).fill(<span class="string">'a'</span>).join(<span class="string">''</span>);</span><br></pre></td></tr></table></figure><h1 id="字符串方法：repeat"><a href="#字符串方法：repeat" class="headerlink" title="字符串方法：repeat()"></a>字符串方法：repeat()</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'a'</span>.repeat(<span class="number">256</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>浏览器 storage 事件</title>
      <link href="/blog/2022/06/08/%E6%B5%8F%E8%A7%88%E5%99%A8storage%E4%BA%8B%E4%BB%B6/"/>
      <url>/blog/2022/06/08/%E6%B5%8F%E8%A7%88%E5%99%A8storage%E4%BA%8B%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>官方文档：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/storage_event" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/API/Window/storage_event</a></p><p>在使用 storage 事件的时候，我发现了两个不符合我直觉的特性：</p><ol><li>在本窗口修改存储区域（localStorage 或 sessionStorage）时，本窗口的监听无效</li><li>必须写入与旧值不同的值，才能监听到</li></ol><p>我自己写代码测试了以上两个特点，但疑惑的是中文文档里面什么都没讲，原来英文文档里面说了这两点，MDN 的中文文档和英文文档并不是翻译关系，完全就是另写的。所以如果觉得文档有问题，还是切换到英文看吧。</p><a id="more"></a><h1 id="英文文档的解释"><a href="#英文文档的解释" class="headerlink" title="英文文档的解释"></a>英文文档的解释</h1><p>The storage event of the Window interface fires when a storage area (localStorage) has been <strong>modified in the context of another document</strong>.</p><blockquote><p>Note: <strong>This won&#39;t work on the same page that is making the changes</strong> — it is really a way for other pages on the domain using the storage to sync any changes that are made. Pages on other domains can&#39;t access the same storage objects.</p></blockquote><h1 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置监听</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'storage'</span>, ()=&gt;&#123;<span class="built_in">console</span>.log(<span class="string">'监听storage'</span>, localStorage.getItem(<span class="string">'abcd'</span>))&#125;);</span><br><span class="line"><span class="comment">// 查看dom有哪些监听事件</span></span><br><span class="line">getEventListeners(<span class="built_in">window</span>);</span><br><span class="line"><span class="comment">// 设置localStorage</span></span><br><span class="line">localStorage.setItem(<span class="string">'abcd'</span>, <span class="string">'1111'</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二分查找</title>
      <link href="/blog/2022/06/08/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/blog/2022/06/08/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<p>什么是二分查找：二分查找每次只查询 mid（数组最中间的数），如果没找到目标，就缩小区间，根据 mid 和目标数对比，只搜左半区间或右半区间。</p><p>二分查找的前提：<strong>数据有序</strong></p><p>二分查找结束的条件：查找区间为空，或者找到元素</p><p>二分查找的条件分支：</p><ol><li><code>nums[mid]==target</code></li><li><code>nums[mid]&lt;target</code></li><li><code>nums[mid]&gt;target</code></li></ol><p>二分查找的搜索区间表示形式：</p><ol><li>左闭右开（区间为空的条件是 left==right）</li><li>左闭右闭（区间为空的条件是 left&gt;right）</li></ol><p>二分查找有的时候我会写出死循环来，仔细思考了一下：<strong>必须每次收缩边界的时候，都排除掉 mid，完全避免 mid 被重复查的可能</strong>。</p><a id="more"></a><h1 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h1><ol><li><a href="https://leetcode.cn/problems/binary-search/" target="_blank" rel="noopener">leetcode 704. 二分查找</a></li><li><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">leetcode 34. 在排序数组中查找元素的第一个和最后一个位置（中等）</a></li></ol><p>第一题答案：<br>左闭右闭搜索区间的写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; target</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> search = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right = nums.length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">const</span> mid = left + <span class="built_in">Math</span>.floor((right-left)/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">            right = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>左闭右开搜索区间的写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; target</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> search = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right = nums.length;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">const</span> mid = left + <span class="built_in">Math</span>.floor((right-left)/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第二题答案：<br>左闭右闭搜索区间的写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; target</span></span><br><span class="line"><span class="comment"> * @return &#123;number[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> searchRange = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [findLeft(nums, target), findRight(nums, target)]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> findLeft = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right = nums.length;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">let</span> mid = left + <span class="built_in">Math</span>.floor((right-left)/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums[left]==target)&#123;</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> findRight = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right = nums.length;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="keyword">let</span> mid = left + <span class="built_in">Math</span>.floor((right-left)/<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(left, mid, right)</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums[right<span class="number">-1</span>]==target)&#123;</span><br><span class="line">        <span class="keyword">return</span> right<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>左闭右闭搜索区间的写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; target</span></span><br><span class="line"><span class="comment"> * @return &#123;number[]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> searchRange = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [fundLeft(nums, target), fundRight(nums, target)]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fundLeft = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">let</span> mid = left + <span class="built_in">Math</span>.floor((right-left)/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">            right = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">            right = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums[left]==target)&#123;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fundRight = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;=right)&#123;</span><br><span class="line">        <span class="keyword">let</span> mid = left + <span class="built_in">Math</span>.floor((right-left)/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]==target)&#123;</span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">            left = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[mid]&gt;target)&#123;</span><br><span class="line">            right = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(nums[right]==target)&#123;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何学习</title>
      <link href="/blog/2021/08/22/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0/"/>
      <url>/blog/2021/08/22/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>这篇文章的思想来自于这位博主：<a href="https://space.bilibili.com/344849038/" target="_blank" rel="noopener">bilibili-YJango</a>，我觉得很受启发就将其简略写了下来。</p><h3 id="什么是学习？"><a href="#什么是学习？" class="headerlink" title="什么是学习？"></a>什么是学习？</h3><p>学习 vs 记忆</p><p>记忆：容量有限、难以集齐</p><p>学习：从有限的例子中找出问题和答案的规律：知识</p><blockquote><p>费曼说：如果你没有办法用简单的语言描述所学的知识，你就没有真正学会它。</p></blockquote><p>因为学习是用知识来压缩原本无限的信息</p><p>学习：找出知识、压缩信息</p><a id="more"></a><h3 id="如何学习"><a href="#如何学习" class="headerlink" title="如何学习"></a>如何学习</h3><p>找出问题和答案的规律，重塑大脑链接。学习的第一步就是明确：问题和答案。</p><blockquote><p>很多人压根连要学的知识所描述的问题都不清楚就去学习，最后只是记住知识的描述而已。</p></blockquote><p>然而知识不是信息，学习不是记忆。无法仅凭记住知识来学会知识。这也是人们在教和学的过程中最容易犯的错误，以为将知识告诉了某人，对方就可以学会了，以为听懂了知识，就以为自己学会了。然而知识的描述只是对学习起到引导的作用，最终的学习一定要通过例子来理清问题和答案的关系，来重塑大脑链接。这也就是为什么在讨论、写文章以及辩论时一定会伴随着例子，而不是单纯的对知识进行描述。因此在看书时也要注意区分，哪些是例子，哪些是对知识的描述。我个人在写文章时甚至常常会将例子和知识描述分开来写。华罗庚的：<strong>先把书读厚，再把书读薄</strong>。的学习方法就是指：先尽可能的搜集更多的例子来帮助体会问题和答案之间的关系。而当你真正学会的时候这些例子就会压缩成知识。最后由于学习是为了解决新问题，所以需要验证从现有例子中所提炼的知识，是否能描述问题和答案的真正规律，而不是仅仅记住了这些例子。</p><p>学习步骤：</p><ol><li>明确问题和答案</li><li>用例子构建知识</li><li>验证知识有效性</li></ol><h3 id="学习的误区"><a href="#学习的误区" class="headerlink" title="学习的误区"></a>学习的误区</h3><p>学习最重要的两步：</p><ol><li>明确问题（输入）和答案（输出）</li><li>用例子构建知识</li></ol><p>学习方式分为两大类：</p><ul><li>思考类：数学、逻辑</li><li>运动类：语言、运动</li></ul><p>区别在于是否依靠意识，因为意识是后进化出来的，擅长解决的是推断问题，速度缓慢，学不会的原因在于：</p><ol><li>错误的输入输出</li><li>错误的学习方式：用思考类方式来学习所有知识，比如看书学游泳、学做菜</li><li>不通过例子仅记忆知识</li></ol><p>以语言为例，四项能力的正确输入、输出分别是：</p><ul><li>听（声音）</li><li>说（想法）</li><li>读（文字）</li><li>写（想法）</li></ul><p>应试英语的误区是：输入、输出变成了完形填空，阅读选择等，这类从一些文字到另一些文字的思考类问题。用百词斩背单词时还容易产生另一种偏差：图片-&gt;中文。英语学习中最致命的是插入了中文思考这个中间输出，不仅输出错误，而且非常缓慢。若让很多懂外语，但未经训练的人同时翻译中文的话，他们会反应不过来，就是因为他的大脑在这个过程中其实并不思考中文。当出国后就会发现，所学英语的输入和真实英语的输入是不同的，根本用不了。不经过例子而直接记忆知识也是常见的误区，由于语言的输入从来不是一个单词而是一个句子，要想把握句子中某个单词的真正含义，需要通过大量体会不同的例句，但很多时候学生仅仅是记住了单词的中文描述。很多英语名师也犯同样的错误，不管他总结的再好，若仅仅是把他的总结告诉学生，学生永远都是在把他的总结当成信息记忆，而不是作为知识学习。十年学不会英语，不是因为没学会，而是因为搞错了输入输出，造成学到的是完全不同的知识。</p><p>我们可以同时应用多个应用类知识，譬如某人可以边走路边聊天。但意识在某一刻只能专注于一个思考类问题，无法并行。因此在某一刻，若无法从脑中搜索到能直接从输入得到输出的知识，问题就无法解决。然后我们所掌握的知识又是有限的，这种直接从输入得到输出的知识往往会超过我们的知识范围。应对办法可以是学习更多的知识，但还有一个简单，却又无比强大的方法就是分而治之。将问题拆分成脑中存有的，能直接从输入得到输出的小问题来解决。你一定听过这个办法，但恐怕你并不知道它为什么如此强大。原因在于，它可以将原本需要你掌握指数级知识才能解决的问题，变成用线性级知识就可以解决的问题。假设你掌握了三种知识，不考虑顺序，单从组合来看，就可以形成 $2^3$ 种知识，如果不拆分问题你需要掌握 8 种知识才能解决这些问题。而有 20 种知识的时候，二者的差别就是 20 vs 1048576。</p><p>应对方法：</p><ul><li>多学知识</li><li>分而治之（$2^n \rightarrow n$，它直接决定了一个人解决问题的能力）</li></ul><p>造成现象：</p><ul><li>编程无头绪</li><li>写作不出字</li><li>解题没思路</li><li>工作难应对</li></ul>]]></content>
      
      
      <categories>
          
          <category> 方法论 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>快速排序最坏的情况啥时候出现</title>
      <link href="/blog/2021/06/28/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%9C%80%E5%9D%8F%E7%9A%84%E6%83%85%E5%86%B5%E5%95%A5%E6%97%B6%E5%80%99%E5%87%BA%E7%8E%B0/"/>
      <url>/blog/2021/06/28/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%9C%80%E5%9D%8F%E7%9A%84%E6%83%85%E5%86%B5%E5%95%A5%E6%97%B6%E5%80%99%E5%87%BA%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>在面试富途的时候面试官问了这样一个问题：快速排序最坏的情况啥时候出现？当时没有答上来。实际上这个问题比较容易想清楚，思路如下，从快速排序的形式入手：$O(N*logN)$，N 代表单次排序的时间花销，logN 代表递归次数。我们知道最坏情况是$O(N^2)$，也就是说$logN$退化成了$N$。那么什么情况会退化成$logN$，当然是问题规模缩减得慢的时候，这与我们选中枢有直接的关系。假如我们选的中枢，每次都是最小或者最大，那么问题的缩小速度就会变成线性的了；而假如我们选的中枢，每次恰好是中间那个数，那么问题递归次数就是$log_2^N$了。</p><p>由于我们一般都是选第一个或者最后一个元素做中枢，那么最坏的情况对应就是：已经有序（这包括正序，逆序，以及全部元素相等）</p><p>由于快速排序的这个特征，所以我们一般的算法库中是结合了好几种排序算法：<a href="https://zhuanlan.zhihu.com/p/36274119" target="_blank" rel="noopener">C++一道深坑面试题：STL 里 sort 算法用的是什么排序算法？</a></p><p>同时我也在思考为啥快排这种最坏是$O(N^2)$的算法会被使用，而不直接使用最坏是$O(NlogN)$的算法，比如归并排序，堆排序。答案自然是这些排序也有各自的缺点，而且我估计是无法容忍的缺点。比如归并排序，它不是一个原地排序算法，需要额外的存储空间。堆排序，需要构建堆花费额外的时间。堆构建完毕后，借用堆这种结构，每次只能从堆顶取出最大或最小的数，而且取完还要进行堆维护，花费$logN$的时间。构建堆的过程和堆排序的过程类似，只不过构建堆是添加叶节点+上浮堆化的过程，而堆排序是取根节点+下沉堆化的过程，同样的构建堆也要花费$O(NlogN)$的时间。所以堆排序会花费双倍的时间。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>智能合约入门</title>
      <link href="/blog/2021/06/28/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%85%A5%E9%97%A8/"/>
      <url>/blog/2021/06/28/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>前言<br>从 2017 年开始买比特币的时候，我就想学习智能合约相关的开发，也曾想过要投身区块链行业，这一拖就是 4 年。我认真开始学起智能合约，最主要的原因其实是因为我离它更近了。这一轮牛市，DEFI 火爆，让我学会了使用钱包和公链。而在去年，我还是个只会在 OTC 入金的傻子，库币的 OTC 定价那么不合理都只会用 OTC 入金，后来我才发现原来 USDT 可以随意在链上转，而且波场免手续费，由此打开了新世界的大门。</p></blockquote><a id="more"></a><h2 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h2><ul><li><a href="https://solidity.tryblockchain.org/Solidity-%E8%AF%AD%E8%A8%80%E4%BB%8B%E7%BB%8D.html" target="_blank" rel="noopener">Solidity 语言</a></li><li><a href="https://solidity-cn.readthedocs.io/zh/develop/index.html" target="_blank" rel="noopener">Solidity 文档</a></li><li><a href="http://remix.ethereum.org/" target="_blank" rel="noopener">Remix</a></li><li><a href="https://www.jianshu.com/p/8e9882f626f0" target="_blank" rel="noopener">Remix 的使用</a></li><li><a href="https://donaldhan.github.io/blockchain/2020/05/19/RemixIDE%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B.html" target="_blank" rel="noopener">Remix 使用教程</a></li><li><a href="https://juejin.cn/post/6844903679938527246" target="_blank" rel="noopener">发币</a></li></ul><p>人生中第一段智能合约代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract addressTest&#123;</span><br><span class="line"></span><br><span class="line">    function getBalance(address addr) public view returns (uint)&#123;</span><br><span class="line">        return addr.balance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/06/28/NrE2xhpHcPInLAX.png" alt="运行结果"></p>]]></content>
      
      
      <categories>
          
          <category> 币圈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题：474. 一和零</title>
      <link href="/blog/2021/06/06/leetcode-470-%E4%B8%80%E5%92%8C%E9%9B%B6/"/>
      <url>/blog/2021/06/06/leetcode-470-%E4%B8%80%E5%92%8C%E9%9B%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="474-一和零"><a href="#474-一和零" class="headerlink" title="474. 一和零"></a><a href="https://leetcode-cn.com/problems/ones-and-zeroes/" target="_blank" rel="noopener">474. 一和零</a></h2><p>一道动态规划题目。</p><p>首先要明白这是一道背包问题，而且是双维度的，可以装0和1。</p><a id="more"></a><p>那么我们就需要一个三维数组dp来记录动态规划的子过程的结果，第一个维度代表遍历到第i个字符串，第二个维度代表第j个0的问题规模，第三个维度代表第k个1的问题规模，依次扩展到我们的目标字符串个数，目标问题规模。</p><p>状态转移方程：</p><ol><li>如果加入当前字符串，导致背包溢出，则不加：dp[i][j][k] = dp[i-1][j][k]</li><li>如果不溢出，则有两种可能，取最优解：dp[i][j][k] = Math.max(dp[i-1][j][k], dp[i-1][j-zeros][k-ones]+1)</li></ol><p>这里还需要考虑一些边界问题，比如i=0的时候，dp[0][any][any]应该是0，同理m=0和n=0也是如此。所以我们的数组空间需要每个维度上都加1来存放这些初始值。</p><p>JavaScript代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string[]&#125; strs</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; m</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; n</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findMaxForm = <span class="function"><span class="keyword">function</span>(<span class="params">strs, m, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>(strs.length+<span class="number">1</span>).fill(<span class="number">0</span>).map(<span class="function"><span class="params">()</span>=&gt;</span><span class="keyword">new</span> <span class="built_in">Array</span>(m+<span class="number">1</span>).fill(<span class="number">0</span>).map(<span class="function"><span class="params">()</span>=&gt;</span><span class="keyword">new</span> <span class="built_in">Array</span>(n+<span class="number">1</span>).fill(<span class="number">0</span>)))</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;=strs.length;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> [zeros, ones] = getZeros(strs[i<span class="number">-1</span>])</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;=m;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> k=<span class="number">0</span>;k&lt;=n;k++)&#123;</span><br><span class="line">                dp[i][j][k] = dp[i<span class="number">-1</span>][j][k]</span><br><span class="line">                <span class="keyword">if</span>(j&gt;=zeros &amp;&amp; k&gt;=ones)&#123;</span><br><span class="line">                    dp[i][j][k] = <span class="built_in">Math</span>.max(dp[i<span class="number">-1</span>][j][k], dp[i<span class="number">-1</span>][j-zeros][k-ones]+<span class="number">1</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[strs.length][m][n]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getZeros</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> zeros = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;str.length;i++)&#123;</span><br><span class="line">        zeros[str[i]-<span class="string">'0'</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> zeros</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题：203. 移除链表元素</title>
      <link href="/blog/2021/06/05/leetcode-230-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/"/>
      <url>/blog/2021/06/05/leetcode-230-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="203-移除链表元素"><a href="#203-移除链表元素" class="headerlink" title="203. 移除链表元素"></a><a href="https://leetcode-cn.com/problems/remove-linked-list-elements/" target="_blank" rel="noopener">203. 移除链表元素</a></h2><p>很简单的一道删除单链表节点题</p><a id="more"></a><p>JavaScript代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val, next) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = (val===undefined ? 0 : val)</span></span><br><span class="line"><span class="comment"> *     this.next = (next===undefined ? null : next)</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; head</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; val</span></span><br><span class="line"><span class="comment"> * @return &#123;ListNode&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> removeElements = <span class="function"><span class="keyword">function</span>(<span class="params">head, val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> h = <span class="keyword">new</span> ListNode(<span class="number">0</span>, head);</span><br><span class="line">    index = h;</span><br><span class="line">    <span class="keyword">while</span>(index.next)&#123;</span><br><span class="line">        <span class="keyword">if</span>(index.next.val == val)&#123;</span><br><span class="line">            <span class="keyword">let</span> next = index.next.next;</span><br><span class="line">            index.next = next;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        index = index.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h.next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题：160. 相交链表</title>
      <link href="/blog/2021/06/04/leetcode-160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"/>
      <url>/blog/2021/06/04/leetcode-160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists/" target="_blank" rel="noopener">160. 相交链表</a></h2><p>这题有两种解法：</p><ol><li>哈希表记录指针</li><li>双指针</li></ol><a id="more"></a><h3 id="哈希表记录指针"><a href="#哈希表记录指针" class="headerlink" title="哈希表记录指针"></a>哈希表记录指针</h3><p>JavaScript代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; headA</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; headB</span></span><br><span class="line"><span class="comment"> * @return &#123;ListNode&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getIntersectionNode = <span class="function"><span class="keyword">function</span>(<span class="params">headA, headB</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> hashset = <span class="keyword">new</span> <span class="built_in">Set</span>([]);</span><br><span class="line">    <span class="keyword">let</span> index = headA</span><br><span class="line">    <span class="keyword">while</span>(index)&#123;</span><br><span class="line">        hashset.add(index)</span><br><span class="line">        index = index.next</span><br><span class="line">    &#125;</span><br><span class="line">    index = headB</span><br><span class="line">    <span class="keyword">while</span>(index)&#123;</span><br><span class="line">        <span class="keyword">if</span>(hashset.has(index))&#123;</span><br><span class="line">            <span class="keyword">return</span> index;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            index = index.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><p>链表总共分为三部分：</p><ol><li>headA到公共节点</li><li>headB到公共节点</li><li>公共部分</li></ol><p>所以如果我们利用双指针，把这三个部分走一遍，就能让双指针碰上。</p><ol><li>index1走A链，走完A链，走B链</li><li>index2走B链，走完B链，走A链</li></ol><blockquote><p>两个指针同时等于null只有一种情况，就是两个链不相交。如果相交，想要都在链尾碰上，则两个链长度相等，若两个链长度相等且相交，则非公共部分长度一定相等，那么他们早就在第一次遍历的时候在公共节点遇上了。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * function ListNode(val) &#123;</span></span><br><span class="line"><span class="comment"> *     this.val = val;</span></span><br><span class="line"><span class="comment"> *     this.next = null;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; headA</span></span><br><span class="line"><span class="comment"> * @param &#123;ListNode&#125; headB</span></span><br><span class="line"><span class="comment"> * @return &#123;ListNode&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> getIntersectionNode = <span class="function"><span class="keyword">function</span>(<span class="params">headA, headB</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> index1 = headA;</span><br><span class="line">    <span class="keyword">let</span> index2 = headB;</span><br><span class="line">    <span class="keyword">while</span>(index1!==index2)&#123;</span><br><span class="line">        index1 = index1==<span class="literal">null</span>?headB:index1.next;</span><br><span class="line">        index2 = index2==<span class="literal">null</span>?headA:index2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题：525. 连续数组</title>
      <link href="/blog/2021/06/03/leetcode-525-%E8%BF%9E%E7%BB%AD%E6%95%B0%E7%BB%84/"/>
      <url>/blog/2021/06/03/leetcode-525-%E8%BF%9E%E7%BB%AD%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<blockquote><p>凡是涉及到连续子数组的，都可以用前缀和+哈希表来解</p></blockquote><h2 id="525-连续数组"><a href="#525-连续数组" class="headerlink" title="525. 连续数组"></a><a href="https://leetcode-cn.com/problems/contiguous-array/" target="_blank" rel="noopener">525. 连续数组</a></h2><p>这题要注意的就是，因为要统计元素个数，所以要使用i+1。</p><p>哈希表的key的含义是：当前遍历到的1与符合标准（一半是1）之间的差距，而记录的位置则必须是最小位置。所以只在初始化的时候赋值。</p><a id="more"></a><p>JavaScript代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findMaxLength = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> hashmap = &#123;&#125;</span><br><span class="line">    <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        sum += nums[i];</span><br><span class="line">        <span class="keyword">if</span>(i+<span class="number">1</span>==sum*<span class="number">2</span>)&#123;</span><br><span class="line">            max = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(hashmap.hasOwnProperty(i+<span class="number">1</span>-sum*<span class="number">2</span>))&#123;</span><br><span class="line">            <span class="keyword">if</span>(max&lt;(i-hashmap[i+<span class="number">1</span>-sum*<span class="number">2</span>]))&#123;</span><br><span class="line">                max = (i-hashmap[i+<span class="number">1</span>-sum*<span class="number">2</span>])</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            hashmap[i+<span class="number">1</span>-sum*<span class="number">2</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题： 342. 4的幂</title>
      <link href="/blog/2021/05/31/leetcode-342-4%E7%9A%84%E5%B9%82/"/>
      <url>/blog/2021/05/31/leetcode-342-4%E7%9A%84%E5%B9%82/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这个问题看起来是个简单题，其实可以从中学到位运算和一些数学知识。</p></blockquote><h2 id="342-4的幂"><a href="#342-4的幂" class="headerlink" title="342. 4的幂"></a><a href="https://leetcode-cn.com/problems/power-of-four/" target="_blank" rel="noopener">342. 4的幂</a></h2><p>我自己的解法很简单易懂，但是不够高效：</p><a id="more"></a><p>JavaScript代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; n</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isPowerOfFour = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">        i = i*<span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i==n)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个解法的效率很差，只战胜了55%的选手。说明肯定有更优解，我翻了一下答案。主要是2种角度的解法：</p><ol><li>位运算</li><li>数学</li></ol><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>如果是2的幂，那么位中只能出现一个1。如果是4的，那么肯定也只有一个1，且出现的位置是每隔一位出现。那么问题来了，怎么判断位上只有一个1呢？操作是：减去1，然后与。得到的结果必然应该是0。那如何判断1在哪一位上呢？好像只能遍历了。但其实我们不需要知道具体是哪一位，只需要知道是否分布在正确的位上，可以通过mask解决：<code>mask=$(01010101010101010101010101010101)_2$</code>，因为1分布在奇数位。也可以写成更简短的16进制形式：<code>mask=$(55555555)_16$</code></p><p>JavaScript代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; n</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isPowerOfFour = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n&gt;<span class="number">0</span> &amp;&amp; (n &amp; (n<span class="number">-1</span>)) == <span class="number">0</span> &amp;&amp; (n &amp; <span class="number">0x55555555</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>奇怪的是这个代码的运行时间居然比上面那个还长，感觉不科学。</p><h3 id="数学角度"><a href="#数学角度" class="headerlink" title="数学角度"></a>数学角度</h3><p>首先依然是按照上面的两个条件：</p><ol><li>n&gt;0</li><li>n只有一个0</li></ol><p>我们观察到所有偶数分为：$4^x \times 2 \times 2$也就是$4^x$，和$4^x \times 2 \times 1$。而4的幂次除以3的余数必然是1，而$4^x \times 2$这种除以3的余数必然是2。</p><p>我们增加这个条件筛选出$4^x$</p><p>JavaScript代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; n</span></span><br><span class="line"><span class="comment"> * @return &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isPowerOfFour = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n&gt;<span class="number">0</span> &amp;&amp; (n &amp; (n<span class="number">-1</span>)) == <span class="number">0</span> &amp;&amp; (n % <span class="number">3</span>)==<span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcode： 560. 和为K的子数组</title>
      <link href="/blog/2021/05/29/leetcode-560-%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
      <url>/blog/2021/05/29/leetcode-560-%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这题是在做每日一题中遇到的问题的子问题：<a href="https://leetcode-cn.com/problems/number-of-submatrices-that-sum-to-target/" target="_blank" rel="noopener">1074. 元素和为目标值的子矩阵数量</a></p></blockquote><h2 id="560-和为K的子数组"><a href="#560-和为K的子数组" class="headerlink" title="560. 和为K的子数组"></a><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">560. 和为K的子数组</a></h2><p>遇到这类问题，首先想的是复杂度，然后复杂度天然是跟问题规模有关的。遍历一遍肯定是必要的，当我们遍历到第n这个位置，我们怎么判断从0到n中有多少个解，进一步的，我们还只要增量数据，n-1的解不应该去重复计算。第n这个位置上的数是一定要考虑进去的，所以我们从后往前寻找。具体代码如下：</p><a id="more"></a><p>JavaScript代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> subarraySum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> start = <span class="number">0</span>; start &lt; nums.length; ++start) &#123;</span><br><span class="line">        <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> end = start; end &gt;= <span class="number">0</span>; --end) &#123;</span><br><span class="line">            sum += nums[end];</span><br><span class="line">            <span class="keyword">if</span> (sum == k) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样的话，算法的时间复杂度是O(n^2)。有没有重复计算的问题呢，似乎不太好说，但结果是：有，像此类问题有统一的规律，就是我们可以记录前缀和。如果我们知道前缀和，那么我们只需要用当前和减去k，看是否等于某个前缀和，如果有，我们不就正好找到一个子数组的和等于k了吗？所以基于前缀和，我们一次遍历即可解决问题。</p><p>JavaScript代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; k</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> subarraySum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pre = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> preRecord = &#123;<span class="number">0</span>: <span class="number">1</span>&#125;</span><br><span class="line">    <span class="keyword">let</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        pre += nums[i];</span><br><span class="line">        <span class="keyword">if</span>(preRecord[pre-k])&#123;</span><br><span class="line">            count += preRecord[pre-k]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(preRecord[pre])&#123;</span><br><span class="line">            preRecord[pre]++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            preRecord[pre]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>前缀和对过往的遍历总结提取了信息，使我们不用再去进行重复的计算，是非常重要的技巧。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcode： 1074. 元素和为目标值的子矩阵数量</title>
      <link href="/blog/2021/05/29/leetcode-1074-%E5%85%83%E7%B4%A0%E5%92%8C%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E5%AD%90%E7%9F%A9%E9%98%B5%E6%95%B0%E9%87%8F/"/>
      <url>/blog/2021/05/29/leetcode-1074-%E5%85%83%E7%B4%A0%E5%92%8C%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E5%AD%90%E7%9F%A9%E9%98%B5%E6%95%B0%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这个问题需要拆分出子问题才好解决，要不然没有思路。它的子问题是：<a href="https://leetcode-cn.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">560. 和为K的子数组</a></p></blockquote><h2 id="1074-元素和为目标值的子矩阵数量"><a href="#1074-元素和为目标值的子矩阵数量" class="headerlink" title="1074. 元素和为目标值的子矩阵数量"></a><a href="https://leetcode-cn.com/problems/number-of-submatrices-that-sum-to-target/" target="_blank" rel="noopener">1074. 元素和为目标值的子矩阵数量</a></h2><p>当你理解了子问题之后，我们来想想，怎么把这个问题转换到子问题上呢？也就是如何把二维问题变一维问题呢？</p><p>我们想象把一个矩阵的列上的元素全部加起来，不就是一个一维数组了吗。这个一维数组可以等效的应用在这个问题上。</p><a id="more"></a><p>那这样的组合有哪些呢？通过简单的二次遍历，就能得出我们想要的组合：</p><p>JavaScript代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> j=i;j&lt;n;j++)&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次i到j之间的数就是我们想要的组合，拿这些数的和，组成新的一维数组，然后用一维数组的解法去解。这里有个小技巧是这个和也要避免重复计算，所以要把每次计算所得存下来，下次在这个基础上算，这样可以省下从头开始求和的时间。</p><p>JavaScript代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[][]&#125; matrix</span></span><br><span class="line"><span class="comment"> * @param &#123;number&#125; target</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> numSubmatrixSumTarget = <span class="function"><span class="keyword">function</span>(<span class="params">matrix, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;matrix.length;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> sum = <span class="keyword">new</span> <span class="built_in">Array</span>(matrix[<span class="number">0</span>].length).fill(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=i;j&lt;matrix.length;j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> k=<span class="number">0</span>;k&lt;matrix[<span class="number">0</span>].length;k++)&#123;</span><br><span class="line">                sum[k] += matrix[j][k]</span><br><span class="line">            &#125;</span><br><span class="line">            count += subarraySum(sum, target)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> subarraySum = <span class="function"><span class="keyword">function</span>(<span class="params">nums, k</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> pre = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> preRecord = &#123;<span class="number">0</span>: <span class="number">1</span>&#125;</span><br><span class="line">    <span class="keyword">let</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        pre += nums[i];</span><br><span class="line">        <span class="keyword">if</span>(preRecord[pre-k])&#123;</span><br><span class="line">            count += preRecord[pre-k]</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(preRecord[pre])&#123;</span><br><span class="line">            preRecord[pre]++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            preRecord[pre]=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>简化问题的办法有很多，比如降低问题规模，降低维度，二维 -&gt; 一维。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题： 477. 汉明距离总和</title>
      <link href="/blog/2021/05/28/leetcode-477-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB%E6%80%BB%E5%92%8C/"/>
      <url>/blog/2021/05/28/leetcode-477-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB%E6%80%BB%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<blockquote><p>leetcode每日一题是leetcode中文版官方推出的活动，每日一题锻炼解决问题的思维能力。</p></blockquote><h2 id="477-汉明距离总和"><a href="#477-汉明距离总和" class="headerlink" title="477. 汉明距离总和"></a><a href="https://leetcode-cn.com/problems/total-hamming-distance/" target="_blank" rel="noopener">477. 汉明距离总和</a></h2><p>这题初看上去特别简单，就是一个O(n^2)的遍历（组合），对每一组求汉明距离累加起来。不过我一开始就觉得可能会超时，提交后果然超时了。更优的做法是按位遍历，每一位上所有的数要么是0要么是1，把0和1的个数统计出来，相乘，就是这一位的汉明距离总和。</p><a id="more"></a><p>JavaScript代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> totalHammingDistance = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> max = <span class="built_in">Math</span>.max(...nums)</span><br><span class="line">    <span class="keyword">let</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(max&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        max&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">        <span class="keyword">let</span> zero = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">let</span> one = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=<span class="number">0</span>;j&lt;nums.length;j++)&#123;</span><br><span class="line">            <span class="keyword">let</span> temp = nums[j]&gt;&gt;i;</span><br><span class="line">            <span class="keyword">if</span>(temp%<span class="number">2</span>)&#123;</span><br><span class="line">                one++;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                zero++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res += zero*one;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>position sticky</title>
      <link href="/blog/2021/05/28/position-sticky/"/>
      <url>/blog/2021/05/28/position-sticky/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在做公司项目的过程中遇到一个问题：让表头固定，同时其宽度必须占满整个父元素。用 fixed，可以固定但是宽度无法撑开。最终用<code>position: sticky</code>解决了问题。</p></blockquote><p>参考资料：</p><ol><li><a href="https://www.zhangxinxu.com/wordpress/2018/12/css-position-sticky/" target="_blank" rel="noopener">杀了个回马枪，还是说说 position:sticky 吧« 张鑫旭-鑫空间-鑫生活</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/position" target="_blank" rel="noopener">position - CSS（层叠样式表） | MDN</a></li></ol><a id="more"></a><h2 id="position-sticky-的作用"><a href="#position-sticky-的作用" class="headerlink" title="position: sticky 的作用"></a>position: sticky 的作用</h2><p>这个坑先放着，等深入研究了再来填，放上 codepen 试验现场：<a href="https://codepen.io/liuqinh2s/pen/oNZWbeX" target="_blank" rel="noopener">https://codepen.io/liuqinh2s/pen/oNZWbeX</a></p>]]></content>
      
      
      <categories>
          
          <category> css </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>leetcode每日一题： 1190. 反转每对括号间的子串</title>
      <link href="/blog/2021/05/27/leetcode-1190-%E5%8F%8D%E8%BD%AC%E6%AF%8F%E5%AF%B9%E6%8B%AC%E5%8F%B7%E9%97%B4%E7%9A%84%E5%AD%90%E4%B8%B2/"/>
      <url>/blog/2021/05/27/leetcode-1190-%E5%8F%8D%E8%BD%AC%E6%AF%8F%E5%AF%B9%E6%8B%AC%E5%8F%B7%E9%97%B4%E7%9A%84%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>写之前：<br>2020年整整一年没有写过博客了，沉痛的一年。<br>写博客还是继续下去吧，不管怎样。</p></blockquote><h2 id="1190-反转每对括号间的子串"><a href="#1190-反转每对括号间的子串" class="headerlink" title="1190. 反转每对括号间的子串"></a><a href="https://leetcode-cn.com/problems/reverse-substrings-between-each-pair-of-parentheses/" target="_blank" rel="noopener">1190. 反转每对括号间的子串</a></h2><p>这道题一看就知道用栈来解决，但具体到怎么做却依旧不容易想通。直到看过答案后，才发现，实际上真的只需要遍历一遍就能解决问题。</p><a id="more"></a><p>思路如下：</p><p>每遇到一个括号块，就需要把里面的字符串翻转（这是单步操作），然后递归翻转每一层。这是我们人的思维，但机器是看不到这种宏观信息的，我们需要安排具体到每一步的任务。代码在遍历的时候只会遇到左括号或者右括号，假如我们遇到左括号的时候开始记录字符串，那么在遇到右括号的时候，就有翻转的目标对象了。但如果连续遇到两个左括号呢？我们将记录的信息先入栈，然后继续上面的步骤即可。</p><p>具体步骤（单步）：</p><ol><li>遇到左括号：入栈已记录的字符串，清空我们用于记录的变量</li><li>遇到普通字符：记录</li><li>遇到右括号：翻转记录的字符串，将栈顶字符串pop出来拼接上翻转好的字符串</li></ol><p>JavaScript代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; s</span></span><br><span class="line"><span class="comment"> * @return &#123;string&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseParentheses = <span class="function"><span class="keyword">function</span>(<span class="params">s</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> stack = []</span><br><span class="line">    <span class="keyword">let</span> str = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;s.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]==<span class="string">'('</span>)&#123;</span><br><span class="line">            stack.push(str)</span><br><span class="line">            str = <span class="string">''</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[i]==<span class="string">')'</span>)&#123;</span><br><span class="line">            str = stack.pop() + <span class="built_in">Array</span>.from(str).reverse().join(<span class="string">''</span>)</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            str += s[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>后记：这是新年的第一篇博客，以后会做更多的记录，不管有没有人看。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>炒币的基本知识</title>
      <link href="/blog/2019/12/30/%E7%82%92%E5%B8%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
      <url>/blog/2019/12/30/%E7%82%92%E5%B8%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="平台选择"><a href="#平台选择" class="headerlink" title="平台选择"></a>平台选择</h2><p>平台选择：选大平台，像火币、币安。这里有个排行供参考：<a href="https://coinmarketcap.com/zh/rankings/exchanges/" target="_blank" rel="noopener">https://coinmarketcap.com/zh/rankings/exchanges/</a></p><p>我自己选的是火币，以前的火币体验是非常好的，买卖很方便，现在经常数据刷不出来。</p><a id="more"></a><h2 id="k-线图"><a href="#k-线图" class="headerlink" title="k 线图"></a>k 线图</h2><p>K 线图（因为形状酷似蜡烛，也叫蜡烛图）</p><p><img src="https://i.loli.net/2019/07/10/5d2541b86cbe121624.png" alt="K线图"></p><p><a href="https://zh.wikipedia.org/wiki/K%E7%BA%BF" target="_blank" rel="noopener">k 线图</a>是最常用和最基本的信息来源</p><p>k 线图是典型的笛卡尔坐标（也就是直角坐标系），横轴是时间，纵轴是价格。</p><p>横轴可以选择多种时间分片，比如一个月，1 周，1 天，4 小时，1 小时，15 分钟，1 分钟。上图中，我选择的就是 1 天的 k 线图。每一根蜡烛就代表一个时间片的基本信息，当蜡烛是红色的时候，就说明是 <strong>收盘价&lt;开盘价</strong>；是绿色的时候，就说明是 <strong>开盘价&gt;收盘价</strong>。而中间细长的线冒出头，就是在该时间片内价格曾今到过的位置。</p><blockquote><p>什么是收盘价，什么是开盘价？开盘价是时间片开始的时候的价格，收盘价是时间片结束时候的价格。比如你如果选的是 1 天作为时间片，那么开盘时间就是 <strong>00:00:01</strong>，收盘时间就是 <strong>23:59:59</strong>。那什么又是价格呢？价格是上一笔成交的价格。</p></blockquote><p>当然红色和绿色只是一种约定俗成，在中国股市，红色一般代表涨，绿色代表跌。而美股则恰好相反。</p><p>如果你能通过自己的观察发现以上这些信息，说明你已经具备了一定的洞察力。买了这么久比特币，我也是今年才了解了这些信息。 但借助于搜索引擎和维基百科我们可以更快的掌握这些知识。</p><p>我们可以看到还有黄、绿、紫三根曲线贯穿在蜡烛图中。这就是 <strong>均线</strong>。上图中 MA5 是黄色的，MA10 是绿色的，MA30 是紫色的。 MA 是 Moving Average 的意思，MA 线就是 <a href="https://zh.wikipedia.org/wiki/%E7%A7%BB%E5%8B%95%E5%B9%B3%E5%9D%87" target="_blank" rel="noopener">移动平均线</a>。 但要注意的是 MA5 并不一定是 5 日均线的意思，还要看你选择的是什么时间分片，如果是 1 小时，那就是 5 小时均线。另外均线采用的数据一般是收盘价。计算方法很简单，当前均线值=前面几根蜡烛的收盘价相加/蜡烛的根数。比如 MA5 = (前面四根蜡烛图的收盘价+当前价格)/5，由于还没收盘，计算当前的 MA5，最后一根 k 线的收盘价用的是当前价格，所以当前的 MA5 是波动的。</p><h2 id="深度图"><a href="#深度图" class="headerlink" title="深度图"></a>深度图</h2><p><img src="https://i.loli.net/2019/07/10/5d25517d36cdc58042.png" alt="深度图"></p><p>深度图就比较简单了。从图中我们可以得知，绿色这边是买入，红色是卖出。横轴是价格，纵轴是数量。</p><p>一般来说价格越低愿意买的人越多，价格越高愿意卖的人越多，所以会呈现出这种两个三角形尖尖角相对的感觉，中间是谷，两边是峰。</p><p>我们需要留意的是买盘和卖盘哪个更大，买盘大说明很多人想要买（一般情况下会导致供不应求，此时为卖方市场，价格可能会被推高），卖盘大说明很多人想要卖（一般情况下会导致供过于求，此时为买方市场，价格可能会被压低）。</p><p>另一个现象就是在某个价位形成一条比较明显的垂线，说明在这个价格的订单量突然非常多，这种线就是压力位，可以阻止暴涨暴跌。</p><p>但我们也要注意到，深度图只是挂单信息的一个全方位展示，挂单是可以随时取消的，除非挂单不可取消，否则深度图总是有一定的延迟性，有可能被庄家用来迷惑散户。</p><h2 id="流动性"><a href="#流动性" class="headerlink" title="流动性"></a>流动性</h2><p>目前比特币的每日交易量占整个加密货币的 60%以上，流动性最大。某些市值小的币种流动性很小，大资金进不来，也出不去。比特币的这个优势将不断的吸引大资金注入。</p><p>如果你手上有 1000 个比特币，甚至 10000 个比特币，不用担心出售不了，你挂个卖单，市场很快就能吃掉。而一些市值和交易量小的币种则不行，比如 BTS，巨蟹现在要甩卖 3 亿个 BTS，就很困难。</p><h2 id="价格和市值"><a href="#价格和市值" class="headerlink" title="价格和市值"></a>价格和市值</h2><p>加密货币暴涨暴跌，钱都进了谁的腰包？</p><blockquote><p>在市场中，价格主要是通过买卖过程直接决定的，当买方力量强于卖方，价格就涨；反之价格就跌（供需关系决定价格走势）。</p></blockquote><p>但这其中也有不少猫腻，举个实际的例子：</p><p>假设比特币现在的价格是 10000 USDT，并且只有你一个人在交易，你想买 100 万 USDT 的 BTC，只能通过不断抬高价格，吃掉挂着的卖单，才能买到需要数量的 BTC。</p><p>假设买完之后，BTC 价格到了 10100 USDT，目前比特币的流通量为 1777.5 万，所以 BTC 的总市值增加了<code>100*1777.5万=17.775亿</code>。但实际流入的资金量为 100 万 USDT。比特币的实际交易量在<code>100万/10000</code>到<code>100万/10100</code>之间，100 个不到，和所有的比特币数量相比是很少的。<strong>这意味着价格和市值的波动其实只是一部分参与交易的比特币所导致的</strong>。</p><p>这告诉我们：市值是虚的，而交易量更为真实。如果某个币交易量过低，而市值过高，说明该加密货币被人所操控，那么将十分危险。</p>]]></content>
      
      
      <categories>
          
          <category> 币圈 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>图灵机</title>
      <link href="/blog/2019/04/26/%E5%9B%BE%E7%81%B5%E6%9C%BA/"/>
      <url>/blog/2019/04/26/%E5%9B%BE%E7%81%B5%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="图灵机"><a href="#图灵机" class="headerlink" title="图灵机"></a><a href="https://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E6%9C%BA" target="_blank" rel="noopener">图灵机</a></h2><p>图灵机（Turing Machine）是 <a href="https://zh.wikipedia.org/wiki/%E8%89%BE%E4%BC%A6%C2%B7%E5%9B%BE%E7%81%B5" target="_blank" rel="noopener">英国数学家艾伦·图灵</a> 在 1936 年发表的 &quot;<a href="https://www.cs.virginia.edu/~robins/Turing_Paper_1936.pdf" target="_blank" rel="noopener">On Computable Numbers, with an Application to the Entscheidungsproblem</a>&quot;（《论可计算数及其在判定性问题上的应用》）中提出的数学模型。在文章中图灵描述了它是什么，并且证明了，只要图灵机可以被实现，就可以用来解决任何可计算问题。</p><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><ul><li><a href="https://www.bilibili.com/video/av30479683?from=search&amp;seid=11735601712045998475" target="_blank" rel="noopener">妈咪说：图灵</a></li><li><a href="https://movie.douban.com/subject/10463953/" target="_blank" rel="noopener">模仿游戏</a></li></ul><a id="more"></a><h3 id="图灵机的基本思想"><a href="#图灵机的基本思想" class="headerlink" title="图灵机的基本思想"></a>图灵机的基本思想</h3><p>图灵机是一种 <strong>抽象计算模型</strong>，图灵机的构成：</p><ul><li>一条无限长的纸带，纸带由很多个格子构成，用于输入输出信息。每个格子中包含一个来自有限字母表的符号，字母表中有一个特殊符号表示空白。纸带上一端的格子从 0 开始编号，另一端无限延伸一直到无穷大。</li><li>一个读写头，用于读写纸带</li><li>一个状态寄存器，用于保存机器状态。图灵机的状态个数有限，并且有一个特殊的状态：停机状态</li><li>一套控制规则，根据当前机器状态和纸带内容来确定下一步的动作：<ul><li>写入或擦除当前格子内容</li><li>移动读写头，向左、向右、或不动</li><li>保持当前状态或转移到另一状态</li></ul></li></ul><h3 id="图灵机的正式定义"><a href="#图灵机的正式定义" class="headerlink" title="图灵机的正式定义"></a>图灵机的正式定义</h3><p>a (one-tape) Turing machine can be formally defined as a <strong>7-tuple</strong> $M=\langle Q,\Gamma ,b,\Sigma ,\delta ,q_{0},F\rangle $ where</p><ul><li>$Q$ is a finite, non-empty set of <strong>states</strong>;</li><li>$\Gamma$ is a finite, non-empty set of <strong>tape alphabet symbols</strong>;</li><li>$b\in \Gamma$ is the <strong>blank symbol</strong> (the only symbol allowed to occur on the tape infinitely often at any step during the computation);</li><li>$\Sigma \subseteq \Gamma \setminus {b}$ is the set of <strong>input symbols</strong>, that is, the set of symbols allowed to appear in the initial tape contents;</li><li>$q_{0}\in Q$ is the <strong>initial state</strong>;</li><li>$F\subseteq Q$ is the set of <strong>final states or accepting states</strong>. The initial tape contents is said to be accepted by $M$ if it eventually halts in a state from $F$.</li><li>$\delta :(Q\setminus F)\times \Gamma \not \to Q\times \Gamma \times \{L,R\}$ is a partial function called the <strong>transition function</strong>, where L is left shift, R is right shift. (A relatively uncommon variant allows &quot;no shift&quot;, say N, as a third element of the latter set.) If $\delta$ is not defined on the current state and the current tape symbol, then the machine <strong>halts</strong>;</li></ul><h3 id="图灵机的实践"><a href="#图灵机的实践" class="headerlink" title="图灵机的实践"></a>图灵机的实践</h3><ul><li><a href="https://zh.wikipedia.org/wiki/Brainfuck" target="_blank" rel="noopener">Brainfuck</a></li></ul><h3 id="图灵完备"><a href="#图灵完备" class="headerlink" title="图灵完备"></a>图灵完备</h3><p>只要能模拟单带图灵机，就是图灵完备的。这也意味着其计算能力与通用图灵机等同。</p><p>不是图灵完备的的常见情况有；</p><ol><li>递归或循环有限，无法写不终止的程序，如<code>while(true){}</code></li><li>无法实现类似数组或列表这样的数据结构（不能模拟纸带）</li></ol><p>图灵完备也有可能带来坏处，不图灵完备也不是完全没用，比如：有些场景我们需要限制语言的表达能力，如 限制无限循环和递归，保证我们的程序一定是可终止的。</p><h3 id="停机问题"><a href="#停机问题" class="headerlink" title="停机问题"></a><a href="https://zh.wikipedia.org/wiki/%E5%81%9C%E6%9C%BA%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">停机问题</a></h3><p>停机问题（英语：halting problem）是逻辑数学中可计算性理论的一个问题。通俗地说，停机问题就是判断任意一个程序是否能在有限的时间之内结束运行的问题。该问题等价于如下的判定问题：是否存在一个程序 P，对于任意输入的程序 w，能够判断 w 会在有限时间内 <strong>结束或者死循环</strong>。</p><p>艾伦·图灵在 1936 年用 <a href="https://zh.wikipedia.org/wiki/%E5%B0%8D%E8%A7%92%E8%AB%96%E8%AD%89%E6%B3%95" target="_blank" rel="noopener">对角论证法</a> 证明了，不存在解决停机问题的通用算法。</p><blockquote><p>停机问题包含了 <a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E6%8C%87" target="_blank" rel="noopener">自我指涉</a>，本质是 <a href="https://zh.wikipedia.org/wiki/%E4%B8%80%E9%98%B6%E9%80%BB%E8%BE%91" target="_blank" rel="noopener">一阶逻辑</a> 的不完备性，类似的命题有 <a href="https://zh.wikipedia.org/wiki/%E7%90%86%E5%8F%91%E5%B8%88%E6%82%96%E8%AE%BA" target="_blank" rel="noopener">理发师悖论</a>、<a href="https://zh.wikipedia.org/wiki/%E5%85%A8%E8%83%BD%E6%82%96%E8%AB%96" target="_blank" rel="noopener">全能悖论</a> 等。</p></blockquote><p>证明很简单，构造<code>G=~G</code>命题（G 等于 G 非），让逻辑崩溃，无论 G 是真还是假，都是错的，最后推导出：不存在这样的 G。</p><p>停机问题证明过程（反证法）：</p><ol><li>如果存在可以判定任意程序是否停机的程序，我们姑且称它为 <strong>上帝程序</strong></li><li>那我们定义这样一个程序，它利用上帝程序判断自己是否停机，但如果上帝程序输出停机，它就不停；如果上帝程序输出不停机，它就停机（就是反着干）。这样一来无论上帝程序输出什么，上帝程序都是错的。那么我们只能说不存在这样的上帝程序。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_halt</span><span class="params">(program, input)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> program halts on input:</span><br><span class="line">        <span class="keyword">return</span> true</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> false</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fuck_is_halt</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> is_halt(fuck_is_halt):</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><ul><li><a href="http://www.matrix67.com/blog/archives/901" target="_blank" rel="noopener">Matrix67：停机问题、Chaitin 常数与万能证明方法</a></li><li><a href="https://blog.csdn.net/pongba/article/details/1336028" target="_blank" rel="noopener">刘未鹏：康托尔、哥德尔、图灵——永恒的金色对角线(rev#2)</a></li></ul><h3 id="自我指涉"><a href="#自我指涉" class="headerlink" title="自我指涉"></a><a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E6%8C%87" target="_blank" rel="noopener">自我指涉</a></h3><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/fa/Ouroboros.png/220px-Ouroboros.png" alt="自我指涉"></p><p>在数学中，对自指的研究最终导致了著名的 <a href="https://zh.wikipedia.org/wiki/%E5%93%A5%E5%BE%B7%E5%B0%94%E4%B8%8D%E5%AE%8C%E5%A4%87%E5%AE%9A%E7%90%86" target="_blank" rel="noopener">哥德尔不完备定理</a>。</p><blockquote><p>计算机程序中的自指主要是为 <a href="https://zh.wikipedia.org/wiki/%E9%80%92%E5%BD%92" target="_blank" rel="noopener">递归</a></p></blockquote><p><a href="https://zh.wikipedia.org/wiki/%E5%BE%B7%E7%BD%97%E6%96%AF%E7%89%B9%E6%95%88%E5%BA%94" target="_blank" rel="noopener">德罗斯特效应</a>：</p><p>我们经常可以在主播间看到类似的画面：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/b3/Screenshot_Recursion_via_vlc.png/128px-Screenshot_Recursion_via_vlc.png" alt="德罗斯特效应"></p><p>也可以用两面镜子自己做这个实验。</p><ul><li><a href="https://www.bilibili.com/video/av31411706?from=search&amp;seid=7703410137961337640" target="_blank" rel="noopener">妈咪说：哥德尔</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>冯·诺依曼结构</title>
      <link href="/blog/2019/04/22/%E5%86%AF%C2%B7%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84/"/>
      <url>/blog/2019/04/22/%E5%86%AF%C2%B7%E8%AF%BA%E4%BE%9D%E6%9B%BC%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="冯·诺依曼结构"><a href="#冯·诺依曼结构" class="headerlink" title="冯·诺依曼结构"></a><a href="https://zh.wikipedia.org/wiki/%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">冯·诺依曼结构</a></h2><p>冯·诺伊曼结构与 <strong>存储程序型计算机</strong> 是互相通用的名词</p><blockquote><p><strong>哈佛结构</strong> 是一种将程序数据与普通数据分开存储的设计概念，可以说是冯·诺依曼结构的一种。</p></blockquote><p>存储程序计算机在体系结构上主要特点有：</p><ul><li>以运算单元为中心</li><li><strong>采用存储程序原理</strong></li><li>存储器是按地址访问、线性编址的空间</li><li><strong>控制流由指令流产生</strong></li><li>指令由 <strong>操作码</strong> 和 <strong>地址码</strong> 组成</li><li>数据以二进制编码</li></ul><p>五个组成部分：</p><ul><li>存储器</li><li>控制器</li><li>运算器（算术逻辑单元）</li><li>输入</li><li>输出</li></ul><a id="more"></a><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><ul><li><a href="https://www.weibo.com/p/1001603799832564268572" target="_blank" rel="noopener">文明之光：电子计算机的发明－从图灵到冯诺依曼（上）</a></li><li><a href="http://blog.sina.com.cn/s/blog_ac194d320102vdzu.html" target="_blank" rel="noopener">文明之光：冯诺依曼系统结构和电子计算机的发明（下）</a></li><li><a href="https://www.bilibili.com/video/av30558057?from=search&amp;seid=11377470098091075406" target="_blank" rel="noopener">妈咪说：过目不忘的天才——冯诺依曼的传奇人生 他为何被称作通用计算机之父？</a></li><li><a href="https://www.youtube.com/watch?v=WTbZRcW_iTM" target="_blank" rel="noopener">冯·诺依曼</a></li></ul><blockquote><p>冯·诺依曼由于在曼哈顿工程中需要大量的运算，从而使用了当时最先进的两台计算机 Mark I 和 ENIAC，在使用 Mark I 和 ENIAC 的过程中，他意识到了存储程序的重要性，从而提出了存储程序逻辑架构。</p></blockquote><p>最早的计算机内含固定用途的程序，并非可编程，若想要改变此机器的程序，你必须更改线路、更改结构甚至重新设计机器。而存储程序型计算机的概念改变了这一切。借着将指令当成一种特别类型的静态数据，一台存储程序型计算机可轻易改变其程序，并在程序控制下改变其运算内容。</p><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><p>冯·诺依曼架构第一次 <strong>将存储器和运算器分开</strong>，指令和数据均放置于存储器中，为计算机的 <strong>通用性</strong> 奠定了基础。虽然在规范中计算单元依然是核心，但冯·诺依曼架构事实上导致了 <strong>以存储器为核心</strong> 的现代计算机的诞生。</p><blockquote><p>注：请各位在心里明确一件事情：存储器指的是内存，即 RAM。磁盘理论上属于输入输出设备。</p></blockquote><h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><ol><li><strong>程序可修改很可能是非常具伤害性的</strong>：在一个简单的存储程序型计算机上，一个设计不良的程序可能会伤害自己、其他程序甚或是操作系统，导致死机、缓存溢出就是一个典型例子。而创造或更改其他程序的能力也导致了恶意软件的出现。利用缓存溢出，一个恶意程序可以覆盖调用堆栈（Call stack）并改写代码，并且修改其他程序文件以造成连锁破坏。存储器保护机制及其他形式的访问控制可以保护意外或恶意的代码更动。</li><li><strong>冯·诺伊曼瓶颈（von Neumann bottleneck）</strong>：在内存容量指数级提升以后，CPU 和内存之间的数据传输带宽成为了瓶颈。缓解的办法有：<ol><li>在 CPU 和内存之间提供 cache（缓存，速度比内存快很多倍）</li><li>将数据和指令分开存储并能够做到同时访问（在一般的冯·诺依曼结构中数据和指令放在同一内存通过同一数据总线访问，取数据和取指令不能同时进行，而哈佛结构则是将数据和指令分开，可同时访问）</li><li>分支预测和流水线</li></ol></li></ol><blockquote><p>实际上，绝大多数现代计算机使用的是所谓的“Modified Harvard Architecture”，指令和数据共享同一个 address space，但缓存是分开的。在内存里，指令和数据是在一起的。而在 CPU 内的缓存中，还是会区分指令缓存和数据缓存，最终执行的时候，指令和数据是从两个不同的地方出来的。你可以理解为在 CPU 外部，采用的是冯诺依曼模型，而在 CPU 内部用的是哈佛结构。</p></blockquote><blockquote><p>大部分的<a href="https://zh.wikipedia.org/wiki/%E6%95%B8%E4%BD%8D%E8%A8%8A%E8%99%9F%E8%99%95%E7%90%86%E5%99%A8" target="_blank" rel="noopener">DSP</a>都没有缓存，因而直接就是哈佛结构。</p></blockquote><p><img src="https://i.loli.net/2019/04/22/5cbd7fbac175d.png" alt="TIM图片20190422164727.png"></p><p>上图是 i9-7980XE 18 核 36 线程的民用最强 CPU，其配合超频过的 DDR4 3200MHz 的内存，测试出的内存读取速度为 90GB/S。看起来很快了是不是？看看图中的 L1 Cache，3.7TB/S。</p><p>我们再来算算时间。这颗 CPU 最大睿频 4.4GHz，就是说 CPU 执行一个指令需要的时间是 0.000000000227273 秒，即 0.22ns（纳秒），而内存的延迟是 68.1ns。换句话说，只要去内存里取一个字节，就需要 CPU 等待 300 个周期，何其的浪费 CPU 的时间啊。</p><p>CPU L1 L2 L3 三级缓存是使用和 CPU 同样的 14 纳米工艺制造的硅半导体，每一个 bit 都使用六个场效应管（通俗解释成三极管）构成，成本高昂且非常占用 CPU 核心面积，故不能做成很大容量。</p><p>除此之外，L1 L2 L3 三级缓存对计算机速度的提升来源于计算机内存的「局部性」，相关内容我们之后会专门讨论。</p><p><a href="https://zh.wikipedia.org/zh-hans/%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E5%AD%98%E5%82%A8%E5%99%A8" target="_blank" rel="noopener">RAM</a>（Random Access Memory，俗称 <strong>内存</strong>）：内存最大的特点是：<strong>掉电失去数据</strong>。程序是静态的文件存放在外存中，进程正在运行的程序，进程存放在内存中。我们之所以使用内存是因为内存的速度比外存快 100 倍左右。</p><p><a href="https://zh.wikipedia.org/wiki/%E5%94%AF%E8%AE%80%E8%A8%98%E6%86%B6%E9%AB%94" target="_blank" rel="noopener">ROM</a>（Read-Only Memory，只读存储器）：<strong>ROM 掉电不失去数据</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>什么是字符集和编码</title>
      <link href="/blog/2019/04/21/%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E7%BC%96%E7%A0%81/"/>
      <url>/blog/2019/04/21/%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>文本文件中，为了让比特表示文字，我们发明了字符集，让特定的比特序列对应特定的字符。</p><p>常见的字符集有：</p><ul><li><a href="https://zh.wikipedia.org/wiki/ASCII" target="_blank" rel="noopener">ASCII</a></li><li><a href="https://zh.wikipedia.org/wiki/EASCII" target="_blank" rel="noopener">EASCII</a></li><li><a href="https://zh.wikipedia.org/wiki/GB_2312" target="_blank" rel="noopener">GB2312</a></li><li><a href="https://zh.wikipedia.org/wiki/%E6%B1%89%E5%AD%97%E5%86%85%E7%A0%81%E6%89%A9%E5%B1%95%E8%A7%84%E8%8C%83" target="_blank" rel="noopener">GBK</a></li><li><a href="https://zh.wikipedia.org/wiki/Unicode" target="_blank" rel="noopener">Unicode</a></li><li><a href="https://zh.wikipedia.org/zh/UTF-8" target="_blank" rel="noopener">UTF-8</a> （严格来说 UTF-8 只是 Unicode 的一种编码方式）</li><li><a href="https://baike.baidu.com/item/ANSI%E7%BC%96%E7%A0%81" target="_blank" rel="noopener">ANSI 编码</a></li></ul><a id="more"></a><h2 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h2><p>计算机诞生于美国，因此最早的时候，人们只需要表示英文 26 个字符在内的少数字符，用半个字节就可以表示完这些字符。这就是 ASCII 字符集，最高位为 0，其余 7 位可以表示的范围是：<code>0~127</code>。总共 128 个字符。</p><p>ASCII 字符分为：<strong>控制字符</strong>（不可显示） 和 <strong>可显示字符</strong></p><p>其中，0x20 以下为控制字符，不可显示。比如，0x10 表示换行，0x07 表示发声。另外还有个特殊的控制字符：0x7f 表示删除，所以总共是 33 个控制字符，95 个可显示字符。</p><h2 id="EASCII"><a href="#EASCII" class="headerlink" title="EASCII"></a>EASCII</h2><p>欧洲国家使用计算机之后，也有了创建字符集的需求，于是对 ASCII 进行扩展，使用了剩下一半字节的空间，<code>0x80 - 0xff</code>的定义就被填充成了希腊字母，罗马字母等符号。</p><p>此时，编码依旧控制在 8 位以内，相安无事。</p><h2 id="GB2312"><a href="#GB2312" class="headerlink" title="GB2312"></a>GB2312</h2><blockquote><p>GB 是国标的意思</p></blockquote><p>中国开始使用计算机，于是有了这个字符集，由于中文是象形文字，如果每个字符一个键的话，肯定放不下：</p><p><img src="https://i.loli.net/2019/04/21/5cbc05ae5526e.jpg" alt="1555825210135.jpg"></p><p>但我们有拼音，所以直接用美国键盘就行了。</p><p>GB2312 共收录了 6763 个汉字，其中一级汉字 3755 个，二级汉字 3008 个。它所收录的汉字已经覆盖中国大陆 99.75%的使用频率。</p><p>GB2312 的基本思想很简单，如果一个字符值为 127 及以下，那它就是一个单字节字符，和 ASCII 兼容；如果一个字符值为 127 以上，那它和后面的那个字符组成一个汉字。（同时，后面那个字符也一定是 127 以上的）</p><p>通过这个方式，我们扩展出来了 7000+的简体汉字，同时还把日本假名，罗马希腊字母，数学符号也容纳了进来。</p><p>同时还产生了一个新的概念，全角字符：ASCII 码里本身有的字符，也被我们扩展成了双字节字符。为了区分，前者称为半角字符，后者称为全角字符。比如逗号、冒号、引号等等都有半角和全角之分。</p><p>至此，中文也可以在计算机上表示了。</p><h2 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h2><blockquote><p>K 是扩展的意思</p></blockquote><p>7000 个简体汉字并不能把汉字穷举了，一些生僻字并不包含在 GB2312 里。</p><p>GB2312 表示，我可能还可以抢救一下，我还有另一半的潜力没有发挥呢！</p><p>这另一半的潜力就是，第二个字节的<code>0x00 - 0x7f</code>部分。这部分空出来，是由于 GB2312 表示汉字时，要求两个字节都是在<code>0x80 - 0xff</code>范围内的。</p><p>填上这部分的空档之后，再生僻的字也被表示出来了，同时，我们还考虑到港澳台同胞的感受，包含了繁体字，一共大概增加了 20k 的汉字和符号。</p><h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p>随着时间的推移，互联网的兴起，不止海峡两岸，全世界范围内共建一个字符集的呼声越来越高。</p><p>Unicode，统一了所有地区的字符，且还在不断扩充中。Unicode 编码系统可分为 <strong>编码方式</strong> 和 <strong>实现方式</strong> 两个层次。Unicode 的实现方式称为 Unicode 转换格式（Unicode Transformation Format，简称为 UTF）</p><blockquote><p>UTF-8 兼容 ASCII，UTF-16 不兼容 ASCII。</p></blockquote><h2 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h2><p>前面说的都是字符集，UTF-8 却是一种编码方式，因为它并不是去做字符集的事情，而是为的便于 Unicode 码的传输和存储而生的。UTF-8 兼容 ASCII 编码，所以应用非常广泛，几乎已经是互联网标准。</p><p>与其他的编码方式（如哈夫曼编码）的思想一致，UTF-8 的原则就是，使用不定长字节（1-6 字节）来表达一个字符，使用频率越高的字符，字节数越少。这样就能最大程度上节约空间。具体的编码方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">单字节字符：</span><br><span class="line">    以0开头，后面7位表示字符，事实上，UTF-8的单字节字符就是ASCII字符，完美兼容；</span><br><span class="line">n字节字符：</span><br><span class="line">    第一个字节的前n位为1，第n+1位为0。读到此字节时，可以方便的知道后续多少字节是用来表示一个字符；</span><br><span class="line">    其余字节，以10开头。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Unicode符号范围 | UTF-8编码方式</span><br><span class="line">(十六进制) | （二进制）</span><br><span class="line">—————————————————————–</span><br><span class="line">0000 0000-0000 007F | 0xxxxxxx</span><br><span class="line">0000 0080-0000 07FF | 110xxxxx 10xxxxxx</span><br><span class="line">0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx</span><br><span class="line">0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</span><br></pre></td></tr></table></figure><blockquote><p>实际上从第二行对照开始，就存在空间浪费，因为右边的 x 的位数足够用来表示 0 到左边的第二个数所表示范围内的所有数，每行浪费的空间大小是左边的第一个数。</p></blockquote><p>UTF-8 和 Unicode 是一一对应的，对于常用汉字，基本上都是占用 3 个字节，生僻汉字可能占用到 6 个字节。对于 GB2312 和 GBK 来讲，UTF-8 无疑造成了浪费，所以，UTF-8 可以说是对英文友好，但对中文不友好的一种编码方式。所以在中文界，GB2312 与 GBK 依旧有自己的市场。</p><h2 id="ANSI-编码"><a href="#ANSI-编码" class="headerlink" title="ANSI 编码"></a>ANSI 编码</h2><p>ANSI 并不是确定的一种编码，在简体中文操作系统指的是 GB2312，在繁体操作系统指的是 BIG5。</p><p>Windows 里说的「ANSI」其实是 Windows code pages，这个模式根据当前 locale 选定具体的编码，比如简中 locale 下是 GBK。把自己这些 code page 称作「ANSI」是 Windows 的臭毛病。在 ASCII 范围内它们应该是和 ASCII 一致的。</p><h2 id="字符集（character-set）与编码（encoding）的区别"><a href="#字符集（character-set）与编码（encoding）的区别" class="headerlink" title="字符集（character set）与编码（encoding）的区别"></a>字符集（character set）与编码（encoding）的区别</h2><p>对于 ASCII、GB 2312、Big5、GBK、GB 18030 之类的遗留方案来说，基本上一个字符集方案只使用一种编码方案。</p><p>比如 ASCII 这部标准本身就直接规定了字符和字符编码的方式，所以既是字符集又是编码方案；而 GB 2312 只是一个区位码形式的字符集标准，不过实际上基本都用 EUC-CN 来编码，所以提及「GB 2312」时也说的是一个字符集和编码连锁的方案；GBK 和 GB 18030 等向后兼容于 GB 2312 的方案也类似。</p><p>于是，很多人受这些遗留方案的影响而无法理解字符集和编码的关系。</p><p>对于 Unicode，字符集和编码是明确区分的。Unicode/UCS 标准首先是个统一的字符集标准。而 Unicode/UCS 标准同时也定义了几种可选的编码方案，在标准文档中称作「encoding form」，主要包括 UTF-8、UTF-16 和 UTF-32。</p><p>所以，对 Unicode 方案来说，同样的基于 Unicode 字符集的文本可以用多种编码来存储、传输。所以，用「Unicode」来称呼一个编码方案不合适，并且误导。</p><h2 id="字节顺序标记（BOM）"><a href="#字节顺序标记（BOM）" class="headerlink" title="字节顺序标记（BOM）"></a><a href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E5%85%83%E7%B5%84%E9%A0%86%E5%BA%8F%E8%A8%98%E8%99%9F" target="_blank" rel="noopener">字节顺序标记（BOM）</a></h2><p>这里涉及到一个 <strong><a href="../../../../2019/04/21/计算机中的信息/#字节序">字节序</a></strong> 的概念，请先了解这个概念。</p><p>BOM（Byte-Order Mark）:一种为了跨平台设计的文件起始标记，但很多程序没去处理这个，用了 BOM 反而常造成问题。</p><p>在 UTF-16 中，字节顺序标记被放置为文件或字符串流的第一个字符，以标示字节顺序。</p><ul><li>大端：0xFEFF</li><li>小端：0xFFFE</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机中的信息</title>
      <link href="/blog/2019/04/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF/"/>
      <url>/blog/2019/04/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="信息的本质"><a href="#信息的本质" class="headerlink" title="信息的本质"></a>信息的本质</h2><p><strong>信息的本质是消除不确定性</strong>：我们抛掷一枚硬币，然后用手盖住，出现正面朝上和反面朝上的概率都是二分之一。当我们偷看了结果，确定了是正面还是反面朝上，也就获得了信息。在这个例子中，我们消除的不确定性是一个二分之一的概率。在 <strong><a href="https://zh.wikipedia.org/zh-hans/%E5%85%8B%E5%8A%B3%E5%BE%B7%C2%B7%E9%A6%99%E5%86%9C" target="_blank" rel="noopener">香农</a></strong> 划时代的论文 <strong><a href="http://math.harvard.edu/~ctm/home/text/others/shannon/entropy/entropy.pdf" target="_blank" rel="noopener">通信的数学原理</a></strong> 中，首次提出了信息是可量化的，以及如何量化信息。我们以 bit 为信息的度量单位，一个 bit 可以是 0 或者 1，我们每获得一个 bit 的信息，就会消除一个二分之一的不确定性。</p><blockquote><p>小思考题：如果我们抛掷的是一个骰子呢，当我们确定了一次投掷结果，我们获得多少信息（用 bit 为单位衡量）？<br>我们都知道，骰子有 6 个面，分别刻有 1~6，我们有六分之一的概率得到其中任意一个面朝上。那么我们获得的信息应该是：$\log_2 6$。</p></blockquote><a id="more"></a><h2 id="信息计量单位"><a href="#信息计量单位" class="headerlink" title="信息计量单位"></a>信息计量单位</h2><p>比特（bit）：我们现在所使用的计算机都是二进制的电子计算机，每个 bit 非 0 即 1。之所以使用二进制是因为物理上容易实现，<strong>高电压或低电压</strong>。</p><p>字节（byte）：在计算机中为了方便的管理内存，我们以 8 个比特为一个单位，这个单位叫做字节。</p><blockquote><p>在你购买宽带的时候，比如 100M 宽带，指的是 100Mb/s，换算成字节为单位的速度：$\frac{100Mb/s}{8}=12.5MB/s$。所以我们发现下载速度通常没有听起来那么夸张，因为下载的文件通常是以字节为单位的，而运营商口中的 100M 指的是以比特为单位的速度。</p></blockquote><p>K、M、G：这三个是最常见的倍数单位，可以用来搭配 b（bit）或者 B（Byte）。它们都是词根的缩写，K 是 Kilo，表示$2^{10}$ ；M 是 Mega，表示$2^{20}$ ；G 是 Giga，表示$2^{30}$ 。</p><blockquote><p>其实在一般的场合中，K 表示$10^3$，M 表示$10^6$，G 表示$10^9$。而我们看到上面都是以<code>1024</code>倍递增（$2^{10}=1024$），是 1000 的近似。在你购买硬盘的时候，厂商却是使用 1000 这一套进率的。比如 100GB 的硬盘，其实际容量只有：$\frac{100\times1000^3}{1024^3}=93.13GB$。而内存则是用 1024 进率算的，1GB 的内存就是$2^{30}$个字节，因为采用地址总线寻址，寻址空间必须是$2^n$，否则就会造成内存浪费或者定位到一个不存在的内存。</p></blockquote><p>T、P：这两个如果你是程序员的话会比较常见。T 是 Tera，$2^{40}$；P 是 Peta，$2^{50}$。</p><blockquote><p>往上走还有几个单位，但几乎没机会碰到：<br>1EB（Exabyte 百亿亿字节 艾字节）=1024PB，<br>1ZB (Zettabyte 十万亿亿字节 泽字节)= 1024 EB,<br>1YB (Yottabyte 一亿亿亿字节 尧字节)= 1024 ZB,<br>1BB (Brontobyte 一千亿亿亿字节)= 1024 YB.</p></blockquote><h2 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h2><p><strong>信息是 bit 位+上下文</strong>（这里的信息可以理解为：人能读懂的有意义的信息），比特位中的信息可以根据上下文被任意地解读。举个例子，这里有一个<code>hello.c</code>文件，文件内容如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello, world\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果以 <strong><a href="https://zh.wikipedia.org/wiki/ASCII" target="_blank" rel="noopener">ASCII 编码</a></strong> 的话，每个字节的内容如下：</p><p><img src="https://i.loli.net/2019/04/21/5cbbc51c0887c.png" alt="一份C程序的ASCII码表示.png"></p><ul><li>文本文件：内容是文本，文本文件都会采用一种特定的编码方式</li><li>二进制文件：除去文本文件，其他的都是二进制文件</li></ul><blockquote><p>如果你碰到过乱码问题，那么可以尝试了解一下：<a href="../../../../2019/04/21/什么是字符集和编码/">什么是字符集和编码</a></p></blockquote><p>Windows 记事本的 bug（具体原因可以自己上网查）：</p><ul><li>新建一个文本文件，输入“写”，保存之后再打开，乱码<code>д</code>。</li><li>新建一个文本文件，输入“联通”，保存之后再打开，乱码<code>��ͨ</code>。</li></ul><h2 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h2><p>计算机的内存地址是按字节编号，比如 4GB 的内存，它的内存地址从 0 到$2^{30}$，这里有个问题就是多字节的数据如何确定存放顺序。有的计算机采用 <strong>大端</strong> 有的则采用 <strong>小端</strong>。</p><p>假设我有一个 int 型数（4 字节）：0x29 16 10 57</p><p>29 是高位，57 是低位，如果高位存放的内存地址也是高地址，那么我们就称之为 <strong>大端</strong> 字节序。反之就是 <strong>小端</strong> 字节序。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ map的remove函数实现</title>
      <link href="/blog/2019/04/15/C++%E7%9A%84map%E7%9A%84remove%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0/"/>
      <url>/blog/2019/04/15/C++%E7%9A%84map%E7%9A%84remove%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>今天同学群里面讨论了这样一段代码，说是产品出了bug，现场急着修复。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello world"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; mapPeople;</span><br><span class="line">    mapPeople[<span class="number">1</span>] = <span class="string">"hexu1"</span>;</span><br><span class="line">    mapPeople[<span class="number">2</span>] = <span class="string">"hexu2"</span>;</span><br><span class="line">    <span class="comment">// mapPeople[3] = "hexu3";</span></span><br><span class="line">    <span class="comment">// mapPeople[4] = "hexu4";</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;::iterator iter = mapPeople.begin();</span><br><span class="line">    <span class="keyword">for</span> (; iter != mapPeople.end(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;first == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"id : "</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">", name : "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            mapPeople.erase(iter++);</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (iter != mapPeople.end()) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//for (; iter != mapPeople.end();)</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//if (iter-&gt;first == 2)</span></span><br><span class="line">    <span class="comment">//&#123;</span></span><br><span class="line">    <span class="comment">//std::cout &lt;&lt; "id : " &lt;&lt; iter-&gt;first &lt;&lt; ", name : " &lt;&lt; iter-&gt;second &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">//mapPeople.erase(iter++);</span></span><br><span class="line">    <span class="comment">//if (iter == mapPeople.end())</span></span><br><span class="line">    <span class="comment">//break;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//iter++;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    getchar();</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说是第一个for循环会崩溃，第二个for循环可以通过。经过分析，主要问题其实是出在对迭代器和erase的不熟悉上，导致错误的使用，这个程序的错误很明显，就是在erase这条分支中，iter++了两次。那么如何写一个正确的remove函数呢？代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hello world"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; mapPeople;</span><br><span class="line">    mapPeople[<span class="number">1</span>] = <span class="string">"hexu1"</span>;</span><br><span class="line">    mapPeople[<span class="number">2</span>] = <span class="string">"hexu2"</span>;</span><br><span class="line">    mapPeople[<span class="number">3</span>] = <span class="string">"hexu3"</span>;</span><br><span class="line">    mapPeople[<span class="number">4</span>] = <span class="string">"hexu4"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;::iterator iter = mapPeople.begin();</span><br><span class="line">    <span class="keyword">while</span> (iter != mapPeople.end())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;first == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"id : "</span> &lt;&lt; iter-&gt;first &lt;&lt; <span class="string">", name : "</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            iter = mapPeople.erase(iter);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        iter++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，碰到删除的时候，要小心，可以这么写：<code>iter = mapPeople.erase(iter);</code>，也可以这么写：<code>mapPeople.erase(iter++);</code>（必须在删除前给迭代器++，否则迭代器会失效，这个问题那位程序员倒是考虑到了）。</p><p>最后我想说的一点是，根据指定key删除map中的元素，这个功能在其他语言中都有库函数可以调用，而C++却没有，还要自己动手写，而且需要对map的原理有一定的了解。这就从侧面反映了C++可能并不是一个高效的生产工具。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo把英文引号渲染成中文引号的问题</title>
      <link href="/blog/2019/04/15/hexo%E6%8A%8A%E8%8B%B1%E6%96%87%E5%BC%95%E5%8F%B7%E6%B8%B2%E6%9F%93%E6%88%90%E4%B8%AD%E6%96%87%E5%BC%95%E5%8F%B7%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/blog/2019/04/15/hexo%E6%8A%8A%E8%8B%B1%E6%96%87%E5%BC%95%E5%8F%B7%E6%B8%B2%E6%9F%93%E6%88%90%E4%B8%AD%E6%96%87%E5%BC%95%E5%8F%B7%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>其实这个问题我早就发现了，但一直没太在意，今天写博客的时候又看到这个难看的引号，终于忍不住想看看到底出了什么问题。</p><p>首先我试了中文的单引号和英文的单引号，发现渲染效果都一样，然后想看看当我分别打中文单引号和英文单引号的时候，hexo 的渲染结果到底是不是一样。</p><p>打开 chrome 开发工具，发现页面上的英文单引号统一被渲染成了中文的单引号。</p><p>然后我手动修改页面看了下英文单引号是什么样子，发现样式确实很不一样。</p><p>那么问题就确定了：hexo 把英文引号渲染成了中文引号。</p><a id="more"></a><p>谷歌搜了一下：<code>hexo 渲染 单引号 中文单引号</code>，得到几条不错的结果：</p><ul><li><a href="https://github.com/hexojs/hexo/issues/1981" target="_blank" rel="noopener">求助：单引号显示异常 #1981</a></li><li><a href="https://github.com/theme-next/hexo-theme-next/issues/462" target="_blank" rel="noopener">6.4.0 版本之后的两个问题 #462</a></li></ul><p>对于我所使用的<code>kramed</code>，只需要在<code>_config.yml</code>中配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kramed:</span><br><span class="line">  smartypants: false</span><br></pre></td></tr></table></figure><p>问题的原因是 markdown 渲染器把英文引号渲染成了中文引号，但这其实是可以配置的，所以解决起来比较简单。</p><p>在解决这个问题的过程中，如果你想顺利的解决问题，你需要的知识点有：</p><ul><li><strong>字符集的知识</strong></li><li><strong>Chrome 开发工具使用经验</strong></li><li><strong>前端开发知识</strong></li><li><strong>好的搜索习惯</strong></li><li><strong>一定的英语水平</strong></li><li><strong>查阅文档的意识和习惯</strong></li></ul><p>如果你已经具备了以上前提，那么就能比较轻松愉快的解决这个问题了。</p>]]></content>
      
      
      <categories>
          
          <category> debug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>动态数组的分摊分析</title>
      <link href="/blog/2019/03/03/%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%86%E6%91%8A%E5%88%86%E6%9E%90/"/>
      <url>/blog/2019/03/03/%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%86%E6%91%8A%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>动态数组在每次容量用尽时，重新申请 2 倍于当前数组的空间，并将原数组中的内容拷贝到新的空间，然后释放原数组的内存空间。对于动态数组，每次插入的花费有两种情况：</p><ol><li>容量够用，我们只需要存储新的元素</li><li>容量不够用，创建新的空间，拷贝原数组进新的空间，再存储这个新的元素</li></ol><p>分析方法有许多，统称为：amortized analysis（分摊分析）</p><a id="more"></a><p><a href="https://www.cs.cornell.edu/courses/cs3110/2013sp/lectures/lec21-amortized/lec21.html" target="_blank" rel="noopener">Lecture 21: Amortized Analysis</a></p><h3 id="统计分析（aggregate-method）"><a href="#统计分析（aggregate-method）" class="headerlink" title="统计分析（aggregate method）"></a>统计分析（aggregate method）</h3><p>把 n 词操作花费求和，然后取平均值。</p><p>每次扩容时，后半部分元素统一进行第一次移动，而这些元素之后的所有移动操作也是一起发生的，因而我们发现元素是以组为单位，组内的元素移动次数相同。那么有多少个这种组呢？第一组是单个元素，第二组也是单个元素，第三组是两个元素，第四组是四个元素，第五组是 8 个元素，... ，以此类推。而：</p><p>$$<br>1 + 1 + 2+ 2^2 + \cdots + 2^i = n<br>$$</p><p>$$<br>i = \log_2 n -1<br>$$</p><p>而这些组的移动次数分别是多少呢？最后一组元素只移动一次，倒数第二组元素移动 2 次，以此类推。所以总的移动次数是：</p><p>$$<br>1\times 2^i+2\times 2^{i-1}+3\times 2^{i-2}+\cdots+k\times 1<br>$$</p><p>$$<br>k = \log_2n + 1<br>$$</p><p>这个式子挺有规律的，我们可以将其分为很多个组，第一组是：</p><p>$$<br>1 + 1 + 2+ 2^2 + \cdots + 2^i = n<br>$$</p><p>第二组是：</p><p>$$<br>1 + 1 + 2+ 2^2 + \cdots + 2^{i-1} = \frac{n}{2}<br>$$</p><p>以此类推。</p><p>于是我们得到上式的等价表示：</p><p>$$<br>n + \frac{n}{2} + \cdots + 1 = 2n-1<br>$$</p><p>所以移动的平均次数是：$\frac{2n-1}{n}$，也就是每个元素最多移动 2 次，加上插入操作，最多三个操作。</p><h3 id="银行算法（banker-method）"><a href="#银行算法（banker-method）" class="headerlink" title="银行算法（banker method）"></a>银行算法（banker method）</h3><p>对动态数组的插入来说，大部分（后半部分）插入操作是不需要重新分配内存的，是廉价的操作。而少部分操作是需要重新分配内存的，是复杂的操作。我们可以试着想象在每次廉价操作的时候存储额外的费用，相当于存款，来支付复杂操作的费用。</p><p>我们假设一次基本的操作费用是一个硬币，当我们插入了一个下标为 n 的元素时：</p><ol><li>我们要花费第一个硬币，作为基本的插入操作花费</li><li>我们还要存储第二个硬币，作为新插入的 n 在重新分配内存时移动它的费用</li><li>最后我们要存储第三个硬币，作为数组的前半部分的某个对应元素重新分配内存时移动费用</li></ol><p>这样来计算，每个插入操作最多需要付出三个硬币，而第一个元素是不需要第三个硬币的。所以费用总数是：3n-1。</p><h3 id="势能算法（Potential-Method）"><a href="#势能算法（Potential-Method）" class="headerlink" title="势能算法（Potential Method）"></a>势能算法（Potential Method）</h3><p>首先说明一下，目前我对这个方法还是无法直观的理解。先祭出这个势能函数：</p><p>$$<br>\Phi(h) = 2n-m<br>$$</p><p>其中 n 是当前数组元素的个数，m 是当前数组内存空间大小。</p><p>每次插入的费用函数定义为：</p><p>$$<br>c+\Phi(h&#39;)-\Phi(h)<br>$$</p><p>c 表示当前插入操作的总的花费，$\Phi(h&#39;)$是插入后的势能函数，$\Phi(h)$是插入前的势能函数。</p><p>这里分为两种情况：</p><ol><li>如果<code>n&lt;m</code>，不必扩容，c=1，势能函数相差 2，所以加起来是 3</li><li>如果<code>n=m</code>，那么就要扩容，c=n+1，$\Phi(h&#39;)=2(n+1)-2n$，$\Phi(h)=2n-n$，加起来还是 3</li></ol><p>所以费用函数其实是一个等于 3 的常数函数。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="/blog/2019/02/19/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>/blog/2019/02/19/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>快速排序算法是一个原理非常简单易懂的算法，但如果现场手写的话又有多少人能写得出来呢？我今天又试了一下，发现还是存在一些认知上的问题。首先我明白快排的核心操作是：<strong>选取一个中枢，然后把小于中枢的放到左边，大于中枢的放到右边</strong>。但我发现时隔仅仅一年多，我居然已经忘了这个操作的英文名字了。直到我在写这篇文章的时候才突然想起来：partition 操作。</p><p>在使用 partition 操作的前提下，递归解决问题就 OK 了。</p><a id="more"></a><p>partition 具体操作如下：</p><p>我选取的中枢是第一个元素，且从前往后遍历数组。遇到小于中枢的，我要交换当前结点和中枢。遇到大于中枢的，直接略过。</p><p>第一个分支也就是遇到小于中枢的结点，这里才是操作比较复杂的部分，仔细想想其实这里要交换两次。将小于中枢的结点与中枢交换之后，中枢跑到了最后面，此时的结构相当于：<code>小小小..大大大..中枢</code>。<strong>我们还要将中枢塞到中间去</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">qsort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(begin&gt;=end-<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> pivotIndex = partition(array, begin, end);</span><br><span class="line">    qsort(array, begin, pivotIndex);</span><br><span class="line">    qsort(array, pivotIndex+<span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = array[begin];</span><br><span class="line">    <span class="keyword">int</span> pivotIndex = begin;</span><br><span class="line">    <span class="keyword">int</span> index = begin+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(index&lt;end)&#123;</span><br><span class="line">        <span class="keyword">if</span>(array[index]&lt;pivot)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = array[index];</span><br><span class="line">            array[index] = array[pivotIndex];</span><br><span class="line">            array[pivotIndex++] = temp;</span><br><span class="line">            temp = array[index];</span><br><span class="line">            array[index] = array[pivotIndex];</span><br><span class="line">            array[pivotIndex] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pivotIndex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以思考一下：</p><ul><li>选第一个元素做中枢，从后往前遍历</li><li>选最后一个元素做中枢，从前往后遍历</li><li>选最后一个元素做中枢，从后往前遍历</li></ul><p>所以最后我发现快速排序确实是一个简单易懂的算法，难点在于 partition 操作的具体问题具体分析。四类 partition 全部写一遍。应该差不多了。</p><p>上面的方法归根结底都是使用 <strong>一个中枢</strong> 来划分，实际上也可以用两个指针来划分：一个记录小部的末尾，一个记录大部的首部。这两个指针一个从前往后，一个从后往前，直到相遇，本轮划分操作就结束。</p><p>于是我又抽空写了一下这个两个指针往中间靠的，结果并没有一遍写对，原因是边界检查，居然要不停的检查：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">partition1</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = array[begin];</span><br><span class="line">    <span class="keyword">int</span> smallEnd = begin;</span><br><span class="line">    <span class="keyword">int</span> bigBegin = end-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(smallEnd&lt;bigBegin)&#123;</span><br><span class="line">        <span class="keyword">while</span> (smallEnd&lt;bigBegin &amp;&amp; array[bigBegin]&gt;pivot)&#123;</span><br><span class="line">            bigBegin--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(smallEnd&lt;bigBegin)&#123;</span><br><span class="line">            array[smallEnd++] = array[bigBegin];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(smallEnd&lt;bigBegin &amp;&amp; array[smallEnd]&lt;pivot)&#123;</span><br><span class="line">            smallEnd++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(smallEnd&lt;bigBegin)&#123;</span><br><span class="line">            array[bigBegin--] = array[smallEnd];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    array[smallEnd] = pivot;</span><br><span class="line">    <span class="keyword">return</span> smallEnd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样感觉就太不美了。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>并查集</title>
      <link href="/blog/2019/01/19/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/blog/2019/01/19/%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h3 id="什么是并查集"><a href="#什么是并查集" class="headerlink" title="什么是并查集"></a>什么是并查集</h3><p>并查集的核心是<code>parent</code>指针，一个结点可以找到自己所属的结点。从而把结点<strong>归类</strong>。有两个核心操作：</p><ul><li>Union（用来合并两个并查集）</li><li>Find（用于查找一个结点的<code>parent</code>）</li></ul><p>所以并查集可以叫做：union-find data structure。</p><a id="more"></a><h3 id="什么是路径压缩"><a href="#什么是路径压缩" class="headerlink" title="什么是路径压缩"></a>什么是路径压缩</h3><p>我们看两个结点是否属于同一个并查集，实际上只看最顶层的那个<code>parent</code>，如果这两个结点属于同一个最顶层<code>parent</code>，那么它们就在同一个并查集中。</p><p>所以我们实际上只需要两层的树结构，让所有其他结点的<code>parent</code>指针指向最顶层<code>parent</code>，这样就能达到扁平化并查集的目的，从而使<code>Find</code>操作从<code>O(logN)</code>的时间复杂度变成<code>O(1)</code>。这就叫：<strong>路径压缩</strong></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findParent</span><span class="params">(UnionFindSetNode node)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(node.parent!=node)&#123;</span><br><span class="line">        node.parent = findParent(node.parent);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node.parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码很巧妙，可以在查找本结点父亲的时候，将路径上的所有祖先扁平化。</p><h3 id="合并操作"><a href="#合并操作" class="headerlink" title="合并操作"></a>合并操作</h3><p>核心目标是：尽可能减少深度。所以需要注意的点是：把深度小的并查集归并到深度大的并查集。我们给并查集多添加一个深度属性：rank，比如两层的并查集，parent 的 rank 就是 1，叶子节点们的 rank 就是 0。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(UnionFindSetNode node1, UnionFindSetNode node2)</span></span>&#123;</span><br><span class="line">    UnionFindSetNode parent1 = findParent(node1);</span><br><span class="line">    UnionFindSetNode parent2 = findParent(node2);</span><br><span class="line">    <span class="keyword">if</span>(parent1!=parent2)&#123;</span><br><span class="line">        <span class="keyword">if</span>(parent1.rank&gt;parent2.rank)&#123;</span><br><span class="line">            parent2.parent = parent1;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(parent1.rank&lt;parent2.rank)&#123;</span><br><span class="line">            parent1.parent = parent2;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            parent1.parent = parent2;</span><br><span class="line">            parent2.rank++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>KMP算法</title>
      <link href="/blog/2019/01/17/KMP%E7%AE%97%E6%B3%95/"/>
      <url>/blog/2019/01/17/KMP%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="KMP-算法"><a href="#KMP-算法" class="headerlink" title="KMP 算法"></a>KMP 算法</h2><p>KMP 算法用来在一个文本中查找模式串，如下图所示：</p><p>文本匹配例子：</p><p><img src="https://i.loli.net/2019/02/01/5c545a0ceea57.jpg#align=left&amp;display=inline&amp;height=78&amp;linkTarget=_blank&amp;originHeight=78&amp;originWidth=392&amp;width=392" alt></p><p>我们把上面那个长字符串的称为<strong>文本</strong>，下面这个短的称为<strong>模式串</strong>。我们的目的是查看<code>ABADABAD</code>是否出现在文本中。</p><p>不必要的比较：</p><p><img src="https://i.loli.net/2019/02/01/5c545a0d27686.jpg#align=left&amp;display=inline&amp;height=100&amp;linkTarget=_blank&amp;originHeight=100&amp;originWidth=418&amp;width=418" alt></p><p>跳过不必要的比较：</p><p><img src="https://i.loli.net/2019/02/01/5c545a0cf058c.jpg#align=left&amp;display=inline&amp;height=90&amp;linkTarget=_blank&amp;originHeight=90&amp;originWidth=410&amp;width=410" alt></p><p>KMP 算法的核心作用在于帮助模式串顺利的跳过很多不必要的比较（模式串没有任何前缀与文本匹配），直接后移到一部分前缀已经匹配的位置，开始下一次的比较。更准确的讲是移动到：最长真前后缀匹配的位置，如上图所示的<code>ABA</code>。</p><a id="more"></a><h3 id="什么是真前后缀"><a href="#什么是真前后缀" class="headerlink" title="什么是真前后缀"></a>什么是真前后缀</h3><p>前缀和后缀我们都不陌生，比如单词<code>ABA</code>，它有三个前缀：<code>A</code>、<code>AB</code>、<code>ABA</code>，和三个后缀：<code>A</code>、<code>BA</code>、<code>ABA</code>。</p><p>真前后缀的意思是，前后缀必须是单词的<strong>真子集</strong>，也就是说不能是单词本身。所以上面那个单词<code>ABA</code>的真前缀是：<code>A</code>、<code>AB</code>，真后缀是：<code>A</code>、<code>BA</code>。</p><p>那么单词<code>ABA</code>真前后缀的最长匹配是：<code>A</code>。</p><h4 id="那么真前后缀是否匹配有什么用？"><a href="#那么真前后缀是否匹配有什么用？" class="headerlink" title="那么真前后缀是否匹配有什么用？"></a>那么真前后缀是否匹配有什么用？</h4><p>我们仔细观察文章最开头的文本匹配例子。在不必要的比较中，我们拿<code>BADABA</code>和<code>ABADAB</code>比较。而这两个，前者是模式串<code>ABADABA</code>部分的后缀，后者则是前缀。如果我们算得了<code>ABADABA</code>的真前后缀的最长匹配，就已经知道了<code>BADABA</code>和<code>ABADAB</code>不相等。而且还知道<code>ADABA</code>和<code>ABADA</code>也不相等，等等。</p><p><strong>只要我们知道了真前后缀的最长匹配是什么，我们可以直接跳过所有这些没必要的比较。</strong></p><p>KMP 的核心就是：<strong>在每一次失配的时候</strong>，利用最长真前后缀匹配长度，直接跳过不必要的比较。</p><h3 id="next-数组"><a href="#next-数组" class="headerlink" title="next 数组"></a>next 数组</h3><p>next 数组也就是：部分匹配表（Partial Match Table）。<strong>就是一个最长真前后缀匹配长度表。</strong></p><p><strong>首先 next 数组只需要用模式串得出，它是对模式串的解析，跟要匹配的文本没有半毛钱关系。</strong>其次 next 数组记录的其实就是<strong>最长真前后缀匹配长度</strong>，但错开了一位。</p><blockquote><p>真前后缀的意思是，前后缀不能是字符串本身，只能是字符串的真子集</p></blockquote><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th></tr></thead><tbody><tr><td style="text-align:center">模式串</td><td style="text-align:center">A</td><td style="text-align:center">B</td><td style="text-align:center">A</td><td style="text-align:center">D</td><td style="text-align:center">A</td><td style="text-align:center">B</td><td style="text-align:center">A</td><td style="text-align:center">D</td><td style="text-align:center">\0</td></tr><tr><td style="text-align:center">next[i]</td><td style="text-align:center">-1</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td></tr></tbody></table><ol><li>i = 0，<code>next[0]</code>，我们填-1；</li><li>i = 1，前面的字符串为<code>A</code>，其最长相同真前后缀长度为 0，即<code>next[1] = 0</code>；</li><li>i = 2，前面的字符串为<code>AB</code>，其最长相同真前后缀长度为 0，即<code>next[2] = 0</code>；</li><li>i = 3，前面的字符串为<code>ABA</code>，其最长相同真前后缀为<code>A</code>，即<code>next[3] = 1</code>；</li><li>i = 4，前面的字符串为<code>ABAD</code>，其最长相同真前后缀长度为 0，即<code>next[4] = 0</code>；</li><li>i = 5，前面的字符串为<code>ABADA</code>，其最长相同真前后缀长度为<code>A</code>，即<code>next[5] = 1</code>；</li><li>i = 6，前面的字符串为<code>ABADAB</code>，其最长相同真前后缀长度为<code>AB</code>，即<code>next[6] = 2</code>；</li><li>i = 7，前面的字符串为<code>ABADABA</code>，其最长相同真前后缀为<code>ABA</code>，即<code>next[7] = 3</code>；</li><li>i = 8，前面的字符串为<code>ABADABAD</code>，其最长相同真前后缀为<code>ABAD</code>，即<code>next[8]=4</code>；</li></ol><p>这张 next 表极其有用，前面说了，在字符串匹配的每一次失配的时候，我们都可以用已经匹配上的这段字符串的最长真前后缀匹配长度来定位将要跳转的位置。还是拿最开始的文本匹配例子：</p><p>当图一失配的时候，我们查<code>ABADABAD</code>的失配位置的 next 数组，也就是<code>next[7]</code>，得到<code>ABADABA</code>的最长真前后缀匹配长度<code>3</code>，然后拿<code>&quot;ABADABAD&quot;.charAt(3)</code>也就是<code>D</code>跟文本中失配处的字符<code>&#39; &#39;</code>继续匹配。如果又失配，那么递归处理。递归的边界是什么？答案是<code>next[0]</code>。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>这个代码并不难写，我简单讲一下。</p><p>首先我们需要构造 next 数组，需要的参数只有一个：模式串。</p><p>然后我们使用一个指针<strong>遍历模式串</strong>，另一个指针负责<strong>记录匹配深度</strong>。</p><blockquote><p><strong>生成 next 数组，也是一个匹配的过程</strong>，遇到不匹配也要跳过不必要的比较，所以这实际上是一个递归的问题。</p></blockquote><p>分支只有两个，<strong>匹配的时候</strong>：i++，j++，next[i]=j。<strong>不匹配的时候</strong>，递归查找下一个必要的匹配：j=next[j]。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] getNextArray(String pattern)&#123;</span><br><span class="line">    <span class="keyword">int</span>[] nextArray = <span class="keyword">new</span> <span class="keyword">int</span>[pattern.length()+<span class="number">1</span>];</span><br><span class="line">    nextArray[<span class="number">0</span>]=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j=-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;pattern.length())&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==-<span class="number">1</span> || pattern.charAt(i)==pattern.charAt(j))&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">            nextArray[i]=j;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j = nextArray[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nextArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">KMP</span><span class="params">(String text, String pattern)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] nextArray = getNextArray(pattern);</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;text.length() &amp;&amp; j&lt;pattern.length())&#123;</span><br><span class="line">        <span class="keyword">if</span>(j==-<span class="number">1</span> || text.charAt(i)==pattern.charAt(j))&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            j = nextArray[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j==pattern.length())&#123;</span><br><span class="line">        <span class="keyword">return</span> i-j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当然这种错开，和<code>next[0]=-1</code>的设定，不那么自然。其实可以有更自然的设计：</p></blockquote><table><thead><tr><th style="text-align:center">i</th><th style="text-align:center">0</th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th><th style="text-align:center">7</th><th style="text-align:center">8</th></tr></thead><tbody><tr><td style="text-align:center">模式串</td><td style="text-align:center">A</td><td style="text-align:center">B</td><td style="text-align:center">A</td><td style="text-align:center">D</td><td style="text-align:center">A</td><td style="text-align:center">B</td><td style="text-align:center">A</td><td style="text-align:center">D</td><td style="text-align:center">\0</td></tr><tr><td style="text-align:center">next[i]</td><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">4</td></tr></tbody></table><p>这样一一对应就行了，next 数组也与模式串等长。</p><p>这种 next 表的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] getNextArray(String pattern)&#123;</span><br><span class="line">    <span class="keyword">int</span>[] nextArray = <span class="keyword">new</span> <span class="keyword">int</span>[pattern.length()];</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;pattern.length())&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; pattern.charAt(i)!=pattern.charAt(j))&#123;</span><br><span class="line">            j = nextArray[j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;pattern.length() &amp;&amp; pattern.charAt(i)==pattern.charAt(j))&#123;</span><br><span class="line">            nextArray[i++] = ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">            nextArray[i++] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nextArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">KMP</span><span class="params">(String text, String pattern)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] nextArray = getNextArray(pattern);</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;text.length() &amp;&amp; j&lt;pattern.length())&#123;</span><br><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">0</span> &amp;&amp; text.charAt(i)!=pattern.charAt(j))&#123;</span><br><span class="line">            j = nextArray[j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;text.length() &amp;&amp; j&lt;pattern.length() &amp;&amp; text.charAt(i)==pattern.charAt(j))&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j==pattern.length())&#123;</span><br><span class="line">        <span class="keyword">return</span> i-j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码看起来远不如上面第一种 next 表的代码简洁清晰。下面做一个简化，去掉内部的循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] getNextArray(String pattern)&#123;</span><br><span class="line">    <span class="keyword">int</span>[] nextArray = <span class="keyword">new</span> <span class="keyword">int</span>[pattern.length()];</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;pattern.length())&#123;</span><br><span class="line">        <span class="keyword">if</span>(j&gt;<span class="number">0</span> &amp;&amp; pattern.charAt(i)!=pattern.charAt(j))&#123;</span><br><span class="line">            j = nextArray[j-<span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pattern.charAt(i)==pattern.charAt(j))&#123;</span><br><span class="line">            nextArray[i++] = ++j;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">            nextArray[i++] = j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nextArray;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">KMP</span><span class="params">(String text, String pattern)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] nextArray = getNextArray(pattern);</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;text.length() &amp;&amp; j&lt;pattern.length())&#123;</span><br><span class="line">        <span class="keyword">if</span>(j&gt;<span class="number">0</span> &amp;&amp; text.charAt(i)!=pattern.charAt(j))&#123;</span><br><span class="line">            j = nextArray[j-<span class="number">1</span>];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(text.charAt(i)==pattern.charAt(j))&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span>)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j==pattern.length())&#123;</span><br><span class="line">        <span class="keyword">return</span> i-j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看代码很容易知道，文本的指针是只增不减的，而且只在<strong>失配且匹配深度大于 0</strong>的时候递归处理失配情况。但如何精确分析算法复杂度呢？</p><h2 id="算法复杂度分析"><a href="#算法复杂度分析" class="headerlink" title="算法复杂度分析"></a>算法复杂度分析</h2><p>这个算法的分析属于平摊分析。引入一个变量 k，<code>k=2*i-j</code>。观察下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(j&lt;m &amp;&amp; i&lt;n)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span>&gt;j || T[i]==P[j])&#123;</span><br><span class="line">        i++;j++;    <span class="comment">// k加1</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        j = next[j];    <span class="comment">// j至少减一，i不变，那么k至少加1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由上述注释分析得出：k 单调递增。k 的最大值是<code>2*n+1</code>，而 k 是迭代次数的上界，所以算法最坏时间是：<code>2*n+1</code>，所以这是一个<code>O(n)</code>的算法。同理可得算出<code>next</code>表的时间复杂度是<code>O(m)</code>。所以总的算法复杂度是<code>O(m+n)</code>。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>蓄水池算法</title>
      <link href="/blog/2019/01/15/%E8%93%84%E6%B0%B4%E6%B1%A0%E7%AE%97%E6%B3%95/"/>
      <url>/blog/2019/01/15/%E8%93%84%E6%B0%B4%E6%B1%A0%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="蓄水池算法-Reservoir-Sampling"><a href="#蓄水池算法-Reservoir-Sampling" class="headerlink" title="蓄水池算法(Reservoir Sampling)"></a>蓄水池算法(Reservoir Sampling)</h2><p>这个算法真的很奇妙，它的核心是一个<strong>数学证明</strong>。外延，或者说应用场景是：</p><ol><li>$C_n^k$，也就是从大小为 n 的样本集中随机取 k 个不同的样本</li><li>流式数据，或者说无法直接根据索引拿到数据（更加不可能一遍加载到内存）</li></ol><a id="more"></a><h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><p>算法的描述其实很简单：<a href="https://zh.wikipedia.org/zh-cn/%E6%B0%B4%E5%A1%98%E6%8A%BD%E6%A8%A3" target="_blank" rel="noopener">维基百科：水塘抽样</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">问题描述：从包含n个不同的项目的集合S中随机选取k个不同的样本。</span><br><span class="line">算法：</span><br><span class="line">从S中取首k个放入[水塘]中</span><br><span class="line">对每个S[j]项（j&gt;=k，数组从0开始）：</span><br><span class="line">true随机产生一个范围从0到j的整数r</span><br><span class="line">true若r&lt;k则把水塘中的第r项换成S[j]项</span><br><span class="line">最后得到的水塘就是抽样结果</span><br></pre></td></tr></table></figure><p>这个算法保证了每一项最后可能存在于水塘中的概率都是一样的。</p><p>单看算法，你肯定不知道为什么是等概率，其实数学证明并不难，请看下面的证明：</p><h3 id="数学证明"><a href="#数学证明" class="headerlink" title="数学证明"></a>数学证明</h3><p>我们把样本分为两类：</p><ol><li>一类是首 k 个，它们一开始就在水塘中</li><li>一类是其他，它们一开始并不在水塘中</li></ol><p>我们发现两个简单的逻辑：</p><ol><li><strong>对于水塘中的样本，只要随机数不选到该样本，该样本就不会被替换</strong></li><li><strong>水塘的某个项一旦被替换，就不可能再回到水塘</strong>，不会出现被替换掉，然后再回到水塘的局面，这样就保证了问题不会进一步变得复杂。所以：<strong>某个项被保留的概率 = 被选中到水塘的概率 * 后续不被替换的概率</strong></li></ol><p>分类讨论，首 k 个样本最终存在于水塘中的概率，和其余样本最终存在于水塘中的概率：</p><ol><li>首 k 个样本，随便选一个做研究对象。被选中到水塘的概率为：1。（数组从 1 开始）从 j=k+1 开始考虑替换，第一次不被替换的概率是$\frac{k}{k+1}$，第二次不被替换的概率是$\frac{k+1}{k+2}$，第三次...，一直到最后一次不被替换的概率是$\frac{n-1}{n}$。<br><br>所以该项被保留的概率 = $1\times\frac{k}{k+1}\times\frac{k+1}{k+2}\times\frac{k+2}{k+3}\times\cdots\times\frac{n-1}{n}=\frac{k}{n}$</li><li>一开始不在水塘中的那一部分，随便选一个做研究对象。被选中到水塘的概率为：$\frac{k}{j}$，后续不被替换的概率$\frac{j}{j+1}$，一直到$\frac{n-1}{n}$。<br><br>所以该项被保留的概率 = $\frac{k}{j}\times\frac{j}{j+1}\times\cdots\frac{n-1}{n}=\frac{k}{n}$</li></ol><p>到此我们就证明了所以样本最终存在于水塘中的概率都是$\frac{k}{n}$，这也完全符合了我们的数学期望。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>弄个流式数据我们这里没有条件，只能用伪代码模拟一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Data[] reservoirSampling(<span class="keyword">int</span> k, DataStream dataStream)&#123;</span><br><span class="line">    Data[] reservoir = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// init pool</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;reservoir.length;i++)&#123;</span><br><span class="line">        reservoir[i] = dataStream.getCurrentData();</span><br><span class="line">        dataStream.toNext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=k;!dataStream.isFinish();i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> d = random.nextInt(i+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(d&lt;k)&#123;</span><br><span class="line">            reservoir[d] = dataStream.getCurrentData();</span><br><span class="line">        &#125;</span><br><span class="line">        dataStream.toNext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> reservoir;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>$\lim\limits_{x\rightarrow 0} \frac{\sin x}{x} = 1$的证明</title>
      <link href="/blog/2019/01/07/%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%9E%81%E9%99%90%E7%9A%84%E8%AF%81%E6%98%8E/"/>
      <url>/blog/2019/01/07/%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%9E%81%E9%99%90%E7%9A%84%E8%AF%81%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<p>高数中的第一个证明，可能就是这个$\lim\limits_{x\rightarrow 0} \frac{\sin x}{x} = 1$的证明了。下面给出这个极限的证明，用到了解析几何（作图法）。</p><a id="more"></a><blockquote><p>作图工具 Geometry</p></blockquote><p><img src="https://i.loli.net/2019/01/07/5c3351ce31372.jpg" alt="1546867129927.jpg"></p><p>如图我们可以看到，有一个单位圆，圆心为 $A$ ，线段 $CE$ 的长度等于 $\sin x$，线段 $CB$ 是 <strong>弦</strong>（我们令他等于 $a$），弧 $\overset{\frown} {CB}$ 的长度就是 $x$，线段 DB 的长度等于 $\tan x$。</p><p>它们的长度的大小关系我们很容易得出：</p><ol><li>$\sin x &lt; a$，因为三角形的直角边小于斜边</li><li>$a &lt; x$，因为两点之间线段最短</li><li>$x &lt; \tan x$，这个略微不那么直接，可以用面积法（通过比较面积继而得到表达式中两个未知数的大小关系），扇形 $CAB$ 的面积：$\frac{1}{2} \cdot 1 \cdot x$ ，三角形 $\triangle DAB$ 的面积：$\frac{1}{2} \cdot 1 \cdot \tan x$ 。而 $CAB$ 的面积小于 $DAB$ 的面积。所以得到 $x &lt; \tan x$</li></ol><p>由此我们得到不等式：$\sin x &lt; x &lt; \tan x$ (当 $x&gt;0$ )，同时除以 $\sin x$，得到：$1 &lt; \frac{x}{\sin x} &lt; \frac{1}{\cos x}$。</p><p>当 $x&lt;0$ 时，显然 $\sin x &gt; x &gt; \tan x$，同时除以 $\sin x$（除以负数要变号），得到：$1 &lt; \frac{x}{\sin x} &lt; \frac{1}{\cos x}$。</p><p>令 $x\rightarrow 0^{-}$，由夹逼定理得到左极限 $\lim\limits_{x\rightarrow 0^{-}} \frac{\sin x}{x} = 1$</p><p>令 $x\rightarrow 0^{+}$，由夹逼定理得到右极限 $\lim\limits_{x\rightarrow 0^{+}} \frac{\sin x}{x} = 1$</p><p>最终可以得到：$\lim\limits_{x\rightarrow 0} \frac{\sin x}{x} = 1$ （左右极限都等于 1）</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>熟练使用JetBrains家的IDE</title>
      <link href="/blog/2018/11/04/%E7%86%9F%E7%BB%83%E4%BD%BF%E7%94%A8JetBrains%E5%AE%B6%E7%9A%84IDE/"/>
      <url>/blog/2018/11/04/%E7%86%9F%E7%BB%83%E4%BD%BF%E7%94%A8JetBrains%E5%AE%B6%E7%9A%84IDE/</url>
      
        <content type="html"><![CDATA[<h2 id="通用快捷键"><a href="#通用快捷键" class="headerlink" title="通用快捷键"></a>通用快捷键</h2><ol><li>格式化代码（reformat code）:<br>win: ctrl+alt+L<br>mac: command+option+L</li><li>在一行的任意位置使用： shift + enter，新建下一行并跳到下一行。</li><li>善用代码自动补全功能，变量名和方法名等可以用 enter 补全。导入包可以用 alt + enter。</li><li>上下移动代码，ctrl+shift+上下键</li><li>Android Studio 生成函数注释：你在方法前输入/**然后一回车，自动帮你生成方法和参数的注释。</li></ol><a id="more"></a><h2 id="Intellj-Idea"><a href="#Intellj-Idea" class="headerlink" title="Intellj Idea"></a>Intellj Idea</h2><p>快速打出常用语句：</p><ol><li><strong>sout</strong>：<code>System.out.println();</code></li><li><strong>psvm</strong>：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>使用 IDE 的右键中的生成 Getter Setter 选项自动生成 Getter Setter，使用 toString 自动生成 toString。</p></li><li><p>跳转到接口：<code>ctrl+b</code>； 跳转到实现类：<code>ctrl + alt +B</code></p></li><li><p><img src="../../../../images/2018/idea图解.png" alt></p></li></ol><p>上面这个按钮可以快速的在目录树中定位到当前类所在的路径</p><ol start="6"><li>ctrl+alt+t</li></ol><p><img src="../../../../images/2018/idea-ctrl+alt+t.png" alt="idea-ctrl+alt+t.png"></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>精通一款编辑器之sublime text 3</title>
      <link href="/blog/2018/11/04/%E7%B2%BE%E9%80%9A%E4%B8%80%E6%AC%BE%E7%BC%96%E8%BE%91%E5%99%A8%E4%B9%8Bsublime%20text%203/"/>
      <url>/blog/2018/11/04/%E7%B2%BE%E9%80%9A%E4%B8%80%E6%AC%BE%E7%BC%96%E8%BE%91%E5%99%A8%E4%B9%8Bsublime%20text%203/</url>
      
        <content type="html"><![CDATA[<h2 id="编辑器常用功能"><a href="#编辑器常用功能" class="headerlink" title="编辑器常用功能"></a>编辑器常用功能</h2><ol><li>格式化代码：格式化代码可以让你不用管代码的格式，可以放肆的写程序，你可以少敲很多空格，不用关心代码的格式问题，机器给出的代码格式风格统一且漂亮，一键解决你的格式问题，真是提高码代码效率的非常重要的功能。</li><li>查找文件：查找文件是在集成开发的时候非常重要的功能，当文件多起来的时候，快速定位到文件可以节省很多时间，甚至有时候文件实在太多，你只能通过查找的方式找到那个文件。</li><li>正则全文件查找和替换：轻松让你更改全局变量和配置，这是一个必须的功能，没有它简直无法想象工作量有多大。</li><li>代码收缩和扩展：代码太长怎么办，收缩和扩展啊。</li></ol><a id="more"></a><h2 id="安装卸载插件"><a href="#安装卸载插件" class="headerlink" title="安装卸载插件"></a>安装卸载插件</h2><ol><li><code>cmd+shift+p</code>：打开命令板，输入<code>install</code>，点击：<strong>Package Control: Install Package</strong>选项，然后搜索你想要的插件。</li><li>卸载请在命令板输入：<code>remove</code>，点击：<strong>Package Control: Remove Package</strong>选项。其实卸载无非就是两个词：<code>remove</code>和<code>uninstall</code>，多试试就行了。</li></ol><blockquote><p>打开命令板之后什么都不想干，怎么关闭命令板呢？其实很简单，再按一次打开命令板的快捷键就行了，<strong>开关都用同一个键或者按钮（术语叫：toggle，可开可关），这是比较通用设计理念</strong>。</p></blockquote><h2 id="基本快捷键"><a href="#基本快捷键" class="headerlink" title="基本快捷键"></a>基本快捷键</h2><ul><li>显示隐藏菜单栏：alt，如果你不小心把菜单栏隐藏了，除了用快捷键唤出，还真不知道有什么其他办法。</li><li>显示隐藏目录树：ctrl+k+b，这个功能可以在菜单栏中的 view 中找到，所以我觉得记不记无所谓</li></ul><h2 id="vue-插件"><a href="#vue-插件" class="headerlink" title="vue 插件"></a>vue 插件</h2><ol><li><strong>vue-syntax-highlight</strong>：可以让<code>.vue</code>文件高亮。</li><li><strong>HTML-CSS-JS Prettify</strong>：可以格式化这三种语言的代码，特别是单文件的 vue，非常需要这个来同时格式化三种语言。不过需要配置一下。工具栏路径：<code>Sublime Text -&gt; Preferences -&gt; Package Settings -&gt; HTML/CSS/JS Prettify -&gt; Plugin Options - Default</code>，然后搜索：<code>allowed_file_extensions</code>，给这个配置项添加一个<code>vue</code>即可，要注意的是有四处有这个配置项，分别是<code>html</code>、<code>css</code>、<code>js</code>、<code>json</code>，如果你想它们全都能格式化，自然是要全都添加<code>vue</code>，但实验证明只加 html 里面就行了，如果在其他几个里面加反而引起了冲突。然后格式化代码的快捷键是什么呢？同样也有配置文件的，工具栏路径：<code>Sublime Text -&gt; Preferences -&gt; Package Settings -&gt; HTML/CSS/JS Prettify -&gt; Keyboard Shortcuts - Default</code>，可以看到：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">  &quot;keys&quot;: [&quot;super+shift+h&quot;],</span><br><span class="line">  &quot;command&quot;: &quot;htmlprettify&quot;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  &quot;keys&quot;: [&quot;super+alt+h&quot;, &quot;p&quot;],</span><br><span class="line">  &quot;command&quot;: &quot;htmlprettify_set_prettify_prefs&quot;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  &quot;keys&quot;: [&quot;super+alt+h&quot;, &quot;o&quot;],</span><br><span class="line">  &quot;command&quot;: &quot;htmlprettify_set_plugin_options&quot;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  &quot;keys&quot;: [&quot;super+alt+h&quot;, &quot;k&quot;],</span><br><span class="line">  &quot;command&quot;: &quot;htmlprettify_set_keyboard_shortcuts&quot;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  &quot;keys&quot;: [&quot;super+alt+h&quot;, &quot;n&quot;],</span><br><span class="line">  &quot;command&quot;: &quot;htmlprettify_set_node_path&quot;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p>第一项即为使用这个插件的快捷键，也就是格式化代码的快捷键。</p><h2 id="底栏设置显示文件编码"><a href="#底栏设置显示文件编码" class="headerlink" title="底栏设置显示文件编码"></a>底栏设置显示文件编码</h2><p>在 mac osx 上一不小心按了 cmd+shift+c，文件的存储格式现在变成了 GBK 格式，当我再按下 cmd+s 保存时，提示我 UTF-8 格式的文件不能用 GBK 格式来保存。怎么解决这个问题呢？首先我想查看这个文件是什么编码，Sublime Text 的默认设置是不开启显示编码的，如果想开启，可通过菜单 Perference → Settings – User，在打开的配置文件里 ，在大括号后面，增加以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// Display file encoding in the status bar</span><br><span class="line">&quot;show_encoding&quot;: true,</span><br><span class="line">// Display line endings in the status bar</span><br><span class="line">&quot;show_line_endings&quot;: true,</span><br></pre></td></tr></table></figure><p>此时保存该配置文件，就能够看到 sublime 最底下一行会显示文件编码格式了。以上的配置内容在 Perference → Setting─Default 都是 false 的。</p><p>然后在底栏点击文件编码，点击 reopen with encoding，然后选择 utf-8，然后 cmd+w 关闭窗口，然后 cmd+shift+t 重新打开刚刚关闭的窗口，就一切恢复正常了。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《CSAPP》 -- 处理器体系结构</title>
      <link href="/blog/2018/10/13/%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
      <url>/blog/2018/10/13/%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>阅读这篇文章必须要对汇编码有足够的了解，如果你对 IA32 汇编码还不够了解，可以先看看这篇文章：<a href="../../08/程序的机器级表示">程序的机器级表示</a></p><h2 id="Y86-指令集体系结构"><a href="#Y86-指令集体系结构" class="headerlink" title="Y86 指令集体系结构"></a>Y86 指令集体系结构</h2><p>Y86 指令集基本上是 IA32 指令集的一个子集。这个指令集就是我们处理器实现的目标。如下图：</p><a id="more"></a><p><img src="../../../../images/2018/Y86指令集.png" alt="Y86指令集"></p><p>IA32 的 movl 指令分成了 4 个不同指令：irmovl、rrmovl、mrmovl 和 rmmovl，i 表示立即数 Immediate，r 表示寄存器 Register，m 表示存储器 Memmory。第一个字母表示源，第二个字母表示目的。</p><p>这里不实现的功能有：</p><ol><li>存储器引用方式是简单的基址+偏移量形式，不支持变址寄存器（second index register）和任何寄存器伸缩（scaling）。如果对操作数的结构不太了解可以看看这个：<a href="../../08/程序的机器级表示/#操作数指示符">操作数指示符</a></li><li>和 IA32 一样不允许从一个存储器直接传送到另一个存储器地址。</li><li>不允许立即数传送到存储器</li></ol><p>4 个整数操作指令：addl、subl、andl、xorl</p><p>7 个跳转指令：jmp、jle、jl、je、jne、jge、jg。</p><p>6 个条件传送指令：cmovle、cmovl、cmove、cmovne、cmovge、cmovg。</p><p>另外还有：call、ret、pushl、popl，halt 指令停止指令执行。IA32 中有一个与之相当的指令 hlt，IA32 的应用程序不允许使用这条指令，因为它会导致整个系统暂停运行。对于 Y86 来说，执行 halt 指令会导致处理器停止，并将状态码设置为 HLT。</p><h3 id="指令编码"><a href="#指令编码" class="headerlink" title="指令编码"></a>指令编码</h3><p>与 IA32 一样使用小端编码。</p><p><img src="../../../../images/2018/指令编码.png" alt="指令编码"></p><p>每条指令的第一个字节表明指令的类型，这个字节分为两部分，每部分 4 位：高 4 位是代码（code）部分，低 4 位是功能（function）部分。代码值为 0~0xB。可以观察到，<code>rrmovl</code>与条件传送指令有同样的代码部分，可以把它看作是一个无条件传送。</p><p>寄存器编码如下：</p><p><img src="../../../../images/2018/寄存器编码.png" alt="寄存器编码"></p><p>举个例子：用 16 进制表示指令 <code>rmmvol %esp, 0x12345(%edx)</code>的字节编码。</p><p>从上面图中可以看到，rmmovl 第一个字节为 40，由于%esp 是 4（占 4 位），%edx 是 2（占 4 位），所以第二个字节是 42，最后再加上偏移量 00 01 23 45，小端表示是：45 23 01 00，所以最后得到指令的编码是：<code>404245230100</code>。</p><p>指令集的一个重要性质是字节编码必须有唯一解释，任意一个字节序列要么是一个唯一的指令，要么是一个不合法的指令。</p><p>相比于 IA32，Y86 没那么紧凑，IA32 对寄存器只用了 3 位来编码，5 位表明指令类型，所以 IA32 能将出栈入栈放进一个字节里。另外 IA32 可以将常数值编码成 1、2、4 字节，Y86 总是编码成 4 字节。</p><h3 id="RISC-和-CISC"><a href="#RISC-和-CISC" class="headerlink" title="RISC 和 CISC"></a>RISC 和 CISC</h3><ul><li>RISC: reduced instruction set computers，精简指令集</li><li>CISC: complex instruction set computers，复杂指令集</li></ul><h3 id="Y86-异常"><a href="#Y86-异常" class="headerlink" title="Y86 异常"></a>Y86 异常</h3><p><img src="../../../../images/2018/Y86异常.png" alt="Y86异常"></p><p>对于 Y86，当遇到这些异常的时候，我们简单的让处理器停止执行指令。在更完善的设计中，处理器通常会调用一个 exception handler（异常处理程序），这个过程被指定用来处理遇到的某种类型的异常，例如放弃程序或调用一个用户自定义的 signal handler（信号处理程序）。</p><h3 id="Y86-程序"><a href="#Y86-程序" class="headerlink" title="Y86 程序"></a>Y86 程序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sum</span><span class="params">(<span class="keyword">int</span> *Start, <span class="keyword">int</span> Count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (Count) &#123;</span><br><span class="line">        sum += *Start;</span><br><span class="line">        Start++;</span><br><span class="line">        Count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="../../../../images/2018/IA32对比Y86代码.png" alt="IA32对比Y86代码"></p><p>可以看到 Y86 有时候需要两条指令来完成 IA32 一条指令就能完成的事。然而如果用数组索引来写这个程序，要转换成 Y86 会很困难，因为 Y86 没有伸缩寻址。</p><p>完整代码如下：</p><p><img src="../../../../images/2018/Y86汇编代码.png" alt="Y86汇编代码"></p><p>以<code>.</code>开头的是 assembler directive（汇编器命令），命令<code>.pos 0</code>告诉汇编器应该从地址 0 处开始产生代码。第 3、4 行使用的 Stack 标签，在最后有声明，其位置是 0x100。第 9 到 13 行声明了一个数组，4 字节对齐，值分别是：0xd，0xc0，0xb00，0xa000，array 标签是起址。</p><blockquote><p>细节问题，<code>pushl %esp</code>（这个指令只能用汇编语言写，C 语言无法产生）是先把%esp 的值转移到栈，还是先%esp 减 4 再将结果转移到栈，实际上不同版本的 intel 处理器都会产生不同的结果，所以一个很重要的教训是要保证细节上的一贯性。</p></blockquote><h2 id="逻辑设计和硬件控制语言-HCL（Hardware-Control-Language）"><a href="#逻辑设计和硬件控制语言-HCL（Hardware-Control-Language）" class="headerlink" title="逻辑设计和硬件控制语言 HCL（Hardware Control Language）"></a>逻辑设计和硬件控制语言 HCL（Hardware Control Language）</h2><h3 id="逻辑门"><a href="#逻辑门" class="headerlink" title="逻辑门"></a>逻辑门</h3><p><img src="../../../../images/2018/逻辑门.png" alt="逻辑门"></p><h3 id="组合电路和-HCL-语言"><a href="#组合电路和-HCL-语言" class="headerlink" title="组合电路和 HCL 语言"></a>组合电路和 HCL 语言</h3><p>构建一个组合电路有两条限制：</p><ol><li>两个或多个逻辑门的输出不能连接在一起。这样会导致线上的信号矛盾，产生不合法的电压或电路故障。</li><li>必须是无环的，也就是不能形成回路。</li></ol><p>下面是个简单的例子：</p><p><img src="../../../../images/2018/组合电路.png" alt="组合电路"></p><p>用 HCL 来写这个网的函数就是：<code>bool eq = (a &amp;&amp; b) || (!a &amp;&amp; !b)</code></p><p>HCL 是用来 C 语言风格的语法，但这里同 C 语言不一样，该语句的意思不是执行了一次计算并将结果放入存储器，而是使用一个名字 eq 来称谓一个表达式。</p><p>实际上上面的组合电路就是同或，异或的表达式是：<code>bool eq = (!a &amp;&amp; b) || (a &amp;&amp; !b)</code></p><p>多路复用器（multiplexor，通常称为：MUX）：</p><p><img src="../../../../images/2018/MUX组合电路.png" alt="MUX组合电路"></p><p><code>bool out = (s &amp;&amp; a) || (!s &amp;&amp; b)</code></p><h3 id="字级的组合电路和-HCL-整数表达式"><a href="#字级的组合电路和-HCL-整数表达式" class="headerlink" title="字级的组合电路和 HCL 整数表达式"></a>字级的组合电路和 HCL 整数表达式</h3><p>通常我们设计能对字（word）进行操作的组合电路，字级电路中用到的就是 HCL 整数表达式了。</p><p>字级与电路：</p><p><img src="../../../../images/2018/字级与电路.png" alt="字级与电路"></p><p><code>bool Eq = (A == B);</code></p><p>也可以用异或来实现：</p><p><img src="../../../../images/2018/字级异或电路.png" alt="字级异或电路"></p><p>在 HCL 中，多路复用函数是用情况表达式（case expression）来描述的。情况表达式的通用格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    select_1 : expr_1;</span><br><span class="line">    select_2 : expr_2;</span><br><span class="line">             .</span><br><span class="line">             .</span><br><span class="line">             .</span><br><span class="line">    select_k : expr_k;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>同 C 语言的 switch 语句不同，我们不要求不同的选择表达式之间互斥。从逻辑上讲，这些选择表达式是顺序求值的，且第一个求值为 1 的情况就会被选中。</p><p>字级多路复用电路：</p><p><img src="../../../../images/2018/字级多路复用电路.png" alt="字级多路复用电路"></p><p>用 HCL 来描述就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int Out = [</span><br><span class="line">    s: A;</span><br><span class="line">    1: B;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>大多数人第一眼是看不懂这个表达式的，其实里面有个暗含的条件：先执行 <code>s: A;</code> 如果失败（没有输出 A）才会再执行 <code>1: B;</code>。而<code>1: B;</code>实际上是<code>!s&amp;&amp;1: B;</code>的简写。没有输出 A 就已经代表 s 是 0 了，那么!s 就是 1。</p><p>四路复用器：</p><p><img src="../../../../images/2018/四路复用器.png" alt="四路复用器"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int Out4 = [</span><br><span class="line">    !s1 &amp;&amp; !s0: A; # 00</span><br><span class="line">    !s1       : B; # 01</span><br><span class="line">    !s0       : C; # 10</span><br><span class="line">    1         : D; # 11</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>第二个表达式可以写成<code>!s1</code>，而不用写的更完整<code>!s1&amp;&amp;s0</code>，是因为另一种可能<code>s0=0</code>已经出现在了第一个选择表达式了，若能到达第二个选择表达式，则<code>s0=1</code>。类似的，第三个表达式可以写成<code>!s0</code>，第四个表达式可以简单的写成 1。</p><p>来看最后一个例子，假设我们想设计一个逻辑电路来找一组字 A、B 和 C 中的最小值，如下图所示：</p><p><img src="../../../../images/2018/最小值电路.png" alt="最小值电路"></p><p>用 HCL 来表达：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int Min3 = [</span><br><span class="line">    A&lt;=B &amp;&amp; A&lt;=C : A;</span><br><span class="line">    B&lt;=A &amp;&amp; B&lt;=C : B;</span><br><span class="line">    1            : C;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>算术逻辑单元（arithmetic/logic unit, ALU）</p><p><img src="../../../../images/2018/ALU.png" alt="ALU"></p><h3 id="集合关系"><a href="#集合关系" class="headerlink" title="集合关系"></a>集合关系</h3><p><img src="../../../../images/2018/集合关系.png" alt="集合关系"></p><p>在这个电路中，两位的信号 code 就可以用来控制对 4 个数据字 A、B、C 和 D 做选择。根据可能的 code 值，可以用相等测试来表示信号 s1 和 s0 的产生：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool s1= code==2 || code==3;</span><br><span class="line">bool s0= code==1 || code==3;</span><br></pre></td></tr></table></figure><p>还有一种更简洁的方式来表示这样的属性：当 code 在集合<code>{2,3}</code>中 s1 为 1，而 code 在集合<code>{1,3}</code>中 s0 为 1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bool s1= code in &#123;2,3&#125;;</span><br><span class="line">bool s0= code in &#123;1,3&#125;;</span><br></pre></td></tr></table></figure><p>判断集合关系的通用格式：<code>iexpr in {iexpr1, iexpr2, ... , iexprk}</code></p><h3 id="存储器和时钟"><a href="#存储器和时钟" class="headerlink" title="存储器和时钟"></a>存储器和时钟</h3><p>组合电路从本质上讲，不存储任何信息，它们只是简单的根据输入信号产生一个输出信号。为了产生时序电路（sequential circuit），也就是有状态并且在这个状态上进行计算的系统，我们必须引入按位存储信息的设备。存储设备都是由同一个时钟控制，时钟是一个周期性信号，决定什么时候要把新值加载到设备中。考虑两类存储器设备：</p><ul><li><strong>时钟寄存器</strong>（简称寄存器）存储单个位或字。时钟信号控制寄存器加载输入值。</li><li><strong>随机访问存储器</strong>（简称存储器）存储多个字，用地址来选择该读或该写哪个字。随机访问存储器的例子包括：1.处理器的虚拟存储器系统（由硬件和操作系统结合起来使处理器可以在一个很大的地址空间内访问任意的字，硬件上包括由缓存、内存、外存）。2.寄存器文件，在此，寄存器标识符作为地址。在 IA32 或 Y86 处理器中，寄存器文件有 8 个程序寄存器（%eax、%ecx 等）。</li></ul><p>正如我们看到的那样，在说到硬件和机器级编程时，“寄存器”这个词是有两个不同的意思的。需要避免歧义的时候，我们分别称呼这两类寄存器为：<code>硬件寄存器</code>和<code>程序寄存器</code>。</p><p>下图说明了硬件寄存器是如何工作的：</p><p><img src="../../../../images/2018/硬件寄存器.png" alt="硬件寄存器"></p><p>寄存器是作为电路不同部分中的组合逻辑之间的屏障。我们的 Y86 处理器会用时钟寄存器保存程序计数器（PC），条件码（CC）和程序状态（Stat）。</p><p>下图展示了一个典型的寄存器文件：</p><p><img src="../../../../images/2018/寄存器文件.png" alt="寄存器文件"></p><p>寄存器文件有两个读端口，一个写端口。每个端口都有一个地址输入，地址是图 4-4 中的寄存器标识符。这样一个多端口随机访问存储器允许同时进行多个读和写操作。</p><p>虽然寄存器文件不是组合电路，因为它有内部存储。不过在我们的实现中，从寄存器文件中读数据就好像它是一个以地址为输入、数据为输出的一个组合逻辑块。当 srcA 或 srcB 被设成某个寄存器 ID 时，在一段延迟之后，存储在相应寄存器上的值就会出现在 valA 或 valB 上。</p><p>向寄存器文件写入字是由时钟信号控制的，控制方式类似于将值加载到时钟寄存器。每次时钟上升时，输入 valW 上的值会被写入 dstW 指明的寄存器上。当 dstW 设为特殊的 ID 值 0xF 时，不会写任何程序寄存器。</p><p>由于寄存器文件既可以读又可以写，一个很自然的问题就是：如果我们同时读和写一个程序寄存器会发生什么？答案简单明了：我们会看到一个旧值到新值的变化。所以在设计处理器的时候要把这个问题考虑进去。</p><p>我们的处理器有一个随机访问存储器，如下图所示：</p><p><img src="../../../../images/2018/随机访问存储器.png" alt="随机访问存储器"></p><p>同寄存器文件一样，从存储器中读的操作方式类似于组合逻辑：如果我们在输入 address 上提供一个地址，并将 write 控制信号设置为 0，那么经过一些延迟之后，存储在那个地址上的值会出现在输出 data 上。如果地址超出了范围，error 信号会置为 1，否则就是 0。</p><p>写存储器是由时钟控制的：我们将 address 设置为期望的地址，将 data in 设置为期望的值，而 write 设置为 1。然后我们控制时钟时，只要地址是合法的，就会更新相应的地址中的值，如果是非法地址，error 就会置为 1。</p><h2 id="Y86-的顺序实现"><a href="#Y86-的顺序实现" class="headerlink" title="Y86 的顺序实现"></a>Y86 的顺序实现</h2><h3 id="将处理组织成阶段"><a href="#将处理组织成阶段" class="headerlink" title="将处理组织成阶段"></a>将处理组织成阶段</h3><ul><li><strong>取指（fetch）</strong>：从存储器取指令，地址为 PC 所指的地址。从指令中抽取出指令指示符字节的两个四位部分，称为 icode（指令代码）和 ifun（指令功能）。</li><li><strong>译码（decode）</strong>：译码阶段从寄存器文件最多读入两个操作数，得到值 valA 和 valB（如果是两个的话）。通常，它读入指令 rA 和 rB 字段指明的寄存器，不过有些指令是读寄存器%esp 的。</li><li><strong>执行（execute）</strong></li><li><strong>访存（memory）</strong>：访存阶段可以将数据写入存储器，或者从存储器读出数据。读出的值为 valM。</li><li><strong>写回（write back）</strong>：写回阶段最多可以写两个结果到寄存器文件。</li><li><strong>更新 PC（PC update）</strong>：将 PC 设置成下一条指令的地址。</li></ul><p>处理器无限循环，执行这些阶段。在我们简化的实现中，发生任何异常时，处理器就会停止。比如：它执行 halt 指令或非法指令，或者它试图读或者写非法地址。在更完整的设计中，处理器会进入异常处理模式，开始执行由异常的类型决定的特殊代码。</p><p>在硬件上复制逻辑块的成本比软件中有重复代码的成本要大得多。而且在硬件系统中处理许多特殊情况和特性要比用软件来处理困难得多。</p><p>我们面临的一个挑战是将每条不同指令所需要的计算放入到上述的通用框架中。我们会使用图 4-17 中所示的代码来描述不同的 Y86 指令的处理。图 4-18 到 4-21 描述了不同 Y86 指令在各阶段是怎样处理的。</p><p><img src="../../../../images/2018/Y86指令阶段解析.png" alt="Y86指令阶段解析"></p><p><img src="../../../../images/2018/4-18.png" alt="4-18"></p><p>让我们看一个具体的例子，图 4-17 中的第三条指令：</p><p><img src="../../../../images/2018/subl指令.png" alt="subl指令"></p><p><img src="../../../../images/2018/4-19.png" alt="4-19"></p><p>图 4-17 中第五条指令：</p><p><img src="../../../../images/2018/rmmovl指令.png" alt="rmmovl指令"></p><p><img src="../../../../images/2018/4-20.png" alt="4-20"></p><p>图 4-17 中第六条指令：</p><p><img src="../../../../images/2018/pushl指令.png" alt="pushl指令"></p><p>图 4-21 表明了三类控制转义指令的处理：各种跳转、call 和 ret。</p><p><img src="../../../../images/2018/4-21.png" alt="4-21"></p><p>图 4-17 中第 8 条指令：</p><p><img src="../../../../images/2018/je指令.png" alt="je指令"></p><p>图 4-17 中第 13 条指令：</p><p><img src="../../../../images/2018/ret指令.png" alt="ret指令"></p><h2 id="SEQ-硬件结构"><a href="#SEQ-硬件结构" class="headerlink" title="SEQ 硬件结构"></a>SEQ 硬件结构</h2><p><img src="../../../../images/2018/SEQ硬件结构.png" alt="SEQ硬件结构"></p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《CSAPP》 -- 程序的机器级表示</title>
      <link href="/blog/2018/10/08/%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/"/>
      <url>/blog/2018/10/08/%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="从编译-C-语言文件说起"><a href="#从编译-C-语言文件说起" class="headerlink" title="从编译 C 语言文件说起"></a>从编译 C 语言文件说起</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc <span class="number">-01</span> -o p p1.c p2.c</span><br></pre></td></tr></table></figure><p>使用了 gcc 命令来编译，也可以简单写作：<code>cc</code>。</p><p>优化层级为 1，1 级是最低的，层级越高程序优化越好，但增加了编译时间，也使调试变得更难，且跟源程序差异很大不便于理解。</p><p>编译的流程是：</p><ol><li>预处理器（preprocessor）把诸如：<code>#include</code>、<code>#define</code>、<code>#if</code>、<code>#else</code>、<code>#elif</code>、<code>#ifdef</code>、<code>#endif</code>等预编译指令替换掉。</li><li>编译器（compiler）把<code>.c</code>源文件编译成<code>.s</code>的汇编代码文件。</li><li>汇编器（assembler）把汇编代码文件转换成相应的二进制目标文件<code>.o</code>，目标文件已经是机器码了，只是没有填入全局变量的地址。</li><li>链接器（linker），把多目标文件和库函数链接在一起，形成可执行文件。</li></ol><a id="more"></a><p><strong>instruction set architecture，ISA，指令集体系结构</strong>，定义了处理器状态，指令的格式和行为。intel 的指令集包括 32 位的：IA32，以及 64 位的：x86-64。</p><p>编译器做了整个编译流程的大部分工作，汇编代码几乎就是机器码的供人阅读版。所以看懂汇编代码是关键。</p><p>IA32 程序代码和 C 语言很不相同，一些在 C 语言下看不到的处理器状态可以在这里看到：</p><ul><li>程序计数器（program counter，PC，也叫：instructor pointer，IP）在 IA32 中叫：<code>%eip</code>，指出下一条指令在内存中的位置</li><li>整数寄存器，可以用来保存数据</li><li>状态码寄存器，可以用来实现条件控制代码如：if 和 while</li><li>浮点寄存器，用来计算浮点数</li></ul><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> accum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = x + y;</span><br><span class="line">    accum += t;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要看到编译出的汇编代码，可以使用<code>-S</code>选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -01 -S code.c</span><br></pre></td></tr></table></figure><p>这样就会使编译流程停留在 <strong>预处理-&gt;编译</strong> 阶段，而不是继续进行接下来的汇编和链接，生成的文件是：<code>.s</code>汇编文件。编译后的汇编代码中会包含如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sum:</span><br><span class="line">    pushl %ebp</span><br><span class="line">    movl %esp, %ebp</span><br><span class="line">    movl 12(%ebp), %eax</span><br><span class="line">    addl 8(%ebp), %eax</span><br><span class="line">    addl %eax, accum</span><br><span class="line">    popl %ebp</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>这段代码中的每一句都对应一个机器指令，比如 pushl 这句的意思就是把寄存器%ebp 的内容 push 到程序栈（内存中）上。<strong>在汇编代码里所有的局部变量都不见了，全局变量还可以看到，因为编译器还没有决定这个变量在内存中的存储位置。</strong></p><p>如果我们使用<code>-c</code>选项，GCC 就会既编译又汇编：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -01 -c code.c</span><br></pre></td></tr></table></figure><p>这样就生成了目标文件<code>code.o</code>，在 800bytes 的 code.o 文件中，有 17bytes 是对应上面的汇编代码的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">55 89 e5 8b 45 0c 03 45 08 01 05 00 00 00 00 5d c3</span><br></pre></td></tr></table></figure><p>可以使用反汇编将难懂的目标文件代码转成汇编代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ objdump -d code.o</span><br></pre></td></tr></table></figure><p><img src="../../../../images/2018/反汇编.png" alt="反汇编"></p><ul><li>IA32 指令的长度是 1 到 15 字节，越常用的，操作数越少的指令越短，反之则越长。</li><li>给定一个开始的位置，只对应一种机器指令，比如只有<code>pushl %ebp</code>指令是以 55 开头的</li><li>反汇编只需要根据目标文件就可以翻译出汇编文件</li><li>反汇编出来的文件跟直接编译的汇编文件有些不一样，比如所有指令都省略了后缀<code>l</code>。<code>l</code>是大小指示符，而大多数情况下是可以省略 l 的。</li></ul><blockquote><p>头两个属性跟<a href="https://zh.wikipedia.org/wiki/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81" target="_blank" rel="noopener">哈夫曼编码</a>的原理是一致的，可以说这是一种通用的编码原则，第一条用来保证节省字节空间，第二条则保证编码的唯一性。</p></blockquote><p>生成真正可执行的文件还需要链接操作，而且必须包含 main 函数。假设我们的<code>main.c</code>文件如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用如下指令生成可执行文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -01 -o prog code.o main.c</span><br></pre></td></tr></table></figure><p>prog 文件增长到了 9123bytes，因为它不仅包含我们写的代码，而且包含了用来开始和结束的程序，以及与操作系统进行交互的程序。</p><p><img src="../../../../images/2018/链接之后的反汇编代码1.png" alt="链接之后的反汇编代码1"></p><p><img src="../../../../images/2018/链接之后的反汇编代码2.png" alt="链接之后的反汇编代码2"></p><p>可以看到第 6 行，全局变量在链接的时候定址。</p><h2 id="汇编代码的格式"><a href="#汇编代码的格式" class="headerlink" title="汇编代码的格式"></a>汇编代码的格式</h2><p>假设我们有一个 C 语言文件<code>simple.c</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">simple</span><span class="params">(<span class="keyword">int</span> *xp, <span class="keyword">int</span> y)</span> 2</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = *xp + y;</span><br><span class="line">    *xp = t;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以得到如下汇编代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.file   &quot;simple.c&quot;</span><br><span class="line">  .text</span><br><span class="line">.globl simple</span><br><span class="line">  .type   simple, @function</span><br><span class="line">simple:</span><br><span class="line">  pushl   %ebp</span><br><span class="line">  movl    %esp, %ebp</span><br><span class="line">  movl    8(%ebp), %edx</span><br><span class="line">  movl    12(%ebp), %eax</span><br><span class="line">  addl    (%edx), %eax</span><br><span class="line">  movl    %eax, (%edx)</span><br><span class="line">  popl    %ebp</span><br><span class="line">  ret</span><br><span class="line">  .size   simple, .-simple</span><br><span class="line">  .ident  &quot;GCC: (Ubuntu 4.3.2-1ubuntu11) 4.3.2&quot;</span><br><span class="line">  .section        .note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure><p>所有以<code>.</code>开头的行都是用来指导汇编器和链接器的，我们不用去管。而这段代码的大概意思如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">simple:</span><br><span class="line">    pushl %ebp           保存帧指针</span><br><span class="line">    movl  %esp, %ebp     创建新的帧指针</span><br><span class="line">    movl  8(%ebp), %edx  从内存中读取xp</span><br><span class="line">    movl  12(%ebp), %eax 从内存中读取y</span><br><span class="line">    addl  (%edx), %eax   *xp+y=t</span><br><span class="line">    movl  %eax, (%edx)   把t存到xp指向的地址中</span><br><span class="line">    popl  %ebp           重新获取帧指针</span><br><span class="line">    ret                  返回</span><br></pre></td></tr></table></figure><blockquote><p>这段代码对%ebp 和%esp 的操作涉及到了程序栈模型，看不懂很正常，文章下面会有讲解的。</p></blockquote><h3 id="ATT-和-intel-汇编格式"><a href="#ATT-和-intel-汇编格式" class="headerlink" title="ATT 和 intel 汇编格式"></a>ATT 和 intel 汇编格式</h3><p>ATT 即 AT&amp;T，是贝尔实验室旗下的公司。</p><p>GCC 和 OBJDUMP 默认生成 ATT 格式的汇编代码，微软和因特尔的编程工具则默认生成 intel 格式的汇编代码。</p><p>使用如下命令可以让 GCC 生成 intel 格式的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -01 -S -masm=intel code.c</span><br></pre></td></tr></table></figure><p>两者的区别如下：</p><ul><li>intel 代码省略了用来指定大小的后缀，比如使用<code>mov</code>而不是<code>movl</code></li><li>intel 代码省略了寄存器前面的%，比如使用<code>esp</code>而不是<code>%esp</code></li><li>intel 代码用了不同的方式来描述内存地址，比如使用<code>DWORD PTR [ebp+8]</code>而不是<code>8(%ebp)</code></li><li>intel 代码多操作数指令的操作数顺序跟 ATT 相反</li></ul><p>由于是由 16bit 架构扩展到 32bit 架构的，intel 管 16bit 数据类型叫：<code>word</code>，32bit 数据类型叫：<code>double words</code>，64bit 数据类型叫：<code>quad words</code>。</p><h2 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h2><p><img src="../../../../images/2018/数据格式.png" alt="数据格式"></p><h2 id="访问数据"><a href="#访问数据" class="headerlink" title="访问数据"></a>访问数据</h2><p>IA32 CPU 包含了 8 个寄存器，每个有 32bit 存储空间，用来存储整形值以及指针。</p><p><img src="../../../../images/2018/IA32寄存器.png" alt="IA32寄存器"></p><p>x86-64 则进一步扩展了这些寄存器：</p><p><img src="../../../../images/2018/x86-64寄存器.jpg" alt="x86-64寄存器"></p><p>前六个寄存器称为通用寄存器，有其特定的用途：</p><ul><li>%rax(%eax) 用于做累加，过程调用返回值</li><li>%rcx(%ecx) 用于计数</li><li>%rdx(%edx) 用于保存数据</li><li>%rbx(%ebx) 用于做内存查找的基础地址</li><li>%rsi(%esi) 用于保存源索引值</li><li>%rdi(%edi) 用于保存目标索引值</li></ul><h3 id="操作数指示符"><a href="#操作数指示符" class="headerlink" title="操作数指示符"></a>操作数指示符</h3><p><img src="../../../../images/2018/操作数指示符.png" alt="操作数指示符"></p><p>有三种类型的操作数，立即数(Imm)、寄存器值(Reg)、内存值(Mem)。</p><h3 id="mov-指令"><a href="#mov-指令" class="headerlink" title="mov 指令"></a>mov 指令</h3><p><img src="../../../../images/2018/mov指令.png" alt="mov指令"></p><p><img src="../../../../images/2018/汇编栈操作.png" alt="汇编栈操作"></p><p><code>pushl %ebp</code>指令等价于下面的指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subl $4,%esp     减小栈指针</span><br><span class="line">movl %ebp,(%esp) 把%ebp中的数据写到%esp指向的内存中</span><br></pre></td></tr></table></figure><p><code>popl %eax</code>指令等价于下面的指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movl (%esp), %ebp  把%esp指向的内存地址中的值读到%eax中</span><br><span class="line">addl $4, %esp      增加栈指针</span><br></pre></td></tr></table></figure><h2 id="算术和逻辑操作"><a href="#算术和逻辑操作" class="headerlink" title="算术和逻辑操作"></a>算术和逻辑操作</h2><p>load effective address，leal 指令，实际上是一个 movl 指令。</p><p><img src="../../../../images/2018/算术和逻辑操作指令.png" alt="算术和逻辑操作指令"></p><p>多个操作数的指令，注意一下两个操作数的顺序即可</p><h3 id="位移操作"><a href="#位移操作" class="headerlink" title="位移操作"></a>位移操作</h3><p>位移的值是用一个单字节来表示，且数值只能是 0 到 31，所以这个字节只有低五位才会被考虑。</p><h3 id="扩展乘除指令"><a href="#扩展乘除指令" class="headerlink" title="扩展乘除指令"></a>扩展乘除指令</h3><p><img src="../../../../images/2018/扩展乘除操作.png" alt="扩展乘除操作"></p><h2 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h2><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>使用单比特的状态码来描述算数和逻辑运算的状态。最常用的状态码如下：</p><ul><li>CF: carry flag 进位符，用来表示最高位的进位。通常用来检测无符号运算的溢出</li><li>ZF: zero flag，零标志符，最近的操作产生了 0</li><li>SF: sign flag，符号位，最近的操作产生了负数</li><li>OF: overflow flag，溢出符，补码溢出，正负都可以，表示有符号溢出</li></ul><p><img src="../../../../images/2018/流程控制指令.png" alt="流程控制指令"></p><p>举个例子：t=a+b，a、b、t 都是整形数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CF: (unsigned)t&lt;(unsigned)a       无符号溢出</span><br><span class="line">ZF: (t==0)                        零</span><br><span class="line">SF: (t&lt;0)                         负数</span><br><span class="line">OF: (a&lt;0 == b&lt;0) &amp;&amp; (t&lt;0 != a&lt;0)  有符号溢出</span><br></pre></td></tr></table></figure><blockquote><p>OF 的表达式也可以写作：(a&lt;0 &amp;&amp; b<0 && t>0) || (a&gt;0 &amp;&amp; b&gt;0 &amp;&amp; t&lt;0)，也就是说 a、b 都是负数相加却是正数，或者 a、b 都是正数相加却是负数，这两种情况就代表溢出了。</0></p></blockquote><p>leal 操作不会改变状态码，因为这个指令只是用来计算地址。除此之外表 3.7 中的所有操作都可能改变状态码。例如逻辑操作：XOR，会使 CF 和 OF 置零，移位操作会使 CF 置为最后一个移位出去的 bit，但 OF 要置零。自增和自减指令会设置 OF 和 ZF，不设置 CF。</p><p>CMP 指令类似于 SUB 指令，但只修改状态码而不改变其他寄存器，如果两个操作数相等，ZF 就会被设置；TEST 指令类似于 AND 指令，但只修改状态码而不改变其他寄存器，如果两个操作数是重复的： testl %eax,%eax，作用是检测%eax 是 0，还是正数，还是负数。</p><h3 id="访问状态码"><a href="#访问状态码" class="headerlink" title="访问状态码"></a>访问状态码</h3><p>有三种常用的方式访问状态码：</p><ol><li>根据几个状态码的逻辑组合，设置单个字节为 0 或 1，也就是 set 指令</li><li>根据状态码，跳转到程序的其他分支</li><li>根据状态码传送数据</li></ol><p><img src="../../../../images/2018/set指令.png" alt="set指令"></p><p>举个例子：计算<code>a&lt;b</code>，a 和 b 都是 int 型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a is in %edx, b is in %eax</span><br><span class="line">cmpl   %eax, %edx       Compare a:b</span><br><span class="line">setl   %al              Set low order byte of %eax to 0 or 1</span><br><span class="line">movzbl %al, %eax        Set remaining byte of %eax to 0</span><br></pre></td></tr></table></figure><p>setl 指令是：<code>D &lt;- SF^OF</code>，也就是有两种情况代表 <code>a-b&lt;0</code>：</p><ol><li>OF=0（a-b 没有发生溢出），且 SF=1（a-b 结果为负）</li><li>OF=1（a-b 发生了溢出），且 SF=0（a-b 结果为非负）</li></ol><p>第二种情况比较复杂，需要简单分析一下。a-b 发生了溢出，有两种情况：<strong>正溢出和负溢出</strong>。负溢出：a 是负数，b 是正数，但 a-b 结果为正（结果小于了最小的负数，发生溢出）；正溢出：a 是正数，b 是负数，但 a-b 结果为负（结果大于了最大的正数，发生溢出）。</p><p>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-128： 1000 0000</span><br><span class="line">127:   0111 1111</span><br><span class="line">-127:  1000 0001</span><br></pre></td></tr></table></figure><p>a=-128, b=127, a-b=-128-127= $(1 0000 0001)_2$ , 从结果上来看就变成了 1（正数），这就是负溢出</p><p>a=127, b=-127, a-b=127-(-127) = $(1111 1110)_2$ , 从结果上来看就变成了 -2（负数），这就是正溢出</p><p>OF=1, SF=0，就是负溢出，而负溢出代表着 a 是负数，b 是正数，也就是<code>a&lt;b</code></p><p>其他三个有符号比较以此类推。</p><h3 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h3><p><img src="../../../../images/2018/跳转指令.png" alt="跳转指令"></p><p>可以看到条件跳转必须是直接的，而无条件跳转可以使用操作数。</p><p>跳转位置的编码有两种：</p><ol><li>借助 PC 使用相对定位</li><li>使用绝对定位</li></ol><p>实例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jle .L2                  if &lt;=, goto dest2</span><br><span class="line">  .L5:                   dest1:</span><br><span class="line">  movl %edx, %eax</span><br><span class="line">  sarl %eax</span><br><span class="line">  subl %eax, %edx</span><br><span class="line">  leal (%edx,%edx,2), %edx</span><br><span class="line">  testl %edx, %edx</span><br><span class="line">jg .L5                   if &gt;, goto dest1</span><br><span class="line">  .L2:                   dest2:</span><br><span class="line">   movl %edx, %eax</span><br></pre></td></tr></table></figure><p>目标文件和汇编文件对应如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">8: 7e 0d                 jle 17 &lt;silly+0x17&gt; Target = dest2</span><br><span class="line">a: 89 d0                 mov %edx,%eax dest1:</span><br><span class="line">c: d1 f8                 sar %eax</span><br><span class="line">e: 29 c2                 sub %eax,%edx</span><br><span class="line">10: 8d 14 52             lea (%edx,%edx,2),%edx</span><br><span class="line">13: 85 d2                test %edx,%edx</span><br><span class="line">15: 7f f3                jg a &lt;silly+0xa&gt; Target = dest1</span><br><span class="line">17: 89 d0                mov %edx,%eax dest2:</span><br></pre></td></tr></table></figure><p>对应的关系是：<code>0xd+0xa=0x17</code>，<code>0xf3+0x17=0xa</code>，为什么是加下一条指令的地址而不是当前指令呢？这个传统要追溯到计算机的早期实现，当时的处理器会在执行每一条指令之前先更新一下 PC（program counter）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">804839c: 7e 0d           jle 80483ab &lt;silly+0x17&gt;</span><br><span class="line">804839e: 89 d0           mov %edx,%eax</span><br><span class="line">80483a0: d1 f8           sar %eax</span><br><span class="line">80483a2: 29 c2           sub %eax,%edx</span><br><span class="line">80483a4: 8d 14           52 lea (%edx,%edx,2),%edx</span><br><span class="line">80483a7: 85 d2           test %edx,%edx</span><br><span class="line">80483a9: 7f f3           jg 804839e &lt;silly+0xa&gt;</span><br><span class="line">80483ab: 89 d0           mov %edx,%eax</span><br></pre></td></tr></table></figure><p>从反汇编代码来看，<strong>跳转如果使用 PC 相对地址，则不管代码存储到内存中的哪个位置，跳转的地址都不需要修改，且需要的编码更短</strong>。</p><h3 id="翻译条件分支"><a href="#翻译条件分支" class="headerlink" title="翻译条件分支"></a>翻译条件分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(test-expr)</span><br><span class="line">  then-statement</span><br><span class="line">else</span><br><span class="line">  else-statement</span><br></pre></td></tr></table></figure><p>先写成等价的 goto 版本，然后就可以很轻松的转成汇编了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">t=test-expr;</span><br><span class="line">if(!t)</span><br><span class="line">  goto false;</span><br><span class="line">  then-statement</span><br><span class="line">  goto done;</span><br><span class="line">false:</span><br><span class="line">  else-statement</span><br><span class="line">done:</span><br></pre></td></tr></table></figure><p>从汇编的角度看 <code>&amp;&amp;短路</code> 原理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void cond(int a, int *p)</span><br><span class="line">&#123;</span><br><span class="line">  if (p &amp;&amp; a &gt; 0)</span><br><span class="line">  *p += a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a %ebp +8, p at %ebp +12</span><br><span class="line"></span><br><span class="line">movl 8(%ebp), %edx</span><br><span class="line">movl 12(%ebp), %eax</span><br><span class="line">testl %eax, %eax</span><br><span class="line">je .L3</span><br><span class="line">testl %edx, %edx</span><br><span class="line">jle .L3</span><br><span class="line">addl %edx, (%eax)</span><br><span class="line">.L3:</span><br></pre></td></tr></table></figure><p>可以看到第一个条件通不过的时候就跳过了第二个条件判断。</p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="do-while"><a href="#do-while" class="headerlink" title="do while"></a>do while</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do</span><br><span class="line">  body-statement</span><br><span class="line">  while(test-expr)</span><br></pre></td></tr></table></figure><p>goto 版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">loop:</span><br><span class="line">  body-statement</span><br><span class="line">  t = test-expr;</span><br><span class="line">  if (t)</span><br><span class="line">goto loop;</span><br></pre></td></tr></table></figure><p><img src="../../../../images/2018/while的汇编形式.png" alt="while的汇编形式"></p><h4 id="while"><a href="#while" class="headerlink" title="while"></a>while</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while (test-expr)</span><br><span class="line">  body-statement</span><br></pre></td></tr></table></figure><p>先转成 do while 形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (!test-expr)</span><br><span class="line">  goto done;</span><br><span class="line">do</span><br><span class="line">  body-statement</span><br><span class="line">  while (test-expr);</span><br><span class="line">done:</span><br></pre></td></tr></table></figure><p>在把 do while 转成 goto 版：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">t = test-expr;</span><br><span class="line">if (!t)</span><br><span class="line">  goto done;</span><br><span class="line">loop:</span><br><span class="line">  body-statement</span><br><span class="line">  t = test-expr;</span><br><span class="line">  if (t)</span><br><span class="line">    goto loop;</span><br><span class="line">done:</span><br></pre></td></tr></table></figure><h4 id="for"><a href="#for" class="headerlink" title="for"></a>for</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (init-expr; test-expr; update-expr)</span><br><span class="line">  body-statement</span><br></pre></td></tr></table></figure><p>先转成 while 形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">init-expr;</span><br><span class="line">while (test-expr) &#123;</span><br><span class="line">  body-statement</span><br><span class="line">  update-expr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后转成 do while 形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">init-expr;</span><br><span class="line">if (!test-expr)</span><br><span class="line">  goto done;</span><br><span class="line">do &#123;</span><br><span class="line">  body-statement</span><br><span class="line">  update-expr;</span><br><span class="line">&#125; while (test-expr);</span><br><span class="line">done:</span><br></pre></td></tr></table></figure><p>最后转成 do while 的 goto 版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">init-expr;</span><br><span class="line">t = test-expr;</span><br><span class="line">if (!t)</span><br><span class="line">  goto done;</span><br><span class="line">loop:</span><br><span class="line">  body-statement</span><br><span class="line">  update-expr;</span><br><span class="line">  t = test-expr;</span><br><span class="line">  if (t)</span><br><span class="line">    goto loop;</span><br><span class="line">done:</span><br></pre></td></tr></table></figure><h3 id="状态转移指令"><a href="#状态转移指令" class="headerlink" title="状态转移指令"></a>状态转移指令</h3><p><img src="../../../../images/2018/状态表达式.png" alt="状态表达式"></p><p><img src="../../../../images/2018/状态转移指令.png" alt="状态转移指令"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v = test-expr ? then-expr : else-expr;</span><br></pre></td></tr></table></figure><p>goto 版：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (!test-expr)</span><br><span class="line">  goto false;</span><br><span class="line">v = true-expr;</span><br><span class="line">goto done;</span><br><span class="line">false:</span><br><span class="line">  v = else-expr;</span><br><span class="line">done:</span><br></pre></td></tr></table></figure><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>switch 主要使用了跳转表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">switch_eg</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result = x;</span><br><span class="line">  <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">100</span>:</span><br><span class="line">      result *= <span class="number">13</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">102</span>:</span><br><span class="line">      result += <span class="number">10</span>;</span><br><span class="line">      <span class="comment">/* Fall through */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">103</span>:</span><br><span class="line">      result += <span class="number">11</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">104</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">106</span>:</span><br><span class="line">      result *= result;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      result = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">switch_eg_impl</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* Table of code pointers */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> *jt[<span class="number">7</span>] = &#123;</span><br><span class="line">    &amp;&amp;loc_A, &amp;&amp;loc_def, &amp;&amp;loc_B,</span><br><span class="line">    &amp;&amp;loc_C, &amp;&amp;loc_D, &amp;&amp;loc_def,</span><br><span class="line">    &amp;&amp;loc_D</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">unsigned</span> index = n - <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">int</span> result;</span><br><span class="line">  <span class="keyword">if</span> (index &gt; <span class="number">6</span>)</span><br><span class="line">    <span class="keyword">goto</span> loc_def;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Multiway branch */</span></span><br><span class="line">  <span class="keyword">goto</span> *jt[index];</span><br><span class="line"></span><br><span class="line">  loc_def: <span class="comment">/* Default case*/</span></span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">  loc_C: <span class="comment">/* Case 103 */</span></span><br><span class="line">    result = x;</span><br><span class="line">    <span class="keyword">goto</span> rest;</span><br><span class="line"></span><br><span class="line">  loc_A: <span class="comment">/* Case 100 */</span></span><br><span class="line">    result = x * <span class="number">13</span>;</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">  loc_B: <span class="comment">/* Case 102 */</span></span><br><span class="line">    result = x + <span class="number">10</span>;</span><br><span class="line">    <span class="comment">/* Fall through */</span></span><br><span class="line"></span><br><span class="line">  rest: <span class="comment">/* Finish case 103 */</span></span><br><span class="line">    result += <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">  loc_D: <span class="comment">/* Cases 104, 106 */</span></span><br><span class="line">    result = x * x;</span><br><span class="line">    <span class="comment">/* Fall through */</span></span><br><span class="line"></span><br><span class="line">  done:</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编代码如下：</p><p><img src="../../../../images/2018/switch汇编代码.png" alt="switch汇编代码"></p><p><img src="../../../../images/2018/switch跳转表1.png" alt="switch跳转表1"></p><p><img src="../../../../images/2018/switch跳转表2.png" alt="switch跳转表2"></p><p>跳转表的步长是 4</p><blockquote><p>.rodata 的意思是：read only data</p></blockquote><h2 id="过程调用"><a href="#过程调用" class="headerlink" title="过程调用"></a>过程调用</h2><p><img src="../../../../images/2018/程序栈内存结构.png" alt="程序栈内存结构"></p><p>有以下几个要点：</p><ol><li>栈是倒着长的</li><li>每个过程调用都有一个 stack frame，栈帧</li><li>栈顶帧用两个指针来维护，一个是帧起址：%ebp，一个是栈指针：%esp 指向栈顶。</li></ol><p>%esp 在过程运行的时候可能会被抹掉，这时候可以通过%ebp 来定位。</p><p>可以看到返回地址在每一帧的最后。而每一帧的第一个位置存放着上一帧的帧起址%ebp。帧的中间则放置局部变量、过程参数等值。</p><p>有以下几种情况会将局部变量放到栈帧中：</p><ol><li>局部变量多到寄存器放不下</li><li>局部变量是数组或者结构体，必须用到引用</li><li>局部变量使用了取址符<code>&amp;</code>，所以我们必须给它生成地址</li></ol><h3 id="转移控制"><a href="#转移控制" class="headerlink" title="转移控制"></a>转移控制</h3><p><img src="../../../../images/2018/转移控制指令.png" alt="转移控制指令"></p><p>call 指令的效果是：把返回地址 push 到栈中，然后跳到调用程序的地址（也就是把 PC 设置一下）。<strong>返回地址</strong>是汇编代码中 call 指令后面那条指令的地址。</p><p>ret 指令把栈顶的返回地址 pop 出来，并跳转到这个地址。</p><p><img src="../../../../images/2018/程序调用模型.png" alt="程序调用模型"></p><h3 id="寄存器使用传统"><a href="#寄存器使用传统" class="headerlink" title="寄存器使用传统"></a>寄存器使用传统</h3><p>%eax, %edx, %ecx 是调用者保存寄存器。也就是说当过程 Q 被过程 P 调用，过程 Q 可以随意的写这三个寄存器，因为在调用 Q 之前 P 必须保存这三个寄存器的值。</p><p>%ebx, %esi, %edi 是被调用者保存寄存器。也就是说在过程 Q 写这些寄存器之前，必须保存里面的值，并在 return 之前恢复原样。</p><h3 id="过程调用例子"><a href="#过程调用例子" class="headerlink" title="过程调用例子"></a>过程调用例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int swap_add(int *xp, int *yp)</span><br><span class="line">&#123;</span><br><span class="line">  int x = *xp;</span><br><span class="line">  int y = *yp;</span><br><span class="line"></span><br><span class="line">  *xp = y;</span><br><span class="line">  *yp = x;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int caller()</span><br><span class="line">&#123;</span><br><span class="line">  int arg1 = 534;</span><br><span class="line">  int arg2 = 1057;</span><br><span class="line"></span><br><span class="line">  int sum = swap_add(&amp;arg1, &amp;arg2);</span><br><span class="line">  int diff = arg1 - arg2;</span><br><span class="line">  return sum * diff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="../../../../images/2018/过程调用内存模型.png" alt="过程调用内存模型"></p><p>一些编程语言，比如 Pascal，提供了值传参和引用传参。但 C 语言只有值传参，C++提供了引用传参。C 语言可以通过指针来实现引用传参。</p><p><img src="../../../../images/2018/过程调用汇编代码.png" alt="过程调用汇编代码"></p><p>总共申请了 24 字节的空间，8 字节用来存局部变量，8 字节用来存参数，还有 8 字节未使用。</p><blockquote><p>为什么要浪费 8 字节，原因是：内存对齐。GCC 遵循一个 x86 编程方针：栈空间必须是 16 的整数倍，包括保存%ebp 的 4 字节和返回地址的 4 字节。这里总共加起来是 24 字节，所以需要额外的 8 字节填充成 32 字节。</p></blockquote><p>swap_add 的汇编代码如下：</p><p>分为三个部分：setup、body、finish</p><p>setup:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">swap_add:</span><br><span class="line">  pushl %ebp                  Save old %ebp</span><br><span class="line">  movl %esp, %ebp             Set %ebp as frame pointer</span><br><span class="line">  pushl %ebx                  Save %ebx</span><br></pre></td></tr></table></figure><p>首先要保存调用者的帧基指针，然后重新设置当前帧基指针，然后如果用到%ebx,%esi,%edi 等寄存器就需要保存。</p><p>body:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">movl 8(%ebp), %edx            Get xp</span><br><span class="line">movl 12(%ebp), %ecx           Get yp</span><br><span class="line">movl (%edx), %ebx             Get x</span><br><span class="line">movl (%ecx), %eax             Get y</span><br><span class="line">movl %eax, (%edx)             Store y at xp</span><br><span class="line">movl %ebx, (%ecx)             Store x at yp</span><br><span class="line">addl %ebx, %eax               Return value = x+y</span><br></pre></td></tr></table></figure><p>获取参数，进行计算。</p><p>finish:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">popl %ebx                     Restore %ebx</span><br><span class="line">popl %ebp                     Restore %ebp</span><br><span class="line">ret                           Return</span><br></pre></td></tr></table></figure><p>恢复两个寄存器，同时%esp 回到了上一个帧的栈顶，指向了返回地址，然后 ret 指令就可以把 PC 置为返回地址了，这样就完成了控制权的转移。</p><p>然后执行调用完 swap_add 之后的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">movl -4(%ebp), %edx</span><br><span class="line">subl -8(%ebp), %edx</span><br><span class="line">imull %edx, %eax</span><br><span class="line">leave</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>leave 指令的作用是重置栈指针和帧指针，也可以使用 popl 来重置，很简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//使%esp指向%ebp的地址（也就是Saved %ebp那里）</span><br><span class="line">movl %ebp, %esp</span><br><span class="line">//popl指令会导致%esp+4，所以%esp之后会指向上一帧的帧尾（也就是Return Address那里），popl的内容则放到了%ebp里面</span><br><span class="line">popl %ebp</span><br></pre></td></tr></table></figure><p>而之后的<code>ret</code>指令继续将<code>Return Address</code> pop 出来，并将<code>Return Address</code>放到 PC 中。</p><p>从这个例子我们可以看出，编译器遵循一组简单的惯例来管理栈结构。</p><ol><li>通过%ebp 加偏移量（+8,+12,...）访问参数</li><li>通过 push 指令或者栈指针减偏移量来分配栈空间</li><li>在返回前恢复保存好的寄存器，并使栈指针指向调用者的返回地址（Return Address）</li></ol><p>数组、多维数组、结构体、联合体这些都比较简单，这里略过。</p><blockquote><p>要注意的点：只有 call 才会 push 一个返回地址，所以 swap_add 的栈帧中并没有返回地址，说明它没有调用其他函数</p></blockquote><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>每种数据类型都有对应的指针类型，但指针类型不是机器码的一部分，只是 C 语言提供的一种抽象，帮助程序员避免犯错。</p><h2 id="内存引用越界和缓冲区溢出"><a href="#内存引用越界和缓冲区溢出" class="headerlink" title="内存引用越界和缓冲区溢出"></a>内存引用越界和缓冲区溢出</h2><p>我们可以看到 C 语言对数组引用没有任何边界检查，而且栈里面既保存了局部变量又保存了寄存器值以及返回地址。所以一旦数组越界写就会破坏整个程序的运行。</p><p>看下面这个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Sample implementation of library function gets() */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">gets</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> c;</span><br><span class="line">  <span class="keyword">char</span> *dest = s;</span><br><span class="line">  <span class="keyword">int</span> gotchar = <span class="number">0</span>; <span class="comment">/* Has at least one character been read? */</span></span><br><span class="line">  <span class="keyword">while</span> ((c = getchar()) != <span class="string">'\n'</span> &amp;&amp; c != EOF) &#123;</span><br><span class="line">    *dest++ = c; <span class="comment">/* No bounds checking! */</span></span><br><span class="line">    gotchar = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *dest++ = <span class="string">'\0'</span>; <span class="comment">/* Terminate string */</span></span><br><span class="line">  <span class="keyword">if</span> (c == EOF &amp;&amp; !gotchar)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/* End of file or error */</span></span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Read input line and write it back */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">8</span>]; <span class="comment">/* Way too small! */</span></span><br><span class="line">  gets(buf);</span><br><span class="line">  <span class="built_in">puts</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段 C 语言代码对应的汇编代码如下：</p><p><img src="../../../../images/2018/gets缓冲区溢出.png" alt="gets缓冲区溢出"></p><p>分配数组空间的时候是直接固定了 8 字节，这里给 buf 分配的空间也是 8 字节：<code>leal -12(%ebp), %ebx</code>，并把 buf 作为参数放置于栈顶。</p><p><img src="../../../../images/2018/缓冲区溢出内存模型.png" alt="缓冲区溢出内存模型"></p><p>我们可以看到，当读写 buf[8]的时候，实际上是在读写<code>Saved %ebx</code>。</p><p><img src="../../../../images/2018/缓冲区攻击范围.png" alt="缓冲区攻击范围"></p><p>通常给被攻击的程序输入一个字符串，这个字符串包含了可执行代码的字节编码，如果我们通过缓冲区溢出修改了返回地址，那么 ret 指令就可以跳转到我们攻击代码的位置。</p><blockquote><p>蠕虫（worms）和病毒（viruses）的区别：相同点：都可以复制和传播自身，不同点：蠕虫可以自己运行，病毒是把自己加入到其他程序中，包括操作系统代码，病毒是不能独立运行的。</p></blockquote><h3 id="对抗缓冲区溢出攻击的方法"><a href="#对抗缓冲区溢出攻击的方法" class="headerlink" title="对抗缓冲区溢出攻击的方法"></a>对抗缓冲区溢出攻击的方法</h3><h4 id="栈随机化"><a href="#栈随机化" class="headerlink" title="栈随机化"></a>栈随机化</h4><p>攻击者需要插入攻击代码（一个字符串），并知道攻击代码的位置（也就是字符串存放的栈地址），而且指向这段字符串的指针也是这个字符串的一部分。如果栈的位置是固定的，那么就很容易猜到攻击代码的存放位置。用如下代码可以检测栈的位置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> local;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"local at %p\n"</span>, &amp;local);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要打印一个局部变量的地址。</p><p>栈随机化的思想是程序每次运行时栈的位置都不一样，实现方式是：程序开始时，在栈上分配一段 0~n 字节之间的随机大小的空间，例如使用<code>alloca</code>可以在栈上分配空间。程序不使用这段空间，它的作用是使后续栈的位置发生变化。分配的 n 必须足够大，这样才能有足够多的变化，但又必须足够小，这样才不会浪费空间。</p><p>栈随机化是更大一类技术的一种，这类技术称为：Address-Space Layout Randomization，ASLR，地址空间布局随机化。但攻击者还是可以采取一定措施来增加攻击成功率，一种常见的手段就是在攻击代码前中插入很长一段的<code>nop</code>指令，这个指令只会使程序计数器（PC）加一，除此之外没有任何副作用。只要攻击者能够猜中这段序列中的某个地址，就可以顺利到达攻击代码。这个序列的常用术语是：<strong>nop sled 空操作雪橇</strong>。</p><h4 id="栈破坏检测"><a href="#栈破坏检测" class="headerlink" title="栈破坏检测"></a>栈破坏检测</h4><p>在局部缓冲区和栈状态之间插入一个随机的金丝雀值（也叫哨兵值），一旦发现这个值被改变，就说明缓冲区溢出了，那么就可以将程序异常中止。</p><blockquote><p>攻击者只有输入局部缓冲区变量的权限，所以无从得知金丝雀值。</p></blockquote><p><img src="../../../../images/2018/金丝雀值.png" alt="金丝雀值"></p><p>GCC 默认就会插入金丝雀值，如果不想要可以使用参数：<code>-fno-stack-protector</code>来阻止 GCC 产生这种代码。当不使用此参数时，产生代码如下：</p><p><img src="../../../../images/2018/含金丝雀值汇编码1.png" alt="含金丝雀值汇编码1"></p><p><img src="../../../../images/2018/含金丝雀值汇编码2.png" alt="含金丝雀值汇编码2"></p><p>指令参数<code>%gs20, %eax</code>指明金丝雀值使用 segmented addressing（段寻址）从存储器中读入。将段标志为只读，这样攻击者就不能同时修改段中的金丝雀值。最后使用<code>xorl</code>比较段和栈中的金丝雀值，如果不相等则<code>call __stack_chk_fail</code>。</p><p>这种做法可以带来很小的性能损失。</p><h4 id="限制可执行代码区域"><a href="#限制可执行代码区域" class="headerlink" title="限制可执行代码区域"></a>限制可执行代码区域</h4><p>在典型的程序中，只有保存编译器产生的代码的那一部分存储空间才需要是可执行的。其他部分可以被限制为只允许读写。虚拟存储器空间在逻辑上分成了页（page），典型的每页是 2048 或者 4096 字节。由硬件提供存储器保护。以前，x86 体系结构将读和执行访问控制合并成一个 1 位标志，所以任何被标记为可读的部分也是可执行的，当然也有很多机制可以限制一些页是可读的但是不可执行，然而这些机制都很消耗性能。最近，AMD（Advanced Micro Devices）为它的 64 位处理器的内存加入了 NX, No-eXecute，不可执行位，intel 也跟进了，检查页是否可执行由硬件来完成，效率上没有任何损失。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>浮点数原理</title>
      <link href="/blog/2018/09/27/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%8E%9F%E7%90%86/"/>
      <url>/blog/2018/09/27/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p><strong>浮点数的作用</strong>：区别于整形数，用来表示小数。可以用来表示很大的数，或者非常接近 0 的小数，或者近似的做实数计算，浮点数的一般形式：$x\times 2^y$。</p><blockquote><p><strong>IEEE（pronounced “Eye-Triple-Eee”）浮点数标准</strong> 是行业内公认的标准。</p></blockquote><p><strong>rounding</strong>：when a number cannot be represented exactly in the format and hence must be adjusted upward or downward。可以翻译为：<strong>舍入</strong>。</p><p>十进制的小数表示：$d_m d_{m-1} \cdots d_1 d_0 . d_{-1} d_{-2} \cdots d_{-n}$，写成数学表达式：</p><p>$$<br>d = \sum_{i=-n}^m 10^i \times d_i<br>$$</p><p>相应的，二进制也可以写成这种形式：</p><p>$$<br>b = \sum_{i=-n}^m 2^i \times b_i<br>$$</p><a id="more"></a><h1 id="浮点数的表示"><a href="#浮点数的表示" class="headerlink" title="浮点数的表示"></a>浮点数的表示</h1><p>IEEE 浮点数的格式：$V = (-1)^s \times M \times 2^E$</p><ul><li>s 是符号（Sign），s 为 0 时是正，s 为 1 时是负</li><li>M 是有效数字（Significand，即 <strong>尾数</strong>）</li><li>E 是 <strong>指数</strong>，Exponent，也叫 <strong>幂数</strong>，<strong>阶码</strong></li><li>隐含的 <strong>基数</strong> 是 2</li></ul><p>下图是浮点数的内存分布模型，首先是符号域，然后是指数域，最后是分数域：</p><p><img src="../../../../images/浮点数内存模型.png" alt="浮点数内存模型"></p><ul><li>符号位 s 个，符号位只需要一位，s=1</li><li>指数位 k 个，指数域 $exp=e_{k-1}\cdots e_1 e_0$，用来计算指数 E</li><li>分数为 n 个，分数域 $frac=f_{n-1}\cdots f_1 f_0$，用来计算有效数字 M</li></ul><p>32 位浮点数（单精度，float 型）中，s=1，k=8，n=23；64 位浮点数（双精度，double 型）中，s=1，k=11，n=52。</p><h2 id="正常化值（Normalized-Values）"><a href="#正常化值（Normalized-Values）" class="headerlink" title="正常化值（Normalized Values）"></a>正常化值（Normalized Values）</h2><p>当 $exp$ 域既不是全 0，也不是全 1 的时候，就是正常化值。</p><p>$E = e - Bias$，其中 $e$ 就是 $exp$ 域：$e_{k-1}\cdots e_1e_0$ 的值（除去全 0 和全 1 之后，取值范围是 1 到$2^k-2$），$Bias=2^{k-1}-1$（单精度的时候是 127，双精度的时候是 1023），那么 $E$ 的取值范围，单精度的时候是：<code>-126 ~ +127</code>，双精度的时候是：<code>-1022 ~ +1023</code>，其实 $E$ 的算法就是 <strong>移码</strong> 的计算方法。</p><p>$M = 1+f$，$0\le f\lt 1$，内存里只记录 f，而 1 作为一个前导值计算时候再加上，所以 f 是分数域 $frac$ 的 $0.f_{n-1}\cdots f_1f_0$ 这种形式</p><h2 id="非正常化值（Denormalized-Values）"><a href="#非正常化值（Denormalized-Values）" class="headerlink" title="非正常化值（Denormalized Values）"></a>非正常化值（Denormalized Values）</h2><p>当指数域全 0，就是非正常化格式。</p><p>在这种情况下，指数值是 $E = 1-Bias$，也就是固定了，有效数字值 $M = f$ 也就是没有前导 1 了。这个格式下可以表示 0，因为正常化值中，一定有： $M\ge 1$，所以我们无法在正常化值格式下表示 0。当符号位是 0，有效数字 $M=f=0$，我们得到的就是<code>+0.0</code>，当符号位是 1 的时候就是<code>-0.0</code>。</p><p>除了可以表示 0，这个格式的另一个作用就是用来表示非常接近 0 的数。</p><h2 id="特殊值（Special-Values）"><a href="#特殊值（Special-Values）" class="headerlink" title="特殊值（Special Values）"></a>特殊值（Special Values）</h2><p>当指数域全 1 的时候，且分数域是全 0，就表示无穷大，如果符号域为 0，表示 $+\infty$，如果符号位是 1，则表示 $-\infty$。无穷大可以作为溢出的结果，当我们用两个很大的数相乘，或者除以 0；</p><p>当指数域全 1，且分数域并非全 0 的时候，结果可以叫做：<code>NaN</code>（Not a Number 的简写），这种值用来表示不能用实数或者无穷大表示的计算结果，比如计算：$\sqrt{-1}$ 或者 $\infty - \infty$。</p><h2 id="综合理解"><a href="#综合理解" class="headerlink" title="综合理解"></a>综合理解</h2><p>下图是三类浮点数在数轴上的显示：</p><p><img src="../../../../images/浮点数三种类型.png" alt="浮点数三种类型"></p><p>可以看到非正常化值集中在 0 附近，正常化值散布在整个数轴的空间，特殊值则只表示两个无穷值。</p><p>下图是浮点数三种类型的光滑衔接：</p><p><img src="../../../../images/浮点数三种类型光滑衔接.png" alt="浮点数三种类型光滑衔接"></p><p>看完浮点数的设计和构造我们可以发现以下这些特点：</p><ul><li><strong>从编码上有效数字域采用了无符号整数编码，而指数域采用了移码编码</strong></li><li><strong>非正常化值均匀分布在 0 附近</strong></li><li><strong>正常化值的间隔随着 $2^E$ 变大而逐渐变大，也就是精度逐渐降低</strong></li><li><strong>精度是分组的，以 $2^E$ 增加 1 为一组，每组有 $2^n$ 个数（n 是有效数字域的位数）</strong></li><li><strong>最高精度就是两个非正常化值的间隔，最低精度是最大的一组正常化值的相邻两数的间隔。</strong></li><li><strong>非正常化值按照精度只占一组，正常化值的数量是非正常化值数量的 $2^{k}-2$ 倍</strong></li><li><strong>正常化值的第一组的精度和非正常化值的精度一样，也就是实现了无缝衔接</strong></li></ul><h1 id="浮点数的计算"><a href="#浮点数的计算" class="headerlink" title="浮点数的计算"></a>浮点数的计算</h1><h2 id="舍入"><a href="#舍入" class="headerlink" title="舍入"></a>舍入</h2><p><img src="../../../../images/舍入四种策略.png" alt="舍入四种策略"></p><p><a href="https://en.wikipedia.org/wiki/Rounding" target="_blank" rel="noopener">Rounding 维基百科</a></p><p><a href="https://upload.wikimedia.org/wikipedia/commons/8/8a/Comparison_rounding_graphs_SMIL.svg" target="_blank" rel="noopener">各种 Rounding 合集图</a></p><p>浮点数中使用的是：舍入到最近的偶数，因为舍入结果放大和缩小各占 50%的概率，这样就可以防止最终结果偏大或者偏小。</p><p>下面是把浮点数舍入到小数点后两位数：</p><p>$10.00011_2(2\frac{3}{32})$ -&gt; $10.00_2(2)$ 不到一半，正常四舍五入<br>$10.00110_2(2\frac{3}{16})$ -&gt; $10.01_2(2\frac{1}{4})$ 超过一半，正常四舍五入<br>$10.11100_2(2\frac{7}{8})$ -&gt; $11.00_2(3)$ 正好一半，保证最后一位是偶数，所以向上舍入<br>$10.10100_2(2\frac{5}{8})$ -&gt; $10.10_2(2\frac{1}{2})$ 正好一半，保证最后一位是偶数，所以向下舍入</p><h2 id="浮点数加减运算"><a href="#浮点数加减运算" class="headerlink" title="浮点数加减运算"></a>浮点数加减运算</h2><h3 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h3><ul><li>相加可能产生 infinity 或者 NaN</li><li>不满足交换律，不满足结合律（因为舍入会造成精度上的损失）</li><li>加上 0 等于原来的数</li><li>除了 infinity 和 NaN，每个元素都有对应的相反数</li><li>除了 infinity 和 NaN，满足单调性，即 $a\ge b \rightarrow a+c\ge b+c$</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 浮点数加法不满足交换律</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">3.14</span> + <span class="number">1e20</span> - <span class="number">1e20</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">1e20</span> - <span class="number">1e20</span> + <span class="number">3.14</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 浮点数加法不满足结合律</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (<span class="number">3.14</span> + <span class="number">1e20</span>) - <span class="number">1e20</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">3.14</span> + (<span class="number">1e20</span> - <span class="number">1e20</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">3.14</span><br><span class="line">0</span><br><span class="line">3.14</span><br></pre></td></tr></table></figure><h3 id="具体细节"><a href="#具体细节" class="headerlink" title="具体细节"></a>具体细节</h3><p>设两个浮点数 $x$ 和 $y$：</p><p>$$<br>\begin{cases}<br>x=(-1)^{s_x} M_x 2^{E_x} \<br>y=(-1)^{s_y} M_y 2^{E_y}<br>\end{cases}<br>$$</p><p>则浮点数加减运算结果为：</p><p>$$<br>x\pm y = \left((-1)^{s_x}M_x 2^{E_x-E_y} \pm (-1)^{s_y}M_y \right)2^{E_y}<br>$$</p><ol><li><strong>对阶</strong>：首先要把指数位（阶码）调成一样，并相应的使 M 移位，由于有效域左移会引起最高有效位丢失，误差大，所以采用右移，此时阶码要增加。所以对阶原则是：<strong>小阶向大阶看齐</strong>。</li><li><strong>有效数加减</strong>：简单的无符号数字相加减。</li><li><strong>规格化</strong>：有效数求和结果可能大于 1，那么就向右规格化：尾数右移 1 位，阶码加 1。</li><li><strong>舍入</strong>：对于右移出去的位，采取舍入</li><li><strong>检查阶码是否溢出</strong>：<ul><li><strong>阶码下溢</strong>：运算结果为非规格化数</li><li><strong>阶码上溢</strong>：置溢出标志</li></ul></li></ol><h3 id="浮点数加减实例"><a href="#浮点数加减实例" class="headerlink" title="浮点数加减实例"></a>浮点数加减实例</h3><p>$x=3.14, y=2.718$ 求 $z=x+y$。</p><p>首先算出 $x$ 和 $y$ 的内存表示：</p><p>$x = 3+0.14$，3 的二进制表示是<code>11</code>，0.14 的二进制要稍微计算一下，我们让 0.14 不断的乘以 2（也就是左移），得到的整数位部分就是其二进制值的一位：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0.14 * 2 = 0.28     0</span><br><span class="line">0.28 * 2 = 0.56     0</span><br><span class="line">0.56 * 2 = 1.12     1</span><br><span class="line">0.12 * 2 = 0.24     0</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br></pre></td></tr></table></figure><p>我们可以写个程序来完成这个计算工作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取整形数的位数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDigits</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(num/<span class="number">10</span>&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        num %= <span class="number">10</span>;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取小数的二进制表示</span></span><br><span class="line"><span class="comment"> * @params precision 二进制表示精确到多少位</span></span><br><span class="line"><span class="comment"> * @params num 小数的整数表示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">getFloatBitset</span><span class="params">(<span class="keyword">int</span> precision, <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* res = <span class="keyword">new</span> <span class="keyword">char</span>[precision];</span><br><span class="line">    <span class="keyword">int</span> digits = getDigits(num);</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="built_in">pow</span>(<span class="number">10</span>, digits);</span><br><span class="line">    <span class="keyword">char</span> printFormat[<span class="number">50</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(printFormat,<span class="string">"%%0.%df"</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// cout &lt;&lt; printFormat &lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;precision;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(printFormat, num*<span class="number">1.0</span>/mod);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" * 2 = "</span>;</span><br><span class="line">        num &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(num &gt;= mod)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(printFormat, num*<span class="number">1.0</span>/mod);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"       1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            num %= mod;</span><br><span class="line">            res[i] = <span class="string">'1'</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(printFormat, num*<span class="number">1.0</span>/mod);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"       0"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            res[i] = <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取小数的二进制表示</span></span><br><span class="line"><span class="comment"> * @params precision 二进制表示精确到多少位</span></span><br><span class="line"><span class="comment"> * @params num 浮点型小数</span></span><br><span class="line"><span class="comment"> * @params digits 输入的时候浮点型小数的位数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">getFloatBitset2</span><span class="params">(<span class="keyword">int</span> precision, <span class="keyword">float</span> num, <span class="keyword">int</span> digits)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* res = <span class="keyword">new</span> <span class="keyword">char</span>[precision];</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="built_in">pow</span>(<span class="number">10</span>,digits);</span><br><span class="line">    <span class="comment">// cout&lt;&lt;mod&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">char</span> printFormat[<span class="number">50</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(printFormat,<span class="string">"%%0.%df"</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;precision;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(printFormat, num);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" * 2 = "</span>;</span><br><span class="line">        num*=<span class="number">2</span>;</span><br><span class="line">        num = round(num*mod)/mod;</span><br><span class="line">        <span class="keyword">if</span>(num &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(printFormat, num);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"       1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            num -= <span class="number">1</span>;</span><br><span class="line">            res[i] = <span class="string">'1'</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(printFormat, num);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"       0"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            res[i] = <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="comment">// char* res = getFloatBitset(atoi(argv[1]), atoi(argv[2]));</span></span><br><span class="line">    <span class="keyword">char</span>* res = getFloatBitset2(atoi(argv[<span class="number">1</span>]), atof(argv[<span class="number">2</span>]), atoi(argv[<span class="number">3</span>]));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码保存成：<code>float2Bitset.cpp</code>文件，然后编译，并使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -o float2Bitset float2Bitset.cpp</span><br><span class="line">$ ./float2Bitset 23 0.14 2</span><br></pre></td></tr></table></figure><p>小数位精确到 23 位的话，3.14 的定点浮点数表示是：<code>11.00100011110101110000101</code>。</p><p>转成浮点数，首先规格化 M，那么整体要右移 1 位，指数是 1，由 $E = e-Bias$，$E=1$, $Bias=127$ 得 $e=128$，也就是：<code>1000 0000</code>。</p><p>最终 3.14 的内存表示是：</p><p>$$<br>\underbrace{0}_{Sign}~\underbrace{10000000}_{Exponent}~~\underbrace{10010001111010111000011}_{Significand}<br>$$</p><p>同样的方法得到 2.718 的内存表示：</p><p>$$<br>\underbrace{0}_{Sign}~\underbrace{10000000}_{Exponent}~~\underbrace{01011011111001110110110}_{Significand}<br>$$</p><p>这两个数恰好是同阶的，那么就不需要对阶操作了。将 M 相加，但这个数太长了看着眼花，我们写个加法程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将两个相同位数的二进制数相加</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">addBitset</span><span class="params">(<span class="keyword">char</span> num1[], <span class="keyword">char</span> num2[], <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* res = <span class="keyword">new</span> <span class="keyword">char</span>[length+<span class="number">2</span>];</span><br><span class="line">    res[length+<span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=length<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        res[i+<span class="number">1</span>] = num1[i]-<span class="string">'0'</span>+num2[i]-<span class="string">'0'</span>+carry+<span class="string">'0'</span>;</span><br><span class="line">        carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(res[i+<span class="number">1</span>]&gt;<span class="string">'1'</span>)&#123;</span><br><span class="line">            res[i+<span class="number">1</span>] -= <span class="number">2</span>;</span><br><span class="line">            carry = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(carry)&#123;</span><br><span class="line">        res[<span class="number">0</span>]=<span class="string">'1'</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        res[<span class="number">0</span>]=<span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(argv[<span class="number">1</span>][i]!=<span class="string">'\0'</span>)&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">char</span>* res = addBitset(argv[<span class="number">1</span>], argv[<span class="number">2</span>], i);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码保存成：<code>addBitset.cpp</code>，编译并使用该程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -o addBitset addBitset.cpp</span><br><span class="line">$ ./addBitset 10010001111010111000011 01011011111001110110110</span><br></pre></td></tr></table></figure><p>相加结果等于：<code>0 11101101110100101111001</code>，最高位没有产生进位，这里用了一个 0 来代替，但两个前导 1 相加产生了进位，所以还需要对 M 右归一下，再对指数加 1。所以加法结果的浮点数表示是：</p><p>$$<br>\underbrace{0}_{Sign}~\underbrace{10000001}_{Exponent}~~\underbrace{01110110111010010111101}_{Significand}<br>$$</p><p>这个数的十进制表示的计算方法是：$$2^2 \times (1+0\times (\frac{1}{2})^1 + 1\times (\frac{1}{2})^2 + 1\times (\frac{1}{2})^3 +1\times (\frac{1}{2})^4+0\times(\frac{1}{2})^5+\cdots)$$</p><p>我们依然采用程序来计算这一长串二进制对应的十进制小数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">bitset2Float</span><span class="params">(<span class="keyword">char</span>* num1, <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> res = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">        <span class="keyword">double</span> temp = (num1[i]-<span class="string">'0'</span>)/<span class="built_in">pow</span>(<span class="number">2</span>,count);</span><br><span class="line">        <span class="comment">// cout &lt;&lt; temp &lt;&lt; endl;</span></span><br><span class="line">        res += temp;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(argv[<span class="number">1</span>][i]!=<span class="string">'\0'</span>)&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> res = bitset2Float(argv[<span class="number">1</span>],i);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码保存为：<code>Bitset2float.cpp</code>，编译并执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -o Bitset2float Bitset2float.cpp</span><br><span class="line">$ ./Bitset2float 01110110111010010111101</span><br></pre></td></tr></table></figure><p>对得到结果：<code>0.4645</code>，$1.4645\times 2^2 = 5.858$，而 $3.14+2.718=5.858$，这就说明我们的计算无误。</p><h3 id="算法流程图"><a href="#算法流程图" class="headerlink" title="算法流程图"></a>算法流程图</h3><p><img src="../../../../images/浮点数加减流程图.jpg" alt="浮点数加减流程图"></p><p>这个流程图并不是完美的，真实的浮点数流程图和浮点数计算电路比这个复杂。另外我忘画了一个东西，这个图最后应该加上溢出处理模块，E 可能会上溢（当 E 加 1 的时候），也可能会下溢（当 E 减 1 的时候）。</p><p>最后这个流程图中没有对特殊值的判断，比如：$\infty - \infty = NaN$, $\infty + \infty = \infty$, $NaN + 任何数 = NaN$。</p><p>了解了浮点数加法的流程之后，最后我们回到最上面说的 <strong>浮点数加减法不满足交换律和结合律</strong>，从计算细节分析为什么不行。</p><p>首先 3.14 的浮点数表示我们已经计算过了，那么 1e20 的浮点数是多少呢？1e20 也就是 $10^{20}$，用辗转相除法可以得到其二进制表示。我们这里使用计算器工具</p><p><img src="../../../../images/10的19次方的二进制.png" alt="10的19次方的二进制"></p><p>很遗憾的是 64bit 只能摆的下 $10^{19}$。我试了一下把源程序中的 1e20 换成 1e19 也是同样的结果。所以我们就使用 1e19 来分析这道题。</p><p>首先是 M 规格化，M 右移 63 位，E 加 63，舍入 M，那么 1e19 最终的双精度浮点数表示是：<code>0 10000111110 0001010110001110010001100000100100010011110100000000</code></p><p>小阶向大阶看齐，3.14 的阶是 1，M 需要右移 62 位，而 M 的精度才 52，可想而知 M 就是 0 了。那么 3.14 + 1e19 的结果就是 <strong>1e19</strong>。1e20 就更加不用说了。</p><h2 id="浮点数乘除"><a href="#浮点数乘除" class="headerlink" title="浮点数乘除"></a>浮点数乘除</h2><h3 id="基本性质-1"><a href="#基本性质-1" class="headerlink" title="基本性质"></a>基本性质</h3><ul><li>相乘可能产生 infinity 或者 NaN</li><li>不满足交换律，结合律，分配率（因为溢出会造成程序无法计算出正确的结果）</li><li>乘以 1 会等于原来的数</li><li>除了 infinity 和 NaN，满足单调性：$a\ge b \rightarrow a\times c \ge b \times c$</li></ul><h3 id="具体细节-1"><a href="#具体细节-1" class="headerlink" title="具体细节"></a>具体细节</h3><p>设两个浮点数 $x$ 和 $y$ ：</p><p>$$<br>\begin{cases}<br>x = \pm M_x 2^{E_x} \<br>y = \pm M_y 2^{E_y}<br>\end{cases}<br>$$</p><p>则浮点数乘除运算结果是：</p><p>$$<br>xy = \pm (M_x\times M_y)2^{E_x\pm E_y}<br>$$</p><ol><li>计算阶码，判断是否溢出</li><li>求有效数的乘积</li><li>有效数舍入</li><li>计算符号位</li></ol><p>浮点数还有相当多的细节，可以参考：<a href="https://zh.wikipedia.org/wiki/IEEE_754" target="_blank" rel="noopener">IEEE 754</a></p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>wsl oh my zsh 字符乱码问题</title>
      <link href="/blog/2018/09/20/wsl-oh-my-zsh%E5%AD%97%E4%BD%93%E9%97%AE%E9%A2%98/"/>
      <url>/blog/2018/09/20/wsl-oh-my-zsh%E5%AD%97%E4%BD%93%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="安装-oh-my-zsh"><a href="#安装-oh-my-zsh" class="headerlink" title="安装 oh my zsh"></a>安装 oh my zsh</h2><p>首先检查自己有没有 zsh：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/shells</span><br></pre></td></tr></table></figure><p>如果有的话就下载<a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="noopener">oh my zsh</a></p><a id="more"></a><h2 id="设置默认-shell"><a href="#设置默认-shell" class="headerlink" title="设置默认 shell"></a>设置默认 shell</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure><p>有可能会遇到设置不成功的问题，那么我们可以手动修改<code>/etc/passwd</code>，找到自己那一条配置信息，把默认 shell 改成<code>/bin/zsh</code>就 OK 了。</p><h2 id="字体问题"><a href="#字体问题" class="headerlink" title="字体问题"></a>字体问题</h2><p><code>-&gt;</code>等一些其他字符可能显示不出来，这是字体导致的。google 一下：<code>wsl oh my zsh font</code>，找到：<a href="https://github.com/Microsoft/WSL/issues/1517" target="_blank" rel="noopener">https://github.com/Microsoft/WSL/issues/1517</a>，下载并设置字体为：<a href="https://github.com/powerline/fonts/blob/master/DejaVuSansMono/DejaVu%20Sans%20Mono%20for%20Powerline.ttf" target="_blank" rel="noopener">DejaVuSansMono</a>。</p><h2 id="怎么设置字体"><a href="#怎么设置字体" class="headerlink" title="怎么设置字体"></a>怎么设置字体</h2><p>右键标题栏，进入属性</p>]]></content>
      
      
      <categories>
          
          <category> debug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>wsl修改右键bash图标</title>
      <link href="/blog/2018/09/19/wsl%E4%BF%AE%E6%94%B9%E5%8F%B3%E9%94%AEbash%E5%9B%BE%E6%A0%87/"/>
      <url>/blog/2018/09/19/wsl%E4%BF%AE%E6%94%B9%E5%8F%B3%E9%94%AEbash%E5%9B%BE%E6%A0%87/</url>
      
        <content type="html"><![CDATA[<p>使用 windows subsystem for linux (简称：WSL) 的时候，遇到一个小问题，在文件管理器中右键，唤出 bash，发现图标不对：</p><p><img src="https://i.loli.net/2018/09/19/5ba25208ca7de.png" alt="截图1"></p><a id="more"></a><p>点击之后可以看到调用的是哪个程序：</p><p><img src="https://i.loli.net/2018/09/19/5ba254dbe66ea.png" alt="截图2"></p><p>google 一下：<code>windows 右键图标</code>，搜到百度经验：<a href="https://jingyan.baidu.com/article/7c6fb428321b4a80642c90fd.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/7c6fb428321b4a80642c90fd.html</a>，照着修改就行了。</p><p>如图：</p><p><img src="https://i.loli.net/2018/09/19/5ba255cbd964f.png" alt="截图3"></p><p>那么改成什么呢？google 一下：<code>wsl bash icon</code>，搜到：<a href="https://github.com/Microsoft/WSL/issues/1269" target="_blank" rel="noopener">https://github.com/Microsoft/WSL/issues/1269</a>，然后又在这个页面找到了这个：<a href="https://github.com/cmderdev/cmder/issues/1063#issuecomment-401947209" target="_blank" rel="noopener">https://github.com/cmderdev/cmder/issues/1063#issuecomment-401947209</a></p><p><img src="https://i.loli.net/2018/09/20/5ba2ffde07591.png" alt="截图4"></p><p>把 icon 换成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\WindowsApps\CanonicalGroupLimited.UbuntuonWindows_1804.2018.817.0_x64__79rhkp1fndgsc\ubuntu.exe</span><br></pre></td></tr></table></figure><p>再点击右键，就能看到这个图标了。</p><p>除了修改右键显示的 icon，还可以修改右键显示的名字，以及运行的目标程序。</p><p><img src="https://i.loli.net/2018/09/20/5ba301516885f.png" alt="TIM图片20180920100903.png"></p><p>改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\WindowsApps\CanonicalGroupLimited.UbuntuonWindows_1804.2018.817.0_x64__79rhkp1fndgsc\ubuntu.exe</span><br></pre></td></tr></table></figure><p>但发现无法把工作目录定到当前右键的目录，需要加一个<code>run</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\WindowsApps\CanonicalGroupLimited.UbuntuonWindows_1804.2018.817.0_x64__79rhkp1fndgsc\ubuntu.exe run</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> debug </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>编程珠玑系列笔记 -- 第二章 啊哈！算法</title>
      <link href="/blog/2018/06/28/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
      <url>/blog/2018/06/28/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>本书的另一个中心思想显而易见：<strong>良好的算法是程序性能提升的关键。</strong></p><p>下面还是通过探讨几个实例，来领会一下算法的重要性。</p><a id="more"></a><h2 id="三个问题"><a href="#三个问题" class="headerlink" title="三个问题"></a>三个问题</h2><p>A. 给定一个最多包含40亿个随机排列的32位整数的顺序文件，找出一个不在文件中的32位整数(在文件中至少缺失一个这样的数 - - 为什么? )。在具有足够内存的情况下，如何解决该问题?如果有几个外部的“临时”文件可用，但是仅有几百字节的内存，又该如何解决该问题?</p><p>至少缺失一个这样的数是因为：32位无符号整数的表示范围是<code>0 到 4,294,967,295</code>，比40亿大：。如果有足够的内存，可以采用第一章的位图表示法，需要的内存是：<code>4 000 000 000/8 = 500 000 000</code>，500MB的内存。而且我们需要使用二分查找来加速查找过程，顺序遍历500MB的空间是很慢的。使用二分查找对这种量大的数据集是非常重要的手段，但 <strong>二分查找的基础是数据集有序</strong>。所以初看这里是没法直接使用二分法的，但是如果我们这样想：32位整数的每一位不是0就是1，我们按照第1位划分的话，就可以划分出两个集合（需要遍历全部数据一遍），如果某个集合小于 $2^{31}$ 个数就选中成为我们下一次划分的对象（如果两个集合都小于 $2^{31}$ 就随便选一个），直到我们得到一个空集，而这个空集中本来应该存在的那些数，就是缺失的数了。在划分集合的时候，我们实际上要把数据存到硬盘中，可以使用buffer来减少IO次数。最坏时间复杂度是一个等比数列：<br>$$n+\frac{1}{2}n+\cdots+1 = 2n$$</p><p>可见这里的二分法并没有起到<code>logN</code>的效果。需要遍历的二分法还算什么二分法呢？但庆幸的是，我们至少可以解决这一题。</p><p>B. 将一个n元一维向量左旋转i个位置。例如，当n=8且i=3时，向量abcdefgh旋转为defghabc。简单的代码使用一个n元的中间向量在n步内完成该工作。你能否仅使用数十个额外字节的存储空间，在正比于n的时间内完成向量的旋转？</p><p>方法1：将前i个元素复制到一个临时空间，余下的n-i个元素向左移i个位置，最后将最初的i个元素从临时空间复制到x中余下的位置。时间复杂度：2i+(n-i)=n+i，也就是O(n)；空间复杂度：i，也就是O(n)。</p><p>方法2：使用类似方法1的办法，但只使用一个元素大小的临时空间，每次只移动一位，总共需要移动i次。时间复杂度：(n+1)*i，也就是O(n^2)；空间复杂度：O(1)。</p><p>方法3：杂技算法。第一步：移动<code>x[0]</code>到临时变量t，然后移动<code>x[i]</code>到<code>x[0]</code>，<code>x[2i]</code>到<code>x[i]</code>，依此类推（将x中的所有下标对n取模），直至返回到取<code>x[0]</code>中的元素，此时改为从t取值然后终止过程。第二步：如果该过程没有移动全部元素，就从<code>x[1]</code>开始再次进行移动（执行第一步的算法操作），直到所有的元素都已经移动为止。</p><p>这个算法的核心思想应该是这样的：<strong>将该数组序列看成是一个环状队列，每次执行第一步的算法都可以使一组元素落到它们最终的位置上，而又不影响到其它元素。</strong></p><p>第二步执行的次数是<a href="https://zh.wikipedia.org/zh-hans/%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B8" target="_blank" rel="noopener"><code>GCD(n,i)</code></a>（n和i的最大公约数）。这样一来我们就不用记录元素是否移动过这个状态了，直接就可以知道循环多少次。</p><p>该算法的时间复杂度：n+GCD(n,i)，也就是O(n)。空间复杂度：O(1)。</p><p>这个算法虽然表现不错，但是不便于理解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a%b?gcd(b, a%b): b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acrobat</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">20</span>, i=<span class="number">6</span>;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;gcd(n,i);j++)&#123;</span><br><span class="line">        temp = a[j];</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i*(count+<span class="number">1</span>)%n == <span class="number">0</span>)&#123;</span><br><span class="line">                a[j+i*count%n] = temp;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                a[j+i*count%n] = a[j+i*(count+<span class="number">1</span>)%n];</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">        a[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    acrobat();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"out"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法4：递归算法。旋转向量x其实就是交换向量ab的两段，得到向量ba。这里a代表x中的前i个元素。假设a比b短，将b分为$b_l$和$b_r$，使得$b_r$具有与a相同的长度。交换a和$b_r$，也就将$ab_l b_r$转换为$b_r b_l a$。序列a此时已处于其最终的位置，因此现在的问题就集中到交换b的部分。由于新的问题与原来的问题具有相同的形式，我们可以递归解决。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分别从i和j位置开始，交换k个元素</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">0</span>;p&lt;k;p++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[i+p];</span><br><span class="line">        a[i+p] = a[j+p];</span><br><span class="line">        a[j+p] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从i位置开始，处理左leni，右lenj的旋转</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">first</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> i, <span class="keyword">int</span> leni, <span class="keyword">int</span> lenj)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(leni == lenj)&#123;</span><br><span class="line">        swap(a, i, i+leni, leni);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(leni&lt;lenj)&#123;</span><br><span class="line">        swap(a, i, i+lenj, leni);</span><br><span class="line">        first(a, i, leni, lenj-leni);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        swap(a, i, i+leni, lenj);</span><br><span class="line">        first(a, i+lenj, leni-lenj, lenj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法5：三次翻转: $(a^r b^r)^r = ba$。从ab开始，首先对a求逆，得到$a^r b$，然后对b求逆，得到$a^r b^r$。最后对整体求逆，得到$(a^r b^r)^r$，此时恰好就是ab。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reverse(0, i-1) /* cbadefgh */</span><br><span class="line">reverse(i, n-1) /* cbahgfed */</span><br><span class="line">reverse(0, n-1) /* defghabc */</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从i位置开始，到j位置结束(包含j)，翻转这一段的a中的元素</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;(j+<span class="number">1</span>-i)/<span class="number">2</span>;k++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[k+i];</span><br><span class="line">        a[k+i] = a[j-k];</span><br><span class="line">        a[j-k] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//i位置是b段的开始，总长度n</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">res</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> i, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    reverse(a, <span class="number">0</span>, i<span class="number">-1</span>);</span><br><span class="line">    reverse(a, i, n<span class="number">-1</span>);</span><br><span class="line">    reverse(a, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C. 给定一个英语字典，找出其中的所有变位词集合。例如，“pots”、“stop”、“tops”互为变位词，因此每一个单词都可以通过改变其他单词中字母的顺序来得到。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>编程珠玑系列笔记 -- 第一章 开篇</title>
      <link href="/blog/2018/06/22/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
      <url>/blog/2018/06/22/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>本书的中心思想：<strong>对实例研究的深入思考不仅有趣，而且可以获得实际的益处。</strong></p><p>规律和智慧都隐藏在实例之中，而我们通过实例来窥探它们。实例是道的载体。</p><h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><p>明确问题，一旦问题明确，这场战役就成功了 90%。</p><p>确定用户的真实需求是程序设计的根本。</p><p>简单的程序通常比具有相同功能的复杂程序更可靠、更安全、更健壮、更高效，而且易于实现和维护。因为简单的程序往往更具有概括性、更抽象、更能洞悉问题的本质。</p><a id="more"></a><h3 id="具体问题具体分析"><a href="#具体问题具体分析" class="headerlink" title="具体问题具体分析"></a>具体问题具体分析</h3><p>A：怎样给一个磁盘文件排序？<br>B：为什么非要自己写排序程序呢？为什么不用系统提供的排序程序呢？<br>A：我需要在一个大系统中排序。由于不明的技术原因，我不能使用系统中的文件排序程序。<br>B：需要排序的内容是什么？文件中有多少条记录？每条记录的格式是什么？<br>A：文件最多包含 1 千万条记录，每条记录都是 7 位的整数。<br>B：等一下，既然文件这么小，何必非要在非要在磁盘上进行排序呢？为什么不在内存里进行排序呢？<br>A：尽管机器有许多兆字节的内存，但排序功能只是大系统中的一部分，所以估计到时候只有 1MB 的内存可用。<br>B：你还能告诉我其他一些与记录相关的信息吗？<br>A：每条记录都是 7 位的正整数，再无其他相关数据。每个整数最多出现一次。</p><p>实际上问了这么多，提问者都没有主动将自己的问题无保留的告诉被求助对象，反而是被求助对象耐心的一点一点询问。问题的真实背景是这样的：</p><p>在美国，电话号码由 3 位区号后再跟 7 位数字组成，拨打含免费区号 800（当时只有这一个号码）的电话是不收费的。这位程序员正在开发这类数据库处理系统的一小部分，需要排序的整数就是免费电话号码。输入文件是电话号码列表，号码重复出现算出错。期望的输出文件是以升序排列的电话号码列表。应用背景同时定义了相应的性能需求。当与系统的会话时间较长时，用户大约每小时请求一次有序文件，并且在排序未完成之前什么都做不了。因此，排序最多只允许执行几分钟，10 秒钟是比较理想的运行时间。</p><h3 id="准确的问题描述"><a href="#准确的问题描述" class="headerlink" title="准确的问题描述"></a>准确的问题描述</h3><p><strong>输入：</strong> 一个最多包含 n 个正整数的文件，每个数都小于 n，其中 n=$10^7$。如果在输入文件中有任何整数重复出现就是致命错误。没有其他数据与该整数相关联。</p><p><strong>输出：</strong> 按升序排列的输入整数的列表。</p><p><strong>约束：</strong> 最多有（大约）1MB 的内存可用，有充足的磁盘存储空间。运行时间最多几分钟，运行时间为 10 秒钟就不需要再优化了。</p><h3 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h3><p>传统的排序有归并排序、快速排序，一般人想到的都是使用一个 4 字节的 int 型来表示数据，但 1000 万的数据就需要 40MB 的内存，所以需要至少 40 趟排序，需要读取输入文件至少 40 次，这将会是非常大的开销。</p><p>很显然，我们真正要做的应该是压缩数据表示，如果能让所有数据一次读入内存（仅 1MB）就好了。考虑到这一题的特殊性，我们使用长度为 1000 万位的位图来表示所有数据，每个整数都只占 1bit，可以说是极限的数据表示法了。这样一来我们只需要 125 万个字节，也就是 1.25MB 内存。满足了一次读入内存的要求。</p><p>这种数据表示，利用了该问题的三个在排序问题中不常见的属性：</p><ol><li>输入数据限制在相对较小的范围内</li><li>数据没有重复</li><li>对每条记录而言，除了单一整数外，没有任何其他关联数据</li></ol><p>排序伪代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* phase 1: initialize set to empty */</span><br><span class="line">for i = [0, n)</span><br><span class="line">    bit[i]=0</span><br><span class="line">/* phase 2: insert present elements into the set */</span><br><span class="line">for each i in the input file</span><br><span class="line">    bit[i]=1</span><br><span class="line">/* phase 3: write sorted output */</span><br><span class="line">for i = [0, n)</span><br><span class="line">    if b[i]==1</span><br><span class="line">        write i on the output file</span><br></pre></td></tr></table></figure><p><strong>时间-空间折中与双赢：</strong> 随着现在存储器的空间越来越大，我们往往倾向于用空间换时间的算法，这种折中非常常见。但减少程序的运行空间需求也会减少其运行时间。空间需求的减少之所以会导致运行时间的减少，有两个原因：需要处理的数据变少了，意味着处理这些数据所需的时间也变少了。同时可以将这些数据保存在内存中而不是磁盘上，进一步避免了磁盘访问的时间（IO 是巨大的开销，网络传递数据是更大的开销）。当然了，只有在设计远非最优的时候，才有可能时空双赢。</p><blockquote><p>折中在所有工程领域都存在。例如，汽车设计者可能会通过增加沉重的部件，用行驶里程的减少来换取更快的加速。但双赢是更好的结果。我对自己驾驶过的一辆小轿车做过一番研究，我观察到：“轿车基本结构重量的减少会使各底盘部件的重量进一步减少--甚至消除了对某些底盘部件的需求，例如转向助力系统。”</p></blockquote><h4 id="真实代码"><a href="#真实代码" class="headerlink" title="真实代码"></a>真实代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BITSPERWORD 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHIFT 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MASK 0x1F</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N/BITSPERWORD];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    a[i&gt;&gt;SHIFT] |= (<span class="number">1</span>&lt;&lt;(i&amp;MASK));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    a[i&gt;&gt;SHIFT] &amp;= ~(<span class="number">1</span>&lt;&lt;(i&amp;MASK));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[i&gt;&gt;SHIFT] &amp; (<span class="number">1</span>&lt;&lt;(i&amp;MASK));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        clear(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;i)!=EOF)&#123;</span><br><span class="line">        <span class="built_in">set</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(test(i))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对移位操作熟悉的话就会知道，<code>i&gt;&gt;SHIFT</code>的意思就是<code>i/32</code>。<code>a[i&gt;&gt;SHIFT]</code>也就是定位到 i 所属的数组单元（每个数组单元 4 个字节）。而<code>i&amp;MASK</code>的意思是<code>i%32</code>，然后<code>(1&lt;&lt;(i&amp;MASK))</code>就定位了 i 在所属的数组单元中的具体位置。</p><p>但我们手上没有数据来测试我们的代码是否正确，测试数据可以用随机生成的办法产生，具体会在<a href="#">《编程珠玑第 12 章 取样问题》</a>中讲解。</p><p>接下来我们来看看习题：</p><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><ol><li>如果不缺内存，如何使用一个具有库的语言来实现一种排序算法以表示和排序集合？</li></ol><p>使用 C 语言的标准库函数<code>qsort</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">intcompare</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *x - *y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10000000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[n])!=EOF)&#123;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    qsort(a, n, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), intcompare);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 C++的标准模板库中的容器<code>set</code>来完成相同任务：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator j;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; i)&#123;</span><br><span class="line">        S.insert(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(j=S.begin();j&lt;S.end();j++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>如何使用位逻辑运算（例如与、或、移位）来实现位向量？</li></ol><p>代码上面已经给出：<a href="#真实代码">真实代码</a></p><ol start="3"><li><p>运行时效率是设计目标的一个重要组成部分，所得到的程序需要足够高效。在你自己的系统上实现位图排序并度量其运行时间。该时间与系统排序的运行时间以及习题 1 中排序的运行时间相比如何？假设 n 为 10000000，且输入文件包含 10000000 个整数。</p></li><li><p>如果认真考虑了习题 3，你将会生成小于 n 且没有重复的 k 个整数的问题。最简单的方法就是使用前 k 个正整数。这个极端的数据集合将不会明显地改变位图方法的运行时间，但是可能会歪曲系统排序的运行时间。如何生成位于 0 至 n-1 之间的 k 个不同的随机顺序的随机整数？尽量使你的程序简短且高效。</p></li><li><p>那个程序员说他有 1MB 的内存空间可用，但是我们概要描述的代码需要 1.25MB 内存。他可以不费力的索取到额外的空间。如果 1MB 空间是严格的边界，你会推荐如何处理呢？你的算法的运行时间又是多少？</p></li></ol><p>使用位图表示 1 000 万个数需要 1000 万个位，或者说 125 万字节。考虑到没有以数字 0 或 1 打头<br>的电话号码，我们可以将内存需求降低为 100 万字节。另一种做法是采用两趟算法，首先使用<br>5 000 000/8=625 000 个字的存储空间来排序 0~4 999 999 之间的整数，然后在第二趟排序 5 000 000~9 999 999 的整数。k 趟算法可以在 kn 的时间开销和 n/k 的空间开销内完成对最多 n 个小于 n 的无重复正整数的排序。</p><ol start="6"><li>如果那个程序员说的不是每个整数最多出现一次，而是每个整数最多出现 10 次，你又如何建议他呢？你的解决方案如何随着可用存储空间总量的变化而变化？</li></ol><p>如果每个整数最多出现 10 次，那么我们就可以使用 4 位的半字节来统计它出现的次数。利用习题 5 的答案，我们可以使用 10 000 000/2 个字节在 1 趟内完成对整个文件的排序，或使用 10 000 000/2k 个字节在 k 趟内完成对整个文件的排序。</p><ol start="9"><li>使用更多的空间来换取更少的运行时间存在一个问题：初始化空间本身需要消耗大量的时间。说明如何设计一种技术，在第一次访问向量的项时将其初始化为 0。你的方案应该使用常量时间进行初始化和向量访问，使用的额外空间应正比于向量的大小。因为该方法通过进一步增加空间来减少减少初始化的时间，所以仅在空间很廉价、时间很宝贵且向量很稀疏的情况下才考虑使用。</li></ol><p>借助于两个额外的 n 元向量 from、to 和一个整数 top，from 和 to 也都没有初始化过，top 初始化为 0。当我们访问索引为 i 的 data 元素，想要知道<code>data[i]</code>有没有初始化过。如果<code>from[i]&lt;top</code>且<code>to[from[i]]=i</code>，那么说明已经初始化过。to 数组就是用来记录已经访问过哪些 data 元素的，实际上 to 数组可以是一个<a href="https://zh.wikipedia.org/zh/Vector_(STL" target="_blank" rel="noopener">动态数组</a>&gt;)。</p><p><img src="../../../../images/2018/编程珠玑第一章1.png" width="300px"></p><p>下面代码实现对 data[i]的首次访问：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from[i] = top;</span><br><span class="line">to[top] = i;</span><br><span class="line">data[i] = <span class="number">0</span>;</span><br><span class="line">top++;</span><br></pre></td></tr></table></figure><ol start="10"><li>在成本低廉的隔日送达时代之前，商店允许顾客通过电话订购商品，并在几天后上门自取。商店的数据库使用客户的电话号码作为其检索的主关键字（客户知道他们自己的电话号码，而且这些关键字几乎都是唯一的）。你如何组织商店的数据库，以允许高效的插入和检索操作？</li></ol><p>商店将纸质订单表格放在 10x10 的箱数组中，使用客户电话号码的最后两位作为散列索引。当客户打电话下订单时，将订单放到适当的箱中。当客户来取商品时，销售人员顺序搜索对应箱中的订单--这就是经典的“用顺序搜索来解决冲突的开放散列”。电话号码的最后两位数字非常接近于随机，因此是非常理想的散列函数，而最前面的两位数字则很不理想 - - 为什么?一些市政机关使用类似的方案在记事本中记录信息。</p><ol start="11"><li>在 20 世纪 80 年代早期，洛克希德公司加利福尼亚州桑尼维尔市工厂的工程师每天都要将许多由计算机辅助设计（CAD）系统生成的图纸从工厂送到位于圣克鲁斯市的测试站。虽然仅有 40 公里远，但使用汽车快递服务每天都需要一个多小时的时间（由于交通阻塞和山路崎岖），花费 100 美元。请给出新的数据传输方案并估计每一种方案的费用。</li></ol><p>两地的计算机原先是通过微波连接的，但是当时测试站打印图纸所需的打印机却非常昂贵。因此，该团队在主厂绘制图纸，然后拍摄下来并通过信鸽把 35 毫米的底片送到测试站，在测试站进行放大并打印成图片。鸽子来回一.次需要 45 分钟，是汽车所需时间的一半，并且每天只需要花费几美元。在项目开发的 16 个月中，信鸽传送了几百卷底片，仅丢失了两卷(当地有鹰，因此没有让信鸽传送机密数据)。由于现在打印机比较便宜，因此可以使用微波链路解决该问题。</p><ol start="12"><li>载人航天的先驱们很快就意识到需要在外太空的极端环境下实现顺利书写。民间盛传美国国<br>家宇航局(NASA)花费 100 万美元研发出了一种特殊的钢笔来解决这个问题。那么，前苏联又会如何解决相同的问题呢?</li></ol><p>看过三傻大闹宝莱坞的都知道，前苏联用的是铅笔，但铅笔的碎屑由于失重漂浮在空中会是很麻烦的问题。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《APUE-3rd》 读书笔记 -- File I/O</title>
      <link href="/blog/2018/05/28/File-IO/"/>
      <url>/blog/2018/05/28/File-IO/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这章讲的是文件 IO，其中有几个非常重要的概念：</p><ol><li>File Desriptors，文件描述符</li><li>current file offset，当前文件偏移量</li><li>File Sharing Data Structure，文件共享数据模型</li><li>file descriptor flags ，文件描述位</li><li>file status flags ，文件状态位</li></ol><a id="more"></a><h2 id="File-Descriptors"><a href="#File-Descriptors" class="headerlink" title="File Descriptors"></a>File Descriptors</h2><ul><li>对内核来说，所有 <strong>打开的文件</strong> 都使用 file descriptor 引用。</li><li>文件描述符是一个非负整数。当我们打开一个存在的文件或者创建一个新文件，内核返回一个文件描述符给进程。</li><li>当我们想要读或者写一个文件，我们通过文件描述符来确定这个文件，文件描述符是被 open 或者 creat 返回的，然后作为 read 或者 write 的一个参数。</li></ul><blockquote><p>文件描述符都使用尽可能小的非负整数，File descriptors range from 0 through OPEN_MAX−1.</p></blockquote><p>有三个 magic number，0 代表 STDIN_FILENO，1 代表 STDOUT_FILENO，2 代表 STDERR_FILENO。虽然这已经是 POSIX.1 所定义的标准，但为了程序的可读性，还是不建议直接写数字。这三个常量定义在<code>&lt;unistd.h&gt;</code>中。</p><h2 id="open-and-openat-Functions"><a href="#open-and-openat-Functions" class="headerlink" title="open and openat Functions"></a>open and openat Functions</h2><p>A file is opened or created by calling either the open function or the openat function.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> oflag, ... <span class="comment">/* mode_t mode */</span> )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> oflag, ... <span class="comment">/* mode_t mode */</span> )</span></span>;</span><br><span class="line"><span class="comment">// Both return: file descriptor if OK, −1 on error</span></span><br></pre></td></tr></table></figure><p>最后一个参数是<code>...</code>，这是 ISO C 定义剩下的多个参数的方式。对这些函数来说，只有当新文件被创建时，最后一个参数才被使用，后面我们会讲。在这个原型中我们把这个参数写作一个注释。</p><p>path 这个参数是要打开或者要创建的文件的名字。这个函数有多种操作，定在在 oflag 参数里。这个参数由下列一个或者多个定义在<code>&lt;fcntl.h&gt;</code>头文件中的常量通过 <strong>或(一种逻辑操作)</strong> 操作构成：</p><p>O_RDONLY Open for reading only</p><p>O_WRONLY Open for writing only</p><p>O_RDWR Open for reading and writing</p><blockquote><p>Most implementations define O_RDONLY as 0, O_WRONLY as 1, and O_RDWR as 2, for compatibility with older programs. <strong>为了兼容老程序，许多实现定义 O_RDONLY as 0, O_WRONLY as 1, and O_RDWR as 2</strong>。</p></blockquote><p>O_EXEC Open for execute only</p><p>O_SEARCH Open for search only(applies to directories)</p><blockquote><p>The purpose of the O_SEARCH constant is to evaluate search permissions at the time a directory is opened. Further operations using the directory’s file descriptor will not reevaluate permission to search the directory. None of the versions of the operating systems covered in this book support O_SEARCH yet.</p></blockquote><p>One and only one of the previous five constants must be specified. The following constants are optional:</p><p>上面的五个常量有且只有一个必须被明确。接下来的是可选常量：</p><p>O_APPEND Append to the end of file on each write. We describe this option in detail in Section 3.11.</p><p>O_CLOEXEC Set the FD_CLOEXEC file descriptor flag. We discuss file descriptor flags in Section 3.14.</p><p>O_CREAT Create the file if it doesn’t exist. This option requires a third argument to the open function (a fourth argument to the openat function) — the mode, which specifies the access permission bits of the new file. (When we describe a file’s access permission bits in Section 4.5, we’ll see how to specify the mode and how it can be modified by the umask value of a process.) 创建一个文件，如果不存在。这个操作需要 open 函数的第三个参数（openat 函数的第四个参数）— mode，<strong>它明确了这个新文件的访问权限位</strong>。（当我们在第 4.5 章节讨论文件的访问权限位，我们将看到如何明确 mode，以及它如何修改进程的 umask 值。）</p><p>O_DIRECTORY Generate an error if path doesn’t refer to a directory.</p><p>O_EXCL Generate an error if O_CREAT is also specified and the file already exists. This test for whether the file already exists and the creation of the file if it doesn’t exist is an atomic operation. We describe atomic operations in more detail in Section 3.11. 如果 O_CREAT 被使用了且文件已经存在就会生成一个错误。这个常量的作用是检测文件是否存在如果文件不存在就创建，这是一个原子操作。我们将在第 3.11 章节讨论更多原子操作的细节。</p><p>O_NOCTTY If path refers to a terminal device, do not allocate the device as the controlling terminal for this process. We talk about controlling terminals in Section 9.6. 如果这个路径指向的是终端设备，则不将这个设备分配为此进程的控制终端。</p><p>O_NONBLOCK If path refers to a FIFO, a block special file, or a character special file, this option sets the nonblocking mode for both the opening of the file and subsequent I/O. We describe this mode in Section 14.2. 如果 path 指向 FIFO（先进先出），一个块特殊文件，一个字符特殊文件，这个选项设置了非阻塞模式为本次的打开操作和后续的 I/O 操作。</p><blockquote><p>In earlier releases of System V, the O_NDELAY (no delay) flag was introduced. This option is similar to the O_NONBLOCK (nonblocking) option, but an ambiguity was introduced in the return value from a read operation. The no-delay option causes a read operation to return 0 if there is no data to be read from a pipe, FIFO, or device, but this conflicts with a return value of 0, indicating an end of file. SVR4-based systems still support the no-delay option, with the old semantics, but new applications should use the nonblocking option instead. 在早期的 System V，有一个 O_NDELAY(no delay)符号。这个符号和 O_NONBLOCK(nonblocking)选项相似，但他的读操作返回值具有二义性。如果管道，先进先出，或者设备没有数据可读，no-delay 选项就会造成 read 操作返回 0，这与 end of file 造成的返回值 0 冲突了。虽然基于 SVR4 的系统还支持这个 no-delay 选项，但新的应用应该使用 nonblocking 选项。</p></blockquote><p>O_SYNC Have each write wait for physical I/O to complete, including I/O necessary to update file attributes modified as a result of the write. We use this option in Section 3.14. 使每次 write 都等物理 I/O 完成，包括更新文件属性所需要的 I/O。</p><p>O_TTY_INIT When opening a terminal device that is not already open, set the nonstandard termios parameters to values that result in behavior that conforms to the Single UNIX Specification. We discuss the termios structure when we discuss terminal I/O in Chapter 18. 当打开一个新的终端设备的时候，设置非标准参数 termios。</p><p>The following two flags are also optional. They are part of the synchronized input and output option of the Single UNIX Specification (and thus POSIX.1).</p><p>O_DSYNC Have each write wait for physical I/O to complete, but don’t wait for file attributes to be updated if they don’t affect the ability to read the data just written. 让所有 write 都等待物理 I/O 完成，但是不用等文件属性更新，如果不影响刚刚写完的数据的读操作的话。</p><p>O_RSYNC Have each read operation on the file descriptor wait until any pending writes for the same portion of the file are complete. 使每个使用文件描述符的的读操作等待，直到对文件的同一部分的所有写操作完成。</p><blockquote><p>Solaris 10 supports all three synchronization flags. Historically, FreeBSD (and thus Mac OS X) have used the O_FSYNC flag, which has the same behavior as O_SYNC. Because the two flags are equivalent, they define the flags to have the same value. FreeBSD 8.0 doesn’t support the O_DSYNC or O_RSYNC flags. Mac OS X doesn’t support the O_RSYNC flag, but defines the O_DSYNC flag, treating it the same as the O_SYNC flag. Linux 3.2.0 supports the O_DSYNC flag, but treats the O_RSYNC flag the same as O_SYNC.</p></blockquote><p><strong>The file descriptor returned by open and openat is guaranteed to be the lowest- numbered unused descriptor</strong>. This fact is used by some applications to open a new file on standard input, standard output, or standard error. <strong>For example, an application might close standard output—normally, file descriptor 1—and then open another file, knowing that it will be opened on file descriptor 1</strong>. We’ll see a better way to guarantee that a file is open on a given descriptor in Section 3.12, when we explore the dup2 function.</p><p><strong>The fd parameter</strong> distinguishes the openat function from the open function. There are three possibilities:</p><ol><li><p>The path parameter specifies an absolute pathname. In this case, the fd parameter is ignored and the openat function behaves like the open function.</p></li><li><p>The path parameter specifies a relative pathname and the fd parameter is a file descriptor that specifies the starting location in the file system where the relative pathname is to be evaluated. The fd parameter is obtained by opening the directory where the relative pathname is to be evaluated.</p></li><li><p>The path parameter specifies a relative pathname and the fd parameter has the special value AT_FDCWD. In this case, the pathname is evaluated starting in the current working directory and the openat function behaves like the open function.</p></li></ol><p>The openat function is one of a class of functions added to the latest version of POSIX.1 to address two problems. First, it gives threads a way to use relative pathnames to open files in directories other than the current working directory. As we’ll see in Chapter 11, all threads in the same process share the same current working directory, so this makes it difficult for multiple threads in the same process to work in different directories at the same time. Second, it provides a way to avoid time-of-check- to-time-of-use (TOCTTOU) errors. openat 函数是在最后一个版本的 POSIX.1 加入的，为了解决两个问题。首先，它给线程以相对路径而非当前路径。我们将在第 11 章看到，在同一进程中的所有线程共享同一个当前目录，所以要让同一进程中的多线程同时在不同的目录工作是非常困难的。第二，它提供了避免 time-of-check-to-time-of-use（TOCTTOU） 错误。</p><p>The basic idea behind TOCTTOU errors is that a program is vulnerable if it makes two file-based function calls where the second call depends on the results of the first call. Because the two calls are not atomic, the file can change between the two calls, thereby invalidating the results of the first call, leading to a program error. TOCTTOU errors in the file system namespace generally deal with attempts to subvert file system permissions by tricking a privileged program into either reducing permissions on a privileged file or modifying a privileged file to open up a security hole. Wei and Pu [2005] discuss TOCTTOU weaknesses in the UNIX file system interface. TOCTTOU 错误的意思是，一个调用横叉一脚影响了另一个调用，本来另一个调用应该是一个原子操作。</p><h3 id="Filename-and-Pathname-Truncation"><a href="#Filename-and-Pathname-Truncation" class="headerlink" title="Filename and Pathname Truncation"></a>Filename and Pathname Truncation</h3><p>What happens if NAME_MAX is 14 and we try to create a new file in the current directory with a filename containing 15 characters? Traditionally, early releases of System V, such as SVR2, allowed this to happen, silently truncating the filename beyond the 14th character. BSD-derived systems, in contrast, returned an error status, with errno set to ENAMETOOLONG. Silently truncating the filename presents a problem that affects more than simply the creation of new files. If NAME_MAX is 14 and a file exists whose name is exactly 14 characters, any function that accepts a pathname argument, such as open or stat, has no way to determine what the original name of the file was, as the original name might have been truncated. 如果 NAME_MAX 是 14 怎么办？传统上，早期的 System V 系统，允许这发生，静默的将文件名截断成 14 字符。相反的，BSD 派生的系统，返回一个错误状态，并把 errno 设置成 ENAMETOOLONG。静默的截断文件名呈现的问题不仅仅是创建了一个新文件。如果 NAME_MAX 是 14 且文件存在，且它的名字就是 14 字符，任何接收一个路径名作为参数的函数，比如 open 或者 stat，没办法判断文件原来的名字是什么，因为原始文件名可能已经被截断。</p><p>With POSIX.1, the constant <code>_POSIX_NO_TRUNC</code> determines whether long filenames and long components of pathnames are truncated or an error is returned. As we saw in Chapter 2, this value can vary based on the type of the file system, and we can use fpathconf or pathconf to query a directory to see which behavior is supported. 在 POSIX.1 标准里，常量 <code>_POSIX_NO_TRUNC</code> 决定长文件名和路径名中长的组件是否被截断或者是否返回一个错误。正如我们在第二章中看到的，这个值在文件系统中是非常基本的，我们可以使用 <code>fpathconf</code> 或 <code>pathconf</code>查询一个目录看看它支持哪种行为。</p><blockquote><p>Whether an error is returned is largely historical. For example, SVR4-based systems do not generate an error for the traditional System V file system, S5. For the BSD-style file system (known as UFS), however, SVR4-based systems do generate an error. Figure 2.20 illustrates another example: Solaris will return an error for UFS, but not for PCFS, the DOS-compatible file system, as DOS silently truncates filenames that don’t fit in an 8.3 format. BSD-derived systems and Linux always return an error.</p></blockquote><p>If _POSIX_NO_TRUNC is in effect, errno is set to ENAMETOOLONG, and an error status is returned if any filename component of the pathname exceeds NAME_MAX.</p><blockquote><p>Most modern file systems support a maximum of 255 characters for filenames. Because filenames are usually shorter than this limit, this constraint tends to not present problems for most applications.</p></blockquote><h2 id="creat-Function"><a href="#creat-Function" class="headerlink" title="creat Function"></a>creat Function</h2><p>A new file can also be created by calling the creat function.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="comment">// Returns: file descriptor opened for write-only if OK, −1 on error</span></span><br></pre></td></tr></table></figure><p>Note that this function is equivalent to</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open(path, O_WRONLY | O_CREAT | O_TRUNC, mode);</span><br></pre></td></tr></table></figure><blockquote><p>Historically, in early versions of the UNIX System, the second argument to open could be only 0, 1, or 2. There was no way to open a file that didn’t already exist. Therefore, a separate system call, creat, was needed to create new files. With the O_CREAT and O_TRUNC options now provided by open, a separate creat function is no longer needed. 这个函数诞生的原因是：历史上 open 函数的第二个参数只支持 0，1，2 这三个值，也就是读，写，读写。没办法打开一个不存在的文件。而现在有了 O_CREAT and O_TRUNC options，creat 函数也就没有存在的必要了。</p></blockquote><p>We’ll show how to specify mode in Section 4.5 when we describe a file’s access permissions in detail.</p><p>One deficiency with creat is that the file is opened only for writing. Before the new version of open was provided, if we were creating a temporary file that we wanted to write and then read back, we had to call creat, close, and then open. A better way is to use the open function, as in</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open(path, O_RDWR | O_CREAT | O_TRUNC, mode);</span><br></pre></td></tr></table></figure><h2 id="close-Function"><a href="#close-Function" class="headerlink" title="close Function"></a>close Function</h2><p>An open file is closed by calling the close function.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure><p>Closing a file also releases any record locks that the process may have on the file. We’ll discuss this point further in Section 14.3. 关闭一个文件同样会释放进程对该文件的所有锁。</p><p>When a process terminates, all of its open files are closed automatically by the kernel. Many programs take advantage of this fact and don’t explicitly close open files. See the program in Figure 1.4, for example. 当一个进程终止，所有它打开的文件都会被内核自动关闭。许多程序利用了这一点，不明确关闭文件。</p><h2 id="lseek-Function"><a href="#lseek-Function" class="headerlink" title="lseek Function"></a>lseek Function</h2><p>Every open file has an associated “current file offset,” normally a non-negative integer that measures the number of bytes from the beginning of the file. (We describe some exceptions to the ‘‘non-negative’’ qualifier later in this section.) Read and write operations normally start at the current file offset and cause the offset to be incremented by the number of bytes read or written. By default, this offset is initialized to 0 when a file is opened, unless the O_APPEND option is specified. 每个打开的文件都与 &quot;current file offset&quot;关联，正常情况下它是一个非负整形数，表示从文件开始到目前位置的字节数。读和写操作都是从 current file offset 开始的，并且会让 offset 增加，随着读和写的进行。默认的，当文件被打开时，这个位移初始化时 0，除非指明了 O_APPEND 选项。</p><p>An open file’s offset can be set explicitly by calling lseek. 通过调用 lseek 函数，一个打开的文件的 offset 可以被设定。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">off_t</span> lseek(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence);</span><br><span class="line"><span class="comment">// Returns: new file offset if OK, −1 on error</span></span><br></pre></td></tr></table></figure><p>The interpretation of the offset depends on the value of the whence argument.</p><ul><li>If whence is SEEK_SET, the file’s offset is set to offset bytes from the beginning of the file.</li><li>If whence is SEEK_CUR, the file’s offset is set to its current value plus the offset. The offset can be positive or negative.</li><li>If whence is SEEK_END, the file’s offset is set to the size of the file plus the offset. The offset can be positive or negative.</li></ul><p>Because a successful call to lseek returns the new file offset, we can seek zero bytes from the current position to determine the current offset:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">off_t</span>    currpos;</span><br><span class="line">currpos = lseek(fd, <span class="number">0</span>, SEEK_CUR);</span><br></pre></td></tr></table></figure><p>This technique can also be used to determine if a file is capable of seeking. If the file descriptor refers to a pipe, FIFO, or socket, lseek sets errno to <strong>ESPIPE</strong> and returns −1.</p><blockquote><p>The three symbolic constants—SEEK_SET, SEEK_CUR, and SEEK_END—were introduced with System V. Prior to this, <strong>whence was specified as 0 (absolute), 1 (relative to the current offset), or 2 (relative to the end of file). Much software still exists with these numbers hard coded</strong>.</p><p><strong>The character l in the name lseek means ‘‘long integer.’’ Before the introduction of the off_t data type, the offset argument and the return value were long integers</strong>. lseek was introduced with Version 7 when long integers were added to C. (Similar functionality was provided in Version 6 by the functions seek and tell.)</p></blockquote><h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>The program in Figure 3.1 tests its standard input to see whether it is capable of seeking.</p><blockquote><p>Figure 3.1 Test whether standard input is capable of seeking</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lseek(STDIN_FILENO, <span class="number">0</span>, SEEK_CUR) == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"cannot seek\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"seek OK\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Normally, a file’s current offset must be a non-negative integer. It is possible, however, that certain devices could allow negative offsets. But for regular files, the offset must be non-negative. Because negative offsets are possible, we should be careful to compare the return value from lseek as being equal to or not equal to −1, rather than testing whether it is less than 0</strong>.</p><blockquote><p>The /dev/kmem device on FreeBSD for the Intel x86 processor supports negative offsets. Because the offset (off_t) is a signed data type (Figure 2.21), we lose a factor of 2 in the maximum file size. If off_t is a 32-bit integer, the maximum file size is $2^{31}$−1 bytes.</p></blockquote><p>lseek only records the current file offset within the kernel — it does not cause any I/O to take place. This offset is then used by the next read or write operation.</p><p>The file’s offset can be greater than the file’s current size, in which case the next write to the file will extend the file. This is referred to as creating a hole in a file and is allowed. Any bytes in a file that have not been written are read back as 0. 文件偏移量可以大于文件的目前大小，在这种情况下下一次写文件将扩展文件。也就是说在文件中创建一个空洞是被允许的。在文件中任何没被写入的部分都将被读作 0。</p><p>A hole in a file isn’t required to have storage backing it on disk. Depending on the file system implementation, when you write after seeking past the end of a file, new disk blocks might be allocated to store the data, but there is no need to allocate disk blocks for the data between the old end of file and the location where you start writing. 文件中的空洞并不需要存储到磁盘上。根据文件系统的实现，当你在 end of file 之后写，为了存储数据新的磁盘空间可能会分配，但没有必要分配磁盘块给 end of file 和你开始写的地方之间的这些数据。</p><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example"></a>Example</h3><p>The program shown in Figure 3.2 creates a file with a hole in it.</p><blockquote><p>Figure 3.2 Create a file with a hole in it</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span>    buf1[] = <span class="string">"abcdefghij"</span>;</span><br><span class="line"><span class="keyword">char</span>    buf2[] = <span class="string">"ABCDEFGHIJ"</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">if</span> ((fd = creat(<span class="string">"file.hole"</span>, FILE_MODE)) &lt; <span class="number">0</span>)</span><br><span class="line">        err_sys(<span class="string">"creat error"</span>);</span><br><span class="line">    <span class="keyword">if</span> (write(fd, buf1, <span class="number">10</span>) != <span class="number">10</span>)</span><br><span class="line">        err_sys(<span class="string">"buf1 write error"</span>);</span><br><span class="line">    <span class="comment">/* offset now = 10 */</span></span><br><span class="line">    <span class="keyword">if</span> (lseek(fd, <span class="number">16384</span>, SEEK_SET) == <span class="number">-1</span>)</span><br><span class="line">        err_sys(<span class="string">"lseek error"</span>);</span><br><span class="line">    <span class="comment">/* offset now = 16384 */</span></span><br><span class="line">    <span class="keyword">if</span> (write(fd, buf2, <span class="number">10</span>) != <span class="number">10</span>)</span><br><span class="line">        err_sys(<span class="string">"buf2 write error"</span>);</span><br><span class="line">    <span class="comment">/* offset now = 16394 */</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="read-Function"><a href="#read-Function" class="headerlink" title="read Function"></a>read Function</h2><p>Data is read from an open file with the read function.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">ssize_t read(int fd, void *buf, size_t nbytes);</span><br></pre></td></tr></table></figure><blockquote><p>Returns: numbers of bytes read, 0 if end of file, -1 on error</p></blockquote><p>If the read is successful, the number of bytes read is returned. If the end of file is encountered, 0 is returned.</p><p>There are several cases in which the number of bytes actually read is less than the amount requested: 有以下几种情况，read 读取的字节会比指定的字节数少</p><ul><li>When reading from a regular file, if the end of file is reached before the requested number of bytes has been read. For example, if 30 bytes remain until the end of file and we try to read 100 bytes, read returns 30. The next time we call read, it will return 0 (end of file).</li><li>When reading from a terminal device. Normally, up to one line is read at a time. (We’ll see how to change this default in Chapter 18.)</li><li>When reading from a network. Buffering within the network may cause less than the requested amount to be returned.</li><li>When reading from a pipe or FIFO. If the pipe contains fewer bytes than requested, read will return only what is available.</li><li>When reading from a record-oriented device. Some record-oriented devices, such as magnetic tape, can return up to a single record at a time.</li><li>When interrupted by a signal and a partial amount of data has already been read. We discuss this further in Section 10.5.</li></ul><p>The read operation starts at the file’s current offset. Before a successful return, the offset is incremented by the number of bytes actually read. read 操作是从文件的当前偏移量开始的。在成功返回前，偏移量会随读取的字节增加。</p><p>POSIX.1 changed the prototype for this function in several ways. The classic definition is</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int read(int fd, char *buf, unsigned nbytes);</span><br></pre></td></tr></table></figure><ul><li>First, the second argument was changed from char _ to void _ to be consistent<br>with ISO C: the type void * is used for generic pointers.</li><li>Next, the return value was required to be a signed integer (ssize_t) to return a positive byte count, 0 (for end of file), or −1 (for an error).</li><li>Finally, the third argument historically has been an unsigned integer, to allow a 16-bit implementation to read or write up to 65,534 bytes at a time. With the 1990 POSIX.1 standard, the primitive system data type ssize_t was introduced to provide the signed return value, and the unsigned size_t was used for the third argument. (Recall the SSIZE_MAX constant from Section 2.5.2.)</li></ul><h2 id="write-Function"><a href="#write-Function" class="headerlink" title="write Function"></a>write Function</h2><p>Data is written to an open file with the write function.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">ssize_t write(int fd, const void *buf, size_t nbytes);</span><br></pre></td></tr></table></figure><p>The return value is usually equal to the nbytes argument; otherwise, an error has occurred. A common cause for a write error is either filling up a disk or exceeding the file size limit for a given process (Section 7.11 and Exercise 10.11). 返回值一般会等于<code>nbytes</code>这个参数的大小，否则就是出错了。一般导致写错误的原因是磁盘满了或者超出给定进程的文件大小限制。</p><p>For a regular file, the write operation starts at the file’s current offset. If the O_APPEND option was specified when the file was opened, the file’s offset is set to the current end of file before each write operation. After a successful write, the file’s offset is incremented by the number of bytes actually written.</p><h2 id="I-O-Efficiency"><a href="#I-O-Efficiency" class="headerlink" title="I/O Efficiency"></a>I/O Efficiency</h2><p>The program in Figure 3.5 copies a file, using only the read and write functions.</p><blockquote><p>Figure 3.5 Copy standard input to standard output</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;apue.h&quot;</span><br><span class="line">#define BUFFSIZE 4096</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int     n;</span><br><span class="line">    char    buf[BUFFSIZE];</span><br><span class="line">    while ((n = read(STDIN_FILENO, buf, BUFFSIZE)) &gt; 0)</span><br><span class="line">        if (write(STDOUT_FILENO, buf, n) != n)</span><br><span class="line">            err_sys(&quot;write error&quot;);</span><br><span class="line">    if (n &lt; 0)</span><br><span class="line">        err_sys(&quot;read error&quot;);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The following caveats apply to this program.</p><ul><li>It reads from standard input and writes to standard output, assuming that these have been set up by the shell before this program is executed. Indeed, all normal UNIX system shells provide a way to open a file for reading on standard input and to create (or rewrite) a file on standard output. This prevents the program from having to open the input and output files, and allows the user to take advantage of the shell’s I/O redirection facilities.</li><li>The program doesn’t close the input file or output file. Instead, the program uses the feature of the UNIX kernel that closes all open file descriptors in a process when that process terminates.</li><li>This example works for both text files and binary files, since there is no difference between the two to the UNIX kernel.</li></ul><p>One question we haven’t answered, however, is how we chose the BUFFSIZE value. Before answering that, let’s run the program using different values for BUFFSIZE. Figure 3.6 shows the results for reading a 516,581,760-byte file, using 20 different buffer sizes.</p><p><img src="../../../../images/APUE-3rd-Figure 3.6.png" width="70%"></p><p>The file was read using the program shown in Figure 3.5, with standard output redirected to /dev/null. The file system used for this test was the Linux ext4 file system with 4,096-byte blocks. (The st_blksize value, which we describe in Section 4.12, is 4,096.) This accounts for the minimum in the system time occurring at the few timing measurements starting around a BUFFSIZE of 4,096. Increasing the buffer size beyond this limit has little positive effect.</p><p>Most file systems support some kind of read-ahead to improve performance. When sequential reads are detected, the system tries to read in more data than an application requests, assuming that the application will read it shortly. The effect of read-ahead can be seen in Figure 3.6, where the elapsed time for buffer sizes as small as 32 bytes is as good as the elapsed time for larger buffer sizes.</p><p>We’ll return to this timing example later in the text. In Section 3.14, we show the effect of synchronous writes; in Section 5.8, we compare these unbuffered I/O times with the standard I/O library.</p><blockquote><p>Beware when trying to measure the performance of programs that read and write files. The operating system will try to cache the file incore, so if you measure the performance of the program repeatedly, the successive timings will likely be better than the first. This improvement occurs because the first run causes the file to be entered into the system’s cache, and successive runs access the file from the system’s cache instead of from the disk. (The term incore means in main memory. Back in the day, a computer’s main memory was built out of ferrite core. This is where the phrase ‘‘core dump’’ comes from: the main memory image of a program stored in a file on disk for diagnosis.)</p></blockquote><blockquote><p>In the tests reported in Figure 3.6, each run with a different buffer size was made using a different copy of the file so that the current run didn’t find the data in the cache from the previous run. The files are large enough that they all don’t remain in the cache (the test system was configured with 6 GB of RAM).</p></blockquote><h2 id="File-Sharing"><a href="#File-Sharing" class="headerlink" title="File Sharing"></a>File Sharing</h2><p>The UNIX System supports the sharing of open files among different processes. Before describing the dup function, we need to describe this sharing. To do this, we’ll examine the data structures used by the kernel for all I/O.</p><blockquote><p>The following description is conceptual; it may or may not match a particular implementation. Refer to Bach [1986] for a discussion of these structures in System V. McKusick et al. [1996] describe these structures in 4.4BSD. McKusick and Neville-Neil [2005] cover FreeBSD 5.2. For a similar discussion of Solaris, see McDougall and Mauro [2007]. The Linux 2.6 kernel architecture is discussed in Bovet and Cesati [2006].</p></blockquote><p>The kernel uses three data structures to represent an open file, and the relationships among them determine the effect one process has on another with regard to file sharing.</p><ol><li><p>Every process has an entry in the process table. Within each process table entry is a table of open file descriptors, which we can think of as a vector, with one entry per descriptor. Associated with each file descriptor are</p><ol><li>The file descriptor flags (close-on-exec; refer to Figure 3.7 and Section 3.14)</li><li>A pointer to a file table entry</li></ol></li><li><p>The kernel maintains a file table for all open files. Each file table entry contains</p><ol><li>The file status flags for the file, such as read, write, append, sync, and nonblocking; more on these in Section 3.14</li><li>The current file offset</li><li>A pointer to the v-node table entry for the file</li></ol></li><li><p>Each open file (or device) has a v-node structure that <strong>contains information about the type of file</strong> and <strong>pointers to functions that operate on the file</strong>. For most files, the v-node also contains the i-node for the file. <strong>This information is read from disk when the file is opened</strong>, so that all the pertinent information about the file is readily available. For example, <strong>the i-node contains the owner of the file, the size of the file, pointers to where the actual data blocks for the file are located on disk</strong>, and so on. (We talk more about i-nodes in Section 4.14 when we describe the typical UNIX file system in more detail.)</p></li></ol><blockquote><p>Linux has no v-node. Instead, a generic i-node structure is used. Although the implementations differ, the v-node is conceptually the same as a generic i-node. Both point to an i-node structure specific to the file system.</p></blockquote><p>We’re ignoring some implementation details that don’t affect our discussion. For example, the table of open file descriptors can be stored in the user area (a separate per- process structure that can be paged out) instead of the process table. Also, these tables can be implemented in numerous ways—they need not be arrays; one alternate implementation is a linked lists of structures. Regardless of the implementation details, the general concepts remain the same.</p><p>Figure 3.7 shows a pictorial arrangement of these three tables for a single process that has two different files open: one file is open on standard input (file descriptor 0), and the other is open on standard output (file descriptor 1).</p><p><img src="https://i.loli.net/2018/05/30/5b0e51e54c6d1.png"></p><p>The arrangement of these three tables has existed since the early versions of the UNIX System [Thompson 1978]. <strong>This arrangement is critical to the way files are shared among processes</strong>. We’ll return to this figure in later chapters, when we describe additional ways that files are shared.</p><blockquote><p><strong>The v-node was invented to provide support for multiple file system types on a single computer system</strong>. This work was done independently by Peter Weinberger (Bell Laboratories) and Bill Joy (Sun Microsystems). <strong>Sun called this the Virtual File System and called the file system–independent portion of the i-node the v-node</strong> [Kleiman 1986]. The v-node propagated through various vendor implementations as support for Sun’s Network File System (NFS) was added. The first release from Berkeley to provide v-nodes was the 4.3BSD Reno release, when NFS was added.</p></blockquote><blockquote><p>In SVR4, the v-node replaced the file system–independent i-node of SVR3. Solaris is derived from SVR4 and, therefore, uses v-nodes.</p></blockquote><blockquote><p>Instead of splitting the data structures into a v-node and an i-node, Linux uses a file system–independent i-node and a file system–dependent i-node.</p></blockquote><p>If two independent processes have the same file open, we could have the arrangement shown in Figure 3.8.</p><p><img src="https://i.loli.net/2018/05/30/5b0e5b6638838.png"></p><p>We assume here that the first process has the file open on descriptor 3 and that the second process has that same file open on descriptor 4. Each process that opens the file gets its own file table entry, but only a single v-node table entry is required for a given file. One reason each process gets its own file table entry is so that each process has its own current offset for the file.</p><p>Given these data structures, we now need to be more specific about what happens with certain operations that we’ve already described.</p><ul><li>After each write is complete, the current file offset in the file table entry is incremented by the number of bytes written. If this causes the current file offset to exceed the current file size, the current file size in the i-node table entry is set to the current file offset (for example, the file is extended).</li><li>If a file is opened with the O_APPEND flag, a corresponding flag is set in the file status flags of the file table entry. Each time a write is performed for a file with this append flag set, the current file offset in the file table entry is first set to the current file size from the i-node table entry. This forces every write to be appended to the current end of file. 如果一个文件打开时使用<code>O_APPEND</code>标志，相应的标志会设置到文件表项的文件状态符。每次进行写操作时，文件表项就会首先将当前文件偏移量设置为 i 结点表项的当前文件大小。这样就可以强制每次都写到文件末尾了。</li><li>If a file is positioned to its current end of file using lseek, all that happens is the current file offset in the file table entry is set to the current file size from the i-node table entry. (Note that this is not the same as if the file was opened with the O_APPEND flag, as we will see in Section 3.11.)</li><li>The lseek function modifies only the current file offset in the file table entry. No I/O takes place.</li></ul><p>It is possible for more than one file descriptor entry to point to the same file table entry, as we’ll see when we discuss the dup function in Section 3.12. This also happens after a fork when the parent and the child share the same file table entry for each open descriptor (Section 8.3).</p><p><strong>Note the difference in scope between the file descriptor flags and the file status flags. The former apply only to a single descriptor in a single process, whereas the latter apply to all descriptors in any process that point to the given file table entry</strong>. When we describe the fcntl function in Section 3.14, we’ll see how to fetch and modify both the file descriptor flags and the file status flags.</p><p>Everything that we’ve described so far in this section works fine for multiple processes that are reading the same file. Each process has its own file table entry with its own current file offset. Unexpected results can arise, however, when multiple processes write to the same file. To see how to avoid some surprises, we need to understand the concept of atomic operations.</p><h2 id="Atomic-Operations"><a href="#Atomic-Operations" class="headerlink" title="Atomic Operations"></a>Atomic Operations</h2><h3 id="Appending-to-a-File"><a href="#Appending-to-a-File" class="headerlink" title="Appending to a File"></a>Appending to a File</h3><p>Consider a single process that wants to append to the end of a file. Older versions of the UNIX System didn’t support the O_APPEND option to open, so the program was coded as follows:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (lseek(fd, <span class="number">0L</span>, <span class="number">2</span>) &lt; <span class="number">0</span>)         <span class="comment">/* position to EOF */</span></span><br><span class="line">    err_sys(<span class="string">"lseek error"</span>);</span><br><span class="line"><span class="keyword">if</span> (write(fd, buf, <span class="number">100</span>) != <span class="number">100</span>)   <span class="comment">/* and write */</span></span><br><span class="line">    err_sys(<span class="string">"write error"</span>);</span><br></pre></td></tr></table></figure><p>This works fine for a single process, but problems arise if multiple processes use this technique to append to the same file. (This scenario can arise if multiple instances of the same program are appending messages to a log file, for example.)</p><p>Assume that two independent processes, A and B, are appending to the same file. Each has opened the file but without the O_APPEND flag. This gives us the same picture as Figure 3.8. Each process has its own file table entry, but they share a single v-node table entry. Assume that process A does the lseek and that this sets the current offset for the file for process A to byte offset 1,500 (the current end of file). Then the kernel switches processes, and B continues running. Process B then does the lseek, which sets the current offset for the file for process B to byte offset 1,500 also (the current end of file). Then B calls write, which increments B’s current file offset for the file to 1,600. Because the file’s size has been extended, the kernel also updates the current file size in the v-node to 1,600. Then the kernel switches processes and A resumes. When A calls write, the data is written starting at the current file offset for A, which is byte offset 1,500. This overwrites the data that B wrote to the file.</p><p>The problem here is that our logical operation of ‘‘position to the end of file and write’’ requires two separate function calls (as we’ve shown it). The solution is to have the positioning to the current end of file and the write be an atomic operation with regard to other processes. Any operation that requires more than one function call cannot be atomic, as there is always the possibility that the kernel might temporarily suspend the process between the two function calls (as we assumed previously).</p><p>The UNIX System provides an atomic way to do this operation if we set the O_APPEND flag when a file is opened. As we described in the previous section, this causes the kernel to position the file to its current end of file before each write. We no longer have to call lseek before each write.</p><h3 id="pread-and-pwrite-Functions"><a href="#pread-and-pwrite-Functions" class="headerlink" title="pread and pwrite Functions"></a>pread and pwrite Functions</h3><p>The Single UNIX Specification includes two functions that allow applications to seek and perform I/O atomically: pread and pwrite.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns: number of bytes read, 0 if end of file, −1 on error</span></span><br><span class="line"><span class="keyword">ssize_t</span> pread(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">off_t</span> offset);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns: number of bytes written if OK, −1 on error</span></span><br><span class="line"><span class="keyword">ssize_t</span> pwrite(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">off_t</span> offset);</span><br></pre></td></tr></table></figure><p>Calling pread is equivalent to calling lseek followed by a call to read, with the following exceptions.</p><ul><li>There is no way to interrupt the two operations that occur when we call pread.</li><li>The current file offset is not updated.</li></ul><p>Calling pwrite is equivalent to calling lseek followed by a call to write, with similar exceptions.</p><h3 id="Creating-a-File"><a href="#Creating-a-File" class="headerlink" title="Creating a File"></a>Creating a File</h3><p>We saw another example of an atomic operation when we described the O_CREAT and O_EXCL options for the open function. When both of these options are specified, the open will fail if the file already exists. We also said that the check for the existence of the file and the creation of the file was performed as an atomic operation. If we didn’t have this atomic operation, we might try</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((fd = open(path, O_WRONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (errno == ENOENT) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((fd = creat(path, mode)) &lt; <span class="number">0</span>)</span><br><span class="line">            err_sys(<span class="string">"creat error"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err_sys(<span class="string">"open error"</span>);</span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure><p>The problem occurs if the file is created by another process between the open and the creat. If the file is created by another process between these two function calls, and if that other process writes something to the file, that data is erased when this creat is executed. Combining the test for existence and the creation into a single atomic operation avoids this problem.</p><p>In general, the term atomic operation refers to an operation that might be composed of multiple steps. If the operation is performed atomically, either all the steps are performed (on success) or none are performed (on failure). It must not be possible for only a subset of the steps to be performed. We’ll return to the topic of atomic operations when we describe the link function (Section 4.15) and record locking (Section 14.3).</p><h2 id="dup-and-dup2-Functions"><a href="#dup-and-dup2-Functions" class="headerlink" title="dup and dup2 Functions"></a>dup and dup2 Functions</h2><p>An existing file descriptor is duplicated by either of the following functions:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Both return: new file descriptor if OK, −1 on error</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> fd2)</span></span>;</span><br></pre></td></tr></table></figure><p>The new file descriptor returned by dup is guaranteed to be the lowest-numbered available file descriptor. <strong>With dup2, we specify the value of the new descriptor with the fd2 argument. If fd2 is already open, it is first closed. If fd equals fd2, then dup2 returns fd2 without closing it. Otherwise, the FD_CLOEXEC file descriptor flag is cleared for fd2, so that fd2 is left open if the process calls exec</strong>.</p><p>The new file descriptor that is returned as the value of the functions shares the same file table entry as the fd argument. We show this in Figure 3.9.</p><p><img src="https://i.loli.net/2018/05/30/5b0e6c0a52034.png"></p><p>In this figure, we assume that when it’s started, the process executes</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newfd = dup(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>We assume that the next available descriptor is 3 (which it probably is, since 0, 1, and 2 are opened by the shell). Because both descriptors point to the same file table entry, they share the same file status flags—read, write, append, and so on—and the same current file offset.</p><p>Each descriptor has its own set of file descriptor flags. As we describe in Section 3.14, the close-on-exec file descriptor flag for the new descriptor is always cleared by the dup functions.</p><p>Another way to duplicate a descriptor is with the fcntl function, which we describe in Section 3.14. Indeed, the call</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dup(fd);</span><br></pre></td></tr></table></figure><p>is equivalent to</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fcntl(fd, F_DUPFD, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>Similarly, the call</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dup2(fd, fd2);</span><br></pre></td></tr></table></figure><p>is equivalent to</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">close(fd2);</span><br><span class="line">fcntl(fd, F_DUPFD, fd2);</span><br></pre></td></tr></table></figure><p>In this last case, the dup2 is not exactly the same as a close followed by an fcntl. The differences are as follows:</p><ol><li>dup2 is an atomic operation, whereas the alternate form involves two function calls. It is possible in the latter case to have a signal catcher called between the close and the fcntl that could modify the file descriptors. (We describe signals in Chapter 10.) The same problem could occur if a different thread changes the file descriptors. (We describe threads in Chapter 11.)</li><li>There are some errno differences between dup2 and fcntl.</li></ol><blockquote><p>The dup2 system call originated with Version 7 and propagated through the BSD releases. The fcntl method for duplicating file descriptors appeared with System III and continued with SystemV. SVR3.2 picked up the dup2 function, and 4.2BSD picked up the fcntl function and the F_DUPFD functionality. POSIX.1 requires both dup2 and the F_DUPFD feature of fcntl.</p></blockquote><h2 id="sync-fsync-and-fdatasync-Functions"><a href="#sync-fsync-and-fdatasync-Functions" class="headerlink" title="sync, fsync, and fdatasync Functions"></a>sync, fsync, and fdatasync Functions</h2><p>Traditional implementations of the UNIX System have a buffer cache or page cache in the kernel through which most disk I/O passes. When we write data to a file, the data is normally copied by the kernel into one of its buffers and queued for writing to disk at some later time. This is called delayed write. (Chapter 3 of Bach [1986] discusses this buffer cache in detail.)</p><p>The kernel eventually writes all the delayed-write blocks to disk, normally when it needs to reuse the buffer for some other disk block. To ensure consistency of the file system on disk with the contents of the buffer cache, the sync, fsync, and fdatasync functions are provided.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Both Returns: 0 if OK, −1 on error</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fdatasync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>The sync function simply queues all the modified block buffers for writing and returns; it does not wait for the disk writes to take place</strong>.</p><p><strong>The function sync is normally called periodically (usually every 30 seconds) from a system daemon, often called update</strong>. This guarantees regular flushing of the kernel’s block buffers. The command sync(1) also calls the sync function.</p><p>The function fsync refers only to a single file, specified by the file descriptor fd, and <strong>waits for the disk writes to complete before returning</strong>. This function is used when an application, <strong>such as a database</strong>, needs to be sure that the modified blocks have been written to the disk.</p><p><strong>The fdatasync function is similar to fsync, but it affects only the data portions of a file. With fsync, the file’s attributes are also updated synchronously</strong>.</p><blockquote><p>All four of the platforms described in this book support sync and fsync. However, FreeBSD 8.0 does not support fdatasync.</p></blockquote><h2 id="fcntl-Function"><a href="#fcntl-Function" class="headerlink" title="fcntl Function"></a>fcntl Function</h2><p>The fcntl function can change the properties of a file that is already open.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns: depends on cmd if OK (see following), −1 on error</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* int arg */</span> )</span></span>;</span><br></pre></td></tr></table></figure><p>In the examples in this section, the third argument is always an integer, corresponding to the comment in the function prototype just shown. When we describe record locking in Section 14.3, however, the third argument becomes a pointer to a structure.</p><p>The fcntl function is used for five different purposes.</p><ol><li><p>Duplicate an existing descriptor (cmd = F_DUPFD or F_DUPFD_CLOEXEC)</p></li><li><p>Get/set file descriptor flags (cmd = F_GETFD or F_SETFD)</p></li><li><p>Get/set file status flags (cmd = F_GETFL or F_SETFL)</p></li><li><p>Get/set asynchronous I/O ownership (cmd = F_GETOWN or F_SETOWN)</p></li><li><p>Get/set record locks (cmd = F_GETLK, F_SETLK, or F_SETLKW)</p></li></ol><p>We’ll now describe the first 8 of these 11 cmd values. (We’ll wait until Section 14.3 to describe the last 3, which deal with record locking.) Refer to Figure 3.7, as we’ll discuss both the file descriptor flags associated with each file descriptor in the process table entry and the file status flags associated with each file table entry.</p><p>F_DUPFD Duplicate the file descriptor fd. The new file descriptor is returned as the value of the function. It is the lowest-numbered descriptor that is not already open, and that is greater than or equal to the third argument (taken as an integer). The new descriptor shares the same file table entry as fd. (Refer to Figure 3.9.) But the new descriptor has its own set of file descriptor flags, and its FD_CLOEXEC file descriptor flag is cleared. (This means that the descriptor is left open across an exec, which we discuss in Chapter 8.)</p><p>F_DUPFD_CLOEXEC Duplicate the file descriptor and set the FD_CLOEXEC file descriptor flag associated with the new descriptor. Returns the new file descriptor.</p><p>F_GETFD Return the file descriptor flags for fd as the value of the function. Currently, only one file descriptor flag is defined: the FD_CLOEXEC flag.</p><p>F_SETFD Set the file descriptor flags for fd. The new flag value is set from the third argument (taken as an integer).</p><blockquote><p>Be aware that some existing programs that deal with the file descriptor flags don’t use the constant FD_CLOEXEC. Instead, these programs set the flag to either 0 (don’t close-on-exec, the default) or 1 (do close-on-exec).</p></blockquote><p>F_GETFL Return the file status flags for fd as the value of the function. We described the file status flags when we described the open function. They are listed in Figure 3.10.</p><p><img src="https://i.loli.net/2018/05/31/5b0f49576d719.png" width="70%"></p><p>Unfortunately, the five access-mode flags—O_RDONLY, O_WRONLY, O_RDWR, O_EXEC, and O_SEARCH—are not separate bits that can be tested. (As we mentioned earlier, the first three often have the values 0, 1, and 2, respectively, for historical reasons. Also, these five values are mutually exclusive; a file can have only one of them enabled.) Therefore, we must first use the O_ACCMODE mask to obtain the access-mode bits and then compare the result against any of the five values.</p><p>F_SETFL Set the file status flags to the value of the third argument (taken as an integer). The only flags that can be changed are O_APPEND, O_NONBLOCK, O_SYNC, O_DSYNC, O_RSYNC, O_FSYNC, and O_ASYNC.</p><p>F_GETOWN Get the process ID or process group ID currently receiving the SIGIO and SIGURG signals. We describe these asynchronous I/O signals in Section 14.5.2.</p><p>F_SETOWN Set the process ID or process group ID to receive the SIGIO and SIGURG signals. A positive arg specifies a process ID. A negative arg implies a process group ID equal to the absolute value of arg.</p><p>The return value from fcntl depends on the command. All commands return −1 on an error or some other value if OK. The following four commands have special return values: F_DUPFD, F_GETFD, F_GETFL, and F_GETOWN. The first command returns the new file descriptor, the next two return the corresponding flags, and the final command returns a positive process ID or a negative process group ID.</p><h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example"></a>Example</h3><p>The program in Figure 3.11 takes a single command-line argument that specifies a file descriptor and prints a description of selected file flags for that descriptor.</p><blockquote><p>Figure 3.11 Print file flags for specified descriptor</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"include/apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">     err_quit(<span class="string">"usage: a.out &lt;descriptor#&gt;"</span>);</span><br><span class="line">  <span class="keyword">if</span> ((val = fcntl(atoi(argv[<span class="number">1</span>]), F_GETFL, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">     err_sys(<span class="string">"fcntl error for fd %d"</span>, atoi(argv[<span class="number">1</span>]));</span><br><span class="line">  <span class="keyword">switch</span> (val &amp; O_ACCMODE) &#123;</span><br><span class="line">    <span class="keyword">case</span> O_RDONLY:</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"read only"</span>);</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> O_WRONLY:</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"write only"</span>);</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> O_RDWR:</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"read write"</span>);</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">       err_dump(<span class="string">"unknown access mode"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (val &amp; O_APPEND)</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">", append"</span>);</span><br><span class="line">  <span class="keyword">if</span> (val &amp; O_NONBLOCK)</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">", nonblocking"</span>);</span><br><span class="line">  <span class="keyword">if</span> (val &amp; O_SYNC)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">", synchronous writes"</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> !defined(_POSIX_C_SOURCE) &amp;&amp; defined(O_FSYNC) &amp;&amp; (O_FSYNC != O_SYNC)</span></span><br><span class="line">         <span class="keyword">if</span> (val &amp; O_FSYNC)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">", synchronous writes"</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note that we use the feature test macro _POSIX_C_SOURCE and conditionally compile the file access flags that are not part of POSIX.1. The following script shows the operation of the program, when invoked from bash (the Bourne-again shell). Results will vary, depending on which shell you use.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  apue.3e ./fig3.11 0 &lt; /dev/tty</span><br><span class="line">read only</span><br><span class="line">➜  apue.3e ./fig3.11 1 &gt; temp.foo</span><br><span class="line">➜  apue.3e cat temp.foo</span><br><span class="line">write only</span><br><span class="line">➜  apue.3e ./fig3.11 2 2&gt;&gt;temp.foo</span><br><span class="line">write only, append</span><br><span class="line">➜  apue.3e ./fig3.11 5 5&lt;&gt;temp.foo</span><br><span class="line">read write</span><br></pre></td></tr></table></figure><p>The clause 5&lt;&gt;temp.foo opens the file temp.foo for reading and writing on file descriptor 5.</p><h3 id="Example-3"><a href="#Example-3" class="headerlink" title="Example"></a>Example</h3><p>When we modify either the file descriptor flags or the file status flags, we must be careful to fetch the existing flag value, modify it as desired, and then set the new flag value. We can’t simply issue an F_SETFD or an F_SETFL command, as this could turn off flag bits that were previously set.</p><p>Figure 3.12 shows a function that sets one or more of the file status flags for a descriptor.</p><blockquote><p>Figure 3.12 Turn on one or more of the file status flags for a descriptor</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_fl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> flags)</span> <span class="comment">/* flags are file status flags to turn on */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">if</span> ((val = fcntl(fd, F_GETFL, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">       err_sys(<span class="string">"fcntl F_GETFL error"</span>);</span><br><span class="line">    val |= flags;       <span class="comment">/* turn on flags */</span></span><br><span class="line">    <span class="keyword">if</span> (fcntl(fd, F_SETFL, val) &lt; <span class="number">0</span>)</span><br><span class="line">       err_sys(<span class="string">"fcntl F_SETFL error"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If we change the middle statement to</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val &amp;=  ̃flags;      <span class="comment">/* turn flags off */</span></span><br></pre></td></tr></table></figure><p>we have a function named clr_fl, which we’ll use in some later examples. This statement logically ANDs the one’s complement of flags with the current val.</p><p>If we add the line</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_fl(STDOUT_FILENO, O_SYNC);</span><br></pre></td></tr></table></figure><p>to the beginning of the program shown in Figure 3.5, we’ll turn on the synchronous- write flag. This causes each write to wait for the data to be written to disk before returning. Normally in the UNIX System, a write only queues the data for writing; the actual disk write operation can take place sometime later. A database system is a likely candidate for using O_SYNC, so that it knows on return from a write that the data is actually on the disk, in case of an abnormal system failure.</p><p>We expect the O_SYNC flag to increase the system and clock times when the program runs. To test this, we can run the program in Figure 3.5, copying 492.6 MB of data from one file on disk to another and compare this with a version that does the same thing with the O_SYNC flag set. The results from a Linux system using the ext4 file system are shown in Figure 3.13.</p><p><img src="https://i.loli.net/2018/05/31/5b0f4c0dc6161.png" width="80%"></p><p>The six rows in Figure 3.13 were all measured with a BUFFSIZE of 4,096 bytes. The results in Figure 3.6 were measured while reading a disk file and writing to /dev/null, so there was no disk output. The second row in Figure 3.13 corresponds to reading a disk file and writing to another disk file. This is why the first and second rows in Figure 3.13 are different. The system time increases when we write to a disk file, because the kernel now copies the data from our process and queues the data for writing by the disk driver. We expect the clock time to increase as well when we write to a disk file.</p><p>When we enable synchronous writes, the system and clock times should increase significantly. As the third row shows, the system time for writing synchronously is not much more expensive than when we used delayed writes. This implies that the Linux operating system is doing the same amount of work for delayed and synchronous writes (which is unlikely), or else the O_SYNC flag isn’t having the desired effect. In this case, the Linux operating system isn’t allowing us to set the O_SYNC flag using fcntl, instead failing without returning an error (but it would have honored the flag if we were able to specify it when the file was opened).</p><p>The clock time in the last three rows reflects the extra time needed to wait for all of the writes to be committed to disk. After writing a file synchronously, we expect that a call to fsync will have no effect. This case is supposed to be represented by the last row in Figure 3.13, but since the O_SYNC flag isn’t having the intended effect, the last row behaves the same way as the fifth row.</p><p>Figure 3.14 shows timing results for the same tests run on Mac OS X 10.6.8, which uses the HFS file system. Note that the times match our expectations: synchronous writes are far more expensive than delayed writes, and using fsync with synchronous writes makes very little difference. Note also that adding a call to fsync at the end of the delayed writes makes little measurable difference. It is likely that the operating system flushed previously written data to disk as we were writing new data to the file, so by the time that we called fsync, very little work was left to be done.</p><p><img src="https://i.loli.net/2018/05/31/5b0f4c6873af3.png" width="80%"></p><p>Compare fsync and fdatasync, both of which update a file’s contents when we say so, with the O_SYNC flag, which updates a file’s contents every time we write to the file. The performance of each alternative will depend on many factors, including the underlying operating system implementation, the speed of the disk drive, and the type of the file system.</p><p>With this example, we see the need for fcntl. Our program operates on a descriptor (standard output), never knowing the name of the file that was opened on that descriptor. We can’t set the O_SYNC flag when the file is opened, since the shell opened the file. With fcntl, we can modify the properties of a descriptor, knowing only the descriptor for the open file. We’ll see another need for fcntl when we describe nonblocking pipes (Section 15.2), since all we have with a pipe is a descriptor.</p><h2 id="ioctl-Function"><a href="#ioctl-Function" class="headerlink" title="ioctl Function"></a>ioctl Function</h2><p>The ioctl function has always been the catchall for I/O operations. Anything that couldn’t be expressed using one of the other functions in this chapter usually ended up being specified with an ioctl. Terminal I/O was the biggest user of this function. (When we get to Chapter 18, we’ll see that POSIX.1 has replaced the terminal I/O operations with separate functions.)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;     /* System V */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;  /* BSD and Linux */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns: −1 on error, something else if OK</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ioctl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> request, ...)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>The ioctl function was included in the Single UNIX Specification only as an extension for dealing with STREAMS devices [Rago 1993], but it was moved to obsolescent status in SUSv4. UNIX System implementations use ioctl for many miscellaneous device operations. Some implementations have even extended it for use with regular files.</p></blockquote><p>The prototype that we show corresponds to POSIX.1. FreeBSD 8.0 and Mac OS X 10.6.8 declare the second argument as an unsigned long. This detail doesn’t matter, since the second argument is always a #defined name from a header.</p><p>For the ISO C prototype, an ellipsis is used for the remaining arguments. Normally, however, there is only one more argument, and it’s usually a pointer to a variable or a structure.</p><p>In this prototype, we show only the headers required for the function itself. Normally, additional device-specific headers are required. For example, the ioctl commands for terminal I/O, beyond the basic operations specified by POSIX.1, all require the &lt;termios.h&gt; header.</p><p>Each device driver can define its own set of ioctl commands. The system, however, provides generic ioctl commands for different classes of devices. Examples of some of the categories for these generic ioctl commands supported in FreeBSD are summarized in Figure 3.15.</p><p><img src="https://i.loli.net/2018/05/31/5b0f4cf6d20f6.png" width="60%"></p><p>The mag tape operations allow us to write end-of-file marks on a tape, rewind a tape, space forward over a specified number of files or records, and the like. None of these operations is easily expressed in terms of the other functions in the chapter (read, write, lseek, and so on), so the easiest way to handle these devices has always been to access their operations using ioctl.</p><p>We use the ioctl function in Section 18.12 to fetch and set the size of a terminal’s window, and in Section 19.7 when we access the advanced features of pseudo terminals.</p><h2 id="dev-fd"><a href="#dev-fd" class="headerlink" title="/dev/fd"></a>/dev/fd</h2><p>Newer systems provide a directory named /dev/fd whose entries are files named 0, 1, 2, and so on. Opening the file /dev/fd/n is equivalent to duplicating descriptor n, assuming that descriptor n is open.</p><blockquote><p>The /dev/fd feature was developed by Tom Duff and appeared in the 8th Edition of the Research UNIX System. It is supported by all of the systems described in this book: FreeBSD 8.0, Linux 3.2.0, Mac OS X 10.6.8, and Solaris 10. It is not part of POSIX.1.</p></blockquote><p>In the function call</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd = open(<span class="string">"/dev/fd/0"</span>, mode);</span><br></pre></td></tr></table></figure><p>most systems ignore the specified mode, whereas others require that it be a subset of the mode used when the referenced file (standard input, in this case) was originally opened. Because the previous open is equivalent to</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd = dup(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>the descriptors 0 and fd share the same file table entry (Figure 3.9). For example, if descriptor 0 was opened read-only, we can only read on fd. Even if the system ignores the open mode and the call</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd = open(<span class="string">"/dev/fd/0"</span>, O_RDWR);</span><br></pre></td></tr></table></figure><p>succeeds, we still can’t write to fd.</p><blockquote><p>The Linux implementation of /dev/fd is an exception. It maps file descriptors into symbolic links pointing to the underlying physical files. When you open /dev/fd/0, for example, you are really opening the file associated with your standard input. Thus the mode of the new file descriptor returned is unrelated to the mode of the /dev/fd file descriptor.</p></blockquote><p>We can also call creat with a /dev/fd pathname argument as well as specify O_CREAT in a call to open. This allows a program that calls creat to still work if the pathname argument is /dev/fd/1, for example.</p><blockquote><p>Beware of doing this on Linux. Because the Linux implementation uses symbolic links to the real files, using creat on a /dev/fd file will result in the underlying file being truncated.</p></blockquote><p>Some systems provide the pathnames /dev/stdin, /dev/stdout, and /dev/stderr. These pathnames are equivalent to /dev/fd/0, /dev/fd/1, and /dev/fd/2, respectively.</p><p>The main use of the /dev/fd files is from the shell. It allows programs that use pathname arguments to handle standard input and standard output in the same manner as other pathnames. For example, the cat(1) program specifically looks for an input filename of - and uses it to mean standard input. The command</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter file2 | cat file1 - file3 | lpr</span><br></pre></td></tr></table></figure><p>is an example. First, cat reads file1, then its standard input (the output of the filter program on file2), and then file3. If /dev/fd is supported, the special handling of - can be removed from cat, and we can enter</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter file2 | cat file1 /dev/fd/0 file3 | lpr</span><br></pre></td></tr></table></figure><p>The special meaning of - as a command-line argument to refer to the standard input or the standard output is a kludge that has crept into many programs. There are also problems if we specify - as the first file, as it looks like the start of another command-line option. Using /dev/fd is a step toward uniformity and cleanliness.</p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>This chapter has described the basic I/O functions provided by the UNIX System. These are often called the unbuffered I/O functions because each read or write invokes a system call into the kernel. Using only read and write, we looked at the effect of various I/O sizes on the amount of time required to read a file. We also looked at several ways to flush written data to disk and their effect on application performance.</p><p>Atomic operations were introduced when multiple processes append to the same file and when multiple processes create the same file. We also looked at the data structures used by the kernel to share information about open files. We’ll return to these data structures later in the text.</p><p>We also described the ioctl and fcntl functions. We return to both of these functions later in the book. In Chapter 14, we’ll use fcntl for record locking. In Chapter 18 and Chapter 19, we’ll use ioctl when we deal with terminal devices.</p><h2 id="Exercises"><a href="#Exercises" class="headerlink" title="Exercises"></a>Exercises</h2><ol><li><p>When reading or writing a disk file, are the functions described in this chapter really unbuffered? Explain.</p></li><li><p>Write your own dup2 function that behaves the same way as the dup2 function described in Section 3.12, without calling the fcntl function. Be sure to handle errors correctly.</p></li><li><p>Assume that a process executes the following three function calls:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fd1 = open(path, oflags);</span><br><span class="line">fd2 = dup(fd1);</span><br><span class="line">fd3 = open(path, oflags);</span><br></pre></td></tr></table></figure><p>Draw the resulting picture, similar to Figure 3.9. Which descriptors are affected by an fcntl on fd1 with a command of F_SETFD? Which descriptors are affected by an fcntl on fd1 with a command of F_SETFL?</p></li><li><p>The following sequence of code has been observed in various programs:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dup2(fd, <span class="number">0</span>);</span><br><span class="line">dup2(fd, <span class="number">1</span>);</span><br><span class="line">dup2(fd, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (fd &gt; <span class="number">2</span>)</span><br></pre></td></tr></table></figure></li></ol><p>close(fd);</p><p>To see why the if test is needed, assume that fd is 1 and draw a picture of what happens to the three descriptor entries and the corresponding file table entry with each call to dup2. Then assume that fd is 3 and draw the same picture.</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《APUE-3rd》 读书笔记 -- Unix System Overview</title>
      <link href="/blog/2018/05/22/Unix-System-Overview/"/>
      <url>/blog/2018/05/22/Unix-System-Overview/</url>
      
        <content type="html"><![CDATA[<h2 id="Preperation-Before-Class"><a href="#Preperation-Before-Class" class="headerlink" title="Preperation Before Class"></a>Preperation Before Class</h2><h3 id="apue-编程环境搭建"><a href="#apue-编程环境搭建" class="headerlink" title="apue 编程环境搭建"></a>apue 编程环境搭建</h3><blockquote><p>Figure 1.3 List all the files in a directory</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DIR *dp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dirp</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">        err_quit(<span class="string">"usage: ls directory_name"</span>);</span><br><span class="line">    <span class="keyword">if</span> ((dp = opendir(argv[<span class="number">1</span>])) == <span class="literal">NULL</span>)</span><br><span class="line">        err_sys(<span class="string">"can’t open %s"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span> ((dirp = readdir(dp)) != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, dirp-&gt;d_name);</span><br><span class="line">    closedir(dp);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里简单说一下 apue 的编程环境搭建，实际上只需要用到一点点<strong>make</strong>、<strong>环境变量</strong>和<strong>gcc 命令</strong>的知识。</p><a id="more"></a><p>首先进入：<a href="http://www.apuebook.com/" target="_blank" rel="noopener">http://www.apuebook.com/</a></p><p>选择 2013 年出版的 apue3，然后点击 source code，然后根据提示点击 here 下载。</p><p>拿到编程环境的源码之后，解压进入目录，使用 make 命令编译得到 libapue.a，这是个静态库，生成在 lib 目录下。然后将 include 目录下的 apue.h 这个头文件和 libapue.a 这个静态库分别放置在<code>/usr/include/</code>和<code>/usr/local/lib/</code>下面（这两个路径就是写入环境变量的路径，gcc 命令会在编译的时候搜寻这两个路径）。</p><p>然后使用<code>gcc -o main.o main.c -lapue</code>编译得到 main.o，因为上一步我们将 apue.h 和 libapue.a 放入了环境变量路径下面，所以我们使用它们的时候都不用再指明其路径了。</p><p>然后运行 main.o：<code>./main.o .</code>，将当前目录下的所有文件名打印出来。</p><blockquote><p>如果编译失败，使用 make clean 可以清空编译结果，然后就可以使用 make 重新编译了。不要将程序命名为.cpp 文件，这样的话即便你使用 gcc 编译 myls.cpp，也会出错，更不要使用 g++去编译 myls.cpp，因为库是用 gcc 编译的。</p></blockquote><p>When the program is done, it calls the function exit with an argument of 0. The function exit terminates a program. By convention, an argument of <strong>0 means OK</strong>, and an argument <strong>between 1 and 255 means that an error occurred</strong>.</p><h3 id="man-命令"><a href="#man-命令" class="headerlink" title="man 命令"></a>man 命令</h3><p>man 命令是 unix 系统中的一个非常重要的命令，它提供了所有命令的详细的使用方法。</p><p>Historically, UNIX systems lumped all <strong>eight sections</strong> together into what was called the UNIX Programmer&#39;s Manual. As the page count increased, the trend changed to distributing the sections among separate manuals: <strong>one for users</strong>, <strong>one for programmers</strong>, and <strong>one for system administrators</strong>, for example. Some UNIX systems further divide the manual pages within a given section, using an uppercase letter. For example, all the standard input/output (I/O) functions in AT&amp;T [1990e] are indicated as being in Section 3S, as in fopen(3S). Other systems have replaced the numeric sections with alphabetic ones, such as C for commands.</p><h2 id="Unix-Architecture"><a href="#Unix-Architecture" class="headerlink" title="Unix Architecture"></a>Unix Architecture</h2><p>下图清晰的描述了 Unix 的架构：</p><p><img src="https://i.loli.net/2018/05/22/5b03742b0a818.png" width="50%"></p><p>图中最重要的两个概念是：<strong>内核</strong>和<strong>系统调用</strong>，下面是对这两个概念的简单介绍：</p><ol><li><strong>kernel</strong>: In a strict sense, an operating system can be defined as the software that <strong>controls the hardware resources of the computer</strong> and <strong>provides an environment under which programs can run</strong>.</li><li><strong>system calls</strong>: <strong>The interface to the kernel</strong> is a layer of <strong>software</strong> called the system calls .</li></ol><h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><p>A shell is a <strong>command-line interpreter</strong> that <strong>reads user input and executes commands</strong>. The user input to a shell is normally from the terminal (an interactive shell) or sometimes from a file (called a shell script).</p><p>The system knows which shell to execute for us based on the final field in our entry in the password file.</p><p><strong>bash</strong>: The Bourne-again shell is the GNU shell provided with all Linux systems. It was designed to be POSIX conformant, while still remaining compatible with the Bourne shell. It supports features from both the C shell and the Korn shell.</p><h2 id="Files-and-Directories"><a href="#Files-and-Directories" class="headerlink" title="Files and Directories"></a>Files and Directories</h2><p>文件系统是 Unix 系统中一个非常重要的部分，里面有许多很重要的设计。文件系统从逻辑层面上看是一个<strong>树状</strong>结构，所有文件和目录都从属于一个根目录。</p><ol><li><strong>root</strong>: <strong>Everything starts in the directory</strong> called root, whose name is the single character <code>/</code>.</li><li><strong>directory</strong>: A directory is a <strong>file</strong> that contains <strong>directory entries</strong>. <strong>Logically</strong>, we can think of each directory entry as <strong>containing a filename along with a structure of information describing the attributes of the file</strong>. The attributes of a file are such things as <strong>the type of file</strong> (regular file, directory), <strong>the size of the file</strong>, <strong>the owner of the file</strong>, <strong>permissions for the file</strong> (whether other users may access this file), and <strong>when the file was last modified</strong>.</li></ol><blockquote><p>We make a distinction between the logical view of a directory entry and the way it is actually stored on disk. Most implementations of UNIX file systems <strong>don&#39;t</strong> store attributes in the directory entries themselves, <strong>because of the difficulty of keeping them in synch when a file has multiple hard links</strong>.</p></blockquote><p>文件名和路径名这里面也有讲究：</p><ol><li><strong>文件名中不能包含斜杠和空字符</strong>: The only two characters that cannot appear in a filename are the <strong>slash character (/)</strong> and the <strong>null character</strong>. The slash separates the filenames that form a pathname (described next) and the null character terminates a pathname.</li><li><strong>dot 和 dot-dot</strong>: <strong>Two filenames are automatically created whenever a new directory is created: . (called dot) and .. (called dot-dot)</strong>. Dot refers to the current directory, and dot-dot refers to the parent directory. In the root directory, dot-dot is the same as dot.</li><li><strong>相对路径和绝对路径</strong>: A sequence of one or more filenames, separated by slashes and optionally starting with a slash, forms a pathname. A pathname that begins with a slash is called an <strong>absolute pathname</strong>; otherwise, it&#39;s called a <strong>relative pathname</strong>. Relative pathnames refer to files relative to the current directory.</li></ol><blockquote><p>我们不知道形如：<code>/usr/local/lib/hello</code>的路径中 hello 是目录还是普通文件，哈哈，我觉得 unix 当初在设计上应该强制目录必须以斜杠结尾。</p></blockquote><p>还有两个比较特殊的目录：</p><ol><li><strong>working directory</strong>: <strong>Every process</strong> has a working directory, sometimes called the current working directory. This is the directory from which all <strong>relative pathnames are interpreted</strong>. A process can change its working directory with the <strong>chdir</strong> function.</li><li><strong>home directory</strong>: When we log in, the working directory is set to our home directory. Our home directory is obtained from our entry in the <strong>password file</strong>.</li></ol><h2 id="File-Descriptors"><a href="#File-Descriptors" class="headerlink" title="File Descriptors"></a>File Descriptors</h2><p><strong>file descriptor</strong>: File descriptors are normally <strong>small non-negative integers</strong> that the kernel uses to <strong>identify the files accessed by a process</strong>. Whenever it opens an existing file or creates a new file, the kernel returns a file descriptor that we use when we want to read or write the file.</p><p><strong>Standard Input, Standard Output, and Standard Error</strong>: By convention, all shells open three descriptors whenever a new program is run: standard input, standard output, and standard error. If nothing special is done, as in the simple command</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure><p>then <strong>all three are connected to the terminal</strong>. Most shells provide a way to <strong>redirect</strong> any or all of these three descriptors to any file. For example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls &gt; file.list</span><br></pre></td></tr></table></figure><p>executes the ls command with its standard output redirected to the file named <code>file.list</code>.</p><blockquote><p>stdin 的文件描述符是 0，stdout 的文件描述符是 1，stderr 的文件描述符是 2。all three are connected to the terminal，此 terminal 非彼 terminal，这里指的是硬件终端，stdin 的默认输入对象是 keyboard，stdout 和 stderr 的默认输出对象是 screen。</p></blockquote><h3 id="Redirection"><a href="#Redirection" class="headerlink" title="Redirection"></a>Redirection</h3><p>To redirect a file descriptor, we use N&gt;, where N is a file descriptor. <strong>If there&#39;s no file descriptor, then stdout is used</strong>, like in <code>echo hello &gt; new-file</code>.</p><p>将 stderr 重定向到文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command1 2&gt; error.log</span><br></pre></td></tr></table></figure><p>将 stderr 重定向到 stdout：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command-name 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>将 stdout 和 stderr 都重定向到文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command-name &amp;&gt;file</span><br></pre></td></tr></table></figure><p>或者这么写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command &gt; file-name 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>不能调换顺序：<code>command 2&gt;&amp;1 &gt; file-name</code>，这样写就错了。</p><p>The wrong version points stderr at stdout (which outputs to the shell), then redirects stdout to the file. Thus only stdout is pointing at the file, <strong>because stderr is pointing to the “old” stdout</strong>.</p><blockquote><p>Figure 1.4 Copy standard input to standard output</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFSIZE 4096</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFFSIZE];</span><br><span class="line">    <span class="keyword">while</span> ((n = read(STDIN_FILENO, buf, BUFFSIZE)) &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> (write(STDOUT_FILENO, buf, n) != n)</span><br><span class="line">            err_sys(<span class="string">"write error"</span>);</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        err_sys(<span class="string">"read error"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The <code>&lt;unistd.h&gt;</code> header, included by <code>apue.h</code>, and the two constants <code>STDIN_FILENO</code> and <code>STDOUT_FILENO</code> are part of the POSIX standard (about which we’ll have a lot more to say in the next chapter). This header contains function prototypes for many of the UNIX system services, such as the <code>read</code> and <code>write</code> functions that we call.</p><p>The constants <code>STDIN_FILENO</code> and <code>STDOUT_FILENO</code> are defined in <code>&lt;unistd.h&gt;</code> and specify the file descriptors for standard input and standard output.</p><p>The read function returns the number of bytes that are read, and this value is used as the number of bytes to write. When the end of the input file is encountered, read returns 0 and the program stops. If a read error occurs, read returns −1. Most of the system functions return −1 when an error occurs.</p><p>If we compile the program into the standard name (a.out) and execute it as</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./a.out &gt; data</span><br></pre></td></tr></table></figure><p>standard input is the terminal, standard output is redirected to the file data, and standard error is also the terminal. <strong>If this output file doesn’t exist, the shell creates it by default</strong>. The program copies lines that we type to the standard output <strong>until we type the end-of-file character (usually Control-D)</strong>.</p><blockquote><p>The notation ˆD is used to indicate a <strong>control character</strong>. Control characters are special characters formed by holding down the control key—often labeled Control or Ctrl—on your keyboard and then pressing another key at the same time. <strong>Control-D, or ˆD, is the default end-of-file character</strong>.</p></blockquote><p>If we run</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./a.out &lt; infile &gt; outfile</span><br></pre></td></tr></table></figure><p>then the file named infile will be copied to the file named outfile.</p><p>The standard I/O functions provide a buffered interface to the unbuffered I/O functions. <strong>Using standard I/O relieves us from having to choose optimal buffer sizes</strong>, such as the BUFFSIZE constant in Figure 1.4. The standard I/O functions also simplify dealing with lines of input (a common occurrence in UNIX applications). <strong>The <code>fgets</code> function, for example, reads an entire line. The read function, in contrast, reads a specified number of bytes</strong>.</p><p>The most common standard I/O function is <code>printf</code>. In programs that call <code>printf</code>, we’ll always include <code>&lt;stdio.h&gt;</code> as this header contains the function prototypes for all the standard I/O functions.</p><blockquote><p>Figure 1.5 Copy standard input to standard output, using standard I/O</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">while</span> ((c = getc(<span class="built_in">stdin</span>)) != EOF)</span><br><span class="line">        <span class="keyword">if</span> (putc(c, <span class="built_in">stdout</span>) == EOF)</span><br><span class="line">            err_sys(<span class="string">"output error"</span>);</span><br><span class="line">    <span class="keyword">if</span> (ferror(<span class="built_in">stdin</span>))</span><br><span class="line">        err_sys(<span class="string">"input error"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>The function getc reads one character at a time, and this character is written by putc</strong>. After the last byte of input has been read, getc returns the constant EOF (defined in <code>&lt;stdio.h&gt;</code>). The standard I/O constants stdin and stdout are also defined in the <code>&lt;stdio.h&gt;</code> header and refer to the standard input and standard output.</p><h2 id="Programs-and-Processes"><a href="#Programs-and-Processes" class="headerlink" title="Programs and Processes"></a>Programs and Processes</h2><p><strong>program</strong>: A program is <strong>an executable file</strong> residing on disk in a directory. A program is read into memory and is executed by the kernel as a result of one of the seven exec functions.<br><strong>process</strong>: <strong>An executing instance of a program</strong> is called a process, a term used on almost every page of this text. Some operating systems use the term <strong>task</strong> to refer to a program that is being executed.</p><p>The UNIX System guarantees that every process has a unique numeric identifier called the process ID. The process ID is always a <strong>non-negative integer</strong>.</p><blockquote><p>Figure 1.6 Print the process ID</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world from process ID %ld\n"</span>, (<span class="keyword">long</span>)getpid());</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  apue.3e ./fig1.6</span><br><span class="line">hello world from process ID 8080</span><br><span class="line">➜  apue.3e ./fig1.6</span><br><span class="line">hello world from process ID 8086</span><br></pre></td></tr></table></figure><h3 id="Process-Control"><a href="#Process-Control" class="headerlink" title="Process Control"></a>Process Control</h3><p>There are three primary functions for process control: <code>fork</code>, <code>exec</code>, and <code>waitpid</code>. (The exec function has seven variants, but we often refer to them collectively as simply the exec function.)</p><blockquote><p>Figure 1.7 Read commands from standard input and execute them</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>    buf[MAXLINE];   <span class="comment">/* from apue.h */</span></span><br><span class="line">    <span class="keyword">pid_t</span>   pid;</span><br><span class="line">    <span class="keyword">int</span>     status;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%% "</span>);  <span class="comment">/* print prompt (printf requires %% to print %) */</span></span><br><span class="line">    <span class="keyword">while</span> (fgets(buf, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] == <span class="string">'\n'</span>)</span><br><span class="line">            buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="number">0</span>; <span class="comment">/* replace newline with null */</span></span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            err_sys(<span class="string">"fork error"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;      <span class="comment">/* child */</span></span><br><span class="line">            execlp(buf, buf, (<span class="keyword">char</span> *)<span class="number">0</span>);</span><br><span class="line">            <span class="comment">// or</span></span><br><span class="line">            <span class="comment">// execlp(buf, buf, (char *)NULL);</span></span><br><span class="line">            err_ret(<span class="string">"couldn’t execute: %s"</span>, buf);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">127</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* parent */</span></span><br><span class="line">        <span class="keyword">if</span> ((pid = waitpid(pid, &amp;status, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">            err_sys(<span class="string">"waitpid error"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%% "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>There are several features to consider in this 30-line program.</p><ul><li>We use the standard I/O function fgets <strong>to read one line at a time from the standard input</strong>. When we type the end-of-file character (which is often Control-D) as the first character of a line, fgets returns a null pointer, the loop stops, and the process terminates.</li><li>Because each line returned by fgets is terminated with a newline character, followed by a null byte, we use the standard C function strlen to calculate the length of the string, and then replace the newline with a null byte. We do this <strong>because the execlp function wants a null-terminated argument, not a newline-terminated argument</strong>.</li><li>We call <code>fork</code> to create a new process, which is a copy of the caller. We say that the caller is the parent and that the newly created process is the child. Then <strong><code>fork</code> returns the non-negative process ID of the new child process to the parent, and returns 0 to the child</strong>. Because fork creates a new process, we say that it is <strong>called once—by the parent—but returns twice—in the parent and in the child</strong>.</li><li>In the child, we call execlp to execute the command that was read from the standard input. This replaces the child process with the new program file. The combination of fork followed by exec is called <strong>spawning a new process</strong> on some operating systems. <strong>In the UNIX System, the two parts are separated into individual functions</strong></li><li>Because the child calls execlp to execute the new program file, the parent wants to wait for the child to terminate. This is done by calling <code>waitpid</code>, specifying which process to wait for: the pid argument, which is the process ID of the child. The waitpid function also returns the termination status of the child—<strong>the status variable</strong>—but in this simple program, we don’t do anything with this value. We could examine it to determine how the child terminated.</li><li>The most fundamental limitation of this program is that we can&#39;t pass arguments to the command we execute. We can&#39;t, for example, specify the name of a directory to list. We can execute ls only on the working directory. <strong>To allow arguments would require that we parse the input line, separating the arguments by some convention, probably spaces or tabs, and then pass each argument as a separate parameter to the execlp function</strong>. Nevertheless, this program is still a useful demonstration of the UNIX System&#39;s process control functions.</li></ul><p>If we run this program, we get the following result. Note that our program has a different prompt—the percent sign—to distinguish it from the shell&#39;s prompt.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ ./fig1.7</span><br><span class="line">% pwd</span><br><span class="line">/Users/liuqinh2s/Downloads/apue.3e</span><br><span class="line">% who</span><br><span class="line">liuqinh2s console  May 21 12:09</span><br><span class="line">liuqinh2s ttys000  May 21 12:10</span><br><span class="line">% date</span><br><span class="line">2018年 5月24日 星期四 15时26分59秒 CST</span><br></pre></td></tr></table></figure><h3 id="Threads"><a href="#Threads" class="headerlink" title="Threads"></a>Threads</h3><p>All threads within a process share the same address space, file descriptors, stacks, and process-related attributes. Each thread executes on its own stack, although any thread can access the stacks of other threads in the same process. Because they can access the same memory, the threads need to synchronize access to shared data among themselves to avoid inconsistencies.</p><p>Like processes, threads are identified by IDs. <strong>Thread IDs, however, are local to a process</strong>. A thread ID from one process has no meaning in another process. We use thread IDs to refer to specific threads as we manipulate the threads within a process.</p><blockquote><p>threads were added to the UNIX System long after the process model was established</p></blockquote><h2 id="Error-Handling"><a href="#Error-Handling" class="headerlink" title="Error Handling"></a>Error Handling</h2><p>When an error occurs in one of the UNIX System functions, a negative value is often returned, and the integer <strong>errno</strong> is usually set to a value that tells why. For example, the open function returns either a non-negative file descriptor if all is OK or −1 if an error occurs. An error from open has about 15 possible errno values, such as file doesn’t exist, permission problem, and so on. Some functions use a convention other than returning a negative value. For example, most functions that return a pointer to an object return a null pointer to indicate an error.</p><p>The file <code>&lt;errno.h&gt;</code> defines the symbol errno and constants for each value that errno can assume. <strong>Each of these constants begins with the character E</strong>. Also, the first page of Section 2 of the UNIX system manuals, named intro(2), usually lists all these error constants. For example, if errno is equal to the constant <code>EACCES</code>, this indicates a permission problem, such as insufficient permission to open the requested file.</p><blockquote><p>On Linux, the error constants are listed in the errno(3) manual page.</p></blockquote><p>POSIX and ISO C define errno as a symbol expanding into a modifiable lvalue of type integer. This can be either an integer that contains the error number or a function that returns a pointer to the error number. The historical definition is</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> errno;</span><br></pre></td></tr></table></figure><p>But in an environment that supports threads, the process address space is shared among multiple threads, and each thread needs its own local copy of errno to prevent one thread from interfering with another. Linux, for example, supports multithreaded access to errno by defining it as</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> *__errno_location(<span class="keyword">void</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> errno (*__errno_location())</span></span><br></pre></td></tr></table></figure><p>There are two rules to be aware of with respect to errno. First, <strong>its value is never cleared by a routine if an error does not occur. Therefore, we should examine its value only when the return value from a function indicates that an error occurred.</strong> Second, the value of errno is <strong>never set to 0</strong> by any of the functions, and none of the constants defined in <code>&lt;errno.h&gt;</code> has a value of 0.</p><p>Two functions are defined by the C standard to help with printing error messages.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strerror</span><span class="params">(<span class="keyword">int</span> errnum)</span></span>; <span class="comment">//Returns: pointer to message string</span></span><br></pre></td></tr></table></figure><p>This function maps errnum, which is typically the errno value, into an error message string and returns a pointer to the string.</p><p>The perror function produces an error message on the standard error, based on the current value of errno, and returns.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perror</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span></span>;</span><br></pre></td></tr></table></figure><p>It outputs the string pointed to by msg, followed by a colon and a space, followed by the error message corresponding to the value of errno, followed by a newline.</p><blockquote><p>Figure 1.8 Demonstrate strerror and perror</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"EACCES: %s\n"</span>, strerror(EACCES));</span><br><span class="line">    errno = ENOENT;</span><br><span class="line">    perror(argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./fig1.8</span><br><span class="line">EACCES: Permission denied</span><br><span class="line">./fig1.8: No such file or directory</span><br></pre></td></tr></table></figure><blockquote><p>argv[0] 表示输入的第一个参数，也就是命令名</p></blockquote><h3 id="Error-Recovery"><a href="#Error-Recovery" class="headerlink" title="Error Recovery"></a>Error Recovery</h3><p>The errors defined in <code>&lt;errno.h&gt;</code> can be divided into two categories: <strong>fatal and nonfatal</strong>. A fatal error has no recovery action. The best we can do is print an error message on the user&#39;s screen or to a log file, and then exit. Nonfatal errors, on the other hand, can sometimes be dealt with more robustly. Most nonfatal errors are <strong>temporary</strong>, such as a resource shortage, and might not occur when there is less activity on the system.</p><p>Resource-related nonfatal errors include <strong>EAGAIN, ENFILE, ENOBUFS, ENOLCK, ENOSPC, EWOULDBLOCK</strong>, and sometimes <strong>ENOMEM</strong>. <strong>EBUSY</strong> can be treated as nonfatal when it indicates that a shared resource is in use. Sometimes, <strong>EINTR</strong> can be treated as a nonfatal error when it interrupts a slow system call.</p><p><strong>The typical recovery action for a resource-related nonfatal error is to delay and retry later</strong>. This technique can be applied in other circumstances. For example, if an error indicates that a network connection is no longer functioning, it might be possible for the application to delay a short time and then reestablish the connection. Some applications use an exponential backoff algorithm, waiting a longer period of time in each subsequent iteration.</p><h2 id="User-Identification"><a href="#User-Identification" class="headerlink" title="User Identification"></a>User Identification</h2><h3 id="Password-File"><a href="#Password-File" class="headerlink" title="Password File"></a>Password File</h3><p><strong>/etc/passwd</strong>: When we log in to a UNIX system, we enter our login name, followed by our password. The system then looks up our login name in its password file, usually the file /etc/passwd. If we look at our entry in the password file, we see that it&#39;s composed of seven colon-separated fields: the login name, encrypted password, numeric user ID (205), numeric group ID (105), a comment field, home directory (/home/sar), and shell program (/bin/ksh).</p><p>密码文件的条目的格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">登录名:加密过的密码:user ID:group ID:注解:home目录:shell</span><br></pre></td></tr></table></figure><p>All contemporary systems have moved the encrypted password to a different file.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sar:x:205:105:Stephen Rago:/home/sar:/bin/ksh</span><br></pre></td></tr></table></figure><p>我们可以看到这个文件很关键，因为他配置了我们的很多信息，比如 home 目录，默认的 shell。</p><h3 id="User-ID"><a href="#User-ID" class="headerlink" title="User ID"></a>User ID</h3><p>The user ID from our entry in the password file is a numeric value that identifies us to the system. This user ID is assigned by the system administrator when our login name is assigned, and we cannot change it. The user ID is normally assigned to be unique for every user. We&#39;ll see how the kernel uses the user ID to check whether we have the appropriate permissions to perform certain operations.</p><p>We call <strong>the user whose user ID is 0</strong> either root or the superuser. The entry in the password file normally has a login name of root, and we refer to the special privileges of this user as superuser privileges. As we&#39;ll see in Chapter 4, if a process has superuser privileges, <strong>most file permission checks are bypassed</strong>. Some operating system functions are restricted to the superuser. The superuser has free rein over the system.</p><blockquote><p>Client versions of Mac OS X ship with the superuser account disabled; server versions ship with the account already enabled. Instructions are available on Apple’s Web site describing how to enable it. See <a href="http://support.apple.com/kb/HT1528" target="_blank" rel="noopener">http://support.apple.com/kb/HT1528</a>.</p></blockquote><h3 id="Group-ID"><a href="#Group-ID" class="headerlink" title="Group ID"></a>Group ID</h3><p>Our entry in the password file also specifies our numeric group ID. This, too, is assigned by the system administrator when our login name is assigned. Typically, the password file contains multiple entries that specify the same group ID. Groups are normally used to collect users together into projects or departments. This allows the sharing of resources, such as files, among members of the same group. We’ll see in Section 4.5 that we can set the permissions on a file so that all members of a group can access the file, whereas others outside the group cannot.</p><p>There is also a group file that maps group names into numeric group IDs. The group file is usually /etc/group.</p><p>为何使用数字型 ID，主要原因如下：</p><p>The use of numeric user IDs and numeric group IDs for permissions is historical. With every file on disk, the file system stores both the user ID and the group ID of a file’s owner. Storing both of these values requires only four bytes, assuming that each is stored as a two-byte integer. If the full ASCII login name and group name were used instead, <strong>additional disk space would be required</strong>. In addition, <strong>comparing strings during permission checks is more expensive than comparing integers</strong>.</p><p>Users, however, work better with names than with numbers, so the <strong>password file</strong> maintains the mapping between login names and user IDs, and the <strong>group file</strong> provides the mapping between group names and group IDs. The ls -l command, for example, prints the login name of the owner of a file, using the password file to map the numeric user ID into the corresponding login name.</p><blockquote><p>Early UNIX systems used 16-bit integers to represent user and group IDs. Contemporary UNIX systems use 32-bit integers.</p></blockquote><blockquote><p>Figure 1.9 Print user ID and group ID</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"uid = %d, gid = %d\n"</span>, getuid(), getgid());</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Supplementary-Group-IDs"><a href="#Supplementary-Group-IDs" class="headerlink" title="Supplementary Group IDs"></a>Supplementary Group IDs</h3><p><strong>supplementary group</strong>：In addition to the group ID specified in the password file for a login name, most versions of the UNIX System allow a user to belong to other groups. This practice started with 4.2BSD, which allowed a user to belong to up to 16 additional groups. These supplementary group IDs are obtained at login time by reading the file /etc/group and <strong>finding the first 16 entries that list the user as a member</strong>. As we shall see in the next chapter, POSIX requires that a system support at least 8 supplementary groups per process, but most systems support at least 16.</p><p><code>/etc/group</code>格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_analyticsusers:*:250:_analyticsd,_networkd,_timed</span><br><span class="line">_analyticsd:*:263:_analyticsd</span><br></pre></td></tr></table></figure><p>解释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">组名:口令:组ID:组内用户列表</span><br></pre></td></tr></table></figure><h2 id="Signal"><a href="#Signal" class="headerlink" title="Signal"></a>Signal</h2><p><strong>Signals are a technique used to notify a process that some condition has occurred</strong>. For example, if a process divides by zero, the signal whose name is SIGFPE (floating-point exception) is sent to the process. The process has three choices for dealing with the signal.</p><ol><li>Ignore the signal. This option isn&#39;t recommended for signals that denote a hardware exception, such as dividing by zero or referencing memory outside the address space of the process, as the results are undefined.</li><li>Let the default action occur. For a divide-by-zero condition, the default is to terminate the process.</li><li>Provide a function that is called when the signal occurs (this is called “catching” the signal). By providing a function of our own, we&#39;ll know when the signal occurs and we can handle it as we wish.</li></ol><p>Many conditions generate signals. Two terminal keys, called the <strong>interrupt key</strong>—often the DELETE key or Control-C—and the <strong>quit key</strong>—often Control-backslash—are used to interrupt the currently running process. Another way to generate a signal is by calling the <strong>kill function</strong>. <strong>We can call this function from a process to send a signal to another process</strong>. Naturally, there are limitations: <strong>we have to be the owner of the other process (or the superuser) to be able to send it a signal</strong>.</p><blockquote><p>Figure 1.10 Read commands from standard input and execute them</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_int</span><span class="params">(<span class="keyword">int</span>)</span></span>;    <span class="comment">/* our signal-catching function */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[MAXLINE];   <span class="comment">/* from apue.h */</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (signal(SIGINT, sig_int) == SIG_ERR)</span><br><span class="line">            err_sys(<span class="string">"signal error"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%% "</span>);  <span class="comment">/* print prompt (printf requires %% to print %) */</span></span><br><span class="line">    <span class="keyword">while</span> (fgets(buf, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] == <span class="string">'\n'</span>)</span><br><span class="line">            buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="number">0</span>; <span class="comment">/* replace newline with null */</span></span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            err_sys(<span class="string">"fork error"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;      <span class="comment">/* child */</span></span><br><span class="line">            execlp(buf, buf, (<span class="keyword">char</span> *) <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// or</span></span><br><span class="line">            <span class="comment">// execlp(buf, buf, (char *)NULL);</span></span><br><span class="line">            err_ret(<span class="string">"couldn’t execute: %s"</span>, buf);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">127</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* parent */</span></span><br><span class="line">        <span class="keyword">if</span> ((pid = waitpid(pid, &amp;status, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">            err_sys(<span class="string">"waitpid error"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%% "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_int</span><span class="params">(<span class="keyword">int</span> signo)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"interrupt\n%% "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码使用自己定义的<code>sig_int</code>函数捕获 SIGINT 信号，但如果你按^C，代码依然会结束。原因是^C 也能像^D 一样让<code>fgets</code>函数返回一个 NULL。另外就算 while 是个死循环：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"开始休眠一秒钟...\n"</span>);</span><br><span class="line">   sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当你按第二次^C 的时候，程序依然会退出，这就说明这个<code>signal(SIGINT, sig_int)</code>是一次性的。然后我将其写在了循环中，</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (signal(SIGINT, sig_int) == SIG_ERR)</span><br><span class="line">        err_sys(<span class="string">"signal error"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"开始休眠一秒钟...\n"</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无论你按多少次^C 都无法退出了，另外还有一个现象，每次按^C<code>开始休眠一秒钟...</code>会立马打印出来。</p><h2 id="Time-Values"><a href="#Time-Values" class="headerlink" title="Time Values"></a>Time Values</h2><p>Historically, UNIX systems have maintained two different time values:</p><ol><li><p><strong>Calendar time</strong>. This value counts the number of seconds since the <strong>Epoch: 00:00:00 January 1, 1970,Coordinated Universal Time (UTC)</strong>. (Older manuals refer to UTC as Greenwich Mean Time.) These time values are used to record the time when a file was last modified, for example.</p><p>The primitive system data type <code>time_t</code> holds these time values.</p></li><li><p><strong>Process time</strong>. This is also called CPU time and measures the central processor resources used by a process. Process time is measured in clock ticks, which have historically been 50, 60, or 100 ticks per second.</p><p>The primitive system data type <code>clock_t</code> holds these time values. (We’ll show how to obtain the number of clock ticks per second with the <code>sysconf</code> function in Section 2.5.4.)</p></li></ol><p>有两种类型的时间：<strong>日历时间</strong>和<strong>进程时间</strong>，日历时间也就是 UTC。</p><p>When we measure the execution time of a process, as in Section 3.9, we’ll see that the UNIX System maintains three values for a process:</p><ul><li>Clock time</li><li>User CPU time</li><li>System CPU time</li></ul><p>The clock time, sometimes called <strong>wall clock time</strong>, is the amount of time the process takes to run, and its value depends on the number of other processes being run on the system. Whenever we report the clock time, the measurements are made with no other activities on the system.</p><p>The user CPU time is the CPU time attributed to user instructions. The system CPU time is the CPU time attributed to the kernel when it executes on behalf of the process. For example, whenever a process executes a system service, such as read or write, the time spent within the kernel performing that system service is charged to the process. The sum of user CPU time and system CPU time is often called the CPU time.</p><p>度量进程执行时间，有三种：</p><ol><li>墙上时钟，也就是进程执行花费的总时间。</li><li>用户 CPU 时间，是用户模式（非内核）下的 CPU 使用时间</li><li>系统 CPU 时间，是进程进入内核执行的 CPU 使用时间</li></ol><p>It is easy to measure the clock time, user time, and system time of any process: simply execute the time(1) command, with the argument to the time command being the command we want to measure. For example:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cd /usr/include</span><br><span class="line"><span class="meta">$</span> time -p grep _POSIX_SOURCE */*.h &gt; /dev/null</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">real    0m0.81s</span><br><span class="line">user    0m0.11s</span><br><span class="line">sys     0m0.07s</span><br></pre></td></tr></table></figure><p>The output format from the time command depends on the shell being used, because some shells don’t run /usr/bin/time, but instead have a separate built-in function to measure the time it takes commands to run. time 命令的输出格式取决于使用什么 shell，因为有些 shell 并不运行：<code>/usr/bin/time</code>，而是运行自己内置的一个 time 函数。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mathjax常用公式记录</title>
      <link href="/blog/2018/04/30/mathjax%E5%B8%B8%E7%94%A8%E5%85%AC%E5%BC%8F%E8%AE%B0%E5%BD%95/"/>
      <url>/blog/2018/04/30/mathjax%E5%B8%B8%E7%94%A8%E5%85%AC%E5%BC%8F%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="角度记法"><a href="#角度记法" class="headerlink" title="角度记法"></a>角度记法</h2><ul><li>度数：<code>$60^\circ$</code>，$60^\circ$</li><li>度数分：<code>$60^\prime$</code>，$60^\prime$</li><li>弧度：<code>$\frac{\pi}{2}$</code>，$\frac{\pi}{2}$</li><li>角度记法：<code>$\angle A$</code>，$\angle A$</li></ul><h2 id="三重环积分无法渲染的问题"><a href="#三重环积分无法渲染的问题" class="headerlink" title="三重环积分无法渲染的问题"></a>三重环积分无法渲染的问题</h2><p>在网上找了半天资料最终解决了，参考这个答案：<a href="https://math.meta.stackexchange.com/questions/9973/how-do-you-render-a-closed-surface-double-integral" target="_blank" rel="noopener">How do you render a closed surface double integral?</a>，做法是直接使用 Unicode 编码：<code>\unicode{x222F}</code>，三重环积分的编码，参考这里：<a href="http://unicode-search.net/unicode-namesearch.pl?term=INTEGRAL" target="_blank" rel="noopener">unicode-search.net</a>，所以只要将<code>$\oiiint$</code>换成<code>$\unicode{x2230}$</code>即可正确显示三重环积分。如下：</p><p>$$\unicode{x2230}$$</p><a id="more"></a><h2 id="行内-limit"><a href="#行内-limit" class="headerlink" title="行内 limit"></a>行内 limit</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$\lim\limits_&#123;x\rightarrow 0&#125; \frac&#123;\sin x&#125;&#123;x&#125; = 1$</span><br></pre></td></tr></table></figure><p>效果：$\lim\limits_{x\rightarrow 0} \frac{\sin x}{x} = 1$</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$\lim_&#123;x\rightarrow 0&#125; \frac&#123;\sin x&#125;&#123;x&#125; = 1$</span><br></pre></td></tr></table></figure><p>效果：$\lim_{x\rightarrow 0} \frac{\sin x}{x} = 1$</p><p>凭个人喜好，我就更喜欢第一种。</p><h2 id="弧"><a href="#弧" class="headerlink" title="弧"></a>弧</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$\overset&#123;\frown&#125; &#123;AB&#125;$</span><br></pre></td></tr></table></figure><p>$\overset{\frown} {AB}$</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数学基础公式推导</title>
      <link href="/blog/2018/04/25/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC/"/>
      <url>/blog/2018/04/25/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC/</url>
      
        <content type="html"><![CDATA[<p>今天看到下面这个公式，突然想我好像不会推导啊：</p><p>$\sin(\beta-\alpha) = \sin\beta\cos\alpha - \cos\beta\sin\alpha$</p><p>遂想如何推导，在 youtube 上找了一个视频：<a href="https://www.youtube.com/watch?v=uX6hxwW5BYM" target="_blank" rel="noopener">三角函数正余弦和角公式推导</a></p><a id="more"></a><p>思路是先推导出：$\cos(\beta-\alpha) = \cos\alpha\cos\beta + \sin\alpha\sin\beta$</p><blockquote><p>然后根据这个再结合正弦余弦之间的关系就很容易推 $\sin(\beta-\alpha) = \sin\beta\cos\alpha - \cos\beta\sin\alpha$</p></blockquote><p>那么怎么推导上面这个公式呢？</p><p>需要用到解析几何：</p><p><img src="https://i.loli.net/2018/04/27/5ae29c4bf121f.png" alt="Screen Shot 2018-04-27 at 11.42.48 AM.png"></p><p>结合 <code>勾股定理</code> 和 <code>余弦定理</code> 可以推导出。</p><blockquote><p>这里不给出勾股定理和余弦定理的证明，感兴趣的可以自己证。</p></blockquote><p>根据勾股定理：</p><p>$$<br>\begin{align}<br>\overline{PQ}^2<br>&amp;= (\sin\alpha - \sin\beta)^2 + (\cos\beta - \cos\alpha)^2 \newline<br>&amp;= 2 - 2(\cos\alpha\cos\beta + \sin\alpha\sin\beta) \newline<br>\end{align}<br>$$</p><p>根据余弦定理（$a^2 = b^2 + c^2 -2ab\cos A$）：</p><p>$$<br>\begin{align}<br>\overline{PQ}^2<br>&amp; = 1^2 + 1^2 - 2\cdot1\cdot1\cdot\cos(\alpha-\beta)<br>\end{align}<br>$$</p><p>由此推出：</p><p>$$<br>\cos(\alpha-\beta) = \sin\alpha\sin\beta+\cos\alpha\cos\beta<br>$$</p><p>也即：</p><p>$$<br>\cos(\beta-\alpha) = \sin\alpha\sin\beta+\cos\alpha\cos\beta<br>$$</p><p>然后：</p><p>$$<br>\begin{align}<br>\sin(\beta-\alpha)<br>&amp;= \cos(\frac{\pi}{2}-(\beta-\alpha)) \newline<br>&amp;= \cos((\frac{\pi}{2}+\alpha) - \beta) \newline<br>&amp;= \sin(\frac{\pi}{2}+\alpha)\sin\beta + \cos(\frac{\pi}{2}+\alpha)\cos\beta \newline<br>&amp;= \cos\alpha\sin\beta - \sin\alpha\cos\beta \newline<br>&amp;= \sin\beta\cos\alpha - \cos\beta\sin\alpha<br>\end{align}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Override Overload Overwrite</title>
      <link href="/blog/2017/11/14/Override-Overload-Overwrite/"/>
      <url>/blog/2017/11/14/Override-Overload-Overwrite/</url>
      
        <content type="html"><![CDATA[<p>我们都知道有些东西容易混淆，在加上中文翻译得乱七八糟，更加让人困惑。今天我要讲的这三位可就真是绝了。</p><p>它们是：Override、Overload、Overwrite。</p><a id="more"></a><p>这是我查有道词典时候看到的可怕一幕：</p><p><img src="https://i.loli.net/2019/12/09/LAIVFxpekMXyogD.jpg" alt="006zFO3ggy1flhl8a9e69j312w0tatf9.jpg"></p><p>Override 一个把三个名字都占了，你怕不怕？反正我是看的心里一紧。</p><p>如果把概念都煮成了一锅粥，那还不如不要记这些概念，你应该向更深层次去探寻。就这三个的区别来说，我觉得主要理解两个概念就行了：</p><ol><li>函数签名（signature）</li><li>多态（polymorphism、polymorphic）</li></ol><h2 id="函数签名"><a href="#函数签名" class="headerlink" title="函数签名"></a>函数签名</h2><p>函数签名是什么，其实就是用来区别函数的，两个函数怎么样认定是不同的两个函数呢，只有两个方面：</p><ol><li>函数名</li><li>参数</li></ol><p>有人说还有返回值啊，不行，返回值不能作为函数签名的一部分，因为你调用一个函数的时候，返回值根本不能帮助编译器来识别你用的是哪个函数，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line">func();</span><br></pre></td></tr></table></figure><p>请问我使用的是哪个函数？你看返回值确实不行吧。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态是面向对象编程的概念，你可以看看它的准确定义：</p><p>Polymorphism，定义很简短：polymorphism is the provision of a single interface to entities of different types.</p><p>如果父类有一个函数，子类也定义了一个完全相同的函数（函数签名相同），那么你可以用父类指针（或者说父类对象）作为统一的接口，来调用子类的方法。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(“Vehicles can move!!”);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MotorBike</span> <span class="title">extends</span> <span class="title">Vehicle</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(“MotorBike can move <span class="keyword">and</span> accelerate too!!”);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="title">extends</span> <span class="title">Vehicle</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(“Hi! I am a car!”);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Vehicle vh = <span class="keyword">new</span> MotorBike();</span><br><span class="line">        vh.move();    <span class="comment">// prints MotorBike can move and accelerate too!!</span></span><br><span class="line">        vh = <span class="keyword">new</span> Vehicle();</span><br><span class="line">        vh.move();    <span class="comment">// prints Vehicles can move!!</span></span><br><span class="line">        vh = <span class="keyword">new</span> Car();</span><br><span class="line">        vh.move();   <span class="comment">// prints Hi! I am a car!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多态的好处是可以扩展啊，比如我后来又多了个 truck 类，我不需要去动已经写好的代码，只要把 truck 模块写好，加进去就行了。</p><h2 id="Override、Overload、Overwrite-的区别"><a href="#Override、Overload、Overwrite-的区别" class="headerlink" title="Override、Overload、Overwrite 的区别"></a>Override、Overload、Overwrite 的区别</h2><p>好了，知道了这两个概念，我们再来看看上面的那三个混在一起的东西：</p><ul><li>Override（推翻，对英文意思就是这个）subclass method overrides base class method means:<ul><li>in different range (in derived class and base class)</li><li>the same function signature</li><li>the base class method is virtual（if in C++）</li></ul></li><li>overload（超载）function overloading means:<ul><li>the same range (in the same class)</li><li>the same function name</li><li>but different function signature</li></ul></li><li>overwrite（重写）subclass method hides base class method means:<ul><li>in different range (in derived class and base class)</li><li>the same function name</li></ul></li></ul><p>我们应该记住只有 Override 才跟多态有关。</p><p>Overload 是本 class 里面的不同函数（只不过函数名一样罢了，其实是两个不同的函数，看两个函数是否是同一个函数就看函数签名就行了），其实没啥稀奇的，不就是函数名一样嘛。函数签名一样，区分出是用父类还是子类的函数，这才是面向对象和多态要解决的问题。</p><h2 id="Override-和-Overwrite-的区别"><a href="#Override-和-Overwrite-的区别" class="headerlink" title="Override 和 Overwrite 的区别"></a>Override 和 Overwrite 的区别</h2><blockquote><p>比较容易混淆的其实是 Override 和 Overwrite，但你只要死记住：Override 必须函数签名要一样，而 Overwrite 只需函数名一样即可。另外 C++ 中一定要用 virtual 才算 Override，而 Java 默认就是 Override，不需要修饰词。</p></blockquote><blockquote><p>这里关于 Java 和 C++ 面向对象的细节区别可以写一大堆，比如：C++ class 后面是要加分号的，而 Java 不需要；但 Java 的类名是和文件名要一致的，而且只能有一个 public 类，而 C++不需要；Java 直接就能用 Override，而 C++必须要使用 virtual 关键字才能使用 Override（虚函数）；Java 的抽象方法跟 C++的纯虚函数对应。Java 是单继承，由接口来实现“多继承”，C++是多继承，没有接口，只有抽象类。C++还有个虚基类的概念。具体的写法上还有很多的不同，多用这两种语言写面向对象的代码，就慢慢会知道了。</p></blockquote><p>C++ 有一个 virtual 关键字和 virtual table 这个概念，没有加 virtual 的父类函数是不可能形成多态的，如果这时候你碰到父类和子类两个里面有同名的函数，那么就属于 Overwrite 这个概念了，你其实也可以称这种覆盖掉父类函数的行为为：hide 隐藏。Java 这种语言里面没有 virtual 这一套，Java 也可以表现出 Overwrite，但要注意函数签名如果一样的话，那又不叫 Overwrite 了，应该叫 Override 了（Java 如果要在子类中使用父类的同函数签名方法，则必须使用 super 关键字）。而 C++ 不一样，即便是函数签名一样，如果前面不加 virtual 是不能叫 Override 的，仍然属于 Overwrite 的概念。请看下面的例子：</p><p>用 C++ 写的话：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"A"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"B"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A *a = <span class="keyword">new</span> B();</span><br><span class="line">    a-&gt;func(<span class="number">1</span>);</span><br><span class="line">    ((B*)a)-&gt;func(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">B</span><br></pre></td></tr></table></figure><p>可以看到，C++必须要用子类类型的指针才能访问到子类的部分（建议看一本书，叫：Inside the C++ Object Model，中文叫：深入 C++对象模型，里面讲对象的内存布局讲的很清楚），java 也一样，必须转成子类型的指针才能访问，否则 IDE 会报错提示你。</p><p>Java 代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"A"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="title">extends</span> <span class="title">A</span>&#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"B"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        test t = <span class="keyword">new</span> test();</span><br><span class="line">        A a = t.<span class="keyword">new</span> B();</span><br><span class="line">        a.fun(<span class="number">1</span>);</span><br><span class="line">        ((B)a).func(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">B</span><br></pre></td></tr></table></figure><p>为什么 Java 代码里不像 C++ 代码里面那样，使用两个函数签名相同的函数？因为前面说过了，那样的话就变成 Override 了，只有在 C++ 里才能实现函数签名相同的 Overwrite（不使用 virtual 即可）。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Inside the C++ Object Model 系列笔记 四 -- The Semantics of Function</title>
      <link href="/blog/2017/10/23/The-Semantics-of-Function/"/>
      <url>/blog/2017/10/23/The-Semantics-of-Function/</url>
      
        <content type="html"><![CDATA[<blockquote><p>c++支持三种类型的成员函数，分别为 static,nostatic,virtual。每一种调用方式都不尽相同。</p></blockquote><a id="more"></a><h2 id="nonstatic-member-function"><a href="#nonstatic-member-function" class="headerlink" title="nonstatic member function"></a>nonstatic member function</h2><p>C++的设计准则之一就是:nonstatic member function 至少必须和一般的 nonmember function 有相同的效率。<br>实际上，nonstatic member function 会被编译器进行如下的转换，变成一个普通函数:</p><p>Type1 X::foo(Type2 arg1) { ... }</p><p>会被转换为如下的普通函数:</p><p>void foo(X *const this, Type1 &amp;__result, Type2 arg1) { ... }</p><p>改写函数原型，在参数中增加 this 指针，对每一个”nonstatic data member 的存取操作”改为由 this 指针来存取</p><p>将 member function 重写为一个外部函数，经过”mangling”处理（不需要处理的加上 extern “C”）</p><p>实际上，普通函数、普通成员函数、静态成员函数到最后都会变成与 C 语言函数类似的普通函数，只是编译器在这些不同类型的函数身上做了不同的扩展，并放在不同的 scope 里面而已。</p><p>编译器内部会将成员函数等价转换为非成员函数，具体是这样做的:</p><p>1.改写成员函数的签名，使得其可以接受一个额外参数，这个额外参数即是 this 指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> Point::X();</span><br><span class="line"><span class="comment">//成员函数X被插入额外参数this</span></span><br><span class="line"><span class="keyword">float</span> Point:: X(Point* <span class="keyword">this</span> );</span><br></pre></td></tr></table></figure><p>当然如果成员函数是 const 的，插入的参数类型将为 const Point* 类型。</p><p>2.将每一个对非静态数据成员的操作都改写为经过 this 操作。</p><p>3.将成员函数写成一个外部函数，对函数名进行“mangling”处理，使之成为独一无二的名称。</p><p>可以看出，将一个成员函数改写成一个外部函数的关键在于两点，一是给函数提供一个可以直接读写成员数据的通道；<br>二是解决好有可能带来的名字冲突。第一点通过给函数提供一个额外的指针参数来解决，第二点则是通过一定的规则将名字转换，使之独一无二。</p><p>于是在 VC 中对于上面的例子中的成员函数的调用将发生如下的转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//p-&gt;X();被转化为</span></span><br><span class="line">?X@Point@@QAEMXZ(p);</span><br><span class="line"><span class="comment">//obj.X();被转化为</span></span><br><span class="line">?X@Point@@QAEMXZ(&amp;obj);</span><br></pre></td></tr></table></figure><p>覆盖（override）、重载（overload）、隐藏（hide, overwrite）的区别：</p><ul><li>覆盖（也叫重写）是指在派生类中重新对基类中的虚函数（注意是虚函数）重新实现。即函数名和参数都一样（函数签名一样），只是函数的实现体不一样。</li><li>重载是指 <strong>在同一个类中</strong> 不同的函数使用相同的函数名，但是函数的参数个数或类型不同。调用的时候根据函数的参数来区别不同的函数。</li><li>隐藏是指派生类中的函数把基类中相同名字的函数屏蔽掉了。隐藏与另外两个概念表面上看来很像，很难区分，其实他们的关键区别就是在多态的实现上。</li></ul><blockquote><p>C++多态（polymorphism）表示”以一个 public base class 的指针（或者 reference），寻址出一个 derived class object”</p></blockquote><p>我专门写了一篇关于这些容易弄混的概念的文章：<a href="../2017/11/14/Override-Overload-Overwrite">Override Overload Overwrite</a></p><h2 id="Virtual-Member-Function"><a href="#Virtual-Member-Function" class="headerlink" title="Virtual Member Function"></a>Virtual Member Function</h2><p>如果 function()是一个虚拟函数，那么用指针或引用进行的调用将发生一点特别的转换——一个中间层被引入进来。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p-&gt;function()</span></span><br><span class="line"><span class="comment">//将转化为</span></span><br><span class="line">(*p-&gt;vptr[<span class="number">1</span>])(p);</span><br></pre></td></tr></table></figure><ul><li>其中 vptr 为指向虚函数表的指针，它由编译器产生。vptr 也要进行名字处理，因为一个继承体系可能有多个 vptr。</li><li>1 是虚函数在虚函数表中的索引，通过它关联到虚函数 function().</li></ul><p>何时发生这种转换？答案是在必需的时候 -- 一个再熟悉不过的答案。当通过指针调用的时候，要调用的函数实体无法在编译期决定，必需待到执行期才能获得，所以上面引入一个间接层的转换必不可少。但是当我们通过对象（不是引用，也不是指针）来调用的时候，<br>进行上面的转换就显得多余了，因为在编译器要调用的函数实体已经被决定。此时调用发生的转换，与一个非静态成员函数(Nonstatic Member Functions)调用发生的转换一致。p.function()的处理就跟非静态成员函数一样了。</p><h2 id="Static-Member-Function"><a href="#Static-Member-Function" class="headerlink" title="Static Member Function"></a>Static Member Function</h2><ul><li>不能够直接存取其类中的非静态成员（nostatic members），包括不能调用非静态成员函数(Nonstatic Member Functions)。</li><li>不能声明为 const、volatile 或 virtual</li><li>参数没有 this</li><li>可以不用对象访问，直接 类名::静态成员函数 访问，当然，通过对象调用也被允许</li></ul><p>需要注意的是通过一个表达式或函数对静态成员函数进行调用，被 C++ Standard 要求对表达式进行求值。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(a+=b).static_fuc();</span><br><span class="line">func().static_fuc();</span><br></pre></td></tr></table></figure><p>虽然省去对 a+b 求值对于 static_fuc()的调用并没有影响，但是程序员肯定会认为表达式 a+=b 已经执行，一旦编译器为了效率省去了这一步，很难说会浪费多少程序员多少时间去查找这个 bug。这无疑是一个明智的规定。func()返回一个对象。</p><p>vtable 的内容：</p><ul><li>virtual class offset（有虚基类才有）</li><li>topoffset</li><li>typeinfo</li><li>继承基类所声明的虚函数实例，或者是覆盖（override）基类的虚函数</li><li>新的虚函数（或者是纯虚函数占位）</li></ul><p>虚函数表的构造挺简单的：</p><p><img src="https://i.loli.net/2018/04/25/5ae01bb4b32a9.gif" alt="虚函数表的构造"></p><p>从内存布局的角度看，类对象继承基类的时候只把基类的 nonstatic data member 和 member function（函数入口，也可以说是函数指针） 放进自己内存里，static data member 和 static function 都在 global address 里面。然后就是虚函数表是复制了一份基类的虚函数表，然后把 virtual 实现了的部分替换掉，没实现的就不改，依然用父类的。然后虚函数表指针自然也要不一样，毕竟指向的内存地址不一样，对吧。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Inside the C++ Object Model 系列笔记 三 -- The Semantics of Data</title>
      <link href="/blog/2017/10/21/The-Semantics-of-Data/"/>
      <url>/blog/2017/10/21/The-Semantics-of-Data/</url>
      
        <content type="html"><![CDATA[<p>C++对象模型的细节，讨论了 data members 的处理。</p><h2 id="空类在内存中有空间吗"><a href="#空类在内存中有空间吗" class="headerlink" title="空类在内存中有空间吗"></a>空类在内存中有空间吗</h2><a id="more"></a><p>一个实例引出的思考：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> X&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Z</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> X&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span><span class="keyword">public</span> Y, <span class="keyword">public</span> Z&#123;&#125;;</span><br></pre></td></tr></table></figure><p>猜猜 sizeof 上面各个类都为多少？</p><p>Lippman 的一个法国读者的结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sizeof X yielded 1</span><br><span class="line">sizeof Y yielded 8</span><br><span class="line">sizeof Z yielded 8</span><br><span class="line">sizeof A yielded 12</span><br></pre></td></tr></table></figure><p>Lippman 自己的结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sizeof X yielded 1</span><br><span class="line">sizeof Y yielded 4</span><br><span class="line">sizeof Z yielded 4</span><br><span class="line">sizeof A yielded 8</span><br></pre></td></tr></table></figure><p>事实上，对于像 X 这样的一个空类，编译器会对其动点手脚——隐晦的插入一个字节。为什么要这样做呢？插入了这一个字节，那么 X 的每一个对象都将有一个独一无二的地址。<br>如果不插入这一个字节呢？哼哼，那对 X 的对象取地址的结果是什么？两个不同的 X 对象间地址的比较怎么办？</p><p>我们再来看 Y 和 Z。首先我们要明白的是实现虚继承，将要带来一些额外的负担——额外需要一个某种形式的指针。到目前为止，对于一个 32 位的机器来说 Y、Z 的大小应该为 5，而不是 8 或者 4。我们需要再考虑两点因素：内存对齐（alignment—）和编译器的优化。</p><p>空类也有 1Byte 的大小，因为这样才能使得这个 class 的 2 个 objects 在内存中有独一无二的地址。</p><h2 id="The-Binding-of-a-Data-Member"><a href="#The-Binding-of-a-Data-Member" class="headerlink" title="The Binding of a Data Member"></a>The Binding of a Data Member</h2><p>考虑下面这样的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">float</span> x;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   Point3d(<span class="keyword">float</span>, <span class="keyword">float</span>, <span class="keyword">float</span>);</span><br><span class="line">   <span class="comment">//问题是 x 到底是哪个 x 呢</span></span><br><span class="line">   <span class="function"><span class="keyword">float</span> <span class="title">X</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">X</span><span class="params">(<span class="keyword">float</span> new_x)</span> <span class="keyword">const</span></span>&#123;x = new_x;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="keyword">float</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对 member functions 本身的分析会直到整个 class 的声明都出现了才开始（直到看到代表 class 结束的}右大括号）。所以 class 的 member functions 可以引用声明在后面的成员，C 语言就做不到。</p><p>和 member functions 对比，需要十分注意的一点是:<br>class 中的 typedef 并不具备这个性质。<br>因此，类中的 typedef 的影响会受到函数与 typedef 的先后顺序的影响。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> length;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(length l)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; l &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">   <span class="keyword">typedef</span> <span class="built_in">string</span> length;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(length l)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; l &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样 f1 绑定的 length 类型是 int;<br>而 f2 绑定的 length 类型才是 string。</p><p>所以，对于 typedef 需要防御性的程序风格:<br>始终把 nested type 声明(即 typedef)放在 class 起始处!</p><h2 id="Data-Member-Layout"><a href="#Data-Member-Layout" class="headerlink" title="Data Member Layout"></a>Data Member Layout</h2><p>C++只保证处于同一个 access section（也就是 private,public,protected 片段）的数据，一定会以声明的次序出现在内存布局当中(要求较晚出现的数据成员处在较大的内存地址中)。<br>C++标准只提供了这一点点的保证。<br>允许编译器将多个 Acess Section 的顺序自由排列，而不必在乎它们的声明次序。但似乎没有编译器这样做。<br>对于继承类，C++标准并未指定是其基类成员在前还是自己的成员在前。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="keyword">int</span> k;</span><br><span class="line">   <span class="keyword">int</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据 i 一定在 j 之前，k 一定在 n 之前。具体什么顺序就看编译器了。</p><p>传统上，vptr 被安放在所有被明确声明的 member 的最后，不过也有些编译器把 vptr 放在最前面(MSVC++就是把 vptr 放在最前面，而 G++ 是把 vptr 放在最后面)。</p><h2 id="Access-of-a-Data-Member"><a href="#Access-of-a-Data-Member" class="headerlink" title="Access of a Data Member"></a>Access of a Data Member</h2><p>在 C++中，直观上来说，由一个对象存取一个 member 会比由一个指针存取一个 member 更快捷。<br>但是对于经由一个对象来存取和由一个指针来存取一个静态的 member 来说，是完全一样的，都会被编译器所扩展。</p><p>经由 member selection operators（也就是 “.” 运算符）对一个 static data member 进行存取操作只是一种语法上的便宜行事而已。member 其实并不在 class object 中，因此存取并不需要通过 class object。</p><p>经由一个函数调用的结果来存取静态成员，C++标准要求编译器必须对这个函数进行求值，虽然这个求值的结果并无用处。</p><p>foo().static_member = 100;</p><p>foo()返回一个类型为 X 的对象，含有一个 static_member，foo()其实可以不用求值而直接访 问这个静态成员，但是 C++标准保证了 foo()会被求值，可能的代码扩展为:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">void</span>) foo();</span><br><span class="line">X::static_member = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><h2 id="static-data-members"><a href="#static-data-members" class="headerlink" title="static data members"></a>static data members</h2><p>如果有两个 class ，每个都声明了一个 static member freelist，那么当他们都被放在程序的 data segment 时，就会导致名称冲突。编译器的解决方法是暗中对每一个 static data member 编码（这种手法有个很美的名称：name-mangling），以获得一个独一无二的程序识别代码。有多少种编译器就有多少种 name-mangling 做法！通常不外乎是表格啦，语法措辞啦等等。任何 name-mangling 都有两个要点：</p><ol><li>一种算法，推导出独一无二的名称。</li><li>万一编译系统（或环境工具）必须和使用者交谈，那些独一无二的名称可以轻易被推导回原来的名称。</li></ol><h2 id="nonstatic-data-members"><a href="#nonstatic-data-members" class="headerlink" title="nonstatic data members"></a>nonstatic data members</h2><p>Nonstatic data members are stored directly within each class object and cannot be accessed except through an explicit or implicit class object. An implicit class object is present whenever the programmer directly accesses a nonstatic data member within a member function. For example, in the following code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Point3d</span><br><span class="line">Point3d::translate( <span class="keyword">const</span> Point3d &amp;pt ) &#123;</span><br><span class="line">   x += pt.x;</span><br><span class="line">   y += pt.y;</span><br><span class="line">   z += pt.z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>the seemingly direct access of x, y, and z is actually carried out through an implicit class object represented<br>by the this pointer. Internally, the function is augmented as follows:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// internal augmentation of member function</span></span><br><span class="line">  Point3d</span><br><span class="line">  Point3d::translate( <span class="keyword">const</span> Point3d* <span class="keyword">this</span>, <span class="keyword">const</span> Point3d &amp;pt ) &#123;</span><br><span class="line">     <span class="keyword">this</span>-&gt;x += pt.x;</span><br><span class="line">     <span class="keyword">this</span>-&gt;y += pt.y;</span><br><span class="line">     <span class="keyword">this</span>-&gt;z += pt.z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>地址：&amp;origin._y;和&amp;origin + ( &amp;Point3d::_y - 1 );是一样的。指向 data member 的指针，其 offset 值总是被加上 1。这样可以使编译系统区分出 “一个指针 data member 的指针，用以指向 class 的第一个 member”和“一个指向 data member 的指针，但是没有指向任何 member”两种情况(成员指针也需要有个表示 NULL 的方式，0 相当于用来表示 NULL 了，其它的就都要加上 1 了)。</p><h2 id="Inheritance-and-the-Data-Member"><a href="#Inheritance-and-the-Data-Member" class="headerlink" title="Inheritance and the Data Member"></a>Inheritance and the Data Member</h2><p>C++ Standard 保证:“出现在派生类中的 base class subobject 有其完整原样性!” 子类会被放在父类的对齐空白字节之后，因为父类的完整性必须得以保证，父类的对齐空白字节 也是父类的一部分，也是不可分割的。</p><p>请看下面例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X2</span>:</span><span class="keyword">public</span> X</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span>  c2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>X2 的布局应当是 x(4),c(1),c2(1),这么说来 sizeof(X2)的值应该是 8？错了，实际上是 12。原因在于 X 后面的三个字节的填充空白不能为 c2 所用。也就是说 X2 的大小实际上为：X(8)+c2(1)+填补（3）=12。这样看来编译器似乎是那么的呆板，其实不然，看一下下面的语句会发生什么？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X2 x2;</span><br><span class="line">X x;</span><br><span class="line">x2=x;</span><br></pre></td></tr></table></figure><p>如果 X 后面的填充空白可以被 c2 使用的话，那么 X2 和 X 都将是 8 字节。上面的语句执行后 x2.c2 的值会是多少？一个不确定的值！这样的结果肯定不是我们想要的。</p><p>在多重继承的派生体系中，将派生类的地址转换为第 1 基类时成本与单继承是相同的，只需要改换地址的解释方式而已；而对于转换为非第 1 基类的情况，则需要对地址进行一定的 offset 操作 才行。<br>C++ Standard 并未明确 base classes 的特定排列次序，但是目前的编译器都是按照声明的次序来安放他们的。(有一个优化:如果第 1 基类没有 vtable 而后继基类有，则可能把它们调 个位置)。<br>多重继承中，可能会有多个 vptr 指针，视其继承体系而定:派生类中 vptr 的数目最多等于所有基<br>类的 vptr 数目的总和。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Inside the C++ Object Model 系列笔记 二 -- The Semantics of constructors</title>
      <link href="/blog/2017/10/20/The-Semantics-of-constructors/"/>
      <url>/blog/2017/10/20/The-Semantics-of-constructors/</url>
      
        <content type="html"><![CDATA[<p>这一章详细的讨论了 constructor 如何工作，讨论构造一个对象的过程以及构造一个对象给程序带来的影响。</p><h2 id="区分-trivial-和-notrivial"><a href="#区分-trivial-和-notrivial" class="headerlink" title="区分 trivial 和 notrivial"></a>区分 trivial 和 notrivial</h2><ol><li>只有编译器需要的时候(为什么会需要?后面讲的很清楚)，合成操作才是 nontrivial 的， 这样的构造函数才会被真正的合成出来;</li><li>如果编译器不需要，而程序员又没有提供，这时的默认构造函数就是 trivial 的。虽然它在概念上存在，但是编译器实际上根本不会去合成出来，因为他不做任何没有意义的事情，所以当然可以忽略它不去合成。trivial 的函数只存在于概念上，实际上不存在这个函数。</li></ol><a id="more"></a><h2 id="default-constructor"><a href="#default-constructor" class="headerlink" title="default constructor"></a>default constructor</h2><p>A default constructor is a constructor which can be called with no arguments (either defined with an empty parameter list, or with default arguments provided for every parameter).</p><h3 id="通常很多-C-程序员存在两种误解"><a href="#通常很多-C-程序员存在两种误解" class="headerlink" title="通常很多 C++程序员存在两种误解"></a>通常很多 C++程序员存在两种误解</h3><ul><li>没有定义默认构造函数的类都会被编译器生成一个默认构造函数。</li><li>编译器生成的默认构造函数会明确初始化类中每一个数据成员。</li></ul><p><strong>被声明：declared，被定义：defined</strong>。声明代表分配内存空间，定义代表初始化，也就是分配具体的值。</p><blockquote><p>注意如果声明的是一个指针（或者在其他语言里声明了一个对象或者数组的引用），那么只会开辟一个指针的空间，真正的对象要到定义的时候，也就是初始化的时候，分配内存并初始化。</p></blockquote><p>所以所有成员都在声明的时候被分配内存，构造函数的作用是初始化它们，non-object 成员需要程序员自己初始化，编译器不帮忙。</p><p>C++中对于默认构造函数的解释是:<br><strong>默认的构造函数会在需要的时候被编译器产生出来。</strong><br>这里非常重要的一点是:<br>谁需要?是程序的需要还是编译器的需要?如果是程序的需要，那是程序员的责任;<br>只有在是编译器的需要时，默认构造函数才会被编译器产生出来，而且被产生出来的默认构造函数只会执行编译器所需要的行动，而且这个产生操作只有在默认构造函数真正被调用时才会进行合成。</p><p>例如:成员变量初始化为 0 操作，这个操作就是程序的需要，而不是编译器的需要。</p><p>总结变量的初始化:</p><p>Global objects are guaranteed to have their associated memory “zeroed out” at program start-up. Local objects allocated on the program stack and heap objects allocated on the free-store do not have their associated memory zeroed out; rather, the memory retains the arbitrary bit pattern of its previous use.</p><p>只有全局变量和静态变量才会保证初始化，其中静态变量可以视为全局变量的一种，因为静态变量也是保存在全局变量的存储空间上的。<br>Golbal objects 的内存保证会在程序激活的时候被清 0；Local objects 配置于程序的堆栈中，Heap objects 配置于自由空间中，都不一定会被清为 0,它们的内容将是内存上次被使用后的痕迹!</p><p>全局变量和静态变量都放在 global data Segment 上，且在类被声明的时候就已经分配内存和初始化，也就是 <strong>在任何对象被定义之前静态变量就已经存在了（即使该 class 没有任何 object 实体，static data members 也已经存在）。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span> <span class="keyword">public</span>: <span class="keyword">int</span> val; Foo *pnext; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo_bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// Oops:  program needs bar's members zeroed out</span></span><br><span class="line">   Foo bar;</span><br><span class="line">   <span class="keyword">if</span> ( bar.val || bar.pnext )</span><br><span class="line">      <span class="comment">// ... do something</span></span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>When is a default constructor synthesized, then? Only when the implementation needs it. Moreover, the synthesized constructor performs only those activities required by the implementation. That is, even if there were a need to synthesize a default constructor for class Foo, that constructor would not include code to zero out the two data members val and pnext. For the previous program fragment to execute correctly, the designer of class Foo needs to provide an explicit default constructor that properly initializes the class’s two members.</p><p>意思是初始化 val 和 pnext 是程序员的责任，编译器不负责，所以你这里不初始化它们，它们存储的结果就是内存遗留的痕迹。</p><h3 id="什么时候编译器会给你生成默认构造函数"><a href="#什么时候编译器会给你生成默认构造函数" class="headerlink" title="什么时候编译器会给你生成默认构造函数"></a>什么时候编译器会给你生成默认构造函数</h3><p>首先你得没有写默认构造函数，编译器才会给你生成。有四类情况，编译器会给你加代码：</p><ol><li>类中有一个对象（成员变量），这个对象包含了默认构造函数</li><li>继承自带有默认构造函数的基类的类</li><li>带有虚函数的类</li><li>继承自虚基类的类</li></ol><p>如果 class A 内含一个或以上的 member objects，那么 A 的 constructor 必须调用每一个 member class 的默认构造函数。<br>具体方法是:编译器会扩张 constructors（注意：是所有的构造函数，不仅仅是默认构造函数会被扩张），在其中安插代码使得在 user code 被调用之前先调 用 member objects 的默认构造函数(当然如果需要调用基类的默认构造函数，则放在基类的 默认构造函数调用之后:基类构造函数-&gt;成员构造函数-&gt;user code)。<br>C++要求以“member objects 在 class 中的声明次序”来调用各个 construtors。这就是声明的次序决定了初始化次序(构造函数初始化列表一直要求以声明顺序来初始化)的根本原因!<br>所以你打乱 member initialization list 的顺序根本没有用哦~</p><p>理解了初始化列表中的实际执行顺序中“以 member 声明的次序”来决定的，就可以理解一些很 微妙的错误了。比如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A() : i(<span class="number">99</span>), j(<span class="number">66</span>), value(foo()) &#123;... &#125;</span><br><span class="line"><span class="keyword">int</span> i, value, j;</span><br></pre></td></tr></table></figure><p>这会不会产生错误取决于成员函数 foo()是依赖于 i 还是 j:<br>如果 foo 依赖于 i，由于 i 声明在 value 之前，所以不会产生错误;<br>如果 foo 依赖于 j，由于 j 声明在 value 之后，就产生了使用未初始化成员的错误。</p><p>带有 virtual functions 的类的默认构造函数毫无疑问是 nontrivial 的，需要编译器安插额外的<br>成员 vptr 并在构造函数中正确的设置好 vptr，这是编译器的重要职责之一。<br>继承自 virtual base class 的类的默认构造函数同样也毫无疑问的 nontrivial，编译器需要正确设置相关的信息以使得这些虚基类的信息能够在执行时准备妥当，这些设置取决于编译器实现虚基类的手法。</p><p>编译器有 4 种情况会使得编译器真正的为 class 生成 nontrivial 的默认构造函数，这个 nontrivial 的默认构造函数只满足编译器的需要(调用 member objects 或 base class 的默认构造函数、初始化 virtual function 或 virutal base class 机制)。其它情况时，类在概念上拥有默认构造函数，但是实际上根本不会被产生出来(前面的区分 trivial 和 nontrivial)。</p><p>对于一个 trivial 默认构造函数，编译器的态度是，既然它全无用处，干脆就不合成它。在这儿要厘清的是概念与实现的差别，概念上追求缜密完善，在实现上则追求效率，可以不要的东西就不要。</p><h2 id="copy-constructor"><a href="#copy-constructor" class="headerlink" title="copy constructor"></a>copy constructor</h2><p>有一个参数的类型是其类类型的构造函数是为拷贝构造函数。如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X::X( <span class="keyword">const</span> X&amp; x);</span><br><span class="line">Y::Y( <span class="keyword">const</span> Y&amp; y, <span class="keyword">int</span> =<span class="number">0</span> );</span><br><span class="line"><span class="comment">//可以是多参数形式，但其第二个即后继参数都有一个默认值</span></span><br></pre></td></tr></table></figure><h3 id="什么时候编译器会给你生成拷贝构造函数"><a href="#什么时候编译器会给你生成拷贝构造函数" class="headerlink" title="什么时候编译器会给你生成拷贝构造函数"></a>什么时候编译器会给你生成拷贝构造函数</h3><blockquote><p>其实和前面默认构造函数一样，四种情况</p></blockquote><p>如果一个类没有定义拷贝构造函数，通常按照“成员逐一初始化(Default Memberwise Initialization)”的手法来解决“一个类对象以另一个同类实体作为初值”——也就是说把内建或派生的数据成员从某一个对象拷贝到另一个对象身上，如果数据成员是一个对象，则递归使用“成员逐一初始化(Default Memberwise Initialization)”的手法。</p><p>成员逐一初始化(Default Memberwise Initialization)具体的实现方式则是位逐次拷贝（Bitwise copy semantics）</p><p>Copy constructors 和默认构造函数一样，只有在必须的时候才会被产生出来，对于大部分的 class 来说，拷贝构造函数仅仅需要按位拷贝就可以。满足 bitwise copy semantics 的拷贝构造函数是 trivial 的，就不会真正被合成出来(与默认构造函数一样，只有 nontrivial 的拷贝构 造函数才会被真正合成出来)。对大多数类按位拷贝就够了，什么时候一个 class 不展现出 bitwise copy semantics 呢? 分为 4 种情况，前 2 种很明显，后 2 种是由于编译器必须保证正确设置虚机制而引起的。</p><ul><li>当 class 内含一个 member object 而后者声明了(也可能由于 nontrivial 语意从而编译器 真正合成出来的)一个 copy constructor 时;</li><li>当 class 继承自一个存在有 copy constructor 的 base class(同样也可能是合成)时;</li><li>当 class 声明了一个或多个 virtual functions 时;(vf 影响了位语意，进而影响效率)</li><li>当 class 派生自一个继承串链，其中一个或多个 virtual base classes 时。</li></ul><p>对于前两种情况，不论是基类还是对象成员，既然后者声明有拷贝构造函数时，就表明其类的设计者或者编译器希望以其声明的拷贝构造函数来完成“一个类对象以另一个同类实体作为初值”的工作，而设计者或编译器这样做——声明拷贝构造函数，总有它们的理由，而通常最直接的原因莫过于因为他们想要做一些额外的工作或“位逐次拷贝”无法胜任。</p><p>对于有虚函数的类，如果两个对象的类型相同那么位逐次拷贝其实是可以胜任的。但问题将出现在，如果基类由其继承类进行初始化时，此时若按照位逐次拷贝来完成这个工作，那么基类的 vptr 将指向其继承类的虚函数表，这将导致无法预料的后果——调用一个错误的虚函数实体是无法避免的，轻则带来程序崩溃，更糟糕的问题可能是这个错误被隐藏了。所以对于有虚函数的类编译器将会明确的使被初始化的对象的 vptr 指向正确的虚函数表。因此有虚函数的类没有声明拷贝构造函数，编译将为之合成一个，来完成上述工作，以及初始化各数据成员，声明有拷贝构造函数的话也会被插入完成上述工作的代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"A::f()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"B::f()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  B b;</span><br><span class="line">  b.i=<span class="number">1</span>;</span><br><span class="line">  A a = b;</span><br><span class="line">  A *p = &amp;a;</span><br><span class="line">  p-&gt;f();</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; p-&gt;i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子可以看出，如果 A a = b;是 bitwise copy semantics 的话，a 内放置的就是 b 的 vptr。但其实不是，编译器给 a 生成了拷贝构造函数，初始化了 a 的 vptr。b 的 vptr 是由编译器给 b 生成的默认构造函数初始化的。但对于其他成员变量 bitwise copy semantics 依然有效，所以 i 的结果是 1。我在做这个试验的时候发现了一个有趣的现象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"A::f()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"B::f()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  B b;</span><br><span class="line">  b.i=<span class="number">1</span>;</span><br><span class="line">  A a = b;</span><br><span class="line">  A *p = &amp;a;</span><br><span class="line">  p-&gt;f();</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; p-&gt;i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个 i 不是同一个 i，b.i=1;优先给 b 中的同名变量赋值了。这样的代码简直可怕。那么怎么访问到从 A 继承来的成员变量 i 呢，请看：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"A::f()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"B::f()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  B b;</span><br><span class="line">  b.A::i=<span class="number">6</span>;</span><br><span class="line">  b.B::i=<span class="number">1</span>;</span><br><span class="line">  A a = b;</span><br><span class="line">  A *p = &amp;a;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; p-&gt;i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="命名返回值优化"><a href="#命名返回值优化" class="headerlink" title="命名返回值优化"></a>命名返回值优化</h2><p>对于一个如 foo()这样的函数，它的每一个返回分支都返回相同的对象，编译器有可能对其做 Named return Value 优化（下文都简称 NRV 优化），方法是以一个参数 result 取代返回对象。</p><p>foo()的原型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X xx;</span><br><span class="line">    <span class="keyword">if</span>(...)</span><br><span class="line">        <span class="keyword">return</span> xx;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化后的 foo()以 result 取代 xx：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">foo</span><span class="params">(X &amp;result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    result.X::X();</span><br><span class="line">    <span class="keyword">if</span>(...)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//直接处理result</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//直接处理result</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比优化前与优化后的代码可以看出，对于一句类似于 X a = foo()这样的代码，NRV 优化后的代码相较于原代码节省了一个临时对象的空间（省略了 xx）,同时减少了两次函数调用（减少 xx 对象的默认构造函数和析构函数，以及一次拷贝构造函数的调用，增加了一次对 a 的默认构造函数的调用）。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Inside the C++ Object Model 系列笔记 一 -- Object Lessons</title>
      <link href="/blog/2017/10/19/Object-Lessons/"/>
      <url>/blog/2017/10/19/Object-Lessons/</url>
      
        <content type="html"><![CDATA[<blockquote><p>多态：统一的接口，不同的实现</p></blockquote><p><strong>C++多态（polymorphism）</strong> 表示“以一个 public base class 的指针（或者 reference），寻址出一个 derived class object”</p><h2 id="Layout-Costs-for-Adding-Encapsulation-封装"><a href="#Layout-Costs-for-Adding-Encapsulation-封装" class="headerlink" title="Layout Costs for Adding Encapsulation(封装)"></a>Layout Costs for Adding Encapsulation(封装)</h2><blockquote><p>意思是：为了添加封装所需要付出的内存布局花销</p></blockquote><p>第一章 Object Lessons 介绍了 C++如何在背后实现一个对象，内存中的布局以及空间上的关系。</p><p><strong>在计算机的原理中，要实现某个机制，我们总能找到很多种实现方式</strong>（对比着学习，多思考每种实现方法的利弊），C++的类的实现也不例外，让我们对比以下三种实现方式：</p><a id="more"></a><h3 id="三种对象实现模式"><a href="#三种对象实现模式" class="headerlink" title="三种对象实现模式"></a>三种对象实现模式</h3><h4 id="A-Simple-Object-Model"><a href="#A-Simple-Object-Model" class="headerlink" title="A Simple Object Model"></a>A Simple Object Model</h4><p><img src="../../../../images/简单对象模型.jpg" alt="A Simple Object Model"></p><p>可以看到，简单对象模型把所有的 data member 和 member function（函数指针）都放在对象里了。</p><h4 id="A-Table-driven-Object-Model"><a href="#A-Table-driven-Object-Model" class="headerlink" title="A Table-driven Object Model"></a>A Table-driven Object Model</h4><p><img src="../../../../images/表驱动模型.jpg" alt="A Table-driven Object Model"></p><p>表驱动模型把 member 分为 data 和 function 两类，用两个指针分别指向两个表，一个存放所有的 data member，一个存放所有的 function 指针。</p><h4 id="The-C-Object-Model"><a href="#The-C-Object-Model" class="headerlink" title="The C++ Object Model"></a>The C++ Object Model</h4><p><img src="../../../../images/C++对象模型.jpg" alt="The C++ Object Model"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Point3d</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point3d(Type x, Type y, Type z) : x_(x), y_(y), z_(z) &#123;&#125;</span><br><span class="line">    <span class="function">Type <span class="title">x</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x_; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Type x_, y_, z_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 C++ 类并不会比 C 语言 的 struct 耗费更多的内存空间，三个 data members 直接内含于 Object 中，member functions 则放在 Object 外。</p><p>C++的 data members 有两种：<strong>static 和 nonstatic</strong></p><p>C++的 member functions 有三种：<strong>static 、nonstatic 、virtual</strong></p><blockquote><p>放在 Object 中的只有 nonstatic data members，其他的统统是放在 Object 外。</p></blockquote><p>一个对象的内存布局大小(通常由 3 部分组成):</p><ul><li>其 nonstatic data member 的总和大小;</li><li>任何由于位对齐所需要的填补上去的空间;(关于内存对齐，自己查)</li><li>为了支持 virtual 机制而引起的额外负担。</li></ul><h3 id="data-members-在内存中的布局"><a href="#data-members-在内存中的布局" class="headerlink" title="data members 在内存中的布局"></a>data members 在内存中的布局</h3><p><code>C++</code>只保证处于同一个 access section（也就是 private,public,protected 片段）的数据，一定会以声明的次序出现在内存布局当中(要求较晚出现的数据成员处在较大的内存地址中)。<br><code>C++</code>标准只提供了这一点点的保证。<br>允许编译器将多个 Acess Section 的顺序自由排列，而不必在乎它们的声明次序。但似乎没有编译器这样做。<br>对于继承类，C++标准并未指定是其基类成员在前还是自己的成员在前。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="keyword">int</span> k;</span><br><span class="line">   <span class="keyword">int</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据 i 一定在 j 之前，k 一定在 n 之前。其他顺序就看编译器了。</p><h3 id="Virtual-Table-vtbl-vtable-和-vptr"><a href="#Virtual-Table-vtbl-vtable-和-vptr" class="headerlink" title="Virtual Table(vtbl, vtable) 和 vptr"></a>Virtual Table(vtbl, vtable) 和 vptr</h3><p>Virtual function 机制由以下 2 个步骤来支持：</p><ol><li>每个 class 产生的 Virtual function 的指针放在 Virtual Table 中</li><li>编译器给每个 class object 添加一个指针 vptr，指向相应的 vtable</li></ol><p>一个 vtable 对应一个 class，一个 vptr 才对应一个 class object，必须区分开这 2 个概念。vtable 独立于对象，就跟函数独立于对象一样。这样所有对象才能共享它们，就像 static data members 被共享一样。</p><p><code>nonstatic data member</code>是对象独有的，每个对象都有自己的一份。而其他的 member 全都是公用的。其实这里可以顺便学一下<a href="https://zh.wikipedia.org/zh/序列化" target="_blank" rel="noopener">序列化</a>这个概念，思考一下序列化对象的时候哪些东西需要存储。</p><p>RTTI(run-time type identification):一般来说，每一个 class 相关联的 type_info 对象的指针通常也保存在 vtable 的第一个 slot 中。关于 type_info 是什么，可以自己查。</p><h3 id="引入继承后的对象模型成本"><a href="#引入继承后的对象模型成本" class="headerlink" title="引入继承后的对象模型成本"></a>引入继承后的对象模型成本</h3><ul><li>如果是普通继承，父对象被直接包含在子对象里面，这样父对象的存取也是直接进行的，没有额外的指针成本。</li><li>如果是虚拟继承，父对象由一个指针指出来，这样父对象的存取就必须由指针访问，添加了一层间接性。</li></ul><p>virtual base class，用以实现 “多次出现在继承体系中的 base class，有一个单一而被共享的实例”</p><p><img src="../../../../images/虚基类.jpg" alt="虚基类"></p><p><img src="../../../../images/虚拟多重继承.jpg" alt="虚拟多重继承"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> <span class="keyword">public</span>: <span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123;&#125; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> A &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> A &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>我觉得这里有个问题，class D 继承 class B 和 class C 的时候并不是虚继承，所以何不将 B 和 C 直接放在 D 中呢？这样就省了两次指针。</p></blockquote><p>这是我看到的一个讲的很不错的博客：<a href="https://liuhongjiang.github.io/hexotech/2012/11/30/virtual-inheritance/" target="_blank" rel="noopener">虚拟继承</a></p><h2 id="struct-和-class-关键字的区别"><a href="#struct-和-class-关键字的区别" class="headerlink" title="struct 和 class 关键字的区别"></a>struct 和 class 关键字的区别</h2><p>总共就两个区别：</p><ul><li>struct defaults to public access and class defaults to private access.</li><li>When inheriting, struct defaults to public inheritance and class defaults to private inheritance. (Ironically, as with so many things in C++, the default is backwards: public inheritance is by far the more common choice, but people rarely declare structs just to save on typing the “public” keyword). 哈哈，我觉得这么做的目的无非就是提醒你注意封装，不要给外部暴露没必要的东西，所以才把默认搞成 private。</li></ul><p>除此之外 struct 和 class 一样。</p><p>struct 用来表现那些只有数据的集合体 POD(Plain Old Data)、而 class 则希望表达的是<code>ADT(abstract data type)</code>的思想。</p><blockquote><p>POD stands for Plain Old Data - that is, a class (whether defined with the keyword struct or the keyword class) without constructors, destructors and virtual members functions.</p></blockquote><p>由于这 2 个关键字在本质上无区别，所以 class 并没有必须要引入，但是引入它的确非常令人满意，因为这个语言所引入的不止是这个关键字，还有它所支持的封装和继承的哲学。可以这样想象：struct 只剩下方便 C 程序员迁徙到 C++的用途了。</p><h2 id="programming-paradigms"><a href="#programming-paradigms" class="headerlink" title="programming paradigms"></a>programming paradigms</h2><p>C++支持三种形式的编程风格(或称典范 paradigm):</p><ul><li>面向过程的风格（procedural model）: 就像 C 一样，一条语句接一条语句的执行或者函数跳转;</li><li>抽象数据类型模型(abstract data type model，ADT): 仅仅使用了 class 的封装，很多人都是 在用基于对象的风格却误以为自己在使用面向对象的风格;</li><li>面向对象的风格(object-oriented): 使用了 class 的封装和多态的编程思维(多态才是 真正的面向对象的特征)。</li></ul><p>纯粹以一种 paradigm 写程序，有助于整体行为的良好稳固。</p><blockquote><p>一个 reference 通常是以一个指针来实现的，所以 point 和 reference 并没有本质的区别，reference 和 const 指针的区别就是，你取 reference 指针的地址的时候，取到的是数据的地址，const 指针取地址取到的是指针的地址。下面的程序说明了这一点：</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> &amp;b=a;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; &amp;b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; &amp;p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说你取不到 b 的地址。所以说引用相当于一个 <code>别名</code>。引用常用在函数调用里，可以直接操作原有对象，这样就可以不用写指针的指针这种绕弯的东西了。</p><blockquote><p>函数的实参传递给形参是值传递，也就是一个 copy，形参在函数里将是一个局部变量。这个特性是许多新手面临的大坑。一道经典的考察题目便是，实现一个 C 语言的 swap 函数，由于 C 语言没有引用，你就只能用指针来操作原有对象了。java 更坑，java 没有指针，所以需要用引用，但基础数据类型没有引用，所以你如果要交换基础数据类型的话，根本没办法写 swap 函数。</p></blockquote><blockquote><p>如果你对 C 语言的程序栈很了解的话，就会知道形参实际上是不存在的，实参直接拷贝到了寄存器中，所以底层上来说参数都是值拷贝，而且操作结果无法写回到实参，实参稳稳的放在上一个栈帧中从未发生任何变化。具体的细节可以看：<a href="../../../../2018/10/08/程序的机器级表示/#过程调用例子">《CSAPP》读书笔记 -- 第 3 章：程序的机器级表示</a></p></blockquote><h2 id="指针的类型"><a href="#指针的类型" class="headerlink" title="指针的类型"></a>指针的类型</h2><ul><li>对于内存来说，不同类型的指针并没有什么不同。它们都是占用一个 word 的大小（所以 word 的大小决定了内存可访问空间的大小，32 位系统是 4 字节，64 位系统是 8 字节），包含一个数字，这个数字代表内存中的一个地址;</li><li>指针的类型是编译器的概念，对于硬件来说，并没有什么指针类型的概念;</li><li>转型操作也只是一种编译器的指令，它改变的是编译器对被指内存的解释方式而已!</li><li><code>void*</code>指针只能够持有一个地址（一个字节），而不能通过它操作所指向的 object</li></ul>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>值传递和引用传递</title>
      <link href="/blog/2017/03/29/%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/"/>
      <url>/blog/2017/03/29/%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92/</url>
      
        <content type="html"><![CDATA[<p>Java 没有引用传递，本质上都是值传递，只不过如果传递的值可以是指针（Java 没有指针，所以你也可以理解为对象，其实本质上还是指针）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getString</span><span class="params">(String text)</span></span>&#123;</span><br><span class="line">        text = <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        String text = <span class="string">"world"</span>;</span><br><span class="line">        solution.getString(text);</span><br><span class="line">        System.out.println(text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>text 本质上是一个指针，而 getString 中的 text 则是另一个指针（一个局部变量），所以这里实际上有两个不同的 text，而我们实际上改变的就是一个局部变量。所以输出结果是：world。也可以理解为形参和实参不是同一个对象，形参是一个局部变量，存在于寄存器或者当前栈帧，实参存在于上一级栈帧，和而被调用的函数，在它的执行过程中不会改变上一层栈帧的实参。</p><p>如果深入了解了 C 语言程序栈的构造，就能彻底明白函数调用的细节：<a href="https://liuqinh2s.github.io/blog/2018/10/08/%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/#%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8">过程调用</a></p><p>值传递和引用传递是每个刚开始写代码的程序员的必经之坑，比如经典的 swap 函数交换，就是一个大坑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(String text1, String text2)</span></span>&#123;</span><br><span class="line">        String temp = text1;</span><br><span class="line">        text1 = text2;</span><br><span class="line">        text2 = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Solution solution = <span class="keyword">new</span> Solution();</span><br><span class="line">        String text1 = <span class="string">"world"</span>;</span><br><span class="line">        String text2 = <span class="string">"hello"</span>;</span><br><span class="line">        solution.swap(text1, text2);</span><br><span class="line">        System.out.println(text1+<span class="string">" "</span>+text2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出是：world hello</p><p>实际上我觉得这应该算得上是编程语言底层设计影响到上层使用的一个例子，不是那么自然，比较容易让人困惑。可以算作是一种封装的失败吧。补救方法在 C 中是使用指针，C++中是使用引用，Java 中是使用对象包装一层。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>常量池</title>
      <link href="/blog/2017/03/28/%E5%B8%B8%E9%87%8F%E6%B1%A0/"/>
      <url>/blog/2017/03/28/%E5%B8%B8%E9%87%8F%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<p>字符串由 char 数组实现，字符串以<code>\0</code>结尾，<code>\0</code>是 ASCII 的第一个字符，用 bit 表示也就是：<code>0000 0000</code>，这可以方便我们找到字符串的结尾。</p><blockquote><p>ASCII 字符由一个字节表示，实际上第一版的 ASCII 字符只用到了 7 个 bit，128 个字符，扩展版的 ASCII 使用了 8 个 bit。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">11</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(str, <span class="string">"0123456789\0"</span>);</span><br></pre></td></tr></table></figure><p>为了节省内存，C/C++把常量字符串放到常量池中，当几个指针被赋值了相同的字符串常量时，实际上它们会指向相同的内存地址。但用常量字符串初始化数组，情况却不同。</p><a id="more"></a><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])&#123;</span><br><span class="line">    <span class="keyword">char</span> str1[] = <span class="string">"hello world"</span>;</span><br><span class="line">    <span class="keyword">char</span> str2[] = <span class="string">"hello world"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* str3 = <span class="string">"hello world"</span>;</span><br><span class="line">    <span class="keyword">char</span>* str4 = <span class="string">"hello world"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(str1==str2)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"str1 and str2 are same.\n"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"str1 and str2 are not same.\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(str3==str4)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"str3 and str4 are same.\n"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"str3 and str4 are not same.\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：<br>str1 and str2 are not same.<br>str3 and str4 are same.</p><p>常量池虽然好用，但这样会造成一个问题，就是我们拿其中一个指针改了字符串内容，就会造成另一个指针指向的字符串也变了。为此像 C#和 Java 等语言都将字符串类型设为不可变对象，改变字符串实际上是新建了一个字符串，这样就不会引起冲突了。但如果需要不停的改变就要不停的新建，这样就太影响效率，所以又提供了<code>StringBuilder</code>类，这个类是支持在原字符串上改动的。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数组和指针的区别</title>
      <link href="/blog/2017/03/27/%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/blog/2017/03/27/%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>数组和指针的区别：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetSize</span><span class="params">(<span class="keyword">int</span> data[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">sizeof</span>(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])&#123;</span><br><span class="line">    <span class="keyword">int</span> data1[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> size1 = <span class="keyword">sizeof</span>(data1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>* data2 = data1;</span><br><span class="line">    <span class="keyword">int</span> size2 = <span class="keyword">sizeof</span>(data2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> size3 = GetSize(data1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d, %d, %d\n"</span>, size1, size2, size3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案是输出：20, 4, 4</p><a id="more"></a><p>sizeof是个关键字而不是函数，sizeof(data1)是求数组的大小，这里有5个int型元素，所以总共20个字节，data2声明为指针，尽管指向了一个数组，但本质上只是一个指针，所以sizeof(data2)的语义范围收缩了，无法仅通过一个指针得知其所指范围。在32位系统上一个指针是4字节，所以结果就是4。在C/C++中，当数组作为函数的参数进行传递时，数组就自动退化为同类型的指针，因此size3的结果也是4。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
