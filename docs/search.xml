<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[前端学习攻略]]></title>
    <url>%2Fblog%2F2018%2F11%2F01%2F%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%94%BB%E7%95%A5%2F</url>
    <content type="text"><![CDATA[官方文档： w3school MDN Web Docs 不用刻意跑到这两个网站里去搜索，直接google即可。一般搜索结果里前几个就是这两个网站。]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CSS传统布局]]></title>
    <url>%2Fblog%2F2018%2F11%2F01%2FCSS%E4%BC%A0%E7%BB%9F%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[displaydisplay是CSS中最重要的用于控制布局的属性。每个元素都有一个默认的display值，这与元素的类型有关。对于大多数元素它们的默认值通常是block或inline。一个block元素通常被叫做块级元素。一个inline元素通常被叫做行内元素。 blockdiv是一个标准的块级元素。一个块级元素会新开始一行并尽可能撑满容器。其他常用的块级元素包括p、form和HTML5中的新元素：header、footer、section等。 inlinespan是一个标准的行内元素。一个行内元素可以在段落中&lt;span&gt;像这样&lt;/span&gt;包裹一些文字而不会打乱段落的布局。a元素是最常用的行内元素，它可以被用作链接。 none另一个常用的display值是none。一些特殊元素的默认值是它，例如script。 它和visibility属性不一样。把display设置成none元素不会占据它本来应该显示的空间，但是设置成visibility: hidden还会占据空间。 其他display值还有很多有意思的display值，例如list-item和table。这里有一份详细的列表。之后我们会讨论到inline-block和flex。 使用技巧 每个元素都有一个默认的display类型。不过你可以随时随地重写它，常见的例子是：把li元素修改成inline，制作水平菜单。 display:none通常被javascript用来在不删除元素的情况下隐藏或显示元素。 position为了制作更多复杂的布局，我们需要讨论一下position属性。 staticposition: static;，static是默认值。任意position: static;不会被特殊定位，也就是表示它不会被”positioned”，一个position被设置成其他值的元素表示它会被”positioned”。 relative12345678910.relative1 &#123; position: relative;&#125;.relative2 &#123; position: relative; top: -20px; left: 20px; background-color: white; width: 500px;&#125; 在一个相对定位的元素上设置top、right、bottom、left属性会使其偏离正常位置，其他元素的位置则不会受其影响。 fixed一个固定定位元素会相对于视窗来定位，这意味着即使页面滚动，它还是停留在原来的位置，也就是脱离文档流。 absoluteabsolute与fixed的表现类似，但是它不是相对于视窗而是相对于最近的”positioned”祖先元素，如果没有这样一个祖先元素，那么它相对于文档的body元素，并且它会随着页面滚动而移动。记住一个”positioned”元素是指position值不是static的元素。 float另一个布局中常用的CSS属性是float。float可用于实现文字环绕图片，如下： 1234img&#123; float: right; margin: 0 0 1em 1em;&#125; clearclear属性被用于控制浮动。比较下面两个例子： 12&lt;div class="box"&gt;...&lt;/div&gt;&lt;section&gt;...&lt;/section&gt; 123456.box&#123; float: left; width: 100px; height: 100px; margin: 1em;&#125; 123456789.box &#123; float: left; width: 200px; height: 100px; margin: 1em;&#125;.after-box &#123; clear: left;&#125; 清除浮动（clearfix hack）在使用浮动的时候经常遇到一些古怪的事： 123img &#123; float: right;&#125; 见证奇迹的时刻到了！有一种比较丑陋的方法可以解决这个问题，它叫做清除浮动（clearfix hack）. 让我们加入一些新的CSS样式： 123.clearfix &#123; overflow: auto;&#125; 现在再看看发生了什么：]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CSS Flex 布局]]></title>
    <url>%2Fblog%2F2018%2F11%2F01%2FCSS%20Flex%20%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[Flex布局是什么？Flex 是 Flexible Box 的缩写，意味 “弹性布局”。 flex影响的是其内元素的布局方式，而非影响这个容器自己所处的位置。 任何容器都可以指定为flex布局。 123.box&#123; display: flex;&#125; 行内元素也可以使用flex布局： 123.box&#123; display: inline-flex;&#125; 注意，设为flex布局之后，子元素的float、clear、vertical-align属性将失效。 Flex布局的基本概念采用Flex布局的元素，称为Flex容器（flex container），它的所有子元素自动成为容器成员，称为 flex item。 容器默认存在两根轴：水平的叫：主轴（main axis），垂直的叫：交叉轴（cross axis）。主轴的开始位置叫做：main start，结束位置叫做：main end；交叉轴的开始位置叫做：cross start，结束位置叫做：cross end。 主轴不一定是横向的，可以设置为纵向，且从上到下（起点在上，终点在下），这种情况下交叉轴就是横向了，且从左到右（起点在左，终点在右）。item始终沿主轴排列，交叉轴只是用来辅助主轴的浮动问题，单个item占据的主轴空间叫做：main size，占据的交叉轴空间叫做：cross size。 flex容器的属性 flex-direction flex-wrap flex-flow justify-content align-items align-content flex-direction顾名思义是决定 主轴 的方向： 123.box&#123; flex-direction: row | row-reverse | column | column-reverse&#125; row：水平布局，从左到右 row-reverse：水平布局，从右到左 column：垂直布局，从上到下 column-reverse：垂直布局，从下到上 flex-wrap默认情况下，项目都排列在一条轴上。flex-wrap属性定义，如果一条轴上摆不下，如何换行。 123.box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; nowrap：不换行 wrap：换行，第一行在上方 wrap-reverse：换行，第一行在下方 flex-flowflex-flow是flex-direction和flex-wrap的简写形式，默认值为：row nowrap。 123.box &#123; flex-flow: row nowrap;&#125; justify-contentjustify-content定义了item在主轴上的对齐方式（不管主轴是横向还是纵向，都是作用在主轴上）。 123.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; flex-start（默认值）：左对齐 flex-end：右对齐 center：居中 space-between：两端对齐，item的间隔相等 space-around：每个item两侧的间隔相等，所以item之间的间隔比item与边框的间隔大一倍。 align-itemsalign-items定义了item在交叉轴上如何对齐。 123.box&#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; flex-start：与交叉轴的起点对齐 flex-start：与交叉轴的终点对齐 center：与交叉轴的中点对齐 baseline：item的第一行文字的基线对齐 stretch（默认值）：如果item未设置高度或设为auto，将占满整个容器。 align-contentalign-content属性定义了多根主轴的对齐方式。如果项目只有一根主轴，该属性不起作用。 123.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; flex-start：与交叉轴的起点对齐 flex-end：与交叉轴的中点对齐 center：与交叉轴的中点对齐 space-between：与交叉轴的两端对齐，轴线之间的间隔平均分布 space-around：每根轴线两侧的间隔都相等，所以轴线与轴线之间的间隔，比轴线与边框的间隔大一倍 stretch（默认值）：轴线占满整个交叉轴 item的属性 order flex-grow flex-shrink flex-basis flex align-self orderorder定义item的排列顺序。数值越小，排列越靠前，默认为0。 123.item&#123; order: &lt;integer&gt;;&#125; flex-growflex-grow属性定义项目的放大比例，默认为0，也就是不铺满剩余空间。 123.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; 如果所有item的flew-grow属性都是1，那么它们将等分剩余空间。一个item所占的空间比例就是用它的flex-grow除以总的flex-grow。 flex-shrinkflex-shrink属性定义了item的缩小比例，默认为1，即空间不足时，缩小item。 123.item&#123; flex-shrink: &lt;integer&gt;; /* default 1 */&#125; 如果所有item的flex-shrink属性都为1，当空间不足时，都将等比例缩小（注意是等比例缩小而不是缩成同样大小），如果一个item的flex-shrink为0，则当空间不足时，不缩小。 flex-basisflex-basis属性定义了item占据主轴空间的大小，优先级高于width和height。默认值为 auto，即item的本来大小。 123.item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; flexflex属性是flex-grow、flex-shrink、flex-basis的简写，默认值为0 1 auto。后两个属性可选。 123.item &#123; flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]&#125; 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 align-selfalign-self属性允许单个的item重新设定align-items属性。默认值为auto，表示继承父元素的align-items属性。 123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125;]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CSS布局]]></title>
    <url>%2Fblog%2F2018%2F11%2F01%2FCSS%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[做网站的前端开发，学习CSS布局是非常重要的，这里给出一些质量高的资料： 学习CSS布局 Flex布局教程–阮一峰 Flex布局实战–阮一峰 布局的传统解决方案，基于盒装模型。依赖 display属性 + position属性 + float属性。 传统CSS布局 CSS Flex 布局 居中和自适应margin: auto;1234#main&#123; width: 600px; margin: 0 auto;&#125; 设置块级元素width可以防止它从左到右撑满整个容器。然后你就可以设置左右外边距为auto来使其水平居中。元素会占据你所指定的宽度，然后剩余的宽度会一分为二成为左右外边距。 唯一的问题是，当浏览器窗口比元素的宽度还要窄时，浏览器会显示一个水平滚动条来容纳页面。让我们再来改进一下这个方案… max-width1234#main&#123; max-width: 600px; margin: 0 auto;&#125; 在这种情况下使用max-width来代替width可以使浏览器更好的处理小窗口的情况。这点在移动设备上显得尤为重要。 盒模型元素的真实占据空间 = 元素大小+内边距+边框 box-sizing盒模型对于元素真实大小的获取并不直接，需要自己计算，所以新增了一个叫做：box-sizing的CSS属性。当你设置一个元素为：box-sizing: border-box;时，此元素的内边距和边框不再增加它的宽度。 12345* &#123; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box;&#125; 媒体查询“响应式设计（Responsive Design）”是一种让网站针对不同的浏览器和设备呈现不同显示效果的策略，这样做可以让网站在任何情况下都显示的很棒。 媒体查询是做响应式设计的最强大工具。 123456789101112131415@media screen and (min-width:600px)&#123; nav&#123; float: left; width: 25%; &#125; section&#123; margin-left: 25%; &#125;&#125;@media screen and (max-width:599px)&#123; nav li&#123; display: inline; &#125;&#125;]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue入门重点笔记（可作为面试考察点）]]></title>
    <url>%2Fblog%2F2018%2F10%2F29%2Fvue%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[项目初始化命令 安装vue-cli: npm install -g vue-cli 初始化项目: vue init webpack my-project 进入项目: cd my-project 安装依赖: npm install 运行项目: npm run dev 项目目录结构最重要的几个东西： index.html：项目根视图 main.js App.vue src目录 单文件项目(Single Page Application)vue组件：包含三个部分 template：视图 script：逻辑 style：样式 知识点： template下只能存在一个根元素 script里面必须导出当前组件: export default {} data必须是个函数，否则就是单实例，模板在多处使用表现将一致。 使用scoped来使style只在当前组件生效 vue基本指令： 语法： 可以根据data中返回的值，动态渲染文本。 只能是单行语句。比如if(0&lt;10){return &#39;对的&#39;} else{return &#39;错的&#39;}和let a = 10都不能使用。 不能作用在HTML属性上，遇到这种情况应该使用v-bind指令。 v-html：遇到包含HTML的字符串，可以对HTML进行解析 v-text：遇到包含HTML的字符串，不解析其中的HTML v-bind用来使HTML属性中的字符串成为一个变量，可在data中定义，并动态赋值，使之变化。 v-if、v-else、v-else-if v-if和v-show的区别：v-if是通过js创建和消除元素，在DOM层级上。v-show是通过调整css来显示和不显示元素，在样式层级上。 computed和methods的区别：computed是基于依赖缓存的，如果依赖没有变，就直接返回上次计算的结果。methods则每次都进行计算，浪费性能。 v-model双向数据绑定，常用的场景有：输入框给data里的变量赋值，然后用另一个标签显示这个变量，也就是这个变量是可读可写的。 1&lt;input type="text" v-model="msg"&gt; 父子组件数据交互父 -&gt; 子：props数据传递类型限制（验证） 数据类型验证 多数据类型验证 必选项 默认值 obj、arr数据类型的默认值 子 -&gt; 父：emit Event]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[处理器体系结构]]></title>
    <url>%2Fblog%2F2018%2F10%2F13%2F%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[Y86指令集体系结构Y86指令集基本上是IA32指令集的一个子集。这个指令集就是我们处理器实现的目标。如下图： IA32的movl指令分成了4个不同指令：irmovl、rrmovl、mrmovl和rmmovl，i表示立即数Immediate，r表示寄存器Register，m表示存储器Memmory。第一个字母表示源，第二个字母表示目的。 这里不实现的功能有： 存储器引用方式是简单的基址+偏移量形式，不支持变址寄存器（second index register）和任何寄存器伸缩（scaling）。 和IA32一样不允许从一个存储器直接传送到另一个存储器地址。 不允许立即数传送到存储器 4个整数操作指令：addl、subl、andl、xorl 7个跳转指令：jmp、jle、jl、je、jne、jge、jg。 6个条件传送指令：cmovle、cmovl、cmove、cmovne、cmovge、cmovg。 另外还有：call、ret、pushl、popl，halt指令停止指令执行。IA32中有一个与之相当的指令hlt，IA32的应用程序不允许使用这条指令，因为它会导致整个系统暂停运行。对于Y86来说，执行halt指令会导致处理器停止，并将状态码设置为HLT。 指令编码与IA32一样使用小端编码。 每条指令的第一个字节表明指令的类型，这个字节分为两部分，每部分4位：高4位是代码（code）部分，低4位是功能（function）部分。代码值为 0~0xB。可以观察到，rrmvol与条件传送指令有同样的指令代码，可以把它看作是一个无条件传送，就好像jmp指令是无条件跳转一样，它们的功能代码都是0。 寄存器编码如下： 举个例子：用16进制表示指令 rmmvol %esp, 0x12345(%edx)的字节编码。 从上面图中可以看到，rmmovl第一个字节为40，由于%esp是4（占4位），%edx是2（占4位），所以第二个字节是42，最后再加上偏移量 00 01 23 45，小端表示是：45 23 01 00，所以最后得到指令的编码是：404245230100。 指令集的一个重要性质是字节编码必须有唯一解释，任意一个字节序列要么是一个唯一的指令，要么是一个不合法的指令。 相比于IA32，Y86没那么紧凑，IA32对寄存器只用了3位来编码，5位表明指令类型，所以IA32能将出栈入栈放进一个字节里。另外IA32可以将常数值编码成1、2、4字节，Y86总是编码成4字节。 RISC 和 CISC RISC: reduced instruction set computers，精简指令集 CISC: complex instruction set computers，复杂指令集 Y86异常 对于Y86，当遇到这些异常的时候，我们简单的让处理器停止执行指令。在更完善的设计中，处理器通常会调用一个 exception handler（异常处理程序），这个过程被指定用来处理遇到的某种类型的异常，例如放弃程序或调用一个用户自定义的 signal handler（信号处理程序）。 Y86程序12345678910int Sum(int *Start, int Count)&#123; int sum = 0; while (Count) &#123; sum += *Start; Start++; Count--; &#125; return sum; &#125; 可以看到Y86有时候需要两条指令来完成IA32一条指令就能完成的事。然而如果用数组索引来写这个程序，要转换成Y86会很困难，因为Y86没有伸缩寻址。 完整代码如下： 以.开头的是 assembler directive（汇编器命令），命令.pos 0告诉汇编器应该从地址0处开始产生代码。第3、4行使用的Stack标签，在最后有声明，其位置是0x100。第9到13行声明了一个数组，4字节对齐，值分别是：0xd，0xc0，0xb00，0xa000，array标签是起址。 细节问题，pushl %esp（这个指令只能用汇编语言写，C语言无法产生）是先把%esp的值转移到栈，还是先%esp减4再将结果转移到栈，实际上不同版本的intel处理器都会产生不同的结果，所以一个很重要的教训是要保证细节上的一贯性。 逻辑设计和硬件控制语言HCL 构建一个组合电路有两条限制： 两个或多个逻辑门的输出不能连接在一起。这样会导致线上的信号矛盾，产生不合法的电压或电路故障。 必须是无环的，也就是不能形成回路。 下面是个简单的例子： 用HCL来写这个网的函数就是：bool eq = (a &amp;&amp; b) || (!a &amp;&amp; !b) HCL是用来C语言风格的语法，但这里同C语言不一样，该语句的意思不是执行了一次计算并将结果放入存储器，而是使用一个名字eq来称谓一个表达式。 实际上上面的组合电路就是同或，异或的表达式是：bool eq = (!a &amp;&amp; b) || (a &amp;&amp; !b) 多路复用器（multiplexor，通常称为：MUX）： bool out = (s &amp;&amp; a) || (!s &amp;&amp; b) 字级的组合电路和HCL整数表达式字级与电路： bool Eq = (A == B); 也可以用异或来实现： 字级多路复用电路： 用HCL来描述就是： 1234int Out = [ s: A; 1: B;]; 四路复用器： 123456int Out4 = [ !s1 &amp;&amp; !s0: A; # 00 !s1 : B; # 01 !s0 : C; # 10 1 : D; # 11]; 第二个表达式可以写成!s1，而不用写的更完整!s1&amp;&amp;s0，是因为另一种可能s0=0已经出现在了第一个选择表达式了，若能到达第二个选择表达式，则s0=1。类似的，第三个表达式可以写成!s0，第四个表达式可以简单的写成1。]]></content>
      <categories>
        <category>读书笔记</category>
        <category>《CSAPP》</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[程序的机器级别表示]]></title>
    <url>%2Fblog%2F2018%2F10%2F08%2F%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[从编译C语言文件说起1$ gcc -01 -o p p1.c p2.c 使用了gcc命令来编译，也可以简单写作：cc。 优化层级为1，1级是最低的，层级越高程序优化越好，但增加了编译时间，也使调试变得更难，且跟源程序差异很大不便于理解。 编译的流程是： 预处理器（preprocessor）把诸如：#include、#define、#if、#else、#elif、#ifdef、endif等预编译指令替换掉。 编译器（compiler）把.c源文件编译成.s的汇编代码文件。 汇编器（assembler）把汇编代码文件转换成相应的二进制目标文件.o，目标文件已经是机器码了，只是没有填入全局变量的地址。 链接器（linker），把多目标文件和库函数链接在一起，形成可执行文件。 instruction set architecture，ISA，指令集体系结构，定义了处理器状态，指令的格式和行为。intel的指令集包括32位的：IA32，以及64位的：x86-64。 编译器做了整个编译流程的大部分工作，汇编代码几乎就是可供人阅读版本的机器码。所以看懂汇编代码是关键。 IA32程序代码和C语言很不相同，一些在C语言下看不到的处理器状态可以在这里看到： 程序计数器（program counter，PC，也叫：instructor pointer）在IA32中叫：%eip，指出下一条指令在内存中的位置 整数寄存器，可以用来保存数据 状态码寄存器，可以用来实现条件控制代码如：if和while 浮点寄存器，用来计算浮点数 例子1234567int accum = 0;int sum(int x, int y)&#123; int t = x + y; accum += t; return t;&#125; 如果要看到编译出的汇编代码，可以使用-S选项： 1$ gcc -01 -S code.c 这样就会使编译流程停留在 预处理-&gt;编译 阶段，而不是继续进行接下来的汇编和链接，生成的文件是：.s汇编文件。编译后的汇编代码中会包含如下代码： 12345678sum: pushl %ebp movl %esp, %ebp movl 12(%ebp), %eax addl 8(%ebp), %eax addl %eax, accum popl %ebp ret 这段代码中的每一句都对应一个机器指令，比如pushl这句的意思就是把寄存器%ebp的内容push到程序栈（内存中）上。在汇编代码里所有的所有的局部变量都不见了，全局变量还可以看到，因为编译器还没有决定这个变量在内存中的存储位置。 如果我们使用-c选项，GCC就会既编译又汇编： 1$ gcc -01 -c code.c 这样就生成了目标文件code.o，在800bytes的code.o文件中，有17bytes是对应上面的汇编代码的： 155 89 e5 8b 45 0c 03 45 08 01 05 00 00 00 00 5d c3 可以使用反汇编将难懂的目标文件代码转成汇编代码： 1$ objdump -d code.o IA32指令的长度是1到15字节，越常用的操作数越少的指令越短，反之则越长。 给定一个开始的位置，只对应一种机器指令，比如只有pushl %ebp指令是以55开头的 反汇编只需要根据目标文件就可以翻译出汇编文件 反汇编出来的文件跟直接编译的汇编文件有些不一样，比如所有指令都省略了后缀l。l是大小指示符，而大多数情况下是可以省略l的。 生成真正可执行的文件还需要链接操作，而且必须包含main函数。假设我们的main.c文件如下： 123int main()&#123; return sum(1, 3);&#125; 我们可以使用如下指令生成可执行文件： 1$ gcc -01 -o prog code.o main.c prog文件增长到了9123bytes，因为它不仅包含我们写的代码，而且包含了用来开始和结束的程序，以及与操作系统进行交互的程序。 可以看到全局变量在链接的时候定址。 汇编代码的格式假设我们有一个C语言文件simple.c： 12345int simple(int *xp, int y) 2&#123; int t = *xp + y; *xp = t; return t;&#125; 可以得到如下汇编代码： 12345678910111213141516.file &quot;simple.c&quot; .text.globl simple .type simple, @functionsimple: pushl %ebp movl %esp, %ebp movl 8(%ebp), %edx movl 12(%ebp), %eax addl (%edx), %eax movl %eax, (%edx) popl %ebp ret .size simple, .-simple .ident &quot;GCC: (Ubuntu 4.3.2-1ubuntu11) 4.3.2&quot; .section .note.GNU-stack,&quot;&quot;,@progbits 所有以.开头的行都是用来指导汇编器和链接器的，我们不用去管。而这段代码的大概意思如下： 123456789simple: pushl %ebp 保存帧指针 movl %esp, %ebp 创建新的帧指针 movl 8(%ebp), %edx 从内存中读取xp movl 12(%ebp), %eax 从内存中读取y addl (%edx), %eax *xp+y=t movl %eax, (%edx) 把t存到xp指向的地址中 popl %ebp 重新获取帧指针 ret 返回 ATT和intel汇编格式ATT即AT&amp;T，是贝尔实验室旗下的公司。 GCC和OBJDUMP默认生成ATT格式的汇编代码，微软和因特尔的编程工具则默认生成intel格式的汇编代码。 使用如下命令可以让GCC生成intel格式的代码： 1$ gcc -01 -S -masm=intel code.c 两者的区别如下： intel代码省略了用来指定大小的后缀，比如使用mov而不是movl intel代码省略了寄存器前面的%，比如使用esp而不是%esp intel代码用了不同的方式来描述内存地址，比如使用DWORD PTR [ebp+8]而不是8(%ebp) intel代码多操作数指令的操作数顺序跟ATT相反 由于是由16bit架构扩展到32bit架构的，intel管16bit数据类型叫：word，32bit数据类型叫：double words，64bit数据类型叫：quad words。 数据格式 访问数据IA32 CPU 包含了8个寄存器，每个有32bit存储空间，用来存储整形值以及指针。 x86-64则进一步扩展了这些寄存器： 前六个寄存器称为通用寄存器，有其特定的用途： %rax(%eax) 用于做累加，过程调用返回值 %rcx(%ecx) 用于计数 %rdx(%edx) 用于保存数据 %rbx(%ebx) 用于做内存查找的基础地址 %rsi(%esi) 用于保存源索引值 %rdi(%edi) 用于保存目标索引值 操作数指示符 有三种类型的操作数，立即数(Imm)、寄存器值(Reg)、内存值(Mem)。 mov指令 pushl %ebp指令等价于下面的指令： 12subl $4,%esp 减小栈指针movl %ebp,(%esp) 把%ebp中的数据写到%esp指向的内存中 popl %eax指令等价于下面的指令： 12movl (%esp), %ebp 把%esp指向的内存地址中的值读到%eax中addl $4, %esp 增加栈指针 算术和逻辑操作load effective address，leal指令，实际上是一个movl指令。 多个操作数的指令，注意一下两个操作数的顺序即可 位移操作位移的值是用一个单字节来表示，且数值只能是0到31，所以这个字节只有低五位才会被考虑。 扩展乘除指令 控制状态码使用单比特的状态码来描述算数和逻辑运算的状态。最常用的状态码如下： CF: carry flag 进位符，用来表示最高位的进位。通常用来检测无符号运算的溢出 ZF: zero flag，零标志符，最近的操作产生了0 SF: sign flag，符号位，最近的操作产生了负数 OF: overflow flag，溢出符，补码溢出，正负都可以，表示有符号溢出 举个例子：t=a+b，a、b、t都是整形数。 1234CF: (unsigned)t&lt;(unsigned)a 无符号溢出ZF: (t==0) 零SF: (t&lt;0) 负数OF: (a&lt;0 == b&lt;0) &amp;&amp; (t&lt;0 != a&lt;0) 有符号溢出 OF的表达式也可以写作：(a&lt;0 &amp;&amp; b0) || (a&gt;0 &amp;&amp; b&gt;0 &amp;&amp; t&lt;0)，也就是说a、b都是负数相加却是正数，或者a、b都是正数相加却是负数，这两种情况就代表溢出了。 leal操作不会改变状态码，因为这个指令只是用来计算地址。除此之外表3.7中的所有操作都可能改变状态码。例如逻辑操作：XOR，会使CF和OF置零，移位操作会使CF置为最后一个移位出去的bit，但OF要置零。自增和自减指令会设置OF和ZF，不设置CF。 CMP指令类似于SUB指令，但只修改状态码而不改变其他寄存器，如果两个操作数相等，ZF就会被设置；TEST指令类似于AND指令，但只修改状态码而不改变其他寄存器，如果两个操作数是重复的： testl %eax,%eax，作用是检测%eax是0，还是正数，还是负数。 访问状态码有三种常用的方式访问状态码： 根据几个状态码的逻辑组合，设置单个字节为0或1，也就是set指令 根据状态码，跳转到程序的其他分支 根据状态码传送数据 举个例子：计算a&lt;b，a和b都是int型 1234a is in %edx, b is in %eaxcmpl %eax, %edx Compare a:bsetl %al Set low order byte of %eax to 0 or 1movzbl %al, %eax Set remaining byte of %eax to 0 setl 指令是：D &lt;- SF^OF，也就是有两种情况代表 a-b&lt;0： OF=0（a-b没有发生溢出），且SF=1（a-b结果为负） OF=1（a-b发生了溢出），且SF=0（a-b结果为非负） 第二种情况比较复杂，需要简单分析一下。a-b发生了溢出，有两种情况：正溢出和负溢出。负溢出：a是负数，b是正数，但a-b结果为正（结果小于了最小的负数，发生溢出）；正溢出：a是正数，b是负数，但a-b结果为负（结果大于了最大的正数，发生溢出）。 比如： 123-128： 1000 0000127: 0111 1111-127: 1000 0001 a=-128, b=127, a-b=-128-127= $(1 0000 0001)_2$ , 从结果上来看就变成了1（正数），这就是负溢出 a=127, b=-127, a-b=127-(-127) = $(1111 1110)_2$ , 从结果上来看就变成了 -2（负数），这就是正溢出 OF=1, SF=0，就是负溢出，而负溢出代表着a是负数，b是正数，也就是a&lt;b 其他三个有符号比较以此类推。 跳转指令 可以看到条件跳转必须是直接的，而无条件跳转可以使用操作数。 跳转位置的编码有两种： 借助PC使用相对定位 使用绝对定位 实例如下： 12345678910jle .L2 if &lt;=, goto dest2 .L5: dest1: movl %edx, %eax sarl %eax subl %eax, %edx leal (%edx,%edx,2), %edx testl %edx, %edxjg .L5 if &gt;, goto dest1 .L2: dest2: movl %edx, %eax 目标文件和汇编文件对应如下： 123456788: 7e 0d jle 17 &lt;silly+0x17&gt; Target = dest2a: 89 d0 mov %edx,%eax dest1:c: d1 f8 sar %eaxe: 29 c2 sub %eax,%edx10: 8d 14 52 lea (%edx,%edx,2),%edx13: 85 d2 test %edx,%edx15: 7f f3 jg a &lt;silly+0xa&gt; Target = dest117: 89 d0 mov %edx,%eax dest2: 对应的关系是：0xd+0xa=0x17，0xf3+0x17=0xa，为什么是加下一条指令的地址而不是当前指令呢？这个传统要追溯到计算机的早期实现，当时的处理器会在执行每一条指令之前先更新一下PC（program counter）。 12345678804839c: 7e 0d jle 80483ab &lt;silly+0x17&gt;804839e: 89 d0 mov %edx,%eax80483a0: d1 f8 sar %eax80483a2: 29 c2 sub %eax,%edx80483a4: 8d 14 52 lea (%edx,%edx,2),%edx80483a7: 85 d2 test %edx,%edx80483a9: 7f f3 jg 804839e &lt;silly+0xa&gt;80483ab: 89 d0 mov %edx,%eax 从反汇编代码来看，跳转如果使用PC相对地址，则不管代码存储到内存中的哪个位置，跳转的地址都不需要修改，且需要的编码更短。 翻译条件分支1234if(test-expr) then-statementelse else-statement 先写成等价的goto版本，然后就可以很轻松的转成汇编了 12345678t=test-expr;if(!t) goto false; then-statement goto done;false: else-statementdone: 从汇编的角度看 &amp;&amp;短路 原理： 12345void cond(int a, int *p)&#123; if (p &amp;&amp; a &gt; 0) *p += a;&#125; 12345678910a %ebp +8, p at %ebp +12movl 8(%ebp), %edxmovl 12(%ebp), %eaxtestl %eax, %eaxje .L3testl %edx, %edxjle .L3addl %edx, (%eax).L3: 可以看到第一个条件通不过的时候就跳过了第二个条件判断。 循环do while123do body-statement while(test-expr) goto版本： 12345loop: body-statement t = test-expr; if (t)goto loop; while12while (test-expr) body-statement 先转成do while形式： 123456if (!test-expr) goto done;do body-statement while (test-expr);done: 在把do while转成goto版： 123456789t = test-expr;if (!t) goto done;loop: body-statement t = test-expr; if (t) goto loop;done: for12for (init-expr; test-expr; update-expr) body-statement 先转成while形式： 12345init-expr;while (test-expr) &#123; body-statement update-expr;&#125; 然后转成do while形式： 12345678init-expr;if (!test-expr) goto done;do &#123; body-statement update-expr;&#125; while (test-expr);done: 最后转成do while的goto版本： 1234567891011init-expr;t = test-expr;if (!t) goto done;loop: body-statement update-expr; t = test-expr; if (t) goto loop;done: 状态转移指令 1v = test-expr ? then-expr : else-expr; goto版： 1234567if (!test-expr) goto false;v = true-expr;goto done;false: v = else-expr;done: switchswitch主要使用了跳转表： 123456789101112131415161718192021int switch_eg(int x, int n) &#123; int result = x; switch (n) &#123; case 100: result *= 13; break; case 102: result += 10; /* Fall through */ case 103: result += 11; break; case 104: case 106: result *= result; break; default: result = 0; &#125; return result;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142int switch_eg_impl(int x, int n) &#123; /* Table of code pointers */ static void *jt[7] = &#123; &amp;&amp;loc_A, &amp;&amp;loc_def, &amp;&amp;loc_B, &amp;&amp;loc_C, &amp;&amp;loc_D, &amp;&amp;loc_def, &amp;&amp;loc_D &#125;; unsigned index = n - 100; int result; if (index &gt; 6) goto loc_def; /* Multiway branch */ goto *jt[index]; loc_def: /* Default case*/ result = 0; goto done; loc_C: /* Case 103 */ result = x; goto rest; loc_A: /* Case 100 */ result = x * 13; goto done; loc_B: /* Case 102 */ result = x + 10; /* Fall through */ rest: /* Finish case 103 */ result += 11; goto done; loc_D: /* Cases 104, 106 */ result = x * x; /* Fall through */ done: return result;&#125; 汇编代码如下： 跳转表的步长是4 .rodata的意思是：read only data 过程调用 有以下几个要点： 栈是倒着长的 每个过程调用都有一个stack frame，程序帧 栈顶帧用两个指针来维护，一个是帧起址：%ebp，一个是栈指针：%esp指向栈顶。 %esp在过程运行的时候可能会被抹掉，这时候可以通过%ebp来定位。 可以看到返回地址在每一帧的最后。而每一帧的第一个位置存放着上一帧的帧起址%ebp。帧的中间则放置局部变量、过程参数等值。 有以下几种情况会将局部变量放到栈帧中： 局部变量多到寄存器放不下 局部变量是数组或者结构体，必须用到引用 局部变量使用了取址符&amp;，所以我们必须给它生成地址 转移控制 call指令的效果是：把返回地址push到栈中，然后跳到调用程序的地址（也就是把PC设置一下）。返回地址是汇编代码中call指令后面那条指令的地址。 ret指令把栈顶的返回地址pop出来，并跳转到这个地址。 寄存器使用传统%eax, %edx, %ecx是调用者保存寄存器。也就是说当过程Q被过程P调用，过程Q可以随意的写这三个寄存器，因为在调用Q之前P必须保存这三个寄存器的值。 %ebx, %esi, %edi是被调用者保存寄存器。也就是说在过程Q写这些寄存器之前，必须保存里面的值，并在return之前恢复原样。 过程调用例子12345678910111213141516171819int swap_add(int *xp, int *yp)&#123; int x = *xp; int y = *yp; *xp = y; *yp = x; return x + y;&#125;int caller()&#123; int arg1 = 534; int arg2 = 1057; int sum = swap_add(&amp;arg1, &amp;arg2); int diff = arg1 - arg2; return sum * diff;&#125; 一些编程语言，比如Pascal，提供了值传参和引用传参。但C语言只有值传参，C++提供了引用传参。C语言可以通过指针来实现引用传参。 总共申请了24字节的空间，8字节用来存局部变量，8字节用来存参数，还有8字节未使用。 为什么要浪费8字节，原因是：内存对齐。GCC遵循一个x86编程方针：栈空间必须是16的整数倍，包括保存%ebp的4字节和返回地址的4字节。这里总共加起来是24字节，所以需要额外的8字节填充成32字节。 swap_add的汇编代码如下： 分为三个部分：setup、body、finish setup: 1234swap_add: pushl %ebp Save old %ebp movl %esp, %ebp Set %ebp as frame pointer pushl %ebx Save %ebx 首先要保存调用者的帧基指针，然后重新设置当前帧基指针，然后如果用到%ebx,%esi,%edi等寄存器就需要保存。 body: 1234567movl 8(%ebp), %edx Get xpmovl 12(%ebp), %ecx Get ypmovl (%edx), %ebx Get xmovl (%ecx), %eax Get ymovl %eax, (%edx) Store y at xpmovl %ebx, (%ecx) Store x at ypaddl %ebx, %eax Return value = x+y 获取参数，进行计算。 finish: 123popl %ebx Restore %ebxpopl %ebp Restore %ebpret Return 恢复两个寄存器，同时%esp回到了上一个帧的栈顶，指向了返回地址，然后ret指令就可以把PC置为返回地址了，这样就完成了控制权的转移。 然后执行调用完swap_add之后的代码： 12345movl -4(%ebp), %edxsubl -8(%ebp), %edximull %edx, %eaxleaveret leave指令的作用是重置栈指针和帧指针，也可以使用popl来重置，很简单： 12movl -4(%ebp), %esppopl %ebp 从这个例子我们可以看出，编译器遵循一组简单的惯例来管理栈结构。 通过%ebp加偏移量（+8,+12,…）访问参数 通过push指令或者栈指针减偏移量来分配栈空间 在返回前恢复保存好的寄存器，并使栈指针指向调用者的返回地址 数组、多维数组、结构体、联合体这些都比较简单，这里略过。 指针每种数据类型都有对应的指针类型，但指针类型不是机器码的一部分，只是C语言提供的一种抽象，帮助程序员避免犯错。 内存引用越界和缓冲区溢出我们可以看到C语言对数组引用没有任何边界检查，而且栈里面既保存了局部变量又保存了寄存器值以及返回地址。所以一旦数组越界写就会破坏整个程序的运行。 看下面这个例子： 1234567891011121314151617181920212223/* Sample implementation of library function gets() */char *gets(char *s)&#123; int c; char *dest = s; int gotchar = 0; /* Has at least one character been read? */ while ((c = getchar()) != '\n' &amp;&amp; c != EOF) &#123; *dest++ = c; /* No bounds checking! */ gotchar = 1; &#125; *dest++ = '\0'; /* Terminate string */ if (c == EOF &amp;&amp; !gotchar) return NULL; /* End of file or error */ return s;&#125;/* Read input line and write it back */void echo()&#123; char buf[8]; /* Way too small! */ gets(buf); puts(buf);&#125; 这段C语言代码对应的汇编代码如下： 分配数组空间的时候是直接固定了8字节，这里给buf分配的空间也是8字节：leal -12(%ebp), %ebx，并把buf作为参数放置于栈顶。 我们可以看到，当读写buf[8]的时候，实际上是在读写Saved %ebx。 通常给被攻击的程序输入一个字符串，这个字符串包含了可执行代码的字节编码，如果我们通过缓冲区溢出修改了返回地址，那么ret指令就可以跳转到我们攻击代码的位置。 蠕虫（worms）和病毒（viruses）的区别：相同点：都可以复制和传播自身，不同点：蠕虫可以自己运行，病毒是把自己加入到其他程序中，包括操作系统代码，病毒是不能独立运行的。 对抗缓冲区溢出攻击的方法栈随机化攻击者需要插入攻击代码（一个字符串），并知道攻击代码的位置（也就是字符串存放的栈地址），而且指向这段字符串的指针也是这个字符串的一部分。如果栈的位置是固定的，那么就很容易猜到攻击代码的存放位置。用如下代码可以检测栈的位置： 12345int main() &#123; int local; printf("local at %p\n", &amp;local); return 0;&#125; 只需要打印一个局部变量的地址。 栈随机化的思想是程序每次运行时栈的位置都不一样，实现方式是：程序开始时，在栈上分配一段0~n字节之间的随机大小的空间，例如使用alloca可以在栈上分配空间。程序不使用这段空间，它的作用是使后续栈的位置发生变化。分配的n必须足够大，这样才能有足够多的变化，但又必须足够小，这样才不会浪费空间。 栈随机化是更大一类技术的一种，这类技术称为：Address-Space Layout Randomization，ASLR，地址空间布局随机化。但攻击者还是可以采取一定措施来增加攻击成功率，一种常见的手段就是在攻击代码前中插入很长一段的nop指令，这个指令只会使程序计数器（PC）加一，除此之外没有任何副作用。只要攻击者能够猜中这段序列中的某个地址，就可以顺利到达攻击代码。这个序列的常用术语是：nop sled空操作雪橇。 栈破坏检测在局部缓冲区和栈状态之间插入一个随机的金丝雀值（也叫哨兵值），一旦发现这个值被改变，就说明缓冲区溢出了，那么就可以将程序异常中止。 攻击者只有输入局部缓冲区变量的权限，所以无从得知金丝雀值。 GCC默认就会插入金丝雀值，如果不想要可以使用参数：-fno-stack-protector来阻止GCC产生这种代码。当不使用此参数时，产生代码如下： 指令参数%gs20, %eax指明金丝雀值使用 segmented addressing（段寻址）从存储器中读入。将段标志为只读，这样攻击者就不能同时修改段中的金丝雀值。最后使用xorl比较段和栈中的金丝雀值，如果不相等则call __stack_chk_fail。 这种做法可以带来很小的性能损失。 限制可执行代码区域在典型的程序中，只有保存编译器产生的代码的那一部分存储空间才需要是可执行的。其他部分可以被限制为只允许读写。虚拟存储器空间在逻辑上分成了页（page），典型的每页是 2048 或者 4096 字节。由硬件提供存储器保护。以前，x86体系结构将读和执行访问控制合并成一个1位标志，所以任何被标记为可读的部分也是可执行的，当然也有很多机制可以限制一些页是可读的但是不可执行，然而这些机制都很消耗性能。最近，AMD（Advanced Micro Devices）为它的64位处理器的内存加入了 NX, No-eXecute，不可执行位，intel也跟进了，检查页是否可执行由硬件来完成，效率上没有任何损失。]]></content>
      <categories>
        <category>读书笔记</category>
        <category>《CSAPP》</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[浮点数原理]]></title>
    <url>%2Fblog%2F2018%2F09%2F27%2F%E6%B5%AE%E7%82%B9%E6%95%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[浮点数的作用：区别于整形数，用来表示小数。可以用来表示很大的数，或者非常接近0的小数，或者近似的做实数计算，浮点数的一般形式：$x\times 2^y$。 IEEE（pronounced “Eye-Triple-Eee”）浮点数标准。 rounding：when a number cannot be represented exactly in the format and hence must be adjusted upward or down- ward。可以翻译为：舍入。 十进制的小数表示：$d_m d_{m-1} \cdots d_1 d_0 . d_{-1} d_{-2} \cdots d_{-n}$，写成数学表达式： $$d = \sum_{i=-n}^m 10^i \times d_i$$ 相应的，二进制也可以写成这种形式： $$b = \sum_{i=-n}^m 2^i \times b_i$$ 浮点数的表示IEEE浮点数的格式：$V = (-1)^s \times M \times 2^E$ s是符号（Sign），s为0时是正，s为1时是负 M是有效数字（Significand，即 尾数） E是 指数，Exponent，也叫 幂数，阶码 隐含的 基数 是2 下图是浮点数的内存分布模型，首先是符号域，然后是指数域，最后是分数域： 符号位s个，符号位只需要一位，s=1 指数位k个，指数域 $exp=e_{k-1}\cdots e_1 e_0$，用来计算指数E 分数为n个，分数域 $frac=f_{n-1}\cdots f_1 f_0$，用来计算有效数字M 32位浮点数（单精度，float型）中，s=1，k=8，n=23；64位浮点数（双精度，double型）中，s=1，k=11，n=52。 正常化值（Normalized Values）当 $exp$ 域既不是全0，也不是全1的时候，就是正常化值。 $E = e - Bias$，其中 $e$ 就是 $exp$ 域：$e_{k-1}\cdots e_1e_0$ 的值（除去全0和全1之后，取值范围是1到$2^k-2$），$Bias=2^{k-1}-1$（单精度的时候是127，双精度的时候是1023），那么 $E$ 的取值范围，单精度的时候是：-126 ~ +127，双精度的时候是：-1022 ~ +1023，其实 $E$ 的算法就是 移码 的计算方法。 $M = 1+f$，$0\le f\lt 1$，内存里只记录f，而1作为一个前导值计算时候再加上，所以f是分数域 $frac$ 的 $0.f_{n-1}\cdots f_1f_0$ 这种形式 非正常化值（Denormalized Values）当指数域全0，就是非正常化格式。 在这种情况下，指数值是 $E = 1-Bias$，也就是固定了，有效数字值 $M = f$ 也就是没有前导1了。这个格式下可以表示0，因为正常化值中，一定有： $M\ge 1$，所以我们无法在正常化值格式下表示0。当符号位是0，有效数字 $M=f=0$，我们得到的就是+0.0，当符号位是1的时候就是-0.0。 除了可以表示0，这个格式的另一个作用就是用来表示非常接近0的数。 特殊值（Special Values）当指数域全1的时候，且分数域是全0，就表示无穷大，如果符号域为0，表示 $+\infty$，如果符号位是1，则表示 $-\infty$。无穷大可以作为溢出的结果，当我们用两个很大的数相乘，或者除以0； 当指数域全1，且分数域并非全0的时候，结果可以叫做：NaN（Not a Number的简写），这种值用来表示不能用实数或者无穷大表示的计算结果，比如计算：$\sqrt{-1}$ 或者 $\infty - \infty$。 下图是在数轴上的显示： 可以看到非正常化值集中在0附近，正常化值散布在整个数轴的空间，特殊值则只表示两个无穷值。 下图是浮点数三种类型的光滑衔接： 看完浮点数的设计和构造我们可以发现以下这些特点： 从编码上有效数字域采用了无符号整数编码，而指数域采用了移码编码 非正常化值均匀分布在0附近 正常化值的间隔随着 $2^E$ 变大而逐渐变大，也就是精度逐渐降低 精度是分组的，以 $2^E$ 增加1为一组，每组有 $2^n$ 个数（n是有效数字域的位数） 最高精度就是两个非正常化值的间隔，最低精度是最大的一组正常化值的相邻两数的间隔。 非正常化值按照精度只占一组，正常化值的数量是非正常化值数量的 $2^{k}-2$ 倍 正常化值的第一组的精度和非正常化值的精度一样，也就是实现了无缝衔接 浮点数的计算舍入 Rounding维基百科 各种Rounding合集图 浮点数中使用的是：舍入到最近的偶数，因为舍入结果放大和缩小各占50%的概率，这样就可以防止最终结果偏大或者偏小。 下面是把浮点数舍入到小数点后两位数： $10.00011_2(2\frac{3}{32})$ -&gt; $10.00_2(2)$ 不到一半，正常四舍五入$10.00110_2(2\frac{3}{16})$ -&gt; $10.01_2(2\frac{1}{4})$ 超过一半，正常四舍五入$10.11100_2(2\frac{7}{8})$ -&gt; $11.00_2(3)$ 正好一半，保证最后一位是偶数，所以向上舍入$10.10100_2(2\frac{5}{8})$ -&gt; $10.10_2(2\frac{1}{2})$ 正好一半，保证最后一位是偶数，所以向下舍入 浮点数加减运算基本性质 相加可能产生 infinity 或者 NaN 不满足交换律，不满足结合律（因为舍入会造成精度上的损失） 加上0等于原来的数 除了 infinity 和 NaN，每个元素都有对应的相反数 除了 infinity 和 NaN，满足单调性，即 $a\ge b \rightarrow a+c\ge b+c$ 1234567891011121314#include &lt;iostream&gt;using namespace std;int main()&#123; // 浮点数加法不满足交换律 cout &lt;&lt; 3.14 + 1e20 - 1e20 &lt;&lt; endl; cout &lt;&lt; 1e20 - 1e20 + 3.14 &lt;&lt; endl; // 浮点数加法不满足结合律 cout &lt;&lt; (3.14 + 1e20) - 1e20 &lt;&lt; endl; cout &lt;&lt; 3.14 + (1e20 - 1e20) &lt;&lt; endl; return 0;&#125; 运行结果: 123403.1403.14 具体细节设两个浮点数 $x$ 和 $y$： $$\begin{cases}x=(-1)^{s_x} M_x 2^{E_x} \y=(-1)^{s_y} M_y 2^{E_y}\end{cases}$$ 则浮点数加减运算结果为： $$x\pm y = \left((-1)^{s_x}M_x 2^{E_x-E_y} \pm (-1)^{s_y}M_y \right)2^{E_y}$$ 对阶：首先要把指数位（阶码）调成一样，并相应的使M移位，由于有效域左移会引起最高有效位丢失，误差大，所以采用右移，此时阶码要增加。所以对阶原则是：小阶向大阶看齐。 有效数加减：简单的无符号数字相加减。 规格化：有效数求和结果可能大于1，那么就向右规格化：尾数右移1位，阶码加1。 舍入：对于右移出去的位，采取舍入 检查阶码是否溢出： 阶码下溢：运算结果为非规格化数 阶码上溢：置溢出标志 浮点数加减实例$x=3.14, y=2.718$ 求 $z=x+y$。 首先算出 $x$ 和 $y$ 的内存表示： $x = 3+0.14$，3的二进制表示是11，0.14的二进制要稍微计算一下，我们让0.14不断的乘以2（也就是左移），得到的整数位部分就是其二进制值的一位： 12345670.14 * 2 = 0.28 00.28 * 2 = 0.56 00.56 * 2 = 1.12 10.12 * 2 = 0.24 0... 我们可以写个程序来完成这个计算工作： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;using namespace std;// 获取整形数的位数int getDigits(int num)&#123; int count = 1; while(num/10&gt;0)&#123; num %= 10; count++; &#125; return count;&#125;/** * 获取小数的二进制表示 * @params precision 二进制表示精确到多少位 * @params num 小数的整数表示 */char* getFloatBitset(int precision, int num)&#123; char* res = new char[precision]; int digits = getDigits(num); int mod = pow(10, digits); char printFormat[50]; sprintf(printFormat,"%%0.%df",2); // cout &lt;&lt; printFormat &lt;&lt;endl; for(int i=0;i&lt;precision;i++)&#123; printf(printFormat, num*1.0/mod); cout &lt;&lt; " * 2 = "; num &lt;&lt;= 1; if(num &gt;= mod)&#123; printf(printFormat, num*1.0/mod); cout &lt;&lt; " 1" &lt;&lt; endl; num %= mod; res[i] = '1'; &#125;else&#123; printf(printFormat, num*1.0/mod); cout &lt;&lt; " 0" &lt;&lt; endl; res[i] = '0'; &#125; &#125; return res;&#125;/** * 获取小数的二进制表示 * @params precision 二进制表示精确到多少位 * @params num 浮点型小数 * @params digits 输入的时候浮点型小数的位数 */char* getFloatBitset2(int precision, float num, int digits)&#123; char* res = new char[precision]; int mod = pow(10,digits); // cout&lt;&lt;mod&lt;&lt;endl; char printFormat[50]; sprintf(printFormat,"%%0.%df",2); for(int i=0;i&lt;precision;i++)&#123; printf(printFormat, num); cout &lt;&lt; " * 2 = "; num*=2; num = round(num*mod)/mod; if(num &gt;= 1)&#123; printf(printFormat, num); cout &lt;&lt; " 1" &lt;&lt; endl; num -= 1; res[i] = '1'; &#125;else&#123; printf(printFormat, num); cout &lt;&lt; " 0" &lt;&lt; endl; res[i] = '0'; &#125; &#125; return res;&#125;int main(int argc, char* argv[])&#123; // char* res = getFloatBitset(atoi(argv[1]), atoi(argv[2])); char* res = getFloatBitset2(atoi(argv[1]), atof(argv[2]), atoi(argv[3])); cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; 上面代码保存成：float2Bitset.cpp文件，然后编译，并使用： 12$ g++ -o float2Bitset float2Bitset.cpp$ ./float2Bitset 23 0.14 2 小数位精确到23位的话，3.14的定点浮点数表示是：11.00100011110101110000101。 转成浮点数，首先规格化M，那么整体要右移1位，指数是1，由 $E = e-Bias$，$E=1$, $Bias=127$ 得 $e=128$，也就是：1000 0000。 最终3.14的内存表示是：$$\underbrace{0}_{Sign}~\underbrace{10000000}_{Exponent}~~\underbrace{10010001111010111000011}_{Significand}$$ 同样的方法得到2.718的内存表示： $$\underbrace{0}_{Sign}~\underbrace{10000000}_{Exponent}~~\underbrace{01011011111001110110110}_{Significand}$$ 这两个数恰好是同阶的，那么就不需要对阶操作了。将M相加，但这个数太长了看着眼花，我们写个加法程序： 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;// 将两个相同位数的二进制数相加char* addBitset(char num1[], char num2[], int length)&#123; char* res = new char[length+2]; res[length+1] = '\0'; int carry = 0; for(int i=length-1;i&gt;=0;i--)&#123; res[i+1] = num1[i]-'0'+num2[i]-'0'+carry+'0'; carry = 0; if(res[i+1]&gt;'1')&#123; res[i+1] -= 2; carry = 1; &#125; &#125; if(carry)&#123; res[0]='1'; &#125;else&#123; res[0]='0'; &#125; return res;&#125;int main(int argc, char* argv[])&#123; int i=0; while(argv[1][i]!='\0')&#123; i++; &#125; cout &lt;&lt; i &lt;&lt;endl; char* res = addBitset(argv[1], argv[2], i); cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; 上述代码保存成：addBitset.cpp，编译并使用该程序： 12$ g++ -o addBitset addBitset.cpp$ ./addBitset 10010001111010111000011 01011011111001110110110 相加结果等于：0 11101101110100101111001，最高位没有产生进位，这里用了一个0来代替，但两个前导1相加产生了进位，所以还需要对M右归一下，再对指数加1。所以加法结果的浮点数表示是： $$\underbrace{0}_{Sign}~\underbrace{10000001}_{Exponent}~~\underbrace{01110110111010010111101}_{Significand}$$ 这个数的十进制表示的计算方法是：$$2^2 \times (1+0\times (\frac{1}{2})^1 + 1\times (\frac{1}{2})^2 + 1\times (\frac{1}{2})^3 +1\times (\frac{1}{2})^4+0\times(\frac{1}{2})^5+\cdots)$$ 我们依然采用程序来计算这一长串二进制对应的十进制小数： 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;cmath&gt;using namespace std;double bitset2Float(char* num1, int length)&#123; double res = 0.0; int count=1; for(int i=0;i&lt;length;i++)&#123; double temp = (num1[i]-'0')/pow(2,count); // cout &lt;&lt; temp &lt;&lt; endl; res += temp; count++; &#125; return res;&#125;int main(int argc, char* argv[])&#123; int i=0; while(argv[1][i]!='\0')&#123; i++; &#125; double res = bitset2Float(argv[1],i); cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; 上述代码保存为：Bitset2float.cpp，编译并执行： 12$ g++ -o Bitset2float Bitset2float.cpp$ ./Bitset2float 01110110111010010111101 对得到结果：0.4645，$1.4645\times 2^2 = 5.858$，而 $3.14+2.718=5.858$，这就说明我们的计算无误。 算法流程图 这个流程图并不是完美的，真实的浮点数流程图和浮点数计算电路比这个复杂。另外我忘画了一个东西，这个图最后应该加上溢出处理模块，E可能会上溢（当E加1的时候），也可能会下溢（当E减1的时候）。 最后这个流程图中没有对特殊值的判断，比如：$\infty - \infty = NaN$, $\infty + \infty = \infty$, $NaN + 任何数 = NaN$。 了解了浮点数加法的流程之后，最后我们回到最上面说的 浮点数加减法不满足交换律和结合律，从计算细节分析为什么不行。 首先 3.14 的浮点数表示我们已经计算过了，那么 1e20 的浮点数是多少呢？1e20也就是 $10^{20}$，用辗转相除法可以得到其二进制表示。我们这里使用计算器工具 很遗憾的是64bit只能摆的下 $10^{19}$。我试了一下把源程序中的 1e20 换成 1e19 也是同样的结果。所以我们就使用 1e19 来分析这道题。 首先是M规格化，M右移63位，E加63，舍入M，那么 1e19 最终的双精度浮点数表示是：0 10000111110 0001010110001110010001100000100100010011110100000000 小阶向大阶看齐，3.14的阶是1，M需要右移62位，而M的精度才52，可想而知M就是0了。那么 3.14 + 1e19 的结果就是 1e19。1e20就更加不用说了。 浮点数乘除基本性质 相乘可能产生 infinity 或者 NaN 不满足交换律，结合律，分配率（因为溢出会造成程序无法计算出正确的结果） 乘以1会等于原来的数 除了 infinity 和 NaN，满足单调性：$a\ge b \rightarrow a\times c \ge b \times c$ 具体细节设两个浮点数 $x$ 和 $y$ ： $$\begin{cases}x = \pm M_x 2^{E_x} \y = \pm M_y 2^{E_y}\end{cases}$$ 则浮点数乘除运算结果是： $$xy = \pm (M_x\times M_y)2^{E_x\pm E_y}$$ 计算阶码，判断是否溢出 求有效数的乘积 有效数舍入 计算符号位 浮点数还有相当多的细节，可以参考：IEEE 754]]></content>
      <categories>
        <category>读书笔记</category>
        <category>《Computer Systems:A Programmer&#39;s Perspective》</category>
      </categories>
      <tags>
        <tag>信息记法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wsl oh my zsh 字符乱码问题]]></title>
    <url>%2Fblog%2F2018%2F09%2F20%2Fwsl%20oh%20my%20zsh%20%E5%AD%97%E4%BD%93%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[安装 oh my zsh首先检查自己有没有zsh： 1cat /etc/shells 如果有的话就下载oh my zsh 设置默认shell1chsh -s /bin/zsh 有可能会遇到设置不成功的问题，那么我们可以手动修改/etc/passwd，找到自己那一条配置信息，把默认shell改成/bin/zsh就OK了。 字体问题-&gt;等一些其他字符可能显示不出来，这是字体导致的。google一下：wsl oh my zsh font，找到：https://github.com/Microsoft/WSL/issues/1517，下载并设置字体为：DejaVuSansMono。 怎么设置字体右键标题栏，进入属性]]></content>
      <categories>
        <category>解决的问题</category>
      </categories>
      <tags>
        <tag>windows环境</tag>
        <tag>wsl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wsl修改右键bash图标]]></title>
    <url>%2Fblog%2F2018%2F09%2F19%2Fwsl%E4%BF%AE%E6%94%B9%E5%8F%B3%E9%94%AEbash%E5%9B%BE%E6%A0%87%2F</url>
    <content type="text"><![CDATA[使用 windows subsystem for linux (简称：WSL) 的时候，遇到一个小问题，在文件管理器中右键，唤出bash，发现图标不对： 点击之后可以看到调用的是哪个程序： google一下：windows 右键图标，搜到百度经验：https://jingyan.baidu.com/article/7c6fb428321b4a80642c90fd.html，照着修改就行了。 如图： 那么改成什么呢？google一下：wsl bash icon，搜到：https://github.com/Microsoft/WSL/issues/1269，然后又在这个页面找到了这个：https://github.com/cmderdev/cmder/issues/1063#issuecomment-401947209 把icon换成： 1C:\Program Files\WindowsApps\CanonicalGroupLimited.UbuntuonWindows_1804.2018.817.0_x64__79rhkp1fndgsc\ubuntu.exe 再点击右键，就能看到这个图标了。 除了修改右键显示的icon，还可以修改右键显示的名字，以及运行的目标程序。 改为： 1C:\Program Files\WindowsApps\CanonicalGroupLimited.UbuntuonWindows_1804.2018.817.0_x64__79rhkp1fndgsc\ubuntu.exe 但发现无法把工作目录定到当前右键的目录，需要加一个run： 1C:\Program Files\WindowsApps\CanonicalGroupLimited.UbuntuonWindows_1804.2018.817.0_x64__79rhkp1fndgsc\ubuntu.exe run]]></content>
      <categories>
        <category>解决的问题</category>
      </categories>
      <tags>
        <tag>windows环境</tag>
        <tag>wsl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《代码整洁之道》读书笔记--第2章:有意义的命名]]></title>
    <url>%2Fblog%2F2018%2F06%2F10%2F%E3%80%8A%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC2%E7%AB%A0-%E6%9C%89%E6%84%8F%E4%B9%89%E7%9A%84%E5%91%BD%E5%90%8D%2F</url>
    <content type="text"><![CDATA[我们写代码的时候需要不停的命名，项目、类、函数、变量 等等都要命名。而命名关乎程序的可读性，而程序的可读性又至关重要（代码是写给人看的）。 名副其实一个很重要的原则是：如果命名需要注释来补充，那就不算名副其实。 举个例子： 1int d; //消逝的时间，以日计 名称d什么也没说，如果其他很多地方要用到这个变量那就十分糟糕了，因为用的人不一定想的起来d是什么意思（如果只是局部变量局部使用，那它的罪孽会轻一点，如果是全局变量或者类的成员变量那这简直就是大坑）。其实我们很容易发现，注释没法像好的命名一样方便，因为我们不会在写代码的时候看到一个不懂的命名就去找它的定义处的注释，这样会浪费很多时间。另外如果写成注释就还需要维护注释，如果注释和代码不一致的情况那就变成了一种误导。。所以好的命名就应该能自己说明自己是什么。 好的命名如下： 1234int elapsedTimeInDays;int daysSinceCreation;int daysSinceModification;int fileAgeInDays; 下面我们看一段代码： 123456789public List&lt;int[]&gt; getThem() &#123; List&lt;int[]&gt; list1 = new ArrayList&lt;int[]&gt;(); for (int[] x : theList)&#123; if (x[0] == 4)&#123; list1.add(x); &#125; &#125; return list1;&#125; 这段代码很糟糕，虽然里面没有复杂的表达式，空格和缩进中规中矩，只用到三个变量和两个常量，甚至没涉及到其他类或多态方法。但这段代码很难说清它在做什么。问题不在于代码的简洁度，而在于代码的 模糊度：即上下文在代码中未被明确体现的程度。比如随便提几个问题： theList 是什么类型的东西？ theList 零下标条目的意义是什么？ 值4的意义是什么？ 我们怎么使用返回的list1？ 问题的答案没体现在代码段中，可那就是它们该在的地方！如果不是对上下文及其熟悉，我们根本无法知道这代码在做什么！ 比方说，我们在开发一种扫雷游戏，我们发现，盘面是名为 theList 的单元格列表，那就将其命名为：gameBoard。盘面上每个单元格都用一个简单数组表示。我们还发现，零下标条目是一种状态值，而这种状态值为4表示“已标记”。我们将代码修改如下： 123456789public List&lt;int[]&gt; getFlaggedCells() &#123; List&lt;int[]&gt; flaggedCells = new ArrayList&lt;int[]&gt;(); for (int[] cell : gameBoard)&#123; if (cell[STATE_VALUE] == FLAGGED)&#123; flaggedCells.add(cell); &#125; &#125; return flaggedCells;&#125; 这下这段代码是什么功能，做了些什么工作简直一目了然。还可以进一步，不用int数组表示单元格，而是另写一个类。该类包括一个名副其实的函数（称为 isFlagged），从而掩盖住那个魔术数。 魔术数，magic number：指使用不明其意的立即数，至少我们应该用一个常量来对这种立即数进行命名，赋予其意义。 123456789public List&lt;Cell&gt; getFlaggedCells() &#123; List&lt;Cell&gt; flaggedCells = new ArrayList&lt;&gt;(); for (Cell cell : gameBoard)&#123; if (cell.isFlagged())&#123; flaggedCells.add(cell); &#125; &#125; return flaggedCells;&#125; 从int数组到Cell类，抽象程度又提高了，代码可重用性也就提高了。 避免误导例如，hp、aix 和 sco 都不应该用作变量名，因为它们都是UNIX平台或类UNIX平台的专有名称。别用accountList来指称一组账号，除非它们真的是List类型，List一词对程序员来说有特殊的意义，如果包纳账号的容器并非是一个List，就会引起错误的判断（即便容器就是个List，最好也别在名称中写出容器的类型）。所以，用accountGroup或bunchOfAccounts，甚至直接用accounts都会好一些。 提防使用不同之处较小的命名。想区分模块中某处的XYZControllerForEfficientHandlingOfStrings 和另一处的 XYZControllerForEfficentStorageOfStrings，会花多长时间呢？这两个词外形实在太相似了。我们很享受线代Java编程环境的自动代码完成特性，键入某个名称的前几个字母，就可以得到一列该名称的可能性，假如相似的名字依字母顺序放在一起，且差异很明显，那就会相当有助益。 在某些字体里，1和l，0和O很难分清。要注意这种混淆。 做有意义的区分如果程序员只是为满足编译器或解释器的需要而写代码，就会制造麻烦。例如，因为同一作用域内不能重名，你可能随手改掉其中一个命名，有时候干脆以错误的拼写充数，结果就是有人一不小心更正拼写错误，然后导致编译器出错。 例如class已经是关键字，就给变量命名为klass，clazz，还有this，命名成thiz。 以数字系列命名（a1, a2, …, aN）是以意义命名的对立面。试看： 12345public static void copyChars(char a1[], char a2[])&#123; for (int i=0;i&lt;a1.length;i++)&#123; a2[i] = a1[i]; &#125;&#125; 如果参数名改为 source 和 destination，这个函数就会像样许多。 废话是另一种没意义的区分。假设你有一个 Product 类。如果还有一个 ProductInfo 或 ProductData 类，那它们的名称虽然不同，意思却并无区别。Info和Data就像a、an和the一样是意义含混的废话。注意，只要体现出有意义的区分，使用a和the这样的前缀就没错。例如，你可能把a用在域内变量，而把the用于函数参数。但如果你已经有一个名为zork的变量，又想调用一个名为theZork的变量，麻烦就来了。 废话都是冗余。Variable一词永远不应当出现在变量名中。Table一词永远不应当出现在表名中。NameString会比Name好吗？难倒Name会是一个浮点数不成？如果是这样，就触犯了关于误导的规则。设想有个名为Customer的类，还有一个名为CustomerObject的类。区别何在呢？哪个是表示客户历史支付情况的最佳途径？ 举个例子： 123getActiveAccount();getActiveAccounts();getActiveAccountInfo(); 程序员怎么知道该调用哪个函数呢？ 如果缺少明确约定，变量moneyAmount就与money没区别，customerInfo与custmoer没区别，accountData与account没区别，theMessage也与message没区别。要区分名称，就要以读者能鉴别不同之处的方式来区分。 使用读的出来的名称人类长于记忆和使用单词，若不善加利用，实在是种耻辱。 如果名称读不出来，讨论的时候会像个傻鸟。“哎，这儿，鼻涕阿三喜摁踢（bee cee arr three cee enn tee， BCR3CNT的读音）上头，有个皮挨死极翘（pee ess zee kyew）整数，看见没？” 这不是小事，因为编程本就是一种社会活动。 有家公司，程序里面写了个 genymdhms（生成日期，年、月、日、时、分、秒），他们一般读作：“gen why emm dee aich emm ess”，YMDHMS的读音。我有个见字照读的恶习，于是开口就念“gen-yah-mudda-hims”。后来好些设计师和分析师都有样学样，听起来傻乎乎。我们知道典故，所以觉得很搞笑。搞笑归搞笑，实际是在强忍糟糕的命名。在给新开发者解释变量的意义时，他们总是读出傻乎乎的自造词，而非恰当的英语词。比较： 123456class DtaRcrd102 &#123; private Date genymdhms; private Date modymdhms; private final String pszqint = "102"; /* ... */&#125; 123456class Customer &#123; private Date generationTimestamp; private Date modificationTimestamp; private final String recordId = "102"; /* ... */&#125; 现在读起来就像人话了：“喂，Mikey，看看这条记录！生成时间戳（generation timestamp）被设置为明天了！不能这样吧？” 使用可搜索的名称单字母名称和数字常量有个问题，就是很难在一大篇文字中找出来。 避免使用编码编码已经太多，无谓再自找麻烦。把类型或作用域编进名称里面，徒然增加了解码的负担。没理由要求每位新人都在弄清要应付的编码之外（那算是正常的），还要再搞懂另一套编码“语言”。这对于解决问题而言，纯属多余的负担。带编码的名称通常也不便发音，容易打错。 匈牙利命名法在往昔名称长短很要命的时代，我们毫无必要的破坏了不编码的规矩，如今后悔不迭。Fortran语言要求首字母体现出类型，导致了编码的产生。BASIC早期版本只允许使用一个字母再加一位数字。匈牙利命名法（Hungarian Notation，HN）将这种态势愈演愈烈。 在Windows的C语言API的时代，HN相当重要，那时所有名称要么是个整数句柄，要么是个长指针或者void指针，要不然就是string的几种实现（有不同的用途和属性）之一。那时候编译器并不做类型检查，程序员需要匈牙利命名法来帮助自己记住类型。 现代编程语言具有更丰富的类型系统，编译器也记得并强制使用类型。而且，人们趋向于使用更小的类、更短的方法，好让每个变量的定义都在视野范围内。 Java程序员不需要类型编码。对象是强类型的，代码编辑环境已经先进到在编译开始前就侦测到类型错误的程度！所以，如今HN和其他类型编码形式都纯属多余。它们增加了修改变量、函数或类的名称或类型的难度。它们增加了阅读代码的难度。它们制造了让编码系统误导读者的可能性。 1PhoneNumber phoneString; // 类型变化时，名称并不会自动变化，若名称中编码了类型，还要我们手动去改。 成员前缀也不必用m_前缀来标明成员变量。应当把类和函数做得足够小，消除对成员前缀的需要。你应当使用某种可以高亮或用颜色标出成员的编辑环境。 123456public class Part &#123; private String m_dsc; // The textual description void setName(String name) &#123; m_dsc = name; &#125;&#125; 123456public class Part&#123; String description; void setDescription(String description) &#123; this.description = description; &#125;&#125; 此外，人们会很快就学会无视前缀（或后缀），只看到名称中有意义的部分。代码读的越多，眼中就越没有前缀。最终，前缀变作了不入法眼的废料，变作了旧代码的标志物。 接口和实现有时也会出现采用编码的特殊情形。比如，你在做一个创建形态用的抽象工厂（Abstract Factory）。该工厂是个接口，要用具体类来实现。你怎么 命名工厂和具体类呢？IShapeFactory和ShapeFactory吗？我喜欢不加修饰的接口。前导字母I被滥用到了说好听点是干扰，说难听点根本就是废话的程度。我不想让用户知道我给他们的是接口。我就想让他们知道那是个ShapeFactory。如果接口和实现必须选一个来编码的话，我宁肯选择实现。ShapeFactoryImp，甚至是丑陋的CShapeFactory，都比对接口名称编码来得好。 避免思维映射不应当让读者在脑海中把你的名称翻译为他们熟知的名称。这种问题经常出现在选择是使用问题领域术语还是解决方案领域术语时。 单字母变量名就是个问题。在作用域较小，也没有名称冲突时，循环计数器自然有可能被命名为i或j或k（但千万别用字母l）。这是因为传统上惯用单字母名称做循环计数器。然而，在多数其他情况下，单字母名称不是个好选择，读者必须在脑海中将它映射为真实概念。仅仅是因为有了a和b，就要取名为c，实在并非像样的理由。 程序员通常都是聪明人。聪明人有时会借脑筋急转弯炫耀其聪明。总而言之，假使你记得r代表不包含主机和图式（scheme）的小写字母版url的话，那你真是太聪明了。 聪明程序员和专业程序员之间的区别在于，专业程序员了解，明确是王道。专业程序员善用其能，编写其他人能理解的代码。 类名类名和对象名应该是名词或名词短语，如Customer、WikiPage、Account和AddressParser。避免使用Manager、Processor、Data或Info这样的类名。类名不应当是动词。 这里没看懂，举的例子并不是动词啊 方法名方法名应当是动词或动词短语，如 postPayment、deletePage或save。属性访问器、修改器和断言应该根据其值命名，并依Javabean标准加上get、set和is前缀。 123String name = employee.getName();customer.setName("mike");if(paycheck.isPosted())... 重载构造器时，使用描述了参数的静态工厂方法名。例如： 1Complex fulcrumPoint = Complex.FromRealNumber(23.0); 通常好于 1Complex fulcrumPoint = new Complex(23.0); 可以考虑将相应的构造器设置为private，强制使用这种命名手段。 别扮可爱如果名称太耍宝，那就只有同作者一般有幽默感的人才能记得住，而且还是在他们记得那个笑话的时候才行。谁会知道名为HolyHandGrenade的函数是用来做什么的呢？没错，这名字挺伶俐，不过DeleteItems或许是更好的名称。宁可明确，毋为好玩。 扮可爱的做法在代码中经常体现为使用俗语或俚语。例如，别用whack()来表示kill()。别用eatMyShorts()这类与文化紧密相关的笑话来表示abort()。 每个概念对应一个词给每个抽象概念选一个词，并且一以贯之。例如，使用fetch、retrieve和get来给在多个类中的同种方法命名。你怎么记得住哪个类中是哪个方法呢？ Eclipse和Intellj之类的线代编程环境提供了与环境相关的线索，比如某个对象能调用的方法列表。不过要注意，列表中通常不会给出你为函数名和参数列表编写的注释。如果参数名称来自函数声明，你就太幸运了。函数名称应当独一无二，而且要保持一致，这样你才能不借助多余的浏览就能找到正确的方法。 同样，在同一堆代码中有controller，又有manager，还有driver，就会令人困惑。DeviceManager和Protocal-Controller之间有何根本区别？为什么不全用controllers或managers？他们都是Drivers吗？这种名称，让人觉得这两个对象是不同类型的，也分属不同的类。 对于那些会用到你代码的程序员，一以贯之的命名法简直就是天降福音。 别用双关语避免将同一个单词用于不同目的。如果遵循“一词一意”的规则，可能在好多类里面都会有add方法。只要这些add方法的参数列表和返回值在语义上等价，就一切顺利。 但是，可能会有人决定为“保持一致”而使用add这个词来命名，即便并非真的想表示这种意思。比如，在多个类种都有add方法，该方法通过增加或连接两个现存值来获得新值。假设要写个新类，该类中有一个方法，把单个参数放到群集（collection）中。该把这个方法叫做add吗？这样做貌似和其他add方法保持了一致，但实际上语义却不同，应该用insert或append之类的词来命名才对。把该方法命名为add，就是双关语了。 使用解决方案领域的名称记住，只有程序员才会读你的代码。所以，尽管用那些计算机科学（Computer Science, CS）术语、算法名、模式名、数学术语吧。 对于熟悉访问者（VISITOR）模式的程序来说，名称AccountVisitor富有意义。那个程序员会不知道JobQueue的意思呢？ 使用源自所涉及问题领域的名称如果不能用程序员熟悉的术语来给手头的工作命名，就采用从所涉及领域而来的名称吧。至少，负责维护代码的程序员就能去请教领域专家了。 添加有意义的语境很少有名称是能自我说明的–多数都不能。反之，你需要用有良好命名的类、函数或名称空间来放置名称，给读者提供语境。如果没这么做，给名称添加前缀就是最后一招了。 设想你有名为firstName、lastName、street、houseNumber、city\state和zipcode的变量。当它们搁一块儿的时候，很明确是构成了一个地址。不过，假使只是在某个方法中看见孤零零的一个state变量呢？你会理所当然推断那是某个地址的一部分吗？ 可以添加前缀addrFirstName、addrLastName、addrState等，以此提供语境。至少，读者会明白这些变量都是某个更大结构的一部分。当然，更好的方案是创建名为Address的类。这样，即便是编译器也会知道这些变量隶属某个更大的概念了。 看一个例子： 语境不明确的变量： 123456789101112131415161718192021private void printGuessStatistics(char candidate, int count)&#123; String number; String verb; String pluralModifier; if(count==0)&#123; number="no"; verb="are"; pluralModifier="s"; &#125;else if(count==1)&#123; number="1"; verb="is"; pluralModifier=""; &#125;else&#123; number=Integer.toString(count); verb="are"; pluralModifier="s"; &#125; String guessMessage = String.format( "There %s %s %s%s", verb, number, candidate, pluralModifier); print(guessMessage);&#125; 上列函数有点过长，变量的使用贯穿始终。要分解这个函数，需要创建一个名为GuessStatisticsMessage的类，把三个变量做成该类的成员字段。这样它们就在定义上变作了GuessStatisticsMessage的一部分。语境的增强也让算法能够通过分解为更小的函数而变得更为干净利落。 有语境的变量： 123456789101112131415161718192021222324252627282930313233343536373839public class GuessStatisticsMessage &#123; private String number; private String verb; private String pluralModifier; public String make(char candidate, int count)&#123; createPluralDependentMessageParts(count); return String.format( "There %s %s %s%s", verb, number, candidate, pluralModifier); &#125; private void createPluralDependentMessageParts(int count)&#123; if(count==0)&#123; thereAreNoLetters(); &#125;else if (count==1)&#123; thereIsOneLetter(); &#125;else&#123; thereAreManyLetters(count); &#125; &#125; private void thereAreManyLetters(int count)&#123; number = Integer.toString(count); verb = "are"; pluralModifier="s"; &#125; private void thereIsOneLetters()&#123; number="1"; verb = "is"; pluralModifier = ""; &#125; private void thereAreNoLetters()&#123; number = "no"; verb = "are"; pluralModifier = "s"; &#125;&#125; 不要添加没用的语境设若有一个名为“加油站豪华版”（Gas Station Deluxe）的应用，在其中给每个类添加GSD前缀就不是什么好点子。说白了，你是在和自己在用的工具过不去。输入G，按下自动完成键，结果会得到系统中全部类的列表，列表恨不得有一英里那么长。这样做聪明吗？为什么要搞得IDE没法帮助你？ 再比如，你在GSD应用程序中的记账模块创建了一个表示邮件地址的类，然后给该类命名为GSDAccountAddress。稍后，你的客户联络应用中需要用到邮件地址，你会用GSDAccountAddress吗？这名字听起来没问题吗？在这17个字母里面，有10个字母纯属多余，与当前语境毫无关联。 只要短名称足够清楚，就要比长名称好。别给名称添加不必要的语境。 对于Address类的实体来说，accountAddress和customerAddress都是不错的名称，不过用在类名上就不太好了。Address是个好类名。如果需要与MAC地址、端口地址和Web地址相区别，我会考虑使用PostalAddress、MAC和URI。这样的名称更为精确，而精确正是命名的要点。]]></content>
      <categories>
        <category>读书笔记</category>
        <category>《代码整洁之道》</category>
      </categories>
      <tags>
        <tag>代码规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[APUE-3rd 读书笔记 -- File I/O]]></title>
    <url>%2Fblog%2F2018%2F05%2F28%2FAPUE-3rd-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--File-IO%2F</url>
    <content type="text"><![CDATA[前言这章讲的是文件IO，其中有几个非常重要的概念： File Desriptors，文件描述符 current file offset，当前文件偏移量 File Sharing Data Structure，文件共享数据模型 file descriptor flags ，文件描述位 file status flags ，文件状态位 File Descriptors 对内核来说，所有 打开的文件 都使用file descriptor引用。 文件描述符是一个非负整数。当我们打开一个存在的文件或者创建一个新文件，内核返回一个文件描述符给进程。 当我们想要读或者写一个文件，我们通过文件描述符来确定这个文件，文件描述符是被open或者creat返回的，然后作为read或者write的一个参数。 文件描述符都使用尽可能小的非负整数，File descriptors range from 0 through OPEN_MAX−1. 有三个magic number，0代表STDIN_FILENO，1代表STDOUT_FILENO，2代表STDERR_FILENO。虽然这已经是POSIX.1所定义的标准，但为了程序的可读性，还是不建议直接写数字。这三个常量定义在&lt;unistd.h&gt;中。 open and openat FunctionsA file is opened or created by calling either the open function or the openat function. 1234#include &lt;fcntl.h&gt;int open(const char *path, int oflag, ... /* mode_t mode */ );int openat(int fd, const char *path, int oflag, ... /* mode_t mode */ );// Both return: file descriptor if OK, −1 on error 最后一个参数是...，这是ISO C定义剩下的多个参数的方式。对这些函数来说，只有当新文件被创建时，最后一个参数才被使用，后面我们会讲。在这个原型中我们把这个参数写作一个注释。 path这个参数是要打开或者要创建的文件的名字。这个函数有多种操作，定在在oflag参数里。这个参数由下列一个或者多个定义在&lt;fcntl.h&gt;头文件中的常量通过 或(一种逻辑操作) 操作构成： O_RDONLY Open for reading only O_WRONLY Open for writing only O_RDWR Open for reading and writing Most implementations define O_RDONLY as 0, O_WRONLY as 1, and O_RDWR as 2, for compatibility with older programs. 为了兼容老程序，许多实现定义O_RDONLY as 0, O_WRONLY as 1, and O_RDWR as 2。 O_EXEC Open for execute only O_SEARCH Open for search only(applies to directories) The purpose of the O_SEARCH constant is to evaluate search permissions at the time a directory is opened. Further operations using the directory’s file descriptor will not reevaluate permission to search the directory. None of the versions of the operating systems covered in this book support O_SEARCH yet. One and only one of the previous five constants must be specified. The following constants are optional: 上面的五个常量有且只有一个必须被明确。接下来的是可选常量： O_APPEND Append to the end of file on each write. We describe this option in detail in Section 3.11. O_CLOEXEC Set the FD_CLOEXEC file descriptor flag. We discuss file descriptor flags in Section 3.14. O_CREAT Create the file if it doesn’t exist. This option requires a third argument to the open function (a fourth argument to the openat function) — the mode, which specifies the access permission bits of the new file. (When we describe a file’s access permission bits in Section 4.5, we’ll see how to specify the mode and how it can be modified by the umask value of a process.) 创建一个文件，如果不存在。这个操作需要open函数的第三个参数（openat函数的第四个参数）— mode，它明确了这个新文件的访问权限位。（当我们在第4.5章节讨论文件的访问权限位，我们将看到如何明确mode，以及它如何修改进程的umask值。） O_DIRECTORY Generate an error if path doesn’t refer to a directory. O_EXCL Generate an error if O_CREAT is also specified and the file already exists. This test for whether the file already exists and the creation of the file if it doesn’t exist is an atomic operation. We describe atomic operations in more detail in Section 3.11. 如果O_CREAT被使用了且文件已经存在就会生成一个错误。这个常量的作用是检测文件是否存在如果文件不存在就创建，这是一个原子操作。我们将在第3.11章节讨论更多原子操作的细节。 O_NOCTTY If path refers to a terminal device, do not allocate the device as the controlling terminal for this process. We talk about controlling terminals in Section 9.6. 如果这个路径指向的是终端设备，则不将这个设备分配为此进程的控制终端。 O_NONBLOCK If path refers to a FIFO, a block special file, or a character special file, this option sets the nonblocking mode for both the opening of the file and subsequent I/O. We describe this mode in Section 14.2. 如果path指向FIFO（先进先出），一个块特殊文件，一个字符特殊文件，这个选项设置了非阻塞模式为本次的打开操作和后续的I/O操作。 In earlier releases of System V, the O_NDELAY (no delay) flag was introduced. This option is similar to the O_NONBLOCK (nonblocking) option, but an ambiguity was introduced in the return value from a read operation. The no-delay option causes a read operation to return 0 if there is no data to be read from a pipe, FIFO, or device, but this conflicts with a return value of 0, indicating an end of file. SVR4-based systems still support the no-delay option, with the old semantics, but new applications should use the nonblocking option instead. 在早期的System V，有一个O_NDELAY(no delay)符号。这个符号和O_NONBLOCK(nonblocking)选项相似，但他的读操作返回值具有二义性。如果管道，先进先出，或者设备没有数据可读，no-delay选项就会造成read操作返回0，这与end of file造成的返回值0冲突了。虽然基于SVR4的系统还支持这个no-delay选项，但新的应用应该使用nonblocking选项。 O_SYNC Have each write wait for physical I/O to complete, including I/O necessary to update file attributes modified as a result of the write. We use this option in Section 3.14. 使每次write都等物理I/O完成，包括更新文件属性所需要的I/O。 O_TTY_INIT When opening a terminal device that is not already open, set the nonstandard termios parameters to values that result in behavior that conforms to the Single UNIX Specification. We discuss the termios structure when we discuss terminal I/O in Chapter 18. 当打开一个新的终端设备的时候，设置非标准参数 termios。 The following two flags are also optional. They are part of the synchronized input and output option of the Single UNIX Specification (and thus POSIX.1). O_DSYNC Have each write wait for physical I/O to complete, but don’t wait for file attributes to be updated if they don’t affect the ability to read the data just written. 让所有write都等待物理I/O完成，但是不用等文件属性更新，如果不影响刚刚写完的数据的读操作的话。 O_RSYNC Have each read operation on the file descriptor wait until any pending writes for the same portion of the file are complete. 使每个使用文件描述符的的读操作等待，直到对文件的同一部分的所有写操作完成。 Solaris 10 supports all three synchronization flags. Historically, FreeBSD (and thus Mac OS X) have used the O_FSYNC flag, which has the same behavior as O_SYNC. Because the two flags are equivalent, they define the flags to have the same value. FreeBSD 8.0 doesn’t support the O_DSYNC or O_RSYNC flags. Mac OS X doesn’t support the O_RSYNC flag, but defines the O_DSYNC flag, treating it the same as the O_SYNC flag. Linux 3.2.0 supports the O_DSYNC flag, but treats the O_RSYNC flag the same as O_SYNC. The file descriptor returned by open and openat is guaranteed to be the lowest- numbered unused descriptor. This fact is used by some applications to open a new file on standard input, standard output, or standard error. For example, an application might close standard output—normally, file descriptor 1—and then open another file, knowing that it will be opened on file descriptor 1. We’ll see a better way to guarantee that a file is open on a given descriptor in Section 3.12, when we explore the dup2 function. The fd parameter distinguishes the openat function from the open function. There are three possibilities: The path parameter specifies an absolute pathname. In this case, the fd parameter is ignored and the openat function behaves like the open function. The path parameter specifies a relative pathname and the fd parameter is a file descriptor that specifies the starting location in the file system where the relative pathname is to be evaluated. The fd parameter is obtained by opening the directory where the relative pathname is to be evaluated. The path parameter specifies a relative pathname and the fd parameter has the special value AT_FDCWD. In this case, the pathname is evaluated starting in the current working directory and the openat function behaves like the open function. The openat function is one of a class of functions added to the latest version of POSIX.1 to address two problems. First, it gives threads a way to use relative pathnames to open files in directories other than the current working directory. As we’ll see in Chapter 11, all threads in the same process share the same current working directory, so this makes it difficult for multiple threads in the same process to work in different directories at the same time. Second, it provides a way to avoid time-of-check- to-time-of-use (TOCTTOU) errors. openat函数是在最后一个版本的POSIX.1加入的，为了解决两个问题。首先，它给线程以相对路径而非当前路径。我们将在第11章看到，在同一进程中的所有线程共享同一个当前目录，所以要让同一进程中的多线程同时在不同的目录工作是非常困难的。第二，它提供了避免 time-of-check-to-time-of-use（TOCTTOU） 错误。 The basic idea behind TOCTTOU errors is that a program is vulnerable if it makes two file-based function calls where the second call depends on the results of the first call. Because the two calls are not atomic, the file can change between the two calls, thereby invalidating the results of the first call, leading to a program error. TOCTTOU errors in the file system namespace generally deal with attempts to subvert file system permissions by tricking a privileged program into either reducing permissions on a privileged file or modifying a privileged file to open up a security hole. Wei and Pu [2005] discuss TOCTTOU weaknesses in the UNIX file system interface. TOCTTOU错误的意思是，一个调用横叉一脚影响了另一个调用，本来另一个调用应该是一个原子操作。 Filename and Pathname TruncationWhat happens if NAME_MAX is 14 and we try to create a new file in the current directory with a filename containing 15 characters? Traditionally, early releases of System V, such as SVR2, allowed this to happen, silently truncating the filename beyond the 14th character. BSD-derived systems, in contrast, returned an error status, with errno set to ENAMETOOLONG. Silently truncating the filename presents a problem that affects more than simply the creation of new files. If NAME_MAX is 14 and a file exists whose name is exactly 14 characters, any function that accepts a pathname argument, such as open or stat, has no way to determine what the original name of the file was, as the original name might have been truncated. 如果NAME_MAX是14怎么办？传统上，早期的System V系统，允许这发生，静默的将文件名截断成14字符。相反的，BSD派生的系统，返回一个错误状态，并把errno设置成ENAMETOOLONG。静默的截断文件名呈现的问题不仅仅是创建了一个新文件。如果NAME_MAX是14且文件存在，且它的名字就是14字符，任何接收一个路径名作为参数的函数，比如open或者stat，没办法判断文件原来的名字是什么，因为原始文件名可能已经被截断。 With POSIX.1, the constant _POSIX_NO_TRUNC determines whether long filenames and long components of pathnames are truncated or an error is returned. As we saw in Chapter 2, this value can vary based on the type of the file system, and we can use fpathconf or pathconf to query a directory to see which behavior is supported. 在POSIX.1标准里，常量 _POSIX_NO_TRUNC 决定长文件名和路径名中长的组件是否被截断或者是否返回一个错误。正如我们在第二章中看到的，这个值在文件系统中是非常基本的，我们可以使用 fpathconf 或 pathconf查询一个目录看看它支持哪种行为。 Whether an error is returned is largely historical. For example, SVR4-based systems do not generate an error for the traditional System V file system, S5. For the BSD-style file system (known as UFS), however, SVR4-based systems do generate an error. Figure 2.20 illustrates another example: Solaris will return an error for UFS, but not for PCFS, the DOS-compatible file system, as DOS silently truncates filenames that don’t fit in an 8.3 format. BSD-derived systems and Linux always return an error. If _POSIX_NO_TRUNC is in effect, errno is set to ENAMETOOLONG, and an error status is returned if any filename component of the pathname exceeds NAME_MAX. Most modern file systems support a maximum of 255 characters for filenames. Because filenames are usually shorter than this limit, this constraint tends to not present problems for most applications. creat FunctionA new file can also be created by calling the creat function. 123#include &lt;fcntl.h&gt;int creat(const char *path, mode_t mode);// Returns: file descriptor opened for write-only if OK, −1 on error Note that this function is equivalent to 1open(path, O_WRONLY | O_CREAT | O_TRUNC, mode); Historically, in early versions of the UNIX System, the second argument to open could be only 0, 1, or 2. There was no way to open a file that didn’t already exist. Therefore, a separate system call, creat, was needed to create new files. With the O_CREAT and O_TRUNC options now provided by open, a separate creat function is no longer needed. 这个函数诞生的原因是：历史上open函数的第二个参数只支持0，1，2这三个值，也就是读，写，读写。没办法打开一个不存在的文件。而现在有了O_CREAT and O_TRUNC options，creat函数也就没有存在的必要了。 We’ll show how to specify mode in Section 4.5 when we describe a file’s access permissions in detail. One deficiency with creat is that the file is opened only for writing. Before the new version of open was provided, if we were creating a temporary file that we wanted to write and then read back, we had to call creat, close, and then open. A better way is to use the open function, as in 1open(path, O_RDWR | O_CREAT | O_TRUNC, mode); close FunctionAn open file is closed by calling the close function. 1234#include &lt;unistd.h&gt; // Returns: 0 if OK, −1 on errorint close(int fd); Closing a file also releases any record locks that the process may have on the file. We’ll discuss this point further in Section 14.3. 关闭一个文件同样会释放进程对该文件的所有锁。 When a process terminates, all of its open files are closed automatically by the kernel. Many programs take advantage of this fact and don’t explicitly close open files. See the program in Figure 1.4, for example. 当一个进程终止，所有它打开的文件都会被内核自动关闭。许多程序利用了这一点，不明确关闭文件。 lseek FunctionEvery open file has an associated “current file offset,” normally a non-negative integer that measures the number of bytes from the beginning of the file. (We describe some exceptions to the ‘‘non-negative’’ qualifier later in this section.) Read and write operations normally start at the current file offset and cause the offset to be incremented by the number of bytes read or written. By default, this offset is initialized to 0 when a file is opened, unless the O_APPEND option is specified. 每个打开的文件都与 “current file offset”关联，正常情况下它是一个非负整形数，表示从文件开始到目前位置的字节数。读和写操作都是从 current file offset开始的，并且会让offset增加，随着读和写的进行。默认的，当文件被打开时，这个位移初始化时0，除非指明了O_APPEND选项。 An open file’s offset can be set explicitly by calling lseek. 通过调用 lseek函数，一个打开的文件的offset可以被设定。 123#include &lt;unistd.h&gt;off_t lseek(int fd, off_t offset, int whence);// Returns: new file offset if OK, −1 on error The interpretation of the offset depends on the value of the whence argument. If whence is SEEK_SET, the file’s offset is set to offset bytes from the beginning of the file. If whence is SEEK_CUR, the file’s offset is set to its current value plus the offset. The offset can be positive or negative. If whence is SEEK_END, the file’s offset is set to the size of the file plus the offset. The offset can be positive or negative. Because a successful call to lseek returns the new file offset, we can seek zero bytes from the current position to determine the current offset: 12off_t currpos;currpos = lseek(fd, 0, SEEK_CUR); This technique can also be used to determine if a file is capable of seeking. If the file descriptor refers to a pipe, FIFO, or socket, lseek sets errno to ESPIPE and returns −1. The three symbolic constants—SEEK_SET, SEEK_CUR, and SEEK_END—were introduced with System V. Prior to this, whence was specified as 0 (absolute), 1 (relative to the current offset), or 2 (relative to the end of file). Much software still exists with these numbers hard coded. The character l in the name lseek means ‘‘long integer.’’ Before the introduction of the off_t data type, the offset argument and the return value were long integers. lseek was introduced with Version 7 when long integers were added to C. (Similar functionality was provided in Version 6 by the functions seek and tell.) ExampleThe program in Figure 3.1 tests its standard input to see whether it is capable of seeking. Figure 3.1 Test whether standard input is capable of seeking 123456789#include "apue.h"int main(void)&#123; if (lseek(STDIN_FILENO, 0, SEEK_CUR) == -1) printf("cannot seek\n"); else printf("seek OK\n"); exit(0); &#125; Normally, a file’s current offset must be a non-negative integer. It is possible, however, that certain devices could allow negative offsets. But for regular files, the offset must be non-negative. Because negative offsets are possible, we should be careful to compare the return value from lseek as being equal to or not equal to −1, rather than testing whether it is less than 0. The /dev/kmem device on FreeBSD for the Intel x86 processor supports negative offsets. Because the offset (off_t) is a signed data type (Figure 2.21), we lose a factor of 2 in the maximum file size. If off_t is a 32-bit integer, the maximum file size is $2^{31}$−1 bytes. lseek only records the current file offset within the kernel — it does not cause any I/O to take place. This offset is then used by the next read or write operation. The file’s offset can be greater than the file’s current size, in which case the next write to the file will extend the file. This is referred to as creating a hole in a file and is allowed. Any bytes in a file that have not been written are read back as 0. 文件偏移量可以大于文件的目前大小，在这种情况下下一次写文件将扩展文件。也就是说在文件中创建一个空洞是被允许的。在文件中任何没被写入的部分都将被读作0。 A hole in a file isn’t required to have storage backing it on disk. Depending on the file system implementation, when you write after seeking past the end of a file, new disk blocks might be allocated to store the data, but there is no need to allocate disk blocks for the data between the old end of file and the location where you start writing. 文件中的空洞并不需要存储到磁盘上。根据文件系统的实现，当你在end of file之后写，为了存储数据新的磁盘空间可能会分配，但没有必要分配磁盘块给end of file和你开始写的地方之间的这些数据。 ExampleThe program shown in Figure 3.2 creates a file with a hole in it. Figure 3.2 Create a file with a hole in it 1234567891011121314151617181920#include "apue.h"#include &lt;fcntl.h&gt;char buf1[] = "abcdefghij";char buf2[] = "ABCDEFGHIJ";int main(void)&#123; int fd; if ((fd = creat("file.hole", FILE_MODE)) &lt; 0) err_sys("creat error"); if (write(fd, buf1, 10) != 10) err_sys("buf1 write error"); /* offset now = 10 */ if (lseek(fd, 16384, SEEK_SET) == -1) err_sys("lseek error"); /* offset now = 16384 */ if (write(fd, buf2, 10) != 10) err_sys("buf2 write error"); /* offset now = 16394 */ exit(0); &#125; read FunctionData is read from an open file with the read function. 12#include &lt;unistd.h&gt;ssize_t read(int fd, void *buf, size_t nbytes); Returns: numbers of bytes read, 0 if end of file, -1 on error If the read is successful, the number of bytes read is returned. If the end of file is encountered, 0 is returned. There are several cases in which the number of bytes actually read is less than the amount requested: 有以下几种情况，read读取的字节会比指定的字节数少 When reading from a regular file, if the end of file is reached before the requested number of bytes has been read. For example, if 30 bytes remain until the end of file and we try to read 100 bytes, read returns 30. The next time we call read, it will return 0 (end of file). When reading from a terminal device. Normally, up to one line is read at a time. (We’ll see how to change this default in Chapter 18.) When reading from a network. Buffering within the network may cause less than the requested amount to be returned. When reading from a pipe or FIFO. If the pipe contains fewer bytes than requested, read will return only what is available. When reading from a record-oriented device. Some record-oriented devices, such as magnetic tape, can return up to a single record at a time. When interrupted by a signal and a partial amount of data has already been read. We discuss this further in Section 10.5. The read operation starts at the file’s current offset. Before a successful return, the offset is incremented by the number of bytes actually read. read操作是从文件的当前偏移量开始的。在成功返回前，偏移量会随读取的字节增加。 POSIX.1 changed the prototype for this function in several ways. The classic definition is 1int read(int fd, char *buf, unsigned nbytes); First, the second argument was changed from char to void to be consistentwith ISO C: the type void * is used for generic pointers. Next, the return value was required to be a signed integer (ssize_t) to return a positive byte count, 0 (for end of file), or −1 (for an error). Finally, the third argument historically has been an unsigned integer, to allow a 16-bit implementation to read or write up to 65,534 bytes at a time. With the 1990 POSIX.1 standard, the primitive system data type ssize_t was introduced to provide the signed return value, and the unsigned size_t was used for the third argument. (Recall the SSIZE_MAX constant from Section 2.5.2.) write FunctionData is written to an open file with the write function. 12#include &lt;unistd.h&gt;ssize_t write(int fd, const void *buf, size_t nbytes); The return value is usually equal to the nbytes argument; otherwise, an error has occurred. A common cause for a write error is either filling up a disk or exceeding the file size limit for a given process (Section 7.11 and Exercise 10.11). 返回值一般会等于nbytes这个参数的大小，否则就是出错了。一般导致写错误的原因是磁盘满了或者超出给定进程的文件大小限制。 For a regular file, the write operation starts at the file’s current offset. If the O_APPEND option was specified when the file was opened, the file’s offset is set to the current end of file before each write operation. After a successful write, the file’s offset is incremented by the number of bytes actually written. I/O EfficiencyThe program in Figure 3.5 copies a file, using only the read and write functions. Figure 3.5 Copy standard input to standard output 12345678910111213#include &quot;apue.h&quot;#define BUFFSIZE 4096int main(void)&#123; int n; char buf[BUFFSIZE]; while ((n = read(STDIN_FILENO, buf, BUFFSIZE)) &gt; 0) if (write(STDOUT_FILENO, buf, n) != n) err_sys(&quot;write error&quot;); if (n &lt; 0) err_sys(&quot;read error&quot;); exit(0);&#125; The following caveats apply to this program. It reads from standard input and writes to standard output, assuming that these have been set up by the shell before this program is executed. Indeed, all normal UNIX system shells provide a way to open a file for reading on standard input and to create (or rewrite) a file on standard output. This prevents the program from having to open the input and output files, and allows the user to take advantage of the shell’s I/O redirection facilities. The program doesn’t close the input file or output file. Instead, the program uses the feature of the UNIX kernel that closes all open file descriptors in a process when that process terminates. This example works for both text files and binary files, since there is no difference between the two to the UNIX kernel. One question we haven’t answered, however, is how we chose the BUFFSIZE value. Before answering that, let’s run the program using different values for BUFFSIZE. Figure 3.6 shows the results for reading a 516,581,760-byte file, using 20 different buffer sizes. The file was read using the program shown in Figure 3.5, with standard output redirected to /dev/null. The file system used for this test was the Linux ext4 file system with 4,096-byte blocks. (The st_blksize value, which we describe in Section 4.12, is 4,096.) This accounts for the minimum in the system time occurring at the few timing measurements starting around a BUFFSIZE of 4,096. Increasing the buffer size beyond this limit has little positive effect. Most file systems support some kind of read-ahead to improve performance. When sequential reads are detected, the system tries to read in more data than an application requests, assuming that the application will read it shortly. The effect of read-ahead can be seen in Figure 3.6, where the elapsed time for buffer sizes as small as 32 bytes is as good as the elapsed time for larger buffer sizes. We’ll return to this timing example later in the text. In Section 3.14, we show the effect of synchronous writes; in Section 5.8, we compare these unbuffered I/O times with the standard I/O library. Beware when trying to measure the performance of programs that read and write files. The operating system will try to cache the file incore, so if you measure the performance of the program repeatedly, the successive timings will likely be better than the first. This improvement occurs because the first run causes the file to be entered into the system’s cache, and successive runs access the file from the system’s cache instead of from the disk. (The term incore means in main memory. Back in the day, a computer’s main memory was built out of ferrite core. This is where the phrase ‘‘core dump’’ comes from: the main memory image of a program stored in a file on disk for diagnosis.) In the tests reported in Figure 3.6, each run with a different buffer size was made using a different copy of the file so that the current run didn’t find the data in the cache from the previous run. The files are large enough that they all don’t remain in the cache (the test system was configured with 6 GB of RAM). File SharingThe UNIX System supports the sharing of open files among different processes. Before describing the dup function, we need to describe this sharing. To do this, we’ll examine the data structures used by the kernel for all I/O. The following description is conceptual; it may or may not match a particular implementation. Refer to Bach [1986] for a discussion of these structures in System V. McKusick et al. [1996] describe these structures in 4.4BSD. McKusick and Neville-Neil [2005] cover FreeBSD 5.2. For a similar discussion of Solaris, see McDougall and Mauro [2007]. The Linux 2.6 kernel architecture is discussed in Bovet and Cesati [2006]. The kernel uses three data structures to represent an open file, and the relationships among them determine the effect one process has on another with regard to file sharing. Every process has an entry in the process table. Within each process table entry is a table of open file descriptors, which we can think of as a vector, with one entry per descriptor. Associated with each file descriptor are The file descriptor flags (close-on-exec; refer to Figure 3.7 and Section 3.14) A pointer to a file table entry The kernel maintains a file table for all open files. Each file table entry contains The file status flags for the file, such as read, write, append, sync, and nonblocking; more on these in Section 3.14 The current file offset A pointer to the v-node table entry for the file Each open file (or device) has a v-node structure that contains information about the type of file and pointers to functions that operate on the file. For most files, the v-node also contains the i-node for the file. This information is read from disk when the file is opened, so that all the pertinent information about the file is readily available. For example, the i-node contains the owner of the file, the size of the file, pointers to where the actual data blocks for the file are located on disk, and so on. (We talk more about i-nodes in Section 4.14 when we describe the typical UNIX file system in more detail.) Linux has no v-node. Instead, a generic i-node structure is used. Although the implementations differ, the v-node is conceptually the same as a generic i-node. Both point to an i-node structure specific to the file system. We’re ignoring some implementation details that don’t affect our discussion. For example, the table of open file descriptors can be stored in the user area (a separate per- process structure that can be paged out) instead of the process table. Also, these tables can be implemented in numerous ways—they need not be arrays; one alternate implementation is a linked lists of structures. Regardless of the implementation details, the general concepts remain the same. Figure 3.7 shows a pictorial arrangement of these three tables for a single process that has two different files open: one file is open on standard input (file descriptor 0), and the other is open on standard output (file descriptor 1). The arrangement of these three tables has existed since the early versions of the UNIX System [Thompson 1978]. This arrangement is critical to the way files are shared among processes. We’ll return to this figure in later chapters, when we describe additional ways that files are shared. The v-node was invented to provide support for multiple file system types on a single computer system. This work was done independently by Peter Weinberger (Bell Laboratories) and Bill Joy (Sun Microsystems). Sun called this the Virtual File System and called the file system–independent portion of the i-node the v-node [Kleiman 1986]. The v-node propagated through various vendor implementations as support for Sun’s Network File System (NFS) was added. The first release from Berkeley to provide v-nodes was the 4.3BSD Reno release, when NFS was added. In SVR4, the v-node replaced the file system–independent i-node of SVR3. Solaris is derived from SVR4 and, therefore, uses v-nodes. Instead of splitting the data structures into a v-node and an i-node, Linux uses a file system–independent i-node and a file system–dependent i-node. If two independent processes have the same file open, we could have the arrangement shown in Figure 3.8. We assume here that the first process has the file open on descriptor 3 and that the second process has that same file open on descriptor 4. Each process that opens the file gets its own file table entry, but only a single v-node table entry is required for a given file. One reason each process gets its own file table entry is so that each process has its own current offset for the file. Given these data structures, we now need to be more specific about what happens with certain operations that we’ve already described. After each write is complete, the current file offset in the file table entry is incremented by the number of bytes written. If this causes the current file offset to exceed the current file size, the current file size in the i-node table entry is set to the current file offset (for example, the file is extended). If a file is opened with the O_APPEND flag, a corresponding flag is set in the file status flags of the file table entry. Each time a write is performed for a file with this append flag set, the current file offset in the file table entry is first set to the current file size from the i-node table entry. This forces every write to be appended to the current end of file. 如果一个文件打开时使用O_APPEND标志，相应的标志会设置到文件表项的文件状态符。每次进行写操作时，文件表项就会首先将当前文件偏移量设置为i结点表项的当前文件大小。这样就可以强制每次都写到文件末尾了。 If a file is positioned to its current end of file using lseek, all that happens is the current file offset in the file table entry is set to the current file size from the i-node table entry. (Note that this is not the same as if the file was opened with the O_APPEND flag, as we will see in Section 3.11.) The lseek function modifies only the current file offset in the file table entry. No I/O takes place. It is possible for more than one file descriptor entry to point to the same file table entry, as we’ll see when we discuss the dup function in Section 3.12. This also happens after a fork when the parent and the child share the same file table entry for each open descriptor (Section 8.3). Note the difference in scope between the file descriptor flags and the file status flags. The former apply only to a single descriptor in a single process, whereas the latter apply to all descriptors in any process that point to the given file table entry. When we describe the fcntl function in Section 3.14, we’ll see how to fetch and modify both the file descriptor flags and the file status flags. Everything that we’ve described so far in this section works fine for multiple processes that are reading the same file. Each process has its own file table entry with its own current file offset. Unexpected results can arise, however, when multiple processes write to the same file. To see how to avoid some surprises, we need to understand the concept of atomic operations. Atomic OperationsAppending to a FileConsider a single process that wants to append to the end of a file. Older versions of the UNIX System didn’t support the O_APPEND option to open, so the program was coded as follows: 1234if (lseek(fd, 0L, 2) &lt; 0) /* position to EOF */trueerr_sys("lseek error");if (write(fd, buf, 100) != 100) /* and write */trueerr_sys("write error"); This works fine for a single process, but problems arise if multiple processes use this technique to append to the same file. (This scenario can arise if multiple instances of the same program are appending messages to a log file, for example.) Assume that two independent processes, A and B, are appending to the same file. Each has opened the file but without the O_APPEND flag. This gives us the same picture as Figure 3.8. Each process has its own file table entry, but they share a single v-node table entry. Assume that process A does the lseek and that this sets the current offset for the file for process A to byte offset 1,500 (the current end of file). Then the kernel switches processes, and B continues running. Process B then does the lseek, which sets the current offset for the file for process B to byte offset 1,500 also (the current end of file). Then B calls write, which increments B’s current file offset for the file to 1,600. Because the file’s size has been extended, the kernel also updates the current file size in the v-node to 1,600. Then the kernel switches processes and A resumes. When A calls write, the data is written starting at the current file offset for A, which is byte offset 1,500. This overwrites the data that B wrote to the file. The problem here is that our logical operation of ‘‘position to the end of file and write’’ requires two separate function calls (as we’ve shown it). The solution is to have the positioning to the current end of file and the write be an atomic operation with regard to other processes. Any operation that requires more than one function call cannot be atomic, as there is always the possibility that the kernel might temporarily suspend the process between the two function calls (as we assumed previously). The UNIX System provides an atomic way to do this operation if we set the O_APPEND flag when a file is opened. As we described in the previous section, this causes the kernel to position the file to its current end of file before each write. We no longer have to call lseek before each write. pread and pwrite FunctionsThe Single UNIX Specification includes two functions that allow applications to seek and perform I/O atomically: pread and pwrite. 1234567#include &lt;unistd.h&gt;// Returns: number of bytes read, 0 if end of file, −1 on errorssize_t pread(int fd, void *buf, size_t nbytes, off_t offset);// Returns: number of bytes written if OK, −1 on errorssize_t pwrite(int fd, const void *buf, size_t nbytes, off_t offset); Calling pread is equivalent to calling lseek followed by a call to read, with the following exceptions. There is no way to interrupt the two operations that occur when we call pread. The current file offset is not updated. Calling pwrite is equivalent to calling lseek followed by a call to write, with similar exceptions. Creating a FileWe saw another example of an atomic operation when we described the O_CREAT and O_EXCL options for the open function. When both of these options are specified, the open will fail if the file already exists. We also said that the check for the existence of the file and the creation of the file was performed as an atomic operation. If we didn’t have this atomic operation, we might try 1234567if ((fd = open(path, O_WRONLY)) &lt; 0) &#123; if (errno == ENOENT) &#123; if ((fd = creat(path, mode)) &lt; 0) err_sys("creat error"); &#125; else &#123; err_sys("open error");&#125; &#125; The problem occurs if the file is created by another process between the open and the creat. If the file is created by another process between these two function calls, and if that other process writes something to the file, that data is erased when this creat is executed. Combining the test for existence and the creation into a single atomic operation avoids this problem. In general, the term atomic operation refers to an operation that might be composed of multiple steps. If the operation is performed atomically, either all the steps are performed (on success) or none are performed (on failure). It must not be possible for only a subset of the steps to be performed. We’ll return to the topic of atomic operations when we describe the link function (Section 4.15) and record locking (Section 14.3). dup and dup2 FunctionsAn existing file descriptor is duplicated by either of the following functions: 12345#include &lt;unistd.h&gt;// Both return: new file descriptor if OK, −1 on errorint dup(int fd);int dup2(int fd, int fd2); The new file descriptor returned by dup is guaranteed to be the lowest-numbered available file descriptor. With dup2, we specify the value of the new descriptor with the fd2 argument. If fd2 is already open, it is first closed. If fd equals fd2, then dup2 returns fd2 without closing it. Otherwise, the FD_CLOEXEC file descriptor flag is cleared for fd2, so that fd2 is left open if the process calls exec. The new file descriptor that is returned as the value of the functions shares the same file table entry as the fd argument. We show this in Figure 3.9. In this figure, we assume that when it’s started, the process executes 1newfd = dup(1); We assume that the next available descriptor is 3 (which it probably is, since 0, 1, and 2 are opened by the shell). Because both descriptors point to the same file table entry, they share the same file status flags—read, write, append, and so on—and the same current file offset. Each descriptor has its own set of file descriptor flags. As we describe in Section 3.14, the close-on-exec file descriptor flag for the new descriptor is always cleared by the dup functions. Another way to duplicate a descriptor is with the fcntl function, which we describe in Section 3.14. Indeed, the call 1dup(fd); is equivalent to 1fcntl(fd, F_DUPFD, 0); Similarly, the call 1dup2(fd, fd2); is equivalent to 12close(fd2);fcntl(fd, F_DUPFD, fd2); In this last case, the dup2 is not exactly the same as a close followed by an fcntl. The differences are as follows: dup2 is an atomic operation, whereas the alternate form involves two function calls. It is possible in the latter case to have a signal catcher called between the close and the fcntl that could modify the file descriptors. (We describe signals in Chapter 10.) The same problem could occur if a different thread changes the file descriptors. (We describe threads in Chapter 11.) There are some errno differences between dup2 and fcntl. The dup2 system call originated with Version 7 and propagated through the BSD releases. The fcntl method for duplicating file descriptors appeared with System III and continued with SystemV. SVR3.2 picked up the dup2 function, and 4.2BSD picked up the fcntl function and the F_DUPFD functionality. POSIX.1 requires both dup2 and the F_DUPFD feature of fcntl. sync, fsync, and fdatasync FunctionsTraditional implementations of the UNIX System have a buffer cache or page cache in the kernel through which most disk I/O passes. When we write data to a file, the data is normally copied by the kernel into one of its buffers and queued for writing to disk at some later time. This is called delayed write. (Chapter 3 of Bach [1986] discusses this buffer cache in detail.) The kernel eventually writes all the delayed-write blocks to disk, normally when it needs to reuse the buffer for some other disk block. To ensure consistency of the file system on disk with the contents of the buffer cache, the sync, fsync, and fdatasync functions are provided. 1234567#include &lt;unistd.h&gt; // Both Returns: 0 if OK, −1 on errorint fsync(int fd); int fdatasync(int fd);void sync(void); The sync function simply queues all the modified block buffers for writing and returns; it does not wait for the disk writes to take place. The function sync is normally called periodically (usually every 30 seconds) from a system daemon, often called update. This guarantees regular flushing of the kernel’s block buffers. The command sync(1) also calls the sync function. The function fsync refers only to a single file, specified by the file descriptor fd, and waits for the disk writes to complete before returning. This function is used when an application, such as a database, needs to be sure that the modified blocks have been written to the disk. The fdatasync function is similar to fsync, but it affects only the data portions of a file. With fsync, the file’s attributes are also updated synchronously. All four of the platforms described in this book support sync and fsync. However, FreeBSD 8.0 does not support fdatasync. fcntl FunctionThe fcntl function can change the properties of a file that is already open. 1234#include &lt;fcntl.h&gt;// Returns: depends on cmd if OK (see following), −1 on errorint fcntl(int fd, int cmd, ... /* int arg */ ); In the examples in this section, the third argument is always an integer, corresponding to the comment in the function prototype just shown. When we describe record locking in Section 14.3, however, the third argument becomes a pointer to a structure. The fcntl function is used for five different purposes. Duplicate an existing descriptor (cmd = F_DUPFD or F_DUPFD_CLOEXEC) Get/set file descriptor flags (cmd = F_GETFD or F_SETFD) Get/set file status flags (cmd = F_GETFL or F_SETFL) Get/set asynchronous I/O ownership (cmd = F_GETOWN or F_SETOWN) Get/set record locks (cmd = F_GETLK, F_SETLK, or F_SETLKW) We’ll now describe the first 8 of these 11 cmd values. (We’ll wait until Section 14.3 to describe the last 3, which deal with record locking.) Refer to Figure 3.7, as we’ll discuss both the file descriptor flags associated with each file descriptor in the process table entry and the file status flags associated with each file table entry. F_DUPFD Duplicate the file descriptor fd. The new file descriptor is returned as the value of the function. It is the lowest-numbered descriptor that is not already open, and that is greater than or equal to the third argument (taken as an integer). The new descriptor shares the same file table entry as fd. (Refer to Figure 3.9.) But the new descriptor has its own set of file descriptor flags, and its FD_CLOEXEC file descriptor flag is cleared. (This means that the descriptor is left open across an exec, which we discuss in Chapter 8.) F_DUPFD_CLOEXEC Duplicate the file descriptor and set the FD_CLOEXEC file descriptor flag associated with the new descriptor. Returns the new file descriptor. F_GETFD Return the file descriptor flags for fd as the value of the function. Currently, only one file descriptor flag is defined: the FD_CLOEXEC flag. F_SETFD Set the file descriptor flags for fd. The new flag value is set from the third argument (taken as an integer). Be aware that some existing programs that deal with the file descriptor flags don’t use the constant FD_CLOEXEC. Instead, these programs set the flag to either 0 (don’t close-on-exec, the default) or 1 (do close-on-exec). F_GETFL Return the file status flags for fd as the value of the function. We described the file status flags when we described the open function. They are listed in Figure 3.10. Unfortunately, the five access-mode flags—O_RDONLY, O_WRONLY, O_RDWR, O_EXEC, and O_SEARCH—are not separate bits that can be tested. (As we mentioned earlier, the first three often have the values 0, 1, and 2, respectively, for historical reasons. Also, these five values are mutually exclusive; a file can have only one of them enabled.) Therefore, we must first use the O_ACCMODE mask to obtain the access-mode bits and then compare the result against any of the five values. F_SETFL Set the file status flags to the value of the third argument (taken as an integer). The only flags that can be changed are O_APPEND, O_NONBLOCK, O_SYNC, O_DSYNC, O_RSYNC, O_FSYNC, and O_ASYNC. F_GETOWN Get the process ID or process group ID currently receiving the SIGIO and SIGURG signals. We describe these asynchronous I/O signals in Section 14.5.2. F_SETOWN Set the process ID or process group ID to receive the SIGIO and SIGURG signals. A positive arg specifies a process ID. A negative arg implies a process group ID equal to the absolute value of arg. The return value from fcntl depends on the command. All commands return −1 on an error or some other value if OK. The following four commands have special return values: F_DUPFD, F_GETFD, F_GETFL, and F_GETOWN. The first command returns the new file descriptor, the next two return the corresponding flags, and the final command returns a positive process ID or a negative process group ID. ExampleThe program in Figure 3.11 takes a single command-line argument that specifies a file descriptor and prints a description of selected file flags for that descriptor. Figure 3.11 Print file flags for specified descriptor 1234567891011121314151617181920212223242526272829303132333435#include "include/apue.h"#include &lt;fcntl.h&gt;int main(int argc, char *argv[])&#123; int val; if (argc != 2) err_quit("usage: a.out &lt;descriptor#&gt;"); if ((val = fcntl(atoi(argv[1]), F_GETFL, 0)) &lt; 0) err_sys("fcntl error for fd %d", atoi(argv[1])); switch (val &amp; O_ACCMODE) &#123; case O_RDONLY: printf("read only"); break; case O_WRONLY: printf("write only"); break; case O_RDWR: printf("read write"); break; default: err_dump("unknown access mode"); &#125; if (val &amp; O_APPEND) printf(", append"); if (val &amp; O_NONBLOCK) printf(", nonblocking"); if (val &amp; O_SYNC) printf(", synchronous writes"); #if !defined(_POSIX_C_SOURCE) &amp;&amp; defined(O_FSYNC) &amp;&amp; (O_FSYNC != O_SYNC) if (val &amp; O_FSYNC) printf(", synchronous writes"); #endif putchar('\n'); exit(0); &#125; Note that we use the feature test macro _POSIX_C_SOURCE and conditionally compile the file access flags that are not part of POSIX.1. The following script shows the operation of the program, when invoked from bash (the Bourne-again shell). Results will vary, depending on which shell you use. 123456789➜ apue.3e ./fig3.11 0 &lt; /dev/ttyread only➜ apue.3e ./fig3.11 1 &gt; temp.foo➜ apue.3e cat temp.foowrite only➜ apue.3e ./fig3.11 2 2&gt;&gt;temp.foowrite only, append➜ apue.3e ./fig3.11 5 5&lt;&gt;temp.fooread write The clause 5&lt;&gt;temp.foo opens the file temp.foo for reading and writing on file descriptor 5. ExampleWhen we modify either the file descriptor flags or the file status flags, we must be careful to fetch the existing flag value, modify it as desired, and then set the new flag value. We can’t simply issue an F_SETFD or an F_SETFL command, as this could turn off flag bits that were previously set. Figure 3.12 shows a function that sets one or more of the file status flags for a descriptor. Figure 3.12 Turn on one or more of the file status flags for a descriptor 1234567891011#include "apue.h"#include &lt;fcntl.h&gt;void set_fl(int fd, int flags) /* flags are file status flags to turn on */&#123;trueint val;trueif ((val = fcntl(fd, F_GETFL, 0)) &lt; 0)true err_sys("fcntl F_GETFL error");trueval |= flags; /* turn on flags */trueif (fcntl(fd, F_SETFL, val) &lt; 0)true err_sys("fcntl F_SETFL error");&#125; If we change the middle statement to 1val &amp;= ̃flags; /* turn flags off */ we have a function named clr_fl, which we’ll use in some later examples. This statement logically ANDs the one’s complement of flags with the current val. If we add the line 1set_fl(STDOUT_FILENO, O_SYNC); to the beginning of the program shown in Figure 3.5, we’ll turn on the synchronous- write flag. This causes each write to wait for the data to be written to disk before returning. Normally in the UNIX System, a write only queues the data for writing; the actual disk write operation can take place sometime later. A database system is a likely candidate for using O_SYNC, so that it knows on return from a write that the data is actually on the disk, in case of an abnormal system failure. We expect the O_SYNC flag to increase the system and clock times when the program runs. To test this, we can run the program in Figure 3.5, copying 492.6 MB of data from one file on disk to another and compare this with a version that does the same thing with the O_SYNC flag set. The results from a Linux system using the ext4 file system are shown in Figure 3.13. The six rows in Figure 3.13 were all measured with a BUFFSIZE of 4,096 bytes. The results in Figure 3.6 were measured while reading a disk file and writing to /dev/null, so there was no disk output. The second row in Figure 3.13 corresponds to reading a disk file and writing to another disk file. This is why the first and second rows in Figure 3.13 are different. The system time increases when we write to a disk file, because the kernel now copies the data from our process and queues the data for writing by the disk driver. We expect the clock time to increase as well when we write to a disk file. When we enable synchronous writes, the system and clock times should increase significantly. As the third row shows, the system time for writing synchronously is not much more expensive than when we used delayed writes. This implies that the Linux operating system is doing the same amount of work for delayed and synchronous writes (which is unlikely), or else the O_SYNC flag isn’t having the desired effect. In this case, the Linux operating system isn’t allowing us to set the O_SYNC flag using fcntl, instead failing without returning an error (but it would have honored the flag if we were able to specify it when the file was opened). The clock time in the last three rows reflects the extra time needed to wait for all of the writes to be committed to disk. After writing a file synchronously, we expect that a call to fsync will have no effect. This case is supposed to be represented by the last row in Figure 3.13, but since the O_SYNC flag isn’t having the intended effect, the last row behaves the same way as the fifth row. Figure 3.14 shows timing results for the same tests run on Mac OS X 10.6.8, which uses the HFS file system. Note that the times match our expectations: synchronous writes are far more expensive than delayed writes, and using fsync with synchronous writes makes very little difference. Note also that adding a call to fsync at the end of the delayed writes makes little measurable difference. It is likely that the operating system flushed previously written data to disk as we were writing new data to the file, so by the time that we called fsync, very little work was left to be done. Compare fsync and fdatasync, both of which update a file’s contents when we say so, with the O_SYNC flag, which updates a file’s contents every time we write to the file. The performance of each alternative will depend on many factors, including the underlying operating system implementation, the speed of the disk drive, and the type of the file system. With this example, we see the need for fcntl. Our program operates on a descriptor (standard output), never knowing the name of the file that was opened on that descriptor. We can’t set the O_SYNC flag when the file is opened, since the shell opened the file. With fcntl, we can modify the properties of a descriptor, knowing only the descriptor for the open file. We’ll see another need for fcntl when we describe nonblocking pipes (Section 15.2), since all we have with a pipe is a descriptor. ioctl FunctionThe ioctl function has always been the catchall for I/O operations. Anything that couldn’t be expressed using one of the other functions in this chapter usually ended up being specified with an ioctl. Terminal I/O was the biggest user of this function. (When we get to Chapter 18, we’ll see that POSIX.1 has replaced the terminal I/O operations with separate functions.) 12345#include &lt;unistd.h&gt; /* System V */#include &lt;sys/ioctl.h&gt; /* BSD and Linux */// Returns: −1 on error, something else if OKint ioctl(int fd, int request, ...); The ioctl function was included in the Single UNIX Specification only as an extension for dealing with STREAMS devices [Rago 1993], but it was moved to obsolescent status in SUSv4. UNIX System implementations use ioctl for many miscellaneous device operations. Some implementations have even extended it for use with regular files. The prototype that we show corresponds to POSIX.1. FreeBSD 8.0 and Mac OS X 10.6.8 declare the second argument as an unsigned long. This detail doesn’t matter, since the second argument is always a #defined name from a header. For the ISO C prototype, an ellipsis is used for the remaining arguments. Normally, however, there is only one more argument, and it’s usually a pointer to a variable or a structure. In this prototype, we show only the headers required for the function itself. Normally, additional device-specific headers are required. For example, the ioctl commands for terminal I/O, beyond the basic operations specified by POSIX.1, all require the &lt;termios.h&gt; header. Each device driver can define its own set of ioctl commands. The system, however, provides generic ioctl commands for different classes of devices. Examples of some of the categories for these generic ioctl commands supported in FreeBSD are summarized in Figure 3.15. The mag tape operations allow us to write end-of-file marks on a tape, rewind a tape, space forward over a specified number of files or records, and the like. None of these operations is easily expressed in terms of the other functions in the chapter (read, write, lseek, and so on), so the easiest way to handle these devices has always been to access their operations using ioctl. We use the ioctl function in Section 18.12 to fetch and set the size of a terminal’s window, and in Section 19.7 when we access the advanced features of pseudo terminals. /dev/fdNewer systems provide a directory named /dev/fd whose entries are files named 0, 1, 2, and so on. Opening the file /dev/fd/n is equivalent to duplicating descriptor n, assuming that descriptor n is open. The /dev/fd feature was developed by Tom Duff and appeared in the 8th Edition of the Research UNIX System. It is supported by all of the systems described in this book: FreeBSD 8.0, Linux 3.2.0, Mac OS X 10.6.8, and Solaris 10. It is not part of POSIX.1. In the function call 1fd = open("/dev/fd/0", mode); most systems ignore the specified mode, whereas others require that it be a subset of the mode used when the referenced file (standard input, in this case) was originally opened. Because the previous open is equivalent to 1fd = dup(0); the descriptors 0 and fd share the same file table entry (Figure 3.9). For example, if descriptor 0 was opened read-only, we can only read on fd. Even if the system ignores the open mode and the call 1fd = open("/dev/fd/0", O_RDWR); succeeds, we still can’t write to fd. The Linux implementation of /dev/fd is an exception. It maps file descriptors into symbolic links pointing to the underlying physical files. When you open /dev/fd/0, for example, you are really opening the file associated with your standard input. Thus the mode of the new file descriptor returned is unrelated to the mode of the /dev/fd file descriptor. We can also call creat with a /dev/fd pathname argument as well as specify O_CREAT in a call to open. This allows a program that calls creat to still work if the pathname argument is /dev/fd/1, for example. Beware of doing this on Linux. Because the Linux implementation uses symbolic links to the real files, using creat on a /dev/fd file will result in the underlying file being truncated. Some systems provide the pathnames /dev/stdin, /dev/stdout, and /dev/stderr. These pathnames are equivalent to /dev/fd/0, /dev/fd/1, and /dev/fd/2, respectively. The main use of the /dev/fd files is from the shell. It allows programs that use pathname arguments to handle standard input and standard output in the same manner as other pathnames. For example, the cat(1) program specifically looks for an input filename of - and uses it to mean standard input. The command 1filter file2 | cat file1 - file3 | lpr is an example. First, cat reads file1, then its standard input (the output of the filter program on file2), and then file3. If /dev/fd is supported, the special handling of - can be removed from cat, and we can enter 1filter file2 | cat file1 /dev/fd/0 file3 | lpr The special meaning of - as a command-line argument to refer to the standard input or the standard output is a kludge that has crept into many programs. There are also problems if we specify - as the first file, as it looks like the start of another command-line option. Using /dev/fd is a step toward uniformity and cleanliness. SummaryThis chapter has described the basic I/O functions provided by the UNIX System. These are often called the unbuffered I/O functions because each read or write invokes a system call into the kernel. Using only read and write, we looked at the effect of various I/O sizes on the amount of time required to read a file. We also looked at several ways to flush written data to disk and their effect on application performance. Atomic operations were introduced when multiple processes append to the same file and when multiple processes create the same file. We also looked at the data structures used by the kernel to share information about open files. We’ll return to these data structures later in the text. We also described the ioctl and fcntl functions. We return to both of these functions later in the book. In Chapter 14, we’ll use fcntl for record locking. In Chapter 18 and Chapter 19, we’ll use ioctl when we deal with terminal devices. Exercises When reading or writing a disk file, are the functions described in this chapter really unbuffered? Explain. Write your own dup2 function that behaves the same way as the dup2 function described in Section 3.12, without calling the fcntl function. Be sure to handle errors correctly. Assume that a process executes the following three function calls: 123fd1 = open(path, oflags);fd2 = dup(fd1);fd3 = open(path, oflags); Draw the resulting picture, similar to Figure 3.9. Which descriptors are affected by an fcntl on fd1 with a command of F_SETFD? Which descriptors are affected by an fcntl on fd1 with a command of F_SETFL? The following sequence of code has been observed in various programs: 1234dup2(fd, 0);dup2(fd, 1);dup2(fd, 2);if (fd &gt; 2) close(fd); To see why the if test is needed, assume that fd is 1 and draw a picture of what happens to the three descriptor entries and the corresponding file table entry with each call to dup2. Then assume that fd is 3 and draw the same picture.]]></content>
      <categories>
        <category>Unix</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[APUE-3rd 读书笔记 -- Unix System Overview]]></title>
    <url>%2Fblog%2F2018%2F05%2F22%2FAPUE-3rd-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--Unix%20System%20Overview%2F</url>
    <content type="text"><![CDATA[前言Unix系统中非常重要的概念： 内核 系统调用 库函数 shell 文件、目录、路径、工作路径、权限管理 文件描述符 进程、线程 错误处理 信号 1.1 IntroductionAll operating systems provide services for programs they run. Typical services include executing a new program, opening a file, reading a file, allocating a region of memory, getting the current time of day, and so on. The focus of this text is to describe the services provided by various versions of the UNIX operating system. 所有的操作系统都提供一些服务让程序能够在其上运行，典型的服务包括：执行一个新程序，打开一个文件，读取一个文件，分配一块内存，获取当前时间，等等。 这本书所关注的重点就是众多种类的unix操作系统能提供服务。 Describing the UNIX System in a strictly linear fashion, without any forward references to terms that haven’t been described yet, is nearly impossible (and would probably be boring). 这里道出了一个众所周知的难题，想要线性的给读者讲授一个新课程，在讲授一个知识点时却又不引进任何其他的未知概念，这几乎是不可能的。 但我认为能不能做到，不用去管，做教育的就是要尽可能的降低学习者的难度，将新知识点尽可能的用学习者已有的知识结构描述清楚。所以我们可以看到我们的课程都是有选修课的。 1.2 Unix Architecture 内核（kernel）：In a strict sense, an operating system can be defined as the software that controls the hardware resources of the computer and provides an environment under which programs can run. Generally, we call this software the kernel, since it is relatively small and resides at the core of the environment. 内核控制硬件资源，并给其上的程序提供运行环境，内核相对（相对是指相对于上面这张图，整个软件环境：包括内核、系统调用、公用函数库、shell(命令解释器)、应用程序）来说比较小，并处于整个环境的中心。 系统调用（system calls）：The interface to the kernel is a layer of software called the system calls . 系统调用是内核对外的接口。 Libraries of common functions are built on top of the system call interface, but applications are free to use both. The shell is a special application that provides an interface for running other applications. 公共库是建立在系统调用之上的，但应用程序既可以使用公共库也可以使用系统调用。shell是一种特殊的应用程序，给执行命令(运行其他程序)提供接口。 In a broad sense, an operating system consists of the kernel and all the other software that makes a computer useful and gives the computer its personality. This other software includes system utilities, applications, shells, libraries of common functions, and so on. For example, Linux is the kernel used by the GNU operating system. Some people refer to this combination as the GNU/Linux operating system, but it is more commonly referred to as simply Linux. Although this usage may not be correct in a strict sense, it is understandable, given the dual meaning of the phrase operating system. (It also has the advantage of being more succinct.) 1.3 Logging InLogin NameWhen we log in to a UNIX system, we enter our login name, followed by our password. The system then looks up our login name in its password file, usually the file /etc/passwd. If we look at our entry in the password file, we see that it’s composed of seven colon-separated fields: the login name, encrypted password, numeric user ID (205), numeric group ID (105), a comment field, home directory (/home/sar), and shell program (/bin/ksh).口令文件（password file） ：当我们使用用户名和密码登陆unix的时候，系统会在/etc/passwd文件(password file，又叫：口令文件)中查找我们的用户名，口令文件中每个条目占一行，格式是： 1登录名:加密过的密码:user ID:group ID:注解:home目录:shell All contemporary systems have moved the encrypted password to a different file. In Chapter 6, we’ll look at these files and some functions to access them. 不过加密过的密码现在也不显示在这个文件里了，而是用一个*号或者x号之类的取代，home目录又称为起始目录，新开一个shell，pwd一下，就是home目录。 例子： 1sar:x:205:105:Stephen Rago:/home/sar:/bin/ksh 登录名是sar，加密过的密码是x（不显示在这里），user ID是205，group ID是105，注解是Stephen Rago，home目录是/home/sar，使用的shell是/bin/ksh ShellsA shell is a command-line interpreter that reads user input and executes commands. The user input to a shell is normally from the terminal (an interactive shell) or sometimes from a file (called a shell script). shell是一种命令解释器，可以读取用户的输入，并执行命令，用户可以交互式的输入命令，也可以把命令预先全部写在一个文本文件（shell脚本）中让shell执行。 常见的shell有： The system knows which shell to execute for us based on the final field in our entry in the password file. 系统是通过口令文件的最后一个字段知道我们登陆时使用哪个shell。 bash的全称是Bourne-again shell The Bourne-again shell is the GNU shell provided with all Linux systems. It was designed to be POSIX conformant, while still remaining compatible with the Bourne shell. It supports features from both the C shell and the Korn shell. 1.4 Files and DirectoriesFile System 根目录（root）：The UNIX file system is a hierarchical arrangement of directories and files. Everything starts in the directory called root, whose name is the single character /. unix文件系统是目录和文件的层级安排，所有东西都从一个叫root的目录开始，root的名字是一个单字符：/。 目录（directory）：A directory is a file that contains directory entries. Logically, we can think of each directory entry as containing a filename along with a structure of information describing the attributes of the file. The attributes of a file are such things as the type of file (regular file, directory), the size of the file, the owner of the file, permissions for the file (whether other users may access this file), and when the file was last modified. 目录是一个包含目录条目的文件。逻辑上，我们可以认为每一个目录条目包含一个文件名和一个描述文件属性的结构信息。文件属性包括：文件类型（普通文件还是目录），文件大小，文件所属者，文件权限（其他用户是否能访问），文件最后被修改的时间。 The stat and fstat functions return a structure of information containing all the attributes of a file. stat和fstat函数可以返回一个结构信息，包含文件的所有属性。 We make a distinction between the logical view of a directory entry and the way it is actually stored on disk. Most implementations of UNIX file systems don’t store attributes in the directory entries themselves, because of the difficulty of keeping them in synch when a file has multiple hard links. 也就是说上面目录条目只是逻辑上的，实际上在硬盘存储上并不是直接将目录条目中的那些属性存储在目录文件中的，因为如果文件有硬链接的话，很难让这些属性信息保持同步。 Filename文件名：The names in a directory are called filenames. The only two characters that cannot appear in a filename are the slash character (/) and the null character. The slash separates the filenames that form a pathname (described next) and the null character terminates a pathname. Nevertheless, it’s good practice to restrict the characters in a filename to a subset of the normal printing characters. (If we use some of the shell’s special characters in the filename, we have to use the shell’s quoting mechanism to reference the filename, and this can get complicated.) Indeed, for portability, POSIX.1 recommends restricting filenames to consist of the following characters: letters (a-z, A-Z), numbers (0-9), period (.), dash (-), and underscore (_).一个目录中的诸多名字（包括文件和目录）称为文件名，只有两个字符不能出现在文件名中：斜杠/(slash)和空字符(null character)，斜杠用来分割路径名(pathname)中的文件名，空字符用来结束一个路径名（实际上编程语言中字符串就是由空字符来结束的）。然而，我们命名文件的时候最好不要使用一些乱七八糟的字符，如果我们使用了shell的特殊字符，我们就必须使用shell的引用机制去引用文件名。实际上，为了可移植性，POSIX.1标准推荐严格使用以下字符来命名文件：字母(a-z, A-Z)，数字(0-9)，点(.)，中杠(-)，下划线(_)。 Two filenames are automatically created whenever a new directory is created: . (called dot) and .. (called dot-dot). Dot refers to the current directory, and dot-dot refers to the parent directory. In the root directory, dot-dot is the same as dot. 有两个文件名在目录被创建的时候自动创建：.和..，.指向当前目录，..指向父目录，在根目录中，..和.一样（都指向当前目录）。 The Research UNIX System and some older UNIX System V file systems restricted a filename to 14 characters. BSD versions extended this limit to 255 characters. Today, almost all commercial UNIX file systems support at least 255-character filenames. 现如今的unix文件系统都支持至少255字符的文件名。 PathnameA sequence of one or more filenames, separated by slashes and optionally starting with a slash, forms a pathname. A pathname that begins with a slash is called an absolute pathname; otherwise, it’s called a relative pathname. Relative pathnames refer to files relative to the current directory. 一系列的由斜杠分割而开的文件名组成一个路径名，一个路径名可以由一个斜杠开始，这叫做：绝对路径，反之就是相对路径，相对路径是相对于当前路径的。 ExampleListing the names of all the files in a directory is not difficult. There is a bare-bones implementation of the ls(1) command: Figure 1.3 List all the files in a directory 12345678910111213141516#include "apue.h"#include &lt;dirent.h&gt;int main(int argc, char *argv[])&#123; DIR *dp; struct dirent *dirp; if (argc != 2) err_quit("usage: ls directory_name"); if ((dp = opendir(argv[1])) == NULL) err_sys("can’t open %s", argv[1]); while ((dirp = readdir(dp)) != NULL) printf("%s\n", dirp-&gt;d_name); closedir(dp); exit(0);&#125; The notation ls(1) is the normal way to reference a particular entry in the UNIX system manuals. It refers to the entry for ls in Section 1. The sections are normally numbered 1 through 8, and all the entries within each section are arranged alphabetically. Throughout this text, we assume that you have a copy of the manuals for your UNIX system. 熟悉unix的人应该都知道，unix有个man命令，可以查看其它命令的说明书，当然也可以man man查看自己的说明书。 man命令有8个section，每个section里的条目按照字幕顺序排列。 Historically, UNIX systems lumped all eight sections together into what was called the UNIX Programmer’s Manual. As the page count increased, the trend changed to distributing the sections among separate manuals: one for users, one for programmers, and one for system administrators, for example. Some UNIX systems further divide the manual pages within a given section, using an uppercase letter. For example, all the standard input/output (I/O) functions in AT&amp;T [1990e] are indicated as being in Section 3S, as in fopen(3S). Other systems have replaced the numeric sections with alphabetic ones, such as C for commands. Today, most manuals are distributed in electronic form. If your manuals are online, the way to see the manual pages for the ls command would be something like 1man 1 ls or 1man -s1 ls Figure 1.3 is a program that just prints the name of every file in a directory, and nothing else. If the source file is named myls.c, we compile it into the default a.out executable file by running 1cc myls.c Historically, cc(1) is the C compiler. On systems with the GNU C compilation system, the C compiler is gcc(1). Here, cc is usually linked to gcc. 但在实际的操作过程中，遇到了如下错误： 1234567Undefined symbols for architecture x86_64: &quot;_err_quit&quot;, referenced from: _main in fig1-457251.o &quot;_err_sys&quot;, referenced from: _main in fig1-457251.old: symbol(s) not found for architecture x86_64clang: error: linker command failed with exit code 1 (use -v to see invocation) 这是个链接错误，具体的解决办法请看这篇博客：OS X下UNIX环境高级编程（第三版）学习日志－第一章ChapterI，编译apue包与第一个例程 实际上要先单独编译myls.c，使用命令： 1gcc -c myls.c 得到myls.o，然后与依赖的其他目标文件组合成一个可执行文件，我们可以把本书要用到的所有依赖组合成一个静态库，在apue源代码的根目录下面make一下，编译完成后就可以在lib目录下找到静态库：libapue.a了。使用命令： 1gcc -o myls myls.o -Llib -lapue 如果编译失败，使用make clean可以清空编译结果，然后就可以使用make重新编译了。不要将程序命名为.cpp文件，这样的话即便你使用gcc编译myls.cpp，也会出错，更不要使用g++去编译myls.cpp，因为库是用gcc编译的。 When the program is done, it calls the function exit with an argument of 0. The function exit terminates a program. By convention, an argument of 0 means OK, and an argument between 1 and 255 means that an error occurred. 0代表OK，1到255代表各种类型的错误。 Working Directory工作目录（working directory）：Every process has a working directory, sometimes called the current working directory. This is the directory from which all relative pathnames are interpreted. A process can change its working directory with the chdir function. 每个进程都有一个工作目录，又叫做：当前工作目录，相对路径就是相对于当前工作目录的来解释的，可以调用chdir函数来改变工作目录。 For example, the relative pathname doc/memo/joe refers to the file or directory joe, in the directory memo, in the directory doc, which must be a directory within the working directory. From looking just at this pathname, we know that both doc and memo have to be directories, but we can’t tell whether joe is a file or a directory. The pathname /usr/lib/lint is an absolute pathname that refers to the file or directory lint in the directory lib, in the directory usr, which is in the root directory. 这里有趣的一点是，我们无法判断joe是文件还是目录。 Home DirectoryWhen we log in, the working directory is set to our home directory. Our home directory is obtained from our entry in the password file (Section 1.3). 当我们登陆的时候，工作目录会设定为home目录，而我们的home目录设置在口令文件中。 1.5 Input and OutputFile Descriptors文件描述符（file descriptor）：File descriptors are normally small non-negative integers that the kernel uses to identify the files accessed by a process. Whenever it opens an existing file or creates a new file, the kernel returns a file descriptor that we use when we want to read or write the file. 文件描述符是一个小的非负整数，内核用它来标识正在被进程访问的文件。打开或者创建文件的时候内核会返回一个文件描述符，我们可以使用这个文件描述符来对文件进行读写。 Standard Input, Standard Output, and Standard Error标准输入，标准输出，标准错误：By convention, all shells open three descriptors whenever a new program is run: standard input, standard output, and standard error. If nothing special is done, as in the simple command 1ls then all three are connected to the terminal. Most shells provide a way to redirect any or all of these three descriptors to any file. For example, 1ls &gt; file.list executes the ls command with its standard output redirected to the file named file.list. 按照惯例，当新程序运行的时候，shell会打开三个文件描述符：标准输入，标准输出，标准错误。如果没有进行指明，那么三个文件描述符都会连接到终端。 Unbuffered I/OUnbuffered I/O is provided by the functions open, read,write, lseek, and close. These functions all work with file descriptors. unbuffered I/O意思是系统不提供buffer管理，要你自己申请buffer，并传递给系统函数。 ExampleIf we’re willing to read from the standard input and write to the standard output, then the program in Figure 1.4 copies any regular file on a UNIX system. Figure 1.4 Copy standard input to standard output 12345678910111213#include "apue.h"#define BUFFSIZE 4096int main(void)&#123; int n; char buf[BUFFSIZE]; while ((n = read(STDIN_FILENO, buf, BUFFSIZE)) &gt; 0) if (write(STDOUT_FILENO, buf, n) != n) err_sys("write error"); if (n &lt; 0) err_sys("read error");trueexit(0); &#125; 下面是对程序的解释： The &lt;unistd.h&gt; header, included by apue.h, and the two constants STDIN_FILENO and STDOUT_FILENO are part of the POSIX standard (about which we’ll have a lot more to say in the next chapter). This header contains function prototypes for many of the UNIX system services, such as the read and write functions that we call. The constants STDIN_FILENO and STDOUT_FILENO are defined in &lt;unistd.h&gt; and specify the file descriptors for standard input and standard output. These values are 0 and 1, respectively, as required by POSIX.1, but we’ll use the names for readability. POSIX.1标准：标准输入是0，标准输出是1，标准错误是2。 The read function returns the number of bytes that are read, and this value is used as the number of bytes to write. When the end of the input file is encountered, read returns 0 and the program stops. If a read error occurs, read returns −1. Most of the system functions return −1 when an error occurs. read函数返回的是读入字节的个数，把这个返回值传给write函数，就可以读多少写多少了，当遇到输入文件结束时，read函数返回0，当遇到错误时，read函数返回-1。许多系统函数返回-1，当它们遇到错误时。 If we compile the program into the standard name (a.out) and execute it as 1./a.out &gt; data standard input is the terminal, standard output is redirected to the file data, and standard error is also the terminal. If this output file doesn’t exist, the shell creates it by default. The program copies lines that we type to the standard output until we type the end-of-file character (usually Control-D). If we run 1./a.out &lt; infile &gt; outfile then the file named infile will be copied to the file named outfile. 如果文件不存在，shell默认给我们创建一个。标准输入和标准错误都是终端，我们可以一直输入，直到输入一个文件结束符，也就是ctrl+d。 Standard I/OThe standard I/O functions provide a buffered interface to the unbuffered I/O functions. Using standard I/O relieves us from having to choose optimal buffer sizes, such as the BUFFSIZE constant in Figure 1.4. The standard I/O functions also simplify dealing with lines of input (a common occurrence in UNIX applications). The fgets function, for example, reads an entire line. The read function, in contrast, reads a specified number of bytes. As we shall see in Section 5.4, the standard I/O library provides functions that let us control the style of buffering used by the library. 标准I/O函数给unbuffered I/O 函数提供了缓冲接口，使用标准I/O函数可以让我们从优化buffer大小中解脱出来，举个例子，fgets函数直接读取一整行，而read函数读取固定个数的字节。 The most common standard I/O function is printf. In programs that call printf, we’ll always include &lt;stdio.h&gt;—normally by including apue.h—as this header contains the function prototypes for all the standard I/O functions. ExampleThe program in Figure 1.5, which we’ll examine in more detail in Section 5.8, is like the previous program that called read and write. This program copies standard input to standard output and can copy any regular file. Figure 1.5 Copy standard input to standard output, using standard I/O 1234567891011#include "apue.h"int main(void)&#123;trueint c; while ((c = getc(stdin)) != EOF) if (putc(c, stdout) == EOF) err_sys("output error"); if (ferror(stdin)) err_sys("input error");trueexit(0);&#125; The function getc reads one character at a time, and this character is written by putc. After the last byte of input has been read, getc returns the constant EOF (defined in &lt;stdio.h&gt;). The standard I/O constants stdin and stdout are also defined in the &lt;stdio.h&gt; header and refer to the standard input and standard output. 1.6 Programs and ProcessesProgramA program is an executable file residing on disk in a directory. A program is read into memory and is executed by the kernel as a result of one of the seven exec functions. Processes and Process IDAn executing instance of a program is called a process, a term used on almost every page of this text. Some operating systems use the term task to refer to a program that is being executed. 程序运行的一个实例叫做：进程，也有些操作系统使用：task这个术语来描述被执行的程序。 The UNIX System guarantees that every process has a unique numeric identifier called the process ID. The process ID is always a non-negative integer. unix系统保证每个进程都有独一无二的进程ID，这个进程ID是一个非负整数。 ExampleThe program in Figure 1.6 prints its process ID. Figure 1.6 Print the process ID 123456#include "apue.h"int main(void)&#123; printf("hello world from process ID %ld\n", (long)getpid()); exit(0); &#125; 输出结果： 1234➜ apue.3e ./fig1.6hello world from process ID 8080➜ apue.3e ./fig1.6hello world from process ID 8086 Process ControlThere are three primary functions for process control: fork, exec, and waitpid. (The exec function has seven variants, but we often refer to them collectively as simply the exec function.) 有三个进程控制的基本函数：fork，exec和waitpid，虽然exec函数有7种变体，但我们往往简单的用一个exec来表示它们。 ExampleThe process control features of the UNIX System are demonstrated using a simple program (Figure 1.7) that reads commands from standard input and executes the commands. This is a bare-bones implementation of a shell-like program. Figure 1.7 Read commands from standard input and execute them 1234567891011121314151617181920212223242526272829#include "include/apue.h"#include &lt;sys/wait.h&gt;int main(void)&#123; char buf[MAXLINE]; /* from apue.h */ pid_t pid; int status; printf("%% "); /* print prompt (printf requires %% to print %) */ while (fgets(buf, MAXLINE, stdin) != NULL) &#123; if (buf[strlen(buf) - 1] == '\n') buf[strlen(buf) - 1] = 0; /* replace newline with null */ if ((pid = fork()) &lt; 0) &#123; err_sys("fork error"); &#125; else if (pid == 0) &#123; /* child */ execlp(buf, buf, (char *)0); // or // execlp(buf, buf, (char *)NULL); err_ret("couldn’t execute: %s", buf); exit(127);truetrue&#125; /* parent */ if ((pid = waitpid(pid, &amp;status, 0)) &lt; 0) err_sys("waitpid error"); printf("%% ");true&#125;trueexit(0); &#125; There are several features to consider in this 30-line program. We use the standard I/O function fgets to read one line at a time from the standard input. When we type the end-of-file character (which is often Control-D) as the first character of a line, fgets returns a null pointer, the loop stops, and the process terminates. In Chapter 18, we describe all the special terminal characters—end of file, backspace one character, erase entire line, and so on—and how to change them. 我们使用了标准I/O函数fgets来一次读取标准输入的一行。当我们直接输入一个EOF时，fgets返回一个空指针，循环停止，进程终止。在第18章，我们将讲述特殊终止符，比如：end of file，backspace one character, erase entire line, 等等，以及如何改变它们。 Because each line returned by fgets is terminated with a newline character, followed by a null byte, we use the standard C function strlen to calculate the length of the string, and then replace the newline with a null byte. We do this because the execlp function wants a null-terminated argument, not a newline-terminated argument. 因为fgets返回的每一行都被一个换行符终止，换行符之后是一个空字符，我们使用标准C函数strlen来计算string的长度，然后将换行符替换成空字符（这样末尾就两个空字符了）。我们这样做是因为execlp函数希望有一个空字符来作为结尾参数，而不是一个换行符。 We call fork to create a new process, which is a copy of the caller. We say that the caller is the parent and that the newly created process is the child. Then fork returns the non-negative process ID of the new child process to the parent, and returns 0 to the child. Because fork creates a new process, we say that it is called once—by the parent—but returns twice—in the parent and in the child. 我们调用fork创建一个新进程，这个新进程是调用进程的一个复制。我们说，调用者是父进程，新创建出来的进程是子进程。然后fork返回子进程的非负进程ID给父进程，并返回0给子进程。因为fork创建了一个新进程，我们说它调用了一次（被父进程），但是返回了两次，在父进程和子进程里面。 In the child, we call execlp to execute the command that was read from the standard input. This replaces the child process with the new program file. The combination of fork followed by exec is called spawning a new process on some operating systems. In the UNIX System, the two parts are separated into individual functions. We’ll say a lot more about these functions in Chapter 8. 在子进程中，我们调用execlp来执行从标注输入中读取来的命令。这就把子进程替换成了新执行的程序。fork后面跟个exec这种结合方式被叫做 spawning a new process 在某些操作系统中。在unix系统中，这两部分被分别放到了两个单独的函数中。我们将在第8章中讨论更多的这类函数。 Because the child calls execlp to execute the new program file, the parent wants to wait for the child to terminate. This is done by calling waitpid, specifying which process to wait for: the pid argument, which is the process ID of the child. The waitpid function also returns the termination status of the child—the status variable—but in this simple program, we don’t do anything with this value. We could examine it to determine how the child terminated. 因为子进程调用了execlp来执行新程序文件，父进程想要等子进程结束。通过调用waitpid可以完成这个任务，用pid（子进程的进程ID）参数来明确需要等待哪个进程。waitpid函数同样也返回子进程的终止状态（记录在status这个参数），但在这个简单的程序里，我们没有用到这个值。我们通过这个值得知子进程是如何结束的。 The most fundamental limitation of this program is that we can’t pass arguments to the command we execute. We can’t, for example, specify the name of a directory to list. We can execute ls only on the working directory. To allow arguments would require that we parse the input line, separating the arguments by some convention, probably spaces or tabs, and then pass each argument as a separate parameter to the execlp function. Nevertheless, this program is still a useful demonstration of the UNIX System’s process control functions. 这个程序最大的限制就是，我们不能传递参数给我们要执行的命令。比如，我们不能给定一个目录给list程序（展示目录下的所有目录和文件的程序）。我们只能在当前目录下执行ls。如果要允许传递参数，就需要我们分析输入行，按照惯例，比如空格或者制表符，把参数分割开来，然后把参数传给execlp函数。不管怎么说，这个程序已经很好的展示了unix系统是如何控制函数的。 If we run this program, we get the following result. Note that our program has a different prompt—the percent sign—to distinguish it from the shell’s prompt. 123456789➜ apue.3e ./fig1.7% pwd/Users/liuqinh2s/Downloads/apue.3e% wholiuqinh2s console May 21 12:09liuqinh2s ttys000 May 21 12:10% date2018年 5月24日 星期四 15时26分59秒 CST% % ➜ apue.3e The notation ˆD is used to indicate a control character. Control characters are special characters formed by holding down the control key—often labeled Control or Ctrl—on your keyboard and then pressing another key at the same time. Control-D, or ˆD, is the default end-of-file character. We’ll see many more control characters when we discuss terminal I/O in Chapter 18. ^D这种记法用于表示控制字符，控制字符是一类特殊的字符，由ctrl键加一个其他键组成，Control-D或者说^D是默认的文件终止符。我们将在第18章讨论输入输出终止符的时候看到更多的控制字符。 Threads and Thread IDsUsually, a process has only one thread of control—one set of machine instructions executing at a time. Some problems are easier to solve when more than one thread of control can operate on different parts of the problem. Additionally, multiple threads of control can exploit the parallelism possible on multiprocessor systems. All threads within a process share the same address space, file descriptors, stacks, and process-related attributes. Each thread executes on its own stack, although any thread can access the stacks of other threads in the same process. Because they can access the same memory, the threads need to synchronize access to shared data among themselves to avoid inconsistencies. 属于同一个进程的多个线程共享同一块内存空间，文件描述符，栈，以及和进程相关的属性。每个线程都在自己的栈里面执行，但每个线程又能访问其他线程的栈（同属于一个进程的多个线程）。因为它们能访问同一块内存，所以为了避免不一致性，需要保护好临界资源。 Like processes, threads are identified by IDs. Thread IDs, however, are local to a process. A thread ID from one process has no meaning in another process. We use thread IDs to refer to specific threads as we manipulate the threads within a process. 就像进程一样，线程也用ID标识。然而线程ID是局部的，只在某个进程内有效，出了这个进程，对其他进程来说这个线程ID就没有任何意义了。 threads were added to the UNIX System long after the process model was established 1.7 Error HandlingWhen an error occurs in one of the UNIX System functions, a negative value is often returned, and the integer errno is usually set to a value that tells why. For example, the open function returns either a non-negative file descriptor if all is OK or −1 if an error occurs. An error from open has about 15 possible errno values, such as file doesn’t exist, permission problem, and so on. Some functions use a convention other than returning a negative value. For example, most functions that return a pointer to an object return a null pointer to indicate an error. 当unix系统函数出错时，会返回一个负数，整形变量errno会设置为一个值，这个值告诉我们为什么出错。例如，open函数返回一个非负的文件描述符，如果成功的话，如果出现错误则返回一个-1。open函数返回的错误有15个可能的errno值，比如：文件不存在，权限问题，等等。有些函数使用另一个传统而非返回一个负数。例如，很多函数返回一个对象指针，或者一个空指针如果出现错误。 The file &lt;errno.h&gt; defines the symbol errno and constants for each value that errno can assume. Each of these constants begins with the character E. Also, the first page of Section 2 of the UNIX system manuals, named intro(2), usually lists all these error constants. For example, if errno is equal to the constant EACCES, this indicates a permission problem, such as insufficient permission to open the requested file. &lt;errno.h&gt;文件定义了变量errno和一系列常量（errno可能的值）。每个常量都以字符E开头。unix系统手册intro(2)展示了这些常量。例如，如果errno等于常量EACCES，就表示是权限问题，没有足够的权限去打开这个文件。 On Linux, the error constants are listed in the errno(3) manual page. POSIX and ISO C define errno as a symbol expanding into a modifiable lvalue of type integer. This can be either an integer that contains the error number or a function that returns a pointer to the error number. The historical definition is 1extern int errno; But in an environment that supports threads, the process address space is shared among multiple threads, and each thread needs its own local copy of errno to prevent one thread from interfering with another. Linux, for example, supports multithreaded access to errno by defining it as 12extern int *__errno_location(void); #define errno (*__errno_location()) POSIX和ISO C把errno定义为一个可以修改的左值。可以定义为一个整形值，也可以定义为一个指针，指针指向错误码（String类型）。如果是多线程环境下，每个线程都有自己的一个errno拷贝。通过宏定义把errno给替换成函数：int *__errno_location(void);了。 There are two rules to be aware of with respect to errno. First, its value is never cleared by a routine if an error does not occur. Therefore, we should examine its value only when the return value from a function indicates that an error occurred. Second, the value of errno is never set to 0 by any of the functions, and none of the constants defined in &lt;errno.h&gt; has a value of 0. 第一，如果没有出错，errno的值不会被重置，因此，我们只有在函数返回出错的时候才检查errno；第二，errno不会等于0。 Two functions are defined by the C standard to help with printing error messages. 123#include &lt;string.h&gt;char *strerror(int errnum); //Returns: pointer to message string This function maps errnum, which is typically the errno value, into an error message string and returns a pointer to the string. The perror function produces an error message on the standard error, based on the current value of errno, and returns. 123#include &lt;stdio.h&gt;void perror(const char* msg); It outputs the string pointed to by msg, followed by a colon and a space, followed by the error message corresponding to the value of errno, followed by a newline. ExampleFigure 1.8 shows the use of these two error functions. Figure 1.8 Demonstrate strerror and perror 123456789#include "apue.h"#include &lt;errno.h&gt;int main(int argc, char *argv[])&#123; fprintf(stderr, "EACCES: %s\n", strerror(EACCES)); errno = ENOENT; perror(argv[0]); exit(0);&#125; 输出结果： 1234➜ apue.3e ./fig1.8EACCES: Permission denied./fig1.8: No such file or directory➜ apue.3e argv[0] 表示输入的第一个参数，也就是命令名 Error RecoveryThe errors defined in &lt;errno.h&gt; can be divided into two categories: fatal and nonfatal. A fatal error has no recovery action. The best we can do is print an error message on the user’s screen or to a log file, and then exit. Nonfatal errors, on the other hand, can sometimes be dealt with more robustly. Most nonfatal errors are temporary, such as a resource shortage, and might not occur when there is less activity on the system. 定义在&lt;errno.h&gt;中的错误可以分为两类：fatal和nonfatal，致命和非致命。致命错误没有恢复动作，我们最多能做的就是把错误信息在用户显示屏上打印出来，或者写到log文件里，然后退出。非致命错误，可以更妥善的处理，许多非致命错误都是暂时的，比如：资源短缺，当系统活动较少时这类错误可能不会发生。 Resource-related nonfatal errors include EAGAIN, ENFILE, ENOBUFS, ENOLCK, ENOSPC, EWOULDBLOCK, and sometimes ENOMEM. EBUSY can be treated as nonfatal when it indicates that a shared resource is in use. Sometimes, EINTR can be treated as a nonfatal error when it interrupts a slow system call (more on this in Section 10.5). The typical recovery action for a resource-related nonfatal error is to delay and retry later. This technique can be applied in other circumstances. For example, if an error indicates that a network connection is no longer functioning, it might be possible for the application to delay a short time and then reestablish the connection. Some applications use an exponential backoff algorithm, waiting a longer period of time in each subsequent iteration. 典型的资源相关性非致命错误的处理办法是先等一下，之后再重试。 Ultimately, it is up to the application developer to determine the cases where an application can recover from an error. If a reasonable recovery strategy can be used, we can improve the robustness of our application by avoiding an abnormal exit. 1.8 User IdentificationUser IDThe user ID from our entry in the password file is a numeric value that identifies us to the system. This user ID is assigned by the system administrator when our login name is assigned, and we cannot change it. The user ID is normally assigned to be unique for every user. We’ll see how the kernel uses the user ID to check whether we have the appropriate permissions to perform certain operations. 用户ID来自口令文件中对应的条目，它是以数字的形式帮助系统对我们进行标识。用户ID是系统管理员给我们分配的（当分配登录名时，同时也必须分配用户ID），我们自己无法改。每个人的用户ID应该是唯一的，内核使用用户ID来检查我们是否有合适的权限来进行一个操作。 We call the user whose user ID is 0 either root or the superuser. The entry in the password file normally has a login name of root, and we refer to the special privileges of this user as superuser privileges. As we’ll see in Chapter 4, if a process has superuser privileges, most file permission checks are bypassed. Some operating system functions are restricted to the superuser. The superuser has free rein over the system. 我们把用户ID为0的用户称为：root或者superuser。口令文件中有一个条目的登录名是root，root用户拥有特殊权限。拥有superuser特权的进程可以自由的使用任意文件，而且有些操作系统函数是只对superuser开放的。superuser拥有对系统的绝对的权限（可以把系统弄残）。 Client versions of Mac OS X ship with the superuser account disabled; server versions ship with the account already enabled. Instructions are available on Apple’s Web site describing how to enable it. See http://support.apple.com/kb/HT1528. Group IDOur entry in the password file also specifies our numeric group ID. This, too, is assigned by the system administrator when our login name is assigned. Typically, the password file contains multiple entries that specify the same group ID. Groups are normally used to collect users together into projects or departments. This allows the sharing of resources, such as files, among members of the same group. We’ll see in Section 4.5 that we can set the permissions on a file so that all members of a group can access the file, whereas others outside the group cannot. Group ID的作用就是让相同组的人共享资源。 There is also a group file that maps group names into numeric group IDs. The group file is usually /etc/group. The use of numeric user IDs and numeric group IDs for permissions is historical. With every file on disk, the file system stores both the user ID and the group ID of a file’s owner. Storing both of these values requires only four bytes, assuming that each is stored as a two-byte integer. If the full ASCII login name and group name were used instead, additional disk space would be required. In addition, comparing strings during permission checks is more expensive than comparing integers. 使用数字的用户ID和组ID是有历史原因的。对于每个存放在磁盘上的文件，文件系统都存储了该文件的拥有者的用户ID和组ID。存储这两个数字需要4字节（每个2字节），如果使用ASCII编码的登录名和组名，需要多用掉很多额外的磁盘空间。另外在检查权限是否合格时，整形数字比较要比字符串比较更快。 Users, however, work better with names than with numbers, so the password file maintains the mapping between login names and user IDs, and the group file provides the mapping between group names and group IDs. The ls -l command, for example, prints the login name of the owner of a file, using the password file to map the numeric user ID into the corresponding login name. 然而对于用户来说名字比数字更好记，所以password file和group file分别记录了登录名和用户ID的映射，组名和组ID的映射。使用ls -l命令，可以看到打印出了文件所属者和所属的组，其原理就是查找了password file和group file，把相应的数字ID换成名字。 Early UNIX systems used 16-bit integers to represent user and group IDs. Contemporary UNIX systems use 32-bit integers. ExampleThe program in Figure 1.9 prints the user ID and the group ID. Figure 1.9 Print user ID and group ID 1234567#include "apue.h"int main(void)&#123;trueprintf("uid = %d, gid = %d\n", getuid(), getgid());trueexit(0); &#125; Supplementary Group IDs附加组（supplementary group）：In addition to the group ID specified in the password file for a login name, most versions of the UNIX System allow a user to belong to other groups. This practice started with 4.2BSD, which allowed a user to belong to up to 16 additional groups. These supplementary group IDs are obtained at login time by reading the file /etc/group and finding the first 16 entries that list the user as a member. As we shall see in the next chapter, POSIX requires that a system support at least 8 supplementary groups per process, but most systems support at least 16. 许多unix系统允许用户属于多个组，最多16个。主组，也就是登陆时的默认组记录在/etc/passwd中。 /etc/group格式如下： 12_analyticsusers:*:250:_analyticsd,_networkd,_timed_analyticsd:*:263:_analyticsd 解释： 1组名:口令:组ID:组内用户列表 1.9 SignalSignals are a technique used to notify a process that some condition has occurred. For example, if a process divides by zero, the signal whose name is SIGFPE (floating-point exception) is sent to the process. The process has three choices for dealing with the signal. 信号是一种用来通知进程发生了某些事的技术。举个例子：当进程除以0时，就会有一个SIGFPE (floating-point exception)发送到这个进程。进程处理信号有三种选择： Ignore the signal. This option isn’t recommended for signals that denote a hardware exception, such as dividing by zero or referencing memory outside the address space of the process, as the results are undefined. 忽视信号。如果是硬件异常不推荐这个选择，例如：被0除，引用进程外的内存，因为这些结果都是不确定的。 Let the default action occur. For a divide-by-zero condition, the default is to terminate the process. 让默认动作出现，比如被0除的情况下，默认是终止该进程。 Provide a function that is called when the signal occurs (this is called ‘‘catching’’ the signal). By providing a function of our own, we’ll know when the signal occurs and we can handle it as we wish. 我们自己提供一个函数捕获信号，这样我们就能让程序以我们的意愿处理异常。 Many conditions generate signals. Two terminal keys, called the interrupt key— often the DELETE key or Control-C—and the quit key—often Control-backslash—are used to interrupt the currently running process. Another way to generate a signal is by calling the kill function. We can call this function from a process to send a signal to another process. Naturally, there are limitations: we have to be the owner of the other process (or the superuser) to be able to send it a signal. 很多条件下可以生成信号，终端键有两种，interrupt key（delete键或者ctrl+c）和 quit key（ctrl+\）。另一个生成信号的方法是调用kill函数，我们可以在一个进程里调用kill函数来结束另一个进程，但我们需要有权限（如果我们是另一个进程的拥有者，或者是超级用户，就可以）。 ExampleRecall the bare-bones shell example (Figure 1.7). If we invoke this program and press the interrupt key, the process terminates because the default action for this signal, named SIGINT, is to terminate the process. The process hasn’t told the kernel to do anything other than the default with this signal, so the process terminates. 如果直接执行Figure 1.7的代码，我们按下中断键，程序就会终止，因为这个SIGINT信号的默认动作就是终止进程。 To catch this signal, the program needs to call the signal function, specifying the name of the function to call when the SIGINT signal is generated. The function is named sig_int; when it’s called, it just prints a message and a new prompt. Adding 11 lines to the program in Figure 1.7 gives us the version in Figure 1.10. (The 11 new lines are indicated with a plus sign at the beginning of the line.) 为了捕获这个信号，程序需要调用一个信号函数。我们给它命名为：sig_int函数，在捕获到SIGINT信号之后，打印信息并打印一个新的提示符。下面的程序相比Figure 1.7多了11行，用+号标识了。 Figure 1.10 Read commands from standard input and execute them 123456789101112131415161718192021222324252627282930313233343536 #include "include/apue.h" #include &lt;sys/wait.h&gt; + static void sig_int(int); /* our signal-catching function */+ int main(void) &#123; char buf[MAXLINE]; /* from apue.h */ pid_t pid; int status; + if(signal(SIGINT, sig_int) == SIG_ERR) err_sys("signal error"); printf("%% "); /* print prompt (printf requires %% to print %) */ while (fgets(buf, MAXLINE, stdin) != NULL) &#123; if (buf[strlen(buf) - 1] == '\n') buf[strlen(buf) - 1] = 0; /* replace newline with null */ if ((pid = fork()) &lt; 0) &#123; err_sys("fork error"); &#125; else if (pid == 0) &#123; /* child */ execlp(buf, buf, (char *)0); err_ret("couldn’t execute: %s", buf); exit(127);truetrue &#125; /* parent */ if ((pid = waitpid(pid, &amp;status, 0)) &lt; 0) err_sys("waitpid error"); printf("%% ");true &#125;true exit(0); &#125;++ void sig_int(int signo)&#123;+ printf("interrupt\n%% ");+ &#125; 1.10 Time ValuesHistorically, UNIX systems have maintained two different time values: Calendar time. This value counts the number of seconds since the Epoch: 00:00:00 January 1, 1970,Coordinated Universal Time (UTC). (Older manuals refer to UTC as Greenwich Mean Time.) These time values are used to record the time when a file was last modified, for example. The primitive system data type time_t holds these time values. Process time. This is also called CPU time and measures the central processor resources used by a process. Process time is measured in clock ticks, which have historically been 50, 60, or 100 ticks per second. The primitive system data type clock_t holds these time values. (We’ll show how to obtain the number of clock ticks per second with the sysconf function in Section 2.5.4.) 有两种类型的时间：日历时间和进程时间，日历时间也就是UTC。 When we measure the execution time of a process, as in Section 3.9, we’ll see that the UNIX System maintains three values for a process: Clock time User CPU time System CPU time The clock time, sometimes called wall clock time, is the amount of time the process takes to run, and its value depends on the number of other processes being run on the system. Whenever we report the clock time, the measurements are made with no other activities on the system. The user CPU time is the CPU time attributed to user instructions. The system CPU time is the CPU time attributed to the kernel when it executes on behalf of the process. For example, whenever a process executes a system service, such as read or write, the time spent within the kernel performing that system service is charged to the process. The sum of user CPU time and system CPU time is often called the CPU time. 度量进程执行时间，有三种： 墙上时钟，也就是进程执行花费的总时间。 用户CPU时间，是用户模式（非内核）下的CPU使用时间 系统CPU时间，是进程进入内核执行的CPU使用时间 It is easy to measure the clock time, user time, and system time of any process: simply execute the time(1) command, with the argument to the time command being the command we want to measure. For example: 12$ cd /usr/include$ time -p grep _POSIX_SOURCE */*.h &gt; /dev/null 结果： 123real 0m0.81suser 0m0.11ssys 0m0.07s The output format from the time command depends on the shell being used, because some shells don’t run /usr/bin/time, but instead have a separate built-in function to measure the time it takes commands to run. time命令的输出格式取决于使用什么shell，因为有些shell并不运行：/usr/bin/time，而是运行自己内置的一个time函数。 1.11 System Calls and Library FunctionsAll operating systems provide service points through which programs request services from the kernel. All implementations of the UNIX System provide a well-defined, limited number of entry points directly into the kernel called system calls (recall Figure 1.1). Version 7 of the Research UNIX System provided about 50 system calls, 4.4BSD provided about 110, and SVR4 had around 120. The exact number of system calls varies depending on the operating system version. More recent systems have seen incredible growth in the number of supported system calls. Linux 3.2.0 has 380 system calls and FreeBSD 8.0 has over 450. 随着时间的推移，系统调用越来越多，可见系统是越来越完善的。 The system call interface has always been documented in Section 2 of the UNIX Programmer’s Manual. Its definition is in the C language, no matter which implementation technique is actually used on any given system to invoke a system call. This differs from many older operating systems, which traditionally defined the kernel entry points in the assembly language of the machine. 系统调用的文档总是在unix编程手册的第二个章节里。它是用C语言定义的，不管系统具体是如何实现系统调用的。这一点与很多老操作系统不同（老操作系统使用汇编语言定义内核接口） The technique used on UNIX systems is for each system call to have a function of the same name in the standard C library. The user process calls this function, using the standard C calling sequence. This function then invokes the appropriate kernel service, using whatever technique is required on the system. For example, the function may put one or more of the C arguments into general registers and then execute some machine instruction that generates a software interrupt in the kernel. For our purposes, we can consider the system calls to be C functions. 每个系统调用都对应一个相同名字的函数在标准C库里。用户进程调用这个函数，然后这个函数调用相应的内核服务。举个例子，这个函数可能会把一个或多个C参数放到通用寄存器，并执行机器指令在内核中产生一个软件中断。从我们的角度看，我们可以直接认为系统调用就是C函数。 Section 3 of the UNIX Programmer’s Manual defines the general-purpose library functions available to programmers. These functions aren’t entry points into the kernel, although they may invoke one or more of the kernel’s system calls. For example, the printf function may use the write system call to output a string, but the strcpy (copy a string) and atoi (convert ASCII to integer) functions don’t involve the kernel at all. 在unix编程手册第三章定义了通用库函数给程序员。这些函数不是内核入口，虽然它们可能会调用一个或几个内核的系统调用。举个例子，printf函数可能会使用write系统调用来输出一个字符串，但是strcpy（拷贝一个字符串）和atoi（吧ASCII字符转成整形）函数根本没有调用内核。 From an implementor’s point of view, the distinction between a system call and a library function is fundamental. From a user’s perspective, however, the difference is not as critical. From our perspective in this text, both system calls and library functions appear as normal C functions. Both exist to provide services for application programs. We should realize, however, that we can replace the library functions, if desired, whereas the system calls usually cannot be replaced. 从实现者的角度来看，系统调用和库函数的区别是很大的。然而从使用者的角度来看，这个区别并不重要。在这本书中，在我们看来，系统调用和库函数都以C函数的形式出现。两者的存在都是为了给应用开发者提供服务。然而我们应该意识到，虽然我们能替换库函数（如果我们想这样做），但系统调用不能被替换。 Consider the memory allocation function malloc as an example. There are many ways to do memory allocation and its associated garbage collection (best fit, first fit, and so on). No single technique is optimal for all programs. The UNIX system call that handles memory allocation, sbrk(2), is not a general-purpose memory manager. It increases or decreases the address space of the process by a specified number of bytes. How that space is managed is up to the process. The memory allocation function, malloc(3), implements one particular type of allocation. If we don’t like its operation, we can define our own malloc function, which will probably use the sbrk system call. In fact, numerous software packages implement their own memory allocation algorithms with the sbrk system call. Figure 1.11 shows the relationship between the application, the malloc function, and the sbrk system call. 让我们来看看内存分配函数malloc这个例子。有很多内存分配和相关的垃圾回收方法（最好适应算法，最先适应算法，等等）。没有哪个技术是对所有程序优化的。unix系统调用sbrk(2)不是一个通用的存储管理器。它给进程增加和减少内存空间都是固定的字节数。怎么管理空间其实还要取决于进程自己。内存分配函数malloc(3)，实现了特定类型的分配。如果我们不喜欢它的做法，我们可以定义自己的malloc函数，但也是要用到sbrk系统调用的。实际上大量的软件包都通过直接使用sbrk系统调用实现了自己的内存管理算法。图1.11展示了应用，malloc函数，和sbrk系统调用之间的关系。 Here we have a clean separation of duties: the system call in the kernel allocates an additional chunk of space on behalf of the process. The malloc library function manages this space from user level. 这里职责是分明的：系统调用代表进程在内核里分配了额外的一块空间。malloc库函数在用户层级上管理这块空间。 Another example to illustrate the difference between a system call and a library function is the interface the UNIX System provides to determine the current time and date. Some operating systems provide one system call to return the time and another to return the date. Any special handling, such as the switch to or from daylight saving time, is handled by the kernel or requires human intervention. The UNIX System, in contrast, provides a single system call that returns the number of seconds since the Epoch: midnight, January 1, 1970, Coordinated Universal Time. Any interpretation of this value, such as converting it to a human-readable time and date using the local time zone, is left to the user process. The standard C library provides routines to handle most cases. These library routines handle such details as the various algorithms for daylight saving time. 另一个描述系统调用和库函数不同的例子是当前时间和日期。某些操作系统提供一个系统调用返回时间，另一个系统调用返回日期。任何特殊的处理，比如正常时制与夏令时的切换，需要内核的处理或者人为干预。Unix系统则相反，只提供一个系统调用，返回UTC（UTC是指从1970年的第一秒开始算起到现在经过的总时间）。任何对UTC这个值的解释，例如把它转成人类可读的时间日期使用当地时间，就留给了用户进程。标准C库提供了诸多例程来处理大多数情况。这些库例程处理这些细节，就像大多数算法处理夏令时切换一样。 An application can either make a system call or call a library routine. Also realize that many library routines invoke a system call. This is shown in Figure 1.12. 一个应用可以使用系统调用或者调用库例程，同样要意识到许多库例程调用了系统调用。 Another difference between system calls and library functions is that system calls usually provide a minimal interface, whereas library functions often provide more elaborate functionality. We’ve seen this already in the difference between the sbrk system call and the malloc library function. We’ll see this difference again later, when we compare the unbuffered I/O functions (Chapter 3) and the standard I/O functions (Chapter 5). 另一个系统调用和库函数的区别就是，系统调用往往只提供一个很小的接口，然而库函数经常提供更多精细的功能。 The process control system calls (fork, exec, and waitpid) are usually invoked by the user’s application code directly. (Recall the bare-bones shell in Figure 1.7.) But some library routines exist to simplify certain common cases: the system and popen library routines, for example. In Section 8.13, we’ll show an implementation of the system function that invokes the basic process control system calls. We’ll enhance this example in Section 10.18 to handle signals correctly. To define the interface to the UNIX System that most programmers use, we have to describe both the system calls and some of the library functions. If we described only the sbrk system call, for example, we would skip the more programmer-friendly malloc library function that many applications use. In this text, we’ll use the term function to refer to both system calls and library functions, except when the distinction is necessary.]]></content>
      <categories>
        <category>Unix</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux Shell 配色]]></title>
    <url>%2Fblog%2F2018%2F05%2F08%2FLinux-Shell-%E9%85%8D%E8%89%B2%2F</url>
    <content type="text"><![CDATA[早就想自己给bash配个色，但是一直没空学习这方面的知识，今天抽个空，搞了一点点。 切换shell切换shell，分临时和永久。 临时：输入命令：bash或者zsh都行，shell调用shell，一层套一层，按ctrl+d或者输入exit可以退出。永久：输入命令：chsh -s /bin/bash chsh意思就是change shell，使用man chsh进行查看 修改promptprompt也就是提示符，首先就是要修改这个，什么样的提示符才是一个好的提示符呢？我觉得首要的是要短，太长的提示符占了命令的空间。其次提示符还必须显示用户名和机器名，因为只有这样才能在你远程登录的时候与远程shell区分开。机器名最好是缩写。然后我就得出了我自己的提示符的前缀：liuqinh2s@mbp，然后我觉得得加个短路径，不要求绝对路径，这样太占空间，只需要加个当前文件夹即可。这样进一步修改之后，我的提示符变成了：liuqinh2s@mbp:~，最后需要添加一个普通用户和超级用户的区分，普通用户用：$，超级用户用#，所以我的提示符最终的样子是：liuqinh2s@mbp:~$，注意$后面我加了一个空格，这样看起来比较舒服，提示符和命令的界限一目了然。 但其实还是不清晰，我就给prompt上了个颜色。 最后就变成这样啦： 配置代码：PS1=&quot;\[\e[0;32m\]\u@\h:\[\e[0;34m\]\W\$\[\e[0m\] &quot; 使用export PS1=&quot;\[\e[0;32m\]\u@\h:\[\e[0;34m\]\W\$\[\e[0m\] &quot;，这样的话，你输入bash的时候，也能用到你的配置 export in sh and related shells (such as bash), marks an environment variable to be exported to child-processes, so that the child inherits them. export的作用就是让子进程也继承环境变量 如果你用的是mac的话，在home目录的.bash_profile中修改就可以了 下面是配置代码的讲解： Bash转义序列1234567891011121314151617181920212223242526272829\a an ASCII bell character (07)\d the date in &quot;Weekday Month Date&quot; format (e.g., &quot;Tue May 26&quot;)\D&#123;format&#125; the format is passed to strftime(3) and the result is inserted into the prompt string; an empty format results in a locale- specific time representation. The braces are required\e an ASCII escape character (033)\h the hostname up to the first `.&apos;\H the hostname\j the number of jobs currently managed by the shell\l the basename of the shell&apos;s terminal device name\n newline\r carriage return\s the name of the shell, the basename of $0 (the portion following the final slash)\t the current time in 24-hour HH:MM:SS format\T the current time in 12-hour HH:MM:SS format\@ the current time in 12-hour am/pm format\A the current time in 24-hour HH:MM format\u the username of the current user\v the version of bash (e.g., 2.00)\V the release of bash, version + patch level (e.g., 2.00.0)\w the current working directory, with $HOME abbreviated with a tilde (uses the value of the PROMPT_DIRTRIM variable)\W the basename of the current working directory, with $HOME abbreviated with a tilde\! the history number of this command\# the command number of this command\$ if the effective UID is 0, a #, otherwise a $\nnn the character corresponding to the octal number nnn\\ a backslash\[ begin a sequence of non-printing characters, which could be used to embed a terminal control sequence into the prompt\] end a sequence of non-printing characters 变更prompt颜色首先，大家必须以[与]作为色彩代码的描述范围。对于Bash，这代表两个括号间的字符为非输出字符。 Bash需要在此基础上估算字符数量，以备后续输出。如果不将色彩代码纳入[与]之间，那么Bash会将全部字符都计为文本字符并在下一行中进行打包。 另外，在括号内的非输出序列中，我们需要输入\e[或者\033[指定彩色prompt的起点。二者的作用相同，都负责指定该反义序列的起始位置。 在]之前，我们还需要使用“m”来表示即将提供一条色彩序列。 基本上，每次进行色彩修改时，我们都需要输入下面这种命令格式： 1\[\e[color_informationm\] 下面来看用于变更前景文本颜色的基本代码： 30: Black 31: Red 32: Green 33: Yellow 34: Blue 35: Purple 36: Cyan 37: White 大家也可以通过在以上设定前设置“属性”修改这些基础值，各值之间以分号分隔。 根据实际终端的不同，操作效果也有所区别。部分常见属性包括： 0: 普通文本 1: 在不同终端中可能代表粗体或者浅色显示 4: 下划线文本 因此如果大家希望使用下划线绿色文本，则：\[\e[4;32m\] 接下来继续正常使用即可。另外，我们也可以随时将色彩重置为初始值。 重置命令如下： 1\[\e[0m\] 我们也可以指定背景颜色。背景颜色无法获取属性，具体包括： 40: Black background 41: Red background 42: Green background 43: Yellow background 44: Blue background 45: Purple background 46: Cyan background 47: White background 不过大家可以一次性指定背景颜色、属性与文本颜色： 1\[\e[42;1;36m\] 当然，这里建议各位将背景信息与其它信息分隔开来： 1\[\e[42m\]\[\e[1;36m\] 在使用普通文本属性（0）时，终端中可能出现一些乱码。如果遇到这种问题，大家最好避免使用0值指定普通属性——由于属于默认值，我们无需额外指定。 配置ls和grep的颜色123456# Tell ls to be colourful export CLICOLOR=1 export LSCOLORS=Exfxcxdxbxegedabagacad # Tell grep to highlight matches export GREP_OPTIONS=&apos;--color=auto’ CLICOLOR是用来设置是否进行颜色的显示。CLI是Command Line Interface的缩写。 LSCOLORS是用来设置当CLICOLOR被启用后，各种文件类型的颜色。LSCOLORS的值中每两个字母为一组，分别设置某个文件类型的文字颜色和背景颜色。LSCOLORS中一共11组颜色设置，按照先后顺序，分别对以下的文件类型进行设置： 所以，如果我们想把目录显示成红色，就可以把LSCOLORS设置为fxfxaxdxcxegedabagacad就可以了]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[对区块链以及未来的一些思考]]></title>
    <url>%2Fblog%2F2018%2F05%2F07%2F%E5%AF%B9%E5%8C%BA%E5%9D%97%E9%93%BE%E4%BB%A5%E5%8F%8A%E6%9C%AA%E6%9D%A5%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[有个用户痛点，我来描述一下：当你更改了手机号，it’s a disaster! 你需要改无数绑定的东西，比如：银行预留手机号，各类APP的绑定手机号，还要通知所有人你改了手机号，当然我现在换手机号也懒得通知别人了，除了还给我打电话的那几个人，现在大家都是用QQ和微信沟通了。 我说个笑话，不，其实这是个真实的故事，我曾今在深圳用过摩拜共享单车，当时绑定了我的手机号，后来我在杭州，并且手机号也换了，另外摩拜也加了个身份证验证。我就再也使用不了摩拜了，好像是因为手机号和身份证绑定了，我无法通过其他手机号使用摩拜了。摩拜让我交了200块钱押金，让我充了10块钱车费，最后却告诉我，我不能骑车。我只好申诉，申诉没起效果，最后我直接申请退款了，退款理由我写上了：无法实名认证。我希望以此能够催促摩拜尽早改好这个BUG，从而帮助到其他人吧。 还有就是各种证，从身份证开始，学位证，毕业证，结婚证，团员证，党员证，房产证。。。 还有一些事是大家都知道的，三鹿奶粉，三聚氰胺，地沟油，等等。 那么这些事之间有什么联系呢？ 有，当然有，那就是：信任。 如何让别人信任你，如何让我们信任那些企业，如何做到一个账号上网，或者说不用麻烦的认证，你上网，网就认识你，从这个网站到那个网站，不需要繁琐的注册登陆。 区块链貌似能解决这个问题，如果我们的信息都放在一起，需要的时候就去查看，而且有严格的权限限制，那么我们就建立了一个统一的信息源。]]></content>
      <categories>
        <category>区块链</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[用ipfs发布博客]]></title>
    <url>%2Fblog%2F2018%2F05%2F04%2F%E7%94%A8ipfs%E5%8F%91%E5%B8%83%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[ipfs是一个p2p的网络 常用ipfs命令123ipfs add -r mysite// 通过上一步可以得到很多个哈希值（每个目录和文件都有一个），把根目录对应的哈希值拿出来用ipfs name publish QmZyenFLZtm9rk2B98ZqRAFYRkzhqyUruKBSsdZUnKk9ek 第二步实际上是把这个站点的根目录映射到了你的 ipfs id 上面，你的这个id是固定的。之后你每次更新这个站点下的内容都要 ipfs add -r mysite 一次，然后把根目录对应的哈希值重新映射到你的 ipfs id 上。 然后你访问ipfs站点的时候，可以这样访问：https://ipfs.io/ipns/your_ipfs_id，如果你的浏览器装了ipfs插件就可以自动解析这个网址，从而直接用ipfs协议来访问站点了。 注意your_ipfs_id是指你的ipfs id，你可以用命令ipfs id查看你的id是什么，相信我的读者不会蠢到直接复制粘贴your_ipfs_id。 hexo生成的博客，缺失css和js的问题在hexo的config里面，有个root，这个root就是用来给css和js等资源指定目录的，所以你要改成：/ipns/your_ipfs_id/ 如果你想同时在git pages上面，和ipfs上面发布你的博客，那么root这个属性必定就冲突了，因为在git pages上面发布的时候，直接填/就行了（他是直接发布在像：liuqinh2s.github.io，这个域名后面，也就是子域名的根目录，不像ipfs那样会加个/ipns/your_ipfs_id这种目录）。那么你就只能搞两个博客工程了，新发布博客的时候，就要同时修改两个地方。 比如我是这样做的，我建了一个ipfs文件夹，里面存放我所有发布在ipfs上的资源，所以我会把我的博客复制一份到这个文件夹里面，更新博客的时候，复制一份博客文件到这边，git pages那边要发布一次，然后ipfs这边也要发布一次。 访问我的ipfs站点：https://ipfs.io/ipns/QmT7mga4wwTLNFCrtt1FbvLgmxTWZyKGRsrnFZNMoHdEJa/ 使用脚本自动化push为了实现自动push，我自己写了个脚本，可以同时把博客push到git pages和ipfs上：https://gist.github.com/liuqinh2s/0864ed7799b161bb2f048b4fab867d5a 在你的博客目录下新建一个push.sh，然后把代码复制粘贴，保存，以后每次push的时候执行：bash push.sh]]></content>
      <categories>
        <category>区块链</category>
        <category>ipfs</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Volley库StringRequest编码问题]]></title>
    <url>%2Fblog%2F2018%2F05%2F03%2FVolley%E5%BA%93StringRequest%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最近在做的一个工作是：从一个URL地址读取一系列手机联系人资料，保持到手机通讯录里面。 项目使用了Volley库，FastJson库，遇到的一个bug是编码错误，FastJson在进行从String到bean的解析的时候，编码不正确导致的出错，这个时候，先检查了URL的编码是UTF-8的，然后Android Studio的程序源文件也是UTF-8的，那就只有一个可能了，网络传输过程中的编码错误。 google一下发现早就有人在stackoverflow上问过这个问题了： How to get Android Volley StringRequest GET to return responses in UTF-8 encoding How can I get Android Volley StringRequest GET to return responses in UTF-8 encoding? It only seems to return responses in ISO-8859-1. Is it possible to get it to accept a UTF-8 string? StringRequest call HttpHeaderParser.parseCharset(response.headers) to get charset from response headers, is ‘Content-Type’ in headers don`t contains ‘charset’ the default charset return as ‘ISO-8859-1’. StringRequest.java 12345678910protected Response&lt;String&gt; parseNetworkResponse(NetworkResponse response) &#123; String parsed; try &#123; parsed = new String(response.data, HttpHeaderParser.parseCharset(response.headers)); &#125; catch (UnsupportedEncodingException var4) &#123; parsed = new String(response.data); &#125; return Response.success(parsed, HttpHeaderParser.parseCacheHeaders(response));&#125; HttpHeaderParser.java 123456789101112131415161718192021222324public static String parseCharset(Map&lt;String, String&gt; headers, String defaultCharset) &#123; String contentType = headers.get(HTTP.CONTENT_TYPE); if (contentType != null) &#123; String[] params = contentType.split(";"); for (int i = 1; i &lt; params.length; i++) &#123; String[] pair = params[i].trim().split("="); if (pair.length == 2) &#123; if (pair[0].equals("charset")) &#123; return pair[1]; &#125; &#125; &#125; &#125; return defaultCharset;&#125;/** * Returns the charset specified in the Content-Type of this header, * or the HTTP default (ISO-8859-1) if none can be found. */public static String parseCharset(Map&lt;String, String&gt; headers) &#123; return parseCharset(headers, HTTP.DEFAULT_CONTENT_CHARSET);&#125; so, you can parse to ‘UTF-8’ in 2 ways: tell your webServer to add ‘Content-Type’ with ‘charset=UTF-8’ in headers Create a subclass of StringRequest and override parseNetworkResponse method 意思是定制一个MyStringRequest类，继承StringRequest类，重载parseNetworkResponse即可： 12345678910protected Response&lt;String&gt; parseNetworkResponse(NetworkResponse response) &#123; String parsed; try &#123; parsed = new String(response.data, "utf-8"); &#125; catch (UnsupportedEncodingException var4) &#123; parsed = new String(response.data); &#125; return Response.success(parsed, HttpHeaderParser.parseCacheHeaders(response));&#125;]]></content>
      <categories>
        <category>Android</category>
        <category>Volley库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android通讯录深入研究]]></title>
    <url>%2Fblog%2F2018%2F05%2F03%2FAndroid%E9%80%9A%E8%AE%AF%E5%BD%95%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6%2F</url>
    <content type="text"><![CDATA[The DISPLAY_NAME can be fetched either from Contacts database/ContactsContract.Data&#39; OR &#39;database/ContactsContract.CommonDataKinds.StructuredName&#39; OR &#39;database/RawContactsEntity. In the later 2 cases you will be able to fetch the DISPLAY_NAME using RAW_CONTACT_ID Couple of Key pointers: Contacts._ID = Data.CONTACT_ID RawContacts._ID = Data.RAW_CONTACT_ID RawContacts.CONTACT_ID = Contacts._ID RawContactsEntity._ID = RawContacts._ID Sounds confusing?? Let me try… The Contacts database is divided into 3 tables contacts, raw contacts, and data. Each table contains column (_ID) which is an auto incremented primary key. data table contains all the contact info like phone number, mail id, address etc. The raw contacts points to the actual contact created. Hence we use the raw contacts while adding a contact. The user cannot add any data in the contacts table. The data in this table is populated internally due to aggregation of contacts. The reason your logic worked for some of the contacts is: _ID for contacts, raw contacts remains same until there is any contact aggregation taking place. Lets say you add two contacts with same name abc. Here the _ID for raw contacts increments twice while _ID for contacts increments only once as these two contacts gets merged due to the aggregation of contacts The best approach to fetch the info in your case is by using ContactsContract.RawContactsEntity ( an outer join of the raw_contacts table with the data table) 这里还有一篇文章，写的比较详细：http://android-contact-id-vs-raw-contact-id.blogspot.jp/ 官方文档： https://developer.android.com/reference/android/provider/ContactsContract https://developer.android.com/reference/android/provider/ContactsContract.Data]]></content>
      <categories>
        <category>Android</category>
        <category>通讯录</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java Servlet 学习笔记]]></title>
    <url>%2Fblog%2F2018%2F05%2F01%2FJava-Servlet-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[The difference between servlets and JSP is that servlets typically embed HTML inside Java code, while JSPs embed Java code in HTML. 不过现在都是用MVC框架了。 life cycle of a servletThree methods are central to the life cycle of a servlet. These are init(), service(), and destroy(). They are implemented by every servlet and are invoked at specific times by the server. the web container initializes the servlet instance by calling the init() method, passing an object implementing the javax.servlet.ServletConfig interface. This configuration object allows the servlet to access name-value initialization parameters from the web application. Each request is serviced in its own separate thread. The web container calls the service() method of the servlet for every request. The developer of the servlet must provide an implementation for these methods. Finally, the web container calls the destroy() method that takes the servlet out of service. The destroy() method, like init(), is called only once in the lifecycle of a servlet. The following is a typical user scenario of these methods. Assume that a user requests to visit a URL. The browser then generates an HTTP request for this URL. This request is then sent to the appropriate server. The HTTP request is received by the web server and forwarded to the servlet container. The container maps this request to a particular servlet. The servlet is dynamically retrieved and loaded into the address space of the container. The container invokes the init() method of the servlet. This method is invoked only when the servlet is first loaded into memory. It is possible to pass initialization parameters to the servlet so that it may configure itself. The container invokes the service() method of the servlet. This method is called to process the HTTP request. The servlet may read data that has been provided in the HTTP request. The servlet may also formulate an HTTP response for the client. The servlet remains in the container’s address space and is available to process any other HTTP requests received from clients. The service() method is called for each HTTP request. The container may, at some point, decide to unload the servlet from its memory. The algorithms by which this decision is made are specific to each container. The container calls the servlet’s destroy() method to relinquish any resources such as file handles that are allocated for the servlet; important data may be saved to a persistent store. The memory allocated for the servlet and its objects can then be garbage collected. ExampleThe following example servlet prints how many times its service() method was called. Note that HttpServlet is a subclass of GenericServlet, an implementation of the Servlet interface. The service() method of HttpServlet class dispatches requests to the methods doGet(), doPost(), doPut(), doDelete(), and so on; according to the HTTP request. In the example below service() is overridden and does not distinguish which HTTP request method it serves. 12345678910111213141516171819202122232425262728293031import java.io.IOException; import javax.servlet.ServletConfig;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class ServletLifeCycleExample extends HttpServlet &#123; private int count; @Override public void init(final ServletConfig config) throws ServletException &#123; super.init(config); getServletContext().log("init() called"); count = 0; &#125; @Override protected void service(final HttpServletRequest request, final HttpServletResponse response) throws ServletException, IOException &#123; getServletContext().log("service() called"); count++; response.getWriter().write("Incrementing the count to " + count); &#125; @Override public void destroy() &#123; getServletContext().log("destroy() called"); &#125;&#125; javax是什么？ java和javax都是Java的API(Application Programming Interface)包，java是核心包，javax的x是extension的意思，也就是扩展包。java类库是java发布之初就确定了的基础库，而javax类库则是在上面增加的一层东西，就是为了保持版本兼容要保存原来的，但有些东西有了更好的解决方案，所以，就加上些，典型的就是awt(Abstract Windowing ToolKit) 和swing。]]></content>
      <categories>
        <category>Java</category>
        <category>Java web</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mathjax常用公式记录]]></title>
    <url>%2Fblog%2F2018%2F04%2F30%2Fmathjax%E5%B8%B8%E7%94%A8%E5%85%AC%E5%BC%8F%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[角度记法 度数：$60^\circ$，$60^\circ$ 度数分：$60^\prime$，$60^\prime$ 弧度：$\frac{\pi}{2}$，$\frac{\pi}{2}$ 角度记法：$\angle A$，$\angle A$]]></content>
      <categories>
        <category>LaTex</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[椭圆规]]></title>
    <url>%2Fblog%2F2018%2F04%2F30%2F%E6%A4%AD%E5%9C%86%E8%A7%84%2F</url>
    <content type="text"><![CDATA[利用简单定义的椭圆规椭圆大家高中的时候都学过，椭圆有两个中心，椭圆轨迹上的点到这两个中心的距离加起来就是长轴的长度。 利用参数式的椭圆规 $\overline{AP}=a$，$\overline{BP}=b$，P点所绘制的就是椭圆了。画圆规时先固定十字底座，旋转时A点保持在纵轴滑动，B点保持在横轴滑动，当规臂完成$360^\circ$时，P点的轨迹即为椭圆，且此椭圆的长半轴是 a，短半轴是 b。 下面讲讲原理： 若以十字中心为原点，十字横向为x轴，纵向为y轴，设定一个直角坐标系，并设 $\theta$ 为以x轴为始边，规臂$\overline{AP}$为终边的广义角，不难看出来P点的坐标是 $(a\cos\theta, b\sin\theta)$，即方程式为：$\frac{x^2}{a^2}+\frac{y^2}{b^2}=1$ 的椭圆方程式。其中a为长半轴的长度，b为短半轴的长度。]]></content>
      <categories>
        <category>数学</category>
        <category>解析几何</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Leetcode Algorithm 274. H-Index]]></title>
    <url>%2Fblog%2F2018%2F04%2F30%2FLeetcode-Algorithm-274.H-Index%2F</url>
    <content type="text"><![CDATA[Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher’s h-index. According to the definition of h-index on Wikipedia: “A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each.” For example, given citations = [3, 0, 6, 1, 5], which means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively. Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, his h-index is 3. Note: If there are several possible values for h, the maximum one is taken as the h-index. Credits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases. 看了维基百科的解说之后，我发现这题还是挺简单的，思路就是排序，如果用C++解这题，我就直接用std::sort了。 C++代码如下： 1234567891011121314151617181920class Solution &#123;public: int hIndex(vector&lt;int&gt;&amp; citations) &#123; if(citations.size()&lt;=0)&#123; return 0; &#125; std::sort(citations.begin(), citations.end(), compare); int result = citations[0]; for(int i=0;i&lt;citations.size();i++)&#123; if(i&lt;citations[i])&#123; result = i+1; &#125; &#125; return result; &#125; static bool compare(int i, int j)&#123; return i&gt;j; &#125;&#125;;]]></content>
      <categories>
        <category>ACM</category>
        <category>Leetcode</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[UML图]]></title>
    <url>%2Fblog%2F2018%2F04%2F28%2FUML%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[从一个示例开始看懂UML图请看下面这个类图，类之间的关系是我们需要关注的： 车的类图结构为abstract，代表车是一个抽象类 它有两个继承类：小汽车和自行车，它们之间的关系为实现关系，使用带空心箭头的虚线表示 小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示 小汽车与发动机之间是组合关系，使用带实心箭头的实线表示 学生与班级之间是聚合关系，使用带空心箭头的实线表示 学生与身份证之间为关联关系，使用一根实线表示 学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示 下面我们将介绍这六种关系： 类之间的关系泛化关系（generalization）类的继承结构表现在UML中为：泛化（generalize）与实现（realize）： 继承关系为 is-a 的关系，两个对象之间如果可以用 is-a 来表示，就是继承关系 eg: 自行车是车，猫是动物 泛化关系用一条带空心箭头的直接表示，如下图表示（A继承自B） eg：汽车在现实中有实现，可用汽车定义具体的对象；汽车与SUV之间为泛化关系； 注：最终代码中，泛化关系表现为继承非抽象类； 实现关系（realize）实现关系用一条带空心箭头的虚线表示； eg: “车”为一个抽象的概念，在现实中并无法直接用来定义对象，只有指明具体的子类（汽车还是自行车），才可以用来定义对象（“车”这个类在C++中用抽象类表示，在Java中有接口这个概念，更容易理解） 注：最终代码中，实现关系表现为继承抽象类； 聚合关系（aggregation）聚合关系用一条带空心菱形箭头的直线表示，如下图表示A聚合到B上，或者说B由A组成； 聚合关系用于表示实体对象之间的关系，表示整体由部分构成的语义；例如一个部门由多个员工组成； 与组合关系不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在；例如，部门撤销了，人员不会消失，他们依然存在； 组合关系（composition）组合关系用一条带实心菱形箭头直线表示，如下图表示A组成B，或者B由A组成； 与聚合关系一样，组合关系同样表示整体由部分构成的语义；比如公司由多个部门组成； 但组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在了；例如， 公司不存在了，部门也将不存在了； 关联关系（association）关联关系是用一条直线表示的。它描述不同类的对象之间的结构关系，它是一种静态关系，通常与运行状态无关，一般由常识等因素决定的，它一般用来定义对象之间静态的、天然的结构，所以，关联关系是一种“强关联的关系”。 比如，乘车人和车票之间是一种关联关系；学生和学校是一种关联关系。 关联关系默认不强调方向，表示对象间相互知道，如果特别强调方向，如下图，表示A知道B，但B不知道A。 注：在最终代码中，关联对象通常是以成员变量的形式实现的； 依赖关系（dependency）依赖关系是用一套带箭头的虚线表示的，如下图表示A依赖B，他描述一个对象在运行期间会用到另一个对象的关系： 与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化，依赖关系也可能发生变化 显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生。 注：在最终代码中，依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系，依赖关系除了临时知道对方外，还“使用”对方的方法和属性。]]></content>
      <categories>
        <category>编程范式</category>
        <category>面向对象编程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Markdown+MathJax搭建个人博客]]></title>
    <url>%2Fblog%2F2018%2F04%2F25%2FHexo%2BMarkdown%2BMathJax%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[为什么搭建个人博客其实有想过用简书写博客，但简书不支持 mathjax，而我写作的时候要用到不少数学公式。 以前也用过 leanote，也就是现在的 蚂蚁笔记，但蚂蚁笔记的博客中，[TOC] 是有 mathjax 渲染的，但右上角的目录导航却是没有加 mathjax 渲染的，这样看着会相当别扭。另外还有几个原因： leanote收费 无法彻底的自定义 博客不像使用静态网站引擎那样直观的以文件的形式展示在我面前 为什么选 hexo为什么选择 hexo，而不是 jekyll，或者 hugo。 其实我以前的博客是用的 jekyll，弃用 jekyll 是因为这东西实在是太慢了，我更新文章之后无法立即看到结果，要刷新很多次，或者说要等很久，git pages 上才会显示新的东西。听说 hexo 和 hugo 的速度都比较快，所以就换了 hexo，hexo 的主题比 hugo 多，另外 hugo 的官网和主题网站访问实在太慢了，成功恶心到了我。所以我最后选了 hexo，用上了经典主题 next。现在来说，主要是next主题吸引我，而hugo的next主题太简陋了。 hexo 是用 nodejs 写的，jekyll 是用 ruby 写的，hugo 是用 go 语言写的，wordpress 是用 php 实现的。 那为什么不用 wordpress 呢，因为我想用 git pages 这个平台，而这个平台只支持静态博客。 搭建过程环境配置首先你要安装 git 和 npm，git 是一种版本控制工具，npm 则是 nodejs 的包管理工具。 mac 上，使用 brew 和 brew cask 可以像许多 Linux 系统一样直接通过命令行安装软件。 12brew install gitbrew install node 另外很不幸的是 git 和 npm 在国内都是无法愉快的使用的，虽然没有被墙，但是速度奇慢无比。于是我们需要做些工作： 给 git 挂代理： 12git config --global http.proxy https://127.0.0.1:1087git config --global https.proxy https://127.0.0.1:1087 但为了实现上面的功能，首先你得有个翻墙代理。关于翻墙都可以额外写篇文章了。 想看详细的解决办法： https://www.zhihu.com/question/27159393 https://www.zhihu.com/question/27159393/answer/141047266 然后给 npm 换源： 12npm config set registry https://registry.npm.taobao.orgnpm info underscore （这个只是为了检验上面的设置命令是否成功，若成功，会返回[指定包]的信息） 想看更详细的解决办法： https://segmentfault.com/a/1190000007829080 好了，之后就是 hexo 安装 初始化 blog 目录 然后 hexo server 开启本地服务器，一个 demo 就出现啦。 命令如下： 123npm install hexo-cli -ghexo init bloghexo server 基本的建站过程从 jekyll 迁移到 hexo我是从 jekyll 迁移过来的，所以先把文章全都拷贝进 source/_posts 目录下面，然后修改 _config.yml，把： 1new_post_name: :title.md 变成： 1new_post_name: :year-:month-:day-:title.md 官网迁移教程：https://hexo.io/zh-cn/docs/migration.html 下载 next 主题并添加 mathjax然后下载一个 next 主题： 1git clone https://github.com/iissnan/hexo-theme-next themes/next 然后修改 _config.yml，把： 1theme: landscape 变成： 1theme: next 然后修改 next 的 _config.yml，把： 1234mathjax: enable: false per_page: false cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config#TeX-AMS-MML_HTMLorMML 变成： 1234mathjax: enable: true per_page: false cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config#TeX-AMS-MML_HTMLorMML 注意per_page不能是true，一定要是false。 解决 markdown 与 mathjax 的冲突为了解决 markdown 下划线转义成 &lt;em&gt; 标签（HTML标签），从而导致 mathjax 的下标无法使用，这个问题，我们修改 marked.js 文件，如果你使用的是 sublime text 或者 Atom 编辑器，cmd+o打开你的博客目录，然后 cmd+p 输入你要在此目录下找的文件名：marked.js 就可以找到这个文件。这个文件的是：node_modules/marked/lib/marked.js。把文件中的： 总共发现 mathjax 中的三处冲突： _变成了&lt;em&gt; \\变成了单个\ &lt; xxx &gt;大于号小于号之间会新增一个 #&quot;&quot; 将 1escape: /^\\([\\`*&#123;&#125;\[\]()# +\-.!_&gt;])/, 改为 1escape: /^\\([`*&#123;&#125;\[\]()# +\-.!_&gt;])/, 这样就去掉了，双斜杠转义。 把 1em: /^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/, 改为 1em:/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/, 这样就禁掉了 _ 变 &lt;em&gt;（斜体标记）。 最后，为了解决第三个冲突，我把 &gt; 写成了 HTML 实体形式：&amp;gt;，这样就无法组成一对尖括号了，终于不会冲突了。 我为什么不装个 hexo-renderer-pandoc + pandoc ，说出来都是泪啊，装了啊，一执行就报错，google 了一圈，没有有用的解答，遂作罢。 解决语言不正确的问题我发现有些地方居然默认的是德语还是什么其他语言，反正不是英语，所以我们需要改： 根目录下的 _config.yml next 主题的 _config.yml 两个都改成： 1language: en 生成 public 静态网站目录 和 部署到 github生成静态网站目录： 1hexo g 下载 hexo-deployer-git 插件： 1npm install hexo-deployer-git --save 再修改 _config.yml，把： 12deploy: type: 变成： 1234deploy: type: git repo: https://github.com/liuqinh2s/liuqinh2s.github.io branch: master 然后，用命令 hexo d 部署就行了，不过首先你得有个 github 账号，然后还得有个叫 liuqinh2s.github.io 的项目，然后你还得配置好 github 环境： 12git config --global user.name &quot;Your Name Here&quot;git config --global user.email &quot;your_email@example.com&quot; 然后把公钥的内容传给 github 就行了。这里只说原理，具体的操作懒得贴了。 只有多懂原理（哪怕只是基本的原理），你才能顺利解决遇到的诸多问题。 官网的部署教程：https://hexo.io/zh-cn/docs/deployment.html 基本的建站就结束了，然后就是慢慢把博客进行个性化吧。 hexo 个性化配置 hexo-reference，用来支持 markdown 脚注的 hexo-generator-seo-friendly-sitemap，sitemap用来喂给搜索引擎的，更好的爬取网站 hexo-generator-search，博客内部搜索 hexo-wordcount，统计字数用的 然后就是调 next 主题，把自己喜欢的特性用上。 然后就是加上 不蒜子，百度统计这类统计工具，和 disqus 评论等等。]]></content>
      <categories>
        <category>projects</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数学基础公式推导]]></title>
    <url>%2Fblog%2F2018%2F04%2F25%2F%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC%2F</url>
    <content type="text"><![CDATA[今天看到下面这个公式，突然想我好像不会推导啊： $\sin(\beta-\alpha) = \sin\beta\cos\alpha - \cos\beta\sin\alpha$ 遂想如何推导，在youtube上找了一个视频：三角函数正余弦和角公式推导 思路是先推导出：$\cos(\beta-\alpha) = \cos\alpha\cos\beta + \sin\alpha\sin\beta$ 然后根据这个再结合正弦余弦之间的关系就很容易推 $\sin(\beta-\alpha) = \sin\beta\cos\alpha - \cos\beta\sin\alpha$ 那么怎么推导上面这个公式呢？ 需要用到解析几何： 结合 勾股定理 和 余弦定理 可以推导出。 根据勾股定理： $$\begin{align}\overline{PQ}^2&amp; = (\sin\alpha - \sin\beta)^2 + (\cos\beta - \cos\alpha)^2 \&amp; = 2 - 2(\cos\alpha\cos\beta + \sin\alpha\sin\beta) \\end{align}$$ 根据余弦定理（$a^2 = b^2 + c^2 -2ab\cos A$）： $$\begin{align}\overline{PQ}^2&amp; = 1^2 + 1^2 - 2\cdot1\cdot1\cdot\cos(\alpha-\beta)\end{align}$$ 由此推出： $$\cos(\alpha-\beta) = \sin\alpha\sin\beta+\cos\alpha\cos\beta$$ 也即： $$\cos(\beta-\alpha) = \sin\alpha\sin\beta+\cos\alpha\cos\beta$$ 然后： $$\begin{align}\sin(\beta-\alpha)&amp;= \cos(\frac{\pi}{2}-(\beta-\alpha)) \&amp;= \cos((\frac{\pi}{2}+\alpha) - \beta) \&amp;= \sin(\frac{\pi}{2}+\alpha)\sin\beta + \cos(\frac{\pi}{2}+\alpha)\cos\beta \&amp;= \cos\alpha\sin\beta - \sin\alpha\cos\beta \&amp;= \sin\beta\cos\alpha - \cos\beta\sin\alpha\end{align}$$ 勾股定理和余弦定理的证明比较简单，读者可以试着自证。]]></content>
      <categories>
        <category>数学</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java OutputStream flush]]></title>
    <url>%2Fblog%2F2018%2F02%2F27%2FJava-OutputStream-flush%2F</url>
    <content type="text"><![CDATA[FileOutPutStream继承OutputStream，并不提供flush()方法的重写，所以无论内容多少，write都会将二进制流直接传递给底层操作系统的I/O，flush无效果。而Buffered系列的输入输出流函数单从Buffered这个单词就可以看出他们是使用缓冲区的。 应用程序每次IO都要和设备进行通信，效率很低，因此缓冲区为了提高效率，当写入设备时，先写入缓冲区，每次等到缓冲区满了时，就将数据一次性整体写入设备，避免了每一个数据都和IO进行一次交互，IO交互消耗太大。 使用flush()和不使用flush()效果对比不使用flush()1234567891011String s = "Hello World";try &#123; // create a new stream at specified file PrintWriter pw = new PrintWriter(System.out); // write the string in the file pw.write(s);// // flush the writer// pw.flush();&#125; catch (Exception ex) &#123; ex.printStackTrace();&#125; buffer没有满，输出为空。 使用flush()1234567891011String s = "Hello World";try &#123; // create a new stream at specified file PrintWriter pw = new PrintWriter(System.out); // write the string in the file pw.write(s); // flush the writer pw.flush();&#125; catch (Exception ex) &#123; ex.printStackTrace();&#125; 得到期望的输出结果。 close()和flush()作用有交集！1234567891011public static void main(String[] args) &#123; BufferedWriter fw =null; try &#123; fw = new BufferedWriter(new FileWriter("e:\\test.txt")); fw.write("wo shi lucky girl."); //fw.flush(); fw.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 因为close的时候，会把你没flush掉的一起flush掉。缓冲区中的数据保存直到缓冲区满后才写出，也可以使用flush方法将缓冲区中的数据强制写出或使用close()方法关闭流，关闭流之前，缓冲输出流将缓冲区数据一次性写出。在这个例子中，flush()和close()都使数据强制写出，所以两种结果是一样的，如果都不写的话，会发现不能成功写出。 Java默认缓冲区大小是多少？默认缓冲去大小8192字节，也就是8k。 实验1234char[] array = new char[8192];Arrays.fill(array,'s');PrintWriter pw = new PrintWriter(System.out);pw.write(array); 1234char[] array = new char[8193];Arrays.fill(array,'s');PrintWriter pw = new PrintWriter(System.out);pw.write(array); 当设置数组长度为8192时没有输出，设置8193时有输出。]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[新概念英语四 lesson 03 Matterhorn Man]]></title>
    <url>%2Fblog%2F2018%2F02%2F25%2F%E6%96%B0%E6%A6%82%E5%BF%B5%E8%8B%B1%E8%AF%AD%E5%9B%9B-lesson-03-Matterhorn-Man%2F</url>
    <content type="text"><![CDATA[生词： climber （这个单词要注意发音，b 是不发音的） alpinist 登山运动员 route 路 summit 最高，顶点 sought seek 的过去式, seek sought sought perilous 危险的 manner 方式 court 招致 solitary 孤独的 rapidly 快速的 Alpine 阿尔卑斯山的 impoverished 贫困 settlements 定居点 flea-ridden 跳蚤猖獗 coarse 粗糙的 boast 吹嘘 priest 牧师 parishioner 教徒 shepherd 牧羊人 Invariably 不变的 linen 亚麻的 语言点：alpinist 实际上是由 Alps 阿尔卑斯山演变来的。 What was the main objective of early mountain climbers? 语言用词的多样性：这里的目标用的是 objective，也可以用 aim，goal 等。 这个问题的答案是：to get to the top by the easiest route Modern alpinists try to climb mountains by a route which will give them good sport, and the more difficult it is, the more highly it is regarded. 英语用词有时候非常简单，比如这里的 good sport 和 highly。 而翻译成汉语则是： 现代登山运动员总想找一条能够给他们带来运动乐趣的路线来攀登山峰。他们认为，道路愈艰险愈带劲儿。 汉语用的是 运动乐趣 和 带劲儿。也是相当地道的。 In the pioneering days however, this was not the case at all. 然而，在登山运动的初期，全然不是这种情况。 这里的 pioneering days 用法很新鲜，如果是我的话只会想到 early，this was not the case at all 又一次反映了英语用词的简洁。the case 用的很爽。 The early climbers were looking for the easiest way to the top because the summit was the prize they sought, especially if it had never been attained before. 早期登山者所寻找的是通往山顶的最方便的途径，这是他们追寻的目标，特别是前人未曾到达过的山顶。 这里的 early 呼应了前面的 pioneering，the summit was the prize they sought，时刻注意时态，英语就是如此，有不少的细节，需要严谨对待。另外 summit 用来表示山顶，如果是我的话只能想到 top，以后可以用 summit 来代替了。especially if it had never been attained before，我突然想到是不是也可以用 achieved。 It is true that during their explorations they often faced difficulties and dangers of the most perilous nature, equipped in a manner which would make a modern climber shudder at the thought, but they did not go out of their way to court such excitement. 确实，在探险中他们经常遇到惊心动魄的困难和危险，而他们的装备之简陋足以使现代登山者一想起来就胆战心惊。但是他们并非故意寻求这种刺激。 perilous险恶的，perilous nature 用来形容恶劣的自然环境。equipped in a manner which would make a modern climber shudder at the thought，这一句十分经典。court such excitement，这里的 court 表示招致，我以前只知道：法院、球场。 They had a single aim, a solitary goal – the top! 这个用了相同的词来描述同一个事，作为强调。而且语气上是递进的 single 和 solitary 比，solitary 语气更重，aim 和 goal 比，aim 表示一般的泛泛的目标，goal 则常用在体育竞赛方面。 It is hard for us to realize nowadays how difficult it was for the pioneers. 我们今天很难想象昔日的登山先驱是多么艰苦。 Except for one or two places such as Zermatt and Chamonix, which had rapidly become popular. Alpine villages tended to be impoverished settlements cut off from civilization by the high mountains. 阿尔卑斯山山区的小村几乎全是高山环抱、与世隔绝的穷乡僻壤。 tended to be，几乎全是，用得好。cut off from civilization by the high mountains，简单词用的好，形象的描述了高山环抱、与世隔绝、穷乡僻壤。 Such inns as there were were generally dirty and flea-ridden;the food simply local cheese accompanied by bread often twelve months old, all washed down with coarse wine. 那里的小客栈一般都很脏，而且跳蚤猖獗。食物是当地的干酪和通常存放了一年之久的面包，人们就着劣酒吞下这种食物。 accompanied by 这里用的不错，bread often twelve months old，形容面包和形容人是一样的用法。washed down 用液体灌下。coarse 粗糙的，coarse wine 劣质的酒。 Often a valley boasted no inn at all, and climbers found shelter wherever they could sometimes with the local priest(who was usually as poor as his parishioners), sometimes with shepherds or cheese-makers. Invariably the background was the same: dirt and poverty, and very uncomfortable. 山谷里常常没有小客栈，登山者只好随遇而安。有时同当地牧师（他通常和他的教民一样穷）住在一起，有时同牧羊人或制乳酪的人住在一起。无论在哪儿，情况都一样：肮脏、贫穷，极其不舒适。 boast: to be lucky enough to own。这里不用 have 而是用 boast，表明作者不是在做客观的描述，而是带有感情色彩的。例子：The university boasts the highest number of first-rate teachers in China. invariably 不变的。 For men accustomed to eating seven-course dinners and sleeping between fine linen sheets at home, the change to the Alps must have been very hard indeed. 对于过惯了一顿饭吃7道菜、睡亚麻细布床单的人来说，变换一下生活环境来到阿尔卑斯山山区，那一定是很艰难的。 seven-course dinners，七道菜的晚饭。sheet 薄片，纸张，床单。]]></content>
      <categories>
        <category>新概念英语四</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POJ 1008 Maya Calendar]]></title>
    <url>%2Fblog%2F2018%2F02%2F24%2FPOJ-1009-Edge-Detection%2F</url>
    <content type="text"><![CDATA[这一题花了不少时间，首先是题目没看懂，然后搜了很久的资料，才看懂了。 边缘检测是图像处理里面的基础，这题用的边缘检测就是最简单的边缘检测，根据周边八个像素点和此像素点差值 来描绘图像中的物体的边缘。 比如第一个点15，它周围的三个点是100，100，15，得到的结果是85，再比如第4行第2列是175，它周边的点是100，100，100，175，25，175，175，25，得到的结果是150. 输入也是刚开始没看懂，其实也很简单，第一个数表示图的宽度，接下来是若干对数字，前面是像素的值，后面是个数。 最后贴上有注释的代码（C++）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129//Memory Time //332K 32MS #include&lt;iostream&gt; #include&lt;cmath&gt; #include&lt;algorithm&gt; using namespace std; const int size=1000; //每幅图片的pair上限 int width; //Map的宽 int total=0; //像素点总个数 typedef class OutMapPix &#123; public: int pos; //OutMap中每个像素点的顺序位置，pos从1开始 int code; //OutMap中每个像素点对应InMap的编码 &#125;Pix; int InMapPair[size][2]; //InMapPair[][0]为像素值，InMapPair[][1]为InMapPair[][0]连续出现的个数 Pix OutMap[size*9]; //每个pix都依赖其周围的8个点编码 int cmp(const void* a,const void* b); //快排比较规则 int GetValue(int pos); //返回第pos个像素点的像素值 int GetCode(int pos); //返回第pos个像素点的编码 int main(int k) &#123; while(cin&gt;&gt;width &amp;&amp; width) &#123; int pairv,pairt; k=total=0; while(cin&gt;&gt;pairv&gt;&gt;pairt &amp;&amp; pairt) &#123; InMapPair[k][0]=pairv; InMapPair[k++][1]=pairt; total+=pairt; &#125; int PairNum=k; //pair的个数 cout&lt;&lt;width&lt;&lt;endl; int pos=1; //当前处理的像素点的位置 k=0; //OutMap[]指针 for(int p=0;p&lt;=PairNum;p++) &#123; int row=(pos-1)/width; //得到pos在二维图对应的坐标 int col=(pos-1)%width; for(int i=row-1;i&lt;=row+1;i++) //枚举(row,col)周围及其自身共9个点(x,y) for(int j=col-1;j&lt;=col+1;j++) &#123; int tpos=i*width+j; //得到(x,y)的顺序位置 if(i&lt;0 || j&lt;0 || j&gt;=width || tpos&gt;=total) continue; OutMap[k].pos=tpos+1; OutMap[k++].code=GetCode(tpos+1); //对发生变化的像素点的附近8个点和这一点本身编码（总共是9个点） &#125; pos+=InMapPair[p][1]; //跳跃，确定下一个像素发生变化的点的位置 &#125; qsort(OutMap,k,sizeof(Pix),cmp); //对OutMap根据顺序位置 /*OutPut*/ Pix temp=OutMap[0]; for(int i=0;i&lt;k;i++) &#123; if(temp.code==OutMap[i].code) continue; cout&lt;&lt;temp.code&lt;&lt;' '&lt;&lt;OutMap[i].pos-temp.pos&lt;&lt;endl; temp=OutMap[i]; &#125; cout&lt;&lt;temp.code&lt;&lt;' '&lt;&lt;total-temp.pos+1&lt;&lt;endl; cout&lt;&lt;"0 0"&lt;&lt;endl; &#125; cout&lt;&lt;0&lt;&lt;endl; return 0; &#125; /*快排比较规则*/ int cmp(const void* a,const void* b) &#123; Pix* x=(Pix*)a; Pix* y=(Pix*)b; return x-&gt;pos - y-&gt;pos; &#125; /*返回第pos个像素点的像素值*/ int GetValue(int pos) &#123; int i=0,p=0; while(p&lt;pos) p+=InMapPair[i++][1]; return InMapPair[i-1][0]; &#125; /*返回第pos个像素点的编码*/ int GetCode(int pos) &#123; int code=GetValue(pos); int MaxAbs=0; int row=(pos-1)/width; int col=(pos-1)%width; for(int i=row-1;i&lt;=row+1;i++) for(int j=col-1;j&lt;=col+1;j++) &#123; int tpos=i*width+j; if(i&lt;0 || j&lt;0 || j&gt;=width || tpos&gt;=total || tpos==pos-1) //tpos==pos-1为中心的像素点，即当前待编码的点 continue; int tcode=GetValue(tpos+1); if(MaxAbs&lt;abs(tcode-code)) //注意取绝对值 MaxAbs=abs(tcode-code); &#125; return MaxAbs; &#125; 要注意的点： 主要就是自加，这里面用了很多的右自加，右自加是先使用值，然后再自加。 GetValue函数 是一个典型的寻区间代码。 算法：只计算 RLE 起始点和其周围的点。这里不做证明。]]></content>
      <categories>
        <category>ACM</category>
        <category>POJ</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POJ 1008 Maya Calendar]]></title>
    <url>%2Fblog%2F2018%2F02%2F22%2FPOJ-1008-Maya-Calendar%2F</url>
    <content type="text"><![CDATA[这一题的话： 要注意 C++ 的 switch 不能使用 string，所以只好写成 if 来判断了。 另外一个值得注意的地方是，空格会中断标准输入，所以不能使用一个 string 来装下一行输入，而是分别用 string Day，string str，int Year，装下 day, month, year。 注意 Day[i]-‘0’ 可以使用分批输出，无需打包成一个 string。 C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;#define Haab 365#define Tzolkin 260int main() &#123; int n; cin&gt;&gt;n; string Day; int Year; string str; cout &lt;&lt; n &lt;&lt; endl; while(n--)&#123; int num=0; cin &gt;&gt; Day; for(int i=0;Day[i]!='.';++i)&#123; num = num*10+Day[i]-'0'; &#125; cin &gt;&gt; str; if(str=="no")num += 20; if(str=="zip")num+=40; if(str=="zotz")num+=60; if(str=="tzec")num+=80; if(str=="xul")num+=100; if(str=="yoxkin")num+=120; if(str=="mol")num+=140; if(str=="chen")num+=160; if(str=="yax")num+=180; if(str=="zac")num+=200; if(str=="ceh")num+=220; if(str=="mac")num+=240; if(str=="kankin")num+=260; if(str=="muan")num+=280; if(str=="pax")num+=300; if(str=="koyab")num+=320; if(str=="cumhu")num+=340; if(str=="uayet")num+=360; cin &gt;&gt; Year; num += Year*365; cout &lt;&lt; num%13+1; int month = num%260; switch(month%20)&#123; case 0: str = "imix"; break; case 1: str = "ik"; break; case 2: str = "akbal"; break; case 3: str = "kan"; break; case 4: str = "chicchan"; break; case 5: str = "cimi"; break; case 6: str = "manik"; break; case 7: str = "lamat"; break; case 8: str = "muluk"; break; case 9: str = "ok"; break; case 10: str = "chuen"; break; case 11: str = "eb"; break; case 12: str = "ben"; break; case 13: str = "ix"; break; case 14: str = "mem"; break; case 15: str = "cib"; break; case 16: str = "caban"; break; case 17: str = "eznab"; break; case 18: str = "canac"; break; case 19: str = "ahau"; break; &#125; cout &lt;&lt; " " +str +" "; cout &lt;&lt; num/260 &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>POJ</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POJ 1007 DNA sorting]]></title>
    <url>%2Fblog%2F2018%2F02%2F21%2FPOJ-1007-DNA-sorting%2F</url>
    <content type="text"><![CDATA[这道题有点尴尬，刚开始一直没看懂，主要是先入为主，以为是对每一串字符串做排序，最后发现居然是根据每一串 DNA 的逆序数，对串之间进行排序。 题目本身是简单的，第一步统计逆序数，第二步排序，这里使用C++标准库的sort。 C++代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;algorithm&gt;using namespace std;struct dna&#123; int unorder; string s;&#125;DNA[105];int inversionNumber(string s)&#123; int result = 0; int A, C, G; A = C = G = 0; for(int i = s.length()-1;i&gt;=0;--i)&#123; switch(s[i])&#123; case 'A': A++; break; case 'C': C++; result += A; break; case 'G': G++; result += A; result += C; break; case 'T': result += A; result += C; result += G; break; default: break; &#125; &#125; return result;&#125;bool compare(dna a, dna b)&#123; return a.unorder &lt; b.unorder;&#125;int main() &#123; int n, m; int i=0; cin &gt;&gt; n &gt;&gt; m; while(i&lt;m)&#123; cin &gt;&gt; DNA[i].s; DNA[i].unorder = inversionNumber(DNA[i].s); i++; &#125; sort(DNA, DNA+m, compare); for(int i=0;i&lt;m;++i)&#123; cout &lt;&lt; DNA[i].s &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>POJ</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POJ 1006 Biorhythms]]></title>
    <url>%2Fblog%2F2018%2F02%2F15%2FPOJ-1006-Biorhythms%2F</url>
    <content type="text"><![CDATA[同余两个整数 a, b，若它们除以正整数 m所得的余数相等，则称 a,b对于模 m 同余，记作：$a \equiv b (mod\quad m)$。最先引用同余的概念与”$\equiv$”符号的是德国数学家 高斯。 中国剩余定理在《孙子算经》中有这样一个问题：“今有物不知其数，三三数之剩二（除以3余2），五五数之剩三（除以5余3），七七数之剩二（除以7余2），问物几何？”这个问题称为“孙子问题”，该问题的一般解法国际上称为“中国剩余定理”。具体解法分三步： 找出三个数：从3和5的公倍数中找出被7除余1的最小数15，从3和7的公倍数中找出被5除余1 的最小数21，最后从5和7的公倍数中找出除3余1的最小数70。用15乘以2（2为最终结果除以7的余数），用21乘以3（3为最终结果除以5的余数），同理，用70乘以2（2为最终结果除以3的余数），然后把三个乘积相加（152+213+70*2）得到和233。用233除以3，5，7三个数的最小公倍数105，得到余数23，即233%105=23。这个余数23就是符合条件的最小数。 为什么要这么做呢？ 这就牵涉到一个最基本数学定理，如果有a%b=c,则有(a+kb)%b=c(k为非零整数)，换句话说，如果一个除法运算的余数为c，那么被除数与k倍的除数相加（或相减）的和（差）再与除数相除，余数不变。这就是上面提到的同余。 以此定理为依据，如果n2是3的倍数，n1+n2就依然满足除以3余2。同理，如果n3也是3的倍数，那么n1+n2+n3的和就满足除以3余2。这是从n1的角度考虑的，再从n2，n3的角度出发，我们可推导出以下三点： 为使n1+n2+n3的和满足除以3余2，n2和n3必须是3的倍数。 为使n1+n2+n3的和满足除以5余3，n1和n3必须是5的倍数。 为使n1+n2+n3的和满足除以7余2，n1和n2必须是7的倍数。 因此，为使n1+n2+n3的和作为“孙子问题”的一个最终解，需满足： n1除以3余2，且是5和7的公倍数。 n2除以5余3，且是3和7的公倍数。 n3除以7余2，且是3和5的公倍数。 所以，孙子问题解法的本质是从5和7的公倍数中找一个除以3余2的数n1，从3和7的公倍数中找一个除以5余3的数n2，从3和5的公倍数中找一个除以7余2的数n3，再将三个数相加得到解。在求n1，n2，n3时又用了一个小技巧，以n1为例，并非从5和7的公倍数中直接找一个除以3余2的数，而是先找一个除以3余1的数，再乘以2。 最后，我们还要清楚一点，n1+n2+n3只是问题的一个解，并不是最小的解。如何得到最小解？我们只需要从中最大限度的减掉掉3，5，7的公倍数105即可。道理就是前面讲过的定理“如果a%b=c,则有(a-kb)%b=c”。所以（n1+n2+n3）%105就是最终的最小解。 总结就两个公式： 如果 a%b=c , 则有 (a+kb)%b=c (k为非零整数)。 如果 a%b=c，那么 (a*k)%b=kc (k为大于零的整数)。 解题代码最后我们再来看看我们这道题，如何使用中国剩余定理来得到时间复杂度 O(1) 的解。 已知(n+d)%23=p; (n+d)%28=e; (n+d)%33=i 使33×28×a被23除余1，用33×28×8=5544； 使23×33×b被28除余1，用23×33×19=14421； 使23×28×c被33除余1，用23×28×2=1288。 因此有（5544×p+14421×e+1288×i）% lcm(23,28,33) =n+d 又23、28、33互质，即lcm(23,28,33)= 21252; 所以有n=（5544×p+14421×e+1288×i-d）%21252 本题所求的是最小整数解，避免n为负，因此最后结果为n= [n+21252]% 21252 那么最终求解n的表达式就是：n=(5544p+14421e+1288*i-d+21252)%21252 123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;using namespace std;#define P 23#define E 28#define I 33#define C 21252int main() &#123; int p, e, i, d; int count=1; int J=E*I; int K=P*I; int H=P*E; int j; int k; int h; for(j=J;j%P!=1;j+=J); for(k=K;k%E!=1;k+=K); for(h=H;h%I!=1;h+=H); // cout &lt;&lt; j &lt;&lt; endl; // cout &lt;&lt; k &lt;&lt; endl; // cout &lt;&lt; h &lt;&lt; endl; while (cin &gt;&gt; p &gt;&gt; e &gt;&gt; i &gt;&gt; d) &#123; if(p==-1)&#123; break; &#125; int result = (j*p+k*e+h*i-d+C)%C; if(result==0) result = C; cout &lt;&lt; "Case "&lt;&lt; count &lt;&lt; ": the next triple peak occurs in " &lt;&lt; result &lt;&lt; " days." &lt;&lt; endl; count++; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>POJ</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POJ 1003 Hangover]]></title>
    <url>%2Fblog%2F2018%2F01%2F21%2FPOJ-1004-Financial-Management%2F</url>
    <content type="text"><![CDATA[这一题简单的有点过分了，一度让我有点怀疑，但当我直接提交 AC 的那一刻，才发现还真是就这么简单。 C++ 代码： 123456789101112#include &lt;iostream&gt; using namespace std;int main()&#123; double x; double sum; while(cin &gt;&gt; x)&#123; sum += x; &#125; cout &lt;&lt; "$" &lt;&lt; sum/12 &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>POJ</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POJ-1003-Hangover]]></title>
    <url>%2Fblog%2F2018%2F01%2F21%2FPOJ-1003-Hangover%2F</url>
    <content type="text"><![CDATA[这一题 AC 的速度还是挺快的，题目本身也是很简单： C++ 代码： 123456789101112131415161718192021222324252627282930#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;sstream&gt;using namespace std;string double2Str(const double &amp;double_temp)&#123; stringstream ss; ss &lt;&lt; double_temp; string str; ss &gt;&gt; str; return str;&#125;int main()&#123; double x; cin &gt;&gt; x; //对浮点数只能使用大于、小于号进行比较，不能使用等号和不等号，我这里直接把 double 转成字符串，就可以用不等号比较了 //根据输入条件的限制，可以这样写：x&gt;0.01。 while(double2Str(x)!="0")&#123; int i=2; double sum=1.0/i; while(sum &lt; x)&#123; i++; sum += 1.0/i; &#125; cout &lt;&lt; i-1 &lt;&lt; " card(s)" &lt;&lt; endl; cin &gt;&gt; x; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>POJ</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POJ 1002 487 3279]]></title>
    <url>%2Fblog%2F2018%2F01%2F21%2FPOJ-1002-487-3279%2F</url>
    <content type="text"><![CDATA[这一题看似很简单，却有着很多限制，我也是搞了很久。刚开始的时候我是用了很多 c++11 的东西，然后一直报 Compile Error，但我本地编译是不会有错的，查出几点： vector&lt;vector&gt;会报错，但 c++11可以这样写，以前的老编译器只能这么写：vector&lt;vector &gt;to_string()函数无法使用，这是 c++11 新出的。for(int x:result)这种写法直到 c++11 才支持。POJ 上的编译器是比较老的，所以无法使用 c++11 的新特性。 这还不算，后来一直报 Time Limit Exceeded，上网查资料发现，要把 cin 输入改成 getchar 接收输入，终于 AC。还有就是在勾选 language 的时候，一定要用 G++，不要用 C++，如果你选 C++，会报如下错误： 123456Compile ErrorMain.cppF:\temp\18069972.33777\Main.cpp(16) : error C2057: expected constant expressionF:\temp\18069972.33777\Main.cpp(16) : error C2466: cannot allocate an array of constant size 0F:\temp\18069972.33777\Main.cpp(16) : error C2133: &apos;data&apos; : unknown size C++代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt; #include &lt;cstdio&gt;#include &lt;cstdlib&gt;#include &lt;string&gt; #include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;sstream&gt;using namespace std;int main()&#123; int n; char ch; scanf("%d",&amp;n); int data[n]; int size = n; while(n--)&#123; ch = getchar(); //过滤空行 if(ch=='\n')&#123; n++; continue; &#125; int num = 0; while(ch!='\n')&#123; if(ch&gt;='0' &amp;&amp; ch&lt;='9')&#123; num = num*10 + ch - '0'; &#125;else if(ch &gt;= 'A' &amp;&amp; ch &lt;= 'P')&#123; num = num*10 + (ch - 'A')/3 + 2; &#125;else if(ch &gt;= 'R' &amp;&amp; ch &lt;= 'Y')&#123; num = num*10 + (ch - 'Q')/3 + 7; &#125; ch = getchar(); &#125; data[n]=num; &#125; // qsort(data, size, sizeof(int), compare); sort(data, data+size); // for(int i=0;i&lt;size;i++)&#123; // cout &lt;&lt; data[i] &lt;&lt; endl; // &#125; int count=1; int index=0; for(int i=1;i&lt;size;++i)&#123; if(data[i]==data[i-1])&#123; count++; index=i; &#125;else&#123; if(count!=1)&#123; printf("%03d-%04d %d\n",data[i-1]/10000,data[i-1]%10000,count); // cout &lt;&lt; setfill('0') &lt;&lt; setw(3) &lt;&lt; data[i-1]/10000 &lt;&lt; '-' &lt;&lt; setfill('0') &lt;&lt; setw(4) &lt;&lt; data[i-1]%10000 &lt;&lt; ' ' &lt;&lt; count &lt;&lt; endl; count=1; &#125; &#125; if(i==size-1 &amp;&amp; count!=1)&#123; printf("%03d-%04d %d\n",data[i-1]/10000,data[i-1]%10000,count); count=1; &#125; &#125; if(index==0)&#123; cout &lt;&lt; "No duplicates." &lt;&lt; endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>POJ</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POJ 1005 I Think I Need a Houseboat]]></title>
    <url>%2Fblog%2F2018%2F01%2F21%2FPOJ-1005-I-Think-I-Need-a-Houseboat%2F</url>
    <content type="text"><![CDATA[这一题也很简单，直接上代码： C++ 代码： 1234567891011121314151617181920212223#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;int main()&#123; const double PI = 3.141592653589793; int n; double x; double y; double area; int year; cin &gt;&gt; n; int i=1; while(n--)&#123; cin &gt;&gt; x &gt;&gt; y; area = PI*(x*x+y*y)/2; year = area/50 + 1; cout &lt;&lt; "Property " &lt;&lt; i &lt;&lt; ": This property will begin eroding in year " &lt;&lt; year &lt;&lt; "." &lt;&lt; endl; i++; &#125; cout &lt;&lt; "END OF OUTPUT." &lt;&lt; endl; return 0;&#125;]]></content>
      <categories>
        <category>ACM</category>
        <category>POJ</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[POJ 1001 Exponentiation]]></title>
    <url>%2Fblog%2F2018%2F01%2F20%2FPOJ-1001-Exponentiation%2F</url>
    <content type="text"><![CDATA[这是我第一次做 ACM，也是 POJ 上的第一题，本来以为这一题应该属于很简单的题，但没想到却花了不少时间。 本来我是想着用C++标准库的 pow 函数，但这一题显然是个大实数乘法，double 可能就不够用了，所以只能自己手动实现乘法。Java 有个 BigInteger 和 BigDecimal 分别用来处理大整数和大实数。 我的代码（已经 AC）： C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt;using namespace std; // 两数相乘，使用vector保存每一位数字，从低位到高位vector&lt;int&gt; Multi(vector&lt;int&gt; v1,vector&lt;int&gt; v2)&#123; vector&lt;int&gt; result; for (int i = 0; i &lt; v1.size() + v2.size() + 1; i++) &#123; result.push_back(0); &#125; for (int i = 0; i &lt; v1.size(); i++) &#123; for (int j = 0; j &lt; v2.size(); j++) &#123; result[i + j] += v1[i] * v2[j]; result[i + j + 1] += result[i + j] / 10; result[i + j] %= 10; &#125; &#125; return result;&#125;int main() &#123; string str; int n; while(cin &gt;&gt; str &gt;&gt; n)&#123; // cout &lt;&lt; str &lt;&lt; " " &lt;&lt; n &lt;&lt; " "; vector&lt;int&gt; numArray; vector&lt;int&gt; resultArray; int dotPos = 0, begin = 0, end = str.length() - 1; //如果全是0和. 就直接输出0 bool isAllZero = true; bool hasDot = false; for(int i=0;i&lt;str.length();i++)&#123; if(str[i]!='0' &amp;&amp; str[i]!='.')&#123; isAllZero = false; &#125; if(str[i]=='.')&#123; hasDot = true; &#125; &#125; if(isAllZero)&#123; cout &lt;&lt; 0; cout &lt;&lt; endl; continue; &#125; //如果没有小数点就不用删除后序零 if(hasDot)&#123; //删除后序零（只删除小数点后的后序零，小数点之前的零保留，比如 10.0，变成10，而不是1） for (int i = str.length() - 1; i &gt;= 0; i--) &#123; if(str[i] != '0') &#123; end = i; break; &#125; &#125; &#125; // 测出小数位数 for (int i = end; i &gt;= 0; i--) &#123; if (str[i] == '.') &#123; dotPos = end - i; break; &#125; &#125; //删除前序零（如果小数点被0包裹，那么也将小数点删除，比如：00.001，变成1） for (int i = 0; i &lt; str.length(); i++) &#123; if(str[i] != '0' &amp;&amp; str[i]!='.') &#123; begin = i; break; &#125; &#125; // 将浮点数按位保存为整型 for (int i = end; i &gt;= begin; i--) &#123; if(str[i]!='.')&#123; numArray.push_back(str[i] - '0'); &#125; &#125; // 复制数组 for (int i = 0; i &lt; numArray.size(); i++) &#123; resultArray.push_back(numArray[i]); &#125; // 计算数组的n次方 for (int j = 0; j &lt; n-1; j++) &#123; resultArray = Multi(resultArray, numArray); int len = resultArray.size(); // 移除前导零 while (resultArray[len-1] == 0) &#123; resultArray.pop_back(); len--; &#125; &#125; // 输出结果，结果小于零时 if(n * dotPos &gt;= resultArray.size()) &#123; cout &lt;&lt; "."; for(int k = 0; k &lt; n * dotPos - resultArray.size(); k++) &#123; cout &lt;&lt; "0"; &#125; for(int k=resultArray.size()-1;k&gt;=0;k--)&#123; cout &lt;&lt; resultArray[k]; &#125; &#125;else&#123; for (int k = resultArray.size() - 1; k &gt;= 0; k--) &#123; if (k == n * dotPos - 1) &#123; cout &lt;&lt; "."; &#125; cout &lt;&lt; resultArray[k]; &#125; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 我自己写了一个测试用例的脚本： input.cpp: 1234567891011121314151617181920#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;fstream&gt;using namespace std;int main()&#123; string buffer; ifstream in("hello.txt"); if (! in.is_open()) &#123; cout &lt;&lt; "Error opening file"; exit (1); &#125; while (!in.eof() ) &#123; getline(in,buffer); cout &lt;&lt; buffer &lt;&lt; endl; &#125; return 0;&#125; hello.txt 内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555695.123 120.4321 205.1234 156.7592 998.999 101.0100 12.00001 1.12345 10001.1 11.1000 110.000 1000.10 1000000 1000.00 1.00000 0000010 1000.10 10000.1 100.111 10.0001 10.0001 30.0010 10.0010 30.0100 10.0100 30.1000 10.1000 31.0000 11.0000 31.0001 11.0001 31.0010 11.0010 31.0100 11.0100 31.1000 11.1000 310.000 110.000 310.001 110.001 310.010 110.010 310.100 110.100 399.000 199.000 399.001 199.001 399.010 199.010 399.100 199.100 399.998 199.998 3 这些测试用例都是前辈们留下来的资料。链接在这里：测试用例 顺带讲一下怎么自动测试： 12345//打开命令行，先编译两个 C++ 文件：g++ -std=c++11 -o input input.cppg++ -std=c++11 -o main main.cpp//然后用管道把输入输出串起来，把最终解输入到文件 output.txt 里./input | ./main &gt; output.txt]]></content>
      <categories>
        <category>ACM</category>
        <category>POJ</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Override Overload Overwrite]]></title>
    <url>%2Fblog%2F2017%2F11%2F14%2FOverride-Overload-Overwrite%2F</url>
    <content type="text"><![CDATA[我们都知道有些东西容易混淆，在加上中文翻译得乱七八糟，更加让人困惑。今天我要讲的这三位可就真是绝了。 它们是：Override、Overload、Overwrite。 这是我查有道词典时候看到的可怕一幕： Override 一个把三个名字都占了，你怕不怕？反正我是看的心里一紧。 如果把概念都煮成了一锅粥，那还不如不要记这些概念，你应该向更深层次去探寻。就这三个的区别来说，我觉得主要理解两个概念就行了： 函数签名（signature） 多态（polymorphism、polymorphic） 函数签名函数签名是什么，其实就是用来区别函数的，两个函数怎么样认定是不同的两个函数呢，只有两个方面： 函数名 参数 有人说还有返回值啊，不行，返回值不能作为函数签名的一部分，因为你调用一个函数的时候，返回值根本不能帮助编译器来识别你用的是哪个函数，比如： 1234int func(int a, int b);float func(int a, int b);func(); 请问我使用的是哪个函数？你看返回值确实不行吧。 多态多态是面向对象编程的概念，你可以看看它的准确定义： Polymorphism)。 定义很简短：polymorphism is the provision of a single interface to entities of different types. The Java™ Tutorials 如果父类有一个函数，子类也定义了一个完全相同的函数（函数签名相同），那么你可以用父类指针（或者说父类对象）作为统一的接口，来调用子类的方法。比如： 123456789101112131415161718192021222324252627class Vehicle&#123; public void move()&#123; System.out.println(“Vehicles can move!!”); &#125;&#125;class MotorBike extends Vehicle&#123; public void move()&#123; System.out.println(“MotorBike can move and accelerate too!!”); &#125;&#125;class Car extends Vehicle&#123; public void move()&#123; System.out.println(“Hi! I am a car!”); &#125;&#125;class Test&#123; public static void main(String[] args)&#123; Vehicle vh = new MotorBike(); vh.move(); // prints MotorBike can move and accelerate too!! vh = new Vehicle(); vh.move(); // prints Vehicles can move!! vh = new Car(); vh.move(); // prints Hi! I am a car! &#125;&#125; 多态的好处是可以扩展啊，比如我后来又多了个 truck 类，我不需要去动已经写好的代码，只要把 truck 模块写好，加进去就行了。 Override、Overload、Overwrite 的区别好了，知道了这两个概念，我们再来看看上面的那三个混在一起的东西： Override（推翻，对英文意思就是这个）subclass method overrides base class method means: in different range (in derived class and base class) the same function signature the base class method is virtual（if in C++） overload（超载）function overloading means: the same range (in the same class) the same function name but different function signature overwrite（重写）subclass method hides base class method means: in different range (in derived class and base class) the same function name 我们应该记住只有 Override 才跟多态有关。 Overload 是本class 里面的不同函数（只不过函数名一样罢了，其实是两个不同的函数，看两个函数是否是同一个函数就看函数签名就行了），其实没啥稀奇的，不就是函数名一样嘛。函数签名一样，区分出是用父类还是子类的函数，这才是面向对象和多态要解决的问题。 Override 和 Overwrite 的区别 比较容易混淆的其实是 Override 和 Overwrite，但你只要死记住：Override 必须函数签名要一样，而 Overwrite 只需函数名一样即可。另外 C++ 中一定要用virtual才算 Override，而 Java 默认就是 Override，不需要修饰词。 这里关于 Java 和 C++ 面向对象的细节区别可以写一大堆，比如：C++ class 后面是要加分号的，而 Java 不需要；但 Java 的类名是和文件名要一致的，而且只能有一个 public 类，而 C++不需要；Java 直接就能用 Override，而 C++必须要使用 virtual 关键字才能使用 Override（虚函数）；Java 的抽象方法跟 C++的纯虚函数对应。Java 是单继承，由接口来实现“多继承”，C++是多继承，没有接口，只有抽象类。C++还有个虚基类的概念。具体的写法上还有很多的不同，多用这两种语言写面向对象的代码，就慢慢会知道了。 C++ 有一个 virtual 关键字和 virtual table 这个概念，没有加 virtual 的父类函数是不可能形成多态的，如果这时候你碰到父类和子类两个里面有同名的函数，那么就属于 Overwrite 这个概念了，你其实也可以称这种覆盖掉父类函数的行为为：hide 隐藏。Java 这种语言里面没有 virtual 这一套，Java 也可以表现出 Overwrite，但要注意函数签名如果一样的话，那又不叫 Overwrite 了，应该叫 Override 了（Java 如果要在子类中使用父类的同函数签名方法，则必须使用 super 关键字）。而 C++ 不一样，即便是函数签名一样，如果前面不加 virtual 是不能叫 Override 的，仍然属于 Overwrite 的概念。请看下面的例子： 用 C++ 写的话： 12345678910111213141516171819202122232425#include &lt;iostream&gt;using std::cout;using std::endl;class A&#123;public: void func(int a)&#123; cout &lt;&lt; "A" &lt;&lt; endl; &#125;&#125;;class B:public A&#123;public: void func(int a)&#123; cout &lt;&lt; "B" &lt;&lt; endl; &#125;&#125;;int main()&#123; A *a = new B(); a-&gt;func(1); ((B*)a)-&gt;func(1); return 0;&#125; 结果输出： 12AB 可以看到，C++必须要用子类类型的指针才能访问到子类的部分（建议看一本书，叫：Inside the C++ Object Model，中文叫：深入C++对象模型，里面讲对象的内存布局讲的很清楚），java 也一样，必须转成子类型的指针才能访问，否则 IDE 会报错提示你。 Java 代码： 1234567891011121314151617181920public class test &#123; class A&#123; void func(int a)&#123; System.out.println("A"); &#125; &#125; class B extends A&#123; void func(int a, int b)&#123; System.out.println("B"); &#125; &#125; public static void main(String[] args)&#123; test t = new test(); A a = t.new B(); a.fun(1); ((B)a).func(1,2); &#125;&#125; 结果输出： 12AB 为什么 Java 代码里不像 C++ 代码里面那样，使用两个函数签名相同的函数？因为前面说过了，那样的话就变成 Override 了，只有在 C++ 里才能实现函数签名相同的 Overwrite（不使用virtual即可）。]]></content>
      <categories>
        <category>编程范式</category>
        <category>面向对象编程</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Inside the C++ Object Model 系列笔记 四 -- The Semantics of Function]]></title>
    <url>%2Fblog%2F2017%2F10%2F23%2FInside-the-C%2B%2B-Object-Model-%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0--The-Semantics-of-Function%2F</url>
    <content type="text"><![CDATA[c++支持三种类型的成员函数，分别为static,nostatic,virtual。每一种调用方式都不尽相同。 nonstatic member functionC++的设计准则之一就是:nonstatic member function至少必须和一般的nonmember function 有相同的效率。实际上，nonstatic member function 会被编译器进行如下的转换，变成一个普通函数: Type1 X::foo(Type2 arg1) { … } 会被转换为如下的普通函数: void foo(X *const this, Type1 &amp;__result, Type2 arg1) { … } 改写函数原型，在参数中增加this指针，对每一个”nonstatic data member的存取操作”改为由this指针来存取 将member function重写为一个外部函数，经过”mangling”处理（不需要处理的加上 extern “C”） 实际上，普通函数、普通成员函数、静态成员函数到最后都会变成与C语言函数类似的普通函数，只是编译器在这些不同类型的函数身上做了不同的扩展，并放在不同的 scope 里面而已。 编译器内部会将成员函数等价转换为非成员函数，具体是这样做的: 1.改写成员函数的签名，使得其可以接受一个额外参数，这个额外参数即是this指针： 123float Point::X();//成员函数X被插入额外参数thisfloat Point:: X(Point* this ); 当然如果成员函数是const的，插入的参数类型将为 const Point* 类型。 2.将每一个对非静态数据成员的操作都改写为经过this操作。 3.将成员函数写成一个外部函数，对函数名进行“mangling”处理，使之成为独一无二的名称。 可以看出，将一个成员函数改写成一个外部函数的关键在于两点，一是给函数提供一个可以直接读写成员数据的通道；二是解决好有可能带来的名字冲突。第一点通过给函数提供一个额外的指针参数来解决，第二点则是通过一定的规则将名字转换，使之独一无二。 于是在VC中对于上面的例子中的成员函数的调用将发生如下的转换： 1234//p-&gt;X();被转化为?X@Point@@QAEMXZ(p);//obj.X();被转化为?X@Point@@QAEMXZ(&amp;obj); 覆盖（override）、重载（overload）、隐藏（hide, overwrite）的区别： 覆盖（也叫重写）是指在派生类中重新对基类中的虚函数（注意是虚函数）重新实现。即函数名和参数都一样（函数签名一样），只是函数的实现体不一样。 重载是指 在同一个类中 不同的函数使用相同的函数名，但是函数的参数个数或类型不同。调用的时候根据函数的参数来区别不同的函数。 隐藏是指派生类中的函数把基类中相同名字的函数屏蔽掉了。隐藏与另外两个概念表面上看来很像，很难区分，其实他们的关键区别就是在多态的实现上。 C++多态（polymorphism）表示”以一个public base class的指针（或者reference），寻址出一个derived class object” 我专门写了一篇关于这些容易弄混的概念的文章：Override Overload Overwrite Virtual Member Function如果function()是一个虚拟函数，那么用指针或引用进行的调用将发生一点特别的转换——一个中间层被引入进来。例如： 123// p-&gt;function()//将转化为(*p-&gt;vptr[1])(p); 其中vptr为指向虚函数表的指针，它由编译器产生。vptr也要进行名字处理，因为一个继承体系可能有多个vptr。 1是虚函数在虚函数表中的索引，通过它关联到虚函数function(). 何时发生这种转换？答案是在必需的时候 – 一个再熟悉不过的答案。当通过指针调用的时候，要调用的函数实体无法在编译期决定，必需待到执行期才能获得，所以上面引入一个间接层的转换必不可少。但是当我们通过对象（不是引用，也不是指针）来调用的时候，进行上面的转换就显得多余了，因为在编译器要调用的函数实体已经被决定。此时调用发生的转换，与一个非静态成员函数(Nonstatic Member Functions)调用发生的转换一致。p.function()的处理就跟非静态成员函数一样了。 Static Member Function 不能够直接存取其类中的非静态成员（nostatic members），包括不能调用非静态成员函数(Nonstatic Member Functions)。 不能声明为const、volatile或virtual 参数没有this 可以不用对象访问，直接 类名::静态成员函数 访问，当然，通过对象调用也被允许 需要注意的是通过一个表达式或函数对静态成员函数进行调用，被C++ Standard要求对表达式进行求值。如： 12(a+=b).static_fuc();func().static_fuc(); 虽然省去对a+b求值对于static_fuc()的调用并没有影响，但是程序员肯定会认为表达式a+=b已经执行，一旦编译器为了效率省去了这一步，很难说会浪费多少程序员多少时间去查找这个bug。这无疑是一个明智的规定。func()返回一个对象。 vtable的内容： virtual class offset（有虚基类才有） topoffset typeinfo 继承基类所声明的虚函数实例，或者是覆盖（override）基类的虚函数 新的虚函数（或者是纯虚函数占位） 虚函数表的构造挺简单的： 从内存布局的角度看，类对象继承基类的时候只把基类的 nonstatic data member和member function（函数入口，也可以说是函数指针） 放进自己内存里，static data member和static function都在global address里面。然后就是虚函数表是复制了一份基类的虚函数表，然后把virtual实现了的部分替换掉，没实现的就不改，依然用父类的。然后虚函数表指针自然也要不一样，毕竟指向的内存地址不一样，对吧。]]></content>
      <categories>
        <category>读书笔记</category>
        <category>《Inside the C++ Object Model》</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Inside the C++ Object Model 系列笔记 三 -- The Semantics of Data]]></title>
    <url>%2Fblog%2F2017%2F10%2F21%2FInside-the-C%2B%2B-Object-Model-%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0--The-Semantics-of-Data%2F</url>
    <content type="text"><![CDATA[C++对象模型的细节，讨论了 data members 的处理。 空类在内存中有空间吗一个实例引出的思考： 1234class X&#123;&#125;;class Y:virtual public X&#123;&#125;;class Z:virtual public X&#123;&#125;;class A:public Y, public Z&#123;&#125;; 猜猜sizeof上面各个类都为多少？ Lippman的一个法国读者的结果是： 1234sizeof X yielded 1sizeof Y yielded 8sizeof Z yielded 8sizeof A yielded 12 Lippman自己的结果是： 1234sizeof X yielded 1sizeof Y yielded 4sizeof Z yielded 4sizeof A yielded 8 事实上，对于像X这样的一个空类，编译器会对其动点手脚——隐晦的插入一个字节。为什么要这样做呢？插入了这一个字节，那么X的每一个对象都将有一个独一无二的地址。如果不插入这一个字节呢？哼哼，那对X的对象取地址的结果是什么？两个不同的X对象间地址的比较怎么办？ 我们再来看Y和Z。首先我们要明白的是实现虚继承，将要带来一些额外的负担——额外需要一个某种形式的指针。到目前为止，对于一个32位的机器来说Y、Z的大小应该为5，而不是8或者4。我们需要再考虑两点因素：内存对齐（alignment—）和编译器的优化。 空类也有1Byte的大小，因为这样才能使得这个class的2个objects在内存中有独一无二的地址。 The Binding of a Data Member考虑下面这样的代码： 1234567891011extern float x;class Point3d&#123;public:truePoint3d(float, float, float);true//问题是 x 到底是哪个 x 呢truefloat X() const &#123;return x;&#125;truevoid X(float new_x) const&#123;x = new_x;&#125;private:truefloat x;&#125; 对member functions本身的分析会直到整个class的声明都出现了才开始（直到看到代表 class 结束的}右大括号）。所以class的 member functions 可以引用声明在后面的成员，C 语言就做不到。 和member functions对比，需要十分注意的一点是:class中的typedef并不具备这个性质。因此，类中的 typedef 的影响会受到函数与 typedef 的先后顺序的影响。 1234567typedef int length;class Point3d&#123;public:truevoid f1(length l)&#123; cout &lt;&lt; l &lt;&lt; endl; &#125;truetypedef string length;truevoid f2(length l)&#123; cout &lt;&lt; l &lt;&lt; endl; &#125;&#125;; 这样 f1 绑定的 length 类型是 int;而 f2 绑定的 length 类型才是 string。 所以，对于 typedef 需要防御性的程序风格:始终把 nested type 声明(即 typedef)放在 class 起始处! Data Member LayoutC++只保证处于同一个 access section（也就是private,public,protected片段）的数据，一定会以声明的次序出现在内存布局当中(要求较晚出现的数据成员处在较大的内存地址中)。C++标准只提供了这一点点的保证。允许编译器将多个Acess Section的顺序自由排列，而不必在乎它们的声明次序。但似乎没有编译器这样做。对于继承类，C++标准并未指定是其基类成员在前还是自己的成员在前。 12345678class X &#123;public: int i; int j;private: int k; int n;&#125; 数据 i 一定在 j 之前，k 一定在 n 之前。具体什么顺序就看编译器了。 传统上，vptr被安放在所有被明确声明的member的最后，不过也有些编译器把vptr放在最前面(MSVC++就是把 vptr 放在最前面，而 G++ 是把 vptr 放在最后面)。 Access of a Data Member在C++中，直观上来说，由一个对象存取一个member会比由一个指针存取一个member更快捷。但是对于经由一个对象来存取和由一个指针来存取一个静态的 member 来说，是完全一样的，都会被编译器所扩展。 经由 member selection operators（也就是 “.” 运算符）对一个 static data member 进行存取操作只是一种语法上的便宜行事而已。member 其实并不在 class object 中，因此存取并不需要通过 class object。 经由一个函数调用的结果来存取静态成员，C++标准要求编译器必须对这个函数进行求值，虽然这个求值的结果并无用处。 foo().static_member = 100; foo()返回一个类型为 X 的对象，含有一个 static_member，foo()其实可以不用求值而直接访 问这个静态成员，但是 C++标准保证了 foo()会被求值，可能的代码扩展为: 12(void) foo();X::static_member = 100; static data members如果有两个 class ，每个都声明了一个 static member freelist，那么当他们都被放在程序的 data segment时，就会导致名称冲突。编译器的解决方法是暗中对每一个 static data member 编码（这种手法有个很美的名称：name-mangling），以获得一个独一无二的程序识别代码。有多少种编译器就有多少种 name-mangling 做法！通常不外乎是表格啦，语法措辞啦等等。任何 name-mangling 都有两个要点： 一种算法，推导出独一无二的名称。 万一编译系统（或环境工具）必须和使用者交谈，那些独一无二的名称可以轻易被推导回原来的名称。 nonstatic data membersNonstatic data members are stored directly within each class object and cannot be accessed except through an explicit or implicit class object. An implicit class object is present whenever the programmer directly accesses a nonstatic data member within a member function. For example, in the following code: 123456Point3dPoint3d::translate( const Point3d &amp;pt ) &#123; x += pt.x; y += pt.y; z += pt.z;&#125; the seemingly direct access of x, y, and z is actually carried out through an implicit class object representedby the this pointer. Internally, the function is augmented as follows: 1234567// internal augmentation of member function Point3d Point3d::translate( const Point3d* this, const Point3d &amp;pt ) &#123; this-&gt;x += pt.x; this-&gt;y += pt.y; this-&gt;z += pt.z;&#125; 地址：&amp;origin._y;和&amp;origin + ( &amp;Point3d::_y - 1 );是一样的。指向 data member 的指针，其 offset 值总是被加上1。这样可以使编译系统区分出 “一个指针 data member 的指针，用以指向 class 的第一个 member”和“一个指向 data member 的指针，但是没有指向任何 member”两种情况(成员指针也需要有个表示 NULL 的方式，0 相当于用来表示 NULL 了，其它的就都要加上 1 了)。 Inheritance and the Data MemberC++ Standard 保证:“出现在派生类中的 base class subobject 有其完整原样性!” 子类会被放在父类的对齐空白字节之后，因为父类的完整性必须得以保证，父类的对齐空白字节 也是父类的一部分，也是不可分割的。 请看下面例子： 12345678910class X&#123;public: int x; char c;&#125;;class X2:public X&#123;public: char c2;&#125;; X2的布局应当是x(4),c(1),c2(1),这么说来sizeof(X2)的值应该是8？错了，实际上是12。原因在于X后面的三个字节的填充空白不能为c2所用。也就是说X2的大小实际上为：X(8)+c2(1)+填补（3）=12。这样看来编译器似乎是那么的呆板，其实不然，看一下下面的语句会发生什么？ 123X2 x2;X x;x2=x; 如果X后面的填充空白可以被c2使用的话，那么X2和X都将是8字节。上面的语句执行后x2.c2的值会是多少？一个不确定的值！这样的结果肯定不是我们想要的。 在多重继承的派生体系中，将派生类的地址转换为第 1 基类时成本与单继承是相同的，只需要改换地址的解释方式而已；而对于转换为非第 1 基类的情况，则需要对地址进行一定的 offset 操作 才行。C++ Standard 并未明确 base classes 的特定排列次序，但是目前的编译器都是按照声明的次序来安放他们的。(有一个优化:如果第 1 基类没有 vtable 而后继基类有，则可能把它们调 个位置)。多重继承中，可能会有多个 vptr 指针，视其继承体系而定:派生类中 vptr 的数目最多等于所有基类的 vptr 数目的总和。]]></content>
      <categories>
        <category>读书笔记</category>
        <category>《Inside the C++ Object Model》</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Inside the C++ Object Model 系列笔记 二 -- The Semantics of constructors]]></title>
    <url>%2Fblog%2F2017%2F10%2F19%2FInside-the-C%2B%2B-Object-Model-%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0--The-Semantics-of-constructors%2F</url>
    <content type="text"><![CDATA[这一章详细的讨论了 constructor 如何工作，讨论构造一个对象的过程以及构造一个对象给程序带来的影响。 区分trivial和notrivial 只有编译器需要的时候(为什么会需要?后面讲的很清楚)，合成操作才是nontrivial的， 这样的函数才会被真正的合成出来; 如果编译器不需要，而程序员又没有提供，这时的默认构造函数就是trivial的。虽然它在概念上存在，但是编译器实际上根本不会去合成出来，因为他不做任何没有意义的事情，所以当然可以忽略它不去合成。trivial 的函数只存在于概念上，实际上不存在这个函数。 default constructorA default constructor is a constructor which can be called with no arguments (either defined with an empty parameter list, or with default arguments provided for every parameter). 通常很多C++程序员存在两种误解 没有定义默认构造函数的类都会被编译器生成一个默认构造函数。 编译器生成的默认构造函数会明确初始化类中每一个数据成员。 被声明：declared，被定义：defined。声明代表分配内存空间，定义代表初始化，也就是分配具体的值。 所以所有成员都在声明的时候被分配内存，构造函数的作用是初始化它们，non-object 成员需要程序员自己初始化，编译器不帮忙。 C++中对于默认构造函数的解释是:默认的构造函数会在需要的时候被编译器产生出来。这里非常重要的一点是:谁需要?是程序的需要还是编译器的需要?如果是程序的需要，那是程序员的责任;只有在是编译器的需要时，默认构造函数才会被编译器产生出来，而且被产生出来的默认构造函数只会执行编译器所需要的行动，而且这个产生操作只有在默认构造函数真正被调用时才会进行合成。 例如:成员变量初始化为 0 操作，这个操作就是程序的需要，而不是编译器的需要。 总结变量的初始化: Global objects are guaranteed to have their associated memory “zeroed out” at program start-up. Local objects allocated on the program stack and heap objects allocated on the free-store do not have their associated memory zeroed out; rather, the memory retains the arbitrary bit pattern of its previous use. 只有全局变量和静态变量才会保证初始化，其中静态变量可以视为全局变量的一种，因为静态变量也是保存在全局变量的存储空间上的。Golbal objects 的内存保证会在程序激活的时候被清 0；Local objects 配置于程序的堆栈中，Heap objects 配置于自由空间中，都不一定会被清为 0,它们的内容将是内存上次被使用后的痕迹! 全局变量和静态变量都放在 global data Segment 上，且在类被声明的时候就已经分配内存和初始化，也就是 在任何对象被定义之前静态变量就已经存在了（即使该 class 没有任何 object 实体，static data members也已经存在）。 123456789class Foo &#123; public: int val; Foo *pnext; &#125;;void foo_bar()&#123; // Oops: program needs bar's members zeroed out Foo bar; if ( bar.val || bar.pnext ) // ... do something // ...&#125; When is a default constructor synthesized, then? Only when the implementation needs it. Moreover, the synthesized constructor performs only those activities required by the implementation. That is, even if there were a need to synthesize a default constructor for class Foo, that constructor would not include code to zero out the two data members val and pnext. For the previous program fragment to execute correctly, the designer of class Foo needs to provide an explicit default constructor that properly initializes the class’s two members. 意思是初始化 val 和 pnext 是程序员的责任，编译器不负责，所以你这里不初始化它们，它们存储的结果就是内存遗留的痕迹。 什么时候编译器会给你生成默认构造函数首先你得没有写默认构造函数，编译器才会给你生成。有四类情况，编译器会给你加代码： 类中有一个对象（成员变量），这个对象包含了默认构造函数 继承自带有默认构造函数的基类的类 带有虚函数的类 继承自虚基类的类 如果class A内含一个或以上的member objects，那么A的constructor必须调用每一个 member class 的默认构造函数。具体方法是:编译器会扩张 constructors（注意：是所有的构造函数，不仅仅是默认构造函数会被扩张），在其中安插代码使得在 user code 被调用之前先调 用 member objects 的默认构造函数(当然如果需要调用基类的默认构造函数，则放在基类的 默认构造函数调用之后:基类构造函数-&gt;成员构造函数-&gt;user code)。C++要求以“member objects 在 class 中的声明次序”来调用各个 construtors。这就是声明的次序决定了初始化次序(构造函数初始化列表一直要求以声明顺序来初始化)的根本原因!所以你打乱 member initialization list 的顺序根本没有用哦~ 理解了初始化列表中的实际执行顺序中“以 member 声明的次序”来决定的，就可以理解一些很 微妙的错误了。比如: 12A() : i(99), j(66), value(foo()) &#123;... &#125;int i, value, j; 这会不会产生错误取决于成员函数 foo()是依赖于 i 还是 j:如果 foo 依赖于 i，由于 i 声明在 value 之前，所以不会产生错误;如果 foo 依赖于 j，由于 j 声明在 value 之后，就产生了使用未初始化成员的错误。 带有virtual functions的类的默认构造函数毫无疑问是nontrivial的，需要编译器安插额外的成员 vptr 并在构造函数中正确的设置好 vptr，这是编译器的重要职责之一。继承自 virtual base class 的类的默认构造函数同样也毫无疑问的 nontrivial，编译器需要正确设置相关的信息以使得这些虚基类的信息能够在执行时准备妥当，这些设置取决于编译器实现虚基类的手法。 编译器有4种情况会使得编译器真正的为class生成nontrivial的默认构造函数，这个 nontrivial 的默认构造函数只满足编译器的需要(调用 member objects 或 base class 的默认构造函数、初始化 virtual function 或 virutal base class 机制)。其它情况时，类在概念上拥有默认构造函数，但是实际上根本不会被产生出来(前面的区分 trivial 和 nontrivial)。 对于一个trivial默认构造函数，编译器的态度是，既然它全无用处，干脆就不合成它。在这儿要厘清的是概念与实现的差别，概念上追求缜密完善，在实现上则追求效率，可以不要的东西就不要。 copy constructor有一个参数的类型是其类类型的构造函数是为拷贝构造函数。如下： 123X::X( const X&amp; x);Y::Y( const Y&amp; y, int =0 );//可以是多参数形式，但其第二个即后继参数都有一个默认值 什么时候编译器会给你生成拷贝构造函数 其实和前面默认构造函数一样，四种情况 如果一个类没有定义拷贝构造函数，通常按照“成员逐一初始化(Default Memberwise Initialization)”的手法来解决“一个类对象以另一个同类实体作为初值”——也就是说把内建或派生的数据成员从某一个对象拷贝到另一个对象身上，如果数据成员是一个对象，则递归使用“成员逐一初始化(Default Memberwise Initialization)”的手法。 成员逐一初始化(Default Memberwise Initialization)具体的实现方式则是位逐次拷贝（Bitwise copy semantics） Copy constructors和默认构造函数一样，只有在必须的时候才会被产生出来，对于大部分的class 来说，拷贝构造函数仅仅需要按位拷贝就可以。满足 bitwise copy semantics 的拷贝构造函数是 trivial 的，就不会真正被合成出来(与默认构造函数一样，只有 nontrivial 的拷贝构 造函数才会被真正合成出来)。对大多数类按位拷贝就够了，什么时候一个 class 不展现出 bitwise copy semantics 呢? 分为 4 种情况，前 2 种很明显，后 2 种是由于编译器必须保证正确设置虚机制而引起的。 当class内含一个member object而后者声明了(也可能由于nontrivial语意从而编译器 真正合成出来的)一个 copy constructor 时; 当class继承自一个存在有copy constructor的base class(同样也可能是合成)时; 当class声明了一个或多个virtual functions时;(vf影响了位语意，进而影响效率) 当class派生自一个继承串链，其中一个或多个virtual base classes时。 对于前两种情况，不论是基类还是对象成员，既然后者声明有拷贝构造函数时，就表明其类的设计者或者编译器希望以其声明的拷贝构造函数来完成“一个类对象以另一个同类实体作为初值”的工作，而设计者或编译器这样做——声明拷贝构造函数，总有它们的理由，而通常最直接的原因莫过于因为他们想要做一些额外的工作或“位逐次拷贝”无法胜任。 对于有虚函数的类，如果两个对象的类型相同那么位逐次拷贝其实是可以胜任的。但问题将出现在，如果基类由其继承类进行初始化时，此时若按照位逐次拷贝来完成这个工作，那么基类的vptr将指向其继承类的虚函数表，这将导致无法预料的后果——调用一个错误的虚函数实体是无法避免的，轻则带来程序崩溃，更糟糕的问题可能是这个错误被隐藏了。所以对于有虚函数的类编译器将会明确的使被初始化的对象的vptr指向正确的虚函数表。因此有虚函数的类没有声明拷贝构造函数，编译将为之合成一个，来完成上述工作，以及初始化各数据成员，声明有拷贝构造函数的话也会被插入完成上述工作的代码。 1234567891011121314151617181920212223#include &lt;iostream&gt;using namespace std;class A &#123;public: virtual void f() &#123; cout &lt;&lt; "A::f()" &lt;&lt; endl; &#125; int i;&#125;;class B : public A &#123;public: void f()&#123; cout &lt;&lt; "B::f()" &lt;&lt; endl; &#125;&#125;;int main(int argc, char const *argv[])&#123; B b; b.i=1; A a = b; A *p = &amp;a; p-&gt;f(); cout &lt;&lt; p-&gt;i &lt;&lt; endl; return 0;&#125; 上面例子可以看出，如果 A a = b;是 bitwise copy semantics 的话，a 内放置的就是 b 的 vptr。但其实不是，编译器给 a 生成了拷贝构造函数，初始化了 a 的 vptr。b 的 vptr 是由编译器给 b 生成的默认构造函数初始化的。但对于其他成员变量 bitwise copy semantics依然有效，所以 i 的结果是1。我在做这个试验的时候发现了一个有趣的现象： 123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;class A &#123;public: virtual void f() &#123; cout &lt;&lt; "A::f()" &lt;&lt; endl; &#125; int i;&#125;;class B : public A &#123;public: void f()&#123; cout &lt;&lt; "B::f()" &lt;&lt; endl; &#125; int i;&#125;;int main(int argc, char const *argv[])&#123; B b; b.i=1; A a = b; A *p = &amp;a; p-&gt;f(); cout &lt;&lt; p-&gt;i &lt;&lt; endl; return 0;&#125; 两个 i 不是同一个 i，b.i=1;优先给 b 中的同名变量赋值了。这样的代码简直可怕。那么怎么访问到从 A 继承来的成员变量 i 呢，请看： 123456789101112131415161718192021222324#include &lt;iostream&gt;using namespace std;class A &#123;public: virtual void f() &#123; cout &lt;&lt; "A::f()" &lt;&lt; endl; &#125; int i;&#125;;class B : public A &#123;public: void f()&#123; cout &lt;&lt; "B::f()" &lt;&lt; endl; &#125; int i;&#125;;int main(int argc, char const *argv[])&#123; B b; b.A::i=6; b.B::i=1; A a = b; A *p = &amp;a; cout &lt;&lt; p-&gt;i &lt;&lt; endl; return 0;&#125; 命名返回值优化对于一个如foo()这样的函数，它的每一个返回分支都返回相同的对象，编译器有可能对其做Named return Value优化（下文都简称NRV优化），方法是以一个参数result取代返回对象。 foo()的原型： 12345678X foo()&#123; X xx; if(...) return xx; else return xx;&#125; 优化后的foo()以result取代xx： 1234567891011121314void foo(X &amp;result)&#123; result.X::X(); if(...) &#123; //直接处理result return; &#125; else &#123; //直接处理result return; &#125;&#125; 对比优化前与优化后的代码可以看出，对于一句类似于X a = foo()这样的代码，NRV优化后的代码相较于原代码节省了一个临时对象的空间（省略了xx）,同时减少了两次函数调用（减少xx对象的默认构造函数和析构函数，以及一次拷贝构造函数的调用，增加了一次对a的默认构造函数的调用）。]]></content>
      <categories>
        <category>读书笔记</category>
        <category>《Inside the C++ Object Model》</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Inside the C++ Object Model 系列笔记 一 -- Object Lessons]]></title>
    <url>%2Fblog%2F2017%2F10%2F19%2FInside-the-C%2B%2B-Object-Model-%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0--Object-Lessons%2F</url>
    <content type="text"><![CDATA[多态：统一的接口，不同的实现 C++多态（polymorphism） 表示”以一个public base class的指针（或者reference），寻址出一个derived class object” Layout Costs for Adding Encapsulation(封装)第一章 Object Lessons 介绍了 C++如何在背后实现一个对象，内存中的布局以及空间上的关系。 在计算机的原理中，要实现某个机制，我们总能找到很多种实现方式（对比着学习，多思考每种实现方法的利弊），C++的类的实现也不例外，让我们对比以下三种实现方式： 三种对象实现模式A Simple Object Model 可以看到，简单对象模型把所有的data member和member function（函数指针）都放在对象里了。 A Table-driven Object Model 表驱动模型把member分为data和function两类，用两个指针分别指向两个表，一个存放所有的data member，一个存放所有的function指针。 The C++ Object Model 12345678template&lt;class Type&gt;class Point3d&#123;public: Point3d(Type x, Type y, Type z) : x_(x), y_(y), z_(z) &#123;&#125; Type x() &#123; return x_; &#125;private: Type x_, y_, z_;&#125; 上面的 C++ 类并不会比 C 语言 的struct 耗费更多的内存空间，三个 data members 直接内含于 Object 中，member functions 则放在 Object 外。 C++的 data members 有两种：static 和 nonstatic C++的 member functions 有三种：static 、nonstatic 、virtual 放在 Object 中的只有 nonstatic data members，其他的统统是放在 Object 外。 一个对象的内存布局大小(通常由 3 部分组成): 其 nonstatic data member 的总和大小; 任何由于位对齐所需要的填补上去的空间;(关于内存对齐，自己查) 加上了为了支持virtual机制而引起的额外负担。 data members 在内存中的布局C++只保证处于同一个 access section（也就是private,public,protected片段）的数据，一定会以声明的次序出现在内存布局当中(要求较晚出现的数据成员处在较大的内存地址中)。C++标准只提供了这一点点的保证。允许编译器将多个Acess Section的顺序自由排列，而不必在乎它们的声明次序。但似乎没有编译器这样做。对于继承类，C++标准并未指定是其基类成员在前还是自己的成员在前。 12345678class X &#123;public: int i; int j;private: int k; int n;&#125; 数据 i 一定在 j 之前，k 一定在 n 之前。具体什么顺序就看编译器了。 Virtual Table(vtbl, vtable) 和 vptrVirtual function 机制由以下2个步骤来支持： 每个 class 产生的 Virtual function 的指针放在 Virtual Table 中 编译器给每个 class object 添加一个指针 vptr，指向相应的 vtable 一个 vtable 对应一个 class，一个 vptr 才对应一个 class object，必须区分开这 2 个概念。vtable 独立于对象，就跟函数独立于对象一样。这样所有对象才能共享它们，就像 static data members 被共享一样。 RTTI(run-time type identification):一般来说，每一个 class 相关联的 type_info 对象的指针通常也保存在 vtable 的第一个 slot 中。关于 type_info 是什么，可以自己查。 引入继承后的对象模型成本 如果是普通继承，父对象被直接包含在子对象里面，这样父对象的存取也是直接进行的，没有额外的指针成本。 如果是虚拟继承，父对象由一个指针指出来，这样父对象的存取就必须由指针访问，添加了一层间接性。 virtual base class，用以实现 “多次出现在继承体系中的base class，有一个单一而被共享的实例” 1234class A &#123; public: void Foo() &#123;&#125; &#125;;class B : public virtual A &#123;&#125;;class C : public virtual A &#123;&#125;;class D : public B, public C &#123;&#125;; 我觉得这里有个问题，class D继承class B和class C的时候并不是虚继承，所以何不将B和C直接放在D中呢？这样就省了两次指针。 struct 和 class 关键字的区别总共就两个区别： struct defaults to public access and class defaults to private access. When inheriting, struct defaults to public inheritance and class defaults to private inheritance. (Ironically, as with so many things in C++, the default is backwards: public inheritance is by far the more common choice, but people rarely declare structs just to save on typing the “public” keyword). 哈哈，我觉得这么做的目的无非就是提醒你注意封装，不要给外部暴露没必要的东西，所以才把默认搞成private。 除此之外 struct 和 class 一样。 struct 用来表现那些只有数据的集合体 POD(Plain Old Data)、而 class则希望表达的是ADT(abstract data type)的思想。 POD stands for Plain Old Data - that is, a class (whether defined with the keyword struct or the keyword class) without constructors, destructors and virtual members functions. 由于这2个关键字在本质上无区别，所以class并没有必须要引入，但是引入它的确非常令人满意，因为这个语言所引入的不止是这个关键字，还有它所支持的封装和继承的哲学。可以这样想象:struct只剩下方便C程序员迁徙到C++的用途了。 programming paradigmsC++支持三种形式的编程风格(或称典范 paradigm): 面向过程的风格（procedural model）:就像C一样，一条语句接一条语句的执行或者函数跳转; 抽象数据类型模型(abstract data type model，ADT):仅仅使用了class的封装，很多人都是 在用基于对象的风格却误以为自己在使用面向对象的风格; 面向对象的风格(object-oriented):使用了class的封装和多态的编程思维(多态才是 真正的面向对象的特征)。 纯粹以一种paradigm写程序，有助于整体行为的良好稳固。 一个 reference 通常是以一个指针来实现的，所以 point 和 reference 并没有本质的区别，reference 和 const 指针的区别就是，你取 reference 指针的地址的时候，取到的是数据的地址，const 指针取地址取到的是指针的地址。 123456789101112#include &lt;iostream&gt;using namespace std;int main()&#123; int a=1; int &amp;b=a; const int *p = &amp;a; cout &lt;&lt; &amp;b &lt;&lt; endl; cout &lt;&lt; p &lt;&lt; endl; cout &lt;&lt; &amp;p &lt;&lt; endl;&#125; 也就是说你取不到 b 的地址。所以说引用相当于一个 别名。引用常用在函数调用里，可以直接操作原有对象，这样就可以不用写指针的指针这种绕弯的东西了。 函数的实参传递给形参是值传递，也就是一个 copy，形参在函数里将是一个局部变量。这个特性是许多新手面临的大坑。一道经典的考察题目便是，实现一个 C 语言的 swap 函数，由于 C 语言没有引用，你就只能用指针来操作原有对象了。 指针的类型 对于内存来说，不同类型的指针并没有什么不同。它们都是占用一个word的大小（所以word的大小决定了内存可访问空间的大小，32位系统是4字节，64位系统是8字节），包含一个数字，这个数字代表内存中的一个地址; 指针的类型是编译器的概念，对于硬件来说，并没有什么指针类型的概念; 转型操作也只是一种编译器的指令，它改变的是编译器对被指内存的解释方式而已! void*指针只能够持有一个地址（一个字节），而不能通过它操作所指向的object]]></content>
      <categories>
        <category>读书笔记</category>
        <category>《Inside the C++ Object Model》</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我读大学时候的一些思考]]></title>
    <url>%2Fblog%2F2017%2F02%2F06%2F%E6%88%91%E8%AF%BB%E5%A4%A7%E5%AD%A6%E6%97%B6%E5%80%99%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[我上大学之前一直是一个各科都学的很好的学生，文科成绩非常好，而且是个很感性的人，喜欢凭直觉，写一些无病呻吟的小文章，但是我之后毅然决然的选择了理科，并对理科产生了浓厚的兴趣，想去探究事物背后的原理，我高三时候经常问老师一些让老师都犯怵的难题（包括物理的、生物的），后来进大学学了计算机，编程思维对我产生了很大影响，我现在喜欢事事讲逻辑，讲原因，作总结，写东西也希望除了讲究文笔，同时也要言之有物，满满的思考和干货。 下面是我学生时期的一点思考，希望分享给大家，同时我也觉得需要提醒一下，人的成长多半靠经历和阅历，伟人不光是书读得多，他们的人生经历也是波澜壮阔（如果你觉得你的人生经历平平，那么就要警醒自己了），面对不确定的事要保持兴奋感，因为不确定代表着机遇（就像互联网上的超链接），一个人一生只要把握一个大机遇就非常好了，有时间我也要多出去走走，多接触些人和事物，行他个万里路，然而这需要一定的经济基础，不然只能出去要饭。 读计算机专业给我带来的思考做事形式化，规范化做事形式化其实并不是坏事，这个世界的运行体制就是形式化，也必须要形式化的，只有这样才可以高效稳定的运行起来。行有行规家有家法，做人做事都要有原则，与人与物打交道都要有协议有规定，所谓规章制度，并不是拿来消遣人的，出发点是更好的促进沟通交流。一个东西一旦规范起来，那么出漏子的情况就变得相当低了。比如出门前必定要学会检查自己要带哪些东西（都带上），要关掉哪些东西（都关掉，灯，窗，门等等。），这些都要养成习惯。而习惯的形成也正是为了减少大脑多余的思考，跟规章制度可以节约社会资源一样，不用每次都重新设计一遍。所以优秀的习惯是可以让人轻松的保持脑力体力，做好真正需要做的想的事，避免被小事琐事打搅，消耗脑力体力。一个人的习惯决定了一个人。这里引用一句名言： 播种一种思想（态度），收获一种行为；播种一种行为，收获一种习惯；播种一种习惯，收获一种性格；播种一种性格，收获一种人生。 其实习惯和性格是相辅相成的，性格反过来也会影响到习惯，加强习惯。而你的想法，也就是态度，会影响你的行为。所以总的来说态度（想法），行动力和习惯是最重要的三个东西。态度和行动力可以生成习惯，而习惯将决定你的未来，习惯是强大的，习惯就是力量。 把事物信息化要想管理好事物，就要将其信息化。这并不是现代才有的思想，古已有之。譬如政府的户籍制度，一个产品的说明书，都是各成体系，规范（这又说到了第一点：规范化）。其实规范化，也就是信息化。把事物的属性抽象出来列出清单，把操作统一规范好，这样只要懂规则的人只需一点功夫就能把握某件事物，而且丝毫不落下什么。学信息技术，学计算机，给我带来的最大的收获其实就是这个。当我发现这个世界其实无非就是信息的堆叠，这个世界的本质就是信息，而信息所能创造的不仅仅是这个世界，它能创造任意世界，事物。我们生活的这个世界有可能是用计算机模拟出来的，而我们将来也许也有能力模拟出一个复杂的世界，其实某些游戏，譬如minecraft就已经是在模拟我们这个世界了，只是比较简单罢了。现在信息技术越来越发达，各行各业的信息壁垒也越来越高，如果你不懂规则，就无法理解。而信息化思维正是帮助人轻松消化这些规则，打破信息壁垒的。只要你有了信息化思维的习惯，还有大量信息化思维和做事的经验，在这个世界，在各个行业领域都能轻松遨游，游刃有余。譬如写协议，这是件很能锻炼信息化思维的事。写代码，写程序也有此类功效。还有在国家政府机关、法律部门工作也有此类功效。这些事都让你去读懂一个规则，或者创造一个规则，这个过程中各种边角条件（corner cases）情况都要考虑周全，这跟你写出无bug的程序不是异曲同工之妙吗。 这里说一下我个人对能力提升的理解，一个人能力的高低完全取决于他的经验。经验是成功之母，这是我一直以来信奉的观念。失败和成功都只是小插曲罢了，重要的是经验，成功有成功的经验，失败有失败的经验。另外，提一下我对人生的一点理解，人生由什么决定，很多人说由自己决定，也对，也不对，不对的地方是什么呢。人生下来其实就不是由自己决定的，什么样的环境造就什么样的人，当然同样的环境可能产出不同的结果，但不同的结果也是这个环境所造就出来的，这点我们谁也不能否认。所以环境是人生最重要的一个东西，除此之外就是决定，我们这个世界有确定的东西，也有不确定的因素，很明显这里环境所造成的个人决定是不确定的。 微观上有人想用量子的瞬间位置和速度来模拟这个世界，这样就能确定世界的下一个状态，但是量子力学中量子的速度和位置是不能同时确定的，只能确定其一，这个世界宏观上是连续的，微观上是离散的不连续的，连空间都有最小的普朗克常量。宏观上的连续是微观的不连续堆叠起来的，这一点跟计算机不能无限精确的表示一个无限不循环小数有异曲同工之妙，所以我们世界有可能是计算机模拟出来的因为这种相同的不连续性。学过多媒体之后，对于模拟数据和数字数据我有了更深的理解，数字化精确到一定程度可以取代模拟量！用人的感官更加容易实现这个，譬如视网膜屏的分辨率，其实像素点是不连续的，是有穷的，数字的，但在我们眼里是连续的，无穷的，模拟的。再回到世界的非确定性本质，我觉得微观的非确定性也是从本质上导致了宏观的非确定性 环境决定一个人虽然人各有决定，意外时常发生，但是这并不代表环境不重要，相反环境相当重要，因为不定性是有概率指标的，而环境是确定的，你不能过分指望在同样一个环境里产生跟别人不一样的决定（就像理论上你能用量子态穿过一堵墙，但那个概率就实在太低了），特别是从一出生以来，那时候人带的基本是人的自然反应和决定。而现在的你的状态也和这一路走来你的环境有着莫大的关系（基本是一个确定态），什么样的环境造就什么样的人，这并不是一句空话。记得以前看过一个真实故事（不信可以自己去观察）：几个背景不同的年轻人去同样一家公司实习，经理通过观察就能判断他们父母是做什么的。（因为父母对人的影响很大）。你看这里只是 选取了环境的主要因素就已经基本给一个人定型了。而回顾我自己，我也是大为吃惊，自己的性格，自己现在的状态都可以从以前的环境找到原因，就像一种无形的束缚和枷锁。 我现在正在努力根据我以前的家庭环境来核对自己的性格，并努力向不同环境背景的人学习，比如由公务员家庭所继承下来的做事谨慎，妥当的性格。我也努力改善自己的环境，因为在合适的环境中能迅速培养这种环境所产生的性格习惯，而对抗环境去形成相反的性格习惯是特别困难和低效的。有句名言叫：出淤泥而不染。其实这描述的是一种特殊的现象，大部分人是应验了这句：近朱者赤近墨者黑。而我现在深知这其中的道理，我也知道我并不能做到出淤泥而不染，那还是去改变或者选择自己想要的环境吧，那样离自己的梦想更近一些。 人生就像一场游戏，在这场游戏里你不能决定你的出生，而出生其实反而是最重要的，在一个没有女权的地方，女孩子生活的有多不容易，而如果你出生就是奴隶，这又会是怎样的一生。出生在山沟沟里的孩子，很可能永远看不到城里孩子的世界。很多人说视野决定人生的高低，我上面也说了经验是成功之母。其实这些都可以归为一句话来讲，环境决定一个人。我很庆幸在这么年轻的时候就深刻认识到了这个定理。（虽然很多人都知道这一点，但如同知识你学了不一定会用一样，其实是没有用的，你不能在绝大多数该用到这个知识的时候都能想起这个）。但是出生这种环境是不能改变的，我们也不能消极的看待这一点。相反在认识到这一点后我变得更加积极了，我知道哪些是能改变的，哪些是不能改变的。那么就努力去改变我们能改变的。 在这个信息时代，人的视野更加开阔了，以前信息不发达的时候你最大的梦想很可能就是像村里王大爷一样，家里20多亩地，几十头猪牛，但现在我们可以看到更远的，人的现实处境和梦想的沟壑变的更大了，（人的梦想总是跟最大欲望有关，最大欲望又局限于视野之内），这是一件好事，但也是个不幸的事，当我们发现原来还有人活的那么潇洒那么漂亮，而我们可以成为跟他们一样的人，拥有一样漂亮的人生，但却要为此付出无比艰辛的努力，有很多人选择了放弃，选择了自我安慰和自我麻醉，到生命的尽头时才后悔不已。人生而为了梦想。困难，险阻，恐惧这些虽然难克服，但是如果真的一辈子这么龟缩着在自己的角落里真的有意思吗，每当我有困难的时候，每当我恐惧不已，惴惴不安的时候，都应该用这句话激励自己，“如果真的一辈子这么龟缩着在自己的一片小角落里真的有意思吗！！”。 当然不要因此学会去抱怨环境，环境能改变就改变，不能改变就要靠自己努力去改变，人有主观能动性。 心理学的一点小分析所有的过度改变都是痛苦的，这是人的天性。一尘不变和太过简单是无趣的，一点点改变是有趣的，稍强一点的改变是累人的，过度的改变就是痛苦的了。当一个学渣励志要变成学霸，从原来的睡到中午12点到现在的早上6点起床，这是极为痛苦的。当一个学渣要去学一些虽然不是很难，对什么都不会，没有基础的他而言，很难的东西，他是痛苦的。而要克服这两类痛苦（改变的痛苦和复杂的痛苦）主要靠习惯和方法，当你是高三学生的时候，你不会觉得高三很辛苦，（人的忍耐，甚至人的所有情感都是有弹性的，不是个定值），反而觉得自己不够努力。而到了大学再要你像高三那样高强度的学习，你会觉得痛苦不堪。学霸并不觉得自己的生活很苦，他们觉得轻松自在，理所当然。这都是因为习惯了，习惯可以减轻很多负担。当你例行公事的去刷牙洗脸，你一点都不觉的难，人的习惯是人最大的助手。习惯一养成，一切都OK。当这种习惯一尘不变时可以稍作改变，变为有趣，例子：刷牙买新牙膏。习惯的养成刚开始都是痛苦的，巨大的改变所带来的痛苦要挺过去。长痛不如短痛，这是对付改变的痛苦的方法。对付复杂带来的痛苦的方法更简单，把复杂程度降到一点点的时候，痛苦变为有趣。这里我还写了点有关学习方法的建议：学习方法总结。 最后附上我喜欢的一张壁纸，愿每个人都如这个 月夜攀登者 一样执着： 曾今的思考笔记人生的动与静：本来很早就想写这个话题了，这个想法是我在逛长沙市博物馆看画展的时候想到的，现在我连那个画家叫什么名字都忘了，但那一天出去走的时候去了很多地方，包括创客展，长沙市一中，烈士公园，等等。看完老先生的画作后我突然有一种感觉，就是人生不应该只呆在一个老地方过完这一辈子，那样当你回想起来的时候，发现每天都过得差不多，也就了无生趣了，生活应该是动态的有活力的，世界那么大，应该出去看看。人生那么长，应该多经历一些有趣的事。记得以前看过一篇文章，是讲什么叫有趣，什么叫舒适，有趣就是复杂，舒适就是简单，过于复杂让人渴望简单，过于简单，人又觉得无趣。所以生活就是在这两者之间取舍。累了就歇着，无聊了就找些稍复杂、有挑战性的事来做。 我的观点是人生在宏观上来看应该是动态的，在微观上是静态的。人需要不断的用新鲜事物来刺激自己，所谓生活每一天都很新鲜，就是这个道理。但过于奔波劳累，就又让人心生疲惫和厌倦。所以在动的过程中，也要让每一段经历沉下心去，过好那一段。这种感觉是很美好的。每次出去走走，头脑都会清新好多，好像突然跳出了原来那个时空，以一种更宽广的视野看待现在的自己，人生的轨迹，想做的事仿佛又清晰了一些。所以要不时的出去走走，或者换一换环境，不要呆在寝室，一天下来只干了一堆琐事。 明白自己真正想要什么，然后动手去做。人生才会精彩。 参差多态乃幸福本源。去经历一些新奇的事，有趣的事。不要每天都一成不变。 少收藏，多消化：这个世界上所有的东西都是有生命周期的（有寿命的），那些好用的工具，美好的东西也是如此。今天清理了一下手机，又想起了umano，突然感悟到这世界上所有的东西都是有自己的期限的。以前也想过这个问题，就是要趁着那些美好的事物还在的时候去好好体验一下，见证他们的存在，王小波说希望这一生经历一些有趣的事，懂得一些道理。我觉得很对。但是反过来，既然所有的东西都是有寿命的，那么我现在手机上用的这些应用，这些工具也许有一天也终将没落。有太多的例子了，天涯，猫扑，衰败何其快，这个世界发展的太快了。微信也是才出不久就如日中天了。我应该好好去利用这些工具，但同时又不被他们绑架。 不要在收着藏着了，那不是你自己的东西，也不会成为你自己的东西。我曾今非常喜欢在用chrome浏览网页的时候收藏网页，随着时间的推移我收藏的网页变得越来越多，心理负担也变得越来越重，我不断的想花个时间去给我的书签分个类，我后来确实做到了，为了尽可能的细分管理，分了很多类别。但总有感觉不对劲的地方，最终我放弃了书签，而是改用搜索，最开始的理由是为了锻炼自己的搜索能力（因为我觉得曾今找到过一次的网页，今后也应该有能力找到才对），后来我渐渐明白收藏癖对自己的压力有多大，尤其是你心里总是惦记着自己的收藏夹的时候，不是你的终究不是你的，收藏了不看和没收藏实际上是一样的，但留在那里却给自己造成了无形的压力，注重消化和吸收，并做好记录和总结吧。 积极的人生态度：在这里我要强调，若想人生过得精彩，过得开心，一定要培养一种积极的人生态度。毛泽东就是一个典型的例子，豪气冲天，自信积极，人生无比精彩，会当击水三千里，自信人生二百年。这不是我以前所向往的生活吗，对，生活理当如此，一个人怎么能苟且的活着，那样还有什么意思呢。消极是失意人生之源。想想七龙珠里面的热血，火影，海贼王，莫不是有梦想之人的奋斗史。曾今的少年就真的被打败了吗，就真的甘于被生活和现实打败了吗，那这样下去接下来的人生可还有什么意义可言，无梦想，无热血，无积极的生活态度，可以去死矣。自卑是一种傻逼的生活方式，想想曾今电影王牌大贱谍2中的奥斯汀，人长得丑，矮，那又怎样，看看他的人生多精彩。人生唯爱情和美食不可辜负。爱情和美食你都经历过吗。人生只有血凉与热的区别。火苗再小，也要反复点燃。 做好规划：今天晚上7点去参加深圳双选会，看宣传片的时候突然脑子里蹦出一个念头，而且感觉越来越强烈。一个人究竟能走多远？我曾今以为自己能走很远，走到天涯海角， 既去做研究，当教授，又去赚大钱，做老板，所有美好的事全都在我身上。可是现在呢？呵呵，现在的处境离想象实在太远了。现在连找工作都是个问题。我们都知道企业做项目要有规划，一个国家发展要有规划，很多事都要有规划，而且越重要的事规划就越是严密，漏洞很少，并且都一一实现了。人生这么重要的一趟旅程又怎能随波逐流呢？很多人说随心随性，到头来这旅程又真的是你想要的吗？大多数人都是被生活推着走，没有人生规划的人更是如行尸走肉，如随风飘荡的落叶不知去向何方。年轻时的壮志，梦想，或者幻想，最终都一一破灭，成为遥不可及的东西。回头看我的人生轨迹，可以说我自己从来没有规划过，小的时候基本上是父母，社会，学校在规划我的轨迹，现在到了大学，自己有了能力和权力规划自己的人生（其实小的时候就可以规划，可惜没有这种意识，就算是大学的前三年，也不依旧没这意识吗）。想追求什么，可能我现在还不明白自己真的想追求什么，我一无所长，没有热爱。想追求什么也并不是想想就可以实现的，必须对此作出规划，才知道原来人生，原来生命并不是有无限可能，无限可能说出来都是骗人的。当你真的着手去规划，你才发现，要达到目的是要付出多大的努力，耗费多大的时间。而人生区区几十年，又能完成多少你所想的壮志和梦想呢。恐怕不多。这提醒我们，再不规划，再随风飘荡，恐怕连一件想要做的事也完不成，人生留下的将尽是无奈和事与愿违。比如一件小事，复习操作系统，你是直接就开始拿起课本复习，还是有规划的复习。没有规划，你知道自己几时能看完吗？你知道自己能在多长时间内看到多少程度吗？恐怕到最后要花很长时间，但是你当初没想到，恐怕你没有计划地想什么时候看两眼就看两眼，不想看就扔一边，最后只看了一点点就放弃了。这就是随性的最可怕的地方。你根本没有去预计自己会到达什么地方，你的预算能力将变得很弱，你的生活和人生将失去控制不由你主宰。看了人生7年the up series，才知道人生何其短暂，要达成自己梦想的成就根本没多少时间可以用。如果不从现在开始规划，7年后的你是什么样子呢。 规划的关注点不应该是自己的时间，而应该是具体的任务，对于许多长期目标来说，花多少时间去做事不重要，做完你要做的事才重要，做的不好不要紧，坚持去做。 注意自己的性格今天中午2点去华为笔试，做了一个性格测试，这是我第一次认认真真做性格测试，我突然发现自己的性格很有问题，于我对自己的的期望，幻想中的自己区别很大。可以肯定的说，以我目前的性格，恐怕无法实现我的梦想，让自己的能力和地位达到想象中的高度。如果我想要做一个领导，我需要哪些品质，又需要怎样去培养？如果我要让自己更受欢迎，我需要哪些品质，又需要怎样去培养？这些都是很重要的问题，平时如果不注意，对自己的梦想只是想想罢了，那到时候就会发现自己也真的只是想想罢了。有句话很经典，播种一种思想，收获一种行为，播种一种行为，收获一种习惯，播种一种习惯，收获一种性格，播种一种性格，收获一种人生。性格决定一个人的行为，而行为习惯又在巩固性格，或者形成性格。性格决定人的取舍和行为方式的例子屡见不鲜。性格将决定一个人的命运。但这也是个顽固的东西，很难改变，需要坚持。我觉得自己应该多问问自己今天做的这类性格测试中的问题，这些都是一个人的基本性格，世界观和价值取向，一个人灵魂的体现。我发现自己的性格很差，基本像一张白纸，没有自己的主张，有的全是懦弱，老好人，这跟我从小的经历有关。关于性格的培养，今后要有详细的规划才行。 你的迷茫值得吗？我们都想让自己的人生达到最优解，对此我推荐贪心算法（动态规划不可取，因为你无法归因，人生是向前的，你无法回到过去重来），我相信只要人生的每个阶段都最优化，整个人生的解一定不会差（相反，你如果每个阶段都混得很差，怎么指望活出人生的最优）。 这是我学生时期写的一篇关于怎么找准努力方向，走对正确的路，以及高效的学习和进步的一点思考。当时我正为自己的专业学的不好而感到恐慌和自卑，为自己遇到各种不懂的问题而不得解感到烦躁，继而封闭自己，企图逃避。高中到大学的跨越始终太大，有些人四年之中一直是迷茫的，这种深深的不适是教育体制造成的，但是这种改变也是必要的，因为你的人生你要自己负责，带你高三的老师班主任不会为这负责，不要被桎梏久了就忘了外面精彩的世界和人生。 从被动到主动，也许只需要一个观念的转变，也许对于许多人来说却是千折百回、痛苦煎熬。愿你不要再做一个被动的人。 学习不难，合适的路径获得难（有时候是教材没有讲得浅显易懂，有时候是自己没有潜心去看。还有时候是根本没有教材，也就是根本没有人带，苦苦摸索耗费你巨大精力，有种要死的感觉，大学的学习难于高中大概也是这种感觉（在上大学之前所有的知识都是老师一口一口喂的，大学里我所有的专业知识都是自学的，老师无异于一个摆设）。其实这个道理十分广泛，可以改成前进不难，找对路子难。关于学习方法，可以参考我这篇：学习方法总结） 最近一直感慨没有前人带路，走的步履维艰，回头看看自己走过的路。最后悔的莫过于没有参加ACM，没有任何竞赛，也没有奖学金，还有很多原本能做到的东西都没有去做。没有人提醒自己，教自己，不管是技术上的还是生活规划等等。我知道是自己以前都被别人规划好了，小的时候有家人带路，九年义务教育的时候有老师带路，何况我妈还是我小学老师呢，使得我从小备受关注和提携。现在才发现以前的那种生活状态才是不合理的，现在过的是生活的本质的样子，想要回头看的时候不那么后悔一定要得到全局视角，要跳出来看。去主动争取，去联系前辈们， 去获得过来人的箴言和 第三视角的指导，不要把自己框在现时现地 当然不能只听一家之言，要做大数据统计分析，然后应对现在，应对未来。 意识很重要自己终于意识到了，摸着石头过河是愚蠢的，是不必要的，前人早就有了经验，这条路并不是新的。但是生活中又有多少的东西是我还没有意识到的呢？突然有点恐慌。仔细思考一下，发现。其实意识不到是很正常的，你没有处于那个环境之下，没有经历和经验，始终是意识不到的。换句话说，意识不能凭空产生。要么自己经历了，要么别人经历了，然后告诉你，然后你获得了新的思考，恍然大悟，如获新生。 对的，意识不能凭空产生。那么节省时间的方法就是，去跟别人交流吧，去获得别人的经历，经验。去不断增强自己的见识，拓宽自己的视野。意识，思考，思想会源源不断的产生。 把自己闷在自己的思考里，并不能获得多少新的东西。 不要想当然，事情可能根本不是这样高中的时候以为成绩最重要，到了大学也继续这样认为，直到被现实打破，才知道了能力很重要（如果你在985大学，建议还是一定要刷好绩点，因为可以保研，而且还是保到很不错的学校，我自己就认为不注重成绩是我大学里做的最失败的一件事，因为相对考研来讲，平时的考试要拿高分确实简单不少）。可能到了工作中，我们还一直奉行能力很重要这一条，但是现实又会告诉我们关系很重要。可能我们觉得现在可以单身，不谈恋爱，到了工作后一定年纪觉得当时自己真的傻透了。就这样我们一直想当然，自以为是。现实会粉碎你的想当然，让你痛苦万分，后悔不已。可以大胆猜测，但是不要默默地就把它当成真理。 还是前面说的，我们应该去问问经历过的人，做大量数据统计分析。然后才能得出合乎事实的东西。补充：（大学里成绩同样很重要，保研和奖学金都靠成绩，即使考试很水，但判断学生的基本条件是成绩，而且认真的态度在哪都是最重要的，态度决定高度。我相信很多人身边都有这种人，他们就是凭着一股认真的劲儿，大学生活才如此丰富多彩。另外能力确实很重要，在中国并不是有关系就行，工作看的是业绩，那么能力就是重要的。可以说学习是学生的天职，那么成绩就是重要的，读研可能就是研究水平，就是发的paper的多少了，这些都是简单的就可以推理出来的，并不是想当然。而大学谈恋爱确实不怎么好，因为可能根本找不到我喜欢的女孩子也喜欢我的情况，将就自己会更加不快乐。要谈恋爱首先得正确的认识自己，然后看看自己的眼光和自己的水平是否匹配，眼光高水平低那就注孤生啊。） 获得局外视角的途径前面讲的三条都指向同一点：不要闭门造车，要找前辈，获得局外视角。所谓当局者迷，旁观者清。所谓经历过了才懂得。所以接下来我记下怎样去找。 找导师，导师再介绍师兄师姐。进论坛，找工作多年的前辈。（因为即将步入工作，可以问问工作中什么最重要，怎样让这个最重要的方面成为自己的强项）搜索各种群，进群找工作经验丰富的前辈。这里补充一句，现在的话，学计算机专业的同学可以找我啊，我们可以一起进步，共同成长，人类一直都是以共同话题和爱好而相聚在一起的，我相信未来的互联网的社区化会越来越成熟。 信息时代的一点思考这个时代的最大特征就是信息爆炸，人类每天面临着海量的信息，但有多少是有用的呢，这还真不敢恭维，其实有意义的东西就那么多，人类所有的智慧加起来也就那么多，学个大部分完全是可以的。所以面对信息爆炸最好的方法就是不要去接触那些杂七杂八的信息，而是 转过头去学习最本质的人类智慧，看看新闻可以、一些基本的娱乐常识可以了解，但没必要懂那么多，只要算个融入社会的现代人就行了，网上流行的东西更迭那么快，没必要主动去接触，被动的去接受就行了，只要你处在那个环境中，只要一件事很火，你自然而然就从身边的人那里得知了，而且这些都是没有价值的信息，只是为了塑造一种圈内认同感，就是我们都是现代社会互联网八卦这个圈内人。要学习、要搜索，主动去接触有价值的信息，规避泛滥的没有价值的信息。 比如各种广告，软文，比如打开有道词典各种推荐，千万不要点进去啊，比如知乎各种垃圾提问，粗浅的回答，抖机灵的回答，大部分其实也都是些无意义的信息，比如QQ聊天其实都挺没意义的。只要自己往前，不要回头（志同道合的可以稍微聊聊）。什么破公众号其实也没啥意思。这么看来我以前自我提升那么慢，进步那么慢，甚至退步，这些的最根本原因就在于被信息爆炸炸到了，被很多无意义的信息淹没了，感觉每天都很忙，其实都在浪费时间，都在消耗自己，都在做没有价值的事。幸好现在终于幡然醒悟。好好把新概念英语看的滚瓜烂熟，不要看知乎了，想学人生经验，心理学，哲学，经济学，法律，摄影等等，完全应该主动的去学，而不是被动的去每天刷知乎，这种学法完全错误，也就是说知乎是用来搜的，不是用来每天被动接受信息。可以按领域和话题搜索学习，也可以按人来学习，比如大V，肥肥猫，轮子哥，公众号罗辑思维可以听，因为这是聚合信息，王小波全集可以看，这两个都是按人来划分学习的。所以要么按话题领域，要么按人，来进行有效学习。少听点歌，多学点乐理。少看点电视剧，多学点写故事，小说。即有目的地做事，而不是无目的的消遣。即便再好的材料，你囫囵吞枣能尝出什么味道出来，你只是消遣能学到什么，看完了什么收获都没有那跟没看有什么区别呢？不要消遣和漫无目的啊，人必须要成长，提升，否则虚耗光阴，人生也就平淡无奇。信息爆炸带来的后果，就是无意义的信息大大增加，占信息总比越来越大，新出的游戏层出不穷，新出的影视剧层出不穷，新出的小说层出不穷，新出的音乐层出不穷，人们的时间正在越来越多的被这些东西夺取，游戏无非是一些逻辑加循环，循环多一点，故事也无非是一些逻辑加循环，循环少一点，背后的原理才是有意义的信息，而故事和游戏本身并不是那么重要，因为它们本身都是千千万万，根本看不完。现代社会有一个词应用而生：娱乐至死，这其实是信息爆炸带来的结果之一，也是人类生产力提高的后果，越来越多的工作交给了机器和自然能源，人空闲下来就开始找乐子，娱乐的东西现在每天充斥着我们的生活，刺激着我们的神经，而且虚拟的东西制作的越来越好，我们就用虚拟的东西去完成自己的梦想，但虚拟的始终是虚拟的。 伴随着信息爆炸，应该要 更好的信息处理技术，处理海量数据，要更好的交互技术，来帮助人机之间无障碍的沟通，最后完全可以做到记录人们每天的所有信息，所有想法。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Macbook]]></title>
    <url>%2Fblog%2F2017%2F02%2F03%2FMacbook%2F</url>
    <content type="text"><![CDATA[好的工具可以使人事半功倍，回顾整个人类史，又何尝不是一个工具史呢，从用石器到用火，从铁器到火药，从蒸汽机到内燃机，从汽车到电脑，我们在使用工具、利用自然规律，从而让自身变得越来越强大。 为什么推荐 Macbook我使用macbook pro 15 retina 已经一年了，感觉非常好（之前用过惠普的一个笔记本，加过内存条，折腾过固态硬盘，但最后还是受不了那风扇呼呼转）。现在我手头上同时还有一个surface pro 4 m3，M3也就是不带风扇的那款，性能一般，当初买是为了那支笔，能在电脑上写写画画，结果现在买了之后很少用这个surface，但是转手卖了又觉得亏本了，可惜，只好留在家里，留着以后做古董吧。 mac机器的亮点： 轻薄 另外触摸板真的很好用，我已经很久没用过鼠标了 retina屏也是非常养眼 立体声也十分不错 细节做得很好，充电口是磁性的，正反两面都能充，指示灯是能显示是否充满的（用过surface pro 4 的对比一下就知道，什么叫做细心），键盘背光，铝制机身，最后外观简洁美观。 OS X的最大亮点： GUI(Graphical User Interface，图形用户界面)和CLI(Command-Line Interface，命令行界面)的完美结合 优化的很好，系统耗电少。 开机速度非常快，另外不用老是关机，我很多时候一个星期都不关机。 缺点： 冬天用MacBook寒气逼人啊，把手放上面就知道了（南方，没有暖气，一般也不怎么开空调） 可以说这是一个不错的工具，无论是对普通用户来说，还是对程序员来说。最大的缺点无疑是：太贵啦。 所谓一分价钱一分货，3份价钱5分货，10分价钱7分货。意思就是，太便宜的东西往往质量很低，不便宜又不贵的往往性价比很高，特别贵的虽然确实质量非常好，但性价比却低了。 我秉承的一个观点是，如果一样东西属于易耗品，如：袜子，内衣裤。我们就应该买性价比高的，大众一点的，我还记得有一次傻逼的去优衣库买了双14块钱的船袜，结果穿了一次就起球了，气得要死啊，还不如买便宜的。如果是非易耗品，如：笔记本电脑，手机，西装，皮鞋，钱包，背包等等。我们就应该在能承担的价格内，尽可能的买质量好的（尤其是你注重这个东西的品质的时候）。我特别注重电脑和手机的流畅性，所以我选择了Macbook pro 和 iphone，我打算至少用个5、6年吧（现在的电子设备产品迭代这么快，能用5、6年真的相当不错了）。另外我的双肩背包一定会买非常结实的帆布的款式（而且功能要多），我现在这个背包就背了3年多了，看起来有点旧，但仍然很好用（有考虑换新的双肩背包了，但是还没找到满意的，这种东西还是不能随便买，就跟你闲置在柜子里的衣服一样，买了不喜欢，不穿，浪费钱，而且通常我们只有一个背包，这就更要精挑细选了）。 好了接下来就开始推荐MacBook的软件了： 软件列表国内的常用娱乐软件 Mac QQ，社交 网易云音乐，真的做的不是一般好，相比于其他的什么酷狗、多米。网易云音乐还有Linux版哦，UWP版（Universal Windows Platform）做的也很不错。这里要批评一下网易云音乐，Mac 版的分享是没办法给其他社交网络上的好友贴链接的（连 Linux 版都有的功能），我每次想分享出去都要打开 Chrome 使用网页版的网易云音乐，那我要你客户端干啥？已经提了 issue，看看网易云音乐的 Mac 工作组能不能加上这个功能吧，对程序员来说这就是顺手的事，做产品关键还是要用心啊。 新浪微博，这个我很少用，微博也刷的少，于是就卸载了，等以后学会高效使用新浪微博了估计会装一个。 百度云，比起Windows版的不知道难用到哪里去了，好在一直在进步。 迅雷，没有广告，比Windows的迅雷爽多了，每次打开Windows的迅雷9都有种想哭的感觉，各种广告视频自动播放，好抢眼啊。 leanote（蚂蚁笔记），现在的笔记软件都开始收费了，如：印象笔记、为知笔记，还有这个蚂蚁笔记也收费了。庆幸的是我现在不写笔记了，我写博客，热衷分享，帮助新人，提高声望。 为知笔记，为知笔记总体来说是最棒的，现在也收费了，但也阻止不了我用它。 有道词典 优酷客户端 爱奇艺客户端，亲们，这两个客户端放视频没有广告！！！，真是太赞了。 腾讯视频客户端，这个是新出的，同样没有广告，还可以看蓝光 阿里旺旺 每日英语听力 MacBook进阶软件： homebrew/brew cask（mac的软件源，让你可以像玩linux一样，用命令安装软件） Chrome，Chrome和Firefox，最经典也是最好用的两个浏览器。不过在MacBook上，safari的性能确实比chrome要好，另外safari可以强制使用HTML5播放视频哦，这样MacBook在看视频的时候就不会发热啦。 Atom，github推出的指定码农编辑器，MacBook上很好用，Windows上开启有点慢。（温馨提示，码字的时候，开着markdown previewer，打字会很卡，刚开始的时候我差点因为这个莫名的卡顿，而放弃Atom了，后来找到了原因😄） calibre，可以看各种电子书，转格式 LICEcap，使用gif格式录制你鼠标的操作。 Pocket，把文章收藏起来慢慢看的一个软件 iStat Menus，显示电脑的各种硬件状态 TeamViewer，跟QQ远程桌面控制类似，不过这个更专业。 Blu-ray Player，蓝光视频播放器，要收费，付不起钱只好在每次打开的时候把注册窗口叉掉。 Irvue，更换壁纸软件 Sip，取像素点的颜色软件 VMware Fusion，MacBook专用虚拟机 The unarchiver，解压缩软件 Keka，压缩和解压缩软件 OmniDiskSweeper，查找大文件 Bartender 2，把MacBook的顶层工具栏里的图标藏起来 Bartender 2效果截图 程序员往这里看： Xcode，相当于Windows上的Visual Studio吧，主要用来开发苹果平台上的软件，平常可以用来写写C/C++ iTerm2，超好用的终端软件 oh-my-zsh，超好用的shell dash，文档，内容相当丰富，连LaTeX和markdown的文档都有，不过有时候要等7秒钟才让你看文档。 FileZilla，FTP利器 github desktop，git的桌面版，很少用，程序员还是多用命令行吧，要不然让你搞Linux服务器，记不起git命令就显得low逼了。 Pycharm，jetbrains家的IDE个个都好用，这个是用来写Python的 Intellj IDEA，jetbrains家的IDE个个都好用，这个是用来写Java的 Android Studio，jetbrains家的IDE个个都好用，这个是用来写Android的 RubyMine，jetbrains家的IDE个个都好用，这个是用来写ruby的 CLion，jetbrains家的IDE个个都好用，这个是用来写C、C++的 jetbrains家的IDE 如何顺利的从Windows使用习惯迁移到macbook使用习惯，我写了一篇文章：从 Windows 转用 Mac OS X 记录 另外建议买东西不要贪小便宜，一定要买正版，我的 Macbook 是在淘宝上买的比较便宜的，结果屏幕涂层脱落了，商家也不给赔偿，送苹果 genius bar 查出我的机器不是正版，也不给修。最后换屏（非官方渠道，要1500人民币）]]></content>
      <categories>
        <category>数码</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[游戏人生--探险者的人生手册]]></title>
    <url>%2Fblog%2F2017%2F01%2F26%2F%E6%B8%B8%E6%88%8F%E4%BA%BA%E7%94%9F--%E6%8E%A2%E9%99%A9%E8%80%85%E7%9A%84%E4%BA%BA%E7%94%9F%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[人生没有意义人喜欢讲意义，但似乎是件很可笑的事情，因为意义是人虚构出来的东西，这个世界上有些东西存在就是存在，不讲道理的存在，没有意义的存在。不信你去问问宇宙存在有什么意义？宇宙之外有没有意义？时间有什么意义？人生又有什么意义？哪怕你想破脑袋也没用。别拿意义去套你的人生了，百年之后终归尘土。就像泰戈尔写的诗：鸟在天空划过，不留下任何痕迹。马克思哲学也说：新事物终将取代旧事物，历史车轮曲折前进。这里是说你会死，就算你不会死又能怎样，永远活下去就能找到人生的意义？嗯，如果能做到同宇宙同岁也许可以，但别瞎想了，在你有生之年都不可能实现。 没有一个终极意义你会慌乱吗？ 游戏 vs. 人生人都是喜欢游戏的，人可以进行没有实际奖励的游戏，人甚至可以进行不为输赢的游戏。很奇怪吧，当你小时候和小伙伴玩泥巴，当你打着坦克，玩着超级玛丽，当你打着魔兽、DOTA、英雄联盟，炉石传说，当你在Minecraft、饥荒里面一玩就忘了时间。你想想你到底在干嘛？你有为了某个意义去玩游戏吗？你也许会抱怨，人生为什么这么枯燥，人生为什么不像游戏？ 简单可行 及时反馈 无限尝试 公平竞技 发现没有，人生跟这四个属性一个都不挨边。 谁的人生是简单可行的？谁的人生是及时反馈的？谁的人生可以无限尝试，不服再来？谁的人生是生活在公平之中？ 一个复杂无比、充满未知的人生，一个慢慢长途、平淡无奇的人生；一个只有一次、甚至其中的很多阶段、很多事都只有一次的人生；一个连公平都做不到无比艰辛的人生。你想不想说一句life is a shit! 同志啊，这句话我早就想说了。 来来来，对着上面这四条，你仔细想想： 有多少人一辈子为生计奔走、迷茫、看不见未来、与机会擦肩而过？ 有多少人不停焦虑、制定计划、却不能坚持、始终碌碌无为？ 有多少事错了就不能再重来？ 有多少人，生来就缺乏竞争力？ 想通了吗？想通了就OK，你要是不能忍上面这四条，却依然厚着脸皮说你喜欢人生、热爱生活，我要骂你：真他妈能装逼，真是厚脸皮！那你要说，不然呢？我生下来就已经是这个样了啊，怪我咯！其实你是正确的，如果你还有活着的欲望，没有急着去死，那么你就该热爱你的生活，罗素有句话叫做：只有一种英雄主义，就是在认清生活真相之后，依然热爱生活。因为这是你的生活，你别无选择。 大学的同学不用再抱怨大学了，不就迷茫了四年嘛，你没发现你其实上大学之前也只是在幻想人生的美事吗？你没发现你上大学之前一直是被安排着忙忙碌碌吗？大学打破了你的美梦，很好，大学让你迷茫，很好，大学让你又闲又焦虑不堪，这更好，大学让你有时间开始思考人生，简直完美！ 其实你忘了，小学的时候你也被老师的抄写课文后的生字词这种作业，弄的死去活来，每讲到新的一课，就从第一课抄到这一课（PS：这就是我真实的童年）。其实你也忘了，上高中的时候，做不完的题，做题做到想吐，从此落下对做题的厌恶感这种奇怪的病根。 现在我们只关心一点，人生到底还有没有救。 简单可行？到底是否可以做到？在你学英语的时候，在你健身的时候，在你打工赚钱的时候。很显然这三件事都不简单，你不应该再过多的考虑这种复杂的事情了。生活中当然有简单的事情，只是你看不上它们罢了，或者你觉着它们的意义太低。比如背一篇新概念3的文章，不算太难，如果觉着太难，那就背一段好了，但是你会想一些看起来很合理，实际上很荒唐的事情，你会想：背了又怎样，有什么用呢？或者我知道背了有点小用，坚持下去背很多就更是有大用了，但这太漫长了，没人能坚持下去。这就牵涉到及时反馈了，你急需立竿见影的效果，否则会在一次又一次的考虑中丧失你的动机。 及时反馈？那你怎么及时反馈？背一篇新概念的文章的一段，对你学好英语的作用就是微乎其微，从这个角度来讲，你需要其他来源的反馈。 无限尝试是不可能了，但有限的 多次模拟 还是可以的。 公平竞技也是不可能的，这一点没有办法（很多英语国家的人不用死命学英语啊，长大成人了谁不会说母语？有些人出生就含着金钥匙啊，富二代官二代），我们只能靠自己，你也可以反过来想，起点很低，却靠自己的智慧变得很厉害，是不是更有成就感（强行安慰自己）。 把人生游戏化的方法从上面的分析可以看出人生非常难以游戏化，但我们不能坐以待毙，下面我来讲讲我自己的一些想法吧。 我自己是学计算机的，在外行看来，计算机是非常神秘的领域，就像某种魔法一样，事实上即便是我们这种内行，如果不清楚具体的实现过程，那么被抽象封装的部分依然是很神秘的，魔幻的。所以我们不妨把计算机技术当成一种现代魔法，而我们学计算机的都是魔法师，像Linus Torvalds、吴恩达这样的则是大法师。我们人区别于动物的地方是什么呢？ 知识 合作 我们能达成上百万人的合作（比如：波音飞机的整个生产过程，有人搞理论，有人设计，有人组装），我们能快速习得知识技能而不用依赖遗传和自然选择。知识+合作=文明。 怎样变成一个更优秀的人？ 习得更多的知识 拥有更强的合作技巧和能力 我们接受教育，不停学习，就是习得更多的知识，我们和人交友，加入公司，获取财富和资本，创业，拉投资，就是拥有更强的合作能力。 游戏是没有一个确定目的的（很多游戏可以有多种玩法和目的），即便很多游戏有一个终极目标，有一个通关的路径，但游戏的意义却非仅此而已，如果仅有一个最终目标，达成目标之后就变得无趣了。游戏拥有一个有趣的过程，让人沉浸其中。所以你可以给你的人生设定一个伟大的目标，但不要忘了，生活的意义不仅在于此，生活的意义还在于你生活的每一年，每一个月，每一天。 把事情变得简单可行，就是要分割和量化目标，提供及时反馈就是要量化成果，得到激励。无限尝试，就是要不停模拟实践。公平竞技，算了吧，不谈这个(你可以从比你基础更差的人身上获取安慰，你想啊至少你的出身没有差到那个地步，是吧)。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[百度贴吧ID挖掘机]]></title>
    <url>%2Fblog%2F2017%2F01%2F12%2F%E7%99%BE%E5%BA%A6%E8%B4%B4%E5%90%A7ID%E6%8C%96%E6%8E%98%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[去年我开了一个minecraft服务器，想拉点人进去玩，就想到要出去打广告啊，怎么办呢，我的好朋友lianera就跟我说，他以前在贴吧里面批量@别人，嗯，这是个不错的方法，他当时还给我看了他写的一个百度贴吧ID挖掘机，但不是用python写的，第一版C语言，第二版java。不过后来这件事没有做成，因为现在百度贴吧禁止批量@了。 后来我就想学点python，因为据说python代码特别简洁，这对于我这种极简主义者是很有诱惑力的，正所谓 – “人生苦短，我用python”（来源于：life is short, you need python）。另外python爬虫很有名啊，python玩数据很方便啊。数据时代怎么能不玩数据呢！于是我就一门心思想学python（其实还有一个原因，因为xx-net（一款翻墙软件）是用python写的，迟迟不出移动端的，我的手机也要翻墙啊，摔！我打算自己把xx-net移植到ios和安卓上，首先需要读懂代码啊，所以我还是需要学python，但后来lianera找了个便宜的VPS，并搭了shadowsocks服务，我们就一起用他搞的VPS翻墙了。。。）。 想着不能光看python语法而不做实事，我就重新造这个百度贴吧ID挖掘机轮子了。 先推荐我的github欢迎各位follow和指教，（程序员之间多多联系还是有必要的，大家可以讨论技术啊，除了技术还可以聊人生啊，电影啊，抱歉我以前是个文青，文科成绩一直很好，嗯，也爱科学）。 项目地址：https://github.com/liuqinh2s/Python 一开始我是用python2，然后想着python3才是未来，然后就想改点代码就升级了呗，但是python2和python3真的是有点不一样，改得有点蛋疼，不过最后还是弄好了。 代码写的不好的地方请指出来哈。 下面我讲讲思路： 首先定义了一个BaiDuTieBa类，用来获取HTML源代码，然后用正则表达式匹配抽取出用户ID，然后我用了一个全局的dict变量存放ID，最后把dict中的ID全部写入文件就可以啦。其中必不可少的要用到urllib库，re（regex, regular expression，正则表达式）库。 然后我就想啊，单线程爬的这么慢简直不能忍，于是就搞个多线程吧，至少把我的网速和带宽占的满满的。这里我使用了任务队列和线程池，简单讲就是把任务都放进任务队列里面，然后线程放线程池里面，线程呢不断的去取任务，做完一个取一个，直到任务队列为空。线程池代码是从网上借鉴来的，管他呢自己改改能用就OK。这里用了threading库，queue库。 然后爬的时候，你看看自己的网络，反正我的是瞬间飙升到几兆每秒了。 代码很初级，关键的地方都有注释哦，看不懂的地方私信我，我会在文章最后贴出常见的问题，并详细讲解。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165#!/usr/bin/env python3# coding=utf-8''' 这是python3版本的，看文件名，TieBaID3.py，这个3啊就是python3，懂了伐。'''__author__ = 'liuqin'import urllib.requestimport reimport threadingimport queueIDdict = &#123;&#125;#百度贴吧爬取用户ID，以minecraft吧为例class BaiDuTieBa(): def __init__(self, kw, pn): self.baseurl = "http://tieba.baidu.com/f/like/manage/list?" self.userAgent = "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36" self.headers = &#123;'User-Agent': self.userAgent&#125; self.kw = kw self.pn = pn self.IDdict = IDdict def getHTML(self): url = self.baseurl + 'kw=' + self.kw + '&amp;' + 'pn=' + str(self.pn) request = urllib.request.urlopen(url) # 注意这里网页源码编码是：GBK，用decode解码时要选择gbk pageHTML = request.read().decode('gbk') return pageHTML def getUserID(self): regex = re.compile('.*?username="(.*?)".*?') pageHTML = self.getHTML() UserID = re.findall(regex, pageHTML) return UserID def writeIDinDict(self): UserID = self.getUserID() count = 0 for id in UserID: count += 1 self.IDdict[count + self.pn * 20] = id def start(self): self.getUserID() self.writeIDinDict() print(u'写入第%d页用户ID' % (self.pn))def writeInFile(): file = open(u'./百度贴吧minecraft吧用户ID.txt', 'a+', encoding='UTF-8') # print(file.encoding) for i in IDdict: file.write(IDdict[i]+'\n') file.close()#具体要做的任务def do_job(kw, pn): spider = BaiDuTieBa(kw, pn) spider.start()def do_job1(kw, pn): spider = BaiDuTieBa(kw, pn) return spider# 单线程爬虫def NoThreads(kw, pn): for i in range(1, pn+1): do_job(kw, i)# 有多少任务创建多少线程，每个任务执行完就销毁相应线程，这种有点太恐怖，哈哈，任务数太多就爆炸了class Thread_spider(threading.Thread): def __init__(self, kw, pn): threading.Thread.__init__(self) self.pn = pn self.kw = kw def run(self): do_job(self.kw, self.pn)def MultiThreads(kw, pn): threads1 = [Thread_spider(kw, i) for i in range(1, pn+1)] for i in threads1: i.start() for i in threads1: if i.is_alive: i.join()# 用线程池和任务队列class WorkManager(object):# 这是一个线程管理器 def __init__(self, kw, work_num, thread_num): self.task_queue = queue.Queue() self.threads = [] self.kw = kw self.__init_task_queue(work_num) self.__init_thread_pool(thread_num) self.start_task() """ 添加一项工作入队 """ def add_job(self, func): self.task_queue.put(func) # 任务入队，Queue内部实现了同步机制 """ 初始化任务队列 """ def __init_task_queue(self, jobs_num): for i in range(1, jobs_num + 1): self.add_job(do_job1(self.kw, i)) """ 初始化线程池 """ def __init_thread_pool(self,thread_num): for i in range(1,thread_num+1): self.threads.append(Work(self.task_queue)) """ 开始执行任务 """ def start_task(self): for i in self.threads: i.setDaemon(1) i.start() """ 等待所有线程运行完毕 """ def wait_allcomplete(self): for item in self.threads: item.join(1) class Work(threading.Thread):# 这是线程类 def __init__(self, task_queue): threading.Thread.__init__(self) self.task_queue = task_queue def run(self): while not self.task_queue.empty(): self.task_queue.get().start()# 任务异步出队，Queue内部实现了同步机制 self.task_queue.task_done() # 通知系统任务完成if __name__ == '__main__': kw = 'minecraft' # 贴吧名称 pn = 1000 # 页面数 # 不用多线程模式 # NoThreads(kw, pn) # 即时创建即时销毁，多线程模式 # MultiThreads(kw, pn) # 任务队列线程池模式：（任务数：1000，线程：100） threads_num = 100 work_manager = WorkManager(kw, pn, threads_num) work_manager.wait_allcomplete() print("hello world") writeInFile()]]></content>
      <categories>
        <category>projects</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[那些年我读过的好故事]]></title>
    <url>%2Fblog%2F2017%2F01%2F10%2F%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E8%AF%BB%E8%BF%87%E7%9A%84%E5%A5%BD%E6%95%85%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[现代人们每天接触的信息量太过庞大，我们都试图把自己的时间花在有意义的、美好的事上和有效的信息上。所以我打算总结一下自己看过的一些作品，无论是电影、小说、连续剧、游戏、音乐都一并算上吧。影视剧和小说都属于 故事 类，音乐属于 艺术，游戏则是带有 故事的艺术（循环元素越多，信息含量越低，越消磨人的时间，而遗憾的是大多数游戏中的循环元素太多，而且含有上瘾设计元素，毕竟人家要挣钱，让你上瘾是在许多游戏厂商考虑之内的事）。 许多游戏其实有上瘾成分，所以含有上瘾设计元素的游戏，建议慎重考虑，不要入坑，这里点名：红色警戒、魔兽世界、魔兽争霸、英雄联盟、王者荣耀、炉石传说，这些游戏都非常容易上瘾，特别是跟小伙伴一起玩的时候，另外电子游戏跟传统游戏最大的区别就是：你随时都可以开始玩，这是很可怕的，如果你把所有时间都花在游戏上，那么就会耽误很多事。所以请相信下面我要说的这句话：如果你长时间沉浸式的玩游戏，游戏将抽空你所有的注意力，让你睡觉的时候脑子里都是这个东西，你甚至没有时间吃饭，拿衣服去洗衣机里洗。其实像：饥荒、我的世界这类游戏沉浸感也很强，玩游戏嘛就是等你玩出一种沉浸感，然后就开始轻度上瘾了，年轻人为啥喜欢玩游戏，这就跟老人下象棋是一样的，就是时间太多了，就用游戏消遣掉了，你听过中年人打游戏颓废掉的吗，应该很少吧，但我还是发现了一个游戏中的清流：纪念碑谷，这完全算艺术的范畴了，我通关后完全没有一点上瘾的感觉，只有过瘾的感觉，真是一场视觉和创意的盛宴，时间和钱都花的值了，我只玩了一遍，就像看电影一样，很多电影你也只会看一遍。 我们人就是喜欢听故事，好的故事更是令人神往，同时也能卖到好价钱，这一篇重点说故事类的作品，书籍类的记录到一定数量就新开一篇推荐。 好的作品可以陶冶人的性格，构建气质的最底层。 这里我列出来的每一部都是我自己看过的，为了纪念那个时候的时光吧。 当你列出来这么多看过的东西的时候，真的有种惊讶的感觉，我们总说时间太短、太少，其实我们花在了其他空间，在这些作品中，我们把自己带入进去，从而度过了短暂而精彩的一生。人生和这些电影相比有太多的冗杂和琐事，太多的、太漫长的过程，而人都是短视的、急功近利的、我们浮躁、我们想要精炼的一辈子，其实我们都错了，人生不过是一个过程，谁都逃不过一死，把自己沉淀下来，享受过程，缓慢的生长。 以过程为导向才是正确的人生态度，结果只是一瞬，你的人生应该也必须由过程组成。 电影印度电影 三傻大闹宝莱坞 3 Idiots (2009) 小萝莉的猴神大叔 (2015) 外星醉汉PK地球神 (2014) 摔跤吧，爸爸（2017） 然后是豆瓣上评出的经典影片： 经典永远不会老去 海上钢琴师 La leggenda del pianista sull’oceano (1998) 肖申克的救赎 The Shawshank Redemption (1994) 盗梦空间 Inception (2010) 楚门的世界 The True man Show (1998) 阿甘正传 Forrest Gump (1994) 当幸福来敲门 The Pursuit of Happyness (2006) V字仇杀队 V for Vendetta (2005) 黑客帝国 The Matrix (1999) 三部 布达佩斯大饭店 The Grand Budapest Hotel (2014) 霸王别姬 (1993) 这个杀手不太冷 Léon (1994) 罗马假日 Roman Holiday (1953) 泰坦尼克号 Titanic (1997) 辛德勒的名单 Schindler’s List (1993) 天堂电影院 Nuovo Cinema Paradiso (1988) 然后是我最爱的科幻片、悬疑片类型： 黑侠 这个男人来自地球 The Man from Earth (2007) 超时空接触 Contact (1997) 星际穿越 Interstellar (2014) 源代码 Source Code (2011) 蝴蝶效应 The Butterfly Effect (2004) 致命魔术 The Prestige (2006) 阿凡达 Avatar (2009) 恐怖游轮 Triangle (2009) 生化危机系列 异次元骇客 The thirteenth floor (1999) 异星战场 复仇者联盟 The Avengers (2012) 钢铁侠系列 绿巨人系列 大鱼 无姓之人 土拨鼠之日 然后是反正好看系列： 冰雪奇缘 Frozen (2013) 疯狂动物城 暮光之城系列 哈利波特系列 速度与激情系列 魔戒三部曲 驯龙高手1、2 疯狂的麦克斯4：狂暴之路 Mad Max: Fury Road (2015) 空中监狱 Con Air (1997) 国产电影： 翻滚吧！阿信 (2011) 夏日乐悠悠 (2011) 破风 (2015) 没错，三部里面都有彭于晏 连续剧美剧 &amp;&amp; 英剧美剧 冰与火之歌，又名：权力的游戏，A Song of Ice and Fire: Game of Thrones 行尸走肉，the walking dead（刚开始看是新鲜，后来就没啥价值了，无非是讲人性罢了） 西部世界，westworld 硅谷 达芬奇密码 英剧 神探夏洛克 黑镜 日剧 legal high（胜者即正义） 半泽直树 逃避可耻但有用 国产电视剧 琅琊榜 大好时光（并不值得看，当时看这个完全是奔着胡歌去的，看这个剧有种白开水的味道，有种淡淡的生活味儿，另外这个剧传递给你一种极正的三观） 李小龙传奇 恰同学少年 仙剑1，3 偶像剧微微一笑很倾城（并不值得看，除了让你羡慕嫉妒恨，或者活在梦里，没什么太大的意义，主角都太过完美了） 网剧 一起同过窗（并不值得看，大学过完了才看这个剧，对学生时代总有种意犹未尽的感觉，这个剧带你再次体验那些鸡毛蒜皮的青春时光） 白夜追凶 太子妃升职记（你要是想猎个奇，那就试试，其实没啥好看的，不推荐） 韩剧 爱在哈佛 太阳的后裔 W 两个世界 纪录片 人生7年，the up series 互联网时代（央视）(2014) 互联网之子 The Internet’s Own Boy: The Story of Aaron Swartz (2014) 史蒂夫·乔布斯：遗失的访谈 Steve Jobs: The Lost Interview (2012) 舌尖上的中国 wild China，美丽中国，BBC产的 小森林（春夏秋冬） 动漫国产 秦时明月 天行九歌 我是白小飞 日本动漫 火影忍者 海贼王 东京食尸鬼 寄生兽 进击的巨人 宫崎骏系列 天空之城 龙猫 千与千寻 风之谷 哈尔的移动城堡 起风了 萤火之森 小说 三体 缥缈之旅（修真小说的鼻祖，在喜马拉雅上听完的，并没有看文字小说，另外很多时候听着睡着了，不停的打怪升级而已吧，太长了） 王小波全集（我主要关注的是他这个人，所以他的所有作品都值得看看，我主要看了《沉默的大多数》） 和空姐同居的日子、第一次亲密接触。这两个也是听的广播剧，男女双人广播剧，言情类型的，不过也是红极一时的作品。在夜里温暖单身狗的小心脏。 陈二狗的妖孽人生（YY小说，在喜马拉雅上听的，同时也看了点网剧） 书籍时间管理的幸福学]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[学习方法总结]]></title>
    <url>%2Fblog%2F2017%2F01%2F02%2F%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[我把自己以前的多个思考笔记综合成了这一篇，有关于学习的 方法论，怎么学英语，怎么背单词，怎么做笔记，以及自我管理 你要坚信做任何事都不能蛮干，做每件事有每件事的方法，不要在错误的道路上越走越远 我把学习分为三个境界：重复、理解性学习、教别人 重复重复再重复你可能知道条件反射，即便是动物也具备的一种学习方法，马戏团天天在证明这一点，通过不断的重复（训练、奖励、惩罚），猪都会钻火圈。无论是学母语，还是学英语，基石都是重复。 构建认知网络人的认知是一张一直在不停编织的网络，很多知识，抽象出来的结论、认知，都是相通的（类似的），人通过联想来举一反三，并通过这种联系轻松的记忆学习。 所以死记硬背是低效的，因为你试图孤立你所学的知识，而孤立的东西难以被人记起，你可以回想一下自己是不是经常忘记熟人的名字，如果熟人的名字都能忘（你是不是仅靠重复使用来记忆别人的名字，而不是通过联系其他事物呢？），忘掉知识不是很正常吗。 所谓理解性学习，就是用原有的认知去解释新事物，以至于新的认知变得水到渠成，你可以从很多条路子记起这个知识，那么你就内化了这个认知，这才学到了位。 构建自己的认知网络，就是理解性学习，学习来不得半点生硬，重复重复再重复，固然有用，但时间久了依然会忘记，并且很多知识都是需要灵活应用的，你要把它跟其他东西联系，而且你必须这样做，否则一个孤立的知识，你记得或者不记得没有任何区别。在已经构建好的认知上添砖加瓦，并不断试图从多个不同角度去应用它，让它指导你的其他思维和行为，这样才能慢慢内化。 不要因此而有了不努力去重复的练习和学习的借口，认真在任何时候都是首要的精神 理解性学习的不可跳跃学习其实不难，你觉得难，觉得不懂，原因只有一个：如果一个结论得出来你无法理解，那就是从前提到结论这个过程你无法理解，为什么无法理解，原因也很简单：这其中暗含着一些前提，而这些暗含的前提你是不知道的，或者还没理解，这造成了一个跳跃，而学习和理解是不能跳跃的，你在这里断了链条，那么就会无法继续前进，或者云里雾里，一处不懂处处不懂。 学习是有路径的，一个初学者你给他看高深的理论，中间越过很多步骤，他是根本无法学会的。你必须一步一个脚印，也只有一步一个脚印才能学的会，学的好，学的精通。很多人由于觉得难就很烦躁，产生畏难情绪，觉得累，想要放下或者放弃。其实就是因为没有找到属于你的学习路径。必须要把中间的那些暗含的前提找到弄懂，然后你就理解了，就可以继续上路。判断一个学习资料是否合适，就要看这份学习资料，对你是不是太难，太难肯定学不下去，太简单又浪费你的时间。 费曼学习法费曼学习法的精髓就是通过教授来强化学习，在教别人的时候你对所学的东西的理解会进一步巩固加深。 其实你教别人的时候就是在解构理解的过程，也是在重复理解的过程，你讲的越是清晰明了，别人一听就懂，就证明你自己的理解过程越成功越细致，何况你自己还在重复，所以用这个方法来复习是非常棒的，效率很高。 怎么学英语学英语应该是很多国人的痛点，因为学了很多年都没学好，有些从小学开始学，有些从初中开始学，但直到大学本科毕业，英语还是很差。我知道这种苦楚与恐惧，也曾想学好英语，但一直没成功，我在思考这里面的原因，又加上看了一些人的见解，我总结如下：没有环境，这是根源，记忆是靠重复加强，靠关联其他记忆来内化。学习语言尤其要重复，可能因为语言是人类表达的根基，主要是靠死记硬背和疯狂输出，你总不能靠推理来学习语言。所以我们学英语的强度还远远不够，我们没有环境，如果有语言环境，那你在无形之间就已经达到一个高强度的状态，所以我们只能靠自己去打造这种高强度的环境。至少你每天都在学英语用英语吗，如果你做到了，你的英语肯定稳步提升。问题就出在这儿。当你看到英文时是不是恐惧性的跳过不看，当你看到不认识的单词你是不是没有去查，就这还想学好英语，你自己内心里都不会相信吧。这还只是初步的，你有没有刻意去输出呢，输入还算有点环境，毕竟英语的资源一不小心就接触到，但输出好像还真没机会。模仿造句应该被当做像你打游戏中的做日常任务，每造一个句子你都该记录下来，作为游戏日志，累积财富，写文章应该当做下艰难副本，每写一篇你都该奖励自己。对语言的热爱是重要的一个环节，去了解英语文化是有好处的，但另一个重要的环节是坚持，坚持属于长期控制，跟你的短期利益其实没多大关系（所以没几个人能坚持做一件事，随时可能放弃），真正能控制你做一件事的就是 及时反馈，就像很多人打游戏会上瘾，这是人的先天特征，短期利益永远重要，及时的反馈才能刺激我们的神经，坚持学英语也应该建立短期目标，提供及时反馈。这和新东方英语老师朱伟所说的：”多一些不为什么的坚持，少一些功利主义的追求“，其实是一样的，说的就是 长期目标无法让人坚持，心怀大志的去做甚至还不如莫名其妙，毫无理由的去做，有句古话很伤人，叫：“小人常立志，君子立志长”，我曾经就被这句话伤过，因为一直是一个有抱负有理想的青年，曾今有过很多远大的理想，但现在依然没什么值得说的成就，而且我经常会遇到与自己对立起来的情况，想要坚持，但又坚持不了，这其实不应该怪自己，就像你饿了要吃饭，而不是怪自己要吃饭，人应该多多发现自己的本性，而不要去对抗，在进行意志力对抗赛中我们应该常打胜仗，而不是去打必定失败的仗，比如你可以定一个小目标，跑1万米，雨中登山，这种短期的较量，只要你肯对自己下狠心，一定可以做成（而不是制定一个过于长远的计划），而且事后会极大的提升自己的自信，而人一天不是每时每刻都斗志满满，在脆弱的时候支撑你的绝不会是你的意志力，而是习惯，我们所做的所谓坚持，往往毫无胜算，而且不断地一次又一次的伤害到自己，不断的消磨意志力而不是提升，最后只会自己和自己对立起来变成一个真正的屌丝，和loser，真的是会有自暴自弃的那一天，只是你现在还年轻，但你仍然会发现岁月不曾停一刻地磨平你的棱角和骄傲，这大概是很多人经历过的吧。我们不应该用自己不多的意志力去打一场不可能赢的仗，我们应该用习惯，用及时反馈，用短期利益，和短期突进训练计划（强迫自己在一个较短的时间内做完某件困难的事，比如跑1万米，看完某个难懂的书的一章，需要查阅大量资料补全理解过程）。初时，随心所欲，以至于放荡不羁，堕落而颓废；中时，勤于律己，结果自我对立，苦不堪言；末了，依旧随心所欲，而不逾矩，如列子乘奔御风，逍遥自在，内心合一。这大概就是看山依旧是山的境界吧。我们需要的只是一个系统的及时反馈方法，和一个一个短时间的小目标（把一个大的计划分解成小目标是有道理的，人可以在短时间内强迫自己，熬一熬就过去了，相信你的意志力）。我这里并没有谈具体的技巧，想看具体技巧可以看接下来的 背单词”。 背单词做一件事，首先要证明他是否对你有用，否则不去做（这里我想说说对于游戏的态度，大多数人生来都喜欢玩游戏，但很明显很多人玩游戏上了瘾耽误了不少事，导致生活过的很糟心，我指的是大多数大学生哦，其实你有没有想过不是你在玩游戏，而是游戏在玩你）。背单词是学习英语的一个重大话题。有人说不用去背单词，因为背了单词却不会使用这样的大有人在，应该去广泛的阅读，在文章中记住单词的意思；有人说应该去背句子，用句子串起单词，这样就知道单词的用法；也有人说在阅读中增长词汇量太费时间，背单词是增长词汇量的捷径。我发表一下我自己总结出来的一套看法： 做任何事都要有正确的方法才能事半功倍，英语学习也是一样，我们可以科学地把学习语言分为：输入和输出，听、读是输入，说、写是输出，输出是输入的巩固和保障，没有输出，英语很难学好，事倍功半。这就是为什么我们大多数中国人总是学不好英语的原因，没有输出环境，输入环境倒是还可以。解决办法就是补上这个输出环节，方法无非是：强迫自己写作，学习地道的写作，地道的英语表达，强迫自己去说，学习地道的口语。 做事情慢比做错好，背单词首先要保证至少背的是正确的意思（无论是中文还是英文释义），在这个对的基础上，背了总比没背要好。 其次关于对背了单词却不会使用的问题，背单词属于输入，使用单词属于输出，你只是背单词当然不一定会使用，使用还得靠说，靠写。而架起输入和输出的桥梁就是模仿，再粗陋一点就是背诵然后一字不改的输出来。多背好句子，长句也好，短句也好，当然这个句子必须有亮点，要不然你自己都能写出来，就没有意义，比如全世界人都会说：I love you.[^1]要明白自己的起点，少做一些无用功。然后就是模仿造句，就像小时候学习中文的时候的造句练习。写短文，然后同样是模仿练习。这里说的背诵并不是要求你过多久都还记得背了什么，而是作为一个模仿对象，帮助自己正确的输出自己想要表达的东西，请问你小时候背过的文章你还记得几篇？关键不在于记忆故事、内容，而在于内化英文表达，形成语感。所以这里的背诵也可以理解为熟读，模仿。 我最想说的一点就是，我们很多人的词汇其实也不算低，但说英语根本没词，没话可说，或者说出来一堆的中式英语表达。原因在于，一门语言背后往往承载着一个相应的文化，就像我们中国不同地方的方言的表达也是不一样的。普通话说：行，河南话说：中。中西方文化差异造成了，即便你认识很多单词，知道很多语法，你依然不知道怎么去描述一件事，表达一种意思。因为别人文化里的表达方式和你的不一样。我们说：毫无睡意，英文表示则是：wide awake。请问这个表达是你直接能想到的吗，我们大多数人可能喜欢从字面上，一字一字翻译，这完全是错的，真正的翻译应该是一个意思对应一个意思的翻译，假如英文中有个意思中文里没有怎么办，这就是极考验翻译水平的地方，你要用简单易懂的方式解释，甚至可以创造一个舶来词。记单词并不是全部，背表达方式才能真正的学会一门语言。 既然背单词是可以有的，那么背单词该怎么背，我推荐用词频[^2]，按照语言掌握的一般规律，先背最常见的，再背次常见的，以此类推。一般柯林斯的词频就行了，网上也是很容易找到，柯林斯选出了1万多的词，把这些词总共分了5类，用五角星标记，五颗星的是最常见的，比如词频排名第一的the，就在这里面，依此类推，一颗星的是词频最低的，当然还有不带星的，那种单词就更少用到了，所以也不用急着去背。按词频背单词可以让你精确定位常用单词，避免学了一堆不常用的，这种安排其实也发生在我们学英语的整个过程，比如小学单词比初中单词常见，初中的又比高中的常见，高考的又比大学四六级的常见，大学四六级的又比考研、托福、雅思、GRE新增的词汇常见。按词频背单词还有一个好处就是可以查漏补缺，你可以清楚的知道自己哪些单词还稍微陌生，还有哪些重要的单词还完全不认识，这是靠阅读学单词花费大量时间也无法办到的。这叫针对性。当然阅读中学单词是有用的，一般来说我们可以在阅读中巩固对单词的记忆，用法等等，用起来的单词更容易记住，因为“用”这个词，代表你在反复强化你脑中的那些相应的神经元路径[^3]，而且增添更多的应用场景（新的神经元路径），让你记得更牢，更生动。 结合互联网的现代化笔记法今天对于记笔记又有了点新想法，结合以前的，总结如下： 所有笔记都不可靠，最终要记在脑子里，内化成自己可以随时调用的资料，和意识。笔记只是为了便于复习回顾，没有内化它就不是你的，只是一团外在的信息，对你来说也就跟没有一样，你还是你，当笔记是身外之物的时候它是不可靠的，只有当知识、技巧和思维方法内化进你大脑的神经回路里，它才真正成为你身体的一部分，是自我意识的一部分，你也因此变得更加强大起来，然而很多人学的知识是死的，不能用于帮助自己解释和理解这个世界，和身边发生的各种事，那你学这些东西又有什么意义呢，你面对这个纷繁复杂的现象宇宙，鸟还是鸟，花草树木还是花草树木，月亮还是月亮，感性统治着你，所有知识和理性全都被封锁起来，你看不透这个世界，也没有借助自己所学去帮助自己看透这个世界，于是你忘了你学的东西。自始至终都没有用到它们，忘掉是很自然的。但其实它们就在你身边，无时无刻不在，只是你没发现它们，没有有意识地去看见它们。这样的学习学一辈子都是竹篮打水（漏的跟打的一样多），到头来一场空，白白虚耗了时光。少年，想获得力量吗，那就去做个有心人吧，把知识用起来，让它成为你大脑的一部分。 笔记一定要电子化，书籍也电子化，因为电子化便于携带，传输，查阅，搜索，检索。就算先写在纸上，但之后也要拍照整理成电子的（并附加上关键词，摘要），数据不应该流失，遇到半熟的知识，第一反应查笔记，第二反应上互联网搜，并把学到的用自己的语言记在笔记里。 善于找别人记下的笔记和总结，同时利用起像百度百科和维基百科和各种人的博客等等东西，前两者比较稳定，所以可以贴链接即可，后者不稳定一定要截图，或者复制粘贴。这样做是尽量保证笔记的持久性，其实这么久的持久性也没啥用，因为你势必要在相对较短的时间内消化知识，你不消化它就会淡忘，你不用起来它就相当于没有，你也就白学了。比如我一直想整理出一份完整的系统的数学笔记，但我其实没有必要一笔一笔写下这个笔记，而且我也没有这个时间去干这件事，而且说到底笔记只是用来协助内化记忆，本身就只是一个附带性工作（当然也不能潦草敷衍，否则难起到应有的作用），何必如此执着，真正要下功夫做的是记忆，运用（做题，解题中应用知识），并结合生活这本无字大书。别人的笔记不完整，这不要紧，你自己立好框架，然后以添加URL链接的方式把这些内容接入你的框架。比如今天我找柯西中值定理的证明，我忘了怎么推导这个定理，我去谷歌搜索了，维基百科里有完整的证明，我只需在笔记中柯西中值定理证明这一处添加一个链接，或做个注释。如上所说，我只添了：证明，维基百科，这么几个字，这是因为只要在有互联网和手机的时候我就可以立即查阅，互联网是一个非常便利的云端，增强了每一个现代人的移动性（这一重要属性在罗辑思维里，吴伯凡总结过，生物的一个基本属性就是移动性，越高等的生物移动属性越高），这就是结合网络的笔记法，整个网络都是你的笔记，你只需要做个标记就可迅速找到。 由此便可得出 只列框架和名词的高度精简笔记（甚至框架也可以在互联网上找到合适的，但每个人都有自己的知识树，另外框架是个索引性的东西，你自己必须非常熟悉，如果索引都依赖于外部，你自己还剩下些什么呢，特别是重要的索引，一定得是非常熟悉的）： 概念 应用场景 发现背景 证明推导过程 习题等等都以树状链接开来，有本地的拓展也有互联网的拓展部分。 由于互联网上的许多内容不一定正确（甚至有的时候会误导你），不一定完整，而书籍和传统出版物相对来说靠谱，所以做笔记时强烈建议考虑内容的质量。 [^1]:英语和汉语的共同点就是主谓宾的顺序是一致的，不同点在于修饰，英语的修饰习惯后置，汉语的修饰从不后置，一定是放在前面的 ↩[^2]:词频号，代表词出现在词频排名中的位置，比如the的词频号是1，代表它在语料库中出现频率最高，排名第一。 ↩[^3]:人脑记忆的物理特点：靠神经元的链接，电脑存储的特点：靠电子元件的电位固定地，精确地存储。有时候你忘了一样东西，并不是他消失了，而是它在你脑中的神经元连接路径太弱、太少，你搜索不到它。所以我们记忆有两个特点：一个是不断重复强化，加强这条路径；一个是把要记忆的东西跟很多已经在你脑海里最常用的记忆联系起来，也就是并入你的记忆主堡，那你将快速的找到它，这也是理解性记忆的根源，因为理解代表与你的已有认知不悖，也就是可以由已有定理推出要学习的定理，如果推导一个定理可以有很多方法，或者有一个非常容易想到的方法，那么这条定理顺理成章的就被你记下来了。死记硬背则是用的第一种方法，不断的重复强化，但效果不佳，原因很简单，我们的大脑天生喜欢第二种方法，这是大脑的物理结构决定的，物理基础决定上层建筑，只有把一个东西并入你的知识树，内化成自己的日常认知习惯，它就牢牢的钉在你的脑子里，成为你随时可以调取的记忆，而这也是世上不存在靠死记硬背能真正学透的原因，因为死记硬背没有使这个知识和其他东西联系起来，就像你是一个瓶子一个瓶子的装知识，其间泾渭分隔，发散性很差，那么你根本不会在很多要用的时候想起它来，也就无法学以致用。 ↩]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[从 windows 转用 mac OS X 记录]]></title>
    <url>%2Fblog%2F2017%2F01%2F01%2F%E4%BB%8Ewindows%E8%BD%AC%E7%94%A8macOSX%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[这篇文章我想讲讲我从用 Windows 到用 mac OS X 的过程中遇到的困难和解决方法。 由于我本人是学计算机的，电脑用的多，喜欢用一些设计的好的快捷键，所以我分为两部分吧，第一部分讲给普通用户，第二部分讲给程序员。 先告诉你们一个通用小技巧，众所周知，flash视频非常让电脑发热，而看HTML5视频则一点都不热。safari有个伪装成iPad或者iPhone的功能，可以把视频强制用HTML5播放。你的MacBook就再也不会在看视频的时候发烫了。 时至今日（2017.9.9），很多网站都可以使用 HTML5播放视频了，如：bilibili，中国大学MOOC，使用 HTML5播放视频是未来的方向。 普通用户使用mac指南浏览器找不到浏览器吗？点击像指南针图标的那个safari，那个应用就是浏览器。 输入法和初次使用Linux一样，一上来我们肯定就要碰到输入法的难题，mac切换输入法的快捷键是command+space（空格），一般的系统或者软件都是支持自定义快捷键的，你可以修改快捷键。对于用惯了搜狗输入法的同学，这里我推荐使用搜狗输入法，它可以记住用户习惯。 搜狗默认的通用中英文切换键是 shift。 触摸板mac的触摸板应该是所有笔记本电脑触摸板的宗师吧，而且也是最好用的触摸板。我用mac的时候，除了玩游戏，完全用不着鼠标。 没有鼠标，那么左右键怎么办？很简单：一指单击触摸板，就是左键，两指单击触摸板，就是右键。记得将轻触触摸板设置为点击，这样可以延长触摸板的寿命，而且点起来也舒服多了。 五指合拢，你可以看到你电脑上安装好的应用，这个界面叫做：launchpad。 五指弹开，如果你处在launchpad界面，五指弹开就会回到原先五指合拢之前的那个界面，回到这个界面之后，再用一次五指弹开，就是弹开所有应用，让你看到桌面（如果你当前窗口是全屏模式，则此法失效）。 三指上推，可以看到所有打开的窗口的缩略图。 三指横扫，可以在全屏之间切换，这是我最喜欢的设计之一。 安装应用去官网下好应用，通常是.dmg后缀的安装包，打开，拖拽到Applications文件夹就完成了安装，比Windows爽多了吧。 文件管理器Finder调整默认Finder窗口大小，可以按住option，然后进行拖动，窗口的大小就可以保留下来了。 command+shift+.可以显示隐藏文件，关闭显示隐藏文件也是这个快捷键。 右键之后，没有新建文件选项。 你只能先打开应用，然后在应用中新建文件。 记住在Windows上用的很爽的ctrl+a、ctrl+s、ctrl+c、ctrl+v、ctrl+f等等，在mac上统统把ctrl换成command就OK了。 command+x不能剪切文件和文件夹是吧。 解决办法是：先command+c，然后command+option+v，成功的完成文件的剪切和粘贴。 普通用户的指南到此结束，如果有什么问题，请私信我的知乎，我博客头像下面有个知乎的知的图标，点击就能到我的知乎个人主页。 程序员mac指南先上几个零碎的小技巧： 触摸板双指双击，放大（我觉得其实没啥卵用） 在应用窗口顶栏双击，缩放窗口（这个Windows也有的） 文件管理器Finder首先讲Finder，这是mac 系统，也就是OS X系统的文件管理器，和windows的文件管理器对比有点不同，最不方便的地方在于点击右键没有新建文件选项，如果你会Linux，可以用命令touch 文件名来新建文件，如果你不会命令，可以先打开文本编辑器，再新建文本文件，它的设计哲学是，你要新建什么文件，就先打开与这个文件相关的软件，再在这个软件里新建这个类型的文件，不过不方便就是不方便。再讲讲优秀的地方，Finder可以打开多级目录。 另外可以 按空格键预览，这个预览功能现在 Windows 也有了。 Finder还有tag系统，你可以通过tag来访问属于同一个tag的文件 快捷键 快捷键肯定是最重要的啦！ 然后讲讲快捷键设计，我在windows下已经有了些使用快捷键的习惯，比如： win+E是打开文件管理器 win+D是显示桌面（也就是将所有窗口最小化） win+L锁屏 ctrl+S保存 ctrl+A全选 ctrl+C复制 ctrl+X剪切 ctrl+V粘贴 ctrl+F查找 当我来到OS X下的时候，我同样先摸索了一番快捷键。设计快捷键的哲学就是通用，这样就可以节省记忆成本，mac上的cmd基本上承担了windows上ctrl的职能，常用的快捷键有： cmd+S保存 cmd+A全选 cmd+C复制 cmd+X剪切 cmd+V粘贴 cmd+F查找 cmd+D制作副本 按住option+command，拖动文件，可以产生快捷方式，也就是链接。 cmd+, 打开preferance也就是打开设置界面，这个快捷键简直不要太爽，希望 Windows 上也弄一个 cmd+N 打开新窗口 cmd+W 关闭窗口 cmd+H 隐藏窗口 cmd+Q 退出程序 cmd+ctrl+F 全屏和退出全屏，播放视频时候退出全屏一般是 ESC 键 cmd+Tab切换程序 你用了Finder之后可能会恼火没有剪切文件的功能，但其实是有的，只是快捷键不一样，剪切文件的快捷键是，先cmd+C复制，然后cmd+option+V粘贴。 这是我常用的几个快捷键。总之快捷键不用记很多，按你自己的需要，记住常用的就行。 Command+Option+D 控制Dock的显示与隐藏，我还是喜欢留着 Dock。 Command+Option+H 隐藏所有其他窗口 Shift+音量 会有声音，直接按音量默认是不出声 Command+I 显示简介（在Finder中），然后就 可以修改打开一个文件的默认APP Command+Control+N 新建一个文件夹，并归类你选中的所有文件 编辑文本的快捷键Command+Space 切换输入法 Command+left 让光标跳到最前面，相当于windows下的home键 Command+right 让光标跳到最后，相当于windows下的end键 Command+up 让光标跳到整个文本的最开头 Command+down 让光标跳到整个文本的最后 Command+delete 删除当前行，相当于windows下的home，shift+end（选中，从行头到行尾），backspace，这三个操作的组合。这个快捷键会让你相当爽的。 截图快捷键Command+Shift+3 截取整个桌面，并把截图作为一个文件存储在桌面上 Command+Shift+4 截取一个区域，并把截图作为一个文件存储在桌面上 Command+Shift+Ctrl+3 截取整个桌面，并复制到剪切板 Command+Shift+Ctrl+4 截取一个区域，并复制到剪切板 Command+Shift+4 然后按Space就会截取一个窗口。这样截图会自带阴影效果。如果不想自带阴影效果，可以按住option再点触摸板。 Command+Ctrl+A mac QQ 截图快捷键，由于屏幕分辨率太高，mac系统快捷键截出来的图都太大了，而macQQ截出来的图大小正合适。 Chrome浏览器快捷键这个应该是与操作系统无关的（有些快捷键还是不一样的），但在Mac下养成了用快捷键的习惯，所以Chrome的快捷键都是在Mac上学的，在windows下注意用Ctrl替换Command键就行了。 Command+R 刷新 Command+L 将窗口焦点锁定到浏览器的地址栏，不用移动鼠标哦 Command+T 打开一个新Tab Command+Shift+T 打开一个之前被关闭的Tab Command+Shift+J 打开下载页面 Command+Shift+C 打开“检查(spectator)”，鼠标右键可以看到这个选项，一般是程序员使用的高级功能，但不能再次使用快捷键关闭。 Command+Shift+I 同样是打开spectator，使用开发人员工具，但可以再次使用快捷键关闭。 Command+Shift+B 打开或关闭书签栏 Command+Option+B 打开书签管理器 Command+Y 打开历史记录 Command+Option+左右方向键 切换标签页 Command+D 收藏此页为书签 Command+Shift+D 将所有标签页加书签 Command+上下方向键 跳到页面顶部或底部 Command+Option+J 打开javascript控制台 按住Command后点击链接，在新Tab（标签页）中打开这条链接。 Command+Shift再点击链接，在新标签页中打开并切换到新标签页 Command+Shift+N 用隐身模式打开新窗口 Command+Shift+W 关闭当前窗口 Command+[ 或者 ] 前进或者回退 Command+左右方向键 前进或者后退 Command+Option+U 查看网页源代码 iTerm2快捷键iTerm2中的文本，选中即复制，这个其实没必要，我现在都习惯了选中后 cmd+c，而且当你选择替换目标时候由于这个选中即复制，会覆盖掉你的剪切板 Command+D 水平分隔出一个终端 Command+Shift+D 垂直分割出一个终端 可以配置透明度，Command+U快速切换透明与否 可以配置全局唤出快捷键，我自己配置的是Command+U 可以配置快捷悬浮，Hotkey window Command+Shift+H 查看复制历史 Command+Enter 快速切换全屏与否 CLI(命令行)快捷键Mac本身的特点就是GUI和CLI的完美结合（很多Linux的爱好者，又不想被Linux的桌面、各种驱动、不兼容等等杂七杂八的问题折腾的，大可选择Mac）。 首先教一个最重要的东西记住按Tab补全，这是命令行用的爽的根源。 Ctrl+A 回到行首 Ctrl+E 到行末 Ctrl+U 删除一行 格式转换有时候需要把 png 等格式的图片转成 jpg 的格式，于是有同学就去到处找格式转换软件了。其实在 Mac 中直接更改图片的扩展名，即可自动转成相应地格式~试试吧，如果你改格式前看了文件修改日期，改完格式后你会发现修改日期依然没变，至于原因是什么，需要你有图片的文件格式的相关知识。 Launchpad与DockLaunchpad是指，你在触摸板上用五指向中间收拢，出现的全是APP的页面，半透明的。 Dock是指，最下方的摆满APP的一栏，在Dock上你可以放上最常用的APP。 调整launchpad的图标大小： 123456789101112//把行数重定义成6delete write com.apple.dock springboard-rows -int 6//把行数充定义成默认defaults write com.apple.dock springboard-rows Default//删除定义好的行数（恢复默认）defaults delete com.apple.dock springboard-rows//把列数定义成默认defaults write com.apple.dock springboard-columns Default//重置 Launchpad，效果就是 launchpad 的布局全给你打乱了，而第一页恢复默认，建议不要使用defaults write com.apple.dock ResetLaunchPad -bool TRUE//重启 Launchpad，并使你前面的设置生效killall Dock 在appstore下载一个软件到一半，然后在Application删除了该软件，结果在launchpad中留下了一个垃圾残留空图标。删除launchpad中的垃圾残留图标，只需拖拽到下载文件夹。其他方法都试过（无效），比如按住图标几秒，出现一个叉，点击叉，删除，没用。在Application找到相应项删除没用。 Option的妙用下面再讲些不常用但是有意思的： 除了cmd是常用的，option键也值得我们关注，下面讲几个option的妙用： 按住option+shift可以微调（1/4微调）音量、键盘背光亮度和屏幕亮度，按住option再按其他字母键等，会出现奇怪的字符¥©©œ∑®†¥åß©≈ç等等。 按住option再把鼠标移到Dock上的APP上，你会发现退出变成了强制退出，怎么样option键还是挺强大的吧。 数学符号约等于: Option + X = ≈度数: Shift + Option + 8 = °除号: Option + / = ÷无穷: Option + 5 = ∞大于等于和小于等于: Option + , 和 Option + . = ≤ 和 ≥不等于: Option + = = ≠圆周率: Option + P = π加减: Shift + Option + = = ±开方: Option + V = √求和符号: Option + W = ∑ 输入特殊符号版权符号: Option + G = © 人民币符号: Option + Y = ¥]]></content>
      <categories>
        <category>数码</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[线性代数笔记--基础篇：行列式、矩阵的本质]]></title>
    <url>%2Fblog%2F2016%2F09%2F30%2F%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0--%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%9A%E8%A1%8C%E5%88%97%E5%BC%8F%E3%80%81%E7%9F%A9%E9%98%B5%E7%9A%84%E6%9C%AC%E8%B4%A8%2F</url>
    <content type="text"><![CDATA[线性：量和量之间的关系是一次的线性代数的核心研究对象：向量 行列式的本质定义（行列式的绝对值）是n维向量所构成的图形的面积或体积（面积和体积分别是二唯和三维的说法，更高维数依次类推）。determinant（行列式） 行列式的性质 $D_n=|A|中某行元素全为0\Rightarrow |A|=0$,因为有一个向量为0，所以构成的图形比n少一维，所以体积为0。 $D_n=|A|中某两行元素对应成比例\Rightarrow |A|=0$,因为有两个向量是平行的，所以构成的图形体积为0. （互换）$|A|$中某两行元素互换$\Rightarrow|A|$变号(即得到$-|A|$),两向量的夹角变了，$\sin (\alpha-\beta)=-\sin (\beta-\alpha)$,所以体积变号。 （倍乘）乘k，就把k乘到任意一行或者列，同理如果某行或者列可以提出k倍也行。因为某向量乘k倍，体积变为k倍。这里要区别于矩阵的倍乘，矩阵是用来表达系统信息的数表，每个元素都要乘k倍。 （倍加）某行乘k倍加到另一行上，行列式结果不变，几何表述：因为这两个向量构成的平行四边形同底同高，面积不变，所以体积也不变。可拆性表述：拆成两个行列式，其中一个行列式为0，因为它某两行对应成比例。 单行可拆（加）性 $|A|=|A^T|$，行列等价，前六个性质同样适用于列。 重要观点 $D_n=|A|\neq0\Rightarrow S\neq0\Rightarrow 组成行列式的向量全独立$ $D_n=|A|=0\Rightarrow 组成行列式的向量至少有一个多余$行列式=0还是$\neq$0才是关键，而不是管它等于多少向量与向量之间要么独立要么多余 矩阵的本质 表面上，矩阵是表达系统信息的数表 本质上，矩阵也是由向量构成的，矩阵的核心是矩阵的秩，而秩的本质是组成矩阵的独立向量的个数；矩阵是一种运算，一种对应法则，把一个线性代数研究对象变换成另一个的手段；矩阵还是方程组的系数表，决定了初等变换的性质（可以行对调，可以行倍加倍减，可以行倍乘）。 秩的本质：r(A)=k，则矩阵中有k个独立的向量 台阶数=秩，因为台阶之间（向量之间）是独立的。 行阶梯形矩阵：1）若有0行，全在下方，2）从行上看，自左边起，出现连续0的个数，自上而下严格单增。若还满足3）台角位置元素为1，4）台角上方元素全为0，称为行最简阶梯形矩阵。 初等变换法：互换、倍乘、倍加 解释：互换不影响方程组的解，不影响向量的独立性，倍乘不影响方程组的解，不影响向量的独立性，倍加不影响方程组的解，不影响向量的独立性。矩阵进行初等变换不影响矩阵的秩，不影响矩阵的本质意义，所以初等变换是可以大量广泛使用的。任何可逆矩阵一定可以通过若干次初等变换化成同阶单位阵 矩阵的乘法AB=C 矩阵的乘法中，C中的每一个元素都是一个向量的内积，所以矩阵乘法可以看做向量内积的推广。另外矩阵的左乘代表行变换，矩阵的右乘代表列表换。矩阵的乘法也可以看做一种函数变换，因为矩阵乘法可以把一个线代对象，转换成另一个线代对象。 乘法单位元素：1·a=a,a·1=a，其中1称为乘法单位元素，矩阵的乘法单位元素是E（单位矩阵） 乘法反单位元素：$a\cdot\frac{1}{a}=1,\frac{1}{a}\cdot a=1$，其中$a$和$\frac{1}{a}$互称乘法反单位元素。矩阵$A$的乘法反单位元素是$A^{-1}$。二阶逆矩阵，主对角线对调，次对角线取相反数。]]></content>
      <categories>
        <category>数学</category>
        <category>线性代数</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[线性代数笔记--线性代数复习核心思想]]></title>
    <url>%2Fblog%2F2016%2F09%2F30%2F%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0--%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%A4%8D%E4%B9%A0%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%2F</url>
    <content type="text"><![CDATA[线性代数是一个整体，各个模块之间联系密不可分。 一、行列式、矩阵 二、向量组、方程组 三、特征值、二次型 命题重点在二和三。 难点在矩阵和向量组秩的等式和不等式的研究、分块矩阵 例题：设n阶矩阵A、B乘积可交换，$\xi_1,\xi_2,\cdots,\xi_{r_1}、\eta_1,\eta_2,\cdots,\eta_{r_2}$分别是AX=0,BX=0的一个基础解系，且对于n阶矩阵C、D，有r(CA+DB)=n,（I）证明$r\begin{pmatrix}A\B\end{pmatrix}=n$，且$\xi_1,\cdots,\xi_{r_1},\eta_1,\cdots,\eta_{r_2}$无关；（II）证明$\xi_1,\cdots,\xi_{r_2},\eta_1,\cdots,\eta_{r_2}$是ABX=0的一个基础解系。1.是解，2.无关，3.S=n-r，S是基础解系的个数，是自由变量的个数，也就是总变量-秩（有效方程个数，也即约束的个数）矩阵越乘秩越小（I）$n=r(CA+DB)=r\left((C D)\begin{pmatrix}A\B\end{pmatrix}\right)\leq r\begin{pmatrix}A\B\end{pmatrix}\leq n\Rightarrow r\begin{pmatrix}A\B\end{pmatrix}=n列满秩$ $\Rightarrow \begin{pmatrix}A\B\end{pmatrix}X=0只有零解\Rightarrow AX=0与BX=0没有非零公共解\Rightarrow \xi_i(i=1,2,\cdots,r_1)均不可由\eta_1,\eta_2,\cdots,\eta_{r_2}表出，因若不然，\xi_i=k_1\eta_1+k_2\eta_2+\cdots+k_{r_2}\eta_{r_2}，则有公共非零解，矛盾，同理可得，\eta_i(i=1,2,\cdots,r_1)均不可由\xi_1,\xi_2,\cdots,\xi_{r_2}表出，故\xi_1,\cdots,\xi_{r_1},\eta_1,\cdots,\eta_{r_2}$无关（II）显然，$B\eta_j=0,j=1,2,\cdots,r_2\Rightarrow AB\eta_j=0\Rightarrow\eta_j是ABX=0的解；又AB=BA，A\xi_i=0\Rightarrow BA\xi_i=AB\xi_i=0\Rightarrow\xi_i也是ABX=0的解$$r(AB)\geq r(A)+r(B)-n=n-r_1+n-r_2-n=n-(r_1+r_2)$$ABX=0的S=n-r(AB)\leq r_1+r_2，基础解系中至多r_1+r_2个向量，又根据第一问的证明，显然S\geq r_1+r_2，至少r_1+r_2个，恰有r_1+r_2个解向量$]]></content>
      <categories>
        <category>数学</category>
        <category>线性代数</category>
      </categories>
  </entry>
</search>
