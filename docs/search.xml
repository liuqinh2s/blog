<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Google Hacking</title>
      <link href="/blog/2018/11/21/Google-Hacking/"/>
      <url>/blog/2018/11/21/Google-Hacking/</url>
      <content type="html"><![CDATA[<h2 id="site"><a class="header-anchor" href="#site"> </a>site</h2><p>站内搜索</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:cnblogs.com</span><br></pre></td></tr></table></figure><h2 id="intitle"><a class="header-anchor" href="#intitle"> </a>intitle</h2><p>标题中包含某关键词</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">intitle:login</span><br></pre></td></tr></table></figure>]]></content>
      
      
    </entry>
    
    <entry>
      <title>操作系统大纲</title>
      <link href="/blog/2018/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%A7%E7%BA%B2/"/>
      <url>/blog/2018/11/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%A4%A7%E7%BA%B2/</url>
      <content type="html"><![CDATA[<h2 id="重点"><a class="header-anchor" href="#重点"> </a>重点</h2><ul><li>进程调度算法</li><li>段页式管理</li><li>作业调度算法</li><li>缓存调度算法</li></ul><h2 id="教材推荐"><a class="header-anchor" href="#教材推荐"> </a>教材推荐</h2><p><a href="http://pages.cs.wisc.edu/~remzi/OSTEP/" target="_blank" rel="noopener">OSTEP，Operating Systems: Three Easy Pieces</a></p>]]></content>
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《代码整洁之道》读书笔记--第6章:对象和数据结构</title>
      <link href="/blog/2018/11/19/2018-%E3%80%8A%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC6%E7%AB%A0-%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/blog/2018/11/19/2018-%E3%80%8A%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC6%E7%AB%A0-%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<h2 id="数据-对象的反对称性"><a class="header-anchor" href="#数据-对象的反对称性"> </a>数据、对象的反对称性</h2><p>对象把数据隐藏于抽象之后，暴露操作数据的方法。数据结构暴露其数据，没有提供有意义的函数。</p><p>过程式形状代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Point topLeft;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> side;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Point topLeft;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> height;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> width;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Point center;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">double</span> radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Geometry</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.14159</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">(Object shape)</span> <span class="keyword">throws</span> NoSuchShapeException</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(shape <span class="keyword">instanceof</span> Square)&#123;</span><br><span class="line">            Square s = (Square)shape;</span><br><span class="line">            <span class="keyword">return</span> s.side*s.side;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(shape <span class="keyword">instanceof</span> Rectangle)&#123;</span><br><span class="line">            Rectangle r = (Rectangle)shape;</span><br><span class="line">            <span class="keyword">return</span> r.height*r.width;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(shape <span class="keyword">instanceof</span> Circle)&#123;</span><br><span class="line">            Circle c = (Circle)shape;</span><br><span class="line">            <span class="keyword">return</span> c.radius*c.radius*PI;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchShapeException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过程式的代码的优点在于，如果给Geometry添加一个新的函数<code>perimeter</code>，那些形状类根本不会受任何影响，只需将函数加入到Geometry中即可。而如果新加一个类型，则要修改area函数。</p><p>多态式形状</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">implements</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Point topLeft;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> side;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> side*side;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Point topLeft;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> height;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> width;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> height*width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Point center;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> radius;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.14159</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">area</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> radius*radius*PI;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>面向对象代码便于添加新的类而不用改变已有的代码，但如果要新加一个<code>perimeter</code>方法，就要修改所有的类了。这一点上跟使用数据结构的过程式代码截然相反。</p>]]></content>
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 《代码整洁之道》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程范式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java注解</title>
      <link href="/blog/2018/11/16/Java%E6%B3%A8%E8%A7%A3/"/>
      <url>/blog/2018/11/16/Java%E6%B3%A8%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h2 id="注解语法"><a class="header-anchor" href="#注解语法"> </a>注解语法</h2><p>同class和interface一样，注解也可以用于类的定义，它是在Java SE 5.0版本中开始引入的概念。</p><h2 id="注解的定义"><a class="header-anchor" href="#注解的定义"> </a>注解的定义</h2><p>注解通过<code>@interface</code>关键字进行定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnotation&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比接口多了一个<code>@</code>。上面的代码就创建了一个名为<code>TestAnnotation</code>的注解。</p><h2 id="注解的使用"><a class="header-anchor" href="#注解的使用"> </a>注解的使用</h2><p>注解可以在类、方法、属性、参数上使用，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestAnnotation</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="元注解"><a class="header-anchor" href="#元注解"> </a>元注解</h2><p>元注解是可以注解到注解上的注解，或者说元注解是一种基本的注解。</p><p>元注解有：<code>@Retention</code>、<code>@Documented</code>、<code>@Target</code>、<code>@Inherited</code>、<code>@Repeatable</code>五种。</p><h3 id="retention"><a class="header-anchor" href="#retention"> </a>@Retention</h3><p>Retention的英文意为保留的意思。当<code>@Retention</code>应用到一个注解上的时候，它说明了这个注解的存活时间。</p><p>它的取值如下：</p><ul><li>RetentionPolicy.SOURCE：注解只在源码阶段保留，在编译器进行编译时它将被丢弃</li><li>RetentionPolicy.CLASS：注解只被保留到编译进行的时候，它并不会被加载到JVM中</li><li>RetentionPolicy.RUNTIME：注解可以保留到程序运行的时候，它会被加载进入到JVM中，所以在程序运行时可以获取到它们</li></ul><h3 id="documented"><a class="header-anchor" href="#documented"> </a>@Documented</h3><p>顾名思义，它的作用是能够将注解中的元素包含到JavaDoc中去。</p><h3 id="target"><a class="header-anchor" href="#target"> </a>@Target</h3><p>Target是目标的意思，<code>@Target</code>指定了注解运用的地方。</p><ul><li>ElementType.ANNOTATION_TYPE: 可以给一个注解进行注解</li><li>ElementType.CONSTRUCTOR: 可以给构造方法进行注解</li><li>ElementType.FIELD: 可以给属性进行注解</li><li>ElementType.LOCAL_VARIABLE: 可以给局部变量进行注解</li><li>ElementType.METHOD: 可以给方法进行注解</li><li>ElementType.PACKAGE: 可以给包进行注解</li><li>ElementType.PARAMETER: 可以给方法中的参数进行注解</li><li>ElementType.TYPE: 可以给类型进行注解，比如类、接口、枚举</li></ul><h3 id="inherited"><a class="header-anchor" href="#inherited"> </a>@Inherited</h3><p>顾名思义，如果一个超类被@Inherited注解过的注解进行注解的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了超类的注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@interface</span> Test &#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>注解 Test 被 @Inherited 修饰，之后类 A 被 Test 注解，类 B 继承 A,类 B 也拥有 Test 这个注解。</p><h3 id="repeatable"><a class="header-anchor" href="#repeatable"> </a>@Repeatable</h3><p>Repeatable是可重复的意思，<code>@Repeatable</code>是java 1.8才加进来的。</p><p>什么样的注解可以被应用多次呢？通常是注解的值可以同时取多个。</p><p>举个例子，一个人他既是程序员，又是产品经理，同时还是画家：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@interface</span> Persons &#123;</span><br><span class="line">    Person[]  value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Repeatable</span>(Persons.class)</span><br><span class="line"><span class="meta">@interface</span> Person&#123;</span><br><span class="line">    String role <span class="keyword">default</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Person</span>(role=<span class="string">"artist"</span>)</span><br><span class="line"><span class="meta">@Person</span>(role=<span class="string">"coder"</span>)</span><br><span class="line"><span class="meta">@Person</span>(role=<span class="string">"PM"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperMan</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注解的属性"><a class="header-anchor" href="#注解的属性"> </a>注解的属性</h2><p>注解中只有成员变量，没有方法。注解的成员变量在注解中以 <strong>无形参的方法</strong> 形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnotation &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">id</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">msg</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码定义了TestAnnotation这个注解中拥有id和msg两个属性。在使用的时候，我们给它们进行赋值。</p><p>赋值的方式是在注解的括号内以<code>value=&quot;&quot;</code>的形式，多个属性用<code>,</code>隔开。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestAnnotation</span>(id=<span class="number">3</span>, msg=<span class="string">"hello world"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解中属性可以有默认值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TestAnnotation &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">msg</span><span class="params">()</span> <span class="keyword">default</span> "Hi"</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>TestAnnotation 中 id 属性默认值为 -1，msg 属性默认值为 Hi。<br>它可以这样应用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@TestAnnotation</span>()</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>因为有默认值，所以无需要再在 @TestAnnotation 后面的括号里面进行赋值了，这一步可以省略。</p><p>另外，还有一种情况。如果一个注解内仅仅只有一个名字为 value 的属性时，应用这个注解时可以直接接属性值填写到括号内。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Check &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，Check 这个注解只有 value 这个属性。所以可以这样应用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Check</span>(<span class="string">"hi"</span>)</span><br><span class="line"><span class="keyword">int</span> a;</span><br></pre></td></tr></table></figure><p>这和下面的效果是一样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Check</span>(value=<span class="string">"hi"</span>)</span><br><span class="line"><span class="keyword">int</span> a;</span><br></pre></td></tr></table></figure><p>最后，还需要注意的一种情况是一个注解没有任何属性。比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Perform &#123;&#125;</span><br></pre></td></tr></table></figure><p>那么在应用这个注解的时候，括号都可以省略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Perform</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="java常见的预置注解"><a class="header-anchor" href="#java常见的预置注解"> </a>Java常见的预置注解</h2><ul><li>@Deprecated：标记过时的东西</li><li>@Override：提示子类要复写父类中被@Override修饰的方法</li><li>@SuppressWarnings：阻止警告的意思。阻止警告的意思。之前说过调用被 @Deprecated 注解的方法后，编译器会警告提醒，而有时候开发者会忽略这种警告，他们可以在调用的地方通过 @SuppressWarnings 达到目的。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Hero hero = <span class="keyword">new</span> Hero();</span><br><span class="line">    hero.say();</span><br><span class="line">    hero.speak();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java反射</title>
      <link href="/blog/2018/11/14/Java%E5%8F%8D%E5%B0%84/"/>
      <url>/blog/2018/11/14/Java%E5%8F%8D%E5%B0%84/</url>
      <content type="html"><![CDATA[<h2 id="应用场景"><a class="header-anchor" href="#应用场景"> </a>应用场景</h2><p>研究一个东西我通常喜欢从应用场景入手，从需求出发。</p><p>java反射如果直接看维基百科的定义，会有点让人困惑。</p><p>我们来看一个例子：</p><p>假设现在有4个类，分别为<code>Apple</code>、<code>Pear</code>、<code>StrawBerry</code>、<code>Orange</code>，它们的基类是<code>Fruit</code>，以及一个主类Main。主类中有一个<code>eat</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    Fruit fruit = <span class="keyword">null</span>;</span><br><span class="line">    <span class="meta">@org</span>.junit.Test</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"Apple"</span>.equals(name))&#123;</span><br><span class="line">            fruit = <span class="keyword">new</span> Apple();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"Pear"</span>.equals(name))&#123;</span><br><span class="line">            fruit = <span class="keyword">new</span> Pear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"StrawBerry"</span>.equals(name))&#123;</span><br><span class="line">            fruit = <span class="keyword">new</span> StrawBerry();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"Orange"</span>.equals(name))&#123;</span><br><span class="line">            fruit = <span class="keyword">new</span> Orange();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们使用反射，代码可以更加抽象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">    Class fruit = <span class="keyword">null</span>;</span><br><span class="line">    <span class="meta">@org</span>.junit.Test</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        fruit = Class.forName(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>唯一要注意的一点是，传给eat方法的参数必须是完整的类路径，例如：<code>eat(com.example.demo.Apple)</code></p></blockquote><h2 id="获取class"><a class="header-anchor" href="#获取class"> </a>获取Class</h2><ol><li>类名.class</li><li>对象.getClass()</li><li>Class.forName(“className”)</li></ol><h2 id="获取方法"><a class="header-anchor" href="#获取方法"> </a>获取方法</h2><ol><li><strong>getDeclaredMethods</strong>: 返回类或接口声明的所有方法（包括公共、私有、包（默认）、保护），但不包括继承来的方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Method[] getDeclaredMethods() <span class="keyword">throws</span> SecurityException</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>getMethods</strong>: 返回某个类的所有公共（public）的方法，包括继承来的方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Method[] getMethods() <span class="keyword">throws</span> SecurityException</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>getMethod</strong>: 返回一个特定的方法，其中第一个参数为方法名，后面的参数为方法参数对应的Class的对象。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Method <span class="title">getMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span></span></span><br></pre></td></tr></table></figure><ol start="4"><li><strong>getDeclaredMethod</strong>: 返回一个特定的方法，但不包括继承来的方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Method <span class="title">getDeclaredMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span></span></span><br></pre></td></tr></table></figure><p><code>DemoApplication.java</code>文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Class fruit = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">        DemoApplication d = <span class="keyword">new</span> DemoApplication();</span><br><span class="line">        d.eat(<span class="string">"com.example.demo.Apple"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fruit = Class.forName(name);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(fruit);</span><br><span class="line">        Method[] declaredMethods = fruit.getDeclaredMethods();</span><br><span class="line">        Method[] methods = fruit.getMethods();</span><br><span class="line">        Method method = <span class="keyword">null</span>;</span><br><span class="line">        Method declaredMethod = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            method = fruit.getMethod(<span class="string">"fruit"</span>, String.class);</span><br><span class="line"><span class="comment">//            declaredMethod = fruit.getDeclaredMethod("fruit", String.class);</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        for(Method m:declaredMethods)&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(m);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        for(Method m:methods)&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(m);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        System.out.println(method);</span><br><span class="line"><span class="comment">//        System.out.println(declaredMethod);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fruit</span><span class="params">(String str)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String str)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrawBerry</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pear</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是内部类的形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Class fruit = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">        DemoApplication d = <span class="keyword">new</span> DemoApplication();</span><br><span class="line">        d.eat(<span class="string">"com.example.demo.DemoApplication$Apple"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fruit = Class.forName(name);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(fruit);</span><br><span class="line">        Method[] declaredMethods = fruit.getDeclaredMethods();</span><br><span class="line">        Method[] methods = fruit.getMethods();</span><br><span class="line">        Method method = <span class="keyword">null</span>;</span><br><span class="line">        Method declaredMethod = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            method = fruit.getMethod(<span class="string">"fruit"</span>, String.class);</span><br><span class="line"><span class="comment">//            declaredMethod = fruit.getDeclaredMethod("fruit", String.class);</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        for(Method m:declaredMethods)&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(m);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        for(Method m:methods)&#123;</span></span><br><span class="line"><span class="comment">//            System.out.println(m);</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        System.out.println(method);</span><br><span class="line"><span class="comment">//        System.out.println(declaredMethod);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fruit</span><span class="params">(String str)</span></span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String str)</span></span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">StrawBerry</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Pear</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="java基础知识"><a class="header-anchor" href="#java基础知识"> </a>java基础知识</h3><p>我一般习惯了一个文件放一个类，现在来回顾一下如果一个文件放多个类会是怎样。</p><p>一个<code>.java</code>文件只能有一个<code>public</code>类，且public类名字要跟文件名一样。一个文件中如果有多个类，编译之后得到多个<code>.class</code>文件。</p><p>实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>   <span class="class"><span class="keyword">class</span>   <span class="title">A</span>   </span>&#123;&#125;   </span><br><span class="line"><span class="class"><span class="keyword">class</span>   <span class="title">B</span>   </span>&#123;&#125;   </span><br><span class="line"><span class="class"><span class="keyword">class</span>   <span class="title">C</span>   </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>编译得到：A.class、B.class、C.class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>   <span class="class"><span class="keyword">class</span>   <span class="title">A</span>   </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span>   <span class="title">B</span>   </span>&#123;&#125;   </span><br><span class="line">    <span class="class"><span class="keyword">class</span>   <span class="title">C</span>   </span>&#123;&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译得到：A.class、A$B.class、A$C.class</p><h2 id="获取构造函数"><a class="header-anchor" href="#获取构造函数"> </a>获取构造函数</h2><p>通过反射机制得到某个类的构造器，然后调用该构造器创建该类的一个实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回有指定参数的构造器(共有)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Constructor&lt;T&gt; <span class="title">getConstructor</span><span class="params">(Class&lt;?&gt;... parameterTypes)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//返回所有构造器(共有)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Constructor&lt;?&gt;[] <span class="title">getConstructors</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//返回有指定参数的构造器(共有和私有)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Constructor&lt;T&gt; <span class="title">getDeclaredConstructor</span><span class="params">(Class&lt;?&gt;...parameterTypes)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//返回所有构造器(共有和私有)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Constructor&lt;?&gt;[] <span class="title">getDeclaredConstructors</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h2 id="获取属性"><a class="header-anchor" href="#获取属性"> </a>获取属性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getField(String name)   <span class="comment">//获取class对象的公有name字段</span></span><br><span class="line">getFields()             <span class="comment">//获取class对象的所有共有字段</span></span><br><span class="line"></span><br><span class="line">getDeclaredField(name)  <span class="comment">//获取class对象name字段，无论是公有还是私有，但不能得到其父类的成员变量                                     </span></span><br><span class="line">getDeclaredFields()     <span class="comment">//获取class对象所有字段，无论是公有还是私有，但不能得到其父类的成员变量</span></span><br></pre></td></tr></table></figure><h2 id="调用方法"><a class="header-anchor" href="#调用方法"> </a>调用方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException </span>&#123;</span><br><span class="line">        Class&lt;?&gt; klass = methodClass.class;</span><br><span class="line">        <span class="comment">//创建methodClass的实例</span></span><br><span class="line">        Object obj = klass.newInstance();</span><br><span class="line">        <span class="comment">//获取methodClass类的add方法</span></span><br><span class="line">        Method method = klass.getMethod(<span class="string">"add"</span>,<span class="keyword">int</span>.class,<span class="keyword">int</span>.class);</span><br><span class="line">        <span class="comment">//调用method对应的方法 =&gt; add(1,4)</span></span><br><span class="line">        Object result = method.invoke(obj,<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">methodClass</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> fuck = <span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a+b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="利用反射创建数组"><a class="header-anchor" href="#利用反射创建数组"> </a>利用反射创建数组</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testArray</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    Class&lt;?&gt; cls = Class.forName(<span class="string">"java.lang.String"</span>);</span><br><span class="line">    Object array = Array.newInstance(cls,<span class="number">25</span>);</span><br><span class="line">    <span class="comment">//往数组里添加内容</span></span><br><span class="line">    Array.set(array,<span class="number">0</span>,<span class="string">"hello"</span>);</span><br><span class="line">    Array.set(array,<span class="number">1</span>,<span class="string">"Java"</span>);</span><br><span class="line">    Array.set(array,<span class="number">2</span>,<span class="string">"fuck"</span>);</span><br><span class="line">    Array.set(array,<span class="number">3</span>,<span class="string">"Scala"</span>);</span><br><span class="line">    Array.set(array,<span class="number">4</span>,<span class="string">"Clojure"</span>);</span><br><span class="line">    <span class="comment">//获取某一项的内容</span></span><br><span class="line">    System.out.println(Array.get(array,<span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的Array类为java.lang.reflect.Array类</p><h2 id="注意事项"><a class="header-anchor" href="#注意事项"> </a>注意事项</h2><p>反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>YAML语法</title>
      <link href="/blog/2018/11/12/YAML%E8%AF%AD%E6%B3%95/"/>
      <url>/blog/2018/11/12/YAML%E8%AF%AD%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>在学Spring Boot的时候，application.yml使用的就是YAML语法，顺便过来学习一下，有过JSON、XML的基础，应该可以学的很快。</p><p><a href="https://zh.wikipedia.org/wiki/YAML" target="_blank" rel="noopener">YAML</a>是专门用来写配置文件的语言，强调以数据为中心，写起来非常简洁方便。</p><h2 id="基本语法"><a class="header-anchor" href="#基本语法"> </a>基本语法</h2><ul><li>大小写敏感</li><li>冒号、连字符后面一定要加一个空格，再写数据</li><li>使用缩进表示层级关系</li><li>缩进时不允许使用Tab键，只允许使用空格</li><li>缩进的空格数目不重要，只要相同层级的元素左对齐即可</li><li><code>#</code>注释一行</li></ul><p>YAML支持的数据结构有三种：</p><ul><li><strong>对象</strong>：键值对的集合，又称为映射（mapping）/ 哈希（hashes）/ 字典（dictionary）</li><li><strong>数组</strong>：一组按次排列的值，又称为序列（sequence）/ 列表（list）</li><li><strong>纯量(scalars)</strong>：单个的、不可再分的值</li></ul><p>下面分别介绍这三种数据结构的表示方法：</p><h2 id="对象"><a class="header-anchor" href="#对象"> </a>对象</h2><p>对象的一组键值对，使用冒号结构表示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">title: hello world</span><br></pre></td></tr></table></figure><p>行内表示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">maps: &#123;title: hello world, date: 2017/11/11&#125;</span><br></pre></td></tr></table></figure><h2 id="数组"><a class="header-anchor" href="#数组"> </a>数组</h2><p>一组连词线开头的行，构成一个数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- Cat</span><br><span class="line">- Dog</span><br><span class="line">- Pig</span><br></pre></td></tr></table></figure><p>行内表示法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">animals: [Cat, Dog, Pig]</span><br></pre></td></tr></table></figure><p>数据结构的子成员是一个数组，则可以在该项下面缩进一个空格</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-</span><br><span class="line"> - Cat</span><br><span class="line"> - Dog</span><br><span class="line"> - Pig</span><br></pre></td></tr></table></figure><h2 id="纯量"><a class="header-anchor" href="#纯量"> </a>纯量</h2><p>纯量是最基本的，不可再分割的值。</p><ul><li>字符串</li><li>布尔值</li><li>整数</li><li>浮点数</li><li>Null</li><li>时间</li><li>日期</li></ul><h3 id="数值"><a class="header-anchor" href="#数值"> </a>数值</h3><p>数值直接以<a href="https://baike.baidu.com/item/%E5%AD%97%E9%9D%A2%E9%87%8F" target="_blank" rel="noopener">字面量</a>的形式表示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">number: 12.30</span><br></pre></td></tr></table></figure><h3 id="布尔值"><a class="header-anchor" href="#布尔值"> </a>布尔值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isSet: true</span><br></pre></td></tr></table></figure><h3 id="null"><a class="header-anchor" href="#null"> </a>Null</h3><p><code>Null</code>用<code>~</code>表示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parent: ~</span><br></pre></td></tr></table></figure><h3 id="日期"><a class="header-anchor" href="#日期"> </a>日期</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date: 2017-11-11</span><br></pre></td></tr></table></figure><h3 id="字符串"><a class="header-anchor" href="#字符串"> </a>字符串</h3><p>字符串默认不使用引号表示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str: 这是一行字符串</span><br></pre></td></tr></table></figure><p>如果字符串之中包含空格或特殊字符，需要放在引号之中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str: &apos;内容: 字符串&apos;</span><br></pre></td></tr></table></figure><p>单引号和双引号都可以使用，双引号中转义是有效的，单引号中转义是无效的。</p><p>单引号之中如果还有单引号，必须连续使用两个单引号转义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str: &apos;labor&apos;&apos;s day&apos;</span><br></pre></td></tr></table></figure><p>字符串可以写成多行，从第二行开始，必须有一个单空格缩进。换行符会被转为空格。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str: 这是一段</span><br><span class="line">  多行</span><br><span class="line">  字符串</span><br></pre></td></tr></table></figure><p>多行字符串可以使用<code>|</code>保留换行符，也可以使用<code>&gt;</code>折叠换行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">this: |</span><br><span class="line">  Foo</span><br><span class="line">  Bar</span><br><span class="line">that: &gt;</span><br><span class="line">  Foo</span><br><span class="line">  Bar</span><br></pre></td></tr></table></figure><p>转为 JSON 代码如下。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; this: 'Foo\nBar\n', that: 'Foo Bar\n' &#125;</span><br></pre></td></tr></table></figure><p><code>+</code>表示保留文字块末尾的换行，<code>-</code>表示删除字符串末尾的换行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s1: |</span><br><span class="line">  Foo</span><br><span class="line"></span><br><span class="line">s2: |+</span><br><span class="line">  Foo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s3: |-</span><br><span class="line">  Foo</span><br></pre></td></tr></table></figure><p>转为 JSON 代码如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; s1: &apos;Foo\n&apos;, s2: &apos;Foo\n\n\n&apos;, s3: &apos;Foo&apos; &#125;</span><br></pre></td></tr></table></figure><p>字符串之中可以插入 HTML 标记。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">message: |</span><br><span class="line"></span><br><span class="line">  &lt;p style=&quot;color: red&quot;&gt;</span><br><span class="line">    段落</span><br><span class="line">  &lt;/p&gt;</span><br></pre></td></tr></table></figure><p>转为 JSON 如下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; message: &apos;\n&lt;p style=&quot;color: red&quot;&gt;\n  段落\n&lt;/p&gt;\n&apos; &#125;</span><br></pre></td></tr></table></figure><h2 id="引用"><a class="header-anchor" href="#引用"> </a>引用</h2><p>锚点<code>&amp;</code>和别名<code>*</code>，可以用来引用。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">default:</span> <span class="meta">&amp;defaults</span></span><br><span class="line"><span class="attr">  adapter:</span> <span class="string">postgress</span></span><br><span class="line"><span class="attr">  host:</span> <span class="string">localhost</span></span><br><span class="line"></span><br><span class="line"><span class="attr">development:</span> </span><br><span class="line"><span class="attr">  database:</span> <span class="string">myapp_development</span></span><br><span class="line">  <span class="string">&lt;&lt;:</span> <span class="meta">*defaults</span></span><br><span class="line"></span><br><span class="line"><span class="attr">test:</span></span><br><span class="line"><span class="attr">  database:</span> <span class="string">myapp_test</span></span><br><span class="line">  <span class="string">&lt;&lt;:</span> <span class="meta">*defaults</span></span><br></pre></td></tr></table></figure><p>等同于下面的代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">defaults:</span><br><span class="line">  adapter:  postgres</span><br><span class="line">  host:     localhost</span><br><span class="line"></span><br><span class="line">development:</span><br><span class="line">  database: myapp_development</span><br><span class="line">  adapter:  postgres</span><br><span class="line">  host:     localhost</span><br><span class="line"></span><br><span class="line">test:</span><br><span class="line">  database: myapp_test</span><br><span class="line">  adapter:  postgres</span><br><span class="line">  host:     localhost</span><br></pre></td></tr></table></figure><p><code>&amp;</code>用来建立锚点(defaults)，<code>&lt;&lt;</code>表示合并到当前数据，<code>*</code>表示引用锚点</p><p>下面是另一个例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- &amp;showshell Steve</span><br><span class="line">- Clark</span><br><span class="line">- Brian</span><br><span class="line">- Oren</span><br><span class="line">- *showshell</span><br></pre></td></tr></table></figure><p>转为 JSON 代码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ &apos;Steve&apos;, &apos;Clark&apos;, &apos;Brian&apos;, &apos;Oren&apos;, &apos;Steve&apos; ]</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 配置语言 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>spring boot 配置文件</title>
      <link href="/blog/2018/11/09/spring%20boot%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
      <url>/blog/2018/11/09/spring%20boot%20%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
      <content type="html"><![CDATA[<p>spring boot使用一个全局配置文件：</p><ul><li>application.properties</li><li>application.yml</li></ul><p>两者选其一，如果两个都存在，application.properties会覆盖application.yml</p><p>配置文件的作用：修改spring boot的默认配置（spring boot在底层都给我们自动配置好了）</p><p><a href="http://www.ruanyifeng.com/blog/2016/07/yaml.html" target="_blank" rel="noopener">YAML语法</a></p><h2 id="配置文件值注入bean类"><a class="header-anchor" href="#配置文件值注入bean类"> </a>配置文件值注入Bean类</h2><p>使用<code>@Component</code>和<code>@ConfigurationProperties</code></p><p>解决配置文件乱码：</p><p><img src="../../../../images/2018/%E8%A7%A3%E5%86%B3%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E4%B9%B1%E7%A0%81.png" alt="解决配置文件乱码"></p><h3 id="value和-configurationproperties获取值比较"><a class="header-anchor" href="#value和-configurationproperties获取值比较"> </a>@Value和@ConfigurationProperties获取值比较</h3><table><thead><tr><th>区别点</th><th>@ConfigurationProperties</th><th>@Value</th></tr></thead><tbody><tr><td>功能</td><td>批量注入配置文件中的属性</td><td>一个个指定</td></tr><tr><td>松散绑定（松散语法）</td><td>支持</td><td>不支持</td></tr><tr><td>SpEL</td><td>不支持</td><td>支持</td></tr><tr><td>JSR303数据校验</td><td>支持</td><td>不支持</td></tr><tr><td>复杂类型封装</td><td>支持</td><td>不支持</td></tr></tbody></table><h2 id="配置文件占位符"><a class="header-anchor" href="#配置文件占位符"> </a>配置文件占位符</h2><h2 id="profile"><a class="header-anchor" href="#profile"> </a>Profile</h2><h3 id="多profile文件"><a class="header-anchor" href="#多profile文件"> </a>多profile文件</h3><p>我们在主配置文件编写的时候，文件名可以是<code>application-{profile}.properties/yml</code>，默认使用application.properties。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">application-dev.properties</span><br><span class="line">application-prod.properties</span><br></pre></td></tr></table></figure><h3 id="激活指定profile"><a class="header-anchor" href="#激活指定profile"> </a>激活指定profile</h3><ol><li>在默认配置文件中使用：<code>spring.profiles.active=dev</code></li><li>用命令行的方式：<code>--spring.profiles.active=dev</code></li><li>虚拟机参数：<code>-Dspring.profiles.active=dev</code></li></ol><h3 id="yml多文档块"><a class="header-anchor" href="#yml多文档块"> </a>yml多文档块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: prod</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server:</span><br><span class="line">  port: 8083</span><br><span class="line">spring:</span><br><span class="line">  profiles: dev</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">server:</span><br><span class="line">  port: 8084</span><br><span class="line">spring:</span><br><span class="line">  profiles: prod</span><br></pre></td></tr></table></figure><h2 id="配置文件加载路径"><a class="header-anchor" href="#配置文件加载路径"> </a>配置文件加载路径</h2><p>spring boot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件:</p><ul><li>file: ./config/</li><li>file: ./</li><li>classpath: /config/</li><li>classpath: /</li></ul><p>以上是按照优先级从高到低的顺序，所有位置的文件都会被加载（形成互补配置），高优先级配置内容会覆盖低优先级配置内容。我们也可以通过配置<code>spring.config.location</code>来改变默认配置</p><p><img src="https://i.loli.net/2018/11/13/5bea31348cf12.jpeg" alt="springboot配置文件加载位置.jpeg"></p><p><a href="https://docs.spring.io/spring-boot/docs/2.1.0.RELEASE/reference/htmlsingle/#boot-features-external-config" target="_blank" rel="noopener">官方文档中列举了17个加载配置文件的方法</a></p><h2 id="自动配置原理"><a class="header-anchor" href="#自动配置原理"> </a>自动配置原理</h2><p>google搜索<code>spring boot ref doc</code>，找到官方文档，ctrl+f搜索<code>appendices</code>，点击<code>A. Common application properties</code>，可以看到spring boot 有哪些可以配置的项。</p><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#common-application-properties" target="_blank" rel="noopener">Appendix A. Common application properties</a></p><ol><li>spring boot 启动的时候加载主配置类，开启了自动配置功能<code>@EnableAutoConfigure</code></li><li><code>@EnableAutoConfigure</code>的作用：<ul><li>利用<code>AutoConfigurationImportSelector</code>导入组件</li><li>可以查看<code>selectImports</code>方法，进入<code>getAutoConfigurationEntry</code>，进入<code>getCandidateConfigurations</code>，进入<code>loadFactoryNames</code>，它的第一个参数<code>getSpringFactoriesLoaderFactoryClass()</code>，可以看到返回了一个<code>EnableAutoConfiguration.class</code>，这个类就是关键。</li><li>扫描所有包下面的 <code>META-INF/spring.factories</code>，把扫描到的内容包装成properties对象。</li><li>从properties对象中获取<code>EnableAutoConfiguration.class</code>这个类名对应的值</li></ul></li></ol><p>.m2/repository/org/springframework/boot/spring-boot-autoconfigure/2.1.0.RELEASE/spring-boot-autoconfigure-2.1.0.RELEASE.jar!/META-INF/spring.factories中有对这个类名的描述：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cloud.CloudServiceConnectorsAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoReactiveDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoReactiveRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.elasticsearch.rest.RestClientAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.influx.InfluxDbAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mongo.MongoReactiveAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.quartz.QuartzAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.reactor.core.ReactorCoreAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.servlet.SecurityRequestMatcherProviderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.reactive.ReactiveSecurityAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.reactive.ReactiveUserDetailsServiceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.oauth2.client.reactive.ReactiveOAuth2ClientAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.oauth2.resource.reactive.ReactiveOAuth2ResourceServerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.task.TaskSchedulingAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.function.client.ClientHttpConnectorAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.reactive.WebSocketReactiveAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.servlet.WebSocketMessagingAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.webservices.client.WebServiceTemplateAutoConfiguration</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Java </category>
          
          <category> Java web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>spring boot 入门笔记</title>
      <link href="/blog/2018/11/08/spring%20boot%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/blog/2018/11/08/spring%20boot%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/av20965295/?p=6" target="_blank" rel="noopener">B站上学Spring Boot</a></p><h2 id="写一个hello-world程序"><a class="header-anchor" href="#写一个hello-world程序"> </a>写一个Hello World程序</h2><ol><li>创建Maven项目</li><li>导入spring boot相关的依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="3"><li>编写一个主程序，用来启动spring boot应用</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@SpringBootApplication</span> 来标注一个主程序，这是一个Spring Boot应用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldMainApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Spring 应用启动起来</span></span><br><span class="line">        SpringApplication.run(HelloWorldMainApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>编写相关的Controller，Service</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(&#123;<span class="string">"/hello"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(&#123;<span class="string">"/hello"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>运行主程序测试</li><li>简化部署</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--这个插件可以将应用打包成一个可执行的jar包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>将这个应用打成jar包，直接使用<code>java -jar xxx.jar</code>运行。使用<code>jar xf xxx.jar</code>可以查看其中的内容。“x”是“提取”的缩写。“f”是“文件”的缩写。放在一起，“xf”代表你想要在命令行里提取特定的文件。</p><h2 id="hello-world-研究"><a class="header-anchor" href="#hello-world-研究"> </a>Hello World 研究</h2><h3 id="pom文件"><a class="header-anchor" href="#pom文件"> </a>POM文件</h3><ol><li>父项目</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">按住command点spring-boot-starter-parent，点进去发现spring-boot-starter-parent它的父项目是：</span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../../spring-boot-dependencies<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">在spring-boot-dependencies中定义了大量依赖的版本号，它来真正管理Spring Boot应用中的所有依赖版本：</span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">activemq.version</span>&gt;</span>5.15.6<span class="tag">&lt;/<span class="name">activemq.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">antlr2.version</span>&gt;</span>2.7.7<span class="tag">&lt;/<span class="name">antlr2.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appengine-sdk.version</span>&gt;</span>1.9.64<span class="tag">&lt;/<span class="name">appengine-sdk.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artemis.version</span>&gt;</span>2.4.0<span class="tag">&lt;/<span class="name">artemis.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aspectj.version</span>&gt;</span>1.8.13<span class="tag">&lt;/<span class="name">aspectj.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">assertj.version</span>&gt;</span>3.9.1<span class="tag">&lt;/<span class="name">assertj.version</span>&gt;</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>所以有了这个Spring Boot的版本仲裁中心，以后我们导入依赖默认是不需要写版本号的（没有在spring-boot-dependencies中管理的，自然需要我们自己声明版本号）。</p><ol start="2"><li>导入的依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>点击进spring-boot-starter-web，把鼠标放到打开的标签页上，可以看到这个pom文件的路径，可以看到是在<code>.m2/repository/</code>下的，路径由：<code>groupId</code>、<code>artifactId</code>、<code>version</code>三者组成（这里省略了version，使用spring-boot-dependencies中定义的默认版本号）。</p><p>查看spring-boot-starter-web的依赖，可以看到：<strong>spring-boot-starter</strong>: spring-boot场景启动器，帮我们导入了web模块正常运行所依赖的组件。</p><p><a href="https://docs.spring.io/spring-boot/docs/2.1.0.RELEASE/reference/htmlsingle/#using-boot-starter" target="_blank" rel="noopener">Starters</a></p><p>Spring Boot 将所有的功能场景都抽取出来了，做成一个个的starters（启动器），只需要在项目里面引入这些starter，相关场景的所有依赖都会导入进来。要用什么功能，就导入什么场景的启动器。</p><h3 id="主程序类-主入口类"><a class="header-anchor" href="#主程序类-主入口类"> </a>主程序类，主入口类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@SpringBootApplication</span> 来标注一个主程序，这是一个Spring Boot应用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldMainApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Spring 应用启动起来</span></span><br><span class="line">        SpringApplication.run(HelloWorldMainApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>@SpringBootApplication</strong>：标注在某个类上，说明这个类是Spring Boot的主配置类。Spring Boot就应该运行这个类的main方法来启动SpringBoot应用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@SpringBootConfiguration</span></span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(</span><br><span class="line">    excludeFilters = &#123;<span class="meta">@Filter</span>(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;TypeExcludeFilter.class&#125;</span><br><span class="line">), <span class="meta">@Filter</span>(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span><br><span class="line">)&#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123;</span><br></pre></td></tr></table></figure><p><strong>@SpringBootConfiguration</strong>: Spring Boot的配置类。然后再点进去查看它，看到 <strong>@Configuration</strong>：spring标注在配置类上。配置类 - - 配置文件。配置类也是容器中的一个组件（@Component）。</p><p><strong>@EnableAutoConfiguration</strong>：开启自动配置。以前我们需要在spring中配置的东西，现在spring boot帮我们配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(&#123;AutoConfigurationImportSelector.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br></pre></td></tr></table></figure><ul><li><strong>@AutoConfigurationPackage</strong>: 自动配置包。<ul><li><strong>@Import({Registrar.class})</strong>：spring的底层注解@Import，给容器导入一个组件。<code>Registrar</code>将主配置类所在的包及下面的子包里面的所有组件都扫描到spring容器中。</li></ul></li><li><strong>@Import({AutoConfigurationImportSelector.class})</strong>：<code>AutoConfigurationImportSelector</code>导入哪些组件的选择器。<code>selectImports</code>将所有需要导入的组件以全类名的方式返回。这些组件就会被添加到容器中。会给容器中导入非常多的自动配置类（xxxAutoConfiguration）</li></ul><p><img src="../../../../images/2018/%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E7%B1%BB.png" alt="自动配置类"></p><p>有了自动配置类，免去了我们手动编写配置注入功能组件等的工作</p><p>spring boot在启动的时候从类路径下的<code>META-INF/spring.factories</code>中获取EnableAutoConfiguration指定的这些值。</p><p>J2EE的整体整合解决方案和自动配置都在<code>spring-boot-autoconfigure-2.0.5.RELEASE.jar</code>中。</p><h2 id="使用spring-initializer快速创建spring-boot项目"><a class="header-anchor" href="#使用spring-initializer快速创建spring-boot项目"> </a>使用Spring Initializer快速创建Spring Boot项目</h2><p>IDE都支持使用spring的项目创建向导快速创建一个Spring Boot项目。</p><p>选择我们需要的模块，向导会联网创建Spring Boot项目。</p><p>默认生成的Spring Boot项目，主程序已经生成好了，我们只需要编写我们自己的逻辑。</p><p>resource文件夹中目录结构：</p><ul><li>static目录: 保存静态资源：js css images</li><li>templates目录: 保存所有的模板页面，Spring Boot默认jar包使用嵌入式的tomcat，不支持jsp；可以使用模板引擎（freemarker, thymeleaf）</li><li>application.properties文件: Spring Boot 的应用配置文件，可以修改一些默认配置。</li></ul>]]></content>
      
      <categories>
          
          <category> Java </category>
          
          <category> Java web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>编程珠玑系列笔记 -- 第二章 啊哈！算法</title>
      <link href="/blog/2018/11/06/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B02/"/>
      <url>/blog/2018/11/06/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B02/</url>
      <content type="html"><![CDATA[<p>本书的另一个中心思想显而易见：<strong>良好的算法是程序性能提升的关键。</strong></p><p>下面还是通过探讨几个实例，来领会一下算法的重要性。</p><h2 id="三个问题"><a class="header-anchor" href="#三个问题"> </a>三个问题</h2><p>A. 给定一个最多包含40亿个随机排列的32位整数的顺序文件，找出一个不在文件中的32位整数(在文件中至少缺失一个这样的数 - - 为什么? )。在具有足够内存的情况下，如何解决该问题?如果有几个外部的“临时”文件可用，但是仅有几百字节的内存，又该如何解决该问题?</p><p>至少缺失一个这样的数是因为：32位无符号整数的表示范围是<code>0 到 4,294,967,295</code>，比40亿大：。如果有足够的内存，可以采用第一章的位图表示法，需要的内存是：<code>4 000 000 000/8 = 500 000 000</code>，500MB的内存。而且我们需要使用二分查找来加速查找过程，顺序遍历500MB的空间是很慢的。使用二分查找对这种量大的数据集是非常重要的手段，但 <strong>二分查找的基础是数据集有序</strong>。所以初看这里是没法直接使用二分法的，但是如果我们这样想：32位整数的每一位不是0就是1，我们按照第1位划分的话，就可以划分出两个集合（需要遍历全部数据一遍），如果某个集合小于 $2^{31}$ 个数就选中成为我们下一次划分的对象（如果两个集合都小于 $2^{31}$ 就随便选一个），直到我们得到一个空集，而这个空集中本来应该存在的那些数，就是缺失的数了。在划分集合的时候，我们实际上要把数据存到硬盘中，可以使用buffer来减少IO次数。最坏时间复杂度是一个等比数列：<br>$$n+\frac{1}{2}n+\cdots+1 = 2n$$</p><p>可见这里的二分法并没有起到<code>logN</code>的效果。需要遍历的二分法还算什么二分法呢？但庆幸的是，我们至少可以解决这一题。</p><p>B. 将一个n元一维向量左旋转i个位置。例如，当n=8且i=3时，向量abcdefgh旋转为defghabc。简单的代码使用一个n元的中间向量在n步内完成该工作。你能否仅使用数十个额外字节的存储空间，在正比于n的时间内完成向量的旋转？</p><p>方法1：将前i个元素复制到一个临时空间，余下的n-i个元素向左移i个位置，最后将最初的i个元素从临时空间复制到x中余下的位置。时间复杂度：2i+(n-i)=n+i，也就是O(n)；空间复杂度：i，也就是O(n)。</p><p>方法2：使用类似方法1的办法，但只使用一个元素大小的临时空间，每次只移动一位，总共需要移动i次。时间复杂度：(n+1)*i，也就是O(n^2)；空间复杂度：O(1)。</p><p>方法3：杂技算法。第一步：移动<code>x[0]</code>到临时变量t，然后移动<code>x[i]</code>到<code>x[0]</code>，<code>x[2i]</code>到<code>x[i]</code>，依此类推（将x中的所有下标对n取模），直至返回到取<code>x[0]</code>中的元素，此时改为从t取值然后终止过程。第二步：如果该过程没有移动全部元素，就从<code>x[1]</code>开始再次进行移动（执行第一步的算法操作），直到所有的元素都已经移动为止。</p><p>这个算法的核心思想应该是这样的：<strong>将该数组序列看成是一个环状队列，每次执行第一步的算法都可以使一组元素落到它们最终的位置上，而又不影响到其它元素。</strong></p><p>第二步执行的次数是<a href="https://zh.wikipedia.org/zh-hans/%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B8" target="_blank" rel="noopener"><code>GCD(n,i)</code></a>（n和i的最大公约数）。这样一来我们就不用记录元素是否移动过这个状态了，直接就可以知道循环多少次。</p><p>该算法的时间复杂度：n+GCD(n,i)，也就是O(n)。空间复杂度：O(1)。</p><p>这个算法虽然表现不错，但是不便于理解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a%b?gcd(b, a%b): b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">20</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acrobat</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">20</span>, i=<span class="number">6</span>;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;gcd(n,i);j++)&#123;</span><br><span class="line">        temp = a[j];</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i*(count+<span class="number">1</span>)%n == <span class="number">0</span>)&#123;</span><br><span class="line">                a[j+i*count%n] = temp;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                a[j+i*count%n] = a[j+i*(count+<span class="number">1</span>)%n];</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">        a[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    acrobat();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"out"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法4：递归算法。旋转向量x其实就是交换向量ab的两段，得到向量ba。这里a代表x中的前i个元素。假设a比b短，将b分为$b_l$和$b_r$，使得$b_r$具有与a相同的长度。交换a和$b_r$，也就将$ab_l b_r$转换为$b_r b_l a$。序列a此时已处于其最终的位置，因此现在的问题就集中到交换b的部分。由于新的问题与原来的问题具有相同的形式，我们可以递归解决。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分别从i和j位置开始，交换k个元素</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">0</span>;p&lt;k;p++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[i+p];</span><br><span class="line">        a[i+p] = a[j+p];</span><br><span class="line">        a[j+p] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从i位置开始，处理左leni，右lenj的旋转</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">first</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> i, <span class="keyword">int</span> leni, <span class="keyword">int</span> lenj)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(leni == lenj)&#123;</span><br><span class="line">        swap(a, i, i+leni, leni);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(leni&lt;lenj)&#123;</span><br><span class="line">        swap(a, i, i+lenj, leni);</span><br><span class="line">        first(a, i, leni, lenj-leni);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        swap(a, i, i+leni, lenj);</span><br><span class="line">        first(a, i+lenj, leni-lenj, lenj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法5：三次翻转: $(a^r b<sup>r)</sup>r = ba$。从ab开始，首先对a求逆，得到$a^r b$，然后对b求逆，得到$a^r b<sup>r$。最后对整体求逆，得到$(a</sup>r b<sup>r)</sup>r$，此时恰好就是ab。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">reverse(0, i-1) /* cbadefgh */</span><br><span class="line">reverse(i, n-1) /* cbahgfed */</span><br><span class="line">reverse(0, n-1) /* defghabc */</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从i位置开始，到j位置结束(包含j)，翻转这一段的a中的元素</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;(j+<span class="number">1</span>-i)/<span class="number">2</span>;k++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a[k+i];</span><br><span class="line">        a[k+i] = a[j-k];</span><br><span class="line">        a[j-k] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//i位置是b段的开始，总长度n</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">res</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> i, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    reverse(a, <span class="number">0</span>, i<span class="number">-1</span>);</span><br><span class="line">    reverse(a, i, n<span class="number">-1</span>);</span><br><span class="line">    reverse(a, <span class="number">0</span>, n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C. 给定一个英语字典，找出其中的所有变位词集合。例如，“pots”、“stop”、“tops”互为变位词，因此每一个单词都可以通过改变其他单词中字母的顺序来得到。</p>]]></content>
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 《编程珠玑》 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>编程珠玑系列笔记 -- 第一章 开篇</title>
      <link href="/blog/2018/11/05/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B01/"/>
      <url>/blog/2018/11/05/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B01/</url>
      <content type="html"><![CDATA[<p>本书的中心思想：<strong>对实例研究的深入思考不仅有趣，而且可以获得实际的益处。</strong></p><p>规律和智慧都隐藏在实例之中，而我们通过实例来窥探它们。实例是道的载体。</p><h2 id="开篇"><a class="header-anchor" href="#开篇"> </a>开篇</h2><p>明确问题，一旦问题明确，这场战役就成功了90%。</p><p>确定用户的真实需求是程序设计的根本。</p><p>简单的程序通常比具有相同功能的复杂程序更可靠、更安全、更健壮、更高效，而且易于实现和维护。因为简单的程序往往更具有概括性、更抽象、更能洞悉问题的本质。</p><h3 id="具体问题具体分析"><a class="header-anchor" href="#具体问题具体分析"> </a>具体问题具体分析</h3><p>A：怎样给一个磁盘文件排序？<br>B：为什么非要自己写排序程序呢？为什么不用系统提供的排序程序呢？<br>A：我需要在一个大系统中排序。由于不明的技术原因，我不能使用系统中的文件排序程序。<br>B：需要排序的内容是什么？文件中有多少条记录？每条记录的格式是什么？<br>A：文件最多包含1千万条记录，每条记录都是7位的整数。<br>B：等一下，既然文件这么小，何必非要在非要在磁盘上进行排序呢？为什么不在内存里进行排序呢？<br>A：尽管机器有许多兆字节的内存，但排序功能只是大系统中的一部分，所以估计到时候只有1MB的内存可用。<br>B：你还能告诉我其他一些与记录相关的信息吗？<br>A：每条记录都是7位的正整数，再无其他相关数据。每个整数最多出现一次。</p><p>实际上问了这么多，提问者都没有主动将自己的问题无保留的告诉被求助对象，反而是被求助对象耐心的一点一点询问。问题的真实背景是这样的：</p><p>在美国，电话号码由3位区号后再跟7位数字组成，拨打含免费区号800（当时只有这一个号码）的电话是不收费的。这位程序员正在开发这类数据库处理系统的一小部分，需要排序的整数就是免费电话号码。输入文件是电话号码列表，号码重复出现算出错。期望的输出文件是以升序排列的电话号码列表。应用背景同时定义了相应的性能需求。当与系统的会话时间较长时，用户大约每小时请求一次有序文件，并且在排序未完成之前什么都做不了。因此，排序最多只允许执行几分钟，10秒钟是比较理想的运行时间。</p><h3 id="准确的问题描述"><a class="header-anchor" href="#准确的问题描述"> </a>准确的问题描述</h3><p><strong>输入：</strong> 一个最多包含n个正整数的文件，每个数都小于n，其中n=$10^7$。如果在输入文件中有任何整数重复出现就是致命错误。没有其他数据与该整数相关联。</p><p><strong>输出：</strong> 按升序排列的输入整数的列表。</p><p><strong>约束：</strong> 最多有（大约）1MB的内存可用，有充足的磁盘存储空间。运行时间最多几分钟，运行时间为10秒钟就不需要再优化了。</p><h3 id="程序设计"><a class="header-anchor" href="#程序设计"> </a>程序设计</h3><p>传统的排序有归并排序、快速排序，一般人想到的都是使用一个4字节的int型来表示数据，但1000万的数据就需要40MB的内存，所以需要至少40趟排序，需要读取输入文件至少40次，这将会是非常大的开销。</p><p>很显然，我们真正要做的应该是压缩数据表示，如果能让所有数据一次读入内存（仅1MB）就好了。考虑到这一题的特殊性，我们使用长度为1000万位的位图来表示所有数据，每个整数都只占1bit，可以说是极限的数据表示法了。这样一来我们只需要125万个字节，也就是1.25MB内存。满足了一次读入内存的要求。</p><p>这种数据表示，利用了该问题的三个在排序问题中不常见的属性：</p><ol><li>输入数据限制在相对较小的范围内</li><li>数据没有重复</li><li>对每条记录而言，除了单一整数外，没有任何其他关联数据</li></ol><p>排序伪代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* phase 1: initialize set to empty */</span><br><span class="line">for i = [0, n)</span><br><span class="line">    bit[i]=0</span><br><span class="line">/* phase 2: insert present elements into the set */</span><br><span class="line">for each i in the input file</span><br><span class="line">    bit[i]=1</span><br><span class="line">/* phase 3: write sorted output */</span><br><span class="line">for i = [0, n)</span><br><span class="line">    if b[i]==1</span><br><span class="line">        write i on the output file</span><br></pre></td></tr></table></figure><p><strong>时间-空间折中与双赢：</strong> 随着现在存储器的空间越来越大，我们往往倾向于用空间换时间的算法，这种折中非常常见。但减少程序的运行空间需求也会减少其运行时间。空间需求的减少之所以会导致运行时间的减少，有两个原因：需要处理的数据变少了，意味着处理这些数据所需的时间也变少了。同时可以将这些数据保存在内存中而不是磁盘上，进一步避免了磁盘访问的时间（IO是巨大的开销，网络传递数据是更大的开销）。当然了，只有在设计远非最优的时候，才有可能时空双赢。</p><blockquote><p>折中在所有工程领域都存在。例如，汽车设计者可能会通过增加沉重的部件，用行驶里程的减少来换取更快的加速。但双赢是更好的结果。我对自己驾驶过的一辆小轿车做过一番研究，我观察到：“轿车基本结构重量的减少会使各底盘部件的重量进一步减少–甚至消除了对某些底盘部件的需求，例如转向助力系统。”</p></blockquote><h4 id="真实代码"><a class="header-anchor" href="#真实代码"> </a>真实代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BITSPERWORD 32</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHIFT 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MASK 0x1F</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 10000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N/BITSPERWORD];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    a[i&gt;&gt;SHIFT] |= (<span class="number">1</span>&lt;&lt;(i&amp;MASK));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    a[i&gt;&gt;SHIFT] &amp;= ~(<span class="number">1</span>&lt;&lt;(i&amp;MASK));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a[i&gt;&gt;SHIFT] &amp; (<span class="number">1</span>&lt;&lt;(i&amp;MASK));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        clear(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;i)!=EOF)&#123;</span><br><span class="line">        <span class="built_in">set</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(test(i))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对移位操作熟悉的话就会知道，<code>i&gt;&gt;SHIFT</code>的意思就是<code>i/32</code>。<code>a[i&gt;&gt;SHIFT]</code>也就是定位到i所属的数组单元（每个数组单元4个字节）。而<code>i&amp;MASK</code>的意思是<code>i%32</code>，然后<code>(1&lt;&lt;(i&amp;MASK))</code>就定位了i在所属的数组单元中的具体位置。</p><p>但我们手上没有数据来测试我们的代码是否正确，测试数据可以用随机生成的办法产生，具体会在<a href="#">《编程珠玑第12章 取样问题》</a>中讲解。</p><p>接下来我们来看看习题：</p><h2 id="习题"><a class="header-anchor" href="#习题"> </a>习题</h2><ol><li>如果不缺内存，如何使用一个具有库的语言来实现一种排序算法以表示和排序集合？</li></ol><p>使用C语言的标准库函数<code>qsort</code>:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">intcompare</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> *x - *y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">10000000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;a[n])!=EOF)&#123;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    qsort(a, n, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), intcompare);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用C++的标准模板库中的容器<code>set</code>来完成相同任务：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; S;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator j;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; i)&#123;</span><br><span class="line">        S.insert(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(j=S.begin();j&lt;S.end();j++)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>如何使用位逻辑运算（例如与、或、移位）来实现位向量？</li></ol><p>代码上面已经给出：<a href="#%E7%9C%9F%E5%AE%9E%E4%BB%A3%E7%A0%81">真实代码</a></p><ol start="3"><li><p>运行时效率是设计目标的一个重要组成部分，所得到的程序需要足够高效。在你自己的系统上实现位图排序并度量其运行时间。该时间与系统排序的运行时间以及习题1中排序的运行时间相比如何？假设n为10000000，且输入文件包含10000000个整数。</p></li><li><p>如果认真考虑了习题3，你将会生成小于n且没有重复的k个整数的问题。最简单的方法就是使用前k个正整数。这个极端的数据集合将不会明显地改变位图方法的运行时间，但是可能会歪曲系统排序的运行时间。如何生成位于0至n-1之间的k个不同的随机顺序的随机整数？尽量使你的程序简短且高效。</p></li><li><p>那个程序员说他有1MB的内存空间可用，但是我们概要描述的代码需要1.25MB内存。他可以不费力的索取到额外的空间。如果1MB空间是严格的边界，你会推荐如何处理呢？你的算法的运行时间又是多少？</p></li></ol><p>使用位图表示1 000万个数需要1000万个位，或者说125万字节。考虑到没有以数字0或1打头<br>的电话号码，我们可以将内存需求降低为100万字节。另一种做法是采用两趟算法，首先使用<br>5 000 000/8=625 000个字的存储空间来排序0~4 999 999之间的整数，然后在第二趟排序5 000 000~9 999 999的整数。k趟算法可以在kn的时间开销和n/k的空间开销内完成对最多n个小于n的无重复正整数的排序。</p><ol start="6"><li>如果那个程序员说的不是每个整数最多出现一次，而是每个整数最多出现10次，你又如何建议他呢？你的解决方案如何随着可用存储空间总量的变化而变化？</li></ol><p>如果每个整数最多出现10次，那么我们就可以使用4位的半字节来统计它出现的次数。利用习题5的答案，我们可以使用10 000 000/2个字节在1趟内完成对整个文件的排序，或使用10 000 000/2k个字节在k趟内完成对整个文件的排序。</p><ol start="9"><li>使用更多的空间来换取更少的运行时间存在一个问题：初始化空间本身需要消耗大量的时间。说明如何设计一种技术，在第一次访问向量的项时将其初始化为0。你的方案应该使用常量时间进行初始化和向量访问，使用的额外空间应正比于向量的大小。因为该方法通过进一步增加空间来减少减少初始化的时间，所以仅在空间很廉价、时间很宝贵且向量很稀疏的情况下才考虑使用。</li></ol><p>借助于两个额外的n元向量from、to和一个整数top，from和to也都没有初始化过，top初始化为0。当我们访问索引为i的data元素，想要知道<code>data[i]</code>有没有初始化过。如果<code>from[i]&lt;top</code>且<code>to[from[i]]=i</code>，那么说明已经初始化过。to数组就是用来记录已经访问过哪些data元素的，实际上to数组可以是一个<a href="https://zh.wikipedia.org/zh/Vector_(STL)" target="_blank" rel="noopener">动态数组</a>。</p><img src="../../../../images/2018/编程珠玑第一章1.png" width="300px"><p>下面代码实现对data[i]的首次访问：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from[i] = top;</span><br><span class="line">to[top] = i;</span><br><span class="line">data[i] = <span class="number">0</span>;</span><br><span class="line">top++;</span><br></pre></td></tr></table></figure><ol start="10"><li>在成本低廉的隔日送达时代之前，商店允许顾客通过电话订购商品，并在几天后上门自取。商店的数据库使用客户的电话号码作为其检索的主关键字（客户知道他们自己的电话号码，而且这些关键字几乎都是唯一的）。你如何组织商店的数据库，以允许高效的插入和检索操作？</li></ol><p>商店将纸质订单表格放在10x10的箱数组中，使用客户电话号码的最后两位作为散列索引。当客户打电话下订单时，将订单放到适当的箱中。当客户来取商品时，销售人员顺序搜索对应箱中的订单–这就是经典的“用顺序搜索来解决冲突的开放散列”。电话号码的最后两位数字非常接近于随机，因此是非常理想的散列函数，而最前面的两位数字则很不理想 - - 为什么?一些市政机关使用类似的方案在记事本中记录信息。</p><ol start="11"><li>在20世纪80年代早期，洛克希德公司加利福尼亚州桑尼维尔市工厂的工程师每天都要将许多由计算机辅助设计（CAD）系统生成的图纸从工厂送到位于圣克鲁斯市的测试站。虽然仅有40公里远，但使用汽车快递服务每天都需要一个多小时的时间（由于交通阻塞和山路崎岖），花费100美元。请给出新的数据传输方案并估计每一种方案的费用。</li></ol><p>两地的计算机原先是通过微波连接的，但是当时测试站打印图纸所需的打印机却非常昂贵。因此，该团队在主厂绘制图纸，然后拍摄下来并通过信鸽把35毫米的底片送到测试站，在测试站进行放大并打印成图片。鸽子来回一.次需要45分钟，是汽车所需时间的一半，并且每天只需要花费几美元。在项目开发的16个月中，信鸽传送了几百卷底片，仅丢失了两卷(当地有鹰，因此没有让信鸽传送机密数据)。由于现在打印机比较便宜，因此可以使用微波链路解决该问题。</p><ol start="12"><li>载人航天的先驱们很快就意识到需要在外太空的极端环境下实现顺利书写。民间盛传美国国<br>家宇航局(NASA)花费100万美元研发出了一种特殊的钢笔来解决这个问题。那么，前苏联又会如何解决相同的问题呢?</li></ol><p>看过三傻大闹宝莱坞的都知道，前苏联用的是铅笔，但铅笔的碎屑由于失重漂浮在空中会是很麻烦的问题。</p>]]></content>
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 《编程珠玑》 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>mysql问题集合</title>
      <link href="/blog/2018/11/05/mysql%E9%97%AE%E9%A2%98%E9%9B%86%E5%90%88/"/>
      <url>/blog/2018/11/05/mysql%E9%97%AE%E9%A2%98%E9%9B%86%E5%90%88/</url>
      <content type="html"><![CDATA[<h2 id="删除操作"><a class="header-anchor" href="#删除操作"> </a>删除操作</h2><p>delete from table where id not in (select id from table where name1=)<br>这样直接又查又写是不行的，只能造个临时表<br>1093 - You can’t specify target table ‘contacts’ for update in FROM clause</p><p>delete from table where id not in (select * from (select id from table where name1=) t)<br>另外还要关闭一个属性：<br>set SQL_SAFE_UPDATES = 0;</p><h2 id="跨表查询"><a class="header-anchor" href="#跨表查询"> </a>跨表查询</h2><p>跨表查询的时候，我老是先想到子查询，然后会困在一个地方，那就是我认为查询只能选择一个表，例如：<br>select * from table where …<br>其实这里的table可以不止一个table，而是table1[table2,]<br>所以当你查一个监控的宝贝的时候，你在监控表里面只能查到宝贝id，宝贝名称则需要去宝贝表里面根据宝贝id查询，如果我们只需要宝贝名就好办，直接一个子查询。<br>select goods_name from t_goods where goods_guid in (select goods_guid from t_goods_monitor where user_guid = “73ed02cc-c69d-48d9-87c1-8ffbe4fa3e47” and platform = 1 and sm_status = 1)<br>而如果我们还需要用到t_goods_monitor中的字段，则子查询就办不到了。<br>这个时候可以查多个表，也可以用join，正规的做法是用join可以节省查询时间。</p><p>查多个表：</p><p>select  t_goods_monitor.*, t_goods.goods_name from t_goods, t_goods_monitor where t_goods_monitor.user_guid = &quot;73ed02cc-c69d-48d9-87c1-8ffbe4fa3e47&quot;<br>and t_goods_monitor.platform = 1<br>and t_goods_monitor.sm_status = 1<br>and t_goods_monitor.goods_guid = t_goods.goods_guid</p><p>使用JOIN</p><p>select  t_goods_monitor.*, t_goods.goods_name from t_goods_monitor LEFT JOIN t_goods ON<br>t_goods_monitor.goods_guid = t_goods.goods_guid<br>and t_goods_monitor.platform = t_goods.platform<br>where  t_goods_monitor.user_guid = &quot;73ed02cc-c69d-48d9-87c1-8ffbe4fa3e47&quot;<br>and t_goods_monitor.platform = 1<br>and t_goods_monitor.sm_status = 1</p><p>t_goods是大表，里面可能包含几百万的宝贝，t_goods_monitor是小表。</p><p>查询小表，然后左连接大表。如果某个goods_guid没有对应的宝贝名，则依然查询出来。这就是LEFT JOIN，返回左表所有行。<br>这里要注意的是ON的条件只对右表起作用。</p><p>关于 “A LEFT JOIN B ON 条件表达式” 的一点提醒<br>ON 条件（“A LEFT JOIN B ON 条件表达式”中的ON）用来决定如何从 B 表中检索数据行。<br>如果 B 表中没有任何一行数据匹配 ON 的条件,将会额外生成一行所有列为 NULL 的数据<br>在匹配阶段 WHERE 子句的条件都不会被使用。仅在匹配阶段完成以后，WHERE 子句条件才会被使用。它将从匹配阶段产生的数据中检索过滤。</p><p>ON 子句和 WHERE 子句有什么不同？</p><p>一个问题：下面两个查询的结果集有什么不同么？</p><ol><li>SELECT * FROM product LEFT JOIN product_details<br>ON (<a href="http://product.id" target="_blank" rel="noopener">product.id</a> = product_details.id)<br>AND   product_details.id=2;</li><li>SELECT * FROM product LEFT JOIN product_details<br>ON (<a href="http://product.id" target="_blank" rel="noopener">product.id</a> = product_details.id)<br>WHERE product_details.id=2;</li></ol><p>用例子来理解最好不过了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM product LEFT JOIN product_details</span><br><span class="line">       ON (product.id = product_details.id);</span><br><span class="line">+----+--------+------+--------+-------+</span><br><span class="line">| id | amount | id   | weight | exist |</span><br><span class="line">+----+--------+------+--------+-------+</span><br><span class="line">|  1 |    100 | NULL |   NULL |  NULL |</span><br><span class="line">|  2 |    200 |    2 |     22 |     0 |</span><br><span class="line">|  3 |    300 | NULL |   NULL |  NULL |</span><br><span class="line">|  4 |    400 |    4 |     44 |     1 |</span><br><span class="line">+----+--------+------+--------+-------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SELECT * FROM product LEFT JOIN product_details</span><br><span class="line">       ON (product.id = product_details.id)</span><br><span class="line">       AND product_details.id=2;</span><br><span class="line">+----+--------+------+--------+-------+</span><br><span class="line">| id | amount | id   | weight | exist |</span><br><span class="line">+----+--------+------+--------+-------+</span><br><span class="line">|  1 |    100 | NULL |   NULL |  NULL |</span><br><span class="line">|  2 |    200 |    2 |     22 |     0 |</span><br><span class="line">|  3 |    300 | NULL |   NULL |  NULL |</span><br><span class="line">|  4 |    400 | NULL |   NULL |  NULL |</span><br><span class="line">+----+--------+------+--------+-------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"> </span><br><span class="line">mysql&gt; SELECT * FROM product LEFT JOIN product_details</span><br><span class="line">       ON (product.id = product_details.id)</span><br><span class="line">       WHERE product_details.id=2;</span><br><span class="line">+----+--------+----+--------+-------+</span><br><span class="line">| id | amount | id | weight | exist |</span><br><span class="line">+----+--------+----+--------+-------+</span><br><span class="line">|  2 |    200 |  2 |     22 |     0 |</span><br><span class="line">+----+--------+----+--------+-------+</span><br><span class="line">1 row in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>第一条查询使用 ON 条件决定了从 LEFT JOIN的 product_details表中检索符合的所有数据行。<br>第二条查询做了简单的LEFT JOIN，然后使用 WHERE 子句从 LEFT JOIN的数据中过滤掉不符合条件的数据行。<br>再来看一些示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;</span><br><span class="line">mysql&gt; SELECT * FROM product LEFT JOIN product_details</span><br><span class="line">       ON product.id = product_details.id</span><br><span class="line">       AND product.amount=100;</span><br><span class="line">+----+--------+------+--------+-------+</span><br><span class="line">| id | amount | id   | weight | exist |</span><br><span class="line">+----+--------+------+--------+-------+</span><br><span class="line">|  1 |    100 | NULL |   NULL |  NULL |</span><br><span class="line">|  2 |    200 | NULL |   NULL |  NULL |</span><br><span class="line">|  3 |    300 | NULL |   NULL |  NULL |</span><br><span class="line">|  4 |    400 | NULL |   NULL |  NULL |</span><br><span class="line">+----+--------+------+--------+-------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>所有来自product表的数据行都被检索到了，但没有在product_details表中匹配到记录（<a href="http://product.id" target="_blank" rel="noopener">product.id</a> = product_details.id AND product.amount=100 条件并没有匹配到任何数据）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT * FROM product LEFT JOIN product_details</span><br><span class="line">       ON (product.id = product_details.id)</span><br><span class="line">       AND product.amount=200;</span><br><span class="line">+----+--------+------+--------+-------+</span><br><span class="line">| id | amount | id   | weight | exist |</span><br><span class="line">+----+--------+------+--------+-------+</span><br><span class="line">|  1 |    100 | NULL |   NULL |  NULL |</span><br><span class="line">|  2 |    200 |    2 |     22 |     0 |</span><br><span class="line">|  3 |    300 | NULL |   NULL |  NULL |</span><br><span class="line">|  4 |    400 | NULL |   NULL |  NULL |</span><br><span class="line">+----+--------+------+--------+-------+</span><br><span class="line">4 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure><p>有来自product表的数据行都被检索到了，但没有在product_details表中匹配到记录（<a href="http://product.id" target="_blank" rel="noopener">product.id</a> = product_details.id AND product.amount=100 条件并没有匹配到任何数据）</p><p>提问：能不能先where再on，因为先where再on可以提高效率。就拿根据宝贝ID跨表查询宝贝名来说，如果能先用where筛选出需要的宝贝ID在去查询宝贝名的话就能节省查询次数，而如果是先用on直接把所有宝贝ID对应的宝贝名查出来，再where过滤不符合条件的宝贝ID，这样第一步的on操作就做了一些无用功。</p><h2 id="中文显示问题"><a class="header-anchor" href="#中文显示问题"> </a>中文显示问题</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [BookMarkSocial]&gt; show create table users \G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">      Table: users</span><br><span class="line">Create Table: CREATE TABLE `users` (</span><br><span class="line">  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `unique_name` varchar(20) CHARACTER SET latin1 NOT NULL,</span><br><span class="line">  `password` varchar(512) CHARACTER SET latin1 NOT NULL,</span><br><span class="line">  `email` varchar(40) CHARACTER SET latin1 NOT NULL,</span><br><span class="line">  `phone` varchar(20) CHARACTER SET latin1 DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table table_name convert to character set utf8;</span><br><span class="line">//此后再往这个table插入中文的时候，就可以正常存储和读取了，但不知道为什么之前的乱码还是不能纠正，只能新插入的数据没有问题。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MariaDB [BookMarkSocial]&gt; show variables like &apos;%char%&apos;</span><br><span class="line">    -&gt; ;</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| Variable_name            | Value                      |</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| character_set_client    | utf8                      |</span><br><span class="line">| character_set_connection | utf8                      |</span><br><span class="line">| character_set_database  | utf8                      |</span><br><span class="line">| character_set_filesystem | binary                    |</span><br><span class="line">| character_set_results    | utf8                      |</span><br><span class="line">| character_set_server    | utf8                      |</span><br><span class="line">| character_set_system    | utf8                      |</span><br><span class="line">| character_sets_dir      | /usr/share/mysql/charsets/ |</span><br><span class="line">+--------------------------+----------------------------+</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set character_set_server=utf8;</span><br><span class="line">set character_set_database=utf8;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>mysql查询性能优化</title>
      <link href="/blog/2018/11/05/mysql%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
      <url>/blog/2018/11/05/mysql%E6%9F%A5%E8%AF%A2%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<h2 id="为查询缓存优化你的查询"><a class="header-anchor" href="#为查询缓存优化你的查询"> </a>为查询缓存优化你的查询</h2><p>大多数的MySQL服务器都开启了查询缓存。这是提高性最有效的方法之一，而且这是被MySQL的数据库引擎处理的。当有很多相同的查询被执行了多次的时候，这些查询结果会被放到一个缓存中，这样，后续的相同的查询就不用操作表而直接访问缓存结果了。</p><p>这里最主要的问题是，对于程序员来说，这个事情是很容易被忽略的。因为，我们某些查询语句会让MySQL不使用缓存。请看下面的示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 查询缓存不开启</span><br><span class="line">$r = mysql_query(&quot;SELECT username FROM user WHERE signup_date &gt;= CURDATE()&quot;);</span><br><span class="line"> </span><br><span class="line">// 开启查询缓存</span><br><span class="line">$today = date(&quot;Y-m-d&quot;);</span><br><span class="line">$r = mysql_query(&quot;SELECT username FROM user WHERE signup_date &gt;= &apos;$today&apos;&quot;);</span><br></pre></td></tr></table></figure><p>上面两条SQL语句的差别就是 CURDATE() ，MySQL的查询缓存对这个函数不起作用。所以，像 NOW() 和 RAND() 或是其它的诸如此类的SQL函数都不会开启查询缓存，因为这些函数的返回是会不定的易变的。所以，你所需要的就是用一个变量来代替MySQL的函数，从而开启缓存。</p><h2 id="explain-你的-select-查询"><a class="header-anchor" href="#explain-你的-select-查询"> </a>EXPLAIN 你的 SELECT 查询</h2><h2 id="当只要一行数据时使用-limit-1"><a class="header-anchor" href="#当只要一行数据时使用-limit-1"> </a>当只要一行数据时使用 LIMIT 1</h2><p>当你查询表的有些时候，你已经知道结果只会有一条结果，但因为你可能需要去fetch游标，或是你也许会去检查返回的记录数。</p><p>在这种情况下，加上 LIMIT 1 可以增加性能。这样一样，MySQL数据库引擎会在找到一条数据后停止搜索，而不是继续往后查少下一条符合记录的数据。</p><h2 id="为搜索字段建索引"><a class="header-anchor" href="#为搜索字段建索引"> </a>为搜索字段建索引</h2><p>索引并不一定就是给主键或是唯一的字段。如果在你的表中，有某个字段你总要会经常用来做搜索，那么，请为其建立索引吧。</p><h2 id="在join表的时候使用相当类型的例-并将其索引"><a class="header-anchor" href="#在join表的时候使用相当类型的例-并将其索引"> </a>在Join表的时候使用相当类型的例，并将其索引</h2><h2 id="千万不要-order-by-rand"><a class="header-anchor" href="#千万不要-order-by-rand"> </a>千万不要 ORDER BY RAND()</h2><h2 id="避免-select"><a class="header-anchor" href="#避免-select"> </a>避免 SELECT *</h2><p>从数据库里读出越多的数据，那么查询就会变得越慢。并且，如果你的数据库服务器和WEB服务器是两台独立的服务器的话，这还会增加网络传输的负载。</p><p>所以，你应该养成一个需要什么就取什么的好的习惯。</p><h2 id="永远为每张表设置一个id"><a class="header-anchor" href="#永远为每张表设置一个id"> </a>永远为每张表设置一个ID</h2><p>我们应该为数据库里的每张表都设置一个ID做为其主键，而且最好的是一个INT型的（推荐使用UNSIGNED），并设置上自动增加的AUTO_INCREMENT标志。</p><p>就算是你 users 表有一个主键叫 “email”的字段，你也别让它成为主键。使用 VARCHAR 类型来当主键会使用得性能下降。另外，在你的程序中，你应该使用表的ID来构造你的数据结构。</p><p>而且，在MySQL数据引擎下，还有一些操作需要使用主键，在这些情况下，主键的性能和设置变得非常重要，比如，集群，分区……</p><p>在这里，只有一个情况是例外，那就是“关联表”的“外键”，也就是说，这个表的主键，通过若干个别的表的主键构成。我们把这个情况叫做“外键”。比如：有一个“学生表”有学生的ID，有一个“课程表”有课程ID，那么，“成绩表”就是“关联表”了，其关联了学生表和课程表，在成绩表中，学生ID和课程ID叫“外键”其共同组成主键。</p><h2 id="使用-enum-而不是-varchar"><a class="header-anchor" href="#使用-enum-而不是-varchar"> </a>使用 ENUM 而不是 VARCHAR</h2><p>ENUM 类型是非常快和紧凑的。在实际上，其保存的是 TINYINT，但其外表上显示为字符串。这样一来，用这个字段来做一些选项列表变得相当的完美。</p><p>如果你有一个字段，比如“性别”，“国家”，“民族”，“状态”或“部门”，你知道这些字段的取值是有限而且固定的，那么，你应该使用 ENUM 而不是 VARCHAR。</p><h2 id="尽可能的使用-not-null"><a class="header-anchor" href="#尽可能的使用-not-null"> </a>尽可能的使用 NOT NULL</h2><p>除非你有一个很特别的原因去使用 NULL 值，你应该总是让你的字段保持 NOT NULL。这看起来好像有点争议，请往下看。</p><p>首先，问问你自己“Empty”和“NULL”有多大的区别（如果是INT，那就是0和NULL）？如果你觉得它们之间没有什么区别，那么你就不要使用NULL。（你知道吗？在 Oracle 里，NULL 和 Empty 的字符串是一样的！)</p><p>不要以为 NULL 不需要空间，其需要额外的空间，并且，在你进行比较的时候，你的程序会更复杂。 当然，这里并不是说你就不能使用NULL了，现实情况是很复杂的，依然会有些情况下，你需要使用NULL值。</p><h2 id="拆分大的-delete-或-insert-语句"><a class="header-anchor" href="#拆分大的-delete-或-insert-语句"> </a>拆分大的 DELETE 或 INSERT 语句</h2><p>如果你需要在一个在线的网站上去执行一个大的 DELETE 或 INSERT 查询，你需要非常小心，要避免你的操作让你的整个网站停止相应。因为这两个操作是会锁表的，表一锁住了，别的操作都进不来了。</p><p>Apache 会有很多的子进程或线程。所以，其工作起来相当有效率，而我们的服务器也不希望有太多的子进程，线程和数据库链接，这是极大的占服务器资源的事情，尤其是内存。</p><p>如果你把你的表锁上一段时间，比如30秒钟，那么对于一个有很高访问量的站点来说，这30秒所积累的访问进程/线程，数据库链接，打开的文件数，可能不仅仅会让你泊WEB服务Crash，还可能会让你的整台服务器马上掛了。</p><p>所以，如果你有一个大的处理，你定你一定把其拆分，使用 LIMIT 条件是一个好的方法。下面是一个示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">while (1) &#123;</span><br><span class="line">    //每次只做1000条</span><br><span class="line">    mysql_query(&quot;DELETE FROM logs WHERE log_date &lt;= &apos;2009-11-01&apos; LIMIT 1000&quot;);</span><br><span class="line">    if (mysql_affected_rows() == 0) &#123;</span><br><span class="line">        // 没得可删了，退出！</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    // 每次都要休息一会儿</span><br><span class="line">    usleep(50000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>mysql存储过程</title>
      <link href="/blog/2018/11/05/mysql%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/"/>
      <url>/blog/2018/11/05/mysql%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h2 id="基本概念"><a class="header-anchor" href="#基本概念"> </a>基本概念</h2><ol><li><p>什么是存储例程？</p><p>存储例程是一组sql语句，通过在查询中调用一个指定的名称来执行这些sql语句命令。</p></li><li><p>为什么要使用存储例程？</p><p>有时候我们的服务同时有web版，桌面版，移动版，他们都和数据库进行交互来完成数据的存取工作。现在要修改其中一个查询sql语句，那么我们可能要同时修改他们中对应的查询sql语句，这是一种重复劳动！另外把sql语句放在web或桌面程序中很容易遭到sql注入攻击破坏。而存储例程正好可以帮助我们解决这个问题。</p></li><li><p>存储过程（stored procedure）、存储例程（stored routine）和存储函数的区别？</p><p>Mysql存储例程实际上包括了存储过程和存储函数，它们被统称为存储例程。其中存储过程主要完成select、insert、delete、update等工作，而存储函数只完成select工作。</p></li></ol><h2 id="语法"><a class="header-anchor" href="#语法"> </a>语法</h2><h3 id="基本结构"><a class="header-anchor" href="#基本结构"> </a>基本结构</h3><p>创建存储过程和存储函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create procedure 存储过程名 (参数)</span><br><span class="line">create function 存储函数名 (参数)</span><br></pre></td></tr></table></figure><p>一个完整的存储过程例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER //</span><br><span class="line">CREATE PROCEDURE 存储过程名(OUT s int)</span><br><span class="line">BEGIN</span><br><span class="line">SELECT COUNT(*) INTO s FROM user;</span><br><span class="line">END //</span><br><span class="line">DELIMITER ;</span><br></pre></td></tr></table></figure><p>语法解析：</p><ol><li>这里需要注意的是<code>DELIMITER //</code>和<code>DELIMITER ;</code>两句，<code>DELIMITER</code>是分隔符的意思，因为mysql默认以<code>;</code>为分隔符，如果我们没有声明分隔符，那么编译器会把存储过程当成SQL语句处理，存储过程的编译就会报错，所以要事先用<code>DELIMITER</code>关键字声明当前分隔符，这样MySQL才会将<code>;</code>当做存储过程中的代码，不会执行这些代码。<strong>最后用完之后要把分隔符还原</strong>。知道了这语法的意思，你就会知道，为啥有的时候有人代码写成：<code>DELIMITER $$</code>，因为分隔符完全可以自己设定啊，唯一要担心的就是与关键字冲突。<code>//</code>在mysql里面并不是注释符，mysql的注释符是<code>--</code>。</li><li>存储过程有三种类型的参数：<code>IN</code>、<code>OUT</code>、<code>INOUT</code>，顾名思义，<code>IN</code>类型的参数只能用作输入，<code>OUT</code>类型的参数只能用作输出，<code>INOUT</code>类型的参数可以输入输出。</li><li>过程体的开始和结束使用<code>BEGIN</code>和<code>END</code>标识。</li></ol><h3 id="变量"><a class="header-anchor" href="#变量"> </a>变量</h3><h4 id="定义"><a class="header-anchor" href="#定义"> </a>定义</h4><p>局部变量定义一定要放在存储过程体的开始</p><p><code>DECLARE variable_name [,variable_name...] datatype [DEFAULT value];</code></p><p>其中<code>datatype</code>为MySQL的数据类型，例如：int、float、varchar、date</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DECLARE l_int int unsigned default 4000000;</span><br><span class="line">DECLARE l_numeric number(8,2) DEFAULT 9.95;</span><br><span class="line">DECLARE l_date date DEFAULT &apos;1997-12-31&apos;;</span><br><span class="line">DECLARE l_datetime datetime DEFAULT &apos;1997-12-31 23:59:59&apos;</span><br><span class="line">DECLARE l_varchar varchar DEFAULT &apos;This will not be padded&apos;</span><br></pre></td></tr></table></figure><h4 id="赋值"><a class="header-anchor" href="#赋值"> </a>赋值</h4><p><code>SET 变量名=表达式值[,variable_name=expression...];</code></p><p>用户变量名以@开头</p><h4 id="注释"><a class="header-anchor" href="#注释"> </a>注释</h4><ul><li>单行注释：<code>--</code></li><li>多行注释：<code>/**/</code></li></ul><h2 id="存储过程的查询"><a class="header-anchor" href="#存储过程的查询"> </a>存储过程的查询</h2><p>我们想知道一个数据库下有哪些表，可以用<code>show tables;</code>进行查看，那么我们要想看某个数据库下有哪些存储过程，用什么命令呢？</p><p><code>show procedure status where db=&quot;数据库名&quot;;</code></p><p>db这个名字是不能改的。</p><p>如果想知道详细的存储过程，是不是也可以像操作表一样用<code>describe 表名;</code>进行查看呢？</p><p><code>show create procedure 数据库.存储过程名;</code></p>]]></content>
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> mysql </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>LeetCode 543. Diameter of Binary Tree</title>
      <link href="/blog/2018/11/05/LeetCode%20543.%20Diameter%20of%20Binary%20Tree/"/>
      <url>/blog/2018/11/05/LeetCode%20543.%20Diameter%20of%20Binary%20Tree/</url>
      <content type="html"><![CDATA[<p>Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the <strong>longest</strong> path between any two nodes in a tree. This path may or may not pass through the root.</p><p><strong>Example:</strong><br>Given a binary tree</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \     </span><br><span class="line">4   5</span><br></pre></td></tr></table></figure><p>Return <strong>3</strong>, which is the length of the path [4,2,1,3] or [5,2,1,3].</p><p><strong>Note:</strong> The length of path between two nodes is represented by the number of edges between them.</p><p>这一题要求的是二叉树的直径，也就是二叉树中两点之间的最长距离。连接这两个点的路径中必定有一个点是最高点，而这个最高点的左子树深度+右子树深度就是直径，而且任何其他点的左子树深度+右子树深度不可能大于这个点的。所以求这个直径实际上就是求 <code>Max(左子树深度+右子树深度)</code>。</p><p>高的结点在求深度的时候要用到它孩子的深度，所以要么递归，要么像动态规划一样将孩子的结果保存起来。</p><p>递归写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> depth=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;TreeNode, Integer&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        search(root);</span><br><span class="line">        <span class="keyword">return</span> depth-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">search</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(map.get(root)!=<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> map.get(root);</span><br><span class="line">        <span class="keyword">int</span> left = search(root.left);</span><br><span class="line">        <span class="keyword">int</span> right = search(root.right);</span><br><span class="line">        <span class="keyword">if</span>(left+right+<span class="number">1</span>&gt;depth)&#123;</span><br><span class="line">            depth = left+right+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(root,left&gt;right?left+<span class="number">1</span>:right+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> left&gt;right?left+<span class="number">1</span>:right+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>题目中说了，直径是边的个数而不是节点的个数。左子树深度+右子树深度+1 = 直径上的节点数，那么：直径上的节点数-1 = 边的个数，所以：直径=左子树深度+右子树深度</p></blockquote><p>我们可以优化一下，记录一下节点的深度，避免重复计算。</p>]]></content>
      
      <categories>
          
          <category> ACM </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>程序员修炼之道（从小工到专家）</title>
      <link href="/blog/2018/11/05/%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93%EF%BC%88%E4%BB%8E%E5%B0%8F%E5%B7%A5%E5%88%B0%E4%B8%93%E5%AE%B6%EF%BC%89/"/>
      <url>/blog/2018/11/05/%E7%A8%8B%E5%BA%8F%E5%91%98%E4%BF%AE%E7%82%BC%E4%B9%8B%E9%81%93%EF%BC%88%E4%BB%8E%E5%B0%8F%E5%B7%A5%E5%88%B0%E4%B8%93%E5%AE%B6%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="无意的重复"><a class="header-anchor" href="#无意的重复"> </a>无意的重复</h2><p>有时，重复来自设计中的错误。</p><p>让我们来看一个来自配送行业的例子。假定我们的分析揭示，一辆卡车有车型、牌照号、司机以及其他一些属性。与此类似，发运路线的属性包括路线、卡车和司机，基于这一理解，我们编写了一些类。</p><p>但如果Sally打电话请病假，我们必须改换司机，事情又会怎样呢？Truck和DeliverRoute都包含有司机。我们改变哪一个？显然这一的重复很糟糕，根据底层的商业模式对其进行规范化（normalize）–卡车的底层属性集真的应该包含司机？路线呢？又或许我们需要第三种对象，把司机、卡车及路线结合在一起，不管最终的解决方案是什么，我们都应该避免这种不规范的数据。</p><p>当我们拥有多个相互依赖的数据元素时，会出现一种不那么显而易见的不规范数据，让我们看一个表示线段的类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point start;</span><br><span class="line">    Point end;</span><br><span class="line">    <span class="keyword">double</span> length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第一眼看上去，这个类似乎是合理的，线段显然有起点和终点，并总是有长度（即使长度为0），但这里有重复。长度是由起点和终点决定的：改变其中一个，长度就会变化，最好是让长度成为计算字段：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point start;</span><br><span class="line">    Point end;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">length</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> start.distanceTo(end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在以后的开发过程中，你可以因为性能原因而选择违反DRY原则，这经常发生在你需要缓存数据，以避免重复昂贵的操作时，其诀窍是使影响局部化–对DRY原则的违反没有暴露给外界：只有类中的方法需要注意“保持行为良好”。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> changed;</span><br><span class="line">    <span class="keyword">double</span> length;</span><br><span class="line">    Point start;</span><br><span class="line">    Point end;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setStart</span><span class="params">(Point p)</span></span>&#123;</span><br><span class="line">        start = p;</span><br><span class="line">        changed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setEnd</span><span class="params">(Point p)</span></span>&#123;</span><br><span class="line">        end = p;</span><br><span class="line">        changed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Point <span class="title">getStart</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Point <span class="title">getEnd</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> end;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getLength</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(changed)&#123;</span><br><span class="line">            length = start.distanceTo(end);</span><br><span class="line">            changed = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个例子还说明了像Java和C++这样的面向对象语言的一个重要问题在可能的情况下，应该总是用访问器（accessor）函数读写对象的属性。这将使未来增加功能（比如缓存）变得更容易。</p><blockquote><p>访问器函数的使用与Meyer的Uniform Access原则紧密相关，该规则规定：“模块提供的所有服务都应该通过统一的表示法使用，该表示法不能泄露它们是通过存储还是通过计算实现的”</p></blockquote>]]></content>
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 《程序员修炼之道（从小工到专家）》 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>编译原理笔记</title>
      <link href="/blog/2018/11/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/"/>
      <url>/blog/2018/11/04/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="编译原理知识点"><a class="header-anchor" href="#编译原理知识点"> </a>编译原理知识点</h2><p>总共六个阶段：</p><ol><li>词法分析</li><li>语法分析</li><li>语义分析</li><li>中间代码生成</li><li>代码优化</li><li>目标代码生成</li></ol><p><img src="https://i.loli.net/2018/11/04/5bdead1f04562.png" alt="编译原理.png"></p><p>DFA（确定有穷自动机） 和 NFA（非确定有穷自动机）<br>区别就是，NFA 可以包含多个状态作为一个集，从这个集中跳到下一个集。而 DAF 是单个单个的状态，从一个状态跳到下一个状态。</p><p><img src="https://i.loli.net/2018/11/04/5bdeada2958c9.png" alt="编译原理2.png"><br><img src="https://i.loli.net/2018/11/04/5bdeada4b572b.png" alt="编译原理4.png"><br><img src="https://i.loli.net/2018/11/04/5bdeada864ff4.png" alt="编译原理3.png"></p><p>所以文法G的形式定义如上所述<br>Vt：终结符，我们一般用除了大写字母表示。<br>Vn：非终结符，我们一般用大写字母表示。<br>S：一般是开始符号。<br>P：就表示一种规则啦。<br>a-&gt;b被称为产生式（定义式）</p><p><img src="https://i.loli.net/2018/11/04/5bdeada888830.png" alt="编译原理5.png"></p><table><thead><tr><th>文法类型</th><th>规则</th><th>示例</th></tr></thead><tbody><tr><td>0型文法</td><td>a-&gt;b 产生式左边a至少含有一个非终结符</td><td>nA-&gt;b</td></tr><tr><td>1型文法</td><td>在0型基础上，a-&gt;b 产生式右侧的长度越来越长。<code>|b| &gt;=|a| S-&gt;ε</code> 除外。</td><td>nA-&gt;bSd</td></tr><tr><td>2型文法</td><td>在1型基础上，a-&gt;b左侧为一个非终结符。</td><td>A-&gt;bSd</td></tr><tr><td>3型文法</td><td>在2型基础上，a-&gt;b 右侧的形式为：A-&gt;cB 或A-&gt;c （仅此两种形式）AB为非终结符</td><td>A-&gt;bSA-n</td></tr></tbody></table><p>从0型文法到3型文法，规则越来越严格了。<br><strong>0型文法</strong>：可由图灵机识别（关于图灵机，百度百科描述很详细了。）<br><strong>1型文法</strong>：上下文有关文法。（任何产生规则的左手端和右手端都可以被终结符和非终结符的上下文所围绕，乔姆斯基描述自然语言的一种方式介入的，在自然语言中一个单词是否可以出现在特定的位置要依赖于上下文。）<br><strong>2型文法</strong>：上下文无关文法。之所以称为上下文无关文法，是因为在推导式中a-&gt;b ，字符a总可以被字符串b自由替换，而无需考虑字符a出现的上下文。<br><strong>3型文法</strong>：正规语言，之所人称作正规语言（正则语言），可能是因为3型文法只有两种形式 A-&gt;aB A-&gt;a ，比较固定，规则明显，所以称为正规语言。（小菜这么想的）</p><ul><li>文法</li><li>正规式</li><li>有穷自动机</li><li>语法推导树</li></ul><p>正规式：<br>正规式：正则表达式，表示正规集的工具。<br>一个正规式对应一个正规文法（3型文法）<br>之间能够进行准换<br>三个基本规则：<br>A-&gt;xB,B-&gt;y  则 A=xy。<br>A-&gt;xA|y  则A=x<em>y  （x</em>代表x从0到无穷多个）<br>A-&gt;x,A-&gt;y 则A=x|y</p><p>正规式主要用到了递归的思想，无论遇到多复杂的正规式都可以拆分成上面这三种形式，然后进行解题。</p><p><img src="https://i.loli.net/2018/11/04/5bdeaf42b0418.png" alt="编译原理6.png"></p><p>编译器，解释器<br>预处理器（preprocessor），汇编器（assembler），链接器（linker），加载器（loader）</p><h1>龙书笔记</h1><h2 id="1-1-语言处理器"><a class="header-anchor" href="#1-1-语言处理器"> </a>1.1 语言处理器</h2><p>概念</p><ul><li>语言处理器</li><li>源语言</li><li>目标语言</li><li>编译器（compiler）</li><li>解释器（interpreter）</li><li>字节码（bytecode）</li><li>即时（just in time）编译器</li><li>预处理器（preprocessor）</li><li>编译器 （compiler）</li><li>汇编器（assembler）</li><li>链接器（linker）</li><li>加载器（loader）</li></ul><p>知识点</p><ul><li>编译器的一个重要任务是报告它在翻译过程中发现的源程序中的错误</li><li>编译器产生的机器语言目标程序通常比解释器快很多，但解释器由于逐个语句的执行源程序所以错误诊断效果比编译器好</li><li>Java字节码有很好的平台移植性</li><li>预处理器的任务是把多个文件中的源程序集合到一起，并处理宏，然后输出给编译器</li><li>编译器输出汇编语言程序（因为汇编程序容易输出，便于阅读和调试）</li><li>汇编器把汇编程序生成可重定位的机器代码</li><li>大型程序经常被分为多个部分进行编译，因此可重定位的机器代码有必要和其他可重定位的目标文件及库文件连接到一起，形成真正可运行的机器代码。一个文件中的代码可能指向另一个文件中的位置，而 链接器能够解决外部内存地址的问题。</li><li>最后加载器把所有可执行文件放进内存中执行</li></ul><h2 id="1-1节练习"><a class="header-anchor" href="#1-1节练习"> </a>1.1节练习</h2><p>1.1.1：编译器和解释器的区别是什么？<br>编译器一次编译完所有的源代码并生成目标文件，解释器对源程序像读取执行指令一样挨个语句执行。<br>1.1.2：编译器相对于解释器的优点是什么？解释器相对于编译器的有点是什么？<br>编译器生成的目标文件运行比解释器直接执行源程序快很多，解释器比编译器的错误诊断能力好<br>1.1.3：在一个语言处理系统中，编译器产生汇编语言而不是机器语言的好处是什么？<br>汇编语言和机器语言是一一对应的，但汇编语言比机器语言容易阅读和调试，汇编语言面向人，机器语言面向机器。<br>1.1.4：把一种高级语言翻译成另一种高级语言的编译器称为源到源（source-to-source）的翻译器。编译器使用C语言作为目标语言有什么好处？<br>C语言是跨平台的<br>1.1.5：描述一下汇编器所要完成的一些任务。<br>汇编器把汇编程序生成可重定位的机器程序。</p><h2 id="一个编译器的结构"><a class="header-anchor" href="#一个编译器的结构"> </a>一个编译器的结构</h2><p>概念</p><ul><li>分析（analysis）部分</li><li>综合（synthesis）部分</li><li>组成要素</li><li>中间表示</li><li>符号表（symbol table）</li><li>词法分析（lexical analysis）或扫描（scanning）</li><li>词素（lexeme）</li><li>词法单元（token）：</li><li>语法分析（syntax analysis）器或解析（parsing）</li><li>语义分析器（semantic analyzer）</li><li>中间代码生成器</li><li>代码优化器</li><li>代码生成器</li><li>语法树（syntax tree）</li><li>类型检查（type checking）</li><li>自动类型转换（coercion）</li></ul><p>知识点</p><ul><li>分析部分把源程序分解成多个组成要素，并在这些要素只上加上语法结构</li></ul>]]></content>
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>熟练使用JetBrains家的IDE</title>
      <link href="/blog/2018/11/04/%E7%86%9F%E7%BB%83%E4%BD%BF%E7%94%A8JetBrains%E5%AE%B6%E7%9A%84IDE/"/>
      <url>/blog/2018/11/04/%E7%86%9F%E7%BB%83%E4%BD%BF%E7%94%A8JetBrains%E5%AE%B6%E7%9A%84IDE/</url>
      <content type="html"><![CDATA[<h2 id="通用快捷键"><a class="header-anchor" href="#通用快捷键"> </a>通用快捷键</h2><ol><li>格式化代码（reformat code）:<br>win: ctrl+alt+L<br>mac: command+option+L</li><li>在一行的任意位置使用： shift + enter，新建下一行并跳到下一行。</li><li>善用代码自动补全功能，变量名和方法名等可以用 enter 补全。导入包可以用 alt + enter。</li><li>上下移动代码，ctrl+shift+上下键</li><li>Android Studio 生成函数注释：你在方法前输入/**然后一回车，自动帮你生成方法和参数的注释。</li></ol><h2 id="intellj-idea"><a class="header-anchor" href="#intellj-idea"> </a>Intellj Idea</h2><p>快速打出常用语句：</p><ol><li><strong>sout</strong>：<code>System.out.println();</code></li><li><strong>psvm</strong>：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>使用IDE的右键中的生成Getter Setter选项自动生成Getter Setter，使用toString自动生成toString。</p></li><li><p>跳转到接口：<code>ctrl+b</code>； 跳转到实现类：<code>ctrl + alt +B</code></p></li><li><p><img src="../../../../images/2018/idea%E5%9B%BE%E8%A7%A3.png" alt=""></p></li></ol><p>上面这个按钮可以快速的在目录树中定位到当前类所在的路径</p><ol start="6"><li>ctrl+alt+t</li></ol><p><img src="../../../../images/2018/idea-ctrl+alt+t.png" alt="idea-ctrl+alt+t.png"></p>]]></content>
      
      <categories>
          
          <category> 工具 </category>
          
          <category> IDE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDE </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>精通一款编辑器之sublime text 3</title>
      <link href="/blog/2018/11/04/%E7%B2%BE%E9%80%9A%E4%B8%80%E6%AC%BE%E7%BC%96%E8%BE%91%E5%99%A8%E4%B9%8Bsublime%20text%203/"/>
      <url>/blog/2018/11/04/%E7%B2%BE%E9%80%9A%E4%B8%80%E6%AC%BE%E7%BC%96%E8%BE%91%E5%99%A8%E4%B9%8Bsublime%20text%203/</url>
      <content type="html"><![CDATA[<h2 id="编辑器常用功能"><a class="header-anchor" href="#编辑器常用功能"> </a>编辑器常用功能</h2><ol><li>格式化代码：格式化代码可以让你不用管代码的格式，可以放肆的写程序，你可以少敲很多空格，不用关心代码的格式问题，机器给出的代码格式风格统一且漂亮，一键解决你的格式问题，真是提高码代码效率的非常重要的功能。</li><li>查找文件：查找文件是在集成开发的时候非常重要的功能，当文件多起来的时候，快速定位到文件可以节省很多时间，甚至有时候文件实在太多，你只能通过查找的方式找到那个文件。</li><li>正则全文件查找和替换：轻松让你更改全局变量和配置，这是一个必须的功能，没有它简直无法想象工作量有多大。</li><li>代码收缩和扩展：代码太长怎么办，收缩和扩展啊。</li></ol><h2 id="安装卸载插件"><a class="header-anchor" href="#安装卸载插件"> </a>安装卸载插件</h2><ol><li><code>cmd+shift+p</code>：打开命令板，输入<code>install</code>，点击：<strong>Package Control: Install Package</strong>选项，然后搜索你想要的插件。</li><li>卸载请在命令板输入：<code>remove</code>，点击：<strong>Package Control: Remove Package</strong>选项。其实卸载无非就是两个词：<code>remove</code>和<code>uninstall</code>，多试试就行了。</li></ol><blockquote><p>打开命令板之后什么都不想干，怎么关闭命令板呢？其实很简单，再按一次打开命令板的快捷键就行了，<strong>开关都用同一个键或者按钮，这是比较通用设计理念</strong>。</p></blockquote><h2 id="vue-插件"><a class="header-anchor" href="#vue-插件"> </a>vue 插件</h2><ol><li><strong>vue-syntax-highlight</strong>：可以让<code>.vue</code>文件高亮。</li><li><strong>HTML-CSS-JS Prettify</strong>：可以格式化这三种语言的代码，特别是单文件的vue，非常需要这个来同时格式化三种语言。不过需要配置一下。工具栏路径：<code>Sublime Text -&gt; Preferences -&gt; Package Settings -&gt; HTML/CSS/JS Prettify -&gt; Plugin Options - Default</code>，然后搜索：<code>allowed_file_extensions</code>，给这个配置项添加一个<code>vue</code>即可，要注意的是有四处有这个配置项，分别是<code>html</code>、<code>css</code>、<code>js</code>、<code>json</code>，如果你想它们全都能格式化，自然是要全都添加<code>vue</code>，但实验证明只加html里面就行了，如果在其他几个里面加反而引起了冲突。然后格式化代码的快捷键是什么呢？同样也有配置文件的，工具栏路径：<code>Sublime Text -&gt; Preferences -&gt; Package Settings -&gt; HTML/CSS/JS Prettify -&gt; Keyboard Shortcuts - Default</code>，可以看到：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">  &quot;keys&quot;: [&quot;super+shift+h&quot;],</span><br><span class="line">  &quot;command&quot;: &quot;htmlprettify&quot;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  &quot;keys&quot;: [&quot;super+alt+h&quot;, &quot;p&quot;],</span><br><span class="line">  &quot;command&quot;: &quot;htmlprettify_set_prettify_prefs&quot;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  &quot;keys&quot;: [&quot;super+alt+h&quot;, &quot;o&quot;],</span><br><span class="line">  &quot;command&quot;: &quot;htmlprettify_set_plugin_options&quot;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  &quot;keys&quot;: [&quot;super+alt+h&quot;, &quot;k&quot;],</span><br><span class="line">  &quot;command&quot;: &quot;htmlprettify_set_keyboard_shortcuts&quot;</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  &quot;keys&quot;: [&quot;super+alt+h&quot;, &quot;n&quot;],</span><br><span class="line">  &quot;command&quot;: &quot;htmlprettify_set_node_path&quot;</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure><p>第一项即为使用这个插件的快捷键，也就是格式化代码的快捷键。</p>]]></content>
      
      <categories>
          
          <category> 工具 </category>
          
          <category> 编辑器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编辑器 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>什么是回调</title>
      <link href="/blog/2018/11/04/%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E8%B0%83/"/>
      <url>/blog/2018/11/04/%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E8%B0%83/</url>
      <content type="html"><![CDATA[<p><img src="https://i.loli.net/2018/11/04/5bdeaff01640b.png" alt="回调2.png"></p><p>打个比方，有一家旅馆提供叫醒服务，但是要求旅客自己决定叫醒的方法。可以是打客房电话，也可以是派服务员去敲门，睡得死怕耽误事的，还可以要求往自己头上浇盆水。这里，“叫醒”这个行为是旅馆提供的，相当于库函数，但是叫醒的方式是由旅客决定并告诉旅馆的，也就是回调函数。而旅客告诉旅馆怎么叫醒自己的动作，也就是把回调函数传入库函数的动作，称为登记回调函数（to register a callback function）。</p><p>在回调中，我们利用某种方式，把回调函数像参数一样传入中间函数。可以这么理解，在传入一个回调函数之前，中间函数是不完整的。换句话说，程序可以在运行时，通过登记不同的回调函数，来决定、改变中间函数的行为。这就比简单的函数调用要灵活太多了。</p><h2 id="什么是回调函数？"><a class="header-anchor" href="#什么是回调函数？"> </a>什么是回调函数？</h2><p>我们绕点远路来回答这个问题。<br>编程分为两类：系统编程（system programming）和应用编程（application programming）。所谓系统编程，简单来说，就是编写库；而应用编程就是利用写好的各种库来编写具某种功用的程序，也就是应用。系统程序员会给自己写的库留下一些接口，即API（application programming interface，应用编程接口），以供应用程序员使用。所以在抽象层的图示里，库位于应用的底下。<br>当程序跑起来时，一般情况下，应用程序（application program）会时常通过API调用库里所预先备好的函数。但是有些库函数（library function）却要求应用先传给它一个函数，好在合适的时候调用，以完成目标任务。这个被传入的、后又被调用的函数就称为回调函数（callback function）。<br>打个比方，有一家旅馆提供叫醒服务，但是要求旅客自己决定叫醒的方法。可以是打客房电话，也可以是派服务员去敲门，睡得死怕耽误事的，还可以要求往自己头上浇盆水。这里，“叫醒”这个行为是旅馆提供的，相当于库函数，但是叫醒的方式是由旅客决定并告诉旅馆的，也就是回调函数。而旅客告诉旅馆怎么叫醒自己的动作，也就是把回调函数传入库函数的动作，称为登记回调函数（to register a callback function）。如下图所示（图片来源：维基百科）：</p><p><img src="https://i.loli.net/2018/11/04/5bdeaff0d9711.png" alt="回调1.png"></p><p>可以看到，回调函数通常和应用处于同一抽象层（因为传入什么样的回调函数是在应用级别决定的）。而回调就成了一个高层调用底层，底层再回过头来调用高层的过程。（我认为）这应该是回调最早的应用之处，也是其得名如此的原因。<br>回调机制的优势<br>从上面的例子可以看出，回调机制提供了非常大的灵活性。请注意，从现在开始，我们把图中的库函数改称为中间函数了，这是因为回调并不仅仅用在应用和库之间。任何时候，只要想获得类似于上面情况的灵活性，都可以利用回调。<br>这种灵活性是怎么实现的呢？乍看起来，回调似乎只是函数间的调用，但仔细一琢磨，可以发现两者之间的一个关键的不同：在回调中，我们利用某种方式，把回调函数像参数一样传入中间函数。可以这么理解，在传入一个回调函数之前，中间函数是不完整的。换句话说，程序可以在运行时，通过登记不同的回调函数，来决定、改变中间函数的行为。这就比简单的函数调用要灵活太多了。请看下面这段Python写成的回调的简单示例：</p><p><code>even.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#回调函数1</span></span><br><span class="line"><span class="comment">#生成一个2k形式的偶数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">double</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#回调函数2</span></span><br><span class="line"><span class="comment">#生成一个4k形式的偶数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quadruple</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">4</span></span><br></pre></td></tr></table></figure><p><code>callback_demo.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> even <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#中间函数</span></span><br><span class="line"><span class="comment">#接受一个生成偶数的函数作为参数</span></span><br><span class="line"><span class="comment">#返回一个奇数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getOddNumber</span><span class="params">(k, getEvenNumber)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + getEvenNumber(k)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#起始函数，这里是程序的主函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span>    </span><br><span class="line">    k = <span class="number">1</span></span><br><span class="line">    <span class="comment">#当需要生成一个2k+1形式的奇数时</span></span><br><span class="line">    i = getOddNumber(k, double)</span><br><span class="line">    print(i)</span><br><span class="line">    <span class="comment">#当需要一个4k+1形式的奇数时</span></span><br><span class="line">    i = getOddNumber(k, quadruple)</span><br><span class="line">    print(i)</span><br><span class="line">    <span class="comment">#当需要一个8k+1形式的奇数时</span></span><br><span class="line">    i = getOddNumber(k, <span class="keyword">lambda</span> x: x * <span class="number">8</span>)</span><br><span class="line">    print(i)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>运行<code>callback_demp.py</code>，输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">5</span><br><span class="line">9</span><br></pre></td></tr></table></figure><p>上面的代码里，给<code>getOddNumber</code>传入不同的回调函数，它的表现也不同，这就是回调机制的优势所在。值得一提的是，上面的第三个回调函数是一个匿名函数。</p><blockquote><p>编程思想中有一条很重要的原则就是：<strong>尽量少的改动已有的代码</strong>，原因有很多，比如改动一个被多处使用的函数有可能会对很多地方造成影响。所以我们就要 <strong>尽量让我们的代码灵活起来，可重复用起来</strong>，Java的反射就起到了这个作用，Spring框架最重要的作用就是让灵活的部分变成配置，程序动态加载配置就能改变代码的行为。回调也同样是在贯彻这一思想。<strong>可重用</strong> 是编程思想的精髓之一，甚至所有的抽象就都是为了这一目的，无论是<code>变量</code>、<code>函数</code>、<code>对象</code>、<code>数据结构</code>、<code>库</code>、<code>API</code>都是把死的代码变成活的，把不能重复使用的代码变成可以重复使用的代码。<a href="#%E9%98%BF%E9%87%8C%E5%92%8C%E8%9A%82%E8%9A%81%E5%85%AB%E8%8D%A3%E5%85%AB%E8%80%BB">阿里和蚂蚁八荣八耻</a></p></blockquote><blockquote><p>其实面向对象的语言中传递回调函数并不是直接传函数，而是传对象，然后使用对象就可以引用到里面的回调方法了。</p></blockquote><h2 id="易被忽略的第三方"><a class="header-anchor" href="#易被忽略的第三方"> </a>易被忽略的第三方</h2><p>通过上面的论述可知，中间函数和回调函数是回调的两个必要部分，不过人们往往忽略了回调里的第三位要角，就是中间函数的调用者。绝大多数情况下，这个调用者可以和程序的主函数等同起来，但为了表示区别，我这里把它称为起始函数（如上面的代码中注释所示）。<br>之所以特意强调这个第三方，是因为我在网上读相关文章时得到一种印象，很多人把它简单地理解为两个个体之间的来回调用。譬如，很多中文网页在解释“回调”（callback）时，都会提到这么一句话：“If you call me, I will call you back.”我没有查到这句英文的出处。我个人揣测，很多人把起始函数和回调函数看作为一体，大概有两个原因：第一，可能是“回调”这一名字的误导；第二，给中间函数传入什么样的回调函数，是在起始函数里决定的。实际上，回调并不是“你我”两方的互动，而是ABC的三方联动。有了这个清楚的概念，在自己的代码里实现回调时才不容易混淆出错。<br>另外，回调实际上有两种：阻塞式回调和延迟式回调。两者的区别在于：阻塞式回调里，回调函数的调用一定发生在起始函数返回之前；而延迟式回调里，回调函数的调用有可能是在起始函数返回之后。这里不打算对这两个概念做更深入的讨论，之所以把它们提出来，也是为了说明强调起始函数的重要性。网上的很多文章，提到这两个概念时，只是笼统地说阻塞式回调发生在主调函数返回之前，却没有明确这个主调函数到底是起始函数还是中间函数，不免让人糊涂，所以这里特意说明一下。另外还请注意，本文中所举的示例均为阻塞式回调。延迟式回调通常牵扯到多线程。</p><h2 id="阿里和蚂蚁八荣八耻"><a class="header-anchor" href="#阿里和蚂蚁八荣八耻"> </a>阿里和蚂蚁八荣八耻</h2><p>以动手实践为荣，以只看不练为耻。</p><p>以打印日志为荣，以出错不报为耻。</p><p>以局部变量为荣，以全局变量为耻。</p><p>以单元测试为荣，以手工测试为耻。</p><p>以代码重用为荣，以复制粘贴为耻。</p><p>以多态应用为荣，以分支判断为耻。</p><p>以定义常量为荣，以魔法数字为耻。</p><p>以总结思考为荣，以不求甚解为耻。</p><p>以可配置为荣 ，以硬编码为耻</p><p>以可互备为荣 ，以单点为耻</p><p>以可无状态为荣 ，以有状态为耻</p><p>以可随便重启为荣 ，以不能迁移为耻</p><p>以整体交付为荣，以部分交付为耻</p><p>以标准化为荣，以特殊化为耻</p><p>以自动化运维为荣，以人肉化运维为耻</p><p>以无人值守为荣，以人工值班为耻</p>]]></content>
      
      <categories>
          
          <category> 编程概念 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>vim相关</title>
      <link href="/blog/2018/11/04/vim%E7%9B%B8%E5%85%B3/"/>
      <url>/blog/2018/11/04/vim%E7%9B%B8%E5%85%B3/</url>
      <content type="html"><![CDATA[<p>vim的配置文件位于：<code>~/.vimrc</code>，文件使用VimScript语法来编写。</p><p>.vimrc文件分为三个部分，分别是：</p><ul><li>Vundle插件管理部分</li><li>Vim编辑器配置部分</li><li>Vim插件配置部分</li></ul><h2 id="nerdtree的使用"><a class="header-anchor" href="#nerdtree的使用"> </a>NERDTree的使用</h2><h3 id="切换工作台和目录"><a class="header-anchor" href="#切换工作台和目录"> </a>切换工作台和目录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ctrl+w+h    光标focus左侧树形目录</span><br><span class="line">ctrl+w+l    光标focus右侧文件显示窗口</span><br><span class="line">ctrl+w+w    光标自动在左右侧窗口切换</span><br><span class="line">ctrl+w+r    移动当前窗口的布局位置</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">o   在已有窗口中打开文件、目录或书签，并跳到该窗口</span><br><span class="line">go  在已有窗口中打开文件、目录或书签，但不跳到该窗口</span><br><span class="line">t   在新Tab中打开选中文件/书签，并跳到新Tab</span><br><span class="line">T   在新Tab中打开选中文件/书签，但不跳到新Tab</span><br><span class="line">i   split一个新窗口打开选中文件，并跳到该窗口</span><br><span class="line">gi  split一个新窗口打开选中文件，但不跳到该窗口</span><br><span class="line">s   vsplit一个新窗口打开选中文件，并跳到该窗口</span><br><span class="line">gs  vsplit一个新窗口打开选中文件，但不跳到该窗口</span><br><span class="line">!   执行当前文件</span><br><span class="line">O   递归打开选中结点下的所有目录</span><br><span class="line">x   合拢选中结点的父目录</span><br><span class="line">X   递归合拢选中结点下的所有目录</span><br><span class="line">e   Edit the current dif</span><br><span class="line"></span><br><span class="line">D   删除当前书签</span><br><span class="line"></span><br><span class="line">P   跳到根节点</span><br><span class="line">p   跳到父节点</span><br><span class="line">K   跳到当前目录下同级的第一个结点</span><br><span class="line">J   跳到当前目录下同级的最后一个结点</span><br><span class="line">k   跳到当前目录下同级的前一个结点</span><br><span class="line">j   跳到当前目录下同级的后一个结点</span><br><span class="line"></span><br><span class="line">C   将选中目录或选中文件的父目录设为根节点</span><br><span class="line">u   将当前根节点的父目录设为根目录，并变成合拢原根节点</span><br><span class="line">U   将当前根节点的父目录设为根目录，但保持展开原根节点</span><br><span class="line">r   递归刷新选中目录</span><br><span class="line">R   递归刷新根节点</span><br><span class="line">m   显示文件系统菜单</span><br><span class="line">cd  将CWD设为选中目录</span><br><span class="line"></span><br><span class="line">I   切换是否显示隐藏文件</span><br><span class="line">f   切换是否使用文件过滤器</span><br><span class="line">F   切换是否显示文件</span><br><span class="line">B   切换是否显示书签</span><br><span class="line"></span><br><span class="line">q   关闭NerdTree窗口</span><br><span class="line">?  切换是否显示Quick help</span><br></pre></td></tr></table></figure><h3 id="切换标签页"><a class="header-anchor" href="#切换标签页"> </a>切换标签页</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">:tabnew [++opt选项] [+cmd]  文件    建立对指定文件新的tab</span><br><span class="line">:tabc   关闭当前的tab</span><br><span class="line">:tabo   关闭所有其他的tab</span><br><span class="line">:tabs   查看所有打开的tab</span><br><span class="line">:tabp   前一个tab</span><br><span class="line">:tabn   后一个tab</span><br><span class="line"></span><br><span class="line">标准模式下：</span><br><span class="line">gT  前一个tab</span><br><span class="line">gt  后一个tab</span><br><span class="line"></span><br><span class="line">MacVim还可以借助快捷键来完成tab的关闭、切换</span><br><span class="line">cmd+w   关闭当前的tab</span><br><span class="line">cmd+&#123;   前一个tab</span><br><span class="line">cmd+&#125;   后一个tab</span><br></pre></td></tr></table></figure><h3 id="nerdtree在-vimrc中的常用配置"><a class="header-anchor" href="#nerdtree在-vimrc中的常用配置"> </a>NerdTree在.vimrc中的常用配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&quot; 在 vim 启动的时候默认开启 NERDTree（autocmd 可以缩写为 au）</span><br><span class="line">autocmd VimEnter * NERDTree</span><br><span class="line"></span><br><span class="line">&quot; 按下 F2 调出/隐藏 NERDTree</span><br><span class="line">map  :silent! NERDTreeToggle</span><br><span class="line"></span><br><span class="line">&quot; 将 NERDTree 的窗口设置在 vim 窗口的右侧（默认为左侧）</span><br><span class="line">let NERDTreeWinPos=&quot;right&quot;</span><br><span class="line"></span><br><span class="line">&quot; 当打开 NERDTree 窗口时，自动显示 Bookmarks</span><br><span class="line">let NERDTreeShowBookmarks=1</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Unix </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unix </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>pom.xml详解</title>
      <link href="/blog/2018/11/04/pom.xml%E8%AF%A6%E8%A7%A3/"/>
      <url>/blog/2018/11/04/pom.xml%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>POM, Project Object Model，项目对象模型，是Maven的配置文件。</p><blockquote><p><a href="https://zh.wikipedia.org/zh-hans/XML" target="_blank" rel="noopener">什么是xml?</a></p></blockquote><a id="more"></a><h2 id="pom配置一览"><a class="header-anchor" href="#pom配置一览"> </a>POM配置一览</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag"> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">                     http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!-- The Basics --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>...<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>...<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">version</span>&gt;</span>...<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>...<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>...<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">parent</span>&gt;</span>...<span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span>...<span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">modules</span>&gt;</span>...<span class="tag">&lt;/<span class="name">modules</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">properties</span>&gt;</span>...<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!-- Build Settings --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">build</span>&gt;</span>...<span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">reporting</span>&gt;</span>...<span class="tag">&lt;/<span class="name">reporting</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!-- More Project Information --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">name</span>&gt;</span>...<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">description</span>&gt;</span>...<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">url</span>&gt;</span>...<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">inceptionYear</span>&gt;</span>...<span class="tag">&lt;/<span class="name">inceptionYear</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">licenses</span>&gt;</span>...<span class="tag">&lt;/<span class="name">licenses</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">organization</span>&gt;</span>...<span class="tag">&lt;/<span class="name">organization</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">developers</span>&gt;</span>...<span class="tag">&lt;/<span class="name">developers</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">contributors</span>&gt;</span>...<span class="tag">&lt;/<span class="name">contributors</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">&lt;!-- Environment Settings --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">issueManagement</span>&gt;</span>...<span class="tag">&lt;/<span class="name">issueManagement</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">ciManagement</span>&gt;</span>...<span class="tag">&lt;/<span class="name">ciManagement</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">mailingLists</span>&gt;</span>...<span class="tag">&lt;/<span class="name">mailingLists</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">scm</span>&gt;</span>...<span class="tag">&lt;/<span class="name">scm</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">prerequisites</span>&gt;</span>...<span class="tag">&lt;/<span class="name">prerequisites</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">repositories</span>&gt;</span>...<span class="tag">&lt;/<span class="name">repositories</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">pluginRepositories</span>&gt;</span>...<span class="tag">&lt;/<span class="name">pluginRepositories</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">distributionManagement</span>&gt;</span>...<span class="tag">&lt;/<span class="name">distributionManagement</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">profiles</span>&gt;</span>...<span class="tag">&lt;/<span class="name">profiles</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>官方参考：<a href="http://maven.apache.org/ref/3.6.0/maven-model/maven.html" target="_blank" rel="noopener">Maven Model</a></p><p>实际例子中的 <a href="../../../../assets/2018/pom.xml">pom.xml</a></p><h2 id="基本配置"><a class="header-anchor" href="#基本配置"> </a>基本配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">                      http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.mojo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>my-project<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>project：pom.xml中描述符的根</li><li>xmlns：xml namespace，和C++的命名空间一样，肯定都是用来<a href="#xml%E5%91%BD%E5%90%8D%E5%86%B2%E7%AA%81%E7%9A%84%E4%BE%8B%E5%AD%90">解决命名冲突</a>的</li><li>modelVersion：指定pom.xml符合哪个版本。maven2和3只能为4.0.0</li></ul><p>在Maven中，根据<code>groupId</code>、<code>artifactId</code>、<code>version</code>组合成<code>groupId:artifactId:version</code>来唯一标识一个jar包：</p><ul><li><strong>groupId</strong>: 团体、组织的标识符。它以创建这个项目的组织的逆向域名（reverse domain name）开头。</li><li><strong>artifactId</strong>: 单独项目的唯一标识符，比如tomcat。<strong>不要在artifactId中包含<code>.</code>（点号）</strong>。</li><li><strong>version</strong>: 一个项目的特定版本。<a href="#maven%E7%89%88%E6%9C%AC%E8%A7%84%E8%8C%83">版本相关的小知识</a></li><li><strong>packaging</strong>: 项目的类型，描述了项目打包后的输出，默认是jar。常见的输出类型有：pom, jar, maven-plugin, ejb, war, ear, rar, par</li></ul><h2 id="dependencies"><a class="header-anchor" href="#dependencies"> </a>dependencies</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0</span></span></span><br><span class="line"><span class="tag"><span class="string">                      https://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-embedder<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">type</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>groupId, artifactId, version</strong>：和基本配置中的 <code>groupId</code>、<code>artifactId</code>、<code>version</code> 意义相同。</li><li><strong>type</strong>：对应 <code>packaging</code> 的类型，如果不使用 <code>type</code> 标签，maven 默认为 jar。</li><li><strong>scope</strong>：此元素指的是任务的类路径（编译和运行时，测试等）以及如何限制依赖关系的传递性。有 5 种可用的限定范围：<ul><li><strong>compile</strong> - 如果没有指定 scope 标签，maven 默认为这个范围。编译依赖关系在所有 classpath 中都可用。此外，这些依赖关系被传播到依赖项目。</li><li><strong>provided</strong> - 与 compile 类似，但是表示您希望 jdk 或容器在运行时提供它。它只适用于编译和测试 classpath，不可传递。</li><li><strong>runtime</strong> - 此范围表示编译不需要依赖关系，而是用于执行。它是在运行时和测试 classpath，但不是编译 classpath。</li><li><strong>test</strong> - 此范围表示正常使用应用程序不需要依赖关系，仅适用于测试编译和执行阶段。它不是传递的。</li><li><strong>system</strong> - 此范围与 provided 类似，除了您必须提供明确包含它的 jar。该 artifact 始终可用，并且不是在仓库中查找。</li></ul></li><li><strong>systemPath</strong>：仅当依赖范围是系统时才使用。否则，如果设置此元素，构建将失败。该路径必须是绝对路径，因此建议使用 propertie 来指定特定的路径，如$ {java.home} / lib。由于假定先前安装了系统范围依赖关系，maven 将不会检查项目的仓库，而是检查库文件是否存在。如果没有，maven 将会失败，并建议您手动下载安装。</li><li><strong>optional</strong>：optional 让其他项目知道，当您使用此项目时，您不需要这种依赖性也能正常工作。</li><li><strong>exclusions</strong>：包含一个或多个排除元素，每个排除元素都包含一个表示要排除的依赖关系的 groupId 和 artifactId。与可选项不同，可能或可能不会安装和使用，排除主动从依赖关系树中删除自己。</li></ul><h2 id="build"><a class="header-anchor" href="#build"> </a>build</h2><p><a href="https://maven.apache.org/pom.html#Build_Settings" target="_blank" rel="noopener">官方文档</a></p><p>build用于声明项目目录结构和管理插件。</p><p>build元素从概念上被分为两部分：</p><ul><li>BasicBuild</li><li>Build</li></ul><p>BasicBuild是Build的子集。</p><p>build标签也分为两种：</p><ol><li>根标签<code>&lt;project&gt;</code>下的<code>build</code>标签（称为profile build）该配置可以被<code>profile</code>全部继承</li><li><code>profile</code>标签中的<code>build</code>标签（称为profile build），用于重写覆盖掉 project build 中的配置，是project build的子集。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span>    </span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>    </span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0    </span></span></span><br><span class="line"><span class="tag"><span class="string">                      http://maven.apache.org/maven-v4_0_0.xsd"</span>&gt;</span>    </span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">!–-</span> "<span class="attr">Project</span> <span class="attr">Build</span>" 除了包含 <span class="attr">BaseBuild</span> 集合外，还包含其它构建元素 <span class="attr">-</span>–&gt;</span>   </span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span>…<span class="tag">&lt;/<span class="name">build</span>&gt;</span>    </span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">!–-</span> "<span class="attr">Profile</span> <span class="attr">Build</span>" 是 "<span class="attr">Project</span> <span class="attr">Build</span>"<span class="attr">s</span> 的子集 <span class="attr">-</span>–&gt;</span>   </span><br><span class="line">  <span class="tag">&lt;<span class="name">profiles</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">profile</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="name">build</span>&gt;</span>…<span class="tag">&lt;/<span class="name">build</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">profile</span>&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;/<span class="name">profiles</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="配置说明"><a class="header-anchor" href="#配置说明"> </a>配置说明</h3><h4 id="基本元素：basebuild"><a class="header-anchor" href="#基本元素：basebuild"> </a>基本元素：BaseBuild</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">defaultGoal</span>&gt;</span>install<span class="tag">&lt;/<span class="name">defaultGoal</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;basedir&#125;/target<span class="tag">&lt;/<span class="name">directory</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>$&#123;artifactId&#125;-$&#123;version&#125;<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">filters</span>&gt;</span>    </span><br><span class="line">                <span class="tag">&lt;<span class="name">filter</span>&gt;</span>filters/filter1.properties<span class="tag">&lt;/<span class="name">filter</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;/<span class="name">filters</span>&gt;</span>    </span><br><span class="line">         ...    </span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><strong>defaultGoal:</strong> 执行mvn命令时，如果没有指定目标，指定使用的默认目标。如上配置：在命令行中执行mvn，则相当于执行：<code>mvn install</code></li><li><strong>directory:</strong> 目标文件的存放目录，默认在<code>${basedir}/target</code>目录</li><li><strong>finalName:</strong> 目标文件的名称，默认情况为<code>${artifactId}-${version}</code></li><li><strong>filter:</strong> 定义<code>*.properties</code>文件，包含一个properties列表，该列表会应用到支持filter的resources中。也就是说，定义在 filter 的文件中的 name = value 键值对，会在build时代替 ${name} 值应用到 resources 中。maven的默认filter文件夹为 ${basedir}/src/main/filters。</li></ol><h4 id="resource-配置"><a class="header-anchor" href="#resource-配置"> </a>Resource 配置</h4><p>用于包含或排除某些资源文件。<br>说明：资源通常不是源代码（也可以是），它们一般不被编译，例如：.xml文件，.properties文件等。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span>    </span><br><span class="line">   ...    </span><br><span class="line">   <span class="tag">&lt;<span class="name">resources</span>&gt;</span>    </span><br><span class="line">       <span class="tag">&lt;<span class="name">resource</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>META-INF/plexus<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;basedir&#125;/src/main/plexus<span class="tag">&lt;/<span class="name">directory</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;<span class="name">includes</span>&gt;</span>    </span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>configuration.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;/<span class="name">includes</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;<span class="name">excludes</span>&gt;</span>    </span><br><span class="line">                <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span>    </span><br><span class="line">       <span class="tag">&lt;/<span class="name">resource</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">resources</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">testResources</span>&gt;</span>    </span><br><span class="line">        ...    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">testResources</span>&gt;</span>    </span><br><span class="line">    ...    </span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><strong>resources:</strong> 一个resource元素的列表。每一个都描述与项目关联的文件是什么和在哪里</li><li><strong>targetPath:</strong> 指定build后的resource存放的文件夹，默认是basedir。通常被打包在jar中的resources的目标路径是META-INF</li><li><strong>filtering:</strong> true/false，表示为这个resource，filter是否激活。</li><li><strong>directory:</strong> 定义resources文件所在的文件夹，默认为：<code>${basedir}/src/main/resources</code></li><li><strong>includes:</strong> 指定哪些文件将被匹配，以*作为通配符</li><li><strong>excludes:</strong> 指定哪些文件将被忽略</li><li><strong>testResources:</strong> 定义和resources类似，只不过在test时使用</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span>  </span><br><span class="line">   <span class="comment">&lt;!--   </span></span><br><span class="line"><span class="comment">     | 有几个路径，就对应几个 resource 标签   </span></span><br><span class="line"><span class="comment">     | 或：  </span></span><br><span class="line"><span class="comment">     | 一个目录，对应一个 resource 标签  </span></span><br><span class="line"><span class="comment">   --&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">resource</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">directory</span>&gt;</span>  </span><br><span class="line">           $&#123;basedir&#125;/src/main/content/META-INF  </span><br><span class="line">       <span class="tag">&lt;/<span class="name">directory</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>../vault-work/META-INF<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>true<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;/<span class="name">resource</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;<span class="name">resource</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">directory</span>&gt;</span>  </span><br><span class="line">           $&#123;basedir&#125;/src/main/content/jcr_root  </span><br><span class="line">       <span class="tag">&lt;/<span class="name">directory</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">excludes</span>&gt;</span>  </span><br><span class="line">           <span class="comment">&lt;!-- 用法1：不包括一整个目录--&gt;</span>  </span><br><span class="line">           <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>apps/ui/**<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span>    </span><br><span class="line">  </span><br><span class="line">           <span class="comment">&lt;!-- 用法2：不包括某类文件（所有路径下）--&gt;</span>    </span><br><span class="line">           <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/*.jpg<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span>  </span><br><span class="line">  </span><br><span class="line">           <span class="comment">&lt;!-- 用法3：不包括某个文件（所有路径下）--&gt;</span>  </span><br><span class="line">           <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/.DS_Store<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>.<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span>  </span><br><span class="line">       <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span>  </span><br><span class="line">   <span class="tag">&lt;/<span class="name">resource</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="plugins"><a class="header-anchor" href="#plugins"> </a>plugins</h4><p>用于指定使用的插件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span>    </span><br><span class="line">    ...    </span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;<span class="name">extensions</span>&gt;</span>false<span class="tag">&lt;/<span class="name">extensions</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;<span class="name">inherited</span>&gt;</span>true<span class="tag">&lt;/<span class="name">inherited</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span>    </span><br><span class="line">                <span class="tag">&lt;<span class="name">classifier</span>&gt;</span>test<span class="tag">&lt;/<span class="name">classifier</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span>...<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span>...<span class="tag">&lt;/<span class="name">executions</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>GAV(groupId, artifactId, version)，指定插件的标准坐标</li><li>extensions是否加载plugin的extensions，默认为false</li><li>inherited： true/false，这个plugin是否应用到该pom的孩子pom，默认为true</li><li>configuration配置该plugin期望得到的properties</li><li>dependencies作为plugin的依赖</li><li>executionsplugin可以有多个目标，每一个目标都可以有一个分开的配置，可以将一个plugin绑定到不同的阶段假如绑定antrun：run目标到verify阶段</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-antrun-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span>    </span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span>    </span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>echodir<span class="tag">&lt;/<span class="name">id</span>&gt;</span>    </span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span>    </span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>run<span class="tag">&lt;/<span class="name">goal</span>&gt;</span>    </span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span>    </span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>verify<span class="tag">&lt;/<span class="name">phase</span>&gt;</span>    </span><br><span class="line">                    <span class="tag">&lt;<span class="name">inherited</span>&gt;</span>false<span class="tag">&lt;/<span class="name">inherited</span>&gt;</span>    </span><br><span class="line">                    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span>    </span><br><span class="line">                        <span class="tag">&lt;<span class="name">tasks</span>&gt;</span>    </span><br><span class="line">                            <span class="tag">&lt;<span class="name">echo</span>&gt;</span>Build Dir: $&#123;project.build.directory&#125;<span class="tag">&lt;/<span class="name">echo</span>&gt;</span>    </span><br><span class="line">                        <span class="tag">&lt;/<span class="name">tasks</span>&gt;</span>    </span><br><span class="line">                    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span>    </span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>id：标识，用于和其他 execution 区分。当这个阶段执行时，它将以这个形式展示[plugin:goal execution:id]。举例：在这里为： [antrun:run execution:echodir]</li><li>goals：目标列表</li><li>phase：目标执行的阶段</li><li>inherit：子类pom是否继承</li><li>configuration：在指定目标下的配置</li></ul><h4 id="pluginmanagement"><a class="header-anchor" href="#pluginmanagement"> </a>pluginManagement</h4><p>pluginManagement的配置和plugins的配置是一样的，只是用于继承，使得可以在孩子pom中使用。父pom：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span>    </span><br><span class="line">    ...    </span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>    </span><br><span class="line">              <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    </span><br><span class="line">              <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    </span><br><span class="line">              <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span>    </span><br><span class="line">                <span class="tag">&lt;<span class="name">executions</span>&gt;</span>    </span><br><span class="line">                    <span class="tag">&lt;<span class="name">execution</span>&gt;</span>    </span><br><span class="line">                        <span class="tag">&lt;<span class="name">id</span>&gt;</span>pre-process-classes<span class="tag">&lt;/<span class="name">id</span>&gt;</span>    </span><br><span class="line">                        <span class="tag">&lt;<span class="name">phase</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">phase</span>&gt;</span>    </span><br><span class="line">                        <span class="tag">&lt;<span class="name">goals</span>&gt;</span>    </span><br><span class="line">                            <span class="tag">&lt;<span class="name">goal</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">goal</span>&gt;</span>    </span><br><span class="line">                        <span class="tag">&lt;/<span class="name">goals</span>&gt;</span>    </span><br><span class="line">                        <span class="tag">&lt;<span class="name">configuration</span>&gt;</span>    </span><br><span class="line">                            <span class="tag">&lt;<span class="name">classifier</span>&gt;</span>pre-process<span class="tag">&lt;/<span class="name">classifier</span>&gt;</span>    </span><br><span class="line">                        <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span>    </span><br><span class="line">                    <span class="tag">&lt;/<span class="name">execution</span>&gt;</span>    </span><br><span class="line">                <span class="tag">&lt;/<span class="name">executions</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span>    </span><br><span class="line">    ...    </span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>则在子pom中，我们只需要配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span>    </span><br><span class="line">    ...    </span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span>    </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-jar-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span>    </span><br><span class="line">    ...    </span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样就大大简化了孩子pom的配置</p><h2 id="xml命名冲突的例子"><a class="header-anchor" href="#xml命名冲突的例子"> </a>xml命名冲突的例子</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">td</span>&gt;</span>Apples<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">td</span>&gt;</span>Bananas<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">name</span>&gt;</span>African Coffee Table<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">width</span>&gt;</span>80<span class="tag">&lt;/<span class="name">width</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">length</span>&gt;</span>120<span class="tag">&lt;/<span class="name">length</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这两个xml文档片段如果一起使用的话，会冲突，因为都包含了<code>&lt;table&gt;</code>元素，而这两个table元素的定义与所包含的内容又各不相同。解决冲突的办法就是使用xmlns。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h:table</span> <span class="attr">xmlns:h</span>=<span class="string">"http://www.w3.org/TR/html4/"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">h:tr</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">h:td</span>&gt;</span>Apples<span class="tag">&lt;/<span class="name">h:td</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">h:td</span>&gt;</span>Bananas<span class="tag">&lt;/<span class="name">h:td</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">h:tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">h:table</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">f:table</span> <span class="attr">xmlns:f</span>=<span class="string">"http://www.w3schools.com/furniture"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">f:name</span>&gt;</span>African Coffee Table<span class="tag">&lt;/<span class="name">f:name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">f:width</span>&gt;</span>80<span class="tag">&lt;/<span class="name">f:width</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">f:length</span>&gt;</span>120<span class="tag">&lt;/<span class="name">f:length</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">f:table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可以使用默认命名空间</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3.org/TR/html4/"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">td</span>&gt;</span>Apples<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">td</span>&gt;</span>Bananas<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">xmlns</span>=<span class="string">"http://www.w3schools.com/furniture"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">name</span>&gt;</span>African Coffee Table<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">width</span>&gt;</span>80<span class="tag">&lt;/<span class="name">width</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">length</span>&gt;</span>120<span class="tag">&lt;/<span class="name">length</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>默认命名空间没有名字，无法被再次直接引用。</p></blockquote><h2 id="maven版本规范"><a class="header-anchor" href="#maven版本规范"> </a>Maven版本规范</h2><p>maven有自己的版本规范，一般是如下定义:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">major version.minor version.incremental version-qualifier</span><br></pre></td></tr></table></figure><p>比如 <code>1.2.3-beta-01</code>。要说明的是，maven自己判断版本的算法是<code>major</code>、<code>minor</code>、<code>incremental</code>部分用数字比较，<code>qualifier</code>部分用字符串比较，所以要小心形如<code>alpha-2</code>和<code>alpha-15</code>的比较关系，最好用<code>alpha-02</code>的格式。<br>maven在版本管理的时候可以使用几个特殊的字符串<code>SNAPSHOT</code>、<code>LATEST</code>、<code>RELEASE</code>。比如<code>1.0-SNAPSHOT</code>。</p><ul><li><strong>SNAPSHOT</strong>：这个版本一般用于开发过程中，表示不稳定的版本。</li><li><strong>LATEST</strong>：指定某个特定构件的最新发布，这个发布可能是一个RELEASE版，也可能是一个SNAPSHOT版，具体看哪个时间最后。</li><li><strong>RELEASE</strong>：指最后一个发布版。</li></ul>]]></content>
      
      <categories>
          
          <category> Java </category>
          
          <category> Java web </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>git 使用技巧</title>
      <link href="/blog/2018/11/04/git%20%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/blog/2018/11/04/git%20%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      <content type="html"><![CDATA[<h2 id="git-建立远程项目"><a class="header-anchor" href="#git-建立远程项目"> </a>git 建立远程项目</h2><p>git 是多人写作的版本控制系统，而我却把它用成了单人版本控制系统，真是罪过罪过。上一次用多人 git 的时候，连添加远端库的步骤都没弄清。其实很简单，你在本地做了一个项目之后，远端的项目还没捡起来，或者才新建的一个空的远端项目，这个时候你特别想把本地项目和远端项目关联起来，你想起了 git remote add，但是不是这么操作的。</p><p>具体的操作如下：<br>首先，通过上传 你的公钥给 git 服务器，获得 git 服务器对你本机的认证，这样你用 git 命令就不用每次都输入用户名和密码了。然后就是 git clone 远端项目，即便它是空的，也请你先 clone，然后把你本地的东西复制粘贴到 clone 下来的目录里，并使用 git add . 和 git commit -m “first commit” 提交。然后 git push origin master 。你会发现根本就不需要 git remote add 一个主机，因为 git clone 的时候就把远端给关联好了。使用 git remote -v 查看远端服务器的信息吧。</p><blockquote><p>其实如果原项目太大复制很慢的话，复制<code>.git</code>文件夹到原项目，这样更快（只要把本地项目和远端拉下来的空项目的<code>.git</code>文件放到一起就行了）。</p></blockquote><p>远端名字改了，本地怎么修改 remote 信息：<br><code>git remote set-url origin git@github.com:username/newrepo.git</code><br>修改远程仓库对应的网址.<br>然后：<br><code>git remote -v</code><br>列出所有远程仓库信息, 包括网址.<br>看看是否修改成功吧</p><h2 id="github页面修改仓库信息"><a class="header-anchor" href="#github页面修改仓库信息"> </a>Github页面修改仓库信息</h2><p>跑到自己的仓库那,找到Setting的tag, 点进去后Options的Settings就可以设定Repository name.</p>]]></content>
      
      <categories>
          
          <category> 工具 </category>
          
          <category> git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux 服务器运维</title>
      <link href="/blog/2018/11/04/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E7%BB%B4/"/>
      <url>/blog/2018/11/04/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BF%90%E7%BB%B4/</url>
      <content type="html"><![CDATA[<h2 id="添加用户"><a class="header-anchor" href="#添加用户"> </a>添加用户</h2><p>添加用户：<code>useradd xxx</code><br>密码：<code>passwd xxx</code><br>添加用户进 sudoers<br>修改 <code>/etc/sudoers</code> 文件，首先改权限：<code>sudo chmod u+w /etc/sudoers</code>，然后再用 <code>vi /etc/sudoers</code>。<br>理解这个表达式的意义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALL ALL=(ALL) ALL</span><br></pre></td></tr></table></figure><p>The first ALL is the users allowed<br>The second one is the hosts<br>The third one is the user as you are running the command<br>The last one is the commands allowed</p><p>在文本中 root ALL=(ALL) ALL 后面一行加：xxx ALL=(ALL) ALL</p><p>把用户加进组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd -G &#123;group-name&#125; username</span><br><span class="line">usermod -a -G &#123;group-name&#125; username</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Unix </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unix </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux 入门教程</title>
      <link href="/blog/2018/11/04/Linux%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
      <url>/blog/2018/11/04/Linux%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>这是我亲自写的一份教程（没有参考任何其他人），我认为的最合适的入门应该学些什么，请耐心阅读吧。</p><p>概念：目录，路径，相对路径，绝对路径，文件系统，文件，环境变量</p><p>cd（change directory）后接目录，如：<br><code>cd /opt</code> 或者 <code>cd /opt/</code>都行，直接用cd则切换到你的用户目录，Linux下的用户目录如：/home/liuqinh2s/，mac下的用户目录：/Users/liuqinh2s。使用pwd（print working directory）可以查看当前所在的目录。如果你想回到上次所处的目录，使用<code>cd -</code>。<br>你要运行任何程序，首先得知道程序文件所在的位置（目录），然后去读取文件进内存，然后CPU读内存执行程序。怎么让操作系统明确程序所在的目录，有个叫做PATH的环境变量，操作系统会拿你输入的程序名字（或者一个路径）去环境变量中的那些目录下查找，如果找到就运行，找不到则报告错误给你。也就是说如果你添加了环境变量就可以直接用程序名称运行程序而不用在填写它所在的目录，否则一律要使用路径+程序名称来指定位置。<br><code>cd ..</code> 到上层目录，<code>cd ../..</code>到上上层目录。<code>cd ~/.vim</code>，~表示你的用户目录，如：/Users/liuqinh2s。<br>ls（list），使用<code>ls -al</code>查看当前目录下所有的文件，a=all，l=long，你会发现，头两个文件总是<code>.</code>和<code>..</code>，<code>.</code>代表当前目录，<code>..</code>代表上层目录。假如你用<code>vim .</code>来编辑<code>.</code>文件，在你输入:wq保存的时候，会提示你<code>&quot;.&quot; is a directory</code>。同理<code>vim ..</code>也不行。那么根目录有没有上层目录呢，使用ls命令发现有<code>..</code>，但<code>..</code>和<code>.</code>一样都指向根目录自己（所以才叫根目录啊）。<br>像<code>.vim</code>这种以<code>.</code>开头的文件都是隐藏文件或者隐藏目录。直接使用ls不会显示隐藏的文件和目录。配置文件一般都使用<code>.</code>开头，避免被看见，哈哈。<br>新建目录：mkdir（make directory）<br>新建文件：touch<br>删除：rm（remove）<br>拷贝：cp（copy）<br>移动：mv（move）<br>命令行有文件名自动补全功能，记得常按TAB键哦。</p>]]></content>
      
      <categories>
          
          <category> Unix </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unix </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux Shell 编程</title>
      <link href="/blog/2018/11/04/Linux%20Shell%20%E7%BC%96%E7%A8%8B/"/>
      <url>/blog/2018/11/04/Linux%20Shell%20%E7%BC%96%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h2 id="shell脚本学习笔记规范"><a class="header-anchor" href="#shell脚本学习笔记规范"> </a>Shell脚本学习笔记规范</h2><ol><li>在书写Shell命令的时候，我没有加命令提示符。比如zsh的提示符：<code>➜ myshell</code>，或者bash的提示符：<code>bash-3.2$</code>。因为往往很多读者，直接把命令提示符(promt)也作为命令的一部分直接复制粘贴输入到命令行中了。所以新手读者需要注意这一点，以及知道什么是命令提示符。不过在演示命令和命令的输出的时候，我不会省略命令提示符，因为演示过程中，最好把你所看到的，全部展示给读者看。</li></ol><p>例子：</p><p>不带命令提示符的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash &lt; test.sh</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x test.sh</span><br><span class="line">./test.sh</span><br></pre></td></tr></table></figure><p>带命令提示符的演示过程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ i=0;</span><br><span class="line">➜  ~ ((i++))</span><br><span class="line">➜  ~ echo $i</span><br><span class="line">1</span><br><span class="line">➜  ~ let i++</span><br><span class="line">➜  ~ echo $i</span><br><span class="line">2</span><br><span class="line">➜  ~ expr $i + 1</span><br><span class="line">3</span><br><span class="line">➜  ~ expr $i+1</span><br><span class="line">2+1</span><br><span class="line">➜  ~ echo $i</span><br><span class="line">2</span><br><span class="line">➜  ~ echo $i 1 | awk &apos;&#123;printf $1+$2&#125;&apos;</span><br><span class="line">3%</span><br></pre></td></tr></table></figure><blockquote><p>~是home目录，➜  ~ 是命令提示符，~ 是命令提示符的一部分</p></blockquote><ol start="2"><li>每一个Shell命令，都占一行，所以当你复制粘贴多行命令的时候，你会发现除了最后一行命令，前面的命令都自动执行了。这是因为你把换行符也复制粘贴上去了，这和你手敲换行是一样的原理。所以新手们需要注意到换行符虽然是隐藏的，但是实际存在的。其实你复制没复制到换行符，是可以看到的。</li></ol><p>例子：</p><img src="https://i.loli.net/2018/09/12/5b987ca9be6eb.png" width="200px" align="center"><p>可以看到，第一行是复制了换行符的，第二行则是没有复制换行符。也就是说如果你复制了换行符，蓝色阴影就会覆盖命令后面的空间。很多编辑器（比如atom）可以设置空白符可见，常见的空白符有：空格(space)，制表符(TAB、\t)，换行(\n)，回车(\r)，垂直制表符(\v)。开启这些空白符可见可以培养一下这方面的意识。但会让文本显得杂乱。意识到这些字符的存在即可。</p><h2 id="执行shell脚本的方式"><a class="header-anchor" href="#执行shell脚本的方式"> </a>执行Shell脚本的方式</h2><h3 id="范例1：输入重定向到bash"><a class="header-anchor" href="#范例1：输入重定向到bash"> </a>范例1：输入重定向到bash</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash &lt; test.sh</span><br></pre></td></tr></table></figure><p>可以读入<code>test.sh</code>中的程序，并执行。</p><h3 id="范例2：以脚本名作为参数"><a class="header-anchor" href="#范例2：以脚本名作为参数"> </a>范例2：以脚本名作为参数</h3><p>其一般形式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash 脚本名 [参数]</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash test.sh /usr/bin</span><br></pre></td></tr></table></figure><p>其执行过程与范例1一样，但这种方式的好处是能在脚本名后面带有参数，从而将参数值传递给程序中的命令，使一个Shell脚本可以处理多种情况，就如同函数调用时可以根据具体问题传递相应参数。这个例子中，参数是：<code>/usr/bin</code>。</p><h3 id="范例3：以-来执行"><a class="header-anchor" href="#范例3：以-来执行"> </a>范例3：以 . 来执行</h3><p>如果以当前Shell（以<code>.</code>表示）执行一个Shell脚本，则可以使用如下简便形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">. test.sh [参数]</span><br></pre></td></tr></table></figure><h3 id="范例4：直接执行"><a class="header-anchor" href="#范例4：直接执行"> </a>范例4：直接执行</h3><p>将Shell脚本的权限设置为可执行，然后在提示符下直接执行它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x test.sh</span><br><span class="line">./test.sh</span><br></pre></td></tr></table></figure><p>这个要求在Shell脚本开头指明执行该脚本的具体Shell，例如<code>/bin/bash</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br></pre></td></tr></table></figure><h2 id="正确使用source和"><a class="header-anchor" href="#正确使用source和"> </a>正确使用<code>source</code>和<code>.</code></h2><p>仅使用<code>source</code>和<code>.</code>来执行你的环境配置等功能，建议不要用于其他用途。在Shell中使用脚本时，使用<code>bash your_script.sh</code>而不是<code>source your_script.sh</code>或<code>. your_script.sh</code>。</p><p>当使用<code>bash</code>的时候，当前Shell会创建一个新的子进程来执行你的脚本；当使用<code>source</code>和<code>.</code>时，当前的Shell会直接执行<code>your_script.sh</code>中的代码。如果<code>your_script.sh</code>中包含了类似<code>exit 0</code>这样的代码，使用<code>source</code>和<code>.</code>执行会导致当前Shell意外退出。</p><h2 id="shell的执行原理"><a class="header-anchor" href="#shell的执行原理"> </a>Shell的执行原理</h2><p>Shell接收用户输入的命令（脚本名），并进行分析。如果文件被标记为可执行，但不是被编译过的程序，Shell就认为它是一个Shell脚本。Shell将读取其中的内容，并加以解释执行。所以从用户的角度看，执行Shell脚本的方式与执行一般可执行文件的方式一样。</p><p>因此，用户开发的Shell脚本可以驻留在命令搜索路径的目录之下（通常是<code>/bin</code>、<code>/usr/bin</code>），像普通命令一样使用。这样也就开发出自己的新命令。如果打算反复使用编好的Shell脚本，那么采用这种方式比较方便。</p><h2 id="变量赋值"><a class="header-anchor" href="#变量赋值"> </a>变量赋值</h2><p>可以将一个命令的执行结果赋值给变量。有两种形式的命令替换：</p><h3 id="范例：获取当前工作目录并存放到变量中"><a class="header-anchor" href="#范例：获取当前工作目录并存放到变量中"> </a>范例：获取当前工作目录并存放到变量中</h3><p>例如：将当前工作目录的全路径名存放到变量dir中，输入以下命令行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir=`pwd`</span><br></pre></td></tr></table></figure><p>另一种形式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir=$(pwd)</span><br></pre></td></tr></table></figure><h2 id="数组"><a class="header-anchor" href="#数组"> </a>数组</h2><p><code>Bash</code>只提供一维数组，并没有限定数组的大小。类似于C语言，数组元素的下标由0开始编号。获取数组中的元素要利用下标。下标可以是整数或算术表达式，其值应大于或等于0。用户可以使用赋值语句对数组变量赋值。</p><h3 id="范例：对数组元素赋值"><a class="header-anchor" href="#范例：对数组元素赋值"> </a>范例：对数组元素赋值</h3><p>对数组元素赋值的一般形式是：<code>数组名[下标值]=值</code>，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">city[0]=Beijing</span><br><span class="line">city[1]=Shanghai</span><br><span class="line">city[2]=Tianjin</span><br></pre></td></tr></table></figure><p>也可以用<code>declare</code>命令显示声明一个数组，一般形式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare -a 数组名</span><br></pre></td></tr></table></figure><h3 id="范例：访问某个数组元素"><a class="header-anchor" href="#范例：访问某个数组元素"> </a>范例：访问某个数组元素</h3><p>读取数组元素值的一般形式是：<code>${数组名[下标]}</code>，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash-3.2$ echo $&#123;city[0]&#125;</span><br><span class="line">Beijing</span><br></pre></td></tr></table></figure><h3 id="范例：数组组合赋值"><a class="header-anchor" href="#范例：数组组合赋值"> </a>范例：数组组合赋值</h3><p>一个数组的各个元素可以利用上述方式一个元素一个元素地赋值，也可以组合赋值。定义一个数组并为其赋初值的一般形式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名=(值1 值2 ... 值n)</span><br></pre></td></tr></table></figure><p>其中，各个值之间以空格分开。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bash-3.2$ A=(this is an example of shell script)</span><br><span class="line">bash-3.2$ echo $&#123;A[0]&#125; $&#123;A[1]&#125;</span><br><span class="line">this is</span><br><span class="line">bash-3.2$ echo $&#123;A[8]&#125;</span><br></pre></td></tr></table></figure><p>由于表中初值共有7个，所以<code>A</code>的元素个数也是7。<code>A[8]</code>超出了已赋值的数组<code>A</code>的范围，就认为它是一个新元素，由于预先没有赋值，所以它的值是空串。</p><p>若没有给出数组元素的下标，则数组名表示下标为0的数组元素，如<code>city</code>就等价于<code>city[0]</code>。</p><h3 id="范例：列出数组中所有内容"><a class="header-anchor" href="#范例：列出数组中所有内容"> </a>范例：列出数组中所有内容</h3><p>使用<code>*</code>或<code>@</code>做下标，则会以数组中所有元素取代。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo $&#123;A[*]&#125;</span><br><span class="line">echo $&#123;A[@]&#125;</span><br></pre></td></tr></table></figure><h3 id="范例：获取数组元素个数"><a class="header-anchor" href="#范例：获取数组元素个数"> </a>范例：获取数组元素个数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash-3.2$ echo $&#123;#A[@]&#125;</span><br><span class="line">7</span><br></pre></td></tr></table></figure><h2 id="参数传递"><a class="header-anchor" href="#参数传递"> </a>参数传递</h2><p>假如要编写一个Shell脚本来求解两个数的和，可以怎么实现呢？为了介绍参数传递的用法，编写这样一个脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash-3.2$ cat &gt; add</span><br><span class="line">let sum=$1+$2</span><br><span class="line">echo $sum</span><br></pre></td></tr></table></figure><p>按ctrl+d保存，执行一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bash-3.2$ chmod a+x add</span><br><span class="line">bash-3.2$ ./add 5 10</span><br><span class="line">15</span><br></pre></td></tr></table></figure><p>可以看到5和10分别传给了<code>$1</code>和<code>$2</code>，这是Shell自己预设的参数顺序，其实也可以先定义好变量，然后传递进去。</p><p>例如，修改上述脚本得到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let sum=$X+$Y</span><br><span class="line">echo $sum</span><br></pre></td></tr></table></figure><p>再次执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash-3.2$ X=5 Y=10 ./add</span><br><span class="line">15</span><br></pre></td></tr></table></figure><p>参数要放在执行命令的前面。</p><h2 id="设置环境变量"><a class="header-anchor" href="#设置环境变量"> </a>设置环境变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export opid=True</span><br></pre></td></tr></table></figure><p>这样子就可以，如果要登录以后都生效，可以直接添加到<code>/etc/profile</code>或者<code>~/.bashrc</code>里面。</p><h2 id="键盘读取变量值"><a class="header-anchor" href="#键盘读取变量值"> </a>键盘读取变量值</h2><p>可以通过<code>read</code>来读取变量值，例如，来等待用户输入一个值并显示出来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bash-3.2$ read -p &quot;请输入一个值：&quot; input</span><br><span class="line">请输入一个值：21500</span><br><span class="line">bash-3.2$ echo &quot;你输入了一个值为：&quot; $input</span><br><span class="line">你输入了一个值为： 21500</span><br></pre></td></tr></table></figure><h2 id="设置变量的只读属性"><a class="header-anchor" href="#设置变量的只读属性"> </a>设置变量的只读属性</h2><p>有些重要的Shell变量，赋值后不应该修改，那么可以设置它为<code>readonly</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">oracle_home=/usr/oracle7/bin</span><br><span class="line">readonly oracle_home</span><br></pre></td></tr></table></figure><h2 id="条件测试命令-test"><a class="header-anchor" href="#条件测试命令-test"> </a>条件测试命令 test</h2><p>语法：<code>test 表达式</code>如果表达式真，则返回真，否则，返回假。</p><h3 id="范例：数值比较"><a class="header-anchor" href="#范例：数值比较"> </a>范例：数值比较</h3><p>先给出数值比较时常见的比较符：</p><p><code>-eq =</code>、<code>-ne !=</code>、<code>-gt &gt;</code>、<code>-ge &gt;=</code>、<code>-lt &lt;</code>、<code>-le &lt;=</code>。其实很好记的，eq就是equal，ne就是not equal，gt就是great than，ge就是great or equal，lt就是less than，le就是less or equal。</p><blockquote><p>建议学会自己查命令的说明书，两步走：1. 使用<code>type 命令名</code>来查看命令是内建（shell builtin）的还是外部的命令。 2. 如果是内建命令就使用<code>help 命令名</code>，如果是外部命令就是使用<code>man 命令名</code>。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test var1 -gt var2</span><br></pre></td></tr></table></figure><blockquote><p>注意上面只是test命令的一般形式，不是具体可执行的命令。比如var1，如果你要写一个具体的命令的时候，参数名前面则要加$，所以应该写：$var1。</p></blockquote><p>这个命令的返回值往往是丢给<code>if</code>（if is a shell keyword）。</p><h3 id="范例：测试文件属性"><a class="header-anchor" href="#范例：测试文件属性"> </a>范例：测试文件属性</h3><p>文件的可读、可写、可执行，是否为普通文件，是否为目录分别对应：</p><p><code>-r</code>、<code>-w</code>、<code>-x</code>、<code>-f</code>、<code>-d</code>。对应的单词是read、write、execute、file、directory。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test -r filename</span><br></pre></td></tr></table></figure><h3 id="范例：字符串属性以及比较"><a class="header-anchor" href="#范例：字符串属性以及比较"> </a>范例：字符串属性以及比较</h3><p>串长度为0：<code>-z</code>；非0：<code>-n</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test -z s1</span><br></pre></td></tr></table></figure><h3 id="范例：串比较"><a class="header-anchor" href="#范例：串比较"> </a>范例：串比较</h3><p>相等<code>&quot;s1&quot;=&quot;s2&quot;</code>；不相等<code>&quot;s1&quot;!=&quot;s2&quot;</code></p><p>还有一种比较串的方法（可以按字典序来比较）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if [[&apos;abcde&apos; &lt; &apos;abcdf&apos;]]; then echo &quot;yeah, 小于&quot;; fi</span><br></pre></td></tr></table></figure><h2 id="控制执行流程命令"><a class="header-anchor" href="#控制执行流程命令"> </a>控制执行流程命令</h2><h3 id="范例：条件分支命令-if"><a class="header-anchor" href="#范例：条件分支命令-if"> </a>范例：条件分支命令 if</h3><p><code>if</code>命令举例：如果第一个参数是一个普通文件名，那么分页打印该文件；否则，如果它为目录名，则进入该目录并打印该目录下的所有文件，如果也不是目录，那么提示相关信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">if test -f $1</span><br><span class="line">then</span><br><span class="line">    pr $1&gt;&amp;1</span><br><span class="line">elif</span><br><span class="line">    test -d $1</span><br><span class="line">then</span><br><span class="line">    (cd $1;pr *&gt;&amp;1)</span><br><span class="line">else</span><br><span class="line">    echo $1 is neither a file nor a directory</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h2 id="shell数值运算"><a class="header-anchor" href="#shell数值运算"> </a>Shell数值运算</h2><p>Shell本身可以做整数运算，复杂一些的运算要通过外部命令实现，比如：<code>expr</code>，<code>bc</code>，<code>awk</code>等。另外，可通过<code>RANDOM</code>环境变量产生一个从0到32767的随机数，一些外部工具，比如<code>awk</code>可以通过<code>rand()</code>函数产生随机数。而<code>seq</code>命令可以用来产生一个数列。</p><h2 id="范例：对某个数加1"><a class="header-anchor" href="#范例：对某个数加1"> </a>范例：对某个数加1</h2><p><code>➜ ~</code>是命令提示符（prompt），我用的是mac os x系统，shell是oh-my-zsh。<code>➜</code>是默认的提示符，<code>~</code>表示是home目录。熟悉了的同学都知道，这些都是可以自己配置的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ i=0;</span><br><span class="line">➜  ~ ((i++))</span><br><span class="line">➜  ~ echo $i</span><br><span class="line">1</span><br><span class="line">➜  ~ let i++</span><br><span class="line">➜  ~ echo $i</span><br><span class="line">2</span><br><span class="line">➜  ~ expr $i + 1</span><br><span class="line">3</span><br><span class="line">➜  ~ expr $i+1</span><br><span class="line">2+1</span><br><span class="line">➜  ~ echo $i</span><br><span class="line">2</span><br><span class="line">➜  ~ echo $i 1 | awk &apos;&#123;printf $1+$2&#125;&apos;</span><br><span class="line">3%</span><br></pre></td></tr></table></figure><p>说明：<code>expr</code>之后的<code>$i</code>，<code>+</code>，<code>1</code>之间有空格隔开。如果进行乘法运算，需要对运算符进行转义，否则Shell会把乘号解释为通配符，导致语法错误；<code>awk</code>后面的<code>$1</code>和<code>$2</code>分别指<code>$i</code>和<code>1</code>，即从左往右的第1个和第2个数。这里的<code>%</code>是我的Shell配置引起的，表示没有换行。</p><p>用Shell的内置命令查看各个命令的类型如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ type type</span><br><span class="line">type is a shell builtin</span><br><span class="line">➜  ~ type let</span><br><span class="line">let is a shell builtin</span><br><span class="line">➜  ~ type expr</span><br><span class="line">expr is /bin/expr</span><br><span class="line">➜  ~ type bc</span><br><span class="line">bc is /usr/bin/bc</span><br><span class="line">➜  ~ type awk</span><br><span class="line">awk is /usr/bin/awk</span><br></pre></td></tr></table></figure><p>从上述演示可以看出：<code>let</code>是Shell内置命令，其他几个是外部命令，在<code>/bin</code>或者<code>/usr/bin</code>目录下。</p>]]></content>
      
      <categories>
          
          <category> Unix </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unix </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>高效命令行</title>
      <link href="/blog/2018/11/03/%E9%AB%98%E6%95%88%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
      <url>/blog/2018/11/03/%E9%AB%98%E6%95%88%E5%91%BD%E4%BB%A4%E8%A1%8C/</url>
      <content type="html"><![CDATA[<h2 id="cli-快捷键"><a class="header-anchor" href="#cli-快捷键"> </a>CLI 快捷键</h2><ul><li>ctrl+a：移到命令首</li><li>ctrl+e：移到命令尾</li></ul><h2 id="将历史补全功能绑定到方向键上"><a class="header-anchor" href="#将历史补全功能绑定到方向键上"> </a>将历史补全功能绑定到方向键上</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bind &apos;&quot;\e[A&quot;: history-search-backward&apos;</span><br><span class="line">bind &apos;&quot;\e[B&quot;: history-search-forward&apos;</span><br></pre></td></tr></table></figure><p>按住<code>option</code>再按方向键，可以发现在命令行出现：<code>[A</code>，<code>[B</code>，<code>[C</code>，<code>[D</code>。这代表了这些键的字符绑定，加上<code>\e</code>也就是escape（转义）的意思。</p><h2 id="将ctrl-left-arrow和ctrl-right-arrow指定为cli编辑时-向左向右移动一个单词的距离"><a class="header-anchor" href="#将ctrl-left-arrow和ctrl-right-arrow指定为cli编辑时-向左向右移动一个单词的距离"> </a>将<code>ctrl+left arrow</code>和<code>ctrl+right arrow</code>指定为CLI编辑时，向左向右移动一个单词的距离</h2><p>在iterm2中，<code>cmd+,</code>打开设置(Preferences)，Preferences-&gt;Profiles-&gt;Keys。找到<code>^&lt;-</code>，设置为：<code>Send Escape Sequence</code>：<code>Esc+[C</code>，将<code>^-&gt;</code>，设置为：<code>Send Escape Sequence</code>：<code>Esc+[D</code>。</p><h2 id="man"><a class="header-anchor" href="#man"> </a>man</h2><p>man page是在线帮助，man page显示的内容文件放在<code>/usr/share/man</code>中</p><ul><li>向下翻页：Page Down，Mac OSX里面快捷键是<code>Fn+Down Arrow</code></li><li>向上翻页：Page Up，Mac OSX里面快捷键是<code>Fn+Up Arrow</code></li><li>翻到最后一页：End，Mac OSX里面快捷键是<code>Fn+right Arrow</code></li><li>翻到第一页：Home，Mac OSX里面快捷键是<code>Fn+left Arrow</code></li></ul><h2 id="查找"><a class="header-anchor" href="#查找"> </a>查找</h2><p>使用<code>/string</code>向下搜索string关键字，<code>?string</code>向上搜索string关键字。n键继续关键字的下一个搜索，N键反向搜索关键字。</p><blockquote><p>跟vim里面的搜索是一样的。</p></blockquote>]]></content>
      
      <categories>
          
          <category> Unix </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unix </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mac osx 与 linux 的一些区别</title>
      <link href="/blog/2018/11/03/mac%20osx%20%E4%B8%8E%20linux%20%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8C%BA%E5%88%AB/"/>
      <url>/blog/2018/11/03/mac%20osx%20%E4%B8%8E%20linux%20%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<h2 id="mac-osx上-bashrc和-bash-profile的区别"><a class="header-anchor" href="#mac-osx上-bashrc和-bash-profile的区别"> </a>mac osx上<code>.bashrc</code>和<code>.bash_profile</code>的区别</h2><p><code>.bash_profile</code> is executed for login shells, while <code>.bashrc</code> is executed for interactive non-login shells.</p><p>When you login (type username and password) via console, either sitting at the machine, or remotely via ssh: <code>.bash_profile</code> is executed to configure your shell before the initial command prompt.</p><p>But, if you’ve already logged into your machine and open a new terminal window (xterm) then .bashrc is executed before the window command prompt. <code>.bashrc</code> is also run when you start a new bash instance by typing <code>/bin/bash</code> in a terminal.</p><p>On OS X, Terminal by default runs a login shell every time, so this is a little different to most other systems, but you can configure that in the preferences.</p><h2 id="mac-osx系统的环境变量加载顺序"><a class="header-anchor" href="#mac-osx系统的环境变量加载顺序"> </a>Mac OSX系统的环境变量加载顺序</h2><ol><li>/etc/profile</li><li>/etc/paths</li><li>~/.bash_profile</li><li>~/.bash_login</li><li>~/.profile</li><li>~/.bashrc</li></ol><p>/etc/profile和/etc/paths是系统级别的，系统启动就会加载，后面几个是当前用户级的环境变量，后面几个按从前往后的顺序读取，如果<code>~/.bash_profile</code>文件存在，则后面的几个文件就会被忽略不读了，如果<code>~/.bash_profile</code>文件不存在，才会以此类推读取后面的文件。</p><h2 id="设置path的语法"><a class="header-anchor" href="#设置path的语法"> </a>设置PATH的语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 中间用冒号隔开</span><br><span class="line">export PATH=$PATH:&lt;PATH 1&gt;:&lt;PATH 2&gt;:---:&lt;PATH N&gt;</span><br></pre></td></tr></table></figure><blockquote><p>export的意思是使子进程拥有父进程的环境变量</p></blockquote>]]></content>
      
      <categories>
          
          <category> Unix </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unix </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>社交网站 -- 圈子</title>
      <link href="/blog/2018/11/02/Java%20Web%20%E5%AE%9E%E6%88%98/"/>
      <url>/blog/2018/11/02/Java%20Web%20%E5%AE%9E%E6%88%98/</url>
      <content type="html"><![CDATA[<p>我正在做一个社交网站，目前暂定叫做：圈子。这个项目从产品到UI到前端、后端全部都由我一个人操刀。</p><p>后端使用了 <code>Spring + SpringMVC + Mybatis</code> 的框架组合，据说 <code>SpringBoot</code> 很流行，后面我会学一下。前端使用了 <code>Vue</code> 框架。产品设计移动端优先，使用了 <code>墨刀</code> 这款工具。</p><a id="more"></a><p>后端：servlet容器使用 <code>tomcat</code>，数据库使用 <code>mysql</code>，前端：UI框架使用 <code>muse ui</code>。</p><p>开发工具后端选择了 <code>Intellj idea</code>，前端使用 <code>Sublime text 3</code>。</p><p>代码托管使用 <code>coding.net</code>。</p><p>一般的项目流程都是：</p><ol><li>产品设计</li><li>UI设计</li><li>数据库设计</li><li>前端开发，后端开发</li></ol><h2 id="后端开发"><a class="header-anchor" href="#后端开发"> </a>后端开发</h2><h3 id="服务器上安装java"><a class="header-anchor" href="#服务器上安装java"> </a>服务器上安装Java</h3><p>不使用open-jdk，去oracle官网下载jdk。</p><p>这里遇到的一个问题是，在官网点击accept之后，复制到下载链接，然后在服务器上wget该下载地址，发现不到一秒就下载完了，但是下载的文件不能解压！上网搜了一通，有不少人是在tar上找原因，说参数怎么怎么改，但试了多种参数搭配，查看了参数的说明，还是没解决问题，后来看到有人也遇到了相同的问题，结果是因为认证的问题，用浏览器下载的时候下载链接会多一个后缀。具体如下：</p><p>如果直接复制下载链接，得到的是：<a href="http://download.oracle.com/otn-pub/java/jdk/10.0.2+13/19aef61b38124481863b1413dce1855f/jdk-10.0.2_linux-x64_bin.tar.gz" target="_blank" rel="noopener">http://download.oracle.com/otn-pub/java/jdk/10.0.2+13/19aef61b38124481863b1413dce1855f/jdk-10.0.2_linux-x64_bin.tar.gz</a></p><p>通过chrome浏览器点击下载，然后ctrl+j打开下载界面（chrome://downloads），得到的真正的下载链接是：<a href="http://download.oracle.com/otn-pub/java/jdk/10.0.2+13/19aef61b38124481863b1413dce1855f/jdk-10.0.2_linux-x64_bin.tar.gz?AuthParam=1532949475_ca242a7f9181fc9c51d63b20d1465ae1" target="_blank" rel="noopener">http://download.oracle.com/otn-pub/java/jdk/10.0.2+13/19aef61b38124481863b1413dce1855f/jdk-10.0.2_linux-x64_bin.tar.gz?AuthParam=1532949475_ca242a7f9181fc9c51d63b20d1465ae1</a></p><p>可以看到多了<code>?AuthParam=1532949475_ca242a7f9181fc9c51d63b20d1465ae1</code>这一段。</p><p>其实先用chrome点击一下下载，然后通过下载界面获取真正的下载链接，以前也是干过的，因为很多时候一个下载链接或者按钮并非真正的下载链接，而往往是一个js或者php来触发下载动作，同时完成对下载者的认证。<strong>所以，以后下载的时候还是先用chrome获取到真正的链接比较好</strong>。</p><p>这里再记录一个myeclipse破解过程中的一个问题，破解包里面有个crack.jar，用jdk10是会报错的！后来把jdk换成了1.8就可以了。</p><p>下载好jdk之后，就是配置Java环境了。配置很简单，首选/etc/profile。</p><p>在文件最后添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME=/usr/bin/jdk1.8.0_181/bin</span><br><span class="line">export PATH=$PATH:$JAVA_HOME</span><br></pre></td></tr></table></figure><p>要注意的有两点，一是路径要到bin目录，因为可执行的java和javac文件都是在bin目录下；二是使用变量要加$，定义变量则不需要。</p><p>最后要注意的就是export命令的意思，stackoverflow一下：<strong><code>export</code> makes the variable available to sub-processes.</strong></p><p>翻译成中文就是说：export让子进程可以使用该变量。如果你不用export，那么你在shell里再新开其他shell，环境变量就都没了。</p><p>最后还得谈谈对PATH这个东西的一点深入理解。我居然蠢到以为只要把jdk整个目录扔到/usr/bin下面就能使用java和javac了，实际上只有PATH下的一层目录可以，子目录是不行的！为什么不做成子目录也可以扫描到？因为那样这个PATH机制就失去了意义，既然你子目录都可以扫，那我拿根目录做PATH，然后程序随便扔哪不就行了。从另一个角度来看，你遍历子目录找可执行文件是很耗时的，也是不科学的，因为将会有很多重名的文件，你让shell怎么知道你要执行哪个文件？而同一层目录的文件是不允许同名的，不存在冲突。</p><p>最后一个问题是为什么要配置环境变量，其实当然也可以不配置，配置的好处是可以省去那一串长长的路径。</p><h3 id="tomcat配置"><a class="header-anchor" href="#tomcat配置"> </a>tomcat配置</h3><p>首先是去官网下载，下载一个tar.gz格式的，然后解压，然后也是配置环境，其实tomcat不用配置成环境变量也行，因为网站开关的次数是非常少的。</p><p>这里唯一要注意的问题就是你的服务器端口要打开，默认是8080端口。我一般买了服务器之后先把除ssh之外的所有端口统统关了。</p><h3 id="mysql配置"><a class="header-anchor" href="#mysql配置"> </a>mysql配置</h3><p>mysql也需要去官网下载，这里记录一个问题，mysql8.0会与jdbc不兼容，所以版本太高也是容易出问题的，我换成mysql5.7就好了。</p><p>另外我在安装了centOS服务器上安装mysql也是费了很多功夫，刚开始是想去官网手动下载安装以及配置，刚开始的时候是参照这个博客：<a href="https://blog.csdn.net/Cryhelyxx/article/details/49757217" target="_blank" rel="noopener">64位centos6.7安装mysql-5.7.9-linux-glibc2.5-x86_64.tar.gz</a>。实在太麻烦了，而且配置过程中遇到太多的问题，我后来想linux的安装不是都统一用安装命令解决吗。于是我又上网翻，找到了这个教程：<a href="https://my.oschina.net/Laily/blog/713023" target="_blank" rel="noopener">CentOS 7 yum 安装 MySQL5.7</a>。总算是照着弄完了。但也同样遇到一个问题，就是官网上已经没有5.7版本的链接，只有8.0版本的。没关系下载的接口并没有撤，只要照着教程里的链接下载就行了：<code>wget http://repo.mysql.com//mysql57-community-release-el7-8.noarch.rpm</code></p><p>最后总结一下安装和配置的方法论：</p><ol><li>找到下载源，一般是去官网找，但也有找不到的情况，比如下载低版本的时候，比如找jdk的时候，我一般google关键字：jdk1.8 oracle，如果是想找最新的则输入：java oracle。tomcat则比较好，多个版本都提供而且一直都在更新。mysql则比较坑一点，在官网的yum下载入口中根本就没有低版本的链接。这时候只好找找看别人的教程里的安装低版本时候的链接，说不定那些下载链接都还有效。</li><li>配置，一般主要是配置环境变量，然后像mysql这种还需要初始化，但如果使用linux安装命令的话很多东西就都自动配置好了，所以最好不要自己去配置，除非你有充足的时间，想要学习一下配置过程。</li></ol><h3 id="远程连接mysql"><a class="header-anchor" href="#远程连接mysql"> </a>远程连接mysql</h3><p>用navicat远程连接mysql的时候遇到的问题：错误号：1130.</p><p>是因为权限问题造成的，解决办法：</p><p>进入mysql:<code>mysql -u root -p</code><br>在mysql控制台中输入：<code>GRANT ALL PRIVILEGES ON *.* TO 'myuser'@'%' IDENTIFIED BY 'mypassword' WITH GRANT OPTION;</code></p><p>其中*.*代表ip，这样写就是允许所有IP，然后myuser填你要登录的用户，%这里本来是填登录的设备，使用%表示任何设备都可以，mypassword填该用户对应的密码。</p><h3 id="框架搭建"><a class="header-anchor" href="#框架搭建"> </a>框架搭建</h3><p>关于后台搭框架的过程，可以参考这篇文章：<a href="https://blog.csdn.net/GallenZhang/article/details/51932152" target="_blank" rel="noopener">SSM框架整合（IntelliJ IDEA + maven + Spring + SpringMVC + MyBatis）</a></p><p>要注意的几点：</p><ul><li>tomcat肯定是要手动配置的</li><li>Artifact也是要手动添加</li><li>resource要手动标记，特别是协作开发的时候，搭好框架使用git上传到代码托管服务器，然后再clone下来之后，是需要你手动标记出resource文件夹的。</li><li>第三方库（非Maven远程托管的库）一定要放到 <code>src -&gt; main -&gt; webapp -&gt; WEB-INF -&gt; lib</code> 目录下（没有就自己创建），否则在build的时候你会发现target中的lib没有第三方库（其实build过程对这些库的处理方式就是简单的拷贝，你手动拷贝也是可以的，但自动化才是最好的）</li></ul><p>然后就是多熟悉一下配置，弄好自己需要的配置，弄清楚配置可以做哪些事，这很重要。</p><h4 id="第三方库的管理问题"><a class="header-anchor" href="#第三方库的管理问题"> </a>第三方库的管理问题</h4><p>第三方库老是报错：<code>classNotfound</code>，这个库是用来发短信的：</p><p>在pom.xml中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>sms<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sms<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.6.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>$&#123;basedir&#125;/src/main/webapp/WEB-INF/lib/CCP_REST_SMS_SDK_JAVA_v2.6.3r.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>systemPath一开始我填的是${basedir}/lib/CCP_REST_SMS_SDK_JAVA_v2.6.3r.jar，始终是不行，我看了target里面的lib，没拷贝进去，就算我手动拷贝jar包进去还是classNotfound，后来换成这个路径存放jar之后终于能自动拷贝进target里面，问题也修复了。</p><h3 id="mybatis-generator"><a class="header-anchor" href="#mybatis-generator"> </a>mybatis-generator</h3><p>数据库设计好之后，可以使用mybatis自动生成数据库操作相关的部分：<code>mapper</code>、<code>mapping</code>和<code>dao</code>。可以参考这篇文章：<a href="https://www.cnblogs.com/lichenwei/p/4145696.html" target="_blank" rel="noopener">使用Mybatis-Generator自动生成Dao、Model、Mapping相关文件</a></p><p>下面三个文件放到同一目录，运行指令：<code>java -jar mybatis-generator-core-1.3.7.jar -configfile generatorConfig.xml -overwrite</code></p><ul><li><a href="../../../../assets/2018/generatorConfig.xml">generatorConfig.xml</a></li><li><a href="../../../../assets/2018/mybatis-generator-core-1.3.7.jar">mybatis-generator-core-1.3.7.jar</a></li><li><a href="../../../../assets/2018/mysql-connector-java-5.0.8-bin.jar">mysql-connector-java-5.0.8-bin.jar</a></li></ul><blockquote><p>遇到的坑是overwrite实际上会出问题，如果想重新生成，还是应该先删掉生成的文件，再重新生成，如果覆盖可能会出问题。</p></blockquote><h3 id="gitignore"><a class="header-anchor" href="#gitignore"> </a>.gitignore</h3><p>使用intellj idea的插件.ignore来自动生成，选择java, maven, jetbrains, macosx等选项，生成相应的忽略项。</p><ol><li>如果你有自己下载的第三方jar包，想通过git来维护，必须注释掉java选项生成的*.jar忽略项。</li><li>下载后的项目还要自己配置tomcat才能运行，要手动添加Artifacts，并手动标识resource文件夹。</li></ol><h2 id="用户模块的逻辑"><a class="header-anchor" href="#用户模块的逻辑"> </a>用户模块的逻辑</h2><h3 id="注册"><a class="header-anchor" href="#注册"> </a>注册</h3><h4 id="请求参数校验"><a class="header-anchor" href="#请求参数校验"> </a>请求参数校验</h4><ol><li>基本逻辑：注册必须先注销，检查session的keyId（keyId即数据库中的用户名），如果存在keyId，则是登录状态，系统拒绝服务。</li><li>用户名不能为空</li><li>手机号不能为空</li><li>用户名不能是已被占用的</li><li>手机号不能是已被占用的</li><li>密码不能为空</li><li>确认密码要与密码一致</li><li>图形验证码不正确</li><li>短信验证码错误</li><li>短信验证码过期</li></ol><h4 id="添加用户"><a class="header-anchor" href="#添加用户"> </a>添加用户</h4><ol><li>设置用户ID</li><li>设置用户名</li><li>设置密码</li><li>设置手机</li><li>设置添加时间</li><li>设置更新时间</li><li>设置verifyCode（用于给密码加密）</li></ol><blockquote><p>手机号只能与一个账号绑定，一个账号只能绑定一个手机号，因而也可以用手机号登陆</p></blockquote><blockquote><p>密码使用MD5加密，由<code>用户ID</code>+<code>前端传过来的密码</code>+<code>verifyCode</code>拼成。其中前端传过来的密码也需要经过MD5加密。</p></blockquote><blockquote><p>后端加密的意义在于防止拖库</p></blockquote><blockquote><p>verifyCode的生成使用当前UNIX时间戳减去一个随机数，得到的long型整数，再拼接用户的手机号进行MD5加密</p></blockquote><blockquote><p>前端密码加密的意义在于，用户多站点使用同一密码，防止用户的其他账号被盗（社会学攻击）</p></blockquote><blockquote><p>前端加密并不能防止HTTP劫持，所以要防止盗号还是必须使用HTTPS协议</p></blockquote><h4 id="维护session"><a class="header-anchor" href="#维护session"> </a>维护session</h4><blockquote><p>维护session的时候要去掉用户密码和verifyCode，其他的字段都可以设置进session</p></blockquote><h2 id="数据库重复插入问题"><a class="header-anchor" href="#数据库重复插入问题"> </a>数据库重复插入问题</h2><p>由于网络原因，客户可能连续推送了两条重复的数据，两条数据时间间隔非常小，因此导致了我们的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">if(用户不存在)</span><br><span class="line">&#123;</span><br><span class="line">    xxxxx</span><br><span class="line">    存储用户到数据库</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    重复推送，不采取任何措施</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个操作还没有执行完毕，第二条拥有相同数据的线程已经进入并通过了if的检验，导致数据库存储了两条相同的数据。后来我自己写了个100并发的多线程测试程序，发现100条相同数据中有40条被插入到了数据库里！天啦噜！！！因此确定了是多线程的并发导致了程序的判断逻辑失效。</p><p>考虑使用synchronized对方法添加同步锁，但是这样会导致其他正常数据的推送线程也被阻塞，影响效率。因此不采用。</p><p>即想提高效率不对方法添加synchronized，又想保证数据准确性，最后使用synchronized(siteId + uid) 在Controller层加锁(保证了只有重复数据被加锁,在Controller使用的原因是因为事务会在Service调用完毕才被提交，我实验过在Service同步，150并发会出现2条重复数据，因为事务还没来得及提交)</p><p>这种加同步锁的方法在<br>负载均衡下的多台应用服务器会失效<br>！因为就算Spring保证了对象是单例的，但是多台服务器肯定是多个对象！因此synchronized将无效。解决方法是在数据库层对该对接公司的唯一记录加select锁，这样就能保证数据的不重复性，但是会降低该公司推送数据的效率(相当于逐条推送)，但是公司与公司之间还是并行推送的。还有一个方法就是将业务逻辑写入存储过程，然后对存储过程加锁，这种方法太麻烦了，需求有变动就必须去修改存储过程，但是效率要比前者高得多。</p><p>总结：</p><p>在service层加锁会导致所有用户操作受阻，在controller针对用户id加锁可以锁住重复操作。但多台服务器的情况下会失效。</p><h2 id="参考资料："><a class="header-anchor" href="#参考资料："> </a>参考资料：</h2><ul><li><a href="http://www.voidcn.com/article/p-qtmqetyl-ug.html" target="_blank" rel="noopener">获取用户IP</a></li></ul>]]></content>
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端学习攻略</title>
      <link href="/blog/2018/11/01/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%94%BB%E7%95%A5/"/>
      <url>/blog/2018/11/01/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0%E6%94%BB%E7%95%A5/</url>
      <content type="html"><![CDATA[<p>官方文档：</p><ul><li><a href="http://www.w3school.com.cn/" target="_blank" rel="noopener">w3school</a></li><li><a href="https://developer.mozilla.org/zh-CN/" target="_blank" rel="noopener">MDN Web Docs</a></li></ul><blockquote><p>不用刻意跑到这两个网站里去搜索，直接google即可。一般搜索结果里前几个就是这两个网站。</p></blockquote><a id="more"></a>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>CSS布局</title>
      <link href="/blog/2018/11/01/CSS%E5%B8%83%E5%B1%80/"/>
      <url>/blog/2018/11/01/CSS%E5%B8%83%E5%B1%80/</url>
      <content type="html"><![CDATA[<p>做网站的前端开发，学习CSS布局是非常重要的，这里给出一些质量高的资料：</p><ul><li><a href="http://zh.learnlayout.com/" target="_blank" rel="noopener">学习CSS布局</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">Flex布局教程–阮一峰</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/07/flex-examples.html" target="_blank" rel="noopener">Flex布局实战–阮一峰</a></li></ul><a id="more"></a><p>布局的传统解决方案，基于<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/box_model" target="_blank" rel="noopener">盒装模型</a>。依赖 <code>display</code>属性 + <code>position</code>属性 + <code>float</code>属性。</p><ul><li><a href="../CSS%E4%BC%A0%E7%BB%9F%E5%B8%83%E5%B1%80">传统CSS布局</a></li><li>[CSS Flex 布局](…/CSS Flex 布局)</li></ul><h2 id="居中和自适应"><a class="header-anchor" href="#居中和自适应"> </a>居中和自适应</h2><h3 id="margin-auto"><a class="header-anchor" href="#margin-auto"> </a>margin: auto;</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#main</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置块级元素<code>width</code>可以防止它从左到右撑满整个容器。然后你就可以设置左右外边距为<code>auto</code>来使其水平居中。元素会占据你所指定的宽度，然后剩余的宽度会一分为二成为左右外边距。</p><p>唯一的问题是，当浏览器窗口比元素的宽度还要窄时，浏览器会显示一个水平滚动条来容纳页面。让我们再来改进一下这个方案…</p><h3 id="max-width"><a class="header-anchor" href="#max-width"> </a>max-width</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#main</span>&#123;</span><br><span class="line">    <span class="attribute">max-width</span>: <span class="number">600px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下使用<code>max-width</code>来代替<code>width</code>可以使浏览器更好的处理小窗口的情况。这点在移动设备上显得尤为重要。</p><h3 id="盒模型"><a class="header-anchor" href="#盒模型"> </a>盒模型</h3><p><strong>元素的真实占据空间 = 元素大小+内边距+边框</strong></p><h3 id="box-sizing"><a class="header-anchor" href="#box-sizing"> </a>box-sizing</h3><p>盒模型对于元素真实大小的获取并不直接，需要自己计算，所以新增了一个叫做：<code>box-sizing</code>的CSS属性。当你设置一个元素为：<code>box-sizing: border-box;</code>时，此元素的内边距和边框不再增加它的宽度。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">-webkit-box-sizing</span>: border-box;</span><br><span class="line">       <span class="attribute">-moz-box-sizing</span>: border-box;</span><br><span class="line">            <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="媒体查询"><a class="header-anchor" href="#媒体查询"> </a>媒体查询</h2><p>&quot;响应式设计（Responsive Design）&quot;是一种让网站针对不同的浏览器和设备呈现不同显示效果的策略，这样做可以让网站在任何情况下都显示的很棒。</p><p>媒体查询是做响应式设计的最强大工具。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">media</span> screen and (min-width:<span class="number">600px</span>)&#123;</span><br><span class="line">    <span class="selector-tag">nav</span>&#123;</span><br><span class="line">        <span class="attribute">float</span>: left;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">25%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">section</span>&#123;</span><br><span class="line">        <span class="attribute">margin-left</span>: <span class="number">25%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">media</span> screen and (max-width:<span class="number">599px</span>)&#123;</span><br><span class="line">    <span class="selector-tag">nav</span> <span class="selector-tag">li</span>&#123;</span><br><span class="line">        <span class="attribute">display</span>: inline;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
          <category> CSS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>CSS传统布局</title>
      <link href="/blog/2018/11/01/CSS%E4%BC%A0%E7%BB%9F%E5%B8%83%E5%B1%80/"/>
      <url>/blog/2018/11/01/CSS%E4%BC%A0%E7%BB%9F%E5%B8%83%E5%B1%80/</url>
      <content type="html"><![CDATA[<h2 id="display"><a class="header-anchor" href="#display"> </a>display</h2><p><code>display</code>是CSS中最重要的用于控制布局的属性。<strong>每个元素都有一个默认的display值</strong>，这与元素的类型有关。对于大多数元素它们的默认值通常是<code>block</code>或<code>inline</code>。一个block元素通常被叫做块级元素。一个inline元素通常被叫做行内元素。</p><a id="more"></a><h3 id="block"><a class="header-anchor" href="#block"> </a>block</h3><p><code>div</code>是一个标准的块级元素。<strong>一个块级元素会新开始一行并尽可能撑满容器</strong>。其他常用的块级元素包括<code>p</code>、<code>form</code>和HTML5中的新元素：<code>header</code>、<code>footer</code>、<code>section</code>等。</p><h3 id="inline"><a class="header-anchor" href="#inline"> </a>inline</h3><p><code>span</code>是一个标准的行内元素。一个行内元素可以在段落中<code>&lt;span&gt;像这样&lt;/span&gt;</code>包裹一些文字而不会打乱段落的布局。<code>a</code>元素是最常用的行内元素，它可以被用作链接。</p><h3 id="none"><a class="header-anchor" href="#none"> </a>none</h3><p>另一个常用的display值是<code>none</code>。<strong>一些特殊元素的默认值是它，例如<code>script</code></strong>。</p><p>它和<code>visibility</code>属性不一样。把<code>display</code>设置成<code>none</code>元素不会占据它本来应该显示的空间，但是设置成<code>visibility: hidden</code>还会占据空间。</p><h3 id="其他display值"><a class="header-anchor" href="#其他display值"> </a>其他display值</h3><p>还有很多有意思的display值，例如<code>list-item</code>和<code>table</code>。<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/display" target="_blank" rel="noopener">这里有一份详细的列表</a>。之后我们会讨论到<code>inline-block</code>和<code>flex</code>。</p><h3 id="使用技巧"><a class="header-anchor" href="#使用技巧"> </a>使用技巧</h3><ol><li>每个元素都有一个默认的display类型。不过你可以随时随地重写它，常见的例子是：把<code>li</code>元素修改成inline，制作水平菜单。</li><li><code>display:none</code>通常被javascript用来在不删除元素的情况下隐藏或显示元素。</li></ol><h2 id="position"><a class="header-anchor" href="#position"> </a>position</h2><p>为了制作更多复杂的布局，我们需要讨论一下<code>position</code>属性。</p><h3 id="static"><a class="header-anchor" href="#static"> </a>static</h3><p><code>position: static;</code>，<code>static</code>是默认值。任意<code>position: static;</code>不会被特殊定位，也就是表示它不会被&quot;positioned&quot;，一个position被设置成其他值的元素表示它会被&quot;positioned&quot;。</p><h3 id="relative"><a class="header-anchor" href="#relative"> </a>relative</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.relative1</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.relative2</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: white;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在一个相对定位的元素上设置<code>top</code>、<code>right</code>、<code>bottom</code>、<code>left</code>属性会使其偏离正常位置，其他元素的位置则不会受其影响。</p><h3 id="fixed"><a class="header-anchor" href="#fixed"> </a>fixed</h3><p>一个固定定位元素会相对于视窗来定位，这意味着即使页面滚动，它还是停留在原来的位置，也就是脱离文档流。</p><h3 id="absolute"><a class="header-anchor" href="#absolute"> </a>absolute</h3><p><code>absolute</code>与<code>fixed</code>的表现类似，但是它不是相对于视窗而是相对于最近的&quot;positioned&quot;祖先元素，如果没有这样一个祖先元素，那么它相对于文档的body元素，并且它会随着页面滚动而移动。记住一个&quot;positioned&quot;元素是指position值不是static的元素。</p><h2 id="float"><a class="header-anchor" href="#float"> </a>float</h2><p>另一个布局中常用的CSS属性是<code>float</code>。float可用于实现文字环绕图片，如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span>&#123;</span><br><span class="line">    <span class="attribute">float</span>: right;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">1em</span> <span class="number">1em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2018/11/01/5bda759748c93.png" alt="文字环绕图片.png"></p><h3 id="clear"><a class="header-anchor" href="#clear"> </a>clear</h3><p><code>clear</code>属性被用于控制浮动。比较下面两个例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span>...<span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">1em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2018/11/01/5bda7801d743b.png" alt="float导致的重叠.png"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">1em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.after-box</span> &#123;</span><br><span class="line">  <span class="attribute">clear</span>: left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2018/11/01/5bda77fcac846.png" alt="clear用来清楚float的影响.png"></p><h3 id="清除浮动-clearfix-hack"><a class="header-anchor" href="#清除浮动-clearfix-hack"> </a>清除浮动（clearfix hack）</h3><p>在使用浮动的时候经常遇到一些古怪的事：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2018/11/01/5bda80ed4438c.png" alt="float图片不被框住.png"></p><p>见证奇迹的时刻到了！有一种比较丑陋的方法可以解决这个问题，它叫做清除浮动（clearfix hack）.</p><p>让我们加入一些新的CSS样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在再看看发生了什么：</p><p><img src="https://i.loli.net/2018/11/01/5bda814a3affe.png" alt="clearfix.png"></p>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
          <category> CSS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>CSS Flex 布局</title>
      <link href="/blog/2018/11/01/CSS%20Flex%20%E5%B8%83%E5%B1%80/"/>
      <url>/blog/2018/11/01/CSS%20Flex%20%E5%B8%83%E5%B1%80/</url>
      <content type="html"><![CDATA[<h2 id="flex布局是什么？"><a class="header-anchor" href="#flex布局是什么？"> </a>Flex布局是什么？</h2><p>Flex 是 Flexible Box 的缩写，意味 “弹性布局”。</p><blockquote><p>flex影响的是其内元素的布局方式，而非影响这个容器自己所处的位置。</p></blockquote><p>任何容器都可以指定为flex布局。</p><a id="more"></a><p>任何容器都可以指定为flex布局。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>行内元素也可以使用flex布局：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，设为flex布局之后，子元素的<code>float</code>、<code>clear</code>、<code>vertical-align</code>属性将失效。如果你对这三个属性不熟可以看看这篇文章：<a href="../CSS%E4%BC%A0%E7%BB%9F%E5%B8%83%E5%B1%80">CSS传统布局</a></p><h2 id="flex布局的基本概念"><a class="header-anchor" href="#flex布局的基本概念"> </a>Flex布局的基本概念</h2><p>采用Flex布局的元素，称为Flex容器（flex container），它的所有子元素自动成为容器成员，称为 flex item，简称item（中文可译作：项目）。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png" alt="flex布局图解"></p><p>容器默认存在两根轴，默认情况下：水平的叫：主轴（main axis），垂直的叫：交叉轴（cross axis）。主轴的开始位置叫做：main start，结束位置叫做：main end；交叉轴的开始位置叫做：cross start，结束位置叫做：cross end。</p><p>主轴不一定是横向的，可以设置为纵向，且从上到下（起点在上，终点在下），这种情况下交叉轴就是横向了，且从左到右（起点在左，终点在右）。item始终沿主轴排列，交叉轴只是用来辅助主轴，控制item在另一个方向上的浮动，单个item占据的主轴空间叫做：main size，占据的交叉轴空间叫做：cross size。</p><h2 id="flex容器的属性"><a class="header-anchor" href="#flex容器的属性"> </a>flex容器的属性</h2><ul><li>flex-direction</li><li>flex-wrap</li><li>flex-flow（这个属性是前两者的简写，所以实际上只有5种属性）</li><li>justify-content</li><li>align-items</li><li>align-content</li></ul><h3 id="flex-direction"><a class="header-anchor" href="#flex-direction"> </a>flex-direction</h3><p>顾名思义是决定 <strong>主轴</strong> 的方向：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>row：水平布局，从左到右</li><li>row-reverse：水平布局，从右到左</li><li>column：垂直布局，从上到下</li><li>column-reverse：垂直布局，从下到上</li></ul><h3 id="flex-wrap"><a class="header-anchor" href="#flex-wrap"> </a>flex-wrap</h3><p>默认情况下，项目都排列在一条轴上。flex-wrap属性定义，如果一条轴上摆不下，如何换行。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071006.png" alt="flex-wrap图解"></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>nowrap：不换行</li><li>wrap：换行，第一行在上方</li><li>wrap-reverse：换行，第一行在下方</li></ul><p>wrap:</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071008.jpg" alt="wrap"></p><p>wrap-reverse:</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071009.jpg" alt="wrap-reverse"></p><h3 id="flex-flow"><a class="header-anchor" href="#flex-flow"> </a>flex-flow</h3><p>flex-flow是<code>flex-direction</code>和<code>flex-wrap</code>的简写形式，默认值为：row nowrap。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">flex-flow</span>: row nowrap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>row和nowrap的位置无所谓，可以互换：flex-flow: nowrap row;</p></blockquote><h3 id="justify-content"><a class="header-anchor" href="#justify-content"> </a>justify-content</h3><p><code>justify-content</code>定义了item在主轴上的对齐方式（不管主轴是横向还是纵向，都是作用在主轴上）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>flex-start（默认值）：左对齐</li><li>flex-end：右对齐</li><li>center：居中</li><li>space-between：两端对齐，item的间隔相等</li><li>space-around：每个item两侧的间隔相等，所以item之间的间隔比item与边框的间隔大一倍。</li></ul><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png" alt="justify-content图解"></p><h3 id="align-items"><a class="header-anchor" href="#align-items"> </a>align-items</h3><p><code>align-items</code>定义了item在交叉轴上如何对齐。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span>&#123;</span><br><span class="line">  <span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>flex-start：与交叉轴的起点对齐</li><li>flex-start：与交叉轴的终点对齐</li><li>center：与交叉轴的中点对齐</li><li>baseline：item的第一行文字的基线对齐</li><li>stretch（默认值）：如果item未设置高度或设为auto，将占满整个容器。</li></ul><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071011.png" alt="align-items图解"></p><h3 id="align-content"><a class="header-anchor" href="#align-content"> </a>align-content</h3><p><code>align-content</code>属性定义了多根主轴的对齐方式。如果项目只有一根主轴，该属性不起作用。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>flex-start：与交叉轴的起点对齐</li><li>flex-end：与交叉轴的中点对齐</li><li>center：与交叉轴的中点对齐</li><li>space-between：与交叉轴的两端对齐，轴线之间的间隔平均分布</li><li>space-around：每根轴线两侧的间隔都相等，所以轴线与轴线之间的间隔，比轴线与边框的间隔大一倍</li><li>stretch（默认值）：轴线占满整个交叉轴</li></ul><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071012.png" alt="align-content图解"></p><h2 id="item的属性"><a class="header-anchor" href="#item的属性"> </a>item的属性</h2><ul><li>order</li><li>flex-grow</li><li>flex-shrink</li><li>flex-basis</li><li>flex</li><li>align-self</li></ul><h3 id="order"><a class="header-anchor" href="#order"> </a>order</h3><p><code>order</code>定义item的排列顺序。数值越小，排列越靠前，默认为0。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line">  <span class="attribute">order</span>: &lt;integer&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071013.png" alt="order图解"></p><h3 id="flex-grow"><a class="header-anchor" href="#flex-grow"> </a>flex-grow</h3><p><code>flex-grow</code>属性定义项目的放大比例，默认为0，也就是不铺满剩余空间。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: &lt;number&gt;; <span class="comment">/* default 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071014.png" alt="flex-grow图解"></p><p>如果所有item的<code>flew-grow</code>属性都是1，那么它们将等分剩余空间。一个item所占的空间比例就是用它的<code>flex-grow</code>除以总的<code>flex-grow</code>。</p><h3 id="flex-shrink"><a class="header-anchor" href="#flex-shrink"> </a>flex-shrink</h3><p><code>flex-shrink</code>属性定义了item的缩小比例，默认为1，即空间不足时，缩小item。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span>&#123;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: &lt;integer&gt;; <span class="comment">/* default 1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071015.jpg" alt="flex-shrink"></p><p>如果所有item的<code>flex-shrink</code>属性都为1，当空间不足时，都将等比例缩小（注意是等比例缩小而不是缩成同样大小），如果一个item的<code>flex-shrink</code>为0，则当空间不足时，不缩小。</p><h3 id="flex-basis"><a class="header-anchor" href="#flex-basis"> </a>flex-basis</h3><p><code>flex-basis</code>属性定义了item占据主轴空间的大小，优先级高于width和height。默认值为 auto，即item的本来大小。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-basis</span>: &lt;length&gt; | auto; <span class="comment">/* default auto */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="flex"><a class="header-anchor" href="#flex"> </a>flex</h3><p><code>flex</code>属性是<code>flex-grow</code>、<code>flex-shrink</code>、<code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: none | [ &lt;<span class="string">'flex-grow'</span>&gt; &lt;<span class="string">'flex-shrink'</span>&gt;? || &lt;<span class="string">'flex-basis'</span>&gt; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。</p><h3 id="align-self"><a class="header-anchor" href="#align-self"> </a>align-self</h3><p><code>align-self</code>属性允许单个的item重新设定<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071016.png" alt="align-self图解"></p>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
          <category> CSS </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>vue入门重点笔记（可作为面试考察点）</title>
      <link href="/blog/2018/10/29/vue%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
      <url>/blog/2018/10/29/vue%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1>项目初始化命令</h1><ol><li>安装vue-cli: <code>npm install -g vue-cli</code></li><li>初始化项目: <code>vue init webpack my-project</code></li><li>进入项目: <code>cd my-project</code></li><li>安装依赖: <code>npm install</code></li><li>运行项目: <code>npm run dev</code></li></ol><h1>项目目录结构</h1><p>最重要的几个东西：</p><ol><li>index.html：项目根视图</li><li>main.js</li><li>App.vue</li><li>src目录</li></ol><h1>单文件项目(Single Page Application)</h1><p>vue组件：包含三个部分</p><ul><li>template：视图</li><li>script：逻辑</li><li>style：样式</li></ul><p>知识点：</p><ol><li>template下只能存在一个根元素</li><li>script里面必须导出当前组件: <code>export default {}</code></li><li>data必须是个函数，否则就是单实例，模板在多处使用表现将一致。</li><li>使用<code>scoped</code>来使style只在当前组件生效</li></ol><p>vue基本指令：</p><p>语法：</p><ol><li>可以根据data中返回的值，动态渲染文本。</li><li>只能是单行语句。比如<code>if(0&lt;10){return '对的'} else{return '错的'}</code>和<code>let a = 10</code>都不能使用。</li><li>不能作用在HTML属性上，遇到这种情况应该使用<code>v-bind</code>指令。</li></ol><ul><li>v-html：遇到包含HTML的字符串，可以对HTML进行解析</li><li>v-text：遇到包含HTML的字符串，不解析其中的HTML</li></ul><p>v-bind用来使HTML属性中的字符串成为一个变量，可在data中定义，并动态赋值，使之变化。</p><ul><li><code>v-if</code>、<code>v-else</code>、<code>v-else-if</code></li><li><code>v-if</code>和<code>v-show</code>的区别：<code>v-if</code>是通过js创建和消除元素，在DOM层级上。<code>v-show</code>是通过调整css来显示和不显示元素，在样式层级上。</li></ul><p>computed和methods的区别：computed是基于依赖缓存的，如果依赖没有变，就直接返回上次计算的结果。methods则每次都进行计算，浪费性能。</p><p><code>v-model</code>双向数据绑定，常用的场景有：输入框给data里的变量赋值，然后用另一个标签显示这个变量，也就是这个变量是可读可写的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"msg"</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="父子组件数据交互"><a class="header-anchor" href="#父子组件数据交互"> </a>父子组件数据交互</h2><p>父 -&gt; 子：props<br>数据传递类型限制（验证）</p><ul><li>数据类型验证</li><li>多数据类型验证</li><li>必选项</li><li>默认值</li><li>obj、arr数据类型的默认值</li></ul><p>子 -&gt; 父：emit Event</p>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>《CSAPP》读书笔记 -- 第4章：处理器体系结构</title>
      <link href="/blog/2018/10/13/%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
      <url>/blog/2018/10/13/%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
      <content type="html"><![CDATA[<p>阅读这篇文章必须要对汇编码有足够的了解，如果你对IA32汇编码还不够了解，可以先看看这篇文章：<a href="../../08/%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA">程序的机器级表示</a></p><h2 id="y86指令集体系结构"><a class="header-anchor" href="#y86指令集体系结构"> </a>Y86指令集体系结构</h2><p>Y86指令集基本上是IA32指令集的一个子集。这个指令集就是我们处理器实现的目标。如下图：</p><p><img src="../../../../images/2018/Y86%E6%8C%87%E4%BB%A4%E9%9B%86.png" alt="Y86指令集"></p><p>IA32的movl指令分成了4个不同指令：irmovl、rrmovl、mrmovl和rmmovl，i表示立即数Immediate，r表示寄存器Register，m表示存储器Memmory。第一个字母表示源，第二个字母表示目的。</p><p>这里不实现的功能有：</p><ol><li>存储器引用方式是简单的基址+偏移量形式，不支持变址寄存器（second index register）和任何寄存器伸缩（scaling）。</li><li>和IA32一样不允许从一个存储器直接传送到另一个存储器地址。</li><li>不允许立即数传送到存储器</li></ol><p>4个整数操作指令：addl、subl、andl、xorl</p><p>7个跳转指令：jmp、jle、jl、je、jne、jge、jg。</p><p>6个条件传送指令：cmovle、cmovl、cmove、cmovne、cmovge、cmovg。</p><p>另外还有：call、ret、pushl、popl，halt指令停止指令执行。IA32中有一个与之相当的指令hlt，IA32的应用程序不允许使用这条指令，因为它会导致整个系统暂停运行。对于Y86来说，执行halt指令会导致处理器停止，并将状态码设置为HLT。</p><h3 id="指令编码"><a class="header-anchor" href="#指令编码"> </a>指令编码</h3><p>与IA32一样使用小端编码。</p><p><img src="../../../../images/2018/%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81.png" alt="指令编码"></p><p>每条指令的第一个字节表明指令的类型，这个字节分为两部分，每部分4位：高4位是代码（code）部分，低4位是功能（function）部分。代码值为 0~0xB。可以观察到，<code>rrmovl</code>与条件传送指令有同样的指令代码，可以把它看作是一个无条件传送，就好像jmp指令是无条件跳转一样，它们的功能代码都是0。</p><p>寄存器编码如下：</p><p><img src="../../../../images/2018/%E5%AF%84%E5%AD%98%E5%99%A8%E7%BC%96%E7%A0%81.png" alt="寄存器编码"></p><p>举个例子：用16进制表示指令 <code>rmmvol %esp, 0x12345(%edx)</code>的字节编码。</p><p>从上面图中可以看到，rmmovl第一个字节为40，由于%esp是4（占4位），%edx是2（占4位），所以第二个字节是42，最后再加上偏移量 00 01 23 45，小端表示是：45 23 01 00，所以最后得到指令的编码是：<code>404245230100</code>。</p><p>指令集的一个重要性质是字节编码必须有唯一解释，任意一个字节序列要么是一个唯一的指令，要么是一个不合法的指令。</p><p>相比于IA32，Y86没那么紧凑，IA32对寄存器只用了3位来编码，5位表明指令类型，所以IA32能将出栈入栈放进一个字节里。另外IA32可以将常数值编码成1、2、4字节，Y86总是编码成4字节。</p><h3 id="risc-和-cisc"><a class="header-anchor" href="#risc-和-cisc"> </a>RISC 和 CISC</h3><ul><li>RISC: reduced instruction set computers，精简指令集</li><li>CISC: complex instruction set computers，复杂指令集</li></ul><h2 id="y86异常"><a class="header-anchor" href="#y86异常"> </a>Y86异常</h2><p><img src="../../../../images/2018/Y86%E5%BC%82%E5%B8%B8.png" alt="Y86异常"></p><p>对于Y86，当遇到这些异常的时候，我们简单的让处理器停止执行指令。在更完善的设计中，处理器通常会调用一个 exception handler（异常处理程序），这个过程被指定用来处理遇到的某种类型的异常，例如放弃程序或调用一个用户自定义的 signal handler（信号处理程序）。</p><h2 id="y86程序"><a class="header-anchor" href="#y86程序"> </a>Y86程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sum</span><span class="params">(<span class="keyword">int</span> *Start, <span class="keyword">int</span> Count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (Count) &#123;</span><br><span class="line">        sum += *Start;</span><br><span class="line">        Start++;</span><br><span class="line">        Count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="../../../../images/2018/IA32%E5%AF%B9%E6%AF%94Y86%E4%BB%A3%E7%A0%81.png" alt="IA32对比Y86代码"></p><p>可以看到Y86有时候需要两条指令来完成IA32一条指令就能完成的事。然而如果用数组索引来写这个程序，要转换成Y86会很困难，因为Y86没有伸缩寻址。</p><p>完整代码如下：</p><p><img src="../../../../images/2018/Y86%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81.png" alt="Y86汇编代码"></p><p>以<code>.</code>开头的是 assembler directive（汇编器命令），命令<code>.pos 0</code>告诉汇编器应该从地址0处开始产生代码。第3、4行使用的Stack标签，在最后有声明，其位置是0x100。第9到13行声明了一个数组，4字节对齐，值分别是：0xd，0xc0，0xb00，0xa000，array标签是起址。</p><blockquote><p>细节问题，<code>pushl %esp</code>（这个指令只能用汇编语言写，C语言无法产生）是先把%esp的值转移到栈，还是先%esp减4再将结果转移到栈，实际上不同版本的intel处理器都会产生不同的结果，所以一个很重要的教训是<br>要保证细节上的一贯性。</p></blockquote><h2 id="逻辑设计和硬件控制语言hcl"><a class="header-anchor" href="#逻辑设计和硬件控制语言hcl"> </a>逻辑设计和硬件控制语言HCL</h2><p><img src="../../../../images/2018/%E9%80%BB%E8%BE%91%E9%97%A8.png" alt="逻辑门"></p><p>构建一个组合电路有两条限制：</p><ol><li>两个或多个逻辑门的输出不能连接在一起。这样会导致线上的信号矛盾，产生不合法的电压或电路故障。</li><li>必须是无环的，也就是不能形成回路。</li></ol><p>下面是个简单的例子：</p><p><img src="../../../../images/2018/%E7%BB%84%E5%90%88%E7%94%B5%E8%B7%AF.png" alt="组合电路"></p><p>用HCL来写这个网的函数就是：<code>bool eq = (a &amp;&amp; b) || (!a &amp;&amp; !b)</code></p><p>HCL是用来C语言风格的语法，但这里同C语言不一样，该语句的意思不是执行了一次计算并将结果放入存储器，而是使用一个名字eq来称谓一个表达式。</p><p>实际上上面的组合电路就是同或，异或的表达式是：<code>bool eq = (!a &amp;&amp; b) || (a &amp;&amp; !b)</code></p><p>多路复用器（multiplexor，通常称为：MUX）：</p><p><img src="../../../../images/2018/MUX%E7%BB%84%E5%90%88%E7%94%B5%E8%B7%AF.png" alt="MUX组合电路"></p><p><code>bool out = (s &amp;&amp; a) || (!s &amp;&amp; b)</code></p><h3 id="字级的组合电路和hcl整数表达式"><a class="header-anchor" href="#字级的组合电路和hcl整数表达式"> </a>字级的组合电路和HCL整数表达式</h3><p>字级与电路：</p><p><img src="../../../../images/2018/%E5%AD%97%E7%BA%A7%E4%B8%8E%E7%94%B5%E8%B7%AF.png" alt="字级与电路"></p><p><code>bool Eq = (A == B);</code></p><p>也可以用异或来实现：</p><p><img src="../../../../images/2018/%E5%AD%97%E7%BA%A7%E5%BC%82%E6%88%96%E7%94%B5%E8%B7%AF.png" alt="字级异或电路"></p><p>字级多路复用电路：</p><p><img src="../../../../images/2018/%E5%AD%97%E7%BA%A7%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%94%B5%E8%B7%AF.png" alt="字级多路复用电路"></p><p>用HCL来描述就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int Out = [</span><br><span class="line">    s: A;</span><br><span class="line">    1: B;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>四路复用器：</p><p><img src="../../../../images/2018/%E5%9B%9B%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%99%A8.png" alt="四路复用器"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int Out4 = [</span><br><span class="line">    !s1 &amp;&amp; !s0: A; # 00</span><br><span class="line">    !s1       : B; # 01</span><br><span class="line">    !s0       : C; # 10</span><br><span class="line">    1         : D; # 11</span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>第二个表达式可以写成<code>!s1</code>，而不用写的更完整<code>!s1&amp;&amp;s0</code>，是因为另一种可能<code>s0=0</code>已经出现在了第一个选择表达式了，若能到达第二个选择表达式，则<code>s0=1</code>。类似的，第三个表达式可以写成<code>!s0</code>，第四个表达式可以简单的写成1。</p>]]></content>
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 《CSAPP》 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>《CSAPP》读书笔记 -- 第3章：程序的机器级表示</title>
      <link href="/blog/2018/10/08/%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/"/>
      <url>/blog/2018/10/08/%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/</url>
      <content type="html"><![CDATA[<h2 id="从编译c语言文件说起"><a class="header-anchor" href="#从编译c语言文件说起"> </a>从编译C语言文件说起</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc <span class="number">-01</span> -o p p1.c p2.c</span><br></pre></td></tr></table></figure><p>使用了gcc命令来编译，也可以简单写作：<code>cc</code>。</p><p>优化层级为1，1级是最低的，层级越高程序优化越好，但增加了编译时间，也使调试变得更难，且跟源程序差异很大不便于理解。</p><p>编译的流程是：</p><ol><li>预处理器（preprocessor）把诸如：<code>#include</code>、<code>#define</code>、<code>#if</code>、<code>#else</code>、<code>#elif</code>、<code>#ifdef</code>、<code>#endif</code>等预编译指令替换掉。</li><li>编译器（compiler）把<code>.c</code>源文件编译成<code>.s</code>的汇编代码文件。</li><li>汇编器（assembler）把汇编代码文件转换成相应的二进制目标文件<code>.o</code>，目标文件已经是机器码了，只是没有填入全局变量的地址。</li><li>链接器（linker），把多目标文件和库函数链接在一起，形成可执行文件。</li></ol><p><strong>instruction set architecture，ISA，指令集体系结构</strong>，定义了处理器状态，指令的格式和行为。intel的指令集包括32位的：IA32，以及64位的：x86-64。</p><p>编译器做了整个编译流程的大部分工作，汇编代码几乎就是机器码的供人阅读版。所以看懂汇编代码是关键。</p><p>IA32程序代码和C语言很不相同，一些在C语言下看不到的处理器状态可以在这里看到：</p><ul><li>程序计数器（program counter，PC，也叫：instructor pointer，IP）在IA32中叫：<code>%eip</code>，指出下一条指令在内存中的位置</li><li>整数寄存器，可以用来保存数据</li><li>状态码寄存器，可以用来实现条件控制代码如：if和while</li><li>浮点寄存器，用来计算浮点数</li></ul><h2 id="例子"><a class="header-anchor" href="#例子"> </a>例子</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> accum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = x + y;</span><br><span class="line">    accum += t;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要看到编译出的汇编代码，可以使用<code>-S</code>选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -01 -S code.c</span><br></pre></td></tr></table></figure><p>这样就会使编译流程停留在 <strong>预处理-&gt;编译</strong> 阶段，而不是继续进行接下来的汇编和链接，生成的文件是：<code>.s</code>汇编文件。编译后的汇编代码中会包含如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sum:</span><br><span class="line">    pushl %ebp</span><br><span class="line">    movl %esp, %ebp</span><br><span class="line">    movl 12(%ebp), %eax</span><br><span class="line">    addl 8(%ebp), %eax</span><br><span class="line">    addl %eax, accum</span><br><span class="line">    popl %ebp</span><br><span class="line">    ret</span><br></pre></td></tr></table></figure><p>这段代码中的每一句都对应一个机器指令，比如pushl这句的意思就是把寄存器%ebp的内容push到程序栈（内存中）上。<strong>在汇编代码里所有的局部变量都不见了，全局变量还可以看到，因为编译器还没有决定这个变量在内存中的存储位置。</strong></p><p>如果我们使用<code>-c</code>选项，GCC就会既编译又汇编：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -01 -c code.c</span><br></pre></td></tr></table></figure><p>这样就生成了目标文件<code>code.o</code>，在800bytes的code.o文件中，有17bytes是对应上面的汇编代码的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">55 89 e5 8b 45 0c 03 45 08 01 05 00 00 00 00 5d c3</span><br></pre></td></tr></table></figure><p>可以使用反汇编将难懂的目标文件代码转成汇编代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ objdump -d code.o</span><br></pre></td></tr></table></figure><p><img src="../../../../images/2018/%E5%8F%8D%E6%B1%87%E7%BC%96.png" alt="反汇编"></p><ul><li>IA32指令的长度是1到15字节，越常用的，操作数越少的指令越短，反之则越长。</li><li>给定一个开始的位置，只对应一种机器指令，比如只有<code>pushl %ebp</code>指令是以55开头的</li><li>反汇编只需要根据目标文件就可以翻译出汇编文件</li><li>反汇编出来的文件跟直接编译的汇编文件有些不一样，比如所有指令都省略了后缀<code>l</code>。<code>l</code>是大小指示符，而大多数情况下是可以省略l的。</li></ul><blockquote><p>头两个属性跟<a href="https://zh.wikipedia.org/wiki/%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81" target="_blank" rel="noopener">哈夫曼编码</a>的原理是一致的，可以说这是一种通用的编码原则，第一条用来保证节省字节空间，第二条则保证编码的唯一性。</p></blockquote><p>生成真正可执行的文件还需要链接操作，而且必须包含main函数。假设我们的<code>main.c</code>文件如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sum(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用如下指令生成可执行文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -01 -o prog code.o main.c</span><br></pre></td></tr></table></figure><p>prog文件增长到了9123bytes，因为它不仅包含我们写的代码，而且包含了用来开始和结束的程序，以及与操作系统进行交互的程序。</p><p><img src="../../../../images/2018/%E9%93%BE%E6%8E%A5%E4%B9%8B%E5%90%8E%E7%9A%84%E5%8F%8D%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%811.png" alt="链接之后的反汇编代码1"></p><p><img src="../../../../images/2018/%E9%93%BE%E6%8E%A5%E4%B9%8B%E5%90%8E%E7%9A%84%E5%8F%8D%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%812.png" alt="链接之后的反汇编代码2"></p><p>可以看到第6行，全局变量在链接的时候定址。</p><h2 id="汇编代码的格式"><a class="header-anchor" href="#汇编代码的格式"> </a>汇编代码的格式</h2><p>假设我们有一个C语言文件<code>simple.c</code>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">simple</span><span class="params">(<span class="keyword">int</span> *xp, <span class="keyword">int</span> y)</span> 2</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = *xp + y;</span><br><span class="line">    *xp = t;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以得到如下汇编代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">.file   &quot;simple.c&quot;</span><br><span class="line">  .text</span><br><span class="line">.globl simple</span><br><span class="line">  .type   simple, @function</span><br><span class="line">simple:</span><br><span class="line">  pushl   %ebp</span><br><span class="line">  movl    %esp, %ebp</span><br><span class="line">  movl    8(%ebp), %edx</span><br><span class="line">  movl    12(%ebp), %eax</span><br><span class="line">  addl    (%edx), %eax</span><br><span class="line">  movl    %eax, (%edx)</span><br><span class="line">  popl    %ebp</span><br><span class="line">  ret</span><br><span class="line">  .size   simple, .-simple</span><br><span class="line">  .ident  &quot;GCC: (Ubuntu 4.3.2-1ubuntu11) 4.3.2&quot;</span><br><span class="line">  .section        .note.GNU-stack,&quot;&quot;,@progbits</span><br></pre></td></tr></table></figure><p>所有以<code>.</code>开头的行都是用来指导汇编器和链接器的，我们不用去管。而这段代码的大概意思如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">simple:</span><br><span class="line">    pushl %ebp           保存帧指针</span><br><span class="line">    movl  %esp, %ebp     创建新的帧指针</span><br><span class="line">    movl  8(%ebp), %edx  从内存中读取xp</span><br><span class="line">    movl  12(%ebp), %eax 从内存中读取y</span><br><span class="line">    addl  (%edx), %eax   *xp+y=t</span><br><span class="line">    movl  %eax, (%edx)   把t存到xp指向的地址中</span><br><span class="line">    popl  %ebp           重新获取帧指针</span><br><span class="line">    ret                  返回</span><br></pre></td></tr></table></figure><blockquote><p>这段代码对%ebp和%esp的操作涉及到了程序栈模型，看不懂很正常，文章下面会有讲解的。</p></blockquote><h3 id="att和intel汇编格式"><a class="header-anchor" href="#att和intel汇编格式"> </a>ATT和intel汇编格式</h3><p>ATT即AT&amp;T，是贝尔实验室旗下的公司。</p><p>GCC和OBJDUMP默认生成ATT格式的汇编代码，微软和因特尔的编程工具则默认生成intel格式的汇编代码。</p><p>使用如下命令可以让GCC生成intel格式的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -01 -S -masm=intel code.c</span><br></pre></td></tr></table></figure><p>两者的区别如下：</p><ul><li>intel代码省略了用来指定大小的后缀，比如使用<code>mov</code>而不是<code>movl</code></li><li>intel代码省略了寄存器前面的%，比如使用<code>esp</code>而不是<code>%esp</code></li><li>intel代码用了不同的方式来描述内存地址，比如使用<code>DWORD PTR [ebp+8]</code>而不是<code>8(%ebp)</code></li><li>intel代码多操作数指令的操作数顺序跟ATT相反</li></ul><p>由于是由16bit架构扩展到32bit架构的，intel管16bit数据类型叫：<code>word</code>，32bit数据类型叫：<code>double words</code>，64bit数据类型叫：<code>quad words</code>。</p><h2 id="数据格式"><a class="header-anchor" href="#数据格式"> </a>数据格式</h2><p><img src="../../../../images/2018/%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F.png" alt="数据格式"></p><h2 id="访问数据"><a class="header-anchor" href="#访问数据"> </a>访问数据</h2><p>IA32 CPU 包含了8个寄存器，每个有32bit存储空间，用来存储整形值以及指针。</p><p><img src="../../../../images/2018/IA32%E5%AF%84%E5%AD%98%E5%99%A8.png" alt="IA32寄存器"></p><p>x86-64则进一步扩展了这些寄存器：</p><p><img src="../../../../images/2018/x86-64%E5%AF%84%E5%AD%98%E5%99%A8.jpg" alt="x86-64寄存器"></p><p>前六个寄存器称为通用寄存器，有其特定的用途：</p><ul><li>%rax(%eax) 用于做累加，过程调用返回值</li><li>%rcx(%ecx) 用于计数</li><li>%rdx(%edx) 用于保存数据</li><li>%rbx(%ebx) 用于做内存查找的基础地址</li><li>%rsi(%esi) 用于保存源索引值</li><li>%rdi(%edi) 用于保存目标索引值</li></ul><h3 id="操作数指示符"><a class="header-anchor" href="#操作数指示符"> </a>操作数指示符</h3><p><img src="../../../../images/2018/%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8C%87%E7%A4%BA%E7%AC%A6.png" alt="操作数指示符"></p><p>有三种类型的操作数，立即数(Imm)、寄存器值(Reg)、内存值(Mem)。</p><h3 id="mov指令"><a class="header-anchor" href="#mov指令"> </a>mov指令</h3><p><img src="../../../../images/2018/mov%E6%8C%87%E4%BB%A4.png" alt="mov指令"></p><p><img src="../../../../images/2018/%E6%B1%87%E7%BC%96%E6%A0%88%E6%93%8D%E4%BD%9C.png" alt="汇编栈操作"></p><p><code>pushl %ebp</code>指令等价于下面的指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subl $4,%esp     减小栈指针</span><br><span class="line">movl %ebp,(%esp) 把%ebp中的数据写到%esp指向的内存中</span><br></pre></td></tr></table></figure><p><code>popl %eax</code>指令等价于下面的指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">movl (%esp), %ebp  把%esp指向的内存地址中的值读到%eax中</span><br><span class="line">addl $4, %esp      增加栈指针</span><br></pre></td></tr></table></figure><h2 id="算术和逻辑操作"><a class="header-anchor" href="#算术和逻辑操作"> </a>算术和逻辑操作</h2><p>load effective address，leal指令，实际上是一个movl指令。</p><p><img src="../../../../images/2018/%E7%AE%97%E6%9C%AF%E5%92%8C%E9%80%BB%E8%BE%91%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4.png" alt="算术和逻辑操作指令"></p><p>多个操作数的指令，注意一下两个操作数的顺序即可</p><h3 id="位移操作"><a class="header-anchor" href="#位移操作"> </a>位移操作</h3><p>位移的值是用一个单字节来表示，且数值只能是0到31，所以这个字节只有低五位才会被考虑。</p><h3 id="扩展乘除指令"><a class="header-anchor" href="#扩展乘除指令"> </a>扩展乘除指令</h3><p><img src="../../../../images/2018/%E6%89%A9%E5%B1%95%E4%B9%98%E9%99%A4%E6%93%8D%E4%BD%9C.png" alt="扩展乘除操作"></p><h2 id="控制"><a class="header-anchor" href="#控制"> </a>控制</h2><h3 id="状态码"><a class="header-anchor" href="#状态码"> </a>状态码</h3><p>使用单比特的状态码来描述算数和逻辑运算的状态。最常用的状态码如下：</p><ul><li>CF: carry flag 进位符，用来表示最高位的进位。通常用来检测无符号运算的溢出</li><li>ZF: zero flag，零标志符，最近的操作产生了0</li><li>SF: sign flag，符号位，最近的操作产生了负数</li><li>OF: overflow flag，溢出符，补码溢出，正负都可以，表示有符号溢出</li></ul><p><img src="../../../../images/2018/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E6%8C%87%E4%BB%A4.png" alt="流程控制指令"></p><p>举个例子：t=a+b，a、b、t都是整形数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CF: (unsigned)t&lt;(unsigned)a       无符号溢出</span><br><span class="line">ZF: (t==0)                        零</span><br><span class="line">SF: (t&lt;0)                         负数</span><br><span class="line">OF: (a&lt;0 == b&lt;0) &amp;&amp; (t&lt;0 != a&lt;0)  有符号溢出</span><br></pre></td></tr></table></figure><blockquote><p>OF的表达式也可以写作：(a&lt;0 &amp;&amp; b&lt;0 &amp;&amp; t&gt;0) || (a&gt;0 &amp;&amp; b&gt;0 &amp;&amp; t&lt;0)，也就是说a、b都是负数相加却是正数，或者a、b都是正数相加却是负数，这两种情况就代表溢出了。</p></blockquote><p>leal操作不会改变状态码，因为这个指令只是用来计算地址。除此之外表3.7中的所有操作都可能改变状态码。例如逻辑操作：XOR，会使CF和OF置零，移位操作会使CF置为最后一个移位出去的bit，但OF要置零。自增和自减指令会设置OF和ZF，不设置CF。</p><p>CMP指令类似于SUB指令，但只修改状态码而不改变其他寄存器，如果两个操作数相等，ZF就会被设置；TEST指令类似于AND指令，但只修改状态码而不改变其他寄存器，如果两个操作数是重复的： testl %eax,%eax，作用是检测%eax是0，还是正数，还是负数。</p><h3 id="访问状态码"><a class="header-anchor" href="#访问状态码"> </a>访问状态码</h3><p>有三种常用的方式访问状态码：</p><ol><li>根据几个状态码的逻辑组合，设置单个字节为0或1，也就是set指令</li><li>根据状态码，跳转到程序的其他分支</li><li>根据状态码传送数据</li></ol><p><img src="../../../../images/2018/set%E6%8C%87%E4%BB%A4.png" alt="set指令"></p><p>举个例子：计算<code>a&lt;b</code>，a和b都是int型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a is in %edx, b is in %eax</span><br><span class="line">cmpl   %eax, %edx       Compare a:b</span><br><span class="line">setl   %al              Set low order byte of %eax to 0 or 1</span><br><span class="line">movzbl %al, %eax        Set remaining byte of %eax to 0</span><br></pre></td></tr></table></figure><p>setl 指令是：<code>D &lt;- SF^OF</code>，也就是有两种情况代表 <code>a-b&lt;0</code>：</p><ol><li>OF=0（a-b没有发生溢出），且SF=1（a-b结果为负）</li><li>OF=1（a-b发生了溢出），且SF=0（a-b结果为非负）</li></ol><p>第二种情况比较复杂，需要简单分析一下。a-b发生了溢出，有两种情况：<strong>正溢出和负溢出</strong>。负溢出：a是负数，b是正数，但a-b结果为正（结果小于了最小的负数，发生溢出）；正溢出：a是正数，b是负数，但a-b结果为负（结果大于了最大的正数，发生溢出）。</p><p>比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-128： 1000 0000</span><br><span class="line">127:   0111 1111</span><br><span class="line">-127:  1000 0001</span><br></pre></td></tr></table></figure><p>a=-128, b=127, a-b=-128-127= $(1 0000 0001)_2$ , 从结果上来看就变成了1（正数），这就是负溢出</p><p>a=127, b=-127, a-b=127-(-127) = $(1111 1110)_2$ , 从结果上来看就变成了 -2（负数），这就是正溢出</p><p>OF=1, SF=0，就是负溢出，而负溢出代表着a是负数，b是正数，也就是<code>a&lt;b</code></p><p>其他三个有符号比较以此类推。</p><h3 id="跳转指令"><a class="header-anchor" href="#跳转指令"> </a>跳转指令</h3><p><img src="../../../../images/2018/%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4.png" alt="跳转指令"></p><p>可以看到条件跳转必须是直接的，而无条件跳转可以使用操作数。</p><p>跳转位置的编码有两种：</p><ol><li>借助PC使用相对定位</li><li>使用绝对定位</li></ol><p>实例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jle .L2                  if &lt;=, goto dest2</span><br><span class="line">  .L5:                   dest1:</span><br><span class="line">  movl %edx, %eax</span><br><span class="line">  sarl %eax</span><br><span class="line">  subl %eax, %edx</span><br><span class="line">  leal (%edx,%edx,2), %edx</span><br><span class="line">  testl %edx, %edx</span><br><span class="line">jg .L5                   if &gt;, goto dest1</span><br><span class="line">  .L2:                   dest2:</span><br><span class="line">   movl %edx, %eax</span><br></pre></td></tr></table></figure><p>目标文件和汇编文件对应如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">8: 7e 0d                 jle 17 &lt;silly+0x17&gt; Target = dest2</span><br><span class="line">a: 89 d0                 mov %edx,%eax dest1:</span><br><span class="line">c: d1 f8                 sar %eax</span><br><span class="line">e: 29 c2                 sub %eax,%edx</span><br><span class="line">10: 8d 14 52             lea (%edx,%edx,2),%edx</span><br><span class="line">13: 85 d2                test %edx,%edx</span><br><span class="line">15: 7f f3                jg a &lt;silly+0xa&gt; Target = dest1</span><br><span class="line">17: 89 d0                mov %edx,%eax dest2:</span><br></pre></td></tr></table></figure><p>对应的关系是：<code>0xd+0xa=0x17</code>，<code>0xf3+0x17=0xa</code>，为什么是加下一条指令的地址而不是当前指令呢？这个传统要追溯到计算机的早期实现，当时的处理器会在执行每一条指令之前先更新一下PC（program counter）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">804839c: 7e 0d           jle 80483ab &lt;silly+0x17&gt;</span><br><span class="line">804839e: 89 d0           mov %edx,%eax</span><br><span class="line">80483a0: d1 f8           sar %eax</span><br><span class="line">80483a2: 29 c2           sub %eax,%edx</span><br><span class="line">80483a4: 8d 14           52 lea (%edx,%edx,2),%edx</span><br><span class="line">80483a7: 85 d2           test %edx,%edx</span><br><span class="line">80483a9: 7f f3           jg 804839e &lt;silly+0xa&gt;</span><br><span class="line">80483ab: 89 d0           mov %edx,%eax</span><br></pre></td></tr></table></figure><p>从反汇编代码来看，<strong>跳转如果使用PC相对地址，则不管代码存储到内存中的哪个位置，跳转的地址都不需要修改，且需要的编码更短</strong>。</p><h3 id="翻译条件分支"><a class="header-anchor" href="#翻译条件分支"> </a>翻译条件分支</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(test-expr)</span><br><span class="line">  then-statement</span><br><span class="line">else</span><br><span class="line">  else-statement</span><br></pre></td></tr></table></figure><p>先写成等价的goto版本，然后就可以很轻松的转成汇编了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">t=test-expr;</span><br><span class="line">if(!t)</span><br><span class="line">  goto false;</span><br><span class="line">  then-statement</span><br><span class="line">  goto done;</span><br><span class="line">false:</span><br><span class="line">  else-statement</span><br><span class="line">done:</span><br></pre></td></tr></table></figure><p>从汇编的角度看 <code>&amp;&amp;短路</code> 原理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void cond(int a, int *p)</span><br><span class="line">&#123;</span><br><span class="line">  if (p &amp;&amp; a &gt; 0)</span><br><span class="line">  *p += a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a %ebp +8, p at %ebp +12</span><br><span class="line"></span><br><span class="line">movl 8(%ebp), %edx</span><br><span class="line">movl 12(%ebp), %eax</span><br><span class="line">testl %eax, %eax</span><br><span class="line">je .L3</span><br><span class="line">testl %edx, %edx</span><br><span class="line">jle .L3</span><br><span class="line">addl %edx, (%eax)</span><br><span class="line">.L3:</span><br></pre></td></tr></table></figure><p>可以看到第一个条件通不过的时候就跳过了第二个条件判断。</p><h3 id="循环"><a class="header-anchor" href="#循环"> </a>循环</h3><h4 id="do-while"><a class="header-anchor" href="#do-while"> </a>do while</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do</span><br><span class="line">  body-statement</span><br><span class="line">  while(test-expr)</span><br></pre></td></tr></table></figure><p>goto版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">loop:</span><br><span class="line">  body-statement</span><br><span class="line">  t = test-expr;</span><br><span class="line">  if (t)</span><br><span class="line">goto loop;</span><br></pre></td></tr></table></figure><p><img src="../../../../images/2018/while%E7%9A%84%E6%B1%87%E7%BC%96%E5%BD%A2%E5%BC%8F.png" alt="while的汇编形式"></p><h4 id="while"><a class="header-anchor" href="#while"> </a>while</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">while (test-expr)</span><br><span class="line">  body-statement</span><br></pre></td></tr></table></figure><p>先转成do while形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if (!test-expr)</span><br><span class="line">  goto done;</span><br><span class="line">do</span><br><span class="line">  body-statement</span><br><span class="line">  while (test-expr);</span><br><span class="line">done:</span><br></pre></td></tr></table></figure><p>在把do while转成goto版：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">t = test-expr;</span><br><span class="line">if (!t)</span><br><span class="line">  goto done;</span><br><span class="line">loop:</span><br><span class="line">  body-statement</span><br><span class="line">  t = test-expr;</span><br><span class="line">  if (t)</span><br><span class="line">    goto loop;</span><br><span class="line">done:</span><br></pre></td></tr></table></figure><h4 id="for"><a class="header-anchor" href="#for"> </a>for</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for (init-expr; test-expr; update-expr)</span><br><span class="line">  body-statement</span><br></pre></td></tr></table></figure><p>先转成while形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">init-expr;</span><br><span class="line">while (test-expr) &#123;</span><br><span class="line">  body-statement</span><br><span class="line">  update-expr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后转成do while形式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">init-expr;</span><br><span class="line">if (!test-expr)</span><br><span class="line">  goto done;</span><br><span class="line">do &#123;</span><br><span class="line">  body-statement</span><br><span class="line">  update-expr;</span><br><span class="line">&#125; while (test-expr);</span><br><span class="line">done:</span><br></pre></td></tr></table></figure><p>最后转成do while的goto版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">init-expr;</span><br><span class="line">t = test-expr;</span><br><span class="line">if (!t)</span><br><span class="line">  goto done;</span><br><span class="line">loop:</span><br><span class="line">  body-statement</span><br><span class="line">  update-expr;</span><br><span class="line">  t = test-expr;</span><br><span class="line">  if (t)</span><br><span class="line">    goto loop;</span><br><span class="line">done:</span><br></pre></td></tr></table></figure><h3 id="状态转移指令"><a class="header-anchor" href="#状态转移指令"> </a>状态转移指令</h3><p><img src="../../../../images/2018/%E7%8A%B6%E6%80%81%E8%A1%A8%E8%BE%BE%E5%BC%8F.png" alt="状态表达式"></p><p><img src="../../../../images/2018/%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4.png" alt="状态转移指令"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v = test-expr ? then-expr : else-expr;</span><br></pre></td></tr></table></figure><p>goto版：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (!test-expr)</span><br><span class="line">  goto false;</span><br><span class="line">v = true-expr;</span><br><span class="line">goto done;</span><br><span class="line">false:</span><br><span class="line">  v = else-expr;</span><br><span class="line">done:</span><br></pre></td></tr></table></figure><h3 id="switch"><a class="header-anchor" href="#switch"> </a>switch</h3><p>switch主要使用了跳转表：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">switch_eg</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result = x;</span><br><span class="line">  <span class="keyword">switch</span> (n) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">100</span>:</span><br><span class="line">      result *= <span class="number">13</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">102</span>:</span><br><span class="line">      result += <span class="number">10</span>;</span><br><span class="line">      <span class="comment">/* Fall through */</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">103</span>:</span><br><span class="line">      result += <span class="number">11</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">104</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="number">106</span>:</span><br><span class="line">      result *= result;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      result = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">switch_eg_impl</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* Table of code pointers */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> *jt[<span class="number">7</span>] = &#123;</span><br><span class="line">    &amp;&amp;loc_A, &amp;&amp;loc_def, &amp;&amp;loc_B,</span><br><span class="line">    &amp;&amp;loc_C, &amp;&amp;loc_D, &amp;&amp;loc_def,</span><br><span class="line">    &amp;&amp;loc_D</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">unsigned</span> index = n - <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">int</span> result;</span><br><span class="line">  <span class="keyword">if</span> (index &gt; <span class="number">6</span>)</span><br><span class="line">    <span class="keyword">goto</span> loc_def;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Multiway branch */</span></span><br><span class="line">  <span class="keyword">goto</span> *jt[index];</span><br><span class="line"></span><br><span class="line">  loc_def: <span class="comment">/* Default case*/</span></span><br><span class="line">    result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">  loc_C: <span class="comment">/* Case 103 */</span></span><br><span class="line">    result = x;</span><br><span class="line">    <span class="keyword">goto</span> rest;</span><br><span class="line"></span><br><span class="line">  loc_A: <span class="comment">/* Case 100 */</span></span><br><span class="line">    result = x * <span class="number">13</span>;</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">  loc_B: <span class="comment">/* Case 102 */</span></span><br><span class="line">    result = x + <span class="number">10</span>;</span><br><span class="line">    <span class="comment">/* Fall through */</span></span><br><span class="line"></span><br><span class="line">  rest: <span class="comment">/* Finish case 103 */</span></span><br><span class="line">    result += <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">  loc_D: <span class="comment">/* Cases 104, 106 */</span></span><br><span class="line">    result = x * x;</span><br><span class="line">    <span class="comment">/* Fall through */</span></span><br><span class="line"></span><br><span class="line">  done:</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编代码如下：</p><p><img src="../../../../images/2018/switch%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81.png" alt="switch汇编代码"></p><p><img src="../../../../images/2018/switch%E8%B7%B3%E8%BD%AC%E8%A1%A81.png" alt="switch跳转表1"></p><p><img src="../../../../images/2018/switch%E8%B7%B3%E8%BD%AC%E8%A1%A82.png" alt="switch跳转表2"></p><p>跳转表的步长是4</p><blockquote><p>.rodata的意思是：read only data</p></blockquote><h2 id="过程调用"><a class="header-anchor" href="#过程调用"> </a>过程调用</h2><p><img src="../../../../images/2018/%E7%A8%8B%E5%BA%8F%E6%A0%88%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" alt="程序栈内存结构"></p><p>有以下几个要点：</p><ol><li>栈是倒着长的</li><li>每个过程调用都有一个stack frame，栈帧</li><li>栈顶帧用两个指针来维护，一个是帧起址：%ebp，一个是栈指针：%esp指向栈顶。</li></ol><p>%esp在过程运行的时候可能会被抹掉，这时候可以通过%ebp来定位。</p><p>可以看到返回地址在每一帧的最后。而每一帧的第一个位置存放着上一帧的帧起址%ebp。帧的中间则放置局部变量、过程参数等值。</p><p>有以下几种情况会将局部变量放到栈帧中：</p><ol><li>局部变量多到寄存器放不下</li><li>局部变量是数组或者结构体，必须用到引用</li><li>局部变量使用了取址符<code>&amp;</code>，所以我们必须给它生成地址</li></ol><h3 id="转移控制"><a class="header-anchor" href="#转移控制"> </a>转移控制</h3><p><img src="../../../../images/2018/%E8%BD%AC%E7%A7%BB%E6%8E%A7%E5%88%B6%E6%8C%87%E4%BB%A4.png" alt="转移控制指令"></p><p>call指令的效果是：把返回地址push到栈中，然后跳到调用程序的地址（也就是把PC设置一下）。<strong>返回地址</strong>是汇编代码中call指令后面那条指令的地址。</p><p>ret指令把栈顶的返回地址pop出来，并跳转到这个地址。</p><p><img src="../../../../images/2018/%E7%A8%8B%E5%BA%8F%E8%B0%83%E7%94%A8%E6%A8%A1%E5%9E%8B.png" alt="程序调用模型"></p><h3 id="寄存器使用传统"><a class="header-anchor" href="#寄存器使用传统"> </a>寄存器使用传统</h3><p>%eax, %edx, %ecx是调用者保存寄存器。也就是说当过程Q被过程P调用，过程Q可以随意的写这三个寄存器，因为在调用Q之前P必须保存这三个寄存器的值。</p><p>%ebx, %esi, %edi是被调用者保存寄存器。也就是说在过程Q写这些寄存器之前，必须保存里面的值，并在return之前恢复原样。</p><h3 id="过程调用例子"><a class="header-anchor" href="#过程调用例子"> </a>过程调用例子</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int swap_add(int *xp, int *yp)</span><br><span class="line">&#123;</span><br><span class="line">  int x = *xp;</span><br><span class="line">  int y = *yp;</span><br><span class="line"></span><br><span class="line">  *xp = y;</span><br><span class="line">  *yp = x;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int caller()</span><br><span class="line">&#123;</span><br><span class="line">  int arg1 = 534;</span><br><span class="line">  int arg2 = 1057;</span><br><span class="line"></span><br><span class="line">  int sum = swap_add(&amp;arg1, &amp;arg2);</span><br><span class="line">  int diff = arg1 - arg2;</span><br><span class="line">  return sum * diff;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="../../../../images/2018/%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="过程调用内存模型"></p><p>一些编程语言，比如Pascal，提供了值传参和引用传参。但C语言只有值传参，C++提供了引用传参。C语言可以通过指针来实现引用传参。</p><p><img src="../../../../images/2018/%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81.png" alt="过程调用汇编代码"></p><p>总共申请了24字节的空间，8字节用来存局部变量，8字节用来存参数，还有8字节未使用。</p><blockquote><p>为什么要浪费8字节，原因是：内存对齐。GCC遵循一个x86编程方针：栈空间必须是16的整数倍，包括保存%ebp的4字节和返回地址的4字节。这里总共加起来是24字节，所以需要额外的8字节填充成32字节。</p></blockquote><p>swap_add的汇编代码如下：</p><p>分为三个部分：setup、body、finish</p><p>setup:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">swap_add:</span><br><span class="line">  pushl %ebp                  Save old %ebp</span><br><span class="line">  movl %esp, %ebp             Set %ebp as frame pointer</span><br><span class="line">  pushl %ebx                  Save %ebx</span><br></pre></td></tr></table></figure><p>首先要保存调用者的帧基指针，然后重新设置当前帧基指针，然后如果用到%ebx,%esi,%edi等寄存器就需要保存。</p><p>body:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">movl 8(%ebp), %edx            Get xp</span><br><span class="line">movl 12(%ebp), %ecx           Get yp</span><br><span class="line">movl (%edx), %ebx             Get x</span><br><span class="line">movl (%ecx), %eax             Get y</span><br><span class="line">movl %eax, (%edx)             Store y at xp</span><br><span class="line">movl %ebx, (%ecx)             Store x at yp</span><br><span class="line">addl %ebx, %eax               Return value = x+y</span><br></pre></td></tr></table></figure><p>获取参数，进行计算。</p><p>finish:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">popl %ebx                     Restore %ebx</span><br><span class="line">popl %ebp                     Restore %ebp</span><br><span class="line">ret                           Return</span><br></pre></td></tr></table></figure><p>恢复两个寄存器，同时%esp回到了上一个帧的栈顶，指向了返回地址，然后ret指令就可以把PC置为返回地址了，这样就完成了控制权的转移。</p><p>然后执行调用完swap_add之后的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">movl -4(%ebp), %edx</span><br><span class="line">subl -8(%ebp), %edx</span><br><span class="line">imull %edx, %eax</span><br><span class="line">leave</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>leave指令的作用是重置栈指针和帧指针，也可以使用popl来重置，很简单：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//使%esp指向%ebp的地址（也就是Saved %ebp那里）</span><br><span class="line">movl %ebp, %esp</span><br><span class="line">//popl指令会导致%esp+4，所以%esp之后会指向上一帧的帧尾（也就是Return Address那里），popl的内容则放到了%ebp里面</span><br><span class="line">popl %ebp</span><br></pre></td></tr></table></figure><p>而之后的<code>ret</code>指令继续将<code>Return Address</code> pop出来，并将<code>Return Address</code>放到PC中。</p><p>从这个例子我们可以看出，编译器遵循一组简单的惯例来管理栈结构。</p><ol><li>通过%ebp加偏移量（+8,+12,…）访问参数</li><li>通过push指令或者栈指针减偏移量来分配栈空间</li><li>在返回前恢复保存好的寄存器，并使栈指针指向调用者的返回地址（Return Address）</li></ol><p>数组、多维数组、结构体、联合体这些都比较简单，这里略过。</p><blockquote><p>要注意的点：只有call才会push一个返回地址，所以swap_add的栈帧中并没有返回地址，说明它没有调用其他函数</p></blockquote><h2 id="指针"><a class="header-anchor" href="#指针"> </a>指针</h2><p>每种数据类型都有对应的指针类型，但指针类型不是机器码的一部分，只是C语言提供的一种抽象，帮助程序员避免犯错。</p><h2 id="内存引用越界和缓冲区溢出"><a class="header-anchor" href="#内存引用越界和缓冲区溢出"> </a>内存引用越界和缓冲区溢出</h2><p>我们可以看到C语言对数组引用没有任何边界检查，而且栈里面既保存了局部变量又保存了寄存器值以及返回地址。所以一旦数组越界写就会破坏整个程序的运行。</p><p>看下面这个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Sample implementation of library function gets() */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">gets</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> c;</span><br><span class="line">  <span class="keyword">char</span> *dest = s;</span><br><span class="line">  <span class="keyword">int</span> gotchar = <span class="number">0</span>; <span class="comment">/* Has at least one character been read? */</span></span><br><span class="line">  <span class="keyword">while</span> ((c = getchar()) != <span class="string">'\n'</span> &amp;&amp; c != EOF) &#123;</span><br><span class="line">    *dest++ = c; <span class="comment">/* No bounds checking! */</span></span><br><span class="line">    gotchar = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *dest++ = <span class="string">'\0'</span>; <span class="comment">/* Terminate string */</span></span><br><span class="line">  <span class="keyword">if</span> (c == EOF &amp;&amp; !gotchar)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/* End of file or error */</span></span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Read input line and write it back */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">echo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">8</span>]; <span class="comment">/* Way too small! */</span></span><br><span class="line">  gets(buf);</span><br><span class="line">  <span class="built_in">puts</span>(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段C语言代码对应的汇编代码如下：</p><p><img src="../../../../images/2018/gets%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA.png" alt="gets缓冲区溢出"></p><p>分配数组空间的时候是直接固定了8字节，这里给buf分配的空间也是8字节：<code>leal -12(%ebp), %ebx</code>，并把buf作为参数放置于栈顶。</p><p><img src="../../../../images/2018/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="缓冲区溢出内存模型"></p><p>我们可以看到，当读写buf[8]的时候，实际上是在读写<code>Saved %ebx</code>。</p><p><img src="../../../../images/2018/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%94%BB%E5%87%BB%E8%8C%83%E5%9B%B4.png" alt="缓冲区攻击范围"></p><p>通常给被攻击的程序输入一个字符串，这个字符串包含了可执行代码的字节编码，如果我们通过缓冲区溢出修改了返回地址，那么ret指令就可以跳转到我们攻击代码的位置。</p><blockquote><p>蠕虫（worms）和病毒（viruses）的区别：相同点：都可以复制和传播自身，不同点：蠕虫可以自己运行，病毒是把自己加入到其他程序中，包括操作系统代码，病毒是不能独立运行的。</p></blockquote><h3 id="对抗缓冲区溢出攻击的方法"><a class="header-anchor" href="#对抗缓冲区溢出攻击的方法"> </a>对抗缓冲区溢出攻击的方法</h3><h4 id="栈随机化"><a class="header-anchor" href="#栈随机化"> </a>栈随机化</h4><p>攻击者需要插入攻击代码（一个字符串），并知道攻击代码的位置（也就是字符串存放的栈地址），而且指向这段字符串的指针也是这个字符串的一部分。如果栈的位置是固定的，那么就很容易猜到攻击代码的存放位置。用如下代码可以检测栈的位置：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> local;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"local at %p\n"</span>, &amp;local);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要打印一个局部变量的地址。</p><p>栈随机化的思想是程序每次运行时栈的位置都不一样，实现方式是：程序开始时，在栈上分配一段0~n字节之间的随机大小的空间，例如使用<code>alloca</code>可以在栈上分配空间。程序不使用这段空间，它的作用是使后续栈的位置发生变化。分配的n必须足够大，这样才能有足够多的变化，但又必须足够小，这样才不会浪费空间。</p><p>栈随机化是更大一类技术的一种，这类技术称为：Address-Space Layout Randomization，ASLR，地址空间布局随机化。但攻击者还是可以采取一定措施来增加攻击成功率，一种常见的手段就是在攻击代码前中插入很长一段的<code>nop</code>指令，这个指令只会使程序计数器（PC）加一，除此之外没有任何副作用。只要攻击者能够猜中这段序列中的某个地址，就可以顺利到达攻击代码。这个序列的常用术语是：<strong>nop sled空操作雪橇</strong>。</p><h4 id="栈破坏检测"><a class="header-anchor" href="#栈破坏检测"> </a>栈破坏检测</h4><p>在局部缓冲区和栈状态之间插入一个随机的金丝雀值（也叫哨兵值），一旦发现这个值被改变，就说明缓冲区溢出了，那么就可以将程序异常中止。</p><blockquote><p>攻击者只有输入局部缓冲区变量的权限，所以无从得知金丝雀值。</p></blockquote><p><img src="../../../../images/2018/%E9%87%91%E4%B8%9D%E9%9B%80%E5%80%BC.png" alt="金丝雀值"></p><p>GCC默认就会插入金丝雀值，如果不想要可以使用参数：<code>-fno-stack-protector</code>来阻止GCC产生这种代码。当不使用此参数时，产生代码如下：</p><p><img src="../../../../images/2018/%E5%90%AB%E9%87%91%E4%B8%9D%E9%9B%80%E5%80%BC%E6%B1%87%E7%BC%96%E7%A0%811.png" alt="含金丝雀值汇编码1"></p><p><img src="../../../../images/2018/%E5%90%AB%E9%87%91%E4%B8%9D%E9%9B%80%E5%80%BC%E6%B1%87%E7%BC%96%E7%A0%812.png" alt="含金丝雀值汇编码2"></p><p>指令参数<code>%gs20, %eax</code>指明金丝雀值使用 segmented addressing（段寻址）从存储器中读入。将段标志为只读，这样攻击者就不能同时修改段中的金丝雀值。最后使用<code>xorl</code>比较段和栈中的金丝雀值，如果不相等则<code>call __stack_chk_fail</code>。</p><p>这种做法可以带来很小的性能损失。</p><h4 id="限制可执行代码区域"><a class="header-anchor" href="#限制可执行代码区域"> </a>限制可执行代码区域</h4><p>在典型的程序中，只有保存编译器产生的代码的那一部分存储空间才需要是可执行的。其他部分可以被限制为只允许读写。虚拟存储器空间在逻辑上分成了页（page），典型的每页是 2048 或者 4096 字节。由硬件提供存储器保护。以前，x86体系结构将读和执行访问控制合并成一个1位标志，所以任何被标记为可读的部分也是可执行的，当然也有很多机制可以限制一些页是可读的但是不可执行，然而这些机制都很消耗性能。最近，AMD（Advanced Micro Devices）为它的64位处理器的内存加入了 NX, No-eXecute，不可执行位，intel也跟进了，检查页是否可执行由硬件来完成，效率上没有任何损失。</p>]]></content>
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 《CSAPP》 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>《CSAPP》读书笔记 -- 第2章：浮点数原理（小专题）</title>
      <link href="/blog/2018/09/27/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%8E%9F%E7%90%86/"/>
      <url>/blog/2018/09/27/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%8E%9F%E7%90%86/</url>
      <content type="html"><![CDATA[<p><strong>浮点数的作用</strong>：区别于整形数，用来表示小数。可以用来表示很大的数，或者非常接近0的小数，或者近似的做实数计算，浮点数的一般形式：$x\times 2^y$。</p><p>IEEE（pronounced “Eye-Triple-Eee”）浮点数标准。</p><p><strong>rounding</strong>：when a number cannot be represented exactly in the format and hence must be adjusted upward or down- ward。可以翻译为：<strong>舍入</strong>。</p><p>十进制的小数表示：$d_m d_{m-1} \cdots d_1 d_0 . d_{-1} d_{-2} \cdots d_{-n}$，写成数学表达式：</p><p>$$<br>d = \sum_{i=-n}^m 10^i \times d_i<br>$$</p><p>相应的，二进制也可以写成这种形式：</p><p>$$<br>b = \sum_{i=-n}^m 2^i \times b_i<br>$$</p><h1>浮点数的表示</h1><p>IEEE浮点数的格式：$V = (-1)^s \times M \times 2^E$</p><ul><li>s是符号（Sign），s为0时是正，s为1时是负</li><li>M是有效数字（Significand，即 <strong>尾数</strong>）</li><li>E是 <strong>指数</strong>，Exponent，也叫 <strong>幂数</strong>，<strong>阶码</strong></li><li>隐含的 <strong>基数</strong> 是2</li></ul><p>下图是浮点数的内存分布模型，首先是符号域，然后是指数域，最后是分数域：</p><p><img src="../../../../images/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="浮点数内存模型"></p><ul><li>符号位s个，符号位只需要一位，s=1</li><li>指数位k个，指数域 $exp=e_{k-1}\cdots e_1 e_0$，用来计算指数E</li><li>分数为n个，分数域 $frac=f_{n-1}\cdots f_1 f_0$，用来计算有效数字M</li></ul><p>32位浮点数（单精度，float型）中，s=1，k=8，n=23；64位浮点数（双精度，double型）中，s=1，k=11，n=52。</p><h2 id="正常化值-normalized-values"><a class="header-anchor" href="#正常化值-normalized-values"> </a>正常化值（Normalized Values）</h2><p>当 $exp$ 域既不是全0，也不是全1的时候，就是正常化值。</p><p>$E = e - Bias$，其中 $e$ 就是 $exp$ 域：$e_{k-1}\cdots e_1e_0$ 的值（除去全0和全1之后，取值范围是1到$2<sup>k-2$），$Bias=2</sup>{k-1}-1$（单精度的时候是127，双精度的时候是1023），那么 $E$ 的取值范围，单精度的时候是：<code>-126 ~ +127</code>，双精度的时候是：<code>-1022 ~ +1023</code>，其实 $E$ 的算法就是 <strong>移码</strong> 的计算方法。</p><p>$M = 1+f$，$0\le f\lt 1$，内存里只记录f，而1作为一个前导值计算时候再加上，所以f是分数域 $frac$ 的 $0.f_{n-1}\cdots f_1f_0$ 这种形式</p><h2 id="非正常化值-denormalized-values"><a class="header-anchor" href="#非正常化值-denormalized-values"> </a>非正常化值（Denormalized Values）</h2><p>当指数域全0，就是非正常化格式。</p><p>在这种情况下，指数值是 $E = 1-Bias$，也就是固定了，有效数字值 $M = f$ 也就是没有前导1了。这个格式下可以表示0，因为正常化值中，一定有： $M\ge 1$，所以我们无法在正常化值格式下表示0。当符号位是0，有效数字 $M=f=0$，我们得到的就是<code>+0.0</code>，当符号位是1的时候就是<code>-0.0</code>。</p><p>除了可以表示0，这个格式的另一个作用就是用来表示非常接近0的数。</p><h2 id="特殊值-special-values"><a class="header-anchor" href="#特殊值-special-values"> </a>特殊值（Special Values）</h2><p>当指数域全1的时候，且分数域是全0，就表示无穷大，如果符号域为0，表示 $+\infty$，如果符号位是1，则表示 $-\infty$。无穷大可以作为溢出的结果，当我们用两个很大的数相乘，或者除以0；</p><p>当指数域全1，且分数域并非全0的时候，结果可以叫做：<code>NaN</code>（Not a Number的简写），这种值用来表示不能用实数或者无穷大表示的计算结果，比如计算：$\sqrt{-1}$ 或者 $\infty - \infty$。</p><p>下图是在数轴上的显示：</p><p><img src="../../../../images/%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B8%89%E7%A7%8D%E7%B1%BB%E5%9E%8B.png" alt="浮点数三种类型"></p><p>可以看到非正常化值集中在0附近，正常化值散布在整个数轴的空间，特殊值则只表示两个无穷值。</p><p>下图是浮点数三种类型的光滑衔接：</p><p><img src="../../../../images/%E6%B5%AE%E7%82%B9%E6%95%B0%E4%B8%89%E7%A7%8D%E7%B1%BB%E5%9E%8B%E5%85%89%E6%BB%91%E8%A1%94%E6%8E%A5.png" alt="浮点数三种类型光滑衔接"></p><p>看完浮点数的设计和构造我们可以发现以下这些特点：</p><ul><li><strong>从编码上有效数字域采用了无符号整数编码，而指数域采用了移码编码</strong></li><li><strong>非正常化值均匀分布在0附近</strong></li><li><strong>正常化值的间隔随着 $2^E$ 变大而逐渐变大，也就是精度逐渐降低</strong></li><li><strong>精度是分组的，以 $2^E$ 增加1为一组，每组有 $2^n$ 个数（n是有效数字域的位数）</strong></li><li><strong>最高精度就是两个非正常化值的间隔，最低精度是最大的一组正常化值的相邻两数的间隔。</strong></li><li><strong>非正常化值按照精度只占一组，正常化值的数量是非正常化值数量的 $2^{k}-2$ 倍</strong></li><li><strong>正常化值的第一组的精度和非正常化值的精度一样，也就是实现了无缝衔接</strong></li></ul><h1>浮点数的计算</h1><h2 id="舍入"><a class="header-anchor" href="#舍入"> </a>舍入</h2><p><img src="../../../../images/%E8%88%8D%E5%85%A5%E5%9B%9B%E7%A7%8D%E7%AD%96%E7%95%A5.png" alt="舍入四种策略"></p><p><a href="https://en.wikipedia.org/wiki/Rounding" target="_blank" rel="noopener">Rounding维基百科</a></p><p><a href="https://upload.wikimedia.org/wikipedia/commons/8/8a/Comparison_rounding_graphs_SMIL.svg" target="_blank" rel="noopener">各种Rounding合集图</a></p><p>浮点数中使用的是：舍入到最近的偶数，因为舍入结果放大和缩小各占50%的概率，这样就可以防止最终结果偏大或者偏小。</p><p>下面是把浮点数舍入到小数点后两位数：</p><p>$10.00011_2(2\frac{3}{32})$ -&gt; $10.00_2(2)$ 不到一半，正常四舍五入<br>$10.00110_2(2\frac{3}{16})$ -&gt; $10.01_2(2\frac{1}{4})$ 超过一半，正常四舍五入<br>$10.11100_2(2\frac{7}{8})$ -&gt; $11.00_2(3)$ 正好一半，保证最后一位是偶数，所以向上舍入<br>$10.10100_2(2\frac{5}{8})$ -&gt; $10.10_2(2\frac{1}{2})$ 正好一半，保证最后一位是偶数，所以向下舍入</p><h2 id="浮点数加减运算"><a class="header-anchor" href="#浮点数加减运算"> </a>浮点数加减运算</h2><h3 id="基本性质"><a class="header-anchor" href="#基本性质"> </a>基本性质</h3><ul><li>相加可能产生 infinity 或者 NaN</li><li>不满足交换律，不满足结合律（因为舍入会造成精度上的损失）</li><li>加上0等于原来的数</li><li>除了 infinity 和 NaN，每个元素都有对应的相反数</li><li>除了 infinity 和 NaN，满足单调性，即 $a\ge b \rightarrow a+c\ge b+c$</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 浮点数加法不满足交换律</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">3.14</span> + <span class="number">1e20</span> - <span class="number">1e20</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">1e20</span> - <span class="number">1e20</span> + <span class="number">3.14</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 浮点数加法不满足结合律</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (<span class="number">3.14</span> + <span class="number">1e20</span>) - <span class="number">1e20</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">3.14</span> + (<span class="number">1e20</span> - <span class="number">1e20</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">3.14</span><br><span class="line">0</span><br><span class="line">3.14</span><br></pre></td></tr></table></figure><h3 id="具体细节"><a class="header-anchor" href="#具体细节"> </a>具体细节</h3><p>设两个浮点数 $x$ 和 $y$：</p><p>$$<br>\begin{cases}<br>x=(-1)^{s_x} M_x 2^{E_x} \<br>y=(-1)^{s_y} M_y 2^{E_y}<br>\end{cases}<br>$$</p><p>则浮点数加减运算结果为：</p><p>$$<br>x\pm y = \left((-1)^{s_x}M_x 2^{E_x-E_y} \pm (-1)^{s_y}M_y \right)2^{E_y}<br>$$</p><ol><li><strong>对阶</strong>：首先要把指数位（阶码）调成一样，并相应的使M移位，由于有效域左移会引起最高有效位丢失，误差大，所以采用右移，此时阶码要增加。所以对阶原则是：<strong>小阶向大阶看齐</strong>。</li><li><strong>有效数加减</strong>：简单的无符号数字相加减。</li><li><strong>规格化</strong>：有效数求和结果可能大于1，那么就向右规格化：尾数右移1位，阶码加1。</li><li><strong>舍入</strong>：对于右移出去的位，采取舍入</li><li><strong>检查阶码是否溢出</strong>：<ul><li><strong>阶码下溢</strong>：运算结果为非规格化数</li><li><strong>阶码上溢</strong>：置溢出标志</li></ul></li></ol><h3 id="浮点数加减实例"><a class="header-anchor" href="#浮点数加减实例"> </a>浮点数加减实例</h3><p>$x=3.14, y=2.718$ 求 $z=x+y$。</p><p>首先算出 $x$ 和 $y$ 的内存表示：</p><p>$x = 3+0.14$，3的二进制表示是<code>11</code>，0.14的二进制要稍微计算一下，我们让0.14不断的乘以2（也就是左移），得到的整数位部分就是其二进制值的一位：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0.14 * 2 = 0.28     0</span><br><span class="line">0.28 * 2 = 0.56     0</span><br><span class="line">0.56 * 2 = 1.12     1</span><br><span class="line">0.12 * 2 = 0.24     0</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br></pre></td></tr></table></figure><p>我们可以写个程序来完成这个计算工作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取整形数的位数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDigits</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(num/<span class="number">10</span>&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        num %= <span class="number">10</span>;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取小数的二进制表示</span></span><br><span class="line"><span class="comment"> * @params precision 二进制表示精确到多少位</span></span><br><span class="line"><span class="comment"> * @params num 小数的整数表示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">getFloatBitset</span><span class="params">(<span class="keyword">int</span> precision, <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* res = <span class="keyword">new</span> <span class="keyword">char</span>[precision];</span><br><span class="line">    <span class="keyword">int</span> digits = getDigits(num);</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="built_in">pow</span>(<span class="number">10</span>, digits);</span><br><span class="line">    <span class="keyword">char</span> printFormat[<span class="number">50</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(printFormat,<span class="string">"%%0.%df"</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// cout &lt;&lt; printFormat &lt;&lt;endl;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;precision;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(printFormat, num*<span class="number">1.0</span>/mod);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" * 2 = "</span>;</span><br><span class="line">        num &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(num &gt;= mod)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(printFormat, num*<span class="number">1.0</span>/mod);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"       1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            num %= mod;</span><br><span class="line">            res[i] = <span class="string">'1'</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(printFormat, num*<span class="number">1.0</span>/mod);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"       0"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            res[i] = <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取小数的二进制表示</span></span><br><span class="line"><span class="comment"> * @params precision 二进制表示精确到多少位</span></span><br><span class="line"><span class="comment"> * @params num 浮点型小数</span></span><br><span class="line"><span class="comment"> * @params digits 输入的时候浮点型小数的位数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">getFloatBitset2</span><span class="params">(<span class="keyword">int</span> precision, <span class="keyword">float</span> num, <span class="keyword">int</span> digits)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* res = <span class="keyword">new</span> <span class="keyword">char</span>[precision];</span><br><span class="line">    <span class="keyword">int</span> mod = <span class="built_in">pow</span>(<span class="number">10</span>,digits);</span><br><span class="line">    <span class="comment">// cout&lt;&lt;mod&lt;&lt;endl;</span></span><br><span class="line">    <span class="keyword">char</span> printFormat[<span class="number">50</span>];</span><br><span class="line">    <span class="built_in">sprintf</span>(printFormat,<span class="string">"%%0.%df"</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;precision;i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(printFormat, num);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" * 2 = "</span>;</span><br><span class="line">        num*=<span class="number">2</span>;</span><br><span class="line">        num = round(num*mod)/mod;</span><br><span class="line">        <span class="keyword">if</span>(num &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(printFormat, num);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"       1"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            num -= <span class="number">1</span>;</span><br><span class="line">            res[i] = <span class="string">'1'</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(printFormat, num);</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"       0"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            res[i] = <span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="comment">// char* res = getFloatBitset(atoi(argv[1]), atoi(argv[2]));</span></span><br><span class="line">    <span class="keyword">char</span>* res = getFloatBitset2(atoi(argv[<span class="number">1</span>]), atof(argv[<span class="number">2</span>]), atoi(argv[<span class="number">3</span>]));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码保存成：<code>float2Bitset.cpp</code>文件，然后编译，并使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -o float2Bitset float2Bitset.cpp</span><br><span class="line">$ ./float2Bitset 23 0.14 2</span><br></pre></td></tr></table></figure><p>小数位精确到23位的话，3.14的定点浮点数表示是：<code>11.00100011110101110000101</code>。</p><p>转成浮点数，首先规格化M，那么整体要右移1位，指数是1，由 $E = e-Bias$，$E=1$, $Bias=127$ 得 $e=128$，也就是：<code>1000 0000</code>。</p><p>最终3.14的内存表示是：<br>$$<br>\underbrace{0}_{Sign}<sub>\underbrace{10000000}_{Exponent}</sub>~\underbrace{10010001111010111000011}_{Significand}<br>$$</p><p>同样的方法得到2.718的内存表示：</p><p>$$<br>\underbrace{0}_{Sign}<sub>\underbrace{10000000}_{Exponent}</sub>~\underbrace{01011011111001110110110}_{Significand}<br>$$</p><p>这两个数恰好是同阶的，那么就不需要对阶操作了。将M相加，但这个数太长了看着眼花，我们写个加法程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将两个相同位数的二进制数相加</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">addBitset</span><span class="params">(<span class="keyword">char</span> num1[], <span class="keyword">char</span> num2[], <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>* res = <span class="keyword">new</span> <span class="keyword">char</span>[length+<span class="number">2</span>];</span><br><span class="line">    res[length+<span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=length<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        res[i+<span class="number">1</span>] = num1[i]-<span class="string">'0'</span>+num2[i]-<span class="string">'0'</span>+carry+<span class="string">'0'</span>;</span><br><span class="line">        carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(res[i+<span class="number">1</span>]&gt;<span class="string">'1'</span>)&#123;</span><br><span class="line">            res[i+<span class="number">1</span>] -= <span class="number">2</span>;</span><br><span class="line">            carry = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(carry)&#123;</span><br><span class="line">        res[<span class="number">0</span>]=<span class="string">'1'</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        res[<span class="number">0</span>]=<span class="string">'0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(argv[<span class="number">1</span>][i]!=<span class="string">'\0'</span>)&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">char</span>* res = addBitset(argv[<span class="number">1</span>], argv[<span class="number">2</span>], i);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码保存成：<code>addBitset.cpp</code>，编译并使用该程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -o addBitset addBitset.cpp</span><br><span class="line">$ ./addBitset 10010001111010111000011 01011011111001110110110</span><br></pre></td></tr></table></figure><p>相加结果等于：<code>0 11101101110100101111001</code>，最高位没有产生进位，这里用了一个0来代替，但两个前导1相加产生了进位，所以还需要对M右归一下，再对指数加1。所以加法结果的浮点数表示是：</p><p>$$<br>\underbrace{0}_{Sign}<sub>\underbrace{10000001}_{Exponent}</sub>~\underbrace{01110110111010010111101}_{Significand}<br>$$</p><p>这个数的十进制表示的计算方法是：$$2^2 \times (1+0\times (\frac{1}{2})^1 + 1\times (\frac{1}{2})^2 + 1\times (\frac{1}{2})^3 +1\times (\frac{1}{2})<sup>4+0\times(\frac{1}{2})</sup>5+\cdots)$$</p><p>我们依然采用程序来计算这一长串二进制对应的十进制小数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">bitset2Float</span><span class="params">(<span class="keyword">char</span>* num1, <span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> res = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">        <span class="keyword">double</span> temp = (num1[i]-<span class="string">'0'</span>)/<span class="built_in">pow</span>(<span class="number">2</span>,count);</span><br><span class="line">        <span class="comment">// cout &lt;&lt; temp &lt;&lt; endl;</span></span><br><span class="line">        res += temp;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(argv[<span class="number">1</span>][i]!=<span class="string">'\0'</span>)&#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> res = bitset2Float(argv[<span class="number">1</span>],i);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码保存为：<code>Bitset2float.cpp</code>，编译并执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -o Bitset2float Bitset2float.cpp</span><br><span class="line">$ ./Bitset2float 01110110111010010111101</span><br></pre></td></tr></table></figure><p>对得到结果：<code>0.4645</code>，$1.4645\times 2^2 = 5.858$，而 $3.14+2.718=5.858$，这就说明我们的计算无误。</p><h3 id="算法流程图"><a class="header-anchor" href="#算法流程图"> </a>算法流程图</h3><p><img src="../../../../images/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%8A%A0%E5%87%8F%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt="浮点数加减流程图"></p><p>这个流程图并不是完美的，真实的浮点数流程图和浮点数计算电路比这个复杂。另外我忘画了一个东西，这个图最后应该加上溢出处理模块，E可能会上溢（当E加1的时候），也可能会下溢（当E减1的时候）。</p><p>最后这个流程图中没有对特殊值的判断，比如：$\infty - \infty = NaN$, $\infty + \infty = \infty$, $NaN + 任何数 = NaN$。</p><p>了解了浮点数加法的流程之后，最后我们回到最上面说的 <strong>浮点数加减法不满足交换律和结合律</strong>，从计算细节分析为什么不行。</p><p>首先 3.14 的浮点数表示我们已经计算过了，那么 1e20 的浮点数是多少呢？1e20也就是 $10^{20}$，用辗转相除法可以得到其二进制表示。我们这里使用计算器工具</p><p><img src="../../../../images/10%E7%9A%8419%E6%AC%A1%E6%96%B9%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6.png" alt="10的19次方的二进制"></p><p>很遗憾的是64bit只能摆的下 $10^{19}$。我试了一下把源程序中的 1e20 换成 1e19 也是同样的结果。所以我们就使用 1e19 来分析这道题。</p><p>首先是M规格化，M右移63位，E加63，舍入M，那么 1e19 最终的双精度浮点数表示是：<code>0 10000111110 0001010110001110010001100000100100010011110100000000</code></p><p>小阶向大阶看齐，3.14的阶是1，M需要右移62位，而M的精度才52，可想而知M就是0了。那么 3.14 + 1e19 的结果就是 <strong>1e19</strong>。1e20就更加不用说了。</p><h2 id="浮点数乘除"><a class="header-anchor" href="#浮点数乘除"> </a>浮点数乘除</h2><h3 id="基本性质-v2"><a class="header-anchor" href="#基本性质-v2"> </a>基本性质</h3><ul><li>相乘可能产生 infinity 或者 NaN</li><li>不满足交换律，结合律，分配率（因为溢出会造成程序无法计算出正确的结果）</li><li>乘以1会等于原来的数</li><li>除了 infinity 和 NaN，满足单调性：$a\ge b \rightarrow a\times c \ge b \times c$</li></ul><h3 id="具体细节-v2"><a class="header-anchor" href="#具体细节-v2"> </a>具体细节</h3><p>设两个浮点数 $x$ 和 $y$ ：</p><p>$$<br>\begin{cases}<br>x = \pm M_x 2^{E_x} \<br>y = \pm M_y 2^{E_y}<br>\end{cases}<br>$$</p><p>则浮点数乘除运算结果是：</p><p>$$<br>xy = \pm (M_x\times M_y)2^{E_x\pm E_y}<br>$$</p><ol><li>计算阶码，判断是否溢出</li><li>求有效数的乘积</li><li>有效数舍入</li><li>计算符号位</li></ol><p>浮点数还有相当多的细节，可以参考：<a href="https://zh.wikipedia.org/wiki/IEEE_754" target="_blank" rel="noopener">IEEE 754</a></p>]]></content>
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 《CSAPP》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 信息记法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>wsl oh my zsh 字符乱码问题</title>
      <link href="/blog/2018/09/20/wsl%20oh%20my%20zsh%20%E5%AD%97%E4%BD%93%E9%97%AE%E9%A2%98/"/>
      <url>/blog/2018/09/20/wsl%20oh%20my%20zsh%20%E5%AD%97%E4%BD%93%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<h2 id="安装-oh-my-zsh"><a class="header-anchor" href="#安装-oh-my-zsh"> </a>安装 oh my zsh</h2><p>首先检查自己有没有zsh：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/shells</span><br></pre></td></tr></table></figure><p>如果有的话就下载<a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="noopener">oh my zsh</a></p><h2 id="设置默认shell"><a class="header-anchor" href="#设置默认shell"> </a>设置默认shell</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure><p>有可能会遇到设置不成功的问题，那么我们可以手动修改<code>/etc/passwd</code>，找到自己那一条配置信息，把默认shell改成<code>/bin/zsh</code>就OK了。</p><h2 id="字体问题"><a class="header-anchor" href="#字体问题"> </a>字体问题</h2><p><code>-&gt;</code>等一些其他字符可能显示不出来，这是字体导致的。google一下：<code>wsl oh my zsh font</code>，找到：<a href="https://github.com/Microsoft/WSL/issues/1517" target="_blank" rel="noopener">https://github.com/Microsoft/WSL/issues/1517</a>，下载并设置字体为：<a href="https://github.com/powerline/fonts/blob/master/DejaVuSansMono/DejaVu%20Sans%20Mono%20for%20Powerline.ttf" target="_blank" rel="noopener">DejaVuSansMono</a>。</p><h2 id="怎么设置字体"><a class="header-anchor" href="#怎么设置字体"> </a>怎么设置字体</h2><p>右键标题栏，进入属性</p>]]></content>
      
      <categories>
          
          <category> 解决的问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows环境 </tag>
            
            <tag> wsl </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>wsl修改右键bash图标</title>
      <link href="/blog/2018/09/19/wsl%E4%BF%AE%E6%94%B9%E5%8F%B3%E9%94%AEbash%E5%9B%BE%E6%A0%87/"/>
      <url>/blog/2018/09/19/wsl%E4%BF%AE%E6%94%B9%E5%8F%B3%E9%94%AEbash%E5%9B%BE%E6%A0%87/</url>
      <content type="html"><![CDATA[<p>使用 windows subsystem for linux (简称：WSL) 的时候，遇到一个小问题，在文件管理器中右键，唤出bash，发现图标不对：</p><p><img src="https://i.loli.net/2018/09/19/5ba25208ca7de.png" alt="截图1"></p><p>点击之后可以看到调用的是哪个程序：</p><p><img src="https://i.loli.net/2018/09/19/5ba254dbe66ea.png" alt="截图2"></p><p>google一下：<code>windows 右键图标</code>，搜到百度经验：<a href="https://jingyan.baidu.com/article/7c6fb428321b4a80642c90fd.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/7c6fb428321b4a80642c90fd.html</a>，照着修改就行了。</p><p>如图：</p><p><img src="https://i.loli.net/2018/09/19/5ba255cbd964f.png" alt="截图3"></p><p>那么改成什么呢？google一下：<code>wsl bash icon</code>，搜到：<a href="https://github.com/Microsoft/WSL/issues/1269" target="_blank" rel="noopener">https://github.com/Microsoft/WSL/issues/1269</a>，然后又在这个页面找到了这个：<a href="https://github.com/cmderdev/cmder/issues/1063#issuecomment-401947209" target="_blank" rel="noopener">https://github.com/cmderdev/cmder/issues/1063#issuecomment-401947209</a></p><p><img src="https://i.loli.net/2018/09/20/5ba2ffde07591.png" alt="截图4"></p><p>把icon换成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\WindowsApps\CanonicalGroupLimited.UbuntuonWindows_1804.2018.817.0_x64__79rhkp1fndgsc\ubuntu.exe</span><br></pre></td></tr></table></figure><p>再点击右键，就能看到这个图标了。</p><p>除了修改右键显示的icon，还可以修改右键显示的名字，以及运行的目标程序。</p><p><img src="https://i.loli.net/2018/09/20/5ba301516885f.png" alt="TIM图片20180920100903.png"></p><p>改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\WindowsApps\CanonicalGroupLimited.UbuntuonWindows_1804.2018.817.0_x64__79rhkp1fndgsc\ubuntu.exe</span><br></pre></td></tr></table></figure><p>但发现无法把工作目录定到当前右键的目录，需要加一个<code>run</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Program Files\WindowsApps\CanonicalGroupLimited.UbuntuonWindows_1804.2018.817.0_x64__79rhkp1fndgsc\ubuntu.exe run</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 解决的问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows环境 </tag>
            
            <tag> wsl </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《代码整洁之道》读书笔记--第2章:有意义的命名</title>
      <link href="/blog/2018/06/10/%E3%80%8A%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC2%E7%AB%A0-%E6%9C%89%E6%84%8F%E4%B9%89%E7%9A%84%E5%91%BD%E5%90%8D/"/>
      <url>/blog/2018/06/10/%E3%80%8A%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%AC%AC2%E7%AB%A0-%E6%9C%89%E6%84%8F%E4%B9%89%E7%9A%84%E5%91%BD%E5%90%8D/</url>
      <content type="html"><![CDATA[<p>我们写代码的时候需要不停的命名，项目、类、函数、变量 等等都要命名。而命名关乎程序的可读性，而程序的可读性又至关重要（代码是写给人看的）。</p><h2 id="名副其实"><a class="header-anchor" href="#名副其实"> </a>名副其实</h2><p>一个很重要的原则是：<strong>如果命名需要注释来补充，那就不算名副其实。</strong></p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int d;  //消逝的时间，以日计</span><br></pre></td></tr></table></figure><p>名称<code>d</code>什么也没说，如果其他很多地方要用到这个变量那就十分糟糕了，因为用的人不一定想的起来<code>d</code>是什么意思（如果只是局部变量局部使用，那它的罪孽会轻一点，如果是全局变量或者类的成员变量那这简直就是大坑）。<strong>其实我们很容易发现，注释没法像好的命名一样方便，因为我们不会在写代码的时候看到一个不懂的命名就去找它的定义处的注释，这样会浪费很多时间。另外如果写成注释就还需要维护注释，如果注释和代码不一致的情况那就变成了一种误导。</strong>。所以好的命名就应该能自己说明自己是什么。</p><p>好的命名如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int elapsedTimeInDays;</span><br><span class="line">int daysSinceCreation;</span><br><span class="line">int daysSinceModification;</span><br><span class="line">int fileAgeInDays;</span><br></pre></td></tr></table></figure><p>下面我们看一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;<span class="keyword">int</span>[]&gt; getThem() &#123;</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; list1 = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] x : theList)&#123;</span><br><span class="line">        <span class="keyword">if</span> (x[<span class="number">0</span>] == <span class="number">4</span>)&#123;</span><br><span class="line">            list1.add(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码很糟糕，虽然里面没有复杂的表达式，空格和缩进中规中矩，只用到三个变量和两个常量，甚至没涉及到其他类或多态方法。但这段代码很难说清它在做什么。问题不在于代码的简洁度，而在于代码的 <strong>模糊度：即上下文在代码中未被明确体现的程度</strong>。比如随便提几个问题：</p><ol><li>theList 是什么类型的东西？</li><li>theList 零下标条目的意义是什么？</li><li>值4的意义是什么？</li><li>我们怎么使用返回的list1？</li></ol><p><strong>问题的答案没体现在代码段中，可那就是它们该在的地方！如果不是对上下文及其熟悉，我们根本无法知道这代码在做什么！</strong></p><p>比方说，我们在开发一种扫雷游戏，我们发现，盘面是名为 theList 的单元格列表，那就将其命名为：gameBoard。盘面上每个单元格都用一个简单数组表示。我们还发现，零下标条目是一种状态值，而这种状态值为4表示“已标记”。我们将代码修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;<span class="keyword">int</span>[]&gt; getFlaggedCells() &#123;</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; flaggedCells = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">int</span>[]&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] cell : gameBoard)&#123;</span><br><span class="line">        <span class="keyword">if</span> (cell[STATE_VALUE] == FLAGGED)&#123;</span><br><span class="line">            flaggedCells.add(cell);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flaggedCells;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这下这段代码是什么功能，做了些什么工作简直一目了然。还可以进一步，不用int数组表示单元格，而是另写一个类。该类包括一个名副其实的函数（称为 isFlagged），从而掩盖住那个魔术数。</p><blockquote><p>魔术数，magic number：指使用不明其意的立即数，至少我们应该用一个常量来对这种立即数进行命名，赋予其意义。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Cell&gt; <span class="title">getFlaggedCells</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Cell&gt; flaggedCells = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Cell cell : gameBoard)&#123;</span><br><span class="line">        <span class="keyword">if</span> (cell.isFlagged())&#123;</span><br><span class="line">            flaggedCells.add(cell);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flaggedCells;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从int数组到Cell类，<strong>抽象程度又提高了，代码可重用性也就提高了</strong>。</p><h2 id="避免误导"><a class="header-anchor" href="#避免误导"> </a>避免误导</h2><p>例如，hp、aix 和 sco 都不应该用作变量名，因为它们都是UNIX平台或类UNIX平台的专有名称。别用accountList来指称一组账号，除非它们真的是List类型，List一词对程序员来说有特殊的意义，如果包纳账号的容器并非是一个List，就会引起错误的判断（即便容器就是个List，最好也别在名称中写出容器的类型）。所以，用accountGroup或bunchOfAccounts，甚至直接用accounts都会好一些。</p><p><strong>提防使用不同之处较小的命名</strong>。想区分模块中某处的XYZControllerForEfficientHandlingOfStrings 和另一处的 XYZControllerForEfficentStorageOfStrings，会花多长时间呢？这两个词外形实在太相似了。我们很享受线代Java编程环境的自动代码完成特性，键入某个名称的前几个字母，就可以得到一列该名称的可能性，假如相似的名字依字母顺序放在一起，且差异很明显，那就会相当有助益。</p><blockquote><p>在某些字体里，1和l，0和O很难分清。要注意这种混淆。</p></blockquote><h2 id="做有意义的区分"><a class="header-anchor" href="#做有意义的区分"> </a>做有意义的区分</h2><p>如果程序员只是为满足编译器或解释器的需要而写代码，就会制造麻烦。例如，因为同一作用域内不能重名，你可能随手改掉其中一个命名，有时候干脆以错误的拼写充数，结果就是有人一不小心更正拼写错误，然后导致编译器出错。</p><p>例如class已经是关键字，就给变量命名为klass，clazz，还有this，命名成thiz。</p><p>以数字系列命名（a1, a2, …, aN）是以意义命名的对立面。试看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyChars</span><span class="params">(<span class="keyword">char</span> a1[], <span class="keyword">char</span> a2[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a1.length;i++)&#123;</span><br><span class="line">        a2[i] = a1[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果参数名改为 <code>source</code> 和 <code>destination</code>，这个函数就会像样许多。</p><p><strong>废话是另一种没意义的区分</strong>。假设你有一个 Product 类。如果还有一个 ProductInfo 或 ProductData 类，那它们的名称虽然不同，意思却并无区别。Info和Data就像a、an和the一样是意义含混的废话。<br>注意，只要体现出有意义的区分，使用a和the这样的前缀就没错。例如，你可能把a用在域内变量，而把the用于函数参数。但如果你已经有一个名为zork的变量，又想调用一个名为theZork的变量，麻烦就来了。</p><p>废话都是冗余。Variable一词永远不应当出现在变量名中。Table一词永远不应当出现在表名中。NameString会比Name好吗？难倒Name会是一个浮点数不成？如果是这样，就触犯了关于误导的规则。设想有个名为Customer的类，还有一个名为CustomerObject的类。区别何在呢？哪个是表示客户历史支付情况的最佳途径？</p><p>举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getActiveAccount();</span><br><span class="line">getActiveAccounts();</span><br><span class="line">getActiveAccountInfo();</span><br></pre></td></tr></table></figure><p>程序员怎么知道该调用哪个函数呢？</p><p>如果缺少明确约定，变量moneyAmount就与money没区别，customerInfo与custmoer没区别，accountData与account没区别，theMessage也与message没区别。<strong>要区分名称，就要以读者能鉴别不同之处的方式来区分</strong>。</p><h2 id="使用读的出来的名称"><a class="header-anchor" href="#使用读的出来的名称"> </a>使用读的出来的名称</h2><p>人类长于记忆和使用单词，若不善加利用，实在是种耻辱。</p><p><strong>如果名称读不出来，讨论的时候会像个傻鸟</strong>。“哎，这儿，鼻涕阿三喜摁踢（bee cee arr three cee enn tee， BCR3CNT的读音）上头，有个皮挨死极翘（pee ess zee kyew）整数，看见没？” <strong>这不是小事，因为编程本就是一种社会活动</strong>。</p><p>有家公司，程序里面写了个 genymdhms（生成日期，年、月、日、时、分、秒），他们一般读作：“gen why emm dee aich emm ess”，YMDHMS的读音。我有个见字照读的恶习，于是开口就念“gen-yah-mudda-hims”。后来好些设计师和分析师都有样学样，听起来傻乎乎。我们知道典故，所以觉得很搞笑。搞笑归搞笑，实际是在强忍糟糕的命名。在给新开发者解释变量的意义时，他们总是读出傻乎乎的自造词，而非恰当的英语词。比较：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DtaRcrd102</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Date genymdhms;</span><br><span class="line">    <span class="keyword">private</span> Date modymdhms;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String pszqint = <span class="string">"102"</span>;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Customer</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> Date generationTimestamp;</span><br><span class="line">    <span class="keyword">private</span> Date modificationTimestamp;</span><br><span class="line">    <span class="keyword">private</span> final String recordId = <span class="string">"102"</span>;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在读起来就像人话了：“喂，Mikey，看看这条记录！生成时间戳（generation timestamp）被设置为明天了！不能这样吧？”</p><h2 id="使用可搜索的名称"><a class="header-anchor" href="#使用可搜索的名称"> </a>使用可搜索的名称</h2><p>单字母名称和数字常量有个问题，就是很难在一大篇文字中找出来。</p><h2 id="避免使用编码"><a class="header-anchor" href="#避免使用编码"> </a>避免使用编码</h2><p>编码已经太多，无谓再自找麻烦。把类型或作用域编进名称里面，徒然增加了解码的负担。没理由要求每位新人都在弄清要应付的编码之外（那算是正常的），还要再搞懂另一套编码“语言”。这对于解决问题而言，纯属多余的负担。带编码的名称通常也不便发音，容易打错。</p><h3 id="匈牙利命名法"><a class="header-anchor" href="#匈牙利命名法"> </a>匈牙利命名法</h3><p>在往昔名称长短很要命的时代，我们毫无必要的破坏了不编码的规矩，如今后悔不迭。Fortran语言要求首字母体现出类型，导致了编码的产生。BASIC早期版本只允许使用一个字母再加一位数字。匈牙利命名法（Hungarian Notation，HN）将这种态势愈演愈烈。</p><p>在Windows的C语言API的时代，HN相当重要，那时所有名称要么是个整数句柄，要么是个长指针或者void指针，要不然就是string的几种实现（有不同的用途和属性）之一。那时候编译器并不做类型检查，程序员需要匈牙利命名法来帮助自己记住类型。</p><p>现代编程语言具有更丰富的类型系统，编译器也记得并强制使用类型。而且，人们趋向于使用更小的类、更短的方法，好让每个变量的定义都在视野范围内。</p><p>Java程序员不需要类型编码。对象是强类型的，代码编辑环境已经先进到在编译开始前就侦测到类型错误的程度！所以，如今HN和其他类型编码形式都纯属多余。它们增加了修改变量、函数或类的名称或类型的难度。它们增加了阅读代码的难度。它们制造了让编码系统误导读者的可能性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PhoneNumber phoneString;    // 类型变化时，名称并不会自动变化，若名称中编码了类型，还要我们手动去改。</span><br></pre></td></tr></table></figure><h3 id="成员前缀"><a class="header-anchor" href="#成员前缀"> </a>成员前缀</h3><p>也不必用m_前缀来标明成员变量。应当把类和函数做得足够小，消除对成员前缀的需要。你应当使用某种可以高亮或用颜色标出成员的编辑环境。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class Part &#123;</span><br><span class="line">    private String m_dsc;   // The textual description</span><br><span class="line">    void setName(String name) &#123;</span><br><span class="line">        m_dsc = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Part</span></span>&#123;</span><br><span class="line">    String description;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setDescription</span><span class="params">(String description)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，人们会很快就学会无视前缀（或后缀），只看到名称中有意义的部分。代码读的越多，眼中就越没有前缀。最终，前缀变作了不入法眼的废料，变作了旧代码的标志物。</p><h3 id="接口和实现"><a class="header-anchor" href="#接口和实现"> </a>接口和实现</h3><p>有时也会出现采用编码的特殊情形。比如，你在做一个创建形态用的抽象工厂（Abstract Factory）。该工厂是个接口，要用具体类来实现。你怎么 命名工厂和具体类呢？IShapeFactory和ShapeFactory吗？我喜欢不加修饰的接口。前导字母I被滥用到了说好听点是干扰，说难听点根本就是废话的程度。我不想让用户知道我给他们的是接口。我就想让他们知道那是个ShapeFactory。如果接口和实现必须选一个来编码的话，我宁肯选择实现。ShapeFactoryImp，甚至是丑陋的CShapeFactory，都比对接口名称编码来得好。</p><h2 id="避免思维映射"><a class="header-anchor" href="#避免思维映射"> </a>避免思维映射</h2><p>不应当让读者在脑海中把你的名称翻译为他们熟知的名称。这种问题经常出现在选择是使用问题领域术语还是解决方案领域术语时。</p><p>单字母变量名就是个问题。在作用域较小，也没有名称冲突时，循环计数器自然有可能被命名为i或j或k（但千万别用字母l）。这是因为传统上惯用单字母名称做循环计数器。然而，在多数其他情况下，单字母名称不是个好选择，读者必须在脑海中将它映射为真实概念。仅仅是因为有了a和b，就要取名为c，实在并非像样的理由。</p><p>程序员通常都是聪明人。聪明人有时会借脑筋急转弯炫耀其聪明。总而言之，假使你记得r代表不包含主机和图式（scheme）的小写字母版url的话，那你真是太聪明了。</p><p>聪明程序员和专业程序员之间的区别在于，专业程序员了解，明确是王道。专业程序员善用其能，编写其他人能理解的代码。</p><h2 id="类名"><a class="header-anchor" href="#类名"> </a>类名</h2><p>类名和对象名应该是名词或名词短语，如Customer、WikiPage、Account和AddressParser。避免使用Manager、Processor、Data或Info这样的类名。类名不应当是动词。</p><blockquote><p>这里没看懂，举的例子并不是动词啊</p></blockquote><h2 id="方法名"><a class="header-anchor" href="#方法名"> </a>方法名</h2><p>方法名应当是动词或动词短语，如 postPayment、deletePage或save。属性访问器、修改器和断言应该根据其值命名，并依Javabean标准加上get、set和is前缀。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String name = employee.getName();</span><br><span class="line">customer.setName(<span class="string">"mike"</span>);</span><br><span class="line"><span class="keyword">if</span>(paycheck.isPosted())...</span><br></pre></td></tr></table></figure><p>重载构造器时，使用描述了参数的静态工厂方法名。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Complex fulcrumPoint = Complex.FromRealNumber(<span class="number">23.0</span>);</span><br></pre></td></tr></table></figure><p>通常好于</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Complex fulcrumPoint = <span class="keyword">new</span> Complex(<span class="number">23.0</span>);</span><br></pre></td></tr></table></figure><p>可以考虑将相应的构造器设置为private，强制使用这种命名手段。</p><h2 id="别扮可爱"><a class="header-anchor" href="#别扮可爱"> </a>别扮可爱</h2><p>如果名称太耍宝，那就只有同作者一般有幽默感的人才能记得住，而且还是在他们记得那个笑话的时候才行。谁会知道名为HolyHandGrenade的函数是用来做什么的呢？没错，这名字挺伶俐，不过DeleteItems或许是更好的名称。宁可明确，毋为好玩。</p><p>扮可爱的做法在代码中经常体现为使用俗语或俚语。例如，别用whack()来表示kill()。别用eatMyShorts()这类与文化紧密相关的笑话来表示abort()。</p><h2 id="每个概念对应一个词"><a class="header-anchor" href="#每个概念对应一个词"> </a>每个概念对应一个词</h2><p>给每个抽象概念选一个词，并且一以贯之。例如，使用fetch、retrieve和get来给在多个类中的同种方法命名。你怎么记得住哪个类中是哪个方法呢？</p><p>Eclipse和Intellj之类的线代编程环境提供了与环境相关的线索，比如某个对象能调用的方法列表。不过要注意，列表中通常不会给出你为函数名和参数列表编写的注释。如果参数名称来自函数声明，你就太幸运了。函数名称应当独一无二，而且要保持一致，这样你才能不借助多余的浏览就能找到正确的方法。</p><p>同样，在同一堆代码中有controller，又有manager，还有driver，就会令人困惑。DeviceManager和Protocal-Controller之间有何根本区别？为什么不全用controllers或managers？他们都是Drivers吗？这种名称，让人觉得这两个对象是不同类型的，也分属不同的类。</p><p>对于那些会用到你代码的程序员，一以贯之的命名法简直就是天降福音。</p><h2 id="别用双关语"><a class="header-anchor" href="#别用双关语"> </a>别用双关语</h2><p>避免将同一个单词用于不同目的。如果遵循“一词一意”的规则，可能在好多类里面都会有add方法。只要这些add方法的参数列表和返回值在语义上等价，就一切顺利。</p><p>但是，可能会有人决定为“保持一致”而使用add这个词来命名，即便并非真的想表示这种意思。比如，在多个类种都有add方法，该方法通过增加或连接两个现存值来获得新值。假设要写个新类，该类中有一个方法，把单个参数放到群集（collection）中。该把这个方法叫做add吗？这样做貌似和其他add方法保持了一致，但实际上语义却不同，应该用insert或append之类的词来命名才对。把该方法命名为add，就是双关语了。</p><h2 id="使用解决方案领域的名称"><a class="header-anchor" href="#使用解决方案领域的名称"> </a>使用解决方案领域的名称</h2><p>记住，只有程序员才会读你的代码。所以，尽管用那些计算机科学（Computer Science, CS）术语、算法名、模式名、数学术语吧。</p><p>对于熟悉访问者（VISITOR）模式的程序来说，名称AccountVisitor富有意义。那个程序员会不知道JobQueue的意思呢？</p><h2 id="使用源自所涉及问题领域的名称"><a class="header-anchor" href="#使用源自所涉及问题领域的名称"> </a>使用源自所涉及问题领域的名称</h2><p>如果不能用程序员熟悉的术语来给手头的工作命名，就采用从所涉及领域而来的名称吧。至少，负责维护代码的程序员就能去请教领域专家了。</p><h2 id="添加有意义的语境"><a class="header-anchor" href="#添加有意义的语境"> </a>添加有意义的语境</h2><p>很少有名称是能自我说明的–多数都不能。反之，你需要用有良好命名的类、函数或名称空间来放置名称，给读者提供语境。如果没这么做，给名称添加前缀就是最后一招了。</p><p>设想你有名为firstName、lastName、street、houseNumber、city\state和zipcode的变量。当它们搁一块儿的时候，很明确是构成了一个地址。不过，假使只是在某个方法中看见孤零零的一个state变量呢？你会理所当然推断那是某个地址的一部分吗？</p><p>可以添加前缀addrFirstName、addrLastName、addrState等，以此提供语境。至少，读者会明白这些变量都是某个更大结构的一部分。当然，更好的方案是创建名为Address的类。这样，即便是编译器也会知道这些变量隶属某个更大的概念了。</p><p>看一个例子：</p><p>语境不明确的变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printGuessStatistics</span><span class="params">(<span class="keyword">char</span> candidate, <span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">    String number;</span><br><span class="line">    String verb;</span><br><span class="line">    String pluralModifier;</span><br><span class="line">    <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">        number=<span class="string">"no"</span>;</span><br><span class="line">        verb=<span class="string">"are"</span>;</span><br><span class="line">        pluralModifier=<span class="string">"s"</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(count==<span class="number">1</span>)&#123;</span><br><span class="line">        number=<span class="string">"1"</span>;</span><br><span class="line">        verb=<span class="string">"is"</span>;</span><br><span class="line">        pluralModifier=<span class="string">""</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        number=Integer.toString(count);</span><br><span class="line">        verb=<span class="string">"are"</span>;</span><br><span class="line">        pluralModifier=<span class="string">"s"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String guessMessage = String.format(</span><br><span class="line">        <span class="string">"There %s %s %s%s"</span>, verb, number, candidate, pluralModifier);</span><br><span class="line">    print(guessMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上列函数有点过长，变量的使用贯穿始终。要分解这个函数，需要创建一个名为GuessStatisticsMessage的类，把三个变量做成该类的成员字段。这样它们就在定义上变作了GuessStatisticsMessage的一部分。语境的增强也让算法能够通过分解为更小的函数而变得更为干净利落。</p><p>有语境的变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuessStatisticsMessage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String number;</span><br><span class="line">    <span class="keyword">private</span> String verb;</span><br><span class="line">    <span class="keyword">private</span> String pluralModifier;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">make</span><span class="params">(<span class="keyword">char</span> candidate, <span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">        createPluralDependentMessageParts(count);</span><br><span class="line">        <span class="keyword">return</span> String.format(</span><br><span class="line">            <span class="string">"There %s %s %s%s"</span>, verb, number, candidate, pluralModifier);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createPluralDependentMessageParts</span><span class="params">(<span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(count==<span class="number">0</span>)&#123;</span><br><span class="line">            thereAreNoLetters();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (count==<span class="number">1</span>)&#123;</span><br><span class="line">            thereIsOneLetter();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            thereAreManyLetters(count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">thereAreManyLetters</span><span class="params">(<span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">        number = Integer.toString(count);</span><br><span class="line">        verb = <span class="string">"are"</span>;</span><br><span class="line">        pluralModifier=<span class="string">"s"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">thereIsOneLetters</span><span class="params">()</span></span>&#123;</span><br><span class="line">        number=<span class="string">"1"</span>;</span><br><span class="line">        verb = <span class="string">"is"</span>;</span><br><span class="line">        pluralModifier = <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">thereAreNoLetters</span><span class="params">()</span></span>&#123;</span><br><span class="line">        number = <span class="string">"no"</span>;</span><br><span class="line">        verb = <span class="string">"are"</span>;</span><br><span class="line">        pluralModifier = <span class="string">"s"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不要添加没用的语境"><a class="header-anchor" href="#不要添加没用的语境"> </a>不要添加没用的语境</h2><p>设若有一个名为“加油站豪华版”（Gas Station Deluxe）的应用，在其中给每个类添加GSD前缀就不是什么好点子。说白了，你是在和自己在用的工具过不去。输入G，按下自动完成键，结果会得到系统中全部类的列表，列表恨不得有一英里那么长。这样做聪明吗？为什么要搞得IDE没法帮助你？</p><p>再比如，你在GSD应用程序中的记账模块创建了一个表示邮件地址的类，然后给该类命名为GSDAccountAddress。稍后，你的客户联络应用中需要用到邮件地址，你会用GSDAccountAddress吗？这名字听起来没问题吗？在这17个字母里面，有10个字母纯属多余，与当前语境毫无关联。</p><p>只要短名称足够清楚，就要比长名称好。别给名称添加不必要的语境。</p><p>对于Address类的实体来说，accountAddress和customerAddress都是不错的名称，不过用在类名上就不太好了。Address是个好类名。如果需要与MAC地址、端口地址和Web地址相区别，我会考虑使用PostalAddress、MAC和URI。这样的名称更为精确，而精确正是命名的要点。</p>]]></content>
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 《代码整洁之道》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码规范 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《APUE-3rd》 读书笔记 -- File I/O</title>
      <link href="/blog/2018/05/28/APUE-3rd-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--File-IO/"/>
      <url>/blog/2018/05/28/APUE-3rd-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--File-IO/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言"> </a>前言</h2><p>这章讲的是文件IO，其中有几个非常重要的概念：</p><ol><li>File Desriptors，文件描述符</li><li>current file offset，当前文件偏移量</li><li>File Sharing Data Structure，文件共享数据模型</li><li>file descriptor flags ，文件描述位</li><li>file status flags ，文件状态位</li></ol><h2 id="file-descriptors"><a class="header-anchor" href="#file-descriptors"> </a>File Descriptors</h2><ul><li>对内核来说，所有 <strong>打开的文件</strong> 都使用file descriptor引用。</li><li>文件描述符是一个非负整数。当我们打开一个存在的文件或者创建一个新文件，内核返回一个文件描述符给进程。</li><li>当我们想要读或者写一个文件，我们通过文件描述符来确定这个文件，文件描述符是被open或者creat返回的，然后作为read或者write的一个参数。</li></ul><blockquote><p>文件描述符都使用尽可能小的非负整数，File descriptors range from 0 through OPEN_MAX−1.</p></blockquote><p>有三个magic number，0代表STDIN_FILENO，1代表STDOUT_FILENO，2代表STDERR_FILENO。虽然这已经是POSIX.1所定义的标准，但为了程序的可读性，还是不建议直接写数字。这三个常量定义在<code>&lt;unistd.h&gt;</code>中。</p><h2 id="open-and-openat-functions"><a class="header-anchor" href="#open-and-openat-functions"> </a>open and openat Functions</h2><p>A file is opened or created by calling either the open function or the openat function.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> oflag, ... <span class="comment">/* mode_t mode */</span> )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> oflag, ... <span class="comment">/* mode_t mode */</span> )</span></span>;</span><br><span class="line"><span class="comment">// Both return: file descriptor if OK, −1 on error</span></span><br></pre></td></tr></table></figure><p>最后一个参数是<code>...</code>，这是ISO C定义剩下的多个参数的方式。对这些函数来说，只有当新文件被创建时，最后一个参数才被使用，后面我们会讲。在这个原型中我们把这个参数写作一个注释。</p><p>path这个参数是要打开或者要创建的文件的名字。这个函数有多种操作，定在在oflag参数里。这个参数由下列一个或者多个定义在<code>&lt;fcntl.h&gt;</code>头文件中的常量通过 <strong>或(一种逻辑操作)</strong> 操作构成：</p><p>O_RDONLYOpen for reading only</p><p>O_WRONLYOpen for writing only</p><p>O_RDWROpen for reading and writing</p><blockquote><p>Most implementations define O_RDONLY as 0, O_WRONLY as 1, and O_RDWR as 2, for compatibility with older programs.  <strong>为了兼容老程序，许多实现定义O_RDONLY as 0, O_WRONLY as 1, and O_RDWR as 2</strong>。</p></blockquote><p>O_EXECOpen for execute only</p><p>O_SEARCHOpen for search only(applies to directories)</p><blockquote><p>The purpose of the O_SEARCH constant is to evaluate search permissions at the time a directory is opened. Further operations using the directory’s file descriptor will not reevaluate permission to search the directory. None of the versions of the operating systems covered in this book support O_SEARCH yet.</p></blockquote><p>One and only one of the previous five constants must be specified. The following constants are optional:</p><p>上面的五个常量有且只有一个必须被明确。接下来的是可选常量：</p><p>O_APPENDAppend to the end of file on each write. We describe this option in detail in Section 3.11.</p><p>O_CLOEXECSet the FD_CLOEXEC file descriptor flag. We discuss file descriptor flags in Section 3.14.</p><p>O_CREATCreate the file if it doesn’t exist. This option requires a third argument to the open function (a fourth argument to the openat function) — the mode, which specifies the access permission bits of the new file. (When we describe a file’s access permission bits in Section 4.5, we’ll see how to specify the mode and how it can be modified by the umask value of a process.)  创建一个文件，如果不存在。这个操作需要open函数的第三个参数（openat函数的第四个参数）— mode，<strong>它明确了这个新文件的访问权限位</strong>。（当我们在第4.5章节讨论文件的访问权限位，我们将看到如何明确mode，以及它如何修改进程的umask值。）</p><p>O_DIRECTORYGenerate an error if path doesn’t refer to a directory.</p><p>O_EXCLGenerate an error if O_CREAT is also specified and the file already exists. This test for whether the file already exists and the creation of the file if it doesn’t exist is an atomic operation. We describe atomic operations in more detail in Section 3.11.  如果O_CREAT被使用了且文件已经存在就会生成一个错误。这个常量的作用是检测文件是否存在如果文件不存在就创建，这是一个原子操作。我们将在第3.11章节讨论更多原子操作的细节。</p><p>O_NOCTTYIf path refers to a terminal device, do not allocate the device as the controlling terminal for this process. We talk about controlling terminals in Section 9.6.  如果这个路径指向的是终端设备，则不将这个设备分配为此进程的控制终端。</p><p>O_NONBLOCKIf path refers to a FIFO, a block special file, or a character special file, this option sets the nonblocking mode for both the opening of the file and subsequent I/O. We describe this mode in Section 14.2.  如果path指向FIFO（先进先出），一个块特殊文件，一个字符特殊文件，这个选项设置了非阻塞模式为本次的打开操作和后续的I/O操作。</p><blockquote><p>In earlier releases of System V, the O_NDELAY (no delay) flag was introduced. This option is similar to the O_NONBLOCK (nonblocking) option, but an ambiguity was introduced in the return value from a read operation. The no-delay option causes a read operation to return 0 if there is no data to be read from a pipe, FIFO, or device, but this conflicts with a return value of 0, indicating an end of file. SVR4-based systems still support the no-delay option, with the old semantics, but new applications should use the nonblocking option instead.  在早期的System V，有一个O_NDELAY(no delay)符号。这个符号和O_NONBLOCK(nonblocking)选项相似，但他的读操作返回值具有二义性。如果管道，先进先出，或者设备没有数据可读，no-delay选项就会造成read操作返回0，这与end of file造成的返回值0冲突了。虽然基于SVR4的系统还支持这个no-delay选项，但新的应用应该使用nonblocking选项。</p></blockquote><p>O_SYNCHave each write wait for physical I/O to complete, including I/O necessary to update file attributes modified as a result of the write. We use this option in Section 3.14.  使每次write都等物理I/O完成，包括更新文件属性所需要的I/O。</p><p>O_TTY_INITWhen opening a terminal device that is not already open, set the nonstandard termios parameters to values that result in behavior that conforms to the Single UNIX Specification. We discuss the termios structure when we discuss terminal I/O in Chapter 18.  当打开一个新的终端设备的时候，设置非标准参数 termios。</p><p>The following two flags are also optional. They are part of the synchronized input and output option of the Single UNIX Specification (and thus POSIX.1).</p><p>O_DSYNCHave each write wait for physical I/O to complete, but don’t wait for file attributes to be updated if they don’t affect the ability to read the data just written.  让所有write都等待物理I/O完成，但是不用等文件属性更新，如果不影响刚刚写完的数据的读操作的话。</p><p>O_RSYNCHave each read operation on the file descriptor wait until any pending writes for the same portion of the file are complete.  使每个使用文件描述符的的读操作等待，直到对文件的同一部分的所有写操作完成。</p><blockquote><p>Solaris 10 supports all three synchronization flags. Historically, FreeBSD (and thus Mac OS X) have used the O_FSYNC flag, which has the same behavior as O_SYNC. Because the two flags are equivalent, they define the flags to have the same value. FreeBSD 8.0 doesn’t support the O_DSYNC or O_RSYNC flags. Mac OS X doesn’t support the O_RSYNC flag, but defines the O_DSYNC flag, treating it the same as the O_SYNC flag. Linux 3.2.0 supports the O_DSYNC flag, but treats the O_RSYNC flag the same as O_SYNC.</p></blockquote><p><strong>The file descriptor returned by open and openat is guaranteed to be the lowest- numbered unused descriptor</strong>. This fact is used by some applications to open a new file on standard input, standard output, or standard error. <strong>For example, an application might close standard output—normally, file descriptor 1—and then open another file, knowing that it will be opened on file descriptor 1</strong>. We’ll see a better way to guarantee that a file is open on a given descriptor in Section 3.12, when we explore the dup2 function.</p><p><strong>The fd parameter</strong> distinguishes the openat function from the open function. There are three possibilities:</p><ol><li><p>The path parameter specifies an absolute pathname. In this case, the fd parameter is ignored and the openat function behaves like the open function.</p></li><li><p>The path parameter specifies a relative pathname and the fd parameter is a file descriptor that specifies the starting location in the file system where the relative pathname is to be evaluated. The fd parameter is obtained by opening the directory where the relative pathname is to be evaluated.</p></li><li><p>The path parameter specifies a relative pathname and the fd parameter has the special value AT_FDCWD. In this case, the pathname is evaluated starting in the current working directory and the openat function behaves like the open function.</p></li></ol><p>The openat function is one of a class of functions added to the latest version of POSIX.1 to address two problems. First, it gives threads a way to use relative pathnames to open files in directories other than the current working directory. As we’ll see in Chapter 11, all threads in the same process share the same current working directory, so this makes it difficult for multiple threads in the same process to work in different directories at the same time. Second, it provides a way to avoid time-of-check- to-time-of-use (TOCTTOU) errors.  openat函数是在最后一个版本的POSIX.1加入的，为了解决两个问题。首先，它给线程以相对路径而非当前路径。我们将在第11章看到，在同一进程中的所有线程共享同一个当前目录，所以要让同一进程中的多线程同时在不同的目录工作是非常困难的。第二，它提供了避免 time-of-check-to-time-of-use（TOCTTOU） 错误。</p><p>The basic idea behind TOCTTOU errors is that a program is vulnerable if it makes two file-based function calls where the second call depends on the results of the first call. Because the two calls are not atomic, the file can change between the two calls, thereby invalidating the results of the first call, leading to a program error. TOCTTOU errors in the file system namespace generally deal with attempts to subvert file system permissions by tricking a privileged program into either reducing permissions on a privileged file or modifying a privileged file to open up a security hole. Wei and Pu [2005] discuss TOCTTOU weaknesses in the UNIX file system interface.  TOCTTOU错误的意思是，一个调用横叉一脚影响了另一个调用，本来另一个调用应该是一个原子操作。</p><h3 id="filename-and-pathname-truncation"><a class="header-anchor" href="#filename-and-pathname-truncation"> </a>Filename and Pathname Truncation</h3><p>What happens if NAME_MAX is 14 and we try to create a new file in the current directory with a filename containing 15 characters? Traditionally, early releases of System V, such as SVR2, allowed this to happen, silently truncating the filename beyond the 14th character. BSD-derived systems, in contrast, returned an error status, with errno set to ENAMETOOLONG. Silently truncating the filename presents a problem that affects more than simply the creation of new files. If NAME_MAX is 14 and a file exists whose name is exactly 14 characters, any function that accepts a pathname argument, such as open or stat, has no way to determine what the original name of the file was, as the original name might have been truncated.  如果NAME_MAX是14怎么办？传统上，早期的System V系统，允许这发生，静默的将文件名截断成14字符。相反的，BSD派生的系统，返回一个错误状态，并把errno设置成ENAMETOOLONG。静默的截断文件名呈现的问题不仅仅是创建了一个新文件。如果NAME_MAX是14且文件存在，且它的名字就是14字符，任何接收一个路径名作为参数的函数，比如open或者stat，没办法判断文件原来的名字是什么，因为原始文件名可能已经被截断。</p><p>With POSIX.1, the constant <code>_POSIX_NO_TRUNC</code> determines whether long filenames and long components of pathnames are truncated or an error is returned. As we saw in Chapter 2, this value can vary based on the type of the file system, and we can use fpathconf or pathconf to query a directory to see which behavior is supported.  在POSIX.1标准里，常量 <code>_POSIX_NO_TRUNC</code> 决定长文件名和路径名中长的组件是否被截断或者是否返回一个错误。正如我们在第二章中看到的，这个值在文件系统中是非常基本的，我们可以使用 <code>fpathconf</code> 或 <code>pathconf</code>查询一个目录看看它支持哪种行为。</p><blockquote><p>Whether an error is returned is largely historical. For example, SVR4-based systems do not generate an error for the traditional System V file system, S5. For the BSD-style file system (known as UFS), however, SVR4-based systems do generate an error. Figure 2.20 illustrates another example: Solaris will return an error for UFS, but not for PCFS, the DOS-compatible file system, as DOS silently truncates filenames that don’t fit in an 8.3 format. BSD-derived systems and Linux always return an error.</p></blockquote><p>If _POSIX_NO_TRUNC is in effect, errno is set to ENAMETOOLONG, and an error status is returned if any filename component of the pathname exceeds NAME_MAX.</p><blockquote><p>Most modern file systems support a maximum of 255 characters for filenames. Because filenames are usually shorter than this limit, this constraint tends to not present problems for most applications.</p></blockquote><h2 id="creat-function"><a class="header-anchor" href="#creat-function"> </a>creat Function</h2><p>A new file can also be created by calling the creat function.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="comment">// Returns: file descriptor opened for write-only if OK, −1 on error</span></span><br></pre></td></tr></table></figure><p>Note that this function is equivalent to</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open(path, O_WRONLY | O_CREAT | O_TRUNC, mode);</span><br></pre></td></tr></table></figure><blockquote><p>Historically, in early versions of the UNIX System, the second argument to open could be only 0, 1, or 2. There was no way to open a file that didn’t already exist. Therefore, a separate system call, creat, was needed to create new files. With the O_CREAT and O_TRUNC options now provided by open, a separate creat function is no longer needed.  这个函数诞生的原因是：历史上open函数的第二个参数只支持0，1，2这三个值，也就是读，写，读写。没办法打开一个不存在的文件。而现在有了O_CREAT and O_TRUNC options，creat函数也就没有存在的必要了。</p></blockquote><p>We’ll show how to specify mode in Section 4.5 when we describe a file’s access permissions in detail.</p><p>One deficiency with creat is that the file is opened only for writing. Before the new version of open was provided, if we were creating a temporary file that we wanted to write and then read back, we had to call creat, close, and then open. A better way is to use the open function, as in</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open(path, O_RDWR | O_CREAT | O_TRUNC, mode);</span><br></pre></td></tr></table></figure><h2 id="close-function"><a class="header-anchor" href="#close-function"> </a>close Function</h2><p>An open file is closed by calling the close function.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns: 0 if OK, −1 on error</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure><p>Closing a file also releases any record locks that the process may have on the file. We’ll discuss this point further in Section 14.3.  关闭一个文件同样会释放进程对该文件的所有锁。</p><p>When a process terminates, all of its open files are closed automatically by the kernel. Many programs take advantage of this fact and don’t explicitly close open files. See the program in Figure 1.4, for example.  当一个进程终止，所有它打开的文件都会被内核自动关闭。许多程序利用了这一点，不明确关闭文件。</p><h2 id="lseek-function"><a class="header-anchor" href="#lseek-function"> </a>lseek Function</h2><p>Every open file has an associated “current file offset,” normally a non-negative integer that measures the number of bytes from the beginning of the file. (We describe some exceptions to the ‘‘non-negative’’ qualifier later in this section.) Read and write operations normally start at the current file offset and cause the offset to be incremented by the number of bytes read or written. By default, this offset is initialized to 0 when a file is opened, unless the O_APPEND option is specified.  每个打开的文件都与 &quot;current file offset&quot;关联，正常情况下它是一个非负整形数，表示从文件开始到目前位置的字节数。读和写操作都是从 current file offset开始的，并且会让offset增加，随着读和写的进行。默认的，当文件被打开时，这个位移初始化时0，除非指明了O_APPEND选项。</p><p>An open file’s offset can be set explicitly by calling lseek.  通过调用 lseek函数，一个打开的文件的offset可以被设定。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">off_t</span> lseek(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence);</span><br><span class="line"><span class="comment">// Returns: new file offset if OK, −1 on error</span></span><br></pre></td></tr></table></figure><p>The interpretation of the offset depends on the value of the whence argument.</p><ul><li>If whence is SEEK_SET, the file’s offset is set to offset bytes from the beginning of the file.</li><li>If whence is SEEK_CUR, the file’s offset is set to its current value plus the offset. The offset can be positive or negative.</li><li>If whence is SEEK_END, the file’s offset is set to the size of the file plus the offset. The offset can be positive or negative.</li></ul><p>Because a successful call to lseek returns the new file offset, we can seek zero bytes from the current position to determine the current offset:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">off_t</span>    currpos;</span><br><span class="line">currpos = lseek(fd, <span class="number">0</span>, SEEK_CUR);</span><br></pre></td></tr></table></figure><p>This technique can also be used to determine if a file is capable of seeking. If the file descriptor refers to a pipe, FIFO, or socket, lseek sets errno to <strong>ESPIPE</strong> and returns −1.</p><blockquote><p>The three symbolic constants—SEEK_SET, SEEK_CUR, and SEEK_END—were introduced with System V. Prior to this, <strong>whence was specified as 0 (absolute), 1 (relative to the current offset), or 2 (relative to the end of file). Much software still exists with these numbers hard coded</strong>.</p><p><strong>The character l in the name lseek means ‘‘long integer.’’ Before the introduction of the off_t data type, the offset argument and the return value were long integers</strong>. lseek was introduced with Version 7 when long integers were added to C. (Similar functionality was provided in Version 6 by the functions seek and tell.)</p></blockquote><h3 id="example"><a class="header-anchor" href="#example"> </a>Example</h3><p>The program in Figure 3.1 tests its standard input to see whether it is capable of seeking.</p><blockquote><p>Figure 3.1 Test whether standard input is capable of seeking</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lseek(STDIN_FILENO, <span class="number">0</span>, SEEK_CUR) == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"cannot seek\n"</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"seek OK\n"</span>);</span><br><span class="line"> <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Normally, a file’s current offset must be a non-negative integer. It is possible, however, that certain devices could allow negative offsets. But for regular files, the offset must be non-negative. Because negative offsets are possible, we should be careful to compare the return value from lseek as being equal to or not equal to −1, rather than testing whether it is less than 0</strong>.</p><blockquote><p>The /dev/kmem device on FreeBSD for the Intel x86 processor supports negative offsets. Because the offset (off_t) is a signed data type (Figure 2.21), we lose a factor of 2 in the maximum file size. If off_t is a 32-bit integer, the maximum file size is $2^{31}$−1 bytes.</p></blockquote><p>lseek only records the current file offset within the kernel — it does not cause any I/O to take place. This offset is then used by the next read or write operation.</p><p>The file’s offset can be greater than the file’s current size, in which case the next write to the file will extend the file. This is referred to as creating a hole in a file and is allowed. Any bytes in a file that have not been written are read back as 0.  文件偏移量可以大于文件的目前大小，在这种情况下下一次写文件将扩展文件。也就是说在文件中创建一个空洞是被允许的。在文件中任何没被写入的部分都将被读作0。</p><p>A hole in a file isn’t required to have storage backing it on disk. Depending on the file system implementation, when you write after seeking past the end of a file, new disk blocks might be allocated to store the data, but there is no need to allocate disk blocks for the data between the old end of file and the location where you start writing.  文件中的空洞并不需要存储到磁盘上。根据文件系统的实现，当你在end of file之后写，为了存储数据新的磁盘空间可能会分配，但没有必要分配磁盘块给end of file和你开始写的地方之间的这些数据。</p><h3 id="example-v2"><a class="header-anchor" href="#example-v2"> </a>Example</h3><p>The program shown in Figure 3.2 creates a file with a hole in it.</p><blockquote><p>Figure 3.2  Create a file with a hole in it</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span>    buf1[] = <span class="string">"abcdefghij"</span>;</span><br><span class="line"><span class="keyword">char</span>    buf2[] = <span class="string">"ABCDEFGHIJ"</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">if</span> ((fd = creat(<span class="string">"file.hole"</span>, FILE_MODE)) &lt; <span class="number">0</span>)</span><br><span class="line">    err_sys(<span class="string">"creat error"</span>);</span><br><span class="line">    <span class="keyword">if</span> (write(fd, buf1, <span class="number">10</span>) != <span class="number">10</span>)</span><br><span class="line">    err_sys(<span class="string">"buf1 write error"</span>);</span><br><span class="line">    <span class="comment">/* offset now = 10 */</span></span><br><span class="line">    <span class="keyword">if</span> (lseek(fd, <span class="number">16384</span>, SEEK_SET) == <span class="number">-1</span>)</span><br><span class="line">    err_sys(<span class="string">"lseek error"</span>);</span><br><span class="line">    <span class="comment">/* offset now = 16384 */</span></span><br><span class="line">    <span class="keyword">if</span> (write(fd, buf2, <span class="number">10</span>) != <span class="number">10</span>)</span><br><span class="line">        err_sys(<span class="string">"buf2 write error"</span>);</span><br><span class="line">    <span class="comment">/* offset now = 16394 */</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="read-function"><a class="header-anchor" href="#read-function"> </a>read Function</h2><p>Data is read from an open file with the read function.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">ssize_t read(int fd, void *buf, size_t nbytes);</span><br></pre></td></tr></table></figure><blockquote><p>Returns: numbers of bytes read, 0 if end of file, -1 on error</p></blockquote><p>If the read is successful, the number of bytes read is returned. If the end of file is encountered, 0 is returned.</p><p>There are several cases in which the number of bytes actually read is less than the amount requested: 有以下几种情况，read读取的字节会比指定的字节数少</p><ul><li>When reading from a regular file, if the end of file is reached before the requested number of bytes has been read. For example, if 30 bytes remain until the end of file and we try to read 100 bytes, read returns 30. The next time we call read, it will return 0 (end of file).</li><li>When reading from a terminal device. Normally, up to one line is read at a time. (We’ll see how to change this default in Chapter 18.)</li><li>When reading from a network. Buffering within the network may cause less than the requested amount to be returned.</li><li>When reading from a pipe or FIFO. If the pipe contains fewer bytes than requested, read will return only what is available.</li><li>When reading from a record-oriented device. Some record-oriented devices, such as magnetic tape, can return up to a single record at a time.</li><li>When interrupted by a signal and a partial amount of data has already been read. We discuss this further in Section 10.5.</li></ul><p>The read operation starts at the file’s current offset. Before a successful return, the offset is incremented by the number of bytes actually read. read操作是从文件的当前偏移量开始的。在成功返回前，偏移量会随读取的字节增加。</p><p>POSIX.1 changed the prototype for this function in several ways. The classic definition is</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int read(int fd, char *buf, unsigned nbytes);</span><br></pre></td></tr></table></figure><ul><li>First, the second argument was changed from char * to void * to be consistent<br>with ISO C: the type void * is used for generic pointers.</li><li>Next, the return value was required to be a signed integer (ssize_t) to return a positive byte count, 0 (for end of file), or −1 (for an error).</li><li>Finally, the third argument historically has been an unsigned integer, to allow a 16-bit implementation to read or write up to 65,534 bytes at a time. With the 1990 POSIX.1 standard, the primitive system data type ssize_t was introduced to provide the signed return value, and the unsigned size_t was used for the third argument. (Recall the SSIZE_MAX constant from Section 2.5.2.)</li></ul><h2 id="write-function"><a class="header-anchor" href="#write-function"> </a>write Function</h2><p>Data is written to an open file with the write function.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">ssize_t write(int fd, const void *buf, size_t nbytes);</span><br></pre></td></tr></table></figure><p>The return value is usually equal to the nbytes argument; otherwise, an error has occurred. A common cause for a write error is either filling up a disk or exceeding the file size limit for a given process (Section 7.11 and Exercise 10.11). 返回值一般会等于<code>nbytes</code>这个参数的大小，否则就是出错了。一般导致写错误的原因是磁盘满了或者超出给定进程的文件大小限制。</p><p>For a regular file, the write operation starts at the file’s current offset. If the O_APPEND option was specified when the file was opened, the file’s offset is set to the current end of file before each write operation. After a successful write, the file’s offset is incremented by the number of bytes actually written.</p><h2 id="i-o-efficiency"><a class="header-anchor" href="#i-o-efficiency"> </a>I/O Efficiency</h2><p>The program in Figure 3.5 copies a file, using only the read and write functions.</p><blockquote><p>Figure 3.5 Copy standard input to standard output</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;apue.h&quot;</span><br><span class="line">#define BUFFSIZE 4096</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int     n;</span><br><span class="line">    char    buf[BUFFSIZE];</span><br><span class="line">    while ((n = read(STDIN_FILENO, buf, BUFFSIZE)) &gt; 0)</span><br><span class="line">        if (write(STDOUT_FILENO, buf, n) != n)</span><br><span class="line">            err_sys(&quot;write error&quot;);</span><br><span class="line">    if (n &lt; 0)</span><br><span class="line">        err_sys(&quot;read error&quot;);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The following caveats apply to this program.</p><ul><li>It reads from standard input and writes to standard output, assuming that these have been set up by the shell before this program is executed. Indeed, all normal UNIX system shells provide a way to open a file for reading on standard input and to create (or rewrite) a file on standard output. This prevents the program from having to open the input and output files, and allows the user to take advantage of the shell’s I/O redirection facilities.</li><li>The program doesn’t close the input file or output file. Instead, the program uses the feature of the UNIX kernel that closes all open file descriptors in a process when that process terminates.</li><li>This example works for both text files and binary files, since there is no difference between the two to the UNIX kernel.</li></ul><p>One question we haven’t answered, however, is how we chose the BUFFSIZE value. Before answering that, let’s run the program using different values for BUFFSIZE. Figure 3.6 shows the results for reading a 516,581,760-byte file, using 20 different buffer sizes.</p><img src="../../../../images/APUE-3rd-Figure 3.6.png" width="70%"><p>The file was read using the program shown in Figure 3.5, with standard output redirected to /dev/null. The file system used for this test was the Linux ext4 file system with 4,096-byte blocks. (The st_blksize value, which we describe in Section 4.12, is 4,096.) This accounts for the minimum in the system time occurring at the few timing measurements starting around a BUFFSIZE of 4,096. Increasing the buffer size beyond this limit has little positive effect.</p><p>Most file systems support some kind of read-ahead to improve performance. When sequential reads are detected, the system tries to read in more data than an application requests, assuming that the application will read it shortly. The effect of read-ahead can be seen in Figure 3.6, where the elapsed time for buffer sizes as small as 32 bytes is as good as the elapsed time for larger buffer sizes.</p><p>We’ll return to this timing example later in the text. In Section 3.14, we show the effect of synchronous writes; in Section 5.8, we compare these unbuffered I/O times with the standard I/O library.</p><blockquote><p>Beware when trying to measure the performance of programs that read and write files. The operating system will try to cache the file incore, so if you measure the performance of the program repeatedly, the successive timings will likely be better than the first. This improvement occurs because the first run causes the file to be entered into the system’s cache, and successive runs access the file from the system’s cache instead of from the disk. (The term incore means in main memory. Back in the day, a computer’s main memory was built out of ferrite core. This is where the phrase ‘‘core dump’’ comes from: the main memory image of a program stored in a file on disk for diagnosis.)</p></blockquote><blockquote><p>In the tests reported in Figure 3.6, each run with a different buffer size was made using a different copy of the file so that the current run didn’t find the data in the cache from the previous run. The files are large enough that they all don’t remain in the cache (the test system was configured with 6 GB of RAM).</p></blockquote><h2 id="file-sharing"><a class="header-anchor" href="#file-sharing"> </a>File Sharing</h2><p>The UNIX System supports the sharing of open files among different processes. Before describing the dup function, we need to describe this sharing. To do this, we’ll examine the data structures used by the kernel for all I/O.</p><blockquote><p>The following description is conceptual; it may or may not match a particular implementation. Refer to Bach [1986] for a discussion of these structures in System V. McKusick et al. [1996] describe these structures in 4.4BSD. McKusick and Neville-Neil [2005] cover FreeBSD 5.2. For a similar discussion of Solaris, see McDougall and Mauro [2007]. The Linux 2.6 kernel architecture is discussed in Bovet and Cesati [2006].</p></blockquote><p>The kernel uses three data structures to represent an open file, and the relationships among them determine the effect one process has on another with regard to file sharing.</p><ol><li><p>Every process has an entry in the process table. Within each process table entry is a table of open file descriptors, which we can think of as a vector, with one entry per descriptor. Associated with each file descriptor are</p><ol><li>The file descriptor flags (close-on-exec; refer to Figure 3.7 and Section 3.14)</li><li>A pointer to a file table entry</li></ol></li><li><p>The kernel maintains a file table for all open files. Each file table entry contains</p><ol><li>The file status flags for the file, such as read, write, append, sync, and nonblocking; more on these in Section 3.14</li><li>The current file offset</li><li>A pointer to the v-node table entry for the file</li></ol></li><li><p>Each open file (or device) has a v-node structure that <strong>contains information about the type of file</strong> and <strong>pointers to functions that operate on the file</strong>. For most files, the v-node also contains the i-node for the file. <strong>This information is read from disk when the file is opened</strong>, so that all the pertinent information about the file is readily available. For example, <strong>the i-node contains the owner of the file, the size of the file, pointers to where the actual data blocks for the file are located on disk</strong>, and so on. (We talk more about i-nodes in Section 4.14 when we describe the typical UNIX file system in more detail.)</p></li></ol><blockquote><p>Linux has no v-node. Instead, a generic i-node structure is used. Although the implementations differ, the v-node is conceptually the same as a generic i-node. Both point to an i-node structure specific to the file system.</p></blockquote><p>We’re ignoring some implementation details that don’t affect our discussion. For example, the table of open file descriptors can be stored in the user area (a separate per- process structure that can be paged out) instead of the process table. Also, these tables can be implemented in numerous ways—they need not be arrays; one alternate implementation is a linked lists of structures. Regardless of the implementation details, the general concepts remain the same.</p><p>Figure 3.7 shows a pictorial arrangement of these three tables for a single process that has two different files open: one file is open on standard input (file descriptor 0), and the other is open on standard output (file descriptor 1).</p><img src="https://i.loli.net/2018/05/30/5b0e51e54c6d1.png"><p>The arrangement of these three tables has existed since the early versions of the UNIX System [Thompson 1978]. <strong>This arrangement is critical to the way files are shared among processes</strong>. We’ll return to this figure in later chapters, when we describe additional ways that files are shared.</p><blockquote><p><strong>The v-node was invented to provide support for multiple file system types on a single computer system</strong>. This work was done independently by Peter Weinberger (Bell Laboratories) and Bill Joy (Sun Microsystems). <strong>Sun called this the Virtual File System and called the file system–independent portion of the i-node the v-node</strong> [Kleiman 1986]. The v-node propagated through various vendor implementations as support for Sun’s Network File System (NFS) was added. The first release from Berkeley to provide v-nodes was the 4.3BSD Reno release, when NFS was added.</p></blockquote><blockquote><p>In SVR4, the v-node replaced the file system–independent i-node of SVR3. Solaris is derived from SVR4 and, therefore, uses v-nodes.</p></blockquote><blockquote><p>Instead of splitting the data structures into a v-node and an i-node, Linux uses a file system–independent i-node and a file system–dependent i-node.</p></blockquote><p>If two independent processes have the same file open, we could have the arrangement shown in Figure 3.8.</p><img src="https://i.loli.net/2018/05/30/5b0e5b6638838.png"><p>We assume here that the first process has the file open on descriptor 3 and that the second process has that same file open on descriptor 4. Each process that opens the file gets its own file table entry, but only a single v-node table entry is required for a given file. One reason each process gets its own file table entry is so that each process has its own current offset for the file.</p><p>Given these data structures, we now need to be more specific about what happens with certain operations that we’ve already described.</p><ul><li>After each write is complete, the current file offset in the file table entry is incremented by the number of bytes written. If this causes the current file offset to exceed the current file size, the current file size in the i-node table entry is set to the current file offset (for example, the file is extended).</li><li>If a file is opened with the O_APPEND flag, a corresponding flag is set in the file status flags of the file table entry. Each time a write is performed for a file with this append flag set, the current file offset in the file table entry is first set to the current file size from the i-node table entry. This forces every write to be appended to the current end of file. 如果一个文件打开时使用<code>O_APPEND</code>标志，相应的标志会设置到文件表项的文件状态符。每次进行写操作时，文件表项就会首先将当前文件偏移量设置为i结点表项的当前文件大小。这样就可以强制每次都写到文件末尾了。</li><li>If a file is positioned to its current end of file using lseek, all that happens is the current file offset in the file table entry is set to the current file size from the i-node table entry. (Note that this is not the same as if the file was opened with the O_APPEND flag, as we will see in Section 3.11.)</li><li>The lseek function modifies only the current file offset in the file table entry. No I/O takes place.</li></ul><p>It is possible for more than one file descriptor entry to point to the same file table entry, as we’ll see when we discuss the dup function in Section 3.12. This also happens after a fork when the parent and the child share the same file table entry for each open descriptor (Section 8.3).</p><p><strong>Note the difference in scope between the file descriptor flags and the file status flags. The former apply only to a single descriptor in a single process, whereas the latter apply to all descriptors in any process that point to the given file table entry</strong>. When we describe the fcntl function in Section 3.14, we’ll see how to fetch and modify both the file descriptor flags and the file status flags.</p><p>Everything that we’ve described so far in this section works fine for multiple processes that are reading the same file. Each process has its own file table entry with its own current file offset. Unexpected results can arise, however, when multiple processes write to the same file. To see how to avoid some surprises, we need to understand the concept of atomic operations.</p><h2 id="atomic-operations"><a class="header-anchor" href="#atomic-operations"> </a>Atomic Operations</h2><h3 id="appending-to-a-file"><a class="header-anchor" href="#appending-to-a-file"> </a>Appending to a File</h3><p>Consider a single process that wants to append to the end of a file. Older versions of the UNIX System didn’t support the O_APPEND option to open, so the program was coded as follows:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (lseek(fd, <span class="number">0L</span>, <span class="number">2</span>) &lt; <span class="number">0</span>)         <span class="comment">/* position to EOF */</span></span><br><span class="line">trueerr_sys(<span class="string">"lseek error"</span>);</span><br><span class="line"><span class="keyword">if</span> (write(fd, buf, <span class="number">100</span>) != <span class="number">100</span>)   <span class="comment">/* and write */</span></span><br><span class="line">trueerr_sys(<span class="string">"write error"</span>);</span><br></pre></td></tr></table></figure><p>This works fine for a single process, but problems arise if multiple processes use this technique to append to the same file. (This scenario can arise if multiple instances of the same program are appending messages to a log file, for example.)</p><p>Assume that two independent processes, A and B, are appending to the same file. Each has opened the file but without the O_APPEND flag. This gives us the same picture as Figure 3.8. Each process has its own file table entry, but they share a single v-node table entry. Assume that process A does the lseek and that this sets the current offset for the file for process A to byte offset 1,500 (the current end of file). Then the kernel switches processes, and B continues running. Process B then does the lseek, which sets the current offset for the file for process B to byte offset 1,500 also (the current end of file). Then B calls write, which increments B’s current file offset for the file to 1,600. Because the file’s size has been extended, the kernel also updates the current file size in the v-node to 1,600. Then the kernel switches processes and A resumes. When A calls write, the data is written starting at the current file offset for A, which is byte offset 1,500. This overwrites the data that B wrote to the file.</p><p>The problem here is that our logical operation of ‘‘position to the end of file and write’’ requires two separate function calls (as we’ve shown it). The solution is to have the positioning to the current end of file and the write be an atomic operation with regard to other processes. Any operation that requires more than one function call cannot be atomic, as there is always the possibility that the kernel might temporarily suspend the process between the two function calls (as we assumed previously).</p><p>The UNIX System provides an atomic way to do this operation if we set the O_APPEND flag when a file is opened. As we described in the previous section, this causes the kernel to position the file to its current end of file before each write. We no longer have to call lseek before each write.</p><h3 id="pread-and-pwrite-functions"><a class="header-anchor" href="#pread-and-pwrite-functions"> </a>pread and pwrite Functions</h3><p>The Single UNIX Specification includes two functions that allow applications to seek and perform I/O atomically: pread and pwrite.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns: number of bytes read, 0 if end of file, −1 on error</span></span><br><span class="line"><span class="keyword">ssize_t</span> pread(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">off_t</span> offset);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns: number of bytes written if OK, −1 on error</span></span><br><span class="line"><span class="keyword">ssize_t</span> pwrite(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">off_t</span> offset);</span><br></pre></td></tr></table></figure><p>Calling pread is equivalent to calling lseek followed by a call to read, with the following exceptions.</p><ul><li>There is no way to interrupt the two operations that occur when we call pread.</li><li>The current file offset is not updated.</li></ul><p>Calling pwrite is equivalent to calling lseek followed by a call to write, with similar exceptions.</p><h3 id="creating-a-file"><a class="header-anchor" href="#creating-a-file"> </a>Creating a File</h3><p>We saw another example of an atomic operation when we described the O_CREAT and O_EXCL options for the open function. When both of these options are specified, the open will fail if the file already exists. We also said that the check for the existence of the file and the creation of the file was performed as an atomic operation. If we didn’t have this atomic operation, we might try</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((fd = open(path, O_WRONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (errno == ENOENT) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((fd = creat(path, mode)) &lt; <span class="number">0</span>)</span><br><span class="line">            err_sys(<span class="string">"creat error"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        err_sys(<span class="string">"open error"</span>);</span><br><span class="line">&#125; &#125;</span><br></pre></td></tr></table></figure><p>The problem occurs if the file is created by another process between the open and the creat. If the file is created by another process between these two function calls, and if that other process writes something to the file, that data is erased when this creat is executed. Combining the test for existence and the creation into a single atomic operation avoids this problem.</p><p>In general, the term atomic operation refers to an operation that might be composed of multiple steps. If the operation is performed atomically, either all the steps are performed (on success) or none are performed (on failure). It must not be possible for only a subset of the steps to be performed. We’ll return to the topic of atomic operations when we describe the link function (Section 4.15) and record locking (Section 14.3).</p><h2 id="dup-and-dup2-functions"><a class="header-anchor" href="#dup-and-dup2-functions"> </a>dup and dup2 Functions</h2><p>An existing file descriptor is duplicated by either of the following functions:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Both return: new file descriptor if OK, −1 on error</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> fd2)</span></span>;</span><br></pre></td></tr></table></figure><p>The new file descriptor returned by dup is guaranteed to be the lowest-numbered available file descriptor. <strong>With dup2, we specify the value of the new descriptor with the fd2 argument. If fd2 is already open, it is first closed. If fd equals fd2, then dup2 returns fd2 without closing it. Otherwise, the FD_CLOEXEC file descriptor flag is cleared for fd2, so that fd2 is left open if the process calls exec</strong>.</p><p>The new file descriptor that is returned as the value of the functions shares the same file table entry as the fd argument. We show this in Figure 3.9.</p><img src="https://i.loli.net/2018/05/30/5b0e6c0a52034.png"><p>In this figure, we assume that when it’s started, the process executes</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newfd = dup(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>We assume that the next available descriptor is 3 (which it probably is, since 0, 1, and 2 are opened by the shell). Because both descriptors point to the same file table entry, they share the same file status flags—read, write, append, and so on—and the same current file offset.</p><p>Each descriptor has its own set of file descriptor flags. As we describe in Section 3.14, the close-on-exec file descriptor flag for the new descriptor is always cleared by the dup functions.</p><p>Another way to duplicate a descriptor is with the fcntl function, which we describe in Section 3.14. Indeed, the call</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dup(fd);</span><br></pre></td></tr></table></figure><p>is equivalent to</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fcntl(fd, F_DUPFD, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>Similarly, the call</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dup2(fd, fd2);</span><br></pre></td></tr></table></figure><p>is equivalent to</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">close(fd2);</span><br><span class="line">fcntl(fd, F_DUPFD, fd2);</span><br></pre></td></tr></table></figure><p>In this last case, the dup2 is not exactly the same as a close followed by an fcntl. The differences are as follows:</p><ol><li>dup2 is an atomic operation, whereas the alternate form involves two function calls. It is possible in the latter case to have a signal catcher called between the close and the fcntl that could modify the file descriptors. (We describe signals in Chapter 10.) The same problem could occur if a different thread changes the file descriptors. (We describe threads in Chapter 11.)</li><li>There are some errno differences between dup2 and fcntl.</li></ol><blockquote><p>The dup2 system call originated with Version 7 and propagated through the BSD releases. The fcntl method for duplicating file descriptors appeared with System III and continued with SystemV. SVR3.2 picked up the dup2 function, and 4.2BSD picked up the fcntl function and the F_DUPFD functionality. POSIX.1 requires both dup2 and the F_DUPFD feature of fcntl.</p></blockquote><h2 id="sync-fsync-and-fdatasync-functions"><a class="header-anchor" href="#sync-fsync-and-fdatasync-functions"> </a>sync, fsync, and fdatasync Functions</h2><p>Traditional implementations of the UNIX System have a buffer cache or page cache in the kernel through which most disk I/O passes. When we write data to a file, the data is normally copied by the kernel into one of its buffers and queued for writing to disk at some later time. This is called delayed write. (Chapter 3 of Bach [1986] discusses this buffer cache in detail.)</p><p>The kernel eventually writes all the delayed-write blocks to disk, normally when it needs to reuse the buffer for some other disk block. To ensure consistency of the file system on disk with the contents of the buffer cache, the sync, fsync, and fdatasync functions are provided.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Both Returns: 0 if OK, −1 on error</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fdatasync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>The sync function simply queues all the modified block buffers for writing and returns; it does not wait for the disk writes to take place</strong>.</p><p><strong>The function sync is normally called periodically (usually every 30 seconds) from a system daemon, often called update</strong>. This guarantees regular flushing of the kernel’s block buffers. The command sync(1) also calls the sync function.</p><p>The function fsync refers only to a single file, specified by the file descriptor fd, and <strong>waits for the disk writes to complete before returning</strong>. This function is used when an application, <strong>such as a database</strong>, needs to be sure that the modified blocks have been written to the disk.</p><p><strong>The fdatasync function is similar to fsync, but it affects only the data portions of a file. With fsync, the file’s attributes are also updated synchronously</strong>.</p><blockquote><p>All four of the platforms described in this book support sync and fsync. However, FreeBSD 8.0 does not support fdatasync.</p></blockquote><h2 id="fcntl-function"><a class="header-anchor" href="#fcntl-function"> </a>fcntl Function</h2><p>The fcntl function can change the properties of a file that is already open.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns: depends on cmd if OK (see following), −1 on error</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* int arg */</span> )</span></span>;</span><br></pre></td></tr></table></figure><p>In the examples in this section, the third argument is always an integer, corresponding to the comment in the function prototype just shown. When we describe record locking in Section 14.3, however, the third argument becomes a pointer to a structure.</p><p>The fcntl function is used for five different purposes.</p><ol><li><p>Duplicate an existing descriptor (cmd = F_DUPFD or F_DUPFD_CLOEXEC)</p></li><li><p>Get/set file descriptor flags (cmd = F_GETFD or F_SETFD)</p></li><li><p>Get/set file status flags (cmd = F_GETFL or F_SETFL)</p></li><li><p>Get/set asynchronous I/O ownership (cmd = F_GETOWN or F_SETOWN)</p></li><li><p>Get/set record locks (cmd = F_GETLK, F_SETLK, or F_SETLKW)</p></li></ol><p>We’ll now describe the first 8 of these 11 cmd values. (We’ll wait until Section 14.3 to describe the last 3, which deal with record locking.) Refer to Figure 3.7, as we’ll discuss both the file descriptor flags associated with each file descriptor in the process table entry and the file status flags associated with each file table entry.</p><p>F_DUPFD Duplicate the file descriptor fd. The new file descriptor is returned as the value of the function. It is the lowest-numbered descriptor that is not already open, and that is greater than or equal to the third argument (taken as an integer). The new descriptor shares the same file table entry as fd. (Refer to Figure 3.9.) But the new descriptor has its own set of file descriptor flags, and its FD_CLOEXEC file descriptor flag is cleared. (This means that the descriptor is left open across an exec, which we discuss in Chapter 8.)</p><p>F_DUPFD_CLOEXECDuplicate the file descriptor and set the FD_CLOEXEC file descriptor flag associated with the new descriptor. Returns the new file descriptor.</p><p>F_GETFD Return the file descriptor flags for fd as the value of the function. Currently, only one file descriptor flag is defined: the FD_CLOEXEC flag.</p><p>F_SETFD Set the file descriptor flags for fd. The new flag value is set from the third argument (taken as an integer).</p><blockquote><p>Be aware that some existing programs that deal with the file descriptor flags don’t use the constant FD_CLOEXEC. Instead, these programs set the flag to either 0 (don’t close-on-exec, the default) or 1 (do close-on-exec).</p></blockquote><p>F_GETFL Return the file status flags for fd as the value of the function. We described the file status flags when we described the open function. They are listed in Figure 3.10.</p><img src="https://i.loli.net/2018/05/31/5b0f49576d719.png" width="70%"><p>Unfortunately, the five access-mode flags—O_RDONLY, O_WRONLY, O_RDWR, O_EXEC, and O_SEARCH—are not separate bits that can be tested. (As we mentioned earlier, the first three often have the values 0, 1, and 2, respectively, for historical reasons. Also, these five values are mutually exclusive; a file can have only one of them enabled.) Therefore, we must first use the O_ACCMODE mask to obtain the access-mode bits and then compare the result against any of the five values.</p><p>F_SETFL Set the file status flags to the value of the third argument (taken as an integer). The only flags that can be changed are O_APPEND, O_NONBLOCK, O_SYNC, O_DSYNC, O_RSYNC, O_FSYNC, and O_ASYNC.</p><p>F_GETOWN Get the process ID or process group ID currently receiving the SIGIO and SIGURG signals. We describe these asynchronous I/O signals in Section 14.5.2.</p><p>F_SETOWN Set the process ID or process group ID to receive the SIGIO and SIGURG signals. A positive arg specifies a process ID. A negative arg implies a process group ID equal to the absolute value of arg.</p><p>The return value from fcntl depends on the command. All commands return −1 on an error or some other value if OK. The following four commands have special return values: F_DUPFD, F_GETFD, F_GETFL, and F_GETOWN. The first command returns the new file descriptor, the next two return the corresponding flags, and the final command returns a positive process ID or a negative process group ID.</p><h3 id="example-v3"><a class="header-anchor" href="#example-v3"> </a>Example</h3><p>The program in Figure 3.11 takes a single command-line argument that specifies a file descriptor and prints a description of selected file flags for that descriptor.</p><blockquote><p>Figure 3.11 Print file flags for specified descriptor</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"include/apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">     err_quit(<span class="string">"usage: a.out &lt;descriptor#&gt;"</span>);</span><br><span class="line">  <span class="keyword">if</span> ((val = fcntl(atoi(argv[<span class="number">1</span>]), F_GETFL, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">     err_sys(<span class="string">"fcntl error for fd %d"</span>, atoi(argv[<span class="number">1</span>]));</span><br><span class="line">  <span class="keyword">switch</span> (val &amp; O_ACCMODE) &#123;</span><br><span class="line">    <span class="keyword">case</span> O_RDONLY:</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"read only"</span>);</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> O_WRONLY:</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"write only"</span>);</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> O_RDWR:</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"read write"</span>);</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">       err_dump(<span class="string">"unknown access mode"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (val &amp; O_APPEND)</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">", append"</span>);</span><br><span class="line">  <span class="keyword">if</span> (val &amp; O_NONBLOCK)</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">", nonblocking"</span>);</span><br><span class="line">  <span class="keyword">if</span> (val &amp; O_SYNC)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">", synchronous writes"</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">if</span> !defined(_POSIX_C_SOURCE) &amp;&amp; defined(O_FSYNC) &amp;&amp; (O_FSYNC != O_SYNC)</span></span><br><span class="line">         <span class="keyword">if</span> (val &amp; O_FSYNC)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">", synchronous writes"</span>);</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="built_in">putchar</span>(<span class="string">'\n'</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Note that we use the feature test macro _POSIX_C_SOURCE and conditionally compile the file access flags that are not part of POSIX.1. The following script shows the operation of the program, when invoked from bash (the Bourne-again shell). Results will vary, depending on which shell you use.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  apue.3e ./fig3.11 0 &lt; /dev/tty</span><br><span class="line">read only</span><br><span class="line">➜  apue.3e ./fig3.11 1 &gt; temp.foo</span><br><span class="line">➜  apue.3e cat temp.foo</span><br><span class="line">write only</span><br><span class="line">➜  apue.3e ./fig3.11 2 2&gt;&gt;temp.foo</span><br><span class="line">write only, append</span><br><span class="line">➜  apue.3e ./fig3.11 5 5&lt;&gt;temp.foo</span><br><span class="line">read write</span><br></pre></td></tr></table></figure><p>The clause 5&lt;&gt;temp.foo opens the file temp.foo for reading and writing on file descriptor 5.</p><h3 id="example-v4"><a class="header-anchor" href="#example-v4"> </a>Example</h3><p>When we modify either the file descriptor flags or the file status flags, we must be careful to fetch the existing flag value, modify it as desired, and then set the new flag value. We can’t simply issue an F_SETFD or an F_SETFL command, as this could turn off flag bits that were previously set.</p><p>Figure 3.12 shows a function that sets one or more of the file status flags for a descriptor.</p><blockquote><p>Figure 3.12 Turn on one or more of the file status flags for a descriptor</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_fl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> flags)</span> <span class="comment">/* flags are file status flags to turn on */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">true<span class="keyword">int</span> val;</span><br><span class="line">true<span class="keyword">if</span> ((val = fcntl(fd, F_GETFL, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">true   err_sys(<span class="string">"fcntl F_GETFL error"</span>);</span><br><span class="line">trueval |= flags;       <span class="comment">/* turn on flags */</span></span><br><span class="line">true<span class="keyword">if</span> (fcntl(fd, F_SETFL, val) &lt; <span class="number">0</span>)</span><br><span class="line">true   err_sys(<span class="string">"fcntl F_SETFL error"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If we change the middle statement to</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val &amp;=  ̃flags;      <span class="comment">/* turn flags off */</span></span><br></pre></td></tr></table></figure><p>we have a function named clr_fl, which we’ll use in some later examples. This statement logically ANDs the one’s complement of flags with the current val.</p><p>If we add the line</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_fl(STDOUT_FILENO, O_SYNC);</span><br></pre></td></tr></table></figure><p>to the beginning of the program shown in Figure 3.5, we’ll turn on the synchronous- write flag. This causes each write to wait for the data to be written to disk before returning. Normally in the UNIX System, a write only queues the data for writing; the actual disk write operation can take place sometime later. A database system is a likely candidate for using O_SYNC, so that it knows on return from a write that the data is actually on the disk, in case of an abnormal system failure.</p><p>We expect the O_SYNC flag to increase the system and clock times when the program runs. To test this, we can run the program in Figure 3.5, copying 492.6 MB of data from one file on disk to another and compare this with a version that does the same thing with the O_SYNC flag set. The results from a Linux system using the ext4 file system are shown in Figure 3.13.</p><img src="https://i.loli.net/2018/05/31/5b0f4c0dc6161.png" width="80%"><p>The six rows in Figure 3.13 were all measured with a BUFFSIZE of 4,096 bytes. The results in Figure 3.6 were measured while reading a disk file and writing to /dev/null, so there was no disk output. The second row in Figure 3.13 corresponds to reading a disk file and writing to another disk file. This is why the first and second rows in Figure 3.13 are different. The system time increases when we write to a disk file, because the kernel now copies the data from our process and queues the data for writing by the disk driver. We expect the clock time to increase as well when we write to a disk file.</p><p>When we enable synchronous writes, the system and clock times should increase significantly. As the third row shows, the system time for writing synchronously is not much more expensive than when we used delayed writes. This implies that the Linux operating system is doing the same amount of work for delayed and synchronous writes (which is unlikely), or else the O_SYNC flag isn’t having the desired effect. In this case, the Linux operating system isn’t allowing us to set the O_SYNC flag using fcntl, instead failing without returning an error (but it would have honored the flag if we were able to specify it when the file was opened).</p><p>The clock time in the last three rows reflects the extra time needed to wait for all of the writes to be committed to disk. After writing a file synchronously, we expect that a call to fsync will have no effect. This case is supposed to be represented by the last row in Figure 3.13, but since the O_SYNC flag isn’t having the intended effect, the last row behaves the same way as the fifth row.</p><p>Figure 3.14 shows timing results for the same tests run on Mac OS X 10.6.8, which uses the HFS file system. Note that the times match our expectations: synchronous writes are far more expensive than delayed writes, and using fsync with synchronous writes makes very little difference. Note also that adding a call to fsync at the end of the delayed writes makes little measurable difference. It is likely that the operating system flushed previously written data to disk as we were writing new data to the file, so by the time that we called fsync, very little work was left to be done.</p><img src="https://i.loli.net/2018/05/31/5b0f4c6873af3.png" width="80%"><p>Compare fsync and fdatasync, both of which update a file’s contents when we say so, with the O_SYNC flag, which updates a file’s contents every time we write to the file. The performance of each alternative will depend on many factors, including the underlying operating system implementation, the speed of the disk drive, and the type of the file system.</p><p>With this example, we see the need for fcntl. Our program operates on a descriptor (standard output), never knowing the name of the file that was opened on that descriptor. We can’t set the O_SYNC flag when the file is opened, since the shell opened the file. With fcntl, we can modify the properties of a descriptor, knowing only the descriptor for the open file. We’ll see another need for fcntl when we describe nonblocking pipes (Section 15.2), since all we have with a pipe is a descriptor.</p><h2 id="ioctl-function"><a class="header-anchor" href="#ioctl-function"> </a>ioctl Function</h2><p>The ioctl function has always been the catchall for I/O operations. Anything that couldn’t be expressed using one of the other functions in this chapter usually ended up being specified with an ioctl. Terminal I/O was the biggest user of this function. (When we get to Chapter 18, we’ll see that POSIX.1 has replaced the terminal I/O operations with separate functions.)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;     /* System V */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;  /* BSD and Linux */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Returns: −1 on error, something else if OK</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ioctl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> request, ...)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>The ioctl function was included in the Single UNIX Specification only as an extension for dealing with STREAMS devices [Rago 1993], but it was moved to obsolescent status in SUSv4. UNIX System implementations use ioctl for many miscellaneous device operations. Some implementations have even extended it for use with regular files.</p></blockquote><p>The prototype that we show corresponds to POSIX.1. FreeBSD 8.0 and Mac OS X 10.6.8 declare the second argument as an unsigned long. This detail doesn’t matter, since the second argument is always a #defined name from a header.</p><p>For the ISO C prototype, an ellipsis is used for the remaining arguments. Normally, however, there is only one more argument, and it’s usually a pointer to a variable or a structure.</p><p>In this prototype, we show only the headers required for the function itself. Normally, additional device-specific headers are required. For example, the ioctl commands for terminal I/O, beyond the basic operations specified by POSIX.1, all require the &lt;termios.h&gt; header.</p><p>Each device driver can define its own set of ioctl commands. The system, however, provides generic ioctl commands for different classes of devices. Examples of some of the categories for these generic ioctl commands supported in FreeBSD are summarized in Figure 3.15.</p><img src="https://i.loli.net/2018/05/31/5b0f4cf6d20f6.png" width="60%"><p>The mag tape operations allow us to write end-of-file marks on a tape, rewind a tape, space forward over a specified number of files or records, and the like. None of these operations is easily expressed in terms of the other functions in the chapter (read, write, lseek, and so on), so the easiest way to handle these devices has always been to access their operations using ioctl.</p><p>We use the ioctl function in Section 18.12 to fetch and set the size of a terminal’s window, and in Section 19.7 when we access the advanced features of pseudo terminals.</p><h2 id="dev-fd"><a class="header-anchor" href="#dev-fd"> </a>/dev/fd</h2><p>Newer systems provide a directory named /dev/fd whose entries are files named 0, 1, 2, and so on. Opening the file /dev/fd/n is equivalent to duplicating descriptor n, assuming that descriptor n is open.</p><blockquote><p>The /dev/fd feature was developed by Tom Duff and appeared in the 8th Edition of the Research UNIX System. It is supported by all of the systems described in this book: FreeBSD 8.0, Linux 3.2.0, Mac OS X 10.6.8, and Solaris 10. It is not part of POSIX.1.</p></blockquote><p>In the function call</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd = open(<span class="string">"/dev/fd/0"</span>, mode);</span><br></pre></td></tr></table></figure><p>most systems ignore the specified mode, whereas others require that it be a subset of the mode used when the referenced file (standard input, in this case) was originally opened. Because the previous open is equivalent to</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd = dup(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>the descriptors 0 and fd share the same file table entry (Figure 3.9). For example, if descriptor 0 was opened read-only, we can only read on fd. Even if the system ignores the open mode and the call</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd = open(<span class="string">"/dev/fd/0"</span>, O_RDWR);</span><br></pre></td></tr></table></figure><p>succeeds, we still can’t write to fd.</p><blockquote><p>The Linux implementation of /dev/fd is an exception. It maps file descriptors into symbolic links pointing to the underlying physical files. When you open /dev/fd/0, for example, you are really opening the file associated with your standard input. Thus the mode of the new file descriptor returned is unrelated to the mode of the /dev/fd file descriptor.</p></blockquote><p>We can also call creat with a /dev/fd pathname argument as well as specify O_CREAT in a call to open. This allows a program that calls creat to still work if the pathname argument is /dev/fd/1, for example.</p><blockquote><p>Beware of doing this on Linux. Because the Linux implementation uses symbolic links to the real files, using creat on a /dev/fd file will result in the underlying file being truncated.</p></blockquote><p>Some systems provide the pathnames /dev/stdin, /dev/stdout, and /dev/stderr. These pathnames are equivalent to /dev/fd/0, /dev/fd/1, and /dev/fd/2, respectively.</p><p>The main use of the /dev/fd files is from the shell. It allows programs that use pathname arguments to handle standard input and standard output in the same manner as other pathnames. For example, the cat(1) program specifically looks for an input filename of - and uses it to mean standard input. The command</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter file2 | cat file1 - file3 | lpr</span><br></pre></td></tr></table></figure><p>is an example. First, cat reads file1, then its standard input (the output of the filter program on file2), and then file3. If /dev/fd is supported, the special handling of - can be removed from cat, and we can enter</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filter file2 | cat file1 /dev/fd/0 file3 | lpr</span><br></pre></td></tr></table></figure><p>The special meaning of - as a command-line argument to refer to the standard input or the standard output is a kludge that has crept into many programs. There are also problems if we specify - as the first file, as it looks like the start of another command-line option. Using /dev/fd is a step toward uniformity and cleanliness.</p><h2 id="summary"><a class="header-anchor" href="#summary"> </a>Summary</h2><p>This chapter has described the basic I/O functions provided by the UNIX System. These are often called the unbuffered I/O functions because each read or write invokes a system call into the kernel. Using only read and write, we looked at the effect of various I/O sizes on the amount of time required to read a file. We also looked at several ways to flush written data to disk and their effect on application performance.</p><p>Atomic operations were introduced when multiple processes append to the same file and when multiple processes create the same file. We also looked at the data structures used by the kernel to share information about open files. We’ll return to these data structures later in the text.</p><p>We also described the ioctl and fcntl functions. We return to both of these functions later in the book. In Chapter 14, we’ll use fcntl for record locking. In Chapter 18 and Chapter 19, we’ll use ioctl when we deal with terminal devices.</p><h2 id="exercises"><a class="header-anchor" href="#exercises"> </a>Exercises</h2><ol><li><p>When reading or writing a disk file, are the functions described in this chapter really unbuffered? Explain.</p></li><li><p>Write your own dup2 function that behaves the same way as the dup2 function described in Section 3.12, without calling the fcntl function. Be sure to handle errors correctly.</p></li><li><p>Assume that a process executes the following three function calls:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fd1 = open(path, oflags);</span><br><span class="line">fd2 = dup(fd1);</span><br><span class="line">fd3 = open(path, oflags);</span><br></pre></td></tr></table></figure><p>Draw the resulting picture, similar to Figure 3.9. Which descriptors are affected by an fcntl on fd1 with a command of F_SETFD? Which descriptors are affected by an fcntl on fd1 with a command of F_SETFL?</p></li><li><p>The following sequence of code has been observed in various programs:</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dup2(fd, <span class="number">0</span>);</span><br><span class="line">dup2(fd, <span class="number">1</span>);</span><br><span class="line">dup2(fd, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (fd &gt; <span class="number">2</span>)</span><br></pre></td></tr></table></figure></li></ol><p>close(fd);</p><p>To see why the if test is needed, assume that fd is 1 and draw a picture of what happens to the three descriptor entries and the corresponding file table entry with each call to dup2. Then assume that fd is 3 and draw the same picture.</p>]]></content>
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 《APUE-3rd》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unix </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《APUE-3rd》 读书笔记 -- Unix System Overview</title>
      <link href="/blog/2018/05/22/APUE-3rd-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--Unix%20System%20Overview/"/>
      <url>/blog/2018/05/22/APUE-3rd-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--Unix%20System%20Overview/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a class="header-anchor" href="#前言"> </a>前言</h2><p>Unix系统中非常重要的概念：</p><ul><li>内核</li><li>系统调用</li><li>库函数</li><li>shell</li><li>文件、目录、路径、工作路径、权限管理</li><li>文件描述符</li><li>进程、线程</li><li>错误处理</li><li>信号</li></ul><h2 id="1-1-introduction"><a class="header-anchor" href="#1-1-introduction"> </a>1.1    Introduction</h2><p>All operating systems provide services for programs they run. Typical services include executing a new program, opening a file, reading a file, allocating a region of memory, getting the current time of day, and so on. The focus of this text is to describe the services provided by various versions of the UNIX operating system. 所有的操作系统都提供一些服务让程序能够在其上运行，典型的服务包括：执行一个新程序，打开一个文件，读取一个文件，分配一块内存，获取当前时间，等等。 这本书所关注的重点就是众多种类的unix操作系统能提供服务。</p><p>Describing the UNIX System in a strictly linear fashion, without any forward references to terms that haven’t been described yet, is nearly impossible (and would probably be boring). 这里道出了一个众所周知的难题，想要线性的给读者讲授一个新课程，在讲授一个知识点时却又不引进任何其他的未知概念，这几乎是不可能的。</p><blockquote><p>但我认为能不能做到，不用去管，做教育的就是要尽可能的降低学习者的难度，将新知识点尽可能的用学习者已有的知识结构描述清楚。所以我们可以看到我们的课程都是有选修课的。</p></blockquote><h2 id="1-2-unix-architecture"><a class="header-anchor" href="#1-2-unix-architecture"> </a>1.2    Unix Architecture</h2><img src="https://i.loli.net/2018/05/22/5b03742b0a818.png" width="50%"><ul><li>内核（kernel）：In a strict sense, an operating system can be defined as the software that <strong>controls the hardware resources of the computer</strong> and <strong>provides an environment under which programs can run</strong>. Generally, we call this software the <code>kernel</code>, since it is <strong>relatively small and resides at the core of the environment</strong>. 内核控制硬件资源，并给其上的程序提供运行环境，内核相对（相对是指相对于上面这张图，整个软件环境：包括内核、系统调用、公用函数库、shell(命令解释器)、应用程序）来说比较小，并处于整个环境的中心。</li><li>系统调用（system calls）：<strong>The interface to the kernel</strong> is a layer of software called the system calls . 系统调用是内核对外的接口。</li><li>Libraries of common functions are built on top of the system call interface, but applications are free to use both. The shell is a special application that provides an interface for running other applications. 公共库是建立在系统调用之上的，但应用程序既可以使用公共库也可以使用系统调用。shell是一种特殊的应用程序，给执行命令(运行其他程序)提供接口。</li></ul><p>In a broad sense, an operating system consists of the kernel and all the other software that makes a computer useful and gives the computer its personality. This other software includes system utilities, applications, shells, libraries of common functions, and so on.</p><p>For example, Linux is the kernel used by the GNU operating system. Some people refer to this combination as the GNU/Linux operating system, but it is more commonly referred to as simply Linux. Although this usage may not be correct in a strict sense, it is understandable, given the dual meaning of the phrase operating system. (It also has the advantage of being more succinct.)</p><h2 id="1-3-logging-in"><a class="header-anchor" href="#1-3-logging-in"> </a>1.3    Logging In</h2><h3 id="login-name"><a class="header-anchor" href="#login-name"> </a>Login Name</h3><p>When we log in to a UNIX system, we enter our login name, followed by our password. The system then looks up our login name in its password file, usually the file /etc/passwd. If we look at our entry in the password file, we see that it’s composed of seven colon-separated fields: the login name, encrypted password, numeric user ID (205), numeric group ID (105), a comment field, home directory (/home/sar), and shell program (/bin/ksh).<br><strong>口令文件（password file）</strong> ：当我们使用用户名和密码登陆unix的时候，系统会在<code>/etc/passwd</code>文件(password file，又叫：口令文件)中查找我们的用户名，口令文件中每个条目占一行，格式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">登录名:加密过的密码:user ID:group ID:注解:home目录:shell</span><br></pre></td></tr></table></figure><p>All contemporary systems have moved the encrypted password to a different file. In Chapter 6, we’ll look at these files and some functions to access them.</p><blockquote><p>不过加密过的密码现在也不显示在这个文件里了，而是用一个<code>*</code>号或者<code>x</code>号之类的取代，home目录又称为起始目录，新开一个shell，<code>pwd</code>一下，就是home目录。</p></blockquote><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sar:x:205:105:Stephen Rago:/home/sar:/bin/ksh</span><br></pre></td></tr></table></figure><p>登录名是sar，加密过的密码是<code>x</code>（不显示在这里），user ID是205，group ID是105，注解是Stephen Rago，home目录是<code>/home/sar</code>，使用的shell是<code>/bin/ksh</code></p><h3 id="shells"><a class="header-anchor" href="#shells"> </a>Shells</h3><p>A shell is a command-line interpreter that reads user input and executes commands. The user input to a shell is normally from the terminal (an interactive shell) or sometimes from a file (called a shell script). shell是一种命令解释器，可以读取用户的输入，并执行命令，用户可以交互式的输入命令，也可以把命令预先全部写在一个文本文件（shell脚本）中让shell执行。</p><p>常见的shell有：</p><img src="https://i.loli.net/2018/05/23/5b04b995bf5e1.png" width="70%"><p>The system knows which shell to execute for us based on the final field in our entry in the password file. 系统是通过口令文件的最后一个字段知道我们登陆时使用哪个shell。</p><p><code>bash</code>的全称是<code>Bourne-again shell</code></p><p>The Bourne-again shell is the GNU shell provided with all Linux systems. It was designed to be POSIX conformant, while still remaining compatible with the Bourne shell. It supports features from both the C shell and the Korn shell.</p><h2 id="1-4-files-and-directories"><a class="header-anchor" href="#1-4-files-and-directories"> </a>1.4     Files and Directories</h2><h3 id="file-system"><a class="header-anchor" href="#file-system"> </a>File System</h3><ul><li><strong>根目录（root）</strong>：The UNIX file system is a hierarchical arrangement of directories and files. Everything starts in the directory called root, whose name is the single character /. unix文件系统是目录和文件的层级安排，所有东西都从一个叫root的目录开始，root的名字是一个单字符：<code>/</code>。</li><li><strong>目录（directory）</strong>：A directory is a file that contains directory entries. Logically, we can think of each directory entry as containing a filename along with a structure of information describing the attributes of the file. The attributes of a file are such things as the type of file (regular file, directory), the size of the file, the owner of the file, permissions for the file (whether other users may access this file), and when the file was last modified. 目录是一个包含目录条目的文件。逻辑上，我们可以认为每一个目录条目包含一个文件名和一个描述文件属性的结构信息。文件属性包括：文件类型（普通文件还是目录），文件大小，文件所属者，文件权限（其他用户是否能访问），文件最后被修改的时间。</li></ul><blockquote><p>The stat and fstat functions return a structure of information containing all the attributes of a file. <code>stat</code>和<code>fstat</code>函数可以返回一个结构信息，包含文件的所有属性。</p></blockquote><blockquote><p>We make a distinction between the logical view of a directory entry and the way it is actually stored on disk. Most implementations of UNIX file systems don’t store attributes in the directory entries themselves, because of the difficulty of keeping them in synch when a file has multiple hard links. 也就是说上面目录条目只是逻辑上的，实际上在硬盘存储上并不是直接将目录条目中的那些属性存储在目录文件中的，因为如果文件有硬链接的话，很难让这些属性信息保持同步。</p></blockquote><h3 id="filename"><a class="header-anchor" href="#filename"> </a>Filename</h3><p><strong>文件名</strong>：The names in a directory are called filenames. The only two characters that cannot appear in a filename are the slash character (/) and the null character. The slash separates the filenames that form a pathname (described next) and the null character terminates a pathname. Nevertheless, it’s good practice to restrict the characters in a filename to a subset of the normal printing characters. (If we use some of the shell’s special characters in the filename, we have to use the shell’s quoting mechanism to reference the filename, and this can get complicated.) Indeed, for portability, POSIX.1 recommends restricting filenames to consist of the following characters: letters (a-z, A-Z), numbers (0-9), period (.), dash (-), and underscore (_).<br>一个目录中的诸多名字（包括文件和目录）称为文件名，只有两个字符不能出现在文件名中：<code>斜杠/(slash)</code>和<code>空字符(null character)</code>，斜杠用来分割<code>路径名(pathname)</code>中的文件名，空字符用来结束一个路径名（实际上编程语言中字符串就是由空字符来结束的）。然而，我们命名文件的时候最好不要使用一些乱七八糟的字符，如果我们使用了shell的特殊字符，我们就必须使用shell的引用机制去引用文件名。实际上，为了可移植性，POSIX.1标准推荐严格使用以下字符来命名文件：字母(a-z, A-Z)，数字(0-9)，点(.)，中杠(-)，下划线(_)。</p><p>Two filenames are automatically created whenever a new directory is created: . (called dot) and … (called dot-dot). Dot refers to the current directory, and dot-dot refers to the parent directory. In the root directory, dot-dot is the same as dot. 有两个文件名在目录被创建的时候自动创建：<code>.</code>和<code>..</code>，<code>.</code>指向当前目录，<code>..</code>指向父目录，在根目录中，<code>..</code>和<code>.</code>一样（都指向当前目录）。</p><blockquote><p>The Research UNIX System and some older UNIX System V file systems restricted a filename to 14 characters. BSD versions extended this limit to 255 characters. Today, almost all commercial UNIX file systems support at least 255-character filenames. 现如今的unix文件系统都支持至少255字符的文件名。</p></blockquote><h3 id="pathname"><a class="header-anchor" href="#pathname"> </a>Pathname</h3><p>A sequence of one or more filenames, separated by slashes and optionally starting with a slash, forms a pathname. A pathname that begins with a slash is called an absolute pathname; otherwise, it’s called a relative pathname. Relative pathnames refer to files relative to the current directory. 一系列的由斜杠分割而开的文件名组成一个路径名，一个路径名可以由一个斜杠开始，这叫做：<code>绝对路径</code>，反之就是相对路径，相对路径是相对于当前路径的。</p><h3 id="example"><a class="header-anchor" href="#example"> </a>Example</h3><p>Listing the names of all the files in a directory is not difficult. There is a bare-bones implementation of the ls(1) command:</p><blockquote><p>Figure 1.3 List all the files in a directory</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   DIR *dp;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">dirp</span>;</span></span><br><span class="line">   <span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">       err_quit(<span class="string">"usage: ls directory_name"</span>);</span><br><span class="line">   <span class="keyword">if</span> ((dp = opendir(argv[<span class="number">1</span>])) == <span class="literal">NULL</span>)</span><br><span class="line">       err_sys(<span class="string">"can’t open %s"</span>, argv[<span class="number">1</span>]);</span><br><span class="line">   <span class="keyword">while</span> ((dirp = readdir(dp)) != <span class="literal">NULL</span>)</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, dirp-&gt;d_name);</span><br><span class="line">    closedir(dp);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>The notation ls(1) is the normal way to reference a particular entry in the UNIX system manuals. It refers to the entry for ls in Section 1. The sections are normally numbered 1 through 8, and all the entries within each section are arranged alphabetically. Throughout this text, we assume that you have a copy of the manuals for your UNIX system.  熟悉unix的人应该都知道，unix有个man命令，可以查看其它命令的说明书，当然也可以<code>man man</code>查看自己的说明书。 man命令有8个section，每个section里的条目按照字幕顺序排列。</p><blockquote><p>Historically, UNIX systems lumped all eight sections together into what was called the UNIX Programmer’s Manual. As the page count increased, the trend changed to distributing the sections among separate manuals: <strong>one for users, one for programmers, and one for system administrators</strong>, for example. Some UNIX systems further divide the manual pages within a given section, using an uppercase letter. For example, all the standard input/output (I/O) functions in AT&amp;T [1990e] are indicated as being in Section 3S, as in fopen(3S). Other systems have replaced the numeric sections with alphabetic ones, such as C for commands.</p></blockquote><p>Today, most manuals are distributed in electronic form. If your manuals are online, the way to see the manual pages for the ls command would be something like</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man 1 ls</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man -s1 ls</span><br></pre></td></tr></table></figure><p>Figure 1.3 is a program that just prints the name of every file in a directory, and nothing else. If the source file is named myls.c, we compile it into the default a.out executable file by running</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cc myls.c</span><br></pre></td></tr></table></figure><blockquote><p>Historically, cc(1) is the C compiler. On systems with the GNU C compilation system, the C compiler is gcc(1). Here, cc is usually linked to gcc.</p></blockquote><p>但在实际的操作过程中，遇到了如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Undefined symbols for architecture x86_64:</span><br><span class="line">  &quot;_err_quit&quot;, referenced from:</span><br><span class="line">      _main in fig1-457251.o</span><br><span class="line">  &quot;_err_sys&quot;, referenced from:</span><br><span class="line">      _main in fig1-457251.o</span><br><span class="line">ld: symbol(s) not found for architecture x86_64</span><br><span class="line">clang: error: linker command failed with exit code 1 (use -v to see invocation)</span><br></pre></td></tr></table></figure><p>这是个链接错误，具体的解决办法请看这篇博客：<a href="https://my.oschina.net/alextuan/blog/530425" target="_blank" rel="noopener">OS X下UNIX环境高级编程（第三版）学习日志－第一章ChapterI，编译apue包与第一个例程</a></p><p>实际上要先单独编译<code>myls.c</code>，使用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c myls.c</span><br></pre></td></tr></table></figure><p>得到<code>myls.o</code>，然后与依赖的其他目标文件组合成一个可执行文件，我们可以把本书要用到的所有依赖组合成一个静态库，在apue源代码的根目录下面<code>make</code>一下，编译完成后就可以在lib目录下找到静态库：<code>libapue.a</code>了。使用命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o myls myls.o -Llib -lapue</span><br></pre></td></tr></table></figure><blockquote><p>如果编译失败，使用<code>make clean</code>可以清空编译结果，然后就可以使用<code>make</code>重新编译了。不要将程序命名为<code>.cpp</code>文件，这样的话即便你使用gcc编译<code>myls.cpp</code>，也会出错，更不要使用g++去编译<code>myls.cpp</code>，因为库是用gcc编译的。</p></blockquote><ul><li>When the program is done, it calls the function exit with an argument of 0. The function exit terminates a program. By convention, an argument of 0 means OK, and an argument between 1 and 255 means that an error occurred.  <strong>0代表OK，1到255代表各种类型的错误</strong>。</li></ul><h3 id="working-directory"><a class="header-anchor" href="#working-directory"> </a>Working Directory</h3><p><strong>工作目录（working directory）</strong>：Every process has a working directory, sometimes called the <strong>current working directory</strong>. This is the directory from which all relative pathnames are interpreted. A process can change its working directory with the <code>chdir</code> function.  每个进程都有一个工作目录，又叫做：当前工作目录，相对路径就是相对于当前工作目录的来解释的，可以调用<code>chdir</code>函数来改变工作目录。</p><p>For example, the relative pathname doc/memo/joe refers to the file or directory joe, in the directory memo, in the directory doc, which must be a directory within the working directory. From looking just at this pathname, we know that both doc and memo have to be directories, but we can’t tell whether joe is a file or a directory. The pathname /usr/lib/lint is an absolute pathname that refers to the file or directory lint in the directory lib, in the directory usr, which is in the root directory.  这里有趣的一点是，我们无法判断joe是文件还是目录。</p><h3 id="home-directory"><a class="header-anchor" href="#home-directory"> </a>Home Directory</h3><p>When we log in, the working directory is set to our <strong>home directory</strong>. Our home directory is obtained from our entry in the <strong>password file</strong> (Section 1.3).  当我们登陆的时候，工作目录会设定为home目录，而我们的home目录设置在口令文件中。</p><h2 id="1-5-input-and-output"><a class="header-anchor" href="#1-5-input-and-output"> </a>1.5    Input and Output</h2><h3 id="file-descriptors"><a class="header-anchor" href="#file-descriptors"> </a>File Descriptors</h3><p><strong>文件描述符（file descriptor）</strong>：File descriptors are normally small non-negative integers that the kernel uses to identify the files accessed by a process. Whenever it opens an existing file or creates a new file, the kernel returns a file descriptor that we use when we want to read or write the file.  文件描述符是一个小的非负整数，内核用它来标识正在被进程访问的文件。打开或者创建文件的时候内核会返回一个文件描述符，我们可以使用这个文件描述符来对文件进行读写。</p><h3 id="standard-input-standard-output-and-standard-error"><a class="header-anchor" href="#standard-input-standard-output-and-standard-error"> </a>Standard Input, Standard Output, and Standard Error</h3><p><strong>标准输入，标准输出，标准错误</strong>：By convention, all shells open three descriptors whenever a new program is run: standard input, standard output, and standard error. If nothing special is done, as in the simple command</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure><p>then <strong>all three are connected to the terminal</strong>. Most shells provide a way to redirect any or all of these three descriptors to any file. For example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls &gt; file.list</span><br></pre></td></tr></table></figure><p>executes the ls command with its standard output redirected to the file named</p><p>file.list.</p><p><strong>按照惯例，当新程序运行的时候，shell会打开三个文件描述符：标准输入，标准输出，标准错误。如果没有进行指明，那么三个文件描述符都会连接到终端。</strong></p><h3 id="unbuffered-i-o"><a class="header-anchor" href="#unbuffered-i-o"> </a>Unbuffered I/O</h3><p>Unbuffered I/O is provided by the functions <code>open</code>, <code>read</code>,<code>write</code>, <code>lseek</code>, and <code>close</code>. These functions all work with file descriptors. <strong>unbuffered I/O</strong>意思是系统不提供buffer管理，要你自己申请buffer，并传递给系统函数。</p><h3 id="example-v2"><a class="header-anchor" href="#example-v2"> </a>Example</h3><p>If we’re willing to read from the standard input and write to the standard output, then the program in Figure 1.4 copies any regular file on a UNIX system.</p><blockquote><p>Figure 1.4 Copy standard input to standard output</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFSIZE 4096</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFFSIZE];</span><br><span class="line">    <span class="keyword">while</span> ((n = read(STDIN_FILENO, buf, BUFFSIZE)) &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> (write(STDOUT_FILENO, buf, n) != n)</span><br><span class="line">            err_sys(<span class="string">"write error"</span>);</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        err_sys(<span class="string">"read error"</span>);</span><br><span class="line">true<span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是对程序的解释：</p><p>The <code>&lt;unistd.h&gt;</code> header, included by <code>apue.h</code>, and the two constants <code>STDIN_FILENO</code> and <code>STDOUT_FILENO</code> are part of the POSIX standard (about which we’ll have a lot more to say in the next chapter). This header contains function prototypes for many of the UNIX system services, such as the <code>read</code> and <code>write</code> functions that we call.</p><p>The constants STDIN_FILENO and STDOUT_FILENO are defined in &lt;unistd.h&gt; and specify the file descriptors for standard input and standard output. <strong>These values are 0 and 1, respectively, as required by POSIX.1</strong>, but we’ll use the names for readability. POSIX.1标准：<strong>标准输入是0，标准输出是1，标准错误是2</strong>。</p><p>The <code>read</code> function returns the number of bytes that are read, and this value is used as the number of bytes to <code>write</code>. When the end of the input file is encountered, read returns 0 and the program stops. If a read error occurs, read returns −1. Most of the system functions return −1 when an error occurs.  <code>read</code>函数返回的是读入字节的个数，把这个返回值传给<code>write</code>函数，就可以读多少写多少了，当遇到输入文件结束时，read函数返回0，当遇到错误时，read函数返回-1。<strong>许多系统函数返回-1，当它们遇到错误时</strong>。</p><p>If we compile the program into the standard name (a.out) and execute it as</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./a.out &gt; data</span><br></pre></td></tr></table></figure><p>standard input is the terminal, standard output is redirected to the file data, and standard error is also the terminal. <strong>If this output file doesn’t exist, the shell creates it by default</strong>. The program copies lines that we type to the standard output <strong>until we type the end-of-file character (usually Control-D)</strong>.</p><p>If we run</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./a.out &lt; infile &gt; outfile</span><br></pre></td></tr></table></figure><p>then the file named infile will be copied to the file named outfile.</p><p>如果文件不存在，shell默认给我们创建一个。标准输入和标准错误都是终端，我们可以一直输入，直到输入一个文件结束符，也就是<code>ctrl+d</code>。</p><h3 id="standard-i-o"><a class="header-anchor" href="#standard-i-o"> </a>Standard I/O</h3><p>The standard I/O functions provide a buffered interface to the unbuffered I/O functions. <strong>Using standard I/O relieves us from having to choose optimal buffer sizes</strong>, such as the BUFFSIZE constant in Figure 1.4. The standard I/O functions also simplify dealing with lines of input (a common occurrence in UNIX applications). <strong>The <code>fgets</code> function, for example, reads an entire line. The read function, in contrast, reads a specified number of bytes</strong>. As we shall see in Section 5.4, the standard I/O library provides functions that let us control the style of buffering used by the library. 标准I/O函数给unbuffered I/O 函数提供了缓冲接口，使用标准I/O函数可以让我们从优化buffer大小中解脱出来，举个例子，<code>fgets</code>函数直接读取一整行，而<code>read</code>函数读取固定个数的字节。</p><p>The most common standard I/O function is <code>printf</code>. In programs that call printf, we’ll always include &lt;stdio.h&gt;—normally by including apue.h—as this header contains the function prototypes for all the standard I/O functions.</p><h3 id="example-v3"><a class="header-anchor" href="#example-v3"> </a>Example</h3><p>The program in Figure 1.5, which we’ll examine in more detail in Section 5.8, is like the previous program that called read and write. This program copies standard input to standard output and can copy any regular file.</p><blockquote><p>Figure 1.5 Copy standard input to standard output, using standard I/O</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">true<span class="keyword">int</span> c;</span><br><span class="line">    <span class="keyword">while</span> ((c = getc(<span class="built_in">stdin</span>)) != EOF)</span><br><span class="line">    <span class="keyword">if</span> (putc(c, <span class="built_in">stdout</span>) == EOF)</span><br><span class="line">    err_sys(<span class="string">"output error"</span>);</span><br><span class="line">    <span class="keyword">if</span> (ferror(<span class="built_in">stdin</span>))</span><br><span class="line">    err_sys(<span class="string">"input error"</span>);</span><br><span class="line">true<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>The function getc reads one character at a time, and this character is written by putc</strong>. After the last byte of input has been read, getc returns the constant EOF (defined in &lt;stdio.h&gt;). The standard I/O constants stdin and stdout are also defined in the &lt;stdio.h&gt; header and refer to the standard input and standard output.</p><h2 id="1-6-programs-and-processes"><a class="header-anchor" href="#1-6-programs-and-processes"> </a>1.6    Programs and Processes</h2><h3 id="program"><a class="header-anchor" href="#program"> </a>Program</h3><p>A program is an executable file residing on disk in a directory. A program is read into memory and is executed by the kernel as a result of one of the <strong>seven exec functions</strong>.</p><h3 id="processes-and-process-id"><a class="header-anchor" href="#processes-and-process-id"> </a>Processes and Process ID</h3><p>An executing instance of a program is called a <strong>process</strong>, a term used on almost every page of this text. Some operating systems use the term <strong>task</strong> to refer to a program that is being executed.  程序运行的一个实例叫做：进程，也有些操作系统使用：task这个术语来描述被执行的程序。</p><p>The UNIX System guarantees that every process has a unique numeric identifier called the process ID. The process ID is always a non-negative integer. unix系统保证每个进程都有独一无二的进程ID，这个进程ID是一个非负整数。</p><h3 id="example-v4"><a class="header-anchor" href="#example-v4"> </a>Example</h3><p>The program in Figure 1.6 prints its process ID.</p><blockquote><p>Figure 1.6 Print the process ID</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world from process ID %ld\n"</span>, (<span class="keyword">long</span>)getpid());</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  apue.3e ./fig1.6</span><br><span class="line">hello world from process ID 8080</span><br><span class="line">➜  apue.3e ./fig1.6</span><br><span class="line">hello world from process ID 8086</span><br></pre></td></tr></table></figure><h3 id="process-control"><a class="header-anchor" href="#process-control"> </a>Process Control</h3><p>There are three primary functions for process control: <code>fork</code>, <code>exec</code>, and <code>waitpid</code>. (The exec function has seven variants, but we often refer to them collectively as simply the exec function.)  有三个进程控制的基本函数：<code>fork</code>，<code>exec</code>和<code>waitpid</code>，虽然exec函数有7种变体，但我们往往简单的用一个exec来表示它们。</p><h3 id="example-v5"><a class="header-anchor" href="#example-v5"> </a>Example</h3><p>The process control features of the UNIX System are demonstrated using a simple program (Figure 1.7) that reads commands from standard input and executes the commands. This is a bare-bones implementation of a shell-like program.</p><blockquote><p>Figure 1.7 Read commands from standard input and execute them</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"include/apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>    buf[MAXLINE];   <span class="comment">/* from apue.h */</span></span><br><span class="line">    <span class="keyword">pid_t</span>   pid;</span><br><span class="line">    <span class="keyword">int</span>     status;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%% "</span>);  <span class="comment">/* print prompt (printf requires %% to print %) */</span></span><br><span class="line">    <span class="keyword">while</span> (fgets(buf, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] == <span class="string">'\n'</span>)</span><br><span class="line">            buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="number">0</span>; <span class="comment">/* replace newline with null */</span></span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            err_sys(<span class="string">"fork error"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;      <span class="comment">/* child */</span></span><br><span class="line">            execlp(buf, buf, (<span class="keyword">char</span> *)<span class="number">0</span>);</span><br><span class="line">            <span class="comment">// or</span></span><br><span class="line">            <span class="comment">// execlp(buf, buf, (char *)NULL);</span></span><br><span class="line">            err_ret(<span class="string">"couldn’t execute: %s"</span>, buf);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">127</span>);</span><br><span class="line">truetrue&#125;</span><br><span class="line">        <span class="comment">/* parent */</span></span><br><span class="line">        <span class="keyword">if</span> ((pid = waitpid(pid, &amp;status, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">            err_sys(<span class="string">"waitpid error"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%% "</span>);</span><br><span class="line">true&#125;</span><br><span class="line">true<span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>There are several features to consider in this 30-line program.</p><ul><li>We use the standard I/O function fgets to read one line at a time from the standard input. When we type the end-of-file character (which is often Control-D) as the first character of a line, fgets returns a null pointer, the loop stops, and the process terminates. In Chapter 18, we describe all the special terminal characters—end of file, backspace one character, erase entire line, and so on—and how to change them.  我们使用了标准I/O函数<code>fgets</code>来一次读取标准输入的一行。当我们直接输入一个EOF时，fgets返回一个空指针，循环停止，进程终止。在第18章，我们将讲述特殊终止符，比如：end of file，backspace one character, erase entire line, 等等，以及如何改变它们。</li><li>Because each line returned by fgets is terminated with a newline character, followed by a null byte, we use the standard C function strlen to calculate the length of the string, and then replace the newline with a null byte. We do this because the execlp function wants a null-terminated argument, not a newline-terminated argument.  因为fgets返回的每一行都被一个换行符终止，换行符之后是一个空字符，我们使用标准C函数<code>strlen</code>来计算string的长度，然后将换行符替换成空字符（这样末尾就两个空字符了）。我们这样做是因为<code>execlp</code>函数希望有一个空字符来作为结尾参数，而不是一个换行符。</li><li>We call fork to create a new process, which is a copy of the caller. We say that the caller is the parent and that the newly created process is the child. Then fork returns the non-negative process ID of the new child process to the parent, and returns 0 to the child. Because fork creates a new process, we say that it is called once—by the parent—but returns twice—in the parent and in the child.  我们调用<code>fork</code>创建一个新进程，这个新进程是调用进程的一个复制。我们说，调用者是父进程，新创建出来的进程是子进程。<strong>然后fork返回子进程的非负进程ID给父进程，并返回0给子进程</strong>。因为fork创建了一个新进程，<strong>我们说它调用了一次（被父进程），但是返回了两次</strong>，在父进程和子进程里面。</li><li>In the child, we call execlp to execute the command that was read from the standard input. This replaces the child process with the new program file. The combination of fork followed by exec is called spawning a new process on some operating systems. In the UNIX System, the two parts are separated into individual functions. We’ll say a lot more about these functions in Chapter 8.  在子进程中，我们调用<code>execlp</code>来执行从标注输入中读取来的命令。这就把子进程替换成了新执行的程序。fork后面跟个exec这种结合方式被叫做 <strong>spawning a new process</strong> 在某些操作系统中。在unix系统中，这两部分被分别放到了两个单独的函数中。我们将在第8章中讨论更多的这类函数。</li><li>Because the child calls execlp to execute the new program file, the parent wants to wait for the child to terminate. This is done by calling waitpid, specifying which process to wait for: the pid argument, which is the process ID of the child. The waitpid function also returns the termination status of the child—the status variable—but in this simple program, we don’t do anything with this value. We could examine it to determine how the child terminated.  因为子进程调用了<code>execlp</code>来执行新程序文件，父进程想要等子进程结束。通过调用<code>waitpid</code>可以完成这个任务，用<code>pid</code>（子进程的进程ID）参数来明确需要等待哪个进程。<code>waitpid</code>函数同样也返回子进程的终止状态（记录在status这个参数），但在这个简单的程序里，我们没有用到这个值。我们通过这个值得知子进程是如何结束的。</li><li>The most fundamental limitation of this program is that we can’t pass arguments to the command we execute. We can’t, for example, specify the name of a directory to list. We can execute ls only on the working directory. To allow arguments would require that we parse the input line, separating the arguments by some convention, probably spaces or tabs, and then pass each argument as a separate parameter to the execlp function. Nevertheless, this program is still a useful demonstration of the UNIX System’s process control functions.  这个程序最大的限制就是，我们不能传递参数给我们要执行的命令。比如，我们不能给定一个目录给list程序（展示目录下的所有目录和文件的程序）。我们只能在当前目录下执行ls。如果要允许传递参数，就需要我们分析输入行，按照惯例，比如空格或者制表符，把参数分割开来，然后把参数传给execlp函数。不管怎么说，这个程序已经很好的展示了unix系统是如何控制函数的。</li></ul><p>If we run this program, we get the following result. Note that our program has a different prompt—the percent sign—to distinguish it from the shell’s prompt.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">➜  apue.3e ./fig1.7</span><br><span class="line">% pwd</span><br><span class="line">/Users/liuqinh2s/Downloads/apue.3e</span><br><span class="line">% who</span><br><span class="line">liuqinh2s console  May 21 12:09</span><br><span class="line">liuqinh2s ttys000  May 21 12:10</span><br><span class="line">% date</span><br><span class="line">2018年 5月24日 星期四 15时26分59秒 CST</span><br><span class="line">% %                                                                                                                                                                                                         ➜  apue.3e</span><br></pre></td></tr></table></figure><blockquote><p>The notation ˆD is used to indicate a control character. Control characters are special characters formed by holding down the control key—often labeled Control or Ctrl—on your keyboard and then pressing another key at the same time. <strong>Control-D, or ˆD, is the default end-of-file character</strong>. We’ll see many more control characters when we discuss terminal I/O in Chapter 18.  <code>^D</code>这种记法用于表示控制字符，控制字符是一类特殊的字符，由<code>ctrl</code>键加一个其他键组成，<code>Control-D</code>或者说<code>^D</code>是默认的文件终止符。我们将在第18章讨论输入输出终止符的时候看到更多的控制字符。</p></blockquote><h3 id="threads-and-thread-ids"><a class="header-anchor" href="#threads-and-thread-ids"> </a>Threads and Thread IDs</h3><p>Usually, a process has only one thread of control—one set of machine instructions executing at a time. Some problems are easier to solve when more than one thread of control can operate on different parts of the problem. Additionally, multiple threads of control can exploit the parallelism possible on multiprocessor systems.</p><p>All threads within a process share the same address space, file descriptors, stacks, and process-related attributes. Each thread executes on its own stack, although any thread can access the stacks of other threads in the same process. Because they can access the same memory, the threads need to synchronize access to shared data among themselves to avoid inconsistencies.  属于同一个进程的多个线程共享同一块内存空间，文件描述符，栈，以及和进程相关的属性。每个线程都在自己的栈里面执行，但每个线程又能访问其他线程的栈（同属于一个进程的多个线程）。因为它们能访问同一块内存，所以为了避免不一致性，需要保护好临界资源。</p><p>Like processes, threads are identified by IDs. <strong>Thread IDs, however, are local to a process</strong>. A thread ID from one process has no meaning in another process. We use thread IDs to refer to specific threads as we manipulate the threads within a process.  就像进程一样，线程也用ID标识。<strong>然而线程ID是局部的，只在某个进程内有效，出了这个进程，对其他进程来说这个线程ID就没有任何意义了。</strong></p><blockquote><p>threads were added to the UNIX System long after the process model was established</p></blockquote><h2 id="1-7-error-handling"><a class="header-anchor" href="#1-7-error-handling"> </a>1.7    Error Handling</h2><p>When an error occurs in one of the UNIX System functions, a negative value is often returned, and the integer <strong>errno</strong> is usually set to a value that tells why. For example, the open function returns either a non-negative file descriptor if all is OK or −1 if an error occurs. An error from open has about 15 possible errno values, such as file doesn’t exist, permission problem, and so on. Some functions use a convention other than returning a negative value. For example, most functions that return a pointer to an object return a null pointer to indicate an error.  当unix系统函数出错时，会返回一个负数，整形变量<strong>errno</strong>会设置为一个值，这个值告诉我们为什么出错。例如，open函数返回一个非负的文件描述符，如果成功的话，如果出现错误则返回一个-1。open函数返回的错误有15个可能的errno值，比如：文件不存在，权限问题，等等。有些函数使用另一个传统而非返回一个负数。例如，很多函数返回一个对象指针，或者一个空指针如果出现错误。</p><p>The file &lt;errno.h&gt; defines the symbol errno and constants for each value that errno can assume. Each of these constants begins with the character E. Also, the first page of Section 2 of the UNIX system manuals, named intro(2), usually lists all these error constants. For example, if errno is equal to the constant EACCES, this indicates a permission problem, such as insufficient permission to open the requested file.  <code>&lt;errno.h&gt;</code>文件定义了变量errno和一系列常量（errno可能的值）。每个常量都以字符<code>E</code>开头。unix系统手册<code>intro(2)</code>展示了这些常量。例如，如果errno等于常量EACCES，就表示是权限问题，没有足够的权限去打开这个文件。</p><blockquote><p>On Linux, the error constants are listed in the errno(3) manual page.</p></blockquote><p>POSIX and ISO C define errno as a symbol expanding into a modifiable lvalue of type integer. This can be either an integer that contains the error number or a function that returns a pointer to the error number. The historical definition is</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> errno;</span><br></pre></td></tr></table></figure><p>But in an environment that supports threads, the process address space is shared among multiple threads, and each thread needs its own local copy of errno to prevent one thread from interfering with another. Linux, for example, supports multithreaded access to errno by defining it as</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> *__errno_location(<span class="keyword">void</span>); </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> errno (*__errno_location())</span></span><br></pre></td></tr></table></figure><p>POSIX和ISO C把errno定义为一个可以修改的左值。可以定义为一个整形值，也可以定义为一个指针，指针指向错误码（String类型）。如果是多线程环境下，每个线程都有自己的一个errno拷贝。通过宏定义把errno给替换成函数：<code>int *__errno_location(void);</code>了。</p><p>There are two rules to be aware of with respect to errno. First, its value is never cleared by a routine if an error does not occur. Therefore, we should examine its value only when the return value from a function indicates that an error occurred. Second, the value of errno is never set to 0 by any of the functions, and none of the constants defined in &lt;errno.h&gt; has a value of 0.  第一，如果没有出错，errno的值不会被重置，因此，我们只有在函数返回出错的时候才检查errno；第二，errno不会等于0。</p><p>Two functions are defined by the C standard to help with printing error messages.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strerror</span><span class="params">(<span class="keyword">int</span> errnum)</span></span>;<span class="comment">//Returns: pointer to message string</span></span><br></pre></td></tr></table></figure><p>This function maps errnum, which is typically the errno value, into an error message string and returns a pointer to the string.</p><p>The perror function produces an error message on the standard error, based on the current value of errno, and returns.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">perror</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* msg)</span></span>;</span><br></pre></td></tr></table></figure><p>It outputs the string pointed to by msg, followed by a colon and a space, followed by the error message corresponding to the value of errno, followed by a newline.</p><h3 id="example-v6"><a class="header-anchor" href="#example-v6"> </a>Example</h3><p>Figure 1.8 shows the use of these two error functions.</p><blockquote><p>Figure 1.8 Demonstrate strerror and perror</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"EACCES: %s\n"</span>, strerror(EACCES));</span><br><span class="line">    errno = ENOENT;</span><br><span class="line">    perror(argv[<span class="number">0</span>]);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">➜  apue.3e ./fig1.8</span><br><span class="line">EACCES: Permission denied</span><br><span class="line">./fig1.8: No such file or directory</span><br><span class="line">➜  apue.3e</span><br></pre></td></tr></table></figure><blockquote><p>argv[0] 表示输入的第一个参数，也就是命令名</p></blockquote><h3 id="error-recovery"><a class="header-anchor" href="#error-recovery"> </a>Error Recovery</h3><p>The errors defined in &lt;errno.h&gt; can be divided into two categories: fatal and nonfatal. A fatal error has no recovery action. The best we can do is print an error message on the user’s screen or to a log file, and then exit. Nonfatal errors, on the other hand, can sometimes be dealt with more robustly. Most nonfatal errors are temporary, such as a resource shortage, and might not occur when there is less activity on the system.  定义在<code>&lt;errno.h&gt;</code>中的错误可以分为两类：fatal和nonfatal，致命和非致命。致命错误没有恢复动作，我们最多能做的就是把错误信息在用户显示屏上打印出来，或者写到log文件里，然后退出。非致命错误，可以更妥善的处理，许多非致命错误都是暂时的，比如：资源短缺，当系统活动较少时这类错误可能不会发生。</p><p>Resource-related nonfatal errors include <strong>EAGAIN, ENFILE, ENOBUFS, ENOLCK, ENOSPC, EWOULDBLOCK</strong>, and sometimes <strong>ENOMEM</strong>. <strong>EBUSY</strong> can be treated as nonfatal when it indicates that a shared resource is in use. Sometimes, <strong>EINTR</strong> can be treated as a nonfatal error when it interrupts a slow system call (more on this in Section 10.5).</p><p>The typical recovery action for a resource-related nonfatal error is to delay and retry later. This technique can be applied in other circumstances. For example, if an error indicates that a network connection is no longer functioning, it might be possible for the application to delay a short time and then reestablish the connection. Some applications use an exponential backoff algorithm, waiting a longer period of time in each subsequent iteration.  <strong>典型的资源相关性非致命错误的处理办法是先等一下，之后再重试。</strong></p><p>**Ultimately, it is up to the application developer to determine the cases where an application can recover from an error. If a reasonable recovery strategy can be used, we can improve the robustness of our application by avoiding an abnormal exit. **</p><h2 id="1-8-user-identification"><a class="header-anchor" href="#1-8-user-identification"> </a>1.8    User Identification</h2><h3 id="user-id"><a class="header-anchor" href="#user-id"> </a>User ID</h3><p>The user ID from our entry in the password file is a numeric value that identifies us to the system. This user ID is assigned by the system administrator when our login name is assigned, and we cannot change it. The user ID is normally assigned to be unique for every user. We’ll see how the kernel uses the user ID to check whether we have the appropriate permissions to perform certain operations.  用户ID来自口令文件中对应的条目，它是以数字的形式帮助系统对我们进行标识。用户ID是系统管理员给我们分配的（当分配登录名时，同时也必须分配用户ID），我们自己无法改。每个人的用户ID应该是唯一的，内核使用用户ID来检查我们是否有合适的权限来进行一个操作。</p><p>We call the user whose user ID is 0 either root or the superuser. The entry in the password file normally has a login name of root, and we refer to the special privileges of this user as superuser privileges. As we’ll see in Chapter 4, if a process has superuser privileges, most file permission checks are bypassed. Some operating system functions are restricted to the superuser. The superuser has free rein over the system.  我们把用户ID为0的用户称为：<strong>root</strong>或者<strong>superuser</strong>。口令文件中有一个条目的登录名是root，root用户拥有特殊权限。拥有superuser特权的进程可以自由的使用任意文件，而且有些操作系统函数是只对superuser开放的。superuser拥有对系统的绝对的权限（可以把系统弄残）。</p><blockquote><p>Client versions of Mac OS X ship with the superuser account disabled; server versions ship with the account already enabled. Instructions are available on Apple’s Web site describing how to enable it. See <a href="http://support.apple.com/kb/HT1528" target="_blank" rel="noopener">http://support.apple.com/kb/HT1528</a>.</p></blockquote><h3 id="group-id"><a class="header-anchor" href="#group-id"> </a>Group ID</h3><p>Our entry in the password file also specifies our numeric group ID. This, too, is assigned by the system administrator when our login name is assigned. Typically, the password file contains multiple entries that specify the same group ID. Groups are normally used to collect users together into projects or departments. This allows the sharing of resources, such as files, among members of the same group. We’ll see in Section 4.5 that we can set the permissions on a file so that all members of a group can access the file, whereas others outside the group cannot.  Group ID的作用就是让相同组的人共享资源。</p><p>There is also a group file that maps group names into numeric group IDs. The group file is usually <code>/etc/group</code>.</p><p>The use of numeric user IDs and numeric group IDs for permissions is historical. With every file on disk, the file system stores both the user ID and the group ID of a file’s owner. Storing both of these values requires only four bytes, assuming that each is stored as a two-byte integer. If the full ASCII login name and group name were used instead, additional disk space would be required. In addition, comparing strings during permission checks is more expensive than comparing integers.  使用数字的用户ID和组ID是有历史原因的。对于每个存放在磁盘上的文件，文件系统都存储了该文件的拥有者的用户ID和组ID。存储这两个数字需要4字节（每个2字节），如果使用ASCII编码的登录名和组名，需要多用掉很多额外的磁盘空间。另外在检查权限是否合格时，整形数字比较要比字符串比较更快。</p><p>Users, however, work better with names than with numbers, so the password file maintains the mapping between login names and user IDs, and the group file provides the mapping between group names and group IDs. The ls -l command, for example, prints the login name of the owner of a file, using the password file to map the numeric user ID into the corresponding login name.  然而对于用户来说名字比数字更好记，所以password file和group file分别记录了登录名和用户ID的映射，组名和组ID的映射。使用<code>ls -l</code>命令，可以看到打印出了文件所属者和所属的组，其原理就是查找了password file和group file，把相应的数字ID换成名字。</p><blockquote><p>Early UNIX systems used 16-bit integers to represent user and group IDs. Contemporary UNIX systems use 32-bit integers.</p></blockquote><h3 id="example-v7"><a class="header-anchor" href="#example-v7"> </a>Example</h3><p>The program in Figure 1.9 prints the user ID and the group ID.</p><blockquote><p>Figure 1.9 Print user ID and group ID</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"apue.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">true<span class="built_in">printf</span>(<span class="string">"uid = %d, gid = %d\n"</span>, getuid(), getgid());</span><br><span class="line">true<span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="supplementary-group-ids"><a class="header-anchor" href="#supplementary-group-ids"> </a>Supplementary Group IDs</h3><p><strong>附加组（supplementary group）</strong>：In addition to the group ID specified in the password file for a login name, most versions of the UNIX System allow a user to belong to other groups. This practice started with 4.2BSD, which allowed a user to belong to up to 16 additional groups. These supplementary group IDs are obtained at login time by reading the file /etc/group and finding the first 16 entries that list the user as a member. As we shall see in the next chapter, POSIX requires that a system support at least 8 supplementary groups per process, but most systems support at least 16.  许多unix系统允许用户属于多个组，最多16个。主组，也就是登陆时的默认组记录在<code>/etc/passwd</code>中。</p><p><code>/etc/group</code>格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_analyticsusers:*:250:_analyticsd,_networkd,_timed</span><br><span class="line">_analyticsd:*:263:_analyticsd</span><br></pre></td></tr></table></figure><p>解释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">组名:口令:组ID:组内用户列表</span><br></pre></td></tr></table></figure><h2 id="1-9-signal"><a class="header-anchor" href="#1-9-signal"> </a>1.9    Signal</h2><p><strong>Signals are a technique used to notify a process that some condition has occurred</strong>. For example, if a process divides by zero, the signal whose name is SIGFPE (floating-point exception) is sent to the process. The process has three choices for dealing with the signal.  信号是一种用来通知进程发生了某些事的技术。举个例子：当进程除以0时，就会有一个SIGFPE (floating-point exception)发送到这个进程。进程处理信号有三种选择：</p><ol><li>Ignore the signal. This option isn’t recommended for signals that denote a hardware exception, such as dividing by zero or referencing memory outside the address space of the process, as the results are undefined.  忽视信号。如果是硬件异常不推荐这个选择，例如：被0除，引用进程外的内存，因为这些结果都是不确定的。</li><li>Let the default action occur. For a divide-by-zero condition, the default is to terminate the process.  让默认动作出现，比如被0除的情况下，默认是终止该进程。</li><li>Provide a function that is called when the signal occurs (this is called ‘‘catching’’ the signal). By providing a function of our own, we’ll know when the signal occurs and we can handle it as we wish.  我们自己提供一个函数捕获信号，这样我们就能让程序以我们的意愿处理异常。</li></ol><p>Many conditions generate signals. Two terminal keys, called the <strong>interrupt key</strong>— often the <strong>DELETE</strong> key or <strong>Control-C</strong>—and the <strong>quit key</strong>—often <strong>Control-backslash</strong>—are used to interrupt the currently running process. Another way to generate a signal is by calling the <code>kill</code> function. <strong>We can call this function from a process to send a signal to another process. Naturally, there are limitations: we have to be the owner of the other process (or the superuser) to be able to send it a signal</strong>.    很多条件下可以生成信号，终端键有两种，interrupt key（delete键或者ctrl+c）和 quit key（ctrl+\）。另一个生成信号的方法是调用<code>kill</code>函数，我们可以在一个进程里调用kill函数来结束另一个进程，但我们需要有权限（如果我们是另一个进程的拥有者，或者是超级用户，就可以）。</p><h3 id="example-v8"><a class="header-anchor" href="#example-v8"> </a>Example</h3><p>Recall the bare-bones shell example (Figure 1.7). If we invoke this program and press the interrupt key, the process terminates because the default action for this signal, named SIGINT, is to terminate the process. The process hasn’t told the kernel to do anything other than the default with this signal, so the process terminates.  如果直接执行Figure 1.7的代码，我们按下中断键，程序就会终止，因为这个SIGINT信号的默认动作就是终止进程。</p><p>To catch this signal, the program needs to call the signal function, specifying the name of the function to call when the SIGINT signal is generated. The function is named sig_int; when it’s called, it just prints a message and a new prompt. Adding 11 lines to the program in Figure 1.7 gives us the version in Figure 1.10. (The 11 new lines are indicated with a plus sign at the beginning of the line.)  为了捕获这个信号，程序需要调用一个信号函数。我们给它命名为：<code>sig_int</code>函数，在捕获到<strong>SIGINT</strong>信号之后，打印信息并打印一个新的提示符。下面的程序相比Figure 1.7多了11行，用<code>+</code>号标识了。</p><blockquote><p>Figure 1.10 Read commands from standard input and execute them</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"include/apue.h"</span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line">  </span><br><span class="line">+ <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_int</span><span class="params">(<span class="keyword">int</span>)</span></span>;<span class="comment">/* our signal-catching function */</span></span><br><span class="line">+</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">      <span class="keyword">char</span>    buf[MAXLINE];   <span class="comment">/* from apue.h */</span></span><br><span class="line">      <span class="keyword">pid_t</span>   pid;</span><br><span class="line">      <span class="keyword">int</span>     status;</span><br><span class="line">  </span><br><span class="line">  +  <span class="keyword">if</span>(signal(SIGINT, sig_int) == SIG_ERR)</span><br><span class="line">          err_sys(<span class="string">"signal error"</span>);</span><br><span class="line">    </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%% "</span>);  <span class="comment">/* print prompt (printf requires %% to print %) */</span></span><br><span class="line">      <span class="keyword">while</span> (fgets(buf, MAXLINE, <span class="built_in">stdin</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] == <span class="string">'\n'</span>)</span><br><span class="line">              buf[<span class="built_in">strlen</span>(buf) - <span class="number">1</span>] = <span class="number">0</span>; <span class="comment">/* replace newline with null */</span></span><br><span class="line">          <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">              err_sys(<span class="string">"fork error"</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;      <span class="comment">/* child */</span></span><br><span class="line">              execlp(buf, buf, (<span class="keyword">char</span> *)<span class="number">0</span>);</span><br><span class="line">              err_ret(<span class="string">"couldn’t execute: %s"</span>, buf);</span><br><span class="line">              <span class="built_in">exit</span>(<span class="number">127</span>);</span><br><span class="line">truetrue  &#125;</span><br><span class="line">          <span class="comment">/* parent */</span></span><br><span class="line">          <span class="keyword">if</span> ((pid = waitpid(pid, &amp;status, <span class="number">0</span>)) &lt; <span class="number">0</span>)</span><br><span class="line">              err_sys(<span class="string">"waitpid error"</span>);</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"%% "</span>);</span><br><span class="line">true  &#125;</span><br><span class="line">true  <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">  &#125;</span><br><span class="line">+</span><br><span class="line">+ <span class="function"><span class="keyword">void</span> <span class="title">sig_int</span><span class="params">(<span class="keyword">int</span> signo)</span></span>&#123;</span><br><span class="line">+     <span class="built_in">printf</span>(<span class="string">"interrupt\n%% "</span>);</span><br><span class="line">+ &#125;</span><br></pre></td></tr></table></figure><h2 id="1-10-time-values"><a class="header-anchor" href="#1-10-time-values"> </a>1.10    Time Values</h2><p>Historically, UNIX systems have maintained two different time values:</p><ol><li><p><strong>Calendar time</strong>. This value counts the number of seconds since the <strong>Epoch: 00:00:00 January 1, 1970,Coordinated Universal Time (UTC)</strong>. (Older manuals refer to UTC as Greenwich Mean Time.) These time values are used to record the time when a file was last modified, for example.</p><p>The primitive system data type <code>time_t</code> holds these time values.</p></li><li><p><strong>Process time</strong>. This is also called CPU time and measures the central processor resources used by a process. Process time is measured in clock ticks, which have historically been 50, 60, or 100 ticks per second.</p><p>The primitive system data type <code>clock_t</code> holds these time values. (We’ll show how to obtain the number of clock ticks per second with the <code>sysconf</code> function in Section 2.5.4.)</p></li></ol><p>有两种类型的时间：<strong>日历时间</strong>和<strong>进程时间</strong>，日历时间也就是UTC。</p><p>When we measure the execution time of a process, as in Section 3.9, we’ll see that the UNIX System maintains three values for a process:</p><ul><li>Clock time</li><li>User CPU time</li><li>System CPU time</li></ul><p>The clock time, sometimes called <strong>wall clock time</strong>, is the amount of time the process takes to run, and its value depends on the number of other processes being run on the system. Whenever we report the clock time, the measurements are made with no other activities on the system.</p><p>The user CPU time is the CPU time attributed to user instructions. The system CPU time is the CPU time attributed to the kernel when it executes on behalf of the process. For example, whenever a process executes a system service, such as read or write, the time spent within the kernel performing that system service is charged to the process. The sum of user CPU time and system CPU time is often called the CPU time.</p><p>度量进程执行时间，有三种：</p><ol><li>墙上时钟，也就是进程执行花费的总时间。</li><li>用户CPU时间，是用户模式（非内核）下的CPU使用时间</li><li>系统CPU时间，是进程进入内核执行的CPU使用时间</li></ol><p>It is easy to measure the clock time, user time, and system time of any process: simply execute the time(1) command, with the argument to the time command being the command we want to measure. For example:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cd /usr/include</span><br><span class="line"><span class="meta">$</span> time -p grep _POSIX_SOURCE */*.h &gt; /dev/null</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">real    0m0.81s</span><br><span class="line">user    0m0.11s</span><br><span class="line">sys     0m0.07s</span><br></pre></td></tr></table></figure><p>The output format from the time command depends on the shell being used, because some shells don’t run /usr/bin/time, but instead have a separate built-in function to measure the time it takes commands to run.  time命令的输出格式取决于使用什么shell，因为有些shell并不运行：<code>/usr/bin/time</code>，而是运行自己内置的一个time函数。</p><h2 id="1-11-system-calls-and-library-functions"><a class="header-anchor" href="#1-11-system-calls-and-library-functions"> </a>1.11    System Calls and Library Functions</h2><p>All operating systems provide service points through which programs request services from the kernel. All implementations of the UNIX System provide a well-defined, limited number of entry points directly into the kernel called system calls (recall Figure 1.1). Version 7 of the Research UNIX System provided about 50 system calls, 4.4BSD provided about 110, and SVR4 had around 120. The exact number of system calls varies depending on the operating system version. More recent systems have seen incredible growth in the number of supported system calls. Linux 3.2.0 has 380 system calls and FreeBSD 8.0 has over 450.  随着时间的推移，系统调用越来越多，可见系统是越来越完善的。</p><p>The system call interface has always been documented in Section 2 of the UNIX Programmer’s Manual. Its definition is in the C language, no matter which implementation technique is actually used on any given system to invoke a system call. This differs from many older operating systems, which traditionally defined the kernel entry points in the assembly language of the machine.  <strong>系统调用的文档总是在unix编程手册的第二个章节里。它是用C语言定义的</strong>，不管系统具体是如何实现系统调用的。这一点与很多老操作系统不同（老操作系统使用汇编语言定义内核接口）</p><p>The technique used on UNIX systems is for each system call to have a function of the same name in the standard C library. The user process calls this function, using the standard C calling sequence. This function then invokes the appropriate kernel service, using whatever technique is required on the system. For example, the function may put one or more of the C arguments into general registers and then execute some machine instruction that generates a software interrupt in the kernel. For our purposes, we can consider the system calls to be C functions.  每个系统调用都对应一个相同名字的函数在标准C库里。用户进程调用这个函数，然后这个函数调用相应的内核服务。举个例子，这个函数可能会把一个或多个C参数放到通用寄存器，并执行机器指令在内核中产生一个软件中断。从我们的角度看，我们可以直接认为系统调用就是C函数。</p><p>Section 3 of the UNIX Programmer’s Manual defines the general-purpose library functions available to programmers. These functions aren’t entry points into the kernel, although they may invoke one or more of the kernel’s system calls. For example, the printf function may use the write system call to output a string, but the strcpy (copy a string) and atoi (convert ASCII to integer) functions don’t involve the kernel at all.  在<strong>unix编程手册第三章定义了通用库函数给程序员。这些函数不是内核入口，虽然它们可能会调用一个或几个内核的系统调用</strong>。举个例子，<code>printf</code>函数可能会使用<code>write</code>系统调用来输出一个字符串，但是<code>strcpy</code>（拷贝一个字符串）和<code>atoi</code>（吧ASCII字符转成整形）函数根本没有调用内核。</p><p>From an implementor’s point of view, the distinction between a system call and a library function is fundamental. From a user’s perspective, however, the difference is not as critical. From our perspective in this text, both system calls and library functions appear as normal C functions. Both exist to provide services for application programs. We should realize, however, that we can replace the library functions, if desired, whereas the system calls usually cannot be replaced.  从实现者的角度来看，系统调用和库函数的区别是很大的。然而从使用者的角度来看，这个区别并不重要。在这本书中，在我们看来，系统调用和库函数都以C函数的形式出现。两者的存在都是为了给应用开发者提供服务。然而我们应该意识到，<strong>虽然我们能替换库函数（如果我们想这样做），但系统调用不能被替换</strong>。</p><p>Consider the memory allocation function malloc as an example. There are many ways to do memory allocation and its associated garbage collection (best fit, first fit, and so on). No single technique is optimal for all programs. The UNIX system call that handles memory allocation, sbrk(2), is not a general-purpose memory manager. It increases or decreases the address space of the process by a specified number of bytes. How that space is managed is up to the process. The memory allocation function, malloc(3), implements one particular type of allocation. If we don’t like its operation, we can define our own malloc function, which will probably use the sbrk system call. In fact, numerous software packages implement their own memory allocation algorithms with the sbrk system call. Figure 1.11 shows the relationship between the application, the malloc function, and the sbrk system call.  让我们来看看内存分配函数<code>malloc</code>这个例子。有很多内存分配和相关的垃圾回收方法（最好适应算法，最先适应算法，等等）。没有哪个技术是对所有程序优化的。<strong>unix系统调用<code>sbrk(2)</code>不是一个通用的存储管理器。它给进程增加和减少内存空间都是固定的字节数。怎么管理空间其实还要取决于进程自己。内存分配函数<code>malloc(3)</code>，实现了特定类型的分配。如果我们不喜欢它的做法，我们可以定义自己的malloc函数，但也是要用到sbrk系统调用的。实际上大量的软件包都通过直接使用sbrk系统调用实现了自己的内存管理算法</strong>。图1.11展示了应用，malloc函数，和sbrk系统调用之间的关系。</p><img src="../../../../images/APUE-3rd-Figure 1.11.png" width="70%"><p>Here we have a clean separation of duties: the system call in the kernel allocates an additional chunk of space on behalf of the process. The malloc library function manages this space from user level.  这里职责是分明的：系统调用代表进程在内核里分配了额外的一块空间。malloc库函数在用户层级上管理这块空间。</p><p>Another example to illustrate the difference between a system call and a library function is the interface the UNIX System provides to determine the current time and date. Some operating systems provide one system call to return the time and another to return the date. Any special handling, such as the switch to or from daylight saving time, is handled by the kernel or requires human intervention. The UNIX System, in contrast, provides a single system call that returns the number of seconds since the Epoch: midnight, January 1, 1970, Coordinated Universal Time. Any interpretation of this value, such as converting it to a human-readable time and date using the local time zone, is left to the user process. The standard C library provides routines to handle most cases. These library routines handle such details as the various algorithms for daylight saving time.  另一个描述系统调用和库函数不同的例子是当前时间和日期。某些操作系统提供一个系统调用返回时间，另一个系统调用返回日期。任何特殊的处理，比如正常时制与夏令时的切换，需要内核的处理或者人为干预。Unix系统则相反，只提供一个系统调用，返回UTC（UTC是指从1970年的第一秒开始算起到现在经过的总时间）。任何对UTC这个值的解释，例如把它转成人类可读的时间日期使用当地时间，就留给了用户进程。标准C库提供了诸多例程来处理大多数情况。这些库例程处理这些细节，就像大多数算法处理夏令时切换一样。</p><p>An application can either make a system call or call a library routine. Also realize that many library routines invoke a system call. This is shown in Figure 1.12.  一个应用可以使用系统调用或者调用库例程，同样要意识到许多库例程调用了系统调用。</p><p>Another difference between system calls and library functions is that system calls usually <strong>provide a minimal interface</strong>, whereas library functions often <strong>provide more elaborate functionality</strong>. We’ve seen this already in the difference between the sbrk system call and the malloc library function. We’ll see this difference again later, when we compare the unbuffered I/O functions (Chapter 3) and the standard I/O functions (Chapter 5).  另一个系统调用和库函数的区别就是，系统调用往往只提供一个很小的接口，然而库函数经常提供更多精细的功能。</p><img src="../../../../images/APUE-3rd-Figure 1.12.png" width="70%"><p>The process control system calls (<strong>fork, exec, and waitpid</strong>) are usually invoked by the user’s application code directly. (Recall the bare-bones shell in Figure 1.7.) But some library routines exist to simplify certain common cases: the <strong>system</strong> and <strong>popen</strong> library routines, for example. In Section 8.13, we’ll show an implementation of the system function that invokes the basic process control system calls. We’ll enhance this example in Section 10.18 to handle signals correctly.</p><p>To define the interface to the UNIX System that most programmers use, we have to describe both the system calls and some of the library functions. If we described only the sbrk system call, for example, we would skip the more programmer-friendly malloc library function that many applications use. <strong>In this text, we’ll use the term function to refer to both system calls and library functions, except when the distinction is necessary.</strong></p>]]></content>
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 《APUE-3rd》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unix </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Linux Shell 配色</title>
      <link href="/blog/2018/05/08/Linux-Shell-%E9%85%8D%E8%89%B2/"/>
      <url>/blog/2018/05/08/Linux-Shell-%E9%85%8D%E8%89%B2/</url>
      <content type="html"><![CDATA[<p>早就想自己给bash配个色，但是一直没空学习这方面的知识，今天抽个空，搞了一点点。</p><h2 id="切换shell"><a class="header-anchor" href="#切换shell"> </a>切换shell</h2><p>切换shell，分临时和永久。</p><p>临时：输入命令：<code>bash</code>或者<code>zsh</code>都行，shell调用shell，一层套一层，按<code>ctrl+d</code>或者输入<code>exit</code>可以退出。<br>永久：输入命令：<code>chsh -s /bin/bash</code></p><blockquote><p>chsh意思就是change shell，使用<code>man chsh</code>进行查看</p></blockquote><h2 id="修改prompt"><a class="header-anchor" href="#修改prompt"> </a>修改prompt</h2><p>prompt也就是提示符，首先就是要修改这个，什么样的提示符才是一个好的提示符呢？我觉得首要的是要短，太长的提示符占了命令的空间。其次提示符还必须显示用户名和机器名，因为只有这样才能在你远程登录的时候与远程shell区分开。机器名最好是缩写。然后我就得出了我自己的提示符的前缀：<code>liuqinh2s@mbp</code>，然后我觉得得加个短路径，不要求绝对路径，这样太占空间，只需要加个当前文件夹即可。这样进一步修改之后，我的提示符变成了：<code>liuqinh2s@mbp:~</code>，最后需要添加一个普通用户和超级用户的区分，普通用户用：<code>$</code>，超级用户用<code>#</code>，所以我的提示符最终的样子是：<code>liuqinh2s@mbp:~$</code>，注意<code>$</code>后面我加了一个空格，这样看起来比较舒服，提示符和命令的界限一目了然。</p><p>但其实还是不清晰，我就给prompt上了个颜色。</p><p>最后就变成这样啦：</p><img src="https://i.loli.net/2018/05/08/5af13dcea3fa6.png" alt="屏幕快照 2018-05-08 下午2.03.34.png" title="屏幕快照 2018-05-08 下午2.03.34.png" width="30%" height="30%"><p>配置代码：<code>PS1=&quot;\[\e[0;32m\]\u@\h:\[\e[0;34m\]\W\$\[\e[0m\] &quot;</code></p><blockquote><p>使用<code>export PS1=&quot;\[\e[0;32m\]\u@\h:\[\e[0;34m\]\W\$\[\e[0m\] &quot;</code>，这样的话，你输入<code>bash</code>的时候，也能用到你的配置</p></blockquote><blockquote><p>export in sh and related shells (such as bash), marks an environment variable to be exported to child-processes, so that the child inherits them.</p></blockquote><p>export的作用就是让子进程也继承环境变量</p><p>如果你用的是mac的话，在home目录的<code>.bash_profile</code>中修改就可以了</p><p>下面是配置代码的讲解：</p><h3 id="bash转义序列"><a class="header-anchor" href="#bash转义序列"> </a>Bash转义序列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">\a     an ASCII bell character (07)</span><br><span class="line">\d     the date in &quot;Weekday Month Date&quot; format (e.g., &quot;Tue May 26&quot;)</span><br><span class="line">\D&#123;format&#125;</span><br><span class="line">       the format is passed to strftime(3) and the result is inserted into the prompt string; an empty format results in a locale-</span><br><span class="line">       specific time representation.  The braces are required</span><br><span class="line">\e     an ASCII escape character (033)</span><br><span class="line">\h     the hostname up to the first `.&apos;</span><br><span class="line">\H     the hostname</span><br><span class="line">\j     the number of jobs currently managed by the shell</span><br><span class="line">\l     the basename of the shell&apos;s terminal device name</span><br><span class="line">\n     newline</span><br><span class="line">\r     carriage return</span><br><span class="line">\s     the name of the shell, the basename of $0 (the portion following the final slash)</span><br><span class="line">\t     the current time in 24-hour HH:MM:SS format</span><br><span class="line">\T     the current time in 12-hour HH:MM:SS format</span><br><span class="line">\@     the current time in 12-hour am/pm format</span><br><span class="line">\A     the current time in 24-hour HH:MM format</span><br><span class="line">\u     the username of the current user</span><br><span class="line">\v     the version of bash (e.g., 2.00)</span><br><span class="line">\V     the release of bash, version + patch level (e.g., 2.00.0)</span><br><span class="line">\w     the current working directory, with $HOME abbreviated with a tilde (uses the value of the PROMPT_DIRTRIM variable)</span><br><span class="line">\W     the basename of the current working directory, with $HOME abbreviated with a tilde</span><br><span class="line">\!     the history number of this command</span><br><span class="line">\#     the command number of this command</span><br><span class="line">\$     if the effective UID is 0, a #, otherwise a $</span><br><span class="line">\nnn   the character corresponding to the octal number nnn</span><br><span class="line">\\     a backslash</span><br><span class="line">\[     begin a sequence of non-printing characters, which could be used to embed a terminal control sequence into the prompt</span><br><span class="line">\]     end a sequence of non-printing characters</span><br></pre></td></tr></table></figure><h3 id="变更prompt颜色"><a class="header-anchor" href="#变更prompt颜色"> </a>变更prompt颜色</h3><p>首先，大家必须以[与]作为色彩代码的描述范围。对于Bash，这代表两个括号间的字符为非输出字符。</p><p>Bash需要在此基础上估算字符数量，以备后续输出。如果不将色彩代码纳入[与]之间，那么Bash会将全部字符都计为文本字符并在下一行中进行打包。</p><p>另外，在括号内的非输出序列中，我们需要输入\e[或者\033[指定彩色prompt的起点。二者的作用相同，都负责指定该反义序列的起始位置。</p><p>在]之前，我们还需要使用“m”来表示即将提供一条色彩序列。</p><p>基本上，每次进行色彩修改时，我们都需要输入下面这种命令格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\[\e[color_informationm\]</span><br></pre></td></tr></table></figure><p>下面来看用于变更前景文本颜色的基本代码：</p><ul><li>30: Black</li><li>31: Red</li><li>32: Green</li><li>33: Yellow</li><li>34: Blue</li><li>35: Purple</li><li>36: Cyan</li><li>37: White</li></ul><p>大家也可以通过在以上设定前设置“属性”修改这些基础值，各值之间以分号分隔。</p><p>根据实际终端的不同，操作效果也有所区别。部分常见属性包括：</p><ul><li>0: 普通文本</li><li>1: 在不同终端中可能代表粗体或者浅色显示</li><li>4: 下划线文本</li></ul><p>因此如果大家希望使用下划线绿色文本，则：<code>\[\e[4;32m\]</code></p><p>接下来继续正常使用即可。另外，我们也可以随时将色彩重置为初始值。</p><p>重置命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\[\e[0m\]</span><br></pre></td></tr></table></figure><p>我们也可以指定背景颜色。背景颜色无法获取属性，具体包括：</p><ul><li>40: Black background</li><li>41: Red background</li><li>42: Green background</li><li>43: Yellow background</li><li>44: Blue background</li><li>45: Purple background</li><li>46: Cyan background</li><li>47: White background</li></ul><p>不过大家可以一次性指定背景颜色、属性与文本颜色：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\[\e[42;1;36m\]</span><br></pre></td></tr></table></figure><p>当然，这里建议各位将背景信息与其它信息分隔开来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\[\e[42m\]\[\e[1;36m\]</span><br></pre></td></tr></table></figure><p>在使用普通文本属性（0）时，终端中可能出现一些乱码。如果遇到这种问题，大家最好避免使用0值指定普通属性——由于属于默认值，我们无需额外指定。</p><h2 id="配置ls和grep的颜色"><a class="header-anchor" href="#配置ls和grep的颜色"> </a>配置ls和grep的颜色</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Tell ls to be colourful</span><br><span class="line"> export CLICOLOR=1</span><br><span class="line"> export LSCOLORS=Exfxcxdxbxegedabagacad</span><br><span class="line"></span><br><span class="line"> # Tell grep to highlight matches</span><br><span class="line"> export GREP_OPTIONS=&apos;--color=auto’</span><br></pre></td></tr></table></figure><ul><li><p>CLICOLOR是用来设置是否进行颜色的显示。CLI是Command Line Interface的缩写。</p></li><li><p>LSCOLORS是用来设置当CLICOLOR被启用后，各种文件类型的颜色。LSCOLORS的值中每两个字母为一组，分别设置某个文件类型的文字颜色和背景颜色。LSCOLORS中一共11组颜色设置，按照先后顺序，分别对以下的文件类型进行设置：</p></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/1233651-e586f58eae66c4ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700" alt="文件类型 - 文件颜色"></p><p>所以，如果我们想把目录显示成红色，就可以把LSCOLORS设置为fxfxaxdxcxegedabagacad就可以了</p>]]></content>
      
      <categories>
          
          <category> Unix </category>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>对区块链以及未来的一些思考</title>
      <link href="/blog/2018/05/07/%E5%AF%B9%E5%8C%BA%E5%9D%97%E9%93%BE%E4%BB%A5%E5%8F%8A%E6%9C%AA%E6%9D%A5%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
      <url>/blog/2018/05/07/%E5%AF%B9%E5%8C%BA%E5%9D%97%E9%93%BE%E4%BB%A5%E5%8F%8A%E6%9C%AA%E6%9D%A5%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</url>
      <content type="html"><![CDATA[<p>有个用户痛点，我来描述一下：当你更改了手机号，it’s a disaster! 你需要改无数绑定的东西，比如：银行预留手机号，各类APP的绑定手机号，还要通知所有人你改了手机号，当然我现在换手机号也懒得通知别人了，除了还给我打电话的那几个人，现在大家都是用QQ和微信沟通了。</p><p>我说个笑话，不，其实这是个真实的故事，我曾今在深圳用过摩拜共享单车，当时绑定了我的手机号，后来我在杭州，并且手机号也换了，另外摩拜也加了个身份证验证。我就再也使用不了摩拜了，好像是因为手机号和身份证绑定了，我无法通过其他手机号使用摩拜了。摩拜让我交了200块钱押金，让我充了10块钱车费，最后却告诉我，我不能骑车。我只好申诉，申诉没起效果，最后我直接申请退款了，退款理由我写上了：无法实名认证。我希望以此能够催促摩拜尽早改好这个BUG，从而帮助到其他人吧。</p><p>还有就是各种证，从身份证开始，学位证，毕业证，结婚证，团员证，党员证，房产证。。。</p><p>还有一些事是大家都知道的，三鹿奶粉，三聚氰胺，地沟油，等等。</p><p>那么这些事之间有什么联系呢？</p><p>有，当然有，那就是：信任。</p><p>如何让别人信任你，如何让我们信任那些企业，如何做到一个账号上网，或者说不用麻烦的认证，你上网，网就认识你，从这个网站到那个网站，不需要繁琐的注册登陆。</p><p>区块链貌似能解决这个问题，如果我们的信息都放在一起，需要的时候就去查看，而且有严格的权限限制，那么我们就建立了一个统一的信息源。</p>]]></content>
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>用ipfs发布博客</title>
      <link href="/blog/2018/05/04/%E7%94%A8ipfs%E5%8F%91%E5%B8%83%E5%8D%9A%E5%AE%A2/"/>
      <url>/blog/2018/05/04/%E7%94%A8ipfs%E5%8F%91%E5%B8%83%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p>ipfs是一个p2p的网络</p><h2 id="常用ipfs命令"><a class="header-anchor" href="#常用ipfs命令"> </a>常用ipfs命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ipfs add -r mysite</span><br><span class="line">// 通过上一步可以得到很多个哈希值（每个目录和文件都有一个），把根目录对应的哈希值拿出来用</span><br><span class="line">ipfs name publish QmZyenFLZtm9rk2B98ZqRAFYRkzhqyUruKBSsdZUnKk9ek</span><br></pre></td></tr></table></figure><p>第二步实际上是把这个站点的根目录映射到了你的 <code>ipfs id</code> 上面，你的这个id是固定的。之后你每次更新这个站点下的内容都要 <code>ipfs add -r mysite</code> 一次，然后把根目录对应的哈希值重新映射到你的 ipfs id 上。</p><p>然后你访问ipfs站点的时候，可以这样访问：<code>https://ipfs.io/ipns/your_ipfs_id</code>，如果你的浏览器装了ipfs插件就可以自动解析这个网址，从而直接用ipfs协议来访问站点了。</p><blockquote><p>注意your_ipfs_id是指你的ipfs id，你可以用命令<code>ipfs id</code>查看你的id是什么，相信我的读者不会蠢到直接复制粘贴your_ipfs_id。</p></blockquote><h2 id="hexo生成的博客-缺失css和js的问题"><a class="header-anchor" href="#hexo生成的博客-缺失css和js的问题"> </a>hexo生成的博客，缺失css和js的问题</h2><p>在hexo的config里面，有个root，这个root就是用来给css和js等资源指定目录的，所以你要改成：<code>/ipns/your_ipfs_id/</code></p><p>如果你想同时在git pages上面，和ipfs上面发布你的博客，那么root这个属性必定就冲突了，因为在git pages上面发布的时候，直接填<code>/</code>就行了（他是直接发布在像：<code>liuqinh2s.github.io</code>，这个域名后面，也就是子域名的根目录，不像ipfs那样会加个<code>/ipns/your_ipfs_id</code>这种目录）。那么你就只能搞两个博客工程了，新发布博客的时候，就要同时修改两个地方。</p><p>比如我是这样做的，我建了一个ipfs文件夹，里面存放我所有发布在ipfs上的资源，所以我会把我的博客复制一份到这个文件夹里面，更新博客的时候，复制一份博客文件到这边，git pages那边要发布一次，然后ipfs这边也要发布一次。</p><p>访问我的ipfs站点：<a href="https://ipfs.io/ipns/QmT7mga4wwTLNFCrtt1FbvLgmxTWZyKGRsrnFZNMoHdEJa/" target="_blank" rel="noopener">https://ipfs.io/ipns/QmT7mga4wwTLNFCrtt1FbvLgmxTWZyKGRsrnFZNMoHdEJa/</a></p><h2 id="使用脚本自动化push"><a class="header-anchor" href="#使用脚本自动化push"> </a>使用脚本自动化push</h2><p>为了实现自动push，我自己写了个脚本，可以同时把博客push到git pages和ipfs上：<a href="https://gist.github.com/liuqinh2s/0864ed7799b161bb2f048b4fab867d5a" target="_blank" rel="noopener">https://gist.github.com/liuqinh2s/0864ed7799b161bb2f048b4fab867d5a</a></p><p>在你的博客目录下新建一个<code>push.sh</code>，然后把代码复制粘贴，保存，以后每次push的时候执行：<code>bash push.sh</code></p>]]></content>
      
      <categories>
          
          <category> 区块链 </category>
          
          <category> ipfs </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Volley库StringRequest编码问题</title>
      <link href="/blog/2018/05/03/Volley%E5%BA%93StringRequest%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/"/>
      <url>/blog/2018/05/03/Volley%E5%BA%93StringRequest%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>最近在做的一个工作是：从一个URL地址读取一系列手机联系人资料，保持到手机通讯录里面。</p><p>项目使用了Volley库，FastJson库，遇到的一个bug是编码错误，FastJson在进行从String到bean的解析的时候，编码不正确导致的出错，这个时候，先检查了URL的编码是UTF-8的，然后Android Studio的程序源文件也是UTF-8的，那就只有一个可能了，网络传输过程中的编码错误。</p><p>google一下发现早就有人在stackoverflow上问过这个问题了：</p><blockquote><p>How to get Android Volley StringRequest GET to return responses in UTF-8 encoding</p></blockquote><p>How can I get Android Volley StringRequest GET to return responses in UTF-8 encoding? It only seems to return responses in ISO-8859-1.</p><p>Is it possible to get it to accept a UTF-8 string?</p><p>StringRequest call HttpHeaderParser.parseCharset(response.headers) to get charset from response headers, is ‘Content-Type’ in headers don`t contains ‘charset’ the default charset return as ‘ISO-8859-1’.</p><p>StringRequest.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Response&lt;String&gt; <span class="title">parseNetworkResponse</span><span class="params">(NetworkResponse response)</span> </span>&#123;</span><br><span class="line">    String parsed;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        parsed = <span class="keyword">new</span> String(response.data, HttpHeaderParser.parseCharset(response.headers));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException var4) &#123;</span><br><span class="line">        parsed = <span class="keyword">new</span> String(response.data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Response.success(parsed, HttpHeaderParser.parseCacheHeaders(response));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HttpHeaderParser.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">parseCharset</span><span class="params">(Map&lt;String, String&gt; headers, String defaultCharset)</span> </span>&#123;</span><br><span class="line">    String contentType = headers.get(HTTP.CONTENT_TYPE);</span><br><span class="line">    <span class="keyword">if</span> (contentType != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String[] params = contentType.split(<span class="string">";"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; params.length; i++) &#123;</span><br><span class="line">            String[] pair = params[i].trim().split(<span class="string">"="</span>);</span><br><span class="line">            <span class="keyword">if</span> (pair.length == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (pair[<span class="number">0</span>].equals(<span class="string">"charset"</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> pair[<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> defaultCharset;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the charset specified in the Content-Type of this header,</span></span><br><span class="line"><span class="comment"> * or the HTTP default (ISO-8859-1) if none can be found.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">parseCharset</span><span class="params">(Map&lt;String, String&gt; headers)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> parseCharset(headers, HTTP.DEFAULT_CONTENT_CHARSET);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>so, you can parse to ‘UTF-8’ in 2 ways:</p><ol><li>tell your webServer to add ‘Content-Type’ with ‘charset=UTF-8’ in headers</li><li>Create a subclass of StringRequest and override parseNetworkResponse method</li></ol><p>意思是定制一个<code>MyStringRequest</code>类，继承<code>StringRequest</code>类，重载<code>parseNetworkResponse</code>即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Response&lt;String&gt; <span class="title">parseNetworkResponse</span><span class="params">(NetworkResponse response)</span> </span>&#123;</span><br><span class="line">    String parsed;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        parsed = <span class="keyword">new</span> String(response.data, <span class="string">"utf-8"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException var4) &#123;</span><br><span class="line">        parsed = <span class="keyword">new</span> String(response.data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Response.success(parsed, HttpHeaderParser.parseCacheHeaders(response));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Java </category>
          
          <category> Android </category>
          
          <category> Volley库 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Android通讯录深入研究</title>
      <link href="/blog/2018/05/03/Android%E9%80%9A%E8%AE%AF%E5%BD%95%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6/"/>
      <url>/blog/2018/05/03/Android%E9%80%9A%E8%AE%AF%E5%BD%95%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6/</url>
      <content type="html"><![CDATA[<p>The <code>DISPLAY_NAME</code> can be fetched either from Contacts <code>database/ContactsContract.Data' OR 'database/ContactsContract.CommonDataKinds.StructuredName' OR 'database/RawContactsEntity</code>. In the later 2 cases you will be able to fetch the <code>DISPLAY_NAME</code> using <code>RAW_CONTACT_ID</code></p><p>Couple of Key pointers:</p><ul><li>Contacts._ID = Data.CONTACT_ID</li><li>RawContacts._ID = Data.RAW_CONTACT_ID</li><li>RawContacts.CONTACT_ID = Contacts._ID</li><li>RawContactsEntity._ID = RawContacts._ID</li></ul><p>Sounds confusing?? Let me try…</p><ol><li>The Contacts database is divided into 3 tables <code>contacts</code>, <code>raw contacts</code>, and <code>data</code>.</li><li>Each table contains column (_ID) which is an auto incremented primary key.</li><li>data table contains all the contact info like phone number, mail id, address etc.</li><li>The raw contacts points to the actual contact created. Hence we use the raw contacts while adding a contact.</li><li>The user cannot add any data in the contacts table. The data in this table is populated internally due to aggregation of contacts.</li><li>The reason your logic worked for some of the contacts is: _ID for contacts, raw contacts remains same until there is any contact aggregation taking place. Lets say you add two contacts with same name abc. Here the _ID for raw contacts increments twice while _ID for contacts increments only once as these two contacts gets merged due to the aggregation of contacts</li></ol><p>The best approach to fetch the info in your case is by using <code>ContactsContract.RawContactsEntity</code> ( an outer join of the raw_contacts table with the data table)</p><p>这里还有一篇文章，写的比较详细：<a href="http://android-contact-id-vs-raw-contact-id.blogspot.jp/" target="_blank" rel="noopener">http://android-contact-id-vs-raw-contact-id.blogspot.jp/</a></p><p>官方文档：</p><ul><li><a href="https://developer.android.com/reference/android/provider/ContactsContract" target="_blank" rel="noopener">https://developer.android.com/reference/android/provider/ContactsContract</a></li><li><a href="https://developer.android.com/reference/android/provider/ContactsContract.Data" target="_blank" rel="noopener">https://developer.android.com/reference/android/provider/ContactsContract.Data</a></li></ul>]]></content>
      
      <categories>
          
          <category> Java </category>
          
          <category> Android </category>
          
          <category> 通讯录 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java Servlet 学习笔记</title>
      <link href="/blog/2018/05/01/Java-Servlet-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/blog/2018/05/01/Java-Servlet-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<blockquote><p>The difference between servlets and JSP is that servlets typically embed HTML inside Java code, while JSPs embed Java code in HTML.</p></blockquote><p>不过现在都是用MVC框架了。</p><h2 id="life-cycle-of-a-servlet"><a class="header-anchor" href="#life-cycle-of-a-servlet"> </a>life cycle of a servlet</h2><p>Three methods are central to the life cycle of a servlet. These are <code>init()</code>, <code>service()</code>, and <code>destroy()</code>. They are implemented by every servlet and are invoked at specific times by the server.</p><ul><li>the web container initializes the servlet instance by calling the init() method, passing an object implementing the <code>javax.servlet.ServletConfig</code> interface. This configuration object allows the servlet to access name-value initialization parameters from the web application.</li><li>Each request is serviced in its own separate thread. The web container calls the service() method of the servlet for every request. The developer of the servlet must provide an implementation for these methods.</li><li>Finally, the web container calls the destroy() method that takes the servlet out of service. The destroy() method, like init(), is called only once in the lifecycle of a servlet.</li></ul><p>The following is a typical user scenario of these methods.</p><ol><li>Assume that a user requests to visit a URL.<ul><li>The browser then generates an HTTP request for this URL.</li><li>This request is then sent to the appropriate server.</li></ul></li><li>The HTTP request is received by the web server and forwarded to the servlet container.<ul><li>The container maps this request to a particular servlet.</li><li>The servlet is dynamically retrieved and loaded into the address space of the container.</li></ul></li><li>The container invokes the <code>init()</code> method of the servlet.<ul><li><strong>This method is invoked only when the servlet is first loaded into memory.</strong></li><li>It is possible to pass initialization parameters to the servlet so that it may configure itself.</li></ul></li><li>The container invokes the <code>service()</code> method of the servlet.<ul><li>This method is called to process the HTTP request.</li><li>The servlet may read data that has been provided in the HTTP request.</li><li>The servlet may also formulate an HTTP response for the client.</li></ul></li><li>The servlet remains in the container’s address space and is available to process any other HTTP requests received from clients.<ul><li><strong>The service() method is called for each HTTP request.</strong></li></ul></li><li>The container may, at some point, decide to unload the servlet from its memory.<ul><li>The algorithms by which this decision is made are specific to each container.</li></ul></li><li>The container calls the servlet’s destroy() method to relinquish any resources such as file handles that are allocated for the servlet; important data may be saved to a persistent store.</li><li>The memory allocated for the servlet and its objects can then be garbage collected.</li></ol><h2 id="example"><a class="header-anchor" href="#example"> </a>Example</h2><p>The following example servlet prints how many times its <code>service()</code> method was called.</p><p>Note that <code>HttpServlet</code> is a subclass of <code>GenericServlet</code>, an implementation of the <code>Servlet</code> interface.</p><p>The <code>service()</code> method of <code>HttpServlet</code> class dispatches requests to the methods <code>doGet()</code>, <code>doPost()</code>, <code>doPut()</code>, <code>doDelete()</code>, and so on; according to the HTTP request. In the example below <code>service()</code> is overridden and does not distinguish which HTTP request method it serves.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletConfig;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletLifeCycleExample</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">final</span> ServletConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.init(config);</span><br><span class="line">        getServletContext().log(<span class="string">"init() called"</span>);</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(<span class="keyword">final</span> HttpServletRequest request, <span class="keyword">final</span> HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        getServletContext().log(<span class="string">"service() called"</span>);</span><br><span class="line">        count++;</span><br><span class="line">        response.getWriter().write(<span class="string">"Incrementing the count to "</span> + count);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        getServletContext().log(<span class="string">"destroy() called"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>javax是什么？</p></blockquote><p>java和javax都是Java的API(Application Programming Interface)包，java是核心包，<strong>javax的x是extension的意思，也就是扩展包</strong>。java类库是java发布之初就确定了的基础库，而javax类库则是在上面增加的一层东西，就是为了保持版本兼容要保存原来的，但有些东西有了更好的解决方案，所以，就加上些，典型的就是awt(Abstract Windowing ToolKit) 和swing。</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
          <category> Java web </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>mathjax常用公式记录</title>
      <link href="/blog/2018/04/30/mathjax%E5%B8%B8%E7%94%A8%E5%85%AC%E5%BC%8F%E8%AE%B0%E5%BD%95/"/>
      <url>/blog/2018/04/30/mathjax%E5%B8%B8%E7%94%A8%E5%85%AC%E5%BC%8F%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<h2 id="角度记法"><a class="header-anchor" href="#角度记法"> </a>角度记法</h2><ul><li>度数：<code>$60^\circ$</code>，$60^\circ$</li><li>度数分：<code>$60^\prime$</code>，$60^\prime$</li><li>弧度：<code>$\frac{\pi}{2}$</code>，$\frac{\pi}{2}$</li><li>角度记法：<code>$\angle A$</code>，$\angle A$</li></ul><h2 id="三重环积分无法渲染的问题"><a class="header-anchor" href="#三重环积分无法渲染的问题"> </a>三重环积分无法渲染的问题</h2><p>在网上找了半天资料最终解决了，参考这个答案：<a href="https://math.meta.stackexchange.com/questions/9973/how-do-you-render-a-closed-surface-double-integral" target="_blank" rel="noopener">How do you render a closed surface double integral?</a>，做法是直接使用Unicode编码：<code>\unicode{x222F}</code>，三重环积分的编码，参考这里：<a href="http://unicode-search.net/unicode-namesearch.pl?term=INTEGRAL" target="_blank" rel="noopener">unicode-search.net</a>，所以只要将<code>$oiiint$</code>换成<code>$\unicode{x2230}$</code>即可正确显示三重环积分。如下：</p><p>$$\unicode{x2230}$$</p>]]></content>
      
      <categories>
          
          <category> LaTex </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>LeetCode 274. H-Index</title>
      <link href="/blog/2018/04/30/LeetCode-274.H-Index/"/>
      <url>/blog/2018/04/30/LeetCode-274.H-Index/</url>
      <content type="html"><![CDATA[<p>Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher’s h-index.</p><p>According to the <a href="https://en.wikipedia.org/wiki/H-index" target="_blank" rel="noopener">definition of h-index on Wikipedia</a>: “A scientist has index h if h of his/her N papers have <strong>at least</strong> h citations each, and the other N − h papers have <strong>no more than</strong> h citations each.”</p><p>For example, given <code>citations = [3, 0, 6, 1, 5]</code>, which means the researcher has <code>5</code> papers in total and each of them had received <code>3, 0, 6, 1, 5</code> citations respectively. Since the researcher has <code>3</code> papers with <strong>at least</strong> <code>3</code> citations each and the remaining two with <strong>no more than</strong> <code>3</code> citations each, his h-index is <code>3</code>.</p><p><strong>Note:</strong> If there are several possible values for <code>h</code>, the maximum one is taken as the h-index.</p><p><strong>Credits:</strong><br>Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.</p><p>看了维基百科的解说之后，我发现这题还是挺简单的，思路就是排序，如果用C++解这题，我就直接用std::sort了。</p><p>C++代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; citations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(citations.size()&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::sort(citations.begin(), citations.end(), compare);</span><br><span class="line">        <span class="keyword">int</span> result = citations[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;citations.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;citations[i])&#123;</span><br><span class="line">                result = i+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i&gt;j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> ACM </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>椭圆规</title>
      <link href="/blog/2018/04/30/%E6%A4%AD%E5%9C%86%E8%A7%84/"/>
      <url>/blog/2018/04/30/%E6%A4%AD%E5%9C%86%E8%A7%84/</url>
      <content type="html"><![CDATA[<h2 id="利用简单定义的椭圆规"><a class="header-anchor" href="#利用简单定义的椭圆规"> </a>利用简单定义的椭圆规</h2><p>椭圆大家高中的时候都学过，椭圆有两个中心，椭圆轨迹上的点到这两个中心的距离加起来就是长轴的长度。</p><p><img src="http://highscope.ch.ntu.edu.tw/wordpress/wp-content/uploads/2011/01/EasyCapture1105.bmp" alt="利用简单定义的椭圆规"></p><h2 id="利用参数式的椭圆规"><a class="header-anchor" href="#利用参数式的椭圆规"> </a>利用参数式的椭圆规</h2><p><img src="http://highscope.ch.ntu.edu.tw/wordpress/wp-content/uploads/2011/01/EasyCapture1101.bmp" alt="利用参数式的椭圆规"></p><p>$\overline{AP}=a$，$\overline{BP}=b$，P点所绘制的就是椭圆了。画圆规时先固定十字底座，旋转时A点保持在纵轴滑动，B点保持在横轴滑动，当规臂完成$360^\circ$时，P点的轨迹即为椭圆，且此椭圆的长半轴是 a，短半轴是 b。</p><p>下面讲讲原理：</p><p><img src="http://highscope.ch.ntu.edu.tw/wordpress/wp-content/uploads/2011/01/EasyCapture1102.bmp" alt="参数式椭圆规原理"></p><p>若以十字中心为原点，十字横向为x轴，纵向为y轴，设定一个直角坐标系，并设 $\theta$ 为以x轴为始边，规臂$\overline{AP}$为终边的广义角，不难看出来P点的坐标是 $(a\cos\theta, b\sin\theta)$，即方程式为：$\frac{x<sup>2}{a</sup>2}+\frac{y<sup>2}{b</sup>2}=1$ 的椭圆方程式。其中a为长半轴的长度，b为短半轴的长度。</p>]]></content>
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 解析几何 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>UML图</title>
      <link href="/blog/2018/04/28/UML%E5%9B%BE/"/>
      <url>/blog/2018/04/28/UML%E5%9B%BE/</url>
      <content type="html"><![CDATA[<p>UML，Unified Modeling Language，统一建模语言</p><h2 id="从一个示例开始看懂uml图"><a class="header-anchor" href="#从一个示例开始看懂uml图"> </a>从一个示例开始看懂UML图</h2><p>请看下面这个类图，类之间的关系是我们需要关注的：</p><p><img src="http://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_class_struct.jpg" alt=""></p><ul><li>车的类图结构为abstract，代表车是一个抽象类</li><li>它有两个继承类：小汽车和自行车，它们之间的关系为实现关系，使用带空心箭头的虚线表示</li><li>小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示</li><li>小汽车与发动机之间是组合关系，使用带实心箭头的实线表示</li><li>学生与班级之间是聚合关系，使用带空心箭头的实线表示</li><li>学生与身份证之间为关联关系，使用一根实线表示</li><li>学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示</li></ul><p>下面我们将介绍这六种关系：</p><h2 id="类之间的关系"><a class="header-anchor" href="#类之间的关系"> </a>类之间的关系</h2><h3 id="泛化关系-generalization"><a class="header-anchor" href="#泛化关系-generalization"> </a>泛化关系（generalization）</h3><p>类的继承结构表现在UML中为：泛化（generalize）与实现（realize）：</p><p>继承关系为 <code>is-a</code> 的关系，两个对象之间如果可以用 <code>is-a</code> 来表示，就是继承关系</p><p>eg: 自行车是车，猫是动物</p><p>泛化关系用一条带空心箭头的直接表示，如下图表示（A继承自B）</p><p><img src="http://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_generalization.jpg" alt=""></p><p>eg：汽车在现实中有实现，可用汽车定义具体的对象；汽车与SUV之间为泛化关系；</p><p><img src="http://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_generalize.jpg" alt=""></p><p>注：最终代码中，<strong>泛化关系表现为继承非抽象类</strong>；</p><h3 id="实现关系-realize"><a class="header-anchor" href="#实现关系-realize"> </a>实现关系（realize）</h3><p>实现关系用一条带空心箭头的虚线表示；</p><p>eg: &quot;车&quot;为一个抽象的概念，在现实中并无法直接用来定义对象，只有指明具体的子类（汽车还是自行车），才可以用来定义对象（“车”这个类在C++中用抽象类表示，在Java中有接口这个概念，更容易理解）</p><p><img src="http://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_realize.jpg" alt=""></p><p>注：最终代码中，<strong>实现关系表现为继承抽象类</strong>；</p><h3 id="聚合关系-aggregation"><a class="header-anchor" href="#聚合关系-aggregation"> </a>聚合关系（aggregation）</h3><p>聚合关系用一条带空心菱形箭头的直线表示，如下图表示A聚合到B上，或者说B由A组成；</p><p><img src="http://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_aggregation.jpg" alt=""></p><p>聚合关系用于表示实体对象之间的关系，表示整体由部分构成的语义；例如一个部门由多个员工组成；</p><blockquote><p>与组合关系不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在；例如，部门撤销了，人员不会消失，他们依然存在；</p></blockquote><h3 id="组合关系-composition"><a class="header-anchor" href="#组合关系-composition"> </a>组合关系（composition）</h3><p>组合关系用一条带实心菱形箭头直线表示，如下图表示A组成B，或者B由A组成；</p><p><img src="http://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_composition.jpg" alt=""></p><p>与聚合关系一样，组合关系同样表示整体由部分构成的语义；比如公司由多个部门组成；</p><blockquote><p>但组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在了；例如， 公司不存在了，部门也将不存在了；</p></blockquote><h3 id="关联关系-association"><a class="header-anchor" href="#关联关系-association"> </a>关联关系（association）</h3><p>关联关系是用一条直线表示的。它描述不同类的对象之间的结构关系，它是一种静态关系，通常与运行状态无关，一般由常识等因素决定的，它一般用来定义对象之间静态的、天然的结构，所以，关联关系是一种“强关联的关系”。</p><p>比如，乘车人和车票之间是一种关联关系；学生和学校是一种关联关系。</p><p>关联关系默认不强调方向，表示对象间相互知道，如果特别强调方向，如下图，表示A知道B，但B不知道A。</p><p><img src="http://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_association.jpg" alt=""></p><p>注：在最终代码中，<strong>关联对象通常是以成员变量的形式实现的</strong>；</p><h3 id="依赖关系-dependency"><a class="header-anchor" href="#依赖关系-dependency"> </a>依赖关系（dependency）</h3><p>依赖关系是用一套带箭头的虚线表示的，如下图表示A依赖B，他描述一个对象在运行期间会用到另一个对象的关系：</p><p><img src="http://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_dependency.jpg" alt=""></p><p>与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化，依赖关系也可能发生变化</p><p>显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生。</p><p>注：在最终代码中，<strong>依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系，依赖关系除了临时知道对方外，还“使用”对方的方法和属性</strong>。</p>]]></content>
      
      <categories>
          
          <category> 编程范式 </category>
          
          <category> 面向对象编程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>数学基础公式推导</title>
      <link href="/blog/2018/04/25/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC/"/>
      <url>/blog/2018/04/25/%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80%E5%85%AC%E5%BC%8F%E6%8E%A8%E5%AF%BC/</url>
      <content type="html"><![CDATA[<p>今天看到下面这个公式，突然想我好像不会推导啊：</p><p>$\sin(\beta-\alpha) = \sin\beta\cos\alpha - \cos\beta\sin\alpha$</p><p>遂想如何推导，在youtube上找了一个视频：<a href="https://www.youtube.com/watch?v=uX6hxwW5BYM" target="_blank" rel="noopener">三角函数正余弦和角公式推导</a></p><p>思路是先推导出：$\cos(\beta-\alpha) = \cos\alpha\cos\beta + \sin\alpha\sin\beta$</p><blockquote><p>然后根据这个再结合正弦余弦之间的关系就很容易推 $\sin(\beta-\alpha) = \sin\beta\cos\alpha - \cos\beta\sin\alpha$</p></blockquote><p>那么怎么推导上面这个公式呢？</p><p>需要用到解析几何：</p><p><img src="https://i.loli.net/2018/04/27/5ae29c4bf121f.png" alt="Screen Shot 2018-04-27 at 11.42.48 AM.png"></p><p>结合 <code>勾股定理</code> 和 <code>余弦定理</code> 可以推导出。</p><p>根据勾股定理：</p><p>$$<br>\begin{align}<br>\overline{PQ}^2<br>&amp; = (\sin\alpha - \sin\beta)^2 + (\cos\beta - \cos\alpha)^2 \<br>&amp; = 2 - 2(\cos\alpha\cos\beta + \sin\alpha\sin\beta) \<br>\end{align}<br>$$</p><p>根据余弦定理（$a^2 = b^2 + c^2 -2ab\cos A$）：</p><p>$$<br>\begin{align}<br>\overline{PQ}^2<br>&amp; = 1^2 + 1^2 - 2\cdot1\cdot1\cdot\cos(\alpha-\beta)<br>\end{align}<br>$$</p><p>由此推出：</p><p>$$<br>\cos(\alpha-\beta) = \sin\alpha\sin\beta+\cos\alpha\cos\beta<br>$$</p><p>也即：</p><p>$$<br>\cos(\beta-\alpha) = \sin\alpha\sin\beta+\cos\alpha\cos\beta<br>$$</p><p>然后：</p><p>$$<br>\begin{align}<br>\sin(\beta-\alpha)<br>&amp;= \cos(\frac{\pi}{2}-(\beta-\alpha)) \<br>&amp;= \cos((\frac{\pi}{2}+\alpha) - \beta) \<br>&amp;= \sin(\frac{\pi}{2}+\alpha)\sin\beta + \cos(\frac{\pi}{2}+\alpha)\cos\beta \<br>&amp;= \cos\alpha\sin\beta - \sin\alpha\cos\beta \<br>&amp;= \sin\beta\cos\alpha - \cos\beta\sin\alpha<br>\end{align}<br>$$</p><blockquote><p>勾股定理和余弦定理的证明比较简单，读者可以试着自证。</p></blockquote>]]></content>
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Hexo+Markdown+MathJax搭建个人博客</title>
      <link href="/blog/2018/04/25/Hexo+Markdown+MathJax%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/blog/2018/04/25/Hexo+Markdown+MathJax%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<h2 id="为什么搭建个人博客"><a class="header-anchor" href="#为什么搭建个人博客"> </a>为什么搭建个人博客</h2><p>其实有想过用简书写博客，但简书不支持 <code>mathjax</code>，而我写作的时候要用到不少数学公式。</p><p>以前也用过 leanote，也就是现在的 蚂蚁笔记，但蚂蚁笔记的博客中，[TOC] 是有 mathjax 渲染的，但右上角的目录导航却是没有加 mathjax 渲染的，这样看着会相当别扭。另外还有几个原因：</p><ol><li>leanote收费</li><li>无法彻底的自定义</li><li>博客不像使用静态网站引擎那样直观的以文件的形式展示在我面前</li></ol><h2 id="为什么选-hexo"><a class="header-anchor" href="#为什么选-hexo"> </a>为什么选 hexo</h2><p>为什么选择 <code>hexo</code>，而不是 <code>jekyll</code>，或者 <code>hugo</code>。</p><p>其实我以前的博客是用的 jekyll，弃用 jekyll 是因为这东西实在是太慢了，我更新文章之后无法立即看到结果，要刷新很多次，或者说要等很久，git pages 上才会显示新的东西。听说 hexo 和 hugo 的速度都比较快，所以就换了 hexo，hexo 的主题比 hugo 多，另外 hugo 的官网和主题网站访问实在太慢了，成功恶心到了我。所以我最后选了 hexo，用上了经典主题 next。现在来说，主要是next主题吸引我，而hugo的next主题太简陋了。</p><blockquote><p>hexo 是用 nodejs 写的，jekyll 是用 ruby 写的，hugo 是用 go 语言写的，wordpress 是用 php 实现的。</p></blockquote><p>那为什么不用 wordpress 呢，因为我想用 git pages 这个平台，而这个平台只支持静态博客。</p><h2 id="搭建过程"><a class="header-anchor" href="#搭建过程"> </a>搭建过程</h2><h3 id="环境配置"><a class="header-anchor" href="#环境配置"> </a>环境配置</h3><p>首先你要安装 <code>git</code> 和 <code>npm</code>，git 是一种版本控制工具，npm 则是 nodejs 的包管理工具。</p><p>mac 上，使用 brew 和 brew cask 可以像许多 Linux 系统一样直接通过命令行安装软件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install git</span><br><span class="line">brew install node</span><br></pre></td></tr></table></figure><p>另外很不幸的是 git 和 npm 在国内都是无法愉快的使用的，虽然没有被墙，但是速度奇慢无比。于是我们需要做些工作：</p><p>给 git 挂代理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy https://127.0.0.1:1087</span><br><span class="line">git config --global https.proxy https://127.0.0.1:1087</span><br></pre></td></tr></table></figure><p>但为了实现上面的功能，首先你得有个翻墙代理。关于翻墙都可以额外写篇文章了。</p><p>想看详细的解决办法：</p><ul><li><a href="https://www.zhihu.com/question/27159393" target="_blank" rel="noopener">https://www.zhihu.com/question/27159393</a></li><li><a href="https://www.zhihu.com/question/27159393/answer/141047266" target="_blank" rel="noopener">https://www.zhihu.com/question/27159393/answer/141047266</a></li></ul><p>然后给 npm 换源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br><span class="line">npm info underscore （这个只是为了检验上面的设置命令是否成功，若成功，会返回[指定包]的信息）</span><br></pre></td></tr></table></figure><p>想看更详细的解决办法：</p><ul><li><a href="https://segmentfault.com/a/1190000007829080" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007829080</a></li></ul><p>好了，之后就是</p><ul><li>hexo 安装</li><li>初始化 blog 目录</li><li>然后 hexo server 开启本地服务器，一个 demo 就出现啦。</li></ul><p>命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init blog</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure><h3 id="基本的建站过程"><a class="header-anchor" href="#基本的建站过程"> </a>基本的建站过程</h3><h4 id="从-jekyll-迁移到-hexo"><a class="header-anchor" href="#从-jekyll-迁移到-hexo"> </a>从 jekyll 迁移到 hexo</h4><p>我是从 jekyll 迁移过来的，所以先把文章全都拷贝进 <code>source/_posts</code> 目录下面，然后修改 <code>_config.yml</code>，把：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_post_name: :title.md</span><br></pre></td></tr></table></figure><p>变成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_post_name: :year-:month-:day-:title.md</span><br></pre></td></tr></table></figure><p>官网迁移教程：<a href="https://hexo.io/zh-cn/docs/migration.html" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/migration.html</a></p><h4 id="下载-next-主题并添加-mathjax"><a class="header-anchor" href="#下载-next-主题并添加-mathjax"> </a>下载 next 主题并添加 mathjax</h4><p>然后下载一个 <code>next</code> 主题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure><p>然后修改 <code>_config.yml</code>，把：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: landscape</span><br></pre></td></tr></table></figure><p>变成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure><p>然后修改 <code>next</code> 的 <code>_config.yml</code>，把：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mathjax:</span><br><span class="line">  enable: false</span><br><span class="line">  per_page: false</span><br><span class="line">  cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config#TeX-AMS-MML_HTMLorMML</span><br></pre></td></tr></table></figure><p>变成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mathjax:</span><br><span class="line">  enable: true</span><br><span class="line">  per_page: false</span><br><span class="line">  cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config#TeX-AMS-MML_HTMLorMML</span><br></pre></td></tr></table></figure><blockquote><p>注意<code>per_page</code>不能是true，一定要是false。</p></blockquote><h4 id="解决-markdown-与-mathjax-的冲突"><a class="header-anchor" href="#解决-markdown-与-mathjax-的冲突"> </a>解决 markdown 与 mathjax 的冲突</h4><p>为了解决 <code>markdown</code> 下划线转义成 <code>&lt;em&gt;</code> 标签（HTML标签），从而导致 <code>mathjax</code> 的下标无法使用，这个问题，我们修改 <code>marked.js</code> 文件，如果你使用的是 <code>sublime text</code> 或者 <code>Atom</code> 编辑器，<code>cmd+o</code>打开你的博客目录，然后 <code>cmd+p</code> 输入你要在此目录下找的文件名：<code>marked.js</code> 就可以找到这个文件。这个文件的是：<code>node_modules/marked/lib/marked.js</code>。</p><p>总共发现 mathjax 中的三处冲突：</p><ol><li><code>_</code>变成了<code>&lt;em&gt;</code>，造成数学公式下标无法显示</li><li><code>\\</code>变成了单个<code>\</code>，数学公式<code>\begin{case}...\end{case}</code>之间换行需要用到<code>\\</code></li><li><code>&lt; xxx &gt;</code>大于号小于号之间会新增一个 <code>#&quot;&quot;</code></li></ol><p>将</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">escape: /^\\([\\`*&#123;&#125;\[\]()# +\-.!_&gt;])/,</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">escape: /^\\([`*&#123;&#125;\[\]()# +\-.!_&gt;])/,</span><br></pre></td></tr></table></figure><p>这样就去掉了，双斜杠转义。</p><p>把</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">em: /^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">em:/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span><br></pre></td></tr></table></figure><p>这样就禁掉了 <code>_</code> 变 <code>&lt;em&gt;</code>（斜体标记）。</p><p>最后，为了解决第三个冲突，我把 <code>&gt;</code> 写成了 HTML 实体形式：<code>&amp;gt;</code>，这样就无法组成一对尖括号了，终于不会冲突了。</p><p>我为什么不装个 <code>hexo-renderer-pandoc</code> + <code>pandoc</code> ，说出来都是泪啊，装了啊，一执行就报错，google 了一圈，没有有用的解答，遂作罢。</p><h4 id="解决语言不正确的问题"><a class="header-anchor" href="#解决语言不正确的问题"> </a>解决语言不正确的问题</h4><p>我发现有些地方居然默认的是德语还是什么其他语言，反正不是英语，所以我们需要改：</p><ul><li>根目录下的 <code>_config.yml</code></li><li>next 主题的 <code>_config.yml</code></li></ul><p>两个都改成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">language: en</span><br></pre></td></tr></table></figure><h4 id="生成-public-静态网站目录-和-部署到-github"><a class="header-anchor" href="#生成-public-静态网站目录-和-部署到-github"> </a>生成 public 静态网站目录 和 部署到 github</h4><p>生成静态网站目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure><p>下载 hexo-deployer-git 插件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>再修改 <code>_config.yml</code>，把：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type:</span><br></pre></td></tr></table></figure><p>变成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/liuqinh2s/liuqinh2s.github.io</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>然后，用命令 <code>hexo d</code> 部署就行了，不过首先你得有个 github 账号，然后还得有个叫 <code>liuqinh2s.github.io</code> 的项目，然后你还得配置好 github 环境：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;Your Name Here&quot;</span><br><span class="line">git config --global user.email &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure><p>然后把公钥的内容传给 github 就行了。这里只说原理，具体的操作懒得贴了。</p><blockquote><p>只有多懂原理（哪怕只是基本的原理），你才能顺利解决遇到的诸多问题。</p></blockquote><p>官网的部署教程：<a href="https://hexo.io/zh-cn/docs/deployment.html" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/deployment.html</a></p><p>基本的建站就结束了，然后就是慢慢把博客进行个性化吧。</p><h3 id="hexo-个性化配置"><a class="header-anchor" href="#hexo-个性化配置"> </a>hexo 个性化配置</h3><ul><li>hexo-reference，用来支持 markdown 脚注的</li><li>hexo-generator-seo-friendly-sitemap，sitemap用来喂给搜索引擎的，更好的爬取网站</li><li>hexo-generator-search，博客内部搜索</li><li>hexo-wordcount，统计字数用的</li></ul><p>然后就是调 next 主题，把自己喜欢的特性用上。</p><p>然后就是加上 <code>不蒜子</code>，百度统计这类统计工具，和 disqus 评论等等。</p><h2 id="遇到的问题以及解决方案"><a class="header-anchor" href="#遇到的问题以及解决方案"> </a>遇到的问题以及解决方案</h2><h3 id="如何使用html锚点"><a class="header-anchor" href="#如何使用html锚点"> </a>如何使用HTML锚点</h3><p>如果不了解HTML锚点，可以参考这个：</p><ul><li><a href="http://www.w3school.com.cn/html/html_links.asp" target="_blank" rel="noopener">w3school – HTML 链接</a></li><li><a href="https://baike.baidu.com/item/%E9%94%9A%E7%82%B9" target="_blank" rel="noopener">百度百科 – 锚点</a>。HTML可以在页面内跳转，只需要定义一个锚点，访问的时候 <strong>将 <code>#</code> 符号和锚名称添加到 URL 的末端</strong>。</li></ul><p>markdown本身是没有这个功能的，所以我们直接把标题用HTML写出来就行了。标题的对应是 <code>#</code> 到 <code>######</code> 总共6级，分别对应 <code>&lt;h1&gt;</code> 到 <code>&lt;h6&gt;</code>。</p><p>举个例子：<code>&lt;h4 id=&quot;3.2.3&quot;&gt;解决 markdown 与 mathjax 的冲突&lt;/h4&gt;</code></p><p>这里要注意的是：<strong>不要使用<code>name</code>属性，而必须使用<code>id</code>属性，否则会不起作用</strong></p><p>实际上可以使用一个markdown插件来实现：上标、下标、锚点、脚注。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm un hexo-renderer-marked --save</span><br><span class="line">npm i hexo-renderer-markdown-it --save</span><br></pre></td></tr></table></figure><p>锚点的用法，其实可以先<code>hexo g</code>一下，然后看看生成的HTML长什么样，就知道改怎么引用锚点了，经我观察，空格会被渲染成<code>-</code>，比如一个四级标题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#### 解决 markdown 与 mathjax 的冲突</span><br></pre></td></tr></table></figure><p>会被渲染成：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h4</span> <span class="attr">id</span>=<span class="string">"解决-markdown-与-mathjax-的冲突"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">"header-anchor"</span> <span class="attr">href</span>=<span class="string">"#解决-markdown-与-mathjax-的冲突"</span>&gt;</span>¶<span class="tag">&lt;/<span class="name">a</span>&gt;</span>解决 markdown 与 mathjax 的冲突<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Java OutputStream flush</title>
      <link href="/blog/2018/02/27/Java-OutputStream-flush/"/>
      <url>/blog/2018/02/27/Java-OutputStream-flush/</url>
      <content type="html"><![CDATA[<p>FileOutPutStream继承OutputStream，并不提供flush()方法的重写，所以无论内容多少，write都会将二进制流直接传递给底层操作系统的I/O，flush无效果。而Buffered系列的输入输出流函数单从Buffered这个单词就可以看出他们是使用缓冲区的。</p><p>应用程序每次IO都要和设备进行通信，效率很低，因此缓冲区为了提高效率，当写入设备时，先写入缓冲区，每次等到缓冲区满了时，就将数据一次性整体写入设备，避免了每一个数据都和IO进行一次交互，IO交互消耗太大。</p><h2 id="使用flush-和不使用flush-效果对比"><a class="header-anchor" href="#使用flush-和不使用flush-效果对比"> </a>使用flush()和不使用flush()效果对比</h2><h3 id="不使用flush"><a class="header-anchor" href="#不使用flush"> </a>不使用flush()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"Hello World"</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// create a new stream at specified file</span></span><br><span class="line">    PrintWriter pw = <span class="keyword">new</span> PrintWriter(System.out);</span><br><span class="line">    <span class="comment">// write the string in the file</span></span><br><span class="line">    pw.write(s);</span><br><span class="line"><span class="comment">//            // flush the writer</span></span><br><span class="line"><span class="comment">//            pw.flush();</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    ex.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>buffer没有满，输出为空。</p><h3 id="使用flush"><a class="header-anchor" href="#使用flush"> </a>使用flush()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"Hello World"</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// create a new stream at specified file</span></span><br><span class="line">    PrintWriter pw = <span class="keyword">new</span> PrintWriter(System.out);</span><br><span class="line">    <span class="comment">// write the string in the file</span></span><br><span class="line">    pw.write(s);</span><br><span class="line">    <span class="comment">// flush the writer</span></span><br><span class="line">    pw.flush();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    ex.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到期望的输出结果。</p><h2 id="close-和flush-作用有交集"><a class="header-anchor" href="#close-和flush-作用有交集"> </a>close()和flush()作用有交集！</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    BufferedWriter fw =<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        fw =  <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"e:\\test.txt"</span>));</span><br><span class="line">        fw.write(<span class="string">"wo shi lucky girl."</span>);</span><br><span class="line">        <span class="comment">//fw.flush();</span></span><br><span class="line">        fw.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为close的时候，会把你没flush掉的一起flush掉。<br>缓冲区中的数据保存直到缓冲区满后才写出，也可以使用flush方法将缓冲区中的数据强制写出或使用close()方法关闭流，关闭流之前，缓冲输出流将缓冲区数据一次性写出。在这个例子中，flush()和close()都使数据强制写出，所以两种结果是一样的，如果都不写的话，会发现不能成功写出。</p><h2 id="java默认缓冲区大小是多少？"><a class="header-anchor" href="#java默认缓冲区大小是多少？"> </a>Java默认缓冲区大小是多少？</h2><p>默认缓冲去大小8192字节，也就是8k。</p><h3 id="实验"><a class="header-anchor" href="#实验"> </a>实验</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] array  = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">8192</span>];</span><br><span class="line">Arrays.fill(array,<span class="string">'s'</span>);</span><br><span class="line">PrintWriter pw = <span class="keyword">new</span> PrintWriter(System.out);</span><br><span class="line">pw.write(array);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] array  = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">8193</span>];</span><br><span class="line">Arrays.fill(array,<span class="string">'s'</span>);</span><br><span class="line">PrintWriter pw = <span class="keyword">new</span> PrintWriter(System.out);</span><br><span class="line">pw.write(array);</span><br></pre></td></tr></table></figure><p>当设置数组长度为8192时没有输出，设置8193时有输出。</p>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>新概念英语四 lesson 03 Matterhorn Man</title>
      <link href="/blog/2018/02/25/%E6%96%B0%E6%A6%82%E5%BF%B5%E8%8B%B1%E8%AF%AD%E5%9B%9B-lesson-03-Matterhorn-Man/"/>
      <url>/blog/2018/02/25/%E6%96%B0%E6%A6%82%E5%BF%B5%E8%8B%B1%E8%AF%AD%E5%9B%9B-lesson-03-Matterhorn-Man/</url>
      <content type="html"><![CDATA[<p>生词：</p><ul><li>climber （这个单词要注意发音，b 是不发音的）</li><li>alpinist 登山运动员</li><li>route 路</li><li>summit 最高，顶点</li><li>sought seek 的过去式, seek sought sought</li><li>perilous 危险的</li><li>manner 方式</li><li>court 招致</li><li>solitary 孤独的</li><li>rapidly 快速的</li><li>Alpine 阿尔卑斯山的</li><li>impoverished 贫困</li><li>settlements 定居点</li><li>flea-ridden 跳蚤猖獗</li><li>coarse 粗糙的</li><li>boast 吹嘘</li><li>priest 牧师</li><li>parishioner 教徒</li><li>shepherd 牧羊人</li><li>Invariably 不变的</li><li>linen 亚麻的</li></ul><p>语言点：<br>alpinist 实际上是由 Alps 阿尔卑斯山演变来的。</p><p>What was the main objective of early mountain climbers?</p><p>语言用词的多样性：这里的目标用的是 objective，也可以用 aim，goal 等。</p><p>这个问题的答案是：to get to the top by the easiest route</p><p>Modern alpinists try to climb mountains by a route which will give them good sport, and the more difficult it is, the more highly it is regarded.</p><p>英语用词有时候非常简单，比如这里的 good sport 和 highly。</p><p>而翻译成汉语则是：</p><p>现代登山运动员总想找一条能够给他们带来运动乐趣的路线来攀登山峰。他们认为，道路愈艰险愈带劲儿。</p><p>汉语用的是 运动乐趣 和 带劲儿。也是相当地道的。</p><p>In the pioneering days however, this was not the case at all.</p><p>然而，在登山运动的初期，全然不是这种情况。</p><p>这里的 pioneering days 用法很新鲜，如果是我的话只会想到 early，this was not the case at all 又一次反映了英语用词的简洁。the case 用的很爽。</p><p>The early climbers were looking for the easiest way to the top because the summit was the prize they sought, especially if it had never been attained before.</p><p>早期登山者所寻找的是通往山顶的最方便的途径，这是他们追寻的目标，特别是前人未曾到达过的山顶。</p><p>这里的 early 呼应了前面的 pioneering，the summit was the prize they sought，时刻注意时态，英语就是如此，有不少的细节，需要严谨对待。另外 summit 用来表示山顶，如果是我的话只能想到 top，以后可以用 summit 来代替了。especially if it had never been attained before，我突然想到是不是也可以用 achieved。</p><p>It is true that during their explorations they often faced difficulties and dangers of the most perilous nature, equipped in a manner which would make a modern climber shudder at the thought, but they did not go out of their way to court such excitement.</p><p>确实，在探险中他们经常遇到惊心动魄的困难和危险，而他们的装备之简陋足以使现代登山者一想起来就胆战心惊。但是他们并非故意寻求这种刺激。</p><p>perilous险恶的，perilous nature 用来形容恶劣的自然环境。equipped in a manner which would make a modern climber shudder at the thought，这一句十分经典。court such excitement，这里的 court 表示招致，我以前只知道：法院、球场。</p><p>They had a single aim, a solitary goal – the top!</p><p>这个用了相同的词来描述同一个事，作为强调。而且语气上是递进的 single 和 solitary 比，solitary 语气更重，aim 和 goal 比，aim 表示一般的泛泛的目标，goal 则常用在体育竞赛方面。</p><p>It is hard for us to realize nowadays how difficult it was for the pioneers.</p><p>我们今天很难想象昔日的登山先驱是多么艰苦。</p><p>Except for one or two places such as Zermatt and Chamonix, which had rapidly become popular.</p><p>Alpine villages tended to be impoverished settlements cut off from civilization by the high mountains.</p><p>阿尔卑斯山山区的小村几乎全是高山环抱、与世隔绝的穷乡僻壤。</p><p>tended to be，几乎全是，用得好。cut off from civilization by the high mountains，简单词用的好，形象的描述了高山环抱、与世隔绝、穷乡僻壤。</p><p>Such inns as there were were generally dirty and flea-ridden;the food simply local cheese accompanied by bread often twelve months old, all washed down with coarse wine.</p><p>那里的小客栈一般都很脏，而且跳蚤猖獗。食物是当地的干酪和通常存放了一年之久的面包，人们就着劣酒吞下这种食物。</p><p>accompanied by 这里用的不错，bread often twelve months old，形容面包和形容人是一样的用法。washed down 用液体灌下。coarse 粗糙的，coarse wine 劣质的酒。</p><p>Often a valley boasted no inn at all, and climbers found shelter wherever they could sometimes with the local priest(who was usually as poor as his parishioners), sometimes with shepherds or cheese-makers. Invariably the background was the same: dirt and poverty, and very uncomfortable.</p><p>山谷里常常没有小客栈，登山者只好随遇而安。有时同当地牧师（他通常和他的教民一样穷）住在一起，有时同牧羊人或制乳酪的人住在一起。无论在哪儿，情况都一样：肮脏、贫穷，极其不舒适。</p><p>boast: to be lucky enough to own。这里不用 have 而是用 boast，表明作者不是在做客观的描述，而是带有感情色彩的。例子：The university boasts the highest number of first-rate teachers in China.</p><p>invariably 不变的。</p><p>For men accustomed to eating seven-course dinners and sleeping between fine linen sheets at home, the change to the Alps must have been very hard indeed.</p><p>对于过惯了一顿饭吃7道菜、睡亚麻细布床单的人来说，变换一下生活环境来到阿尔卑斯山山区，那一定是很艰难的。</p><p>seven-course dinners，七道菜的晚饭。sheet 薄片，纸张，床单。</p>]]></content>
      
      <categories>
          
          <category> 新概念英语四 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>POJ 1008 Maya Calendar</title>
      <link href="/blog/2018/02/24/POJ-1009-Edge-Detection/"/>
      <url>/blog/2018/02/24/POJ-1009-Edge-Detection/</url>
      <content type="html"><![CDATA[<p>这一题花了不少时间，首先是题目没看懂，然后搜了很久的资料，才看懂了。</p><p>边缘检测是图像处理里面的基础，这题用的边缘检测就是最简单的边缘检测，根据周边八个像素点和此像素点差值 来描绘图像中的物体的边缘。</p><p>比如第一个点15，它周围的三个点是100，100，15，得到的结果是85，再比如第4行第2列是175，它周边的点是100，100，100，175，25，175，175，25，得到的结果是150.</p><p>输入也是刚开始没看懂，其实也很简单，第一个数表示图的宽度，接下来是若干对数字，前面是像素的值，后面是个数。</p><p>最后贴上有注释的代码（C++）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Memory Time   </span></span><br><span class="line"><span class="comment">//332K   32MS   </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> size=<span class="number">1000</span>;  <span class="comment">//每幅图片的pair上限  </span></span><br><span class="line"><span class="keyword">int</span> width;  <span class="comment">//Map的宽  </span></span><br><span class="line"><span class="keyword">int</span> total=<span class="number">0</span>;  <span class="comment">//像素点总个数  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">class</span> <span class="title">OutMapPix</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    <span class="keyword">public</span>:  </span><br><span class="line">        <span class="keyword">int</span> pos;    <span class="comment">//OutMap中每个像素点的顺序位置，pos从1开始  </span></span><br><span class="line">        <span class="keyword">int</span> code;   <span class="comment">//OutMap中每个像素点对应InMap的编码  </span></span><br><span class="line">&#125;Pix;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> InMapPair[size][<span class="number">2</span>];  <span class="comment">//InMapPair[][0]为像素值，InMapPair[][1]为InMapPair[][0]连续出现的个数  </span></span><br><span class="line">Pix OutMap[size*<span class="number">9</span>];    <span class="comment">//每个pix都依赖其周围的8个点编码  </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* a,<span class="keyword">const</span> <span class="keyword">void</span>* b)</span></span>;  <span class="comment">//快排比较规则  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetValue</span><span class="params">(<span class="keyword">int</span> pos)</span></span>;  <span class="comment">//返回第pos个像素点的像素值  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetCode</span><span class="params">(<span class="keyword">int</span> pos)</span></span>;   <span class="comment">//返回第pos个像素点的编码  </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> k)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;width &amp;&amp; width)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">int</span> pairv,pairt;  </span><br><span class="line">        k=total=<span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;pairv&gt;&gt;pairt &amp;&amp; pairt)  </span><br><span class="line">        &#123;  </span><br><span class="line">            InMapPair[k][<span class="number">0</span>]=pairv;  </span><br><span class="line">            InMapPair[k++][<span class="number">1</span>]=pairt;  </span><br><span class="line">            total+=pairt;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">int</span> PairNum=k;  <span class="comment">//pair的个数  </span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;width&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pos=<span class="number">1</span>;  <span class="comment">//当前处理的像素点的位置  </span></span><br><span class="line">        k=<span class="number">0</span>; <span class="comment">//OutMap[]指针  </span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> p=<span class="number">0</span>;p&lt;=PairNum;p++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">int</span> row=(pos<span class="number">-1</span>)/width;  <span class="comment">//得到pos在二维图对应的坐标  </span></span><br><span class="line">            <span class="keyword">int</span> col=(pos<span class="number">-1</span>)%width;  </span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=row<span class="number">-1</span>;i&lt;=row+<span class="number">1</span>;i++)        <span class="comment">//枚举(row,col)周围及其自身共9个点(x,y)  </span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j=col<span class="number">-1</span>;j&lt;=col+<span class="number">1</span>;j++)  </span><br><span class="line">                &#123;  </span><br><span class="line">                    <span class="keyword">int</span> tpos=i*width+j;  <span class="comment">//得到(x,y)的顺序位置  </span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span>(i&lt;<span class="number">0</span> || j&lt;<span class="number">0</span> || j&gt;=width || tpos&gt;=total)  </span><br><span class="line">                        <span class="keyword">continue</span>;  </span><br><span class="line"></span><br><span class="line">                    OutMap[k].pos=tpos+<span class="number">1</span>;  </span><br><span class="line">                    OutMap[k++].code=GetCode(tpos+<span class="number">1</span>);  <span class="comment">//对发生变化的像素点的附近8个点和这一点本身编码（总共是9个点）</span></span><br><span class="line">                &#125;  </span><br><span class="line"></span><br><span class="line">            pos+=InMapPair[p][<span class="number">1</span>];  <span class="comment">//跳跃，确定下一个像素发生变化的点的位置  </span></span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">        qsort(OutMap,k,<span class="keyword">sizeof</span>(Pix),cmp);  <span class="comment">//对OutMap根据顺序位置  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*OutPut*/</span>  </span><br><span class="line"></span><br><span class="line">        Pix temp=OutMap[<span class="number">0</span>];  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span>(temp.code==OutMap[i].code)  </span><br><span class="line">                <span class="keyword">continue</span>;  </span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;temp.code&lt;&lt;<span class="string">' '</span>&lt;&lt;OutMap[i].pos-temp.pos&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">            temp=OutMap[i];  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;temp.code&lt;&lt;<span class="string">' '</span>&lt;&lt;total-temp.pos+<span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"0 0"</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*快排比较规则*/</span>  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* a,<span class="keyword">const</span> <span class="keyword">void</span>* b)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    Pix* x=(Pix*)a;  </span><br><span class="line">    Pix* y=(Pix*)b;  </span><br><span class="line">    <span class="keyword">return</span> x-&gt;pos - y-&gt;pos;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回第pos个像素点的像素值*/</span>  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetValue</span><span class="params">(<span class="keyword">int</span> pos)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,p=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span>(p&lt;pos)  </span><br><span class="line">        p+=InMapPair[i++][<span class="number">1</span>];  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> InMapPair[i<span class="number">-1</span>][<span class="number">0</span>];  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回第pos个像素点的编码*/</span>  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetCode</span><span class="params">(<span class="keyword">int</span> pos)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> code=GetValue(pos);  </span><br><span class="line">    <span class="keyword">int</span> MaxAbs=<span class="number">0</span>;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> row=(pos<span class="number">-1</span>)/width;  </span><br><span class="line">    <span class="keyword">int</span> col=(pos<span class="number">-1</span>)%width;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=row<span class="number">-1</span>;i&lt;=row+<span class="number">1</span>;i++)  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=col<span class="number">-1</span>;j&lt;=col+<span class="number">1</span>;j++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">int</span> tpos=i*width+j;  </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i&lt;<span class="number">0</span> || j&lt;<span class="number">0</span> || j&gt;=width || tpos&gt;=total || tpos==pos<span class="number">-1</span>)  <span class="comment">//tpos==pos-1为中心的像素点，即当前待编码的点  </span></span><br><span class="line">                <span class="keyword">continue</span>;  </span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> tcode=GetValue(tpos+<span class="number">1</span>);  </span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(MaxAbs&lt;<span class="built_in">abs</span>(tcode-code))   <span class="comment">//注意取绝对值  </span></span><br><span class="line">                MaxAbs=<span class="built_in">abs</span>(tcode-code);  </span><br><span class="line">        &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> MaxAbs;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要注意的点：</p><ol><li>主要就是自加，这里面用了很多的右自加，右自加是先使用值，然后再自加。</li><li>GetValue函数 是一个典型的寻区间代码。</li><li>算法：只计算 RLE 起始点和其周围的点。这里不做证明。</li></ol>]]></content>
      
      <categories>
          
          <category> ACM </category>
          
          <category> POJ </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>POJ 1008 Maya Calendar</title>
      <link href="/blog/2018/02/22/POJ-1008-Maya-Calendar/"/>
      <url>/blog/2018/02/22/POJ-1008-Maya-Calendar/</url>
      <content type="html"><![CDATA[<p>这一题的话：</p><ol><li>要注意 C++ 的 switch 不能使用 string，所以只好写成 if 来判断了。</li><li>另外一个值得注意的地方是，空格会中断标准输入，所以不能使用一个 string 来装下一行输入，而是分别用 string Day，string str，int Year，装下 day, month, year。</li><li>注意 Day[i]-‘0’</li><li>可以使用分批输出，无需打包成一个 string。</li></ol><p>C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Haab 365</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Tzolkin 260</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    <span class="built_in">string</span> Day;</span><br><span class="line">    <span class="keyword">int</span> Year;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="keyword">int</span> num=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; Day;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;Day[i]!=<span class="string">'.'</span>;++i)&#123;</span><br><span class="line">            num = num*<span class="number">10</span>+Day[i]-<span class="string">'0'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; str;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">"no"</span>)num += <span class="number">20</span>;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">"zip"</span>)num+=<span class="number">40</span>;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">"zotz"</span>)num+=<span class="number">60</span>;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">"tzec"</span>)num+=<span class="number">80</span>;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">"xul"</span>)num+=<span class="number">100</span>;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">"yoxkin"</span>)num+=<span class="number">120</span>;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">"mol"</span>)num+=<span class="number">140</span>;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">"chen"</span>)num+=<span class="number">160</span>;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">"yax"</span>)num+=<span class="number">180</span>;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">"zac"</span>)num+=<span class="number">200</span>;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">"ceh"</span>)num+=<span class="number">220</span>;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">"mac"</span>)num+=<span class="number">240</span>;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">"kankin"</span>)num+=<span class="number">260</span>;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">"muan"</span>)num+=<span class="number">280</span>;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">"pax"</span>)num+=<span class="number">300</span>;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">"koyab"</span>)num+=<span class="number">320</span>;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">"cumhu"</span>)num+=<span class="number">340</span>;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">"uayet"</span>)num+=<span class="number">360</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; Year;</span><br><span class="line">        num += Year*<span class="number">365</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; num%<span class="number">13</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> month = num%<span class="number">260</span>;</span><br><span class="line">        <span class="keyword">switch</span>(month%<span class="number">20</span>)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                str = <span class="string">"imix"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                str = <span class="string">"ik"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                str = <span class="string">"akbal"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                str = <span class="string">"kan"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                str = <span class="string">"chicchan"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                str = <span class="string">"cimi"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                str = <span class="string">"manik"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                str = <span class="string">"lamat"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                str = <span class="string">"muluk"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">                str = <span class="string">"ok"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">                str = <span class="string">"chuen"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">11</span>:</span><br><span class="line">                str = <span class="string">"eb"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">12</span>:</span><br><span class="line">                str = <span class="string">"ben"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">13</span>:</span><br><span class="line">                str = <span class="string">"ix"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">14</span>:</span><br><span class="line">                str = <span class="string">"mem"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">15</span>:</span><br><span class="line">                str = <span class="string">"cib"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">16</span>:</span><br><span class="line">                str = <span class="string">"caban"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">17</span>:</span><br><span class="line">                str = <span class="string">"eznab"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">18</span>:</span><br><span class="line">                str = <span class="string">"canac"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">19</span>:</span><br><span class="line">                str = <span class="string">"ahau"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">" "</span> +str +<span class="string">" "</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; num/<span class="number">260</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> ACM </category>
          
          <category> POJ </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>POJ 1007 DNA sorting</title>
      <link href="/blog/2018/02/21/POJ-1007-DNA-sorting/"/>
      <url>/blog/2018/02/21/POJ-1007-DNA-sorting/</url>
      <content type="html"><![CDATA[<p>这道题有点尴尬，刚开始一直没看懂，主要是先入为主，以为是对每一串字符串做排序，最后发现居然是根据每一串 DNA 的逆序数，对串之间进行排序。</p><p>题目本身是简单的，第一步统计逆序数，第二步排序，这里使用C++标准库的sort。</p><p>C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dna</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> unorder;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">&#125;DNA[<span class="number">105</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inversionNumber</span><span class="params">(<span class="built_in">string</span> s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> A, C, G;</span><br><span class="line">    A = C = G = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = s.length()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;--i)&#123;</span><br><span class="line">        <span class="keyword">switch</span>(s[i])&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'A'</span>:</span><br><span class="line">                A++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'C'</span>:</span><br><span class="line">                C++;</span><br><span class="line">                result += A;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'G'</span>:</span><br><span class="line">                G++;</span><br><span class="line">                result += A;</span><br><span class="line">                result += C;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'T'</span>:</span><br><span class="line">                result += A;</span><br><span class="line">                result += C;</span><br><span class="line">                result += G;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compare</span><span class="params">(dna a, dna b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.unorder &lt; b.unorder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;m)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; DNA[i].s;</span><br><span class="line">        DNA[i].unorder = inversionNumber(DNA[i].s);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    sort(DNA, DNA+m, compare);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;++i)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; DNA[i].s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> ACM </category>
          
          <category> POJ </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>POJ 1006 Biorhythms</title>
      <link href="/blog/2018/02/15/POJ-1006-Biorhythms/"/>
      <url>/blog/2018/02/15/POJ-1006-Biorhythms/</url>
      <content type="html"><![CDATA[<h2 id="同余"><a class="header-anchor" href="#同余"> </a>同余</h2><p>两个整数 a, b，若它们除以正整数 m所得的余数相等，则称 a,b对于模 m 同余，记作：$a \equiv b (mod\quad m)$。最先引用同余的概念与”$\equiv$”符号的是德国数学家 高斯。</p><h2 id="中国剩余定理"><a class="header-anchor" href="#中国剩余定理"> </a>中国剩余定理</h2><p>在《孙子算经》中有这样一个问题：“今有物不知其数，三三数之剩二（除以3余2），五五数之剩三（除以5余3），七七数之剩二（除以7余2），问物几何？”这个问题称为“孙子问题”，该问题的一般解法国际上称为“中国剩余定理”。具体解法分三步：</p><p>找出三个数：从3和5的公倍数中找出被7除余1的最小数15，从3和7的公倍数中找出被5除余1 的最小数21，最后从5和7的公倍数中找出除3余1的最小数70。<br>用15乘以2（2为最终结果除以7的余数），用21乘以3（3为最终结果除以5的余数），同理，用70乘以2（2为最终结果除以3的余数），然后把三个乘积相加（15<em>2+21</em>3+70*2）得到和233。<br>用233除以3，5，7三个数的最小公倍数105，得到余数23，即233%105=23。这个余数23就是符合条件的最小数。</p><p>为什么要这么做呢？</p><p>这就牵涉到一个最基本数学定理，如果有a%b=c,则有(a+kb)%b=c(k为非零整数)，换句话说，如果一个除法运算的余数为c，那么被除数与k倍的除数相加（或相减）的和（差）再与除数相除，余数不变。这就是上面提到的同余。</p><p>以此定理为依据，如果n2是3的倍数，n1+n2就依然满足除以3余2。同理，如果n3也是3的倍数，那么n1+n2+n3的和就满足除以3余2。这是从n1的角度考虑的，再从n2，n3的角度出发，我们可推导出以下三点：</p><ul><li>为使n1+n2+n3的和满足除以3余2，n2和n3必须是3的倍数。</li><li>为使n1+n2+n3的和满足除以5余3，n1和n3必须是5的倍数。</li><li>为使n1+n2+n3的和满足除以7余2，n1和n2必须是7的倍数。</li></ul><p>因此，为使n1+n2+n3的和作为“孙子问题”的一个最终解，需满足：</p><ul><li>n1除以3余2，且是5和7的公倍数。</li><li>n2除以5余3，且是3和7的公倍数。</li><li>n3除以7余2，且是3和5的公倍数。</li></ul><p>所以，孙子问题解法的本质是从5和7的公倍数中找一个除以3余2的数n1，从3和7的公倍数中找一个除以5余3的数n2，从3和5的公倍数中找一个除以7余2的数n3，再将三个数相加得到解。在求n1，n2，n3时又用了一个小技巧，以n1为例，并非从5和7的公倍数中直接找一个除以3余2的数，而是先找一个除以3余1的数，再乘以2。</p><p>最后，我们还要清楚一点，n1+n2+n3只是问题的一个解，并不是最小的解。如何得到最小解？我们只需要从中最大限度的减掉掉3，5，7的公倍数105即可。道理就是前面讲过的定理“如果a%b=c,则有(a-kb)%b=c”。所以（n1+n2+n3）%105就是最终的最小解。</p><p>总结就两个公式：</p><ul><li>如果 a%b=c , 则有 (a+kb)%b=c (k为非零整数)。</li><li>如果 a%b=c，那么 (a*k)%b=kc (k为大于零的整数)。</li></ul><h2 id="解题代码"><a class="header-anchor" href="#解题代码"> </a>解题代码</h2><p>最后我们再来看看我们这道题，如何使用中国剩余定理来得到时间复杂度 O(1) 的解。</p><p>已知(n+d)%23=p; (n+d)%28=e; (n+d)%33=i</p><p>使33×28×a被23除余1，用33×28×8=5544；</p><p>使23×33×b被28除余1，用23×33×19=14421；</p><p>使23×28×c被33除余1，用23×28×2=1288。</p><p>因此有（5544×p+14421×e+1288×i）% lcm(23,28,33) =n+d</p><p>又23、28、33互质，即lcm(23,28,33)= 21252;</p><p>所以有n=（5544×p+14421×e+1288×i-d）%21252</p><p>本题所求的是最小整数解，避免n为负，因此最后结果为n= [n+21252]% 21252</p><p>那么最终求解n的表达式就是：<br>n=(5544p+14421e+1288*i-d+21252)%21252</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> P 23</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> E 28</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I 33</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> C 21252</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p, e, i, d;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> J=E*I;</span><br><span class="line">    <span class="keyword">int</span> K=P*I;</span><br><span class="line">    <span class="keyword">int</span> H=P*E;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">for</span>(j=J;j%P!=<span class="number">1</span>;j+=J);</span><br><span class="line">    <span class="keyword">for</span>(k=K;k%E!=<span class="number">1</span>;k+=K);</span><br><span class="line">    <span class="keyword">for</span>(h=H;h%I!=<span class="number">1</span>;h+=H);</span><br><span class="line">    <span class="comment">// cout &lt;&lt; j &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; k &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; h &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; p &gt;&gt; e &gt;&gt; i &gt;&gt; d) &#123;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = (j*p+k*e+h*i-d+C)%C;</span><br><span class="line">        <span class="keyword">if</span>(result==<span class="number">0</span>)</span><br><span class="line">            result = C;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Case "</span>&lt;&lt; count &lt;&lt; <span class="string">": the next triple peak occurs in "</span> &lt;&lt; result &lt;&lt; <span class="string">" days."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> ACM </category>
          
          <category> POJ </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>POJ 1003 Hangover</title>
      <link href="/blog/2018/01/21/POJ-1004-Financial-Management/"/>
      <url>/blog/2018/01/21/POJ-1004-Financial-Management/</url>
      <content type="html"><![CDATA[<p>这一题简单的有点过分了，一度让我有点怀疑，但当我直接提交 AC 的那一刻，才发现还真是就这么简单。</p><p>C++ 代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">double</span> sum;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; x)&#123;</span><br><span class="line">        sum += x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"$"</span> &lt;&lt; sum/<span class="number">12</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> ACM </category>
          
          <category> POJ </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>POJ-1003-Hangover</title>
      <link href="/blog/2018/01/21/POJ-1003-Hangover/"/>
      <url>/blog/2018/01/21/POJ-1003-Hangover/</url>
      <content type="html"><![CDATA[<p>这一题 AC 的速度还是挺快的，题目本身也是很简单：</p><p>C++ 代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">double2Str</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> &amp;double_temp)</span></span>&#123;</span><br><span class="line">    <span class="built_in">stringstream</span> ss;</span><br><span class="line">    ss &lt;&lt; double_temp;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    ss &gt;&gt; str;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    <span class="comment">//对浮点数只能使用大于、小于号进行比较，不能使用等号和不等号，我这里直接把 double 转成字符串，就可以用不等号比较了</span></span><br><span class="line">    <span class="comment">//根据输入条件的限制，可以这样写：x&gt;0.01。</span></span><br><span class="line">    <span class="keyword">while</span>(double2Str(x)!=<span class="string">"0"</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> i=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">double</span> sum=<span class="number">1.0</span>/i;</span><br><span class="line">        <span class="keyword">while</span>(sum &lt; x)&#123;</span><br><span class="line">            i++;</span><br><span class="line">            sum += <span class="number">1.0</span>/i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i<span class="number">-1</span> &lt;&lt; <span class="string">" card(s)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> ACM </category>
          
          <category> POJ </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>POJ 1002 487 3279</title>
      <link href="/blog/2018/01/21/POJ-1002-487-3279/"/>
      <url>/blog/2018/01/21/POJ-1002-487-3279/</url>
      <content type="html"><![CDATA[<p>这一题看似很简单，却有着很多限制，我也是搞了很久。刚开始的时候我是用了很多 c++11 的东西，然后一直报 Compile Error，但我本地编译是不会有错的，查出几点：</p><p>vector&lt;vector<int>&gt;会报错，但 c<ins>11可以这样写，以前的老编译器只能这么写：vector&lt;vector<int> &gt;<br>to_string()函数无法使用，这是 c</int></ins>11 新出的。<br>for(int x:result)这种写法直到 c<ins>11 才支持。<br>POJ 上的编译器是比较老的，所以无法使用 c</ins>11 的新特性。</int></p><p>这还不算，后来一直报 Time Limit Exceeded，上网查资料发现，要把 cin 输入改成 getchar 接收输入，终于 AC。还有就是在勾选 language 的时候，一定要用 G++，不要用 C++，如果你选 C++，会报如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Compile Error</span><br><span class="line"></span><br><span class="line">Main.cpp</span><br><span class="line">F:\temp\18069972.33777\Main.cpp(16) : error C2057: expected constant expression</span><br><span class="line">F:\temp\18069972.33777\Main.cpp(16) : error C2466: cannot allocate an array of constant size 0</span><br><span class="line">F:\temp\18069972.33777\Main.cpp(16) : error C2133: &apos;data&apos; : unknown size</span><br></pre></td></tr></table></figure><p>C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</span><br><span class="line">    <span class="keyword">int</span> data[n];</span><br><span class="line">    <span class="keyword">int</span> size = n;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        ch = getchar();</span><br><span class="line">        <span class="comment">//过滤空行</span></span><br><span class="line">        <span class="keyword">if</span>(ch==<span class="string">'\n'</span>)&#123;</span><br><span class="line">            n++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ch!=<span class="string">'\n'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ch&gt;=<span class="string">'0'</span> &amp;&amp; ch&lt;=<span class="string">'9'</span>)&#123;</span><br><span class="line">                num = num*<span class="number">10</span> + ch - <span class="string">'0'</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch &gt;= <span class="string">'A'</span> &amp;&amp; ch &lt;= <span class="string">'P'</span>)&#123;</span><br><span class="line">                num = num*<span class="number">10</span> + (ch - <span class="string">'A'</span>)/<span class="number">3</span> + <span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ch &gt;= <span class="string">'R'</span> &amp;&amp; ch &lt;= <span class="string">'Y'</span>)&#123;</span><br><span class="line">                num = num*<span class="number">10</span> + (ch - <span class="string">'Q'</span>)/<span class="number">3</span> + <span class="number">7</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ch = getchar();</span><br><span class="line">        &#125;</span><br><span class="line">        data[n]=num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// qsort(data, size, sizeof(int), compare);</span></span><br><span class="line">    sort(data, data+size);</span><br><span class="line">    <span class="comment">// for(int i=0;i&lt;size;i++)&#123;</span></span><br><span class="line">    <span class="comment">//     cout &lt;&lt; data[i] &lt;&lt; endl;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;size;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(data[i]==data[i<span class="number">-1</span>])&#123;</span><br><span class="line">            count++;</span><br><span class="line">            index=i;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(count!=<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%03d-%04d %d\n"</span>,data[i<span class="number">-1</span>]/<span class="number">10000</span>,data[i<span class="number">-1</span>]%<span class="number">10000</span>,count);</span><br><span class="line">                <span class="comment">// cout &lt;&lt; setfill('0') &lt;&lt; setw(3) &lt;&lt; data[i-1]/10000 &lt;&lt; '-' &lt;&lt; setfill('0') &lt;&lt; setw(4) &lt;&lt; data[i-1]%10000 &lt;&lt; ' ' &lt;&lt; count &lt;&lt; endl;</span></span><br><span class="line">                count=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i==size<span class="number">-1</span> &amp;&amp; count!=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%03d-%04d %d\n"</span>,data[i<span class="number">-1</span>]/<span class="number">10000</span>,data[i<span class="number">-1</span>]%<span class="number">10000</span>,count);</span><br><span class="line">            count=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(index==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"No duplicates."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> ACM </category>
          
          <category> POJ </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>POJ 1005 I Think I Need a Houseboat</title>
      <link href="/blog/2018/01/21/POJ-1005-I-Think-I-Need-a-Houseboat/"/>
      <url>/blog/2018/01/21/POJ-1005-I-Think-I-Need-a-Houseboat/</url>
      <content type="html"><![CDATA[<p>这一题也很简单，直接上代码：</p><p>C++ 代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="number">3.141592653589793</span>;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">    <span class="keyword">double</span> area;</span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        area = PI*(x*x+y*y)/<span class="number">2</span>;</span><br><span class="line">        year = area/<span class="number">50</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Property "</span> &lt;&lt; i &lt;&lt; <span class="string">": This property will begin eroding in year "</span> &lt;&lt; year &lt;&lt; <span class="string">"."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"END OF OUTPUT."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> ACM </category>
          
          <category> POJ </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>POJ 1001 Exponentiation</title>
      <link href="/blog/2018/01/20/POJ-1001-Exponentiation/"/>
      <url>/blog/2018/01/20/POJ-1001-Exponentiation/</url>
      <content type="html"><![CDATA[<p>这是我第一次做 ACM，也是 POJ 上的第一题，本来以为这一题应该属于很简单的题，但没想到却花了不少时间。</p><p>本来我是想着用C++标准库的 pow 函数，但这一题显然是个大实数乘法，double 可能就不够用了，所以只能自己手动实现乘法。Java 有个 BigInteger 和 BigDecimal 分别用来处理大整数和大实数。</p><p>我的代码（已经 AC）：</p><p>C++代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 两数相乘，使用vector保存每一位数字，从低位到高位</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Multi(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v1.size() + v2.size() + <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        result.push_back(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v1.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; v2.size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            result[i + j] += v1[i] * v2[j];</span><br><span class="line">            result[i + j + <span class="number">1</span>] += result[i + j] / <span class="number">10</span>;</span><br><span class="line">            result[i + j] %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; str &gt;&gt; n)&#123;</span><br><span class="line">        <span class="comment">// cout &lt;&lt; str &lt;&lt; " " &lt;&lt; n &lt;&lt; " ";</span></span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numArray;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; resultArray;</span><br><span class="line">        <span class="keyword">int</span> dotPos = <span class="number">0</span>, begin = <span class="number">0</span>, end = str.length() - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果全是0和. 就直接输出0</span></span><br><span class="line">        <span class="keyword">bool</span> isAllZero = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">bool</span> hasDot = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str.length();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i]!=<span class="string">'0'</span> &amp;&amp; str[i]!=<span class="string">'.'</span>)&#123;</span><br><span class="line">                isAllZero = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(str[i]==<span class="string">'.'</span>)&#123;</span><br><span class="line">                hasDot = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(isAllZero)&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果没有小数点就不用删除后序零</span></span><br><span class="line">        <span class="keyword">if</span>(hasDot)&#123;</span><br><span class="line">            <span class="comment">//删除后序零（只删除小数点后的后序零，小数点之前的零保留，比如 10.0，变成10，而不是1）</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = str.length() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(str[i] != <span class="string">'0'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    end = i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 测出小数位数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = end; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] == <span class="string">'.'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                dotPos = end - i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//删除前序零（如果小数点被0包裹，那么也将小数点删除，比如：00.001，变成1）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] != <span class="string">'0'</span> &amp;&amp; str[i]!=<span class="string">'.'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                begin = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将浮点数按位保存为整型</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = end; i &gt;= begin; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i]!=<span class="string">'.'</span>)&#123;</span><br><span class="line">                numArray.push_back(str[i] - <span class="string">'0'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 复制数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numArray.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            resultArray.push_back(numArray[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算数组的n次方</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n<span class="number">-1</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            resultArray = Multi(resultArray, numArray);</span><br><span class="line">            <span class="keyword">int</span> len = resultArray.size();</span><br><span class="line">            <span class="comment">// 移除前导零</span></span><br><span class="line">            <span class="keyword">while</span> (resultArray[len<span class="number">-1</span>] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                resultArray.pop_back();</span><br><span class="line">                len--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出结果，结果小于零时</span></span><br><span class="line">        <span class="keyword">if</span>(n * dotPos &gt;= resultArray.size())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"."</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n * dotPos - resultArray.size(); k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"0"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=resultArray.size()<span class="number">-1</span>;k&gt;=<span class="number">0</span>;k--)&#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; resultArray[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = resultArray.size() - <span class="number">1</span>; k &gt;= <span class="number">0</span>; k--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (k == n * dotPos - <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; <span class="string">"."</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; resultArray[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我自己写了一个测试用例的脚本：</p><p>input.cpp:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> buffer;</span><br><span class="line">    <span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">"hello.txt"</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (! in.is_open())  </span><br><span class="line">       &#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"Error opening file"</span>; <span class="built_in">exit</span> (<span class="number">1</span>); &#125;</span><br><span class="line">       <span class="keyword">while</span> (!in.eof() )  </span><br><span class="line">       &#123;  </span><br><span class="line">        getline(in,buffer);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; buffer &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hello.txt 内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">95.123 12</span><br><span class="line">0.4321 20</span><br><span class="line">5.1234 15</span><br><span class="line">6.7592  9</span><br><span class="line">98.999 10</span><br><span class="line">1.0100 12</span><br><span class="line">.00001  1</span><br><span class="line">.12345  1</span><br><span class="line">0001.1  1</span><br><span class="line">1.1000  1</span><br><span class="line">10.000  1</span><br><span class="line">000.10  1</span><br><span class="line">000000  1</span><br><span class="line">000.00  1</span><br><span class="line">.00000  0</span><br><span class="line">000010  1</span><br><span class="line">000.10  1</span><br><span class="line">0000.1  1</span><br><span class="line">00.111  1</span><br><span class="line"></span><br><span class="line">0.0001  1</span><br><span class="line">0.0001  3</span><br><span class="line">0.0010  1</span><br><span class="line">0.0010  3</span><br><span class="line">0.0100  1</span><br><span class="line">0.0100  3</span><br><span class="line">0.1000  1</span><br><span class="line">0.1000  3</span><br><span class="line">1.0000  1</span><br><span class="line">1.0000  3</span><br><span class="line">1.0001  1</span><br><span class="line">1.0001  3</span><br><span class="line">1.0010  1</span><br><span class="line">1.0010  3</span><br><span class="line">1.0100  1</span><br><span class="line">1.0100  3</span><br><span class="line">1.1000  1</span><br><span class="line">1.1000  3</span><br><span class="line">10.000  1</span><br><span class="line">10.000  3</span><br><span class="line">10.001  1</span><br><span class="line">10.001  3</span><br><span class="line">10.010  1</span><br><span class="line">10.010  3</span><br><span class="line">10.100  1</span><br><span class="line">10.100  3</span><br><span class="line">99.000  1</span><br><span class="line">99.000  3</span><br><span class="line">99.001  1</span><br><span class="line">99.001  3</span><br><span class="line">99.010  1</span><br><span class="line">99.010  3</span><br><span class="line">99.100  1</span><br><span class="line">99.100  3</span><br><span class="line">99.998  1</span><br><span class="line">99.998  3</span><br></pre></td></tr></table></figure><p>这些测试用例都是前辈们留下来的资料。链接在这里：<a href="http://poj.org/showmessage?message_id=76017" target="_blank" rel="noopener">测试用例</a></p><p>顺带讲一下怎么自动测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//打开命令行，先编译两个 C++ 文件：</span><br><span class="line">g++ -std=c++11 -o input input.cpp</span><br><span class="line">g++ -std=c++11 -o main main.cpp</span><br><span class="line">//然后用管道把输入输出串起来，把最终解输入到文件 output.txt 里</span><br><span class="line">./input | ./main &gt; output.txt</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> ACM </category>
          
          <category> POJ </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Override Overload Overwrite</title>
      <link href="/blog/2017/11/14/Override-Overload-Overwrite/"/>
      <url>/blog/2017/11/14/Override-Overload-Overwrite/</url>
      <content type="html"><![CDATA[<p>我们都知道有些东西容易混淆，在加上中文翻译得乱七八糟，更加让人困惑。今天我要讲的这三位可就真是绝了。</p><p>它们是：Override、Overload、Overwrite。</p><p>这是我查有道词典时候看到的可怕一幕：</p><p><img src="https://wx4.sinaimg.cn/mw690/006zFO3ggy1flhl8a9e69j312w0tatf9.jpg" alt=""></p><p>Override 一个把三个名字都占了，你怕不怕？反正我是看的心里一紧。</p><p>如果把概念都煮成了一锅粥，那还不如不要记这些概念，你应该向更深层次去探寻。就这三个的区别来说，我觉得主要理解两个概念就行了：</p><ol><li>函数签名（signature）</li><li>多态（polymorphism、polymorphic）</li></ol><h2 id="函数签名"><a class="header-anchor" href="#函数签名"> </a>函数签名</h2><p>函数签名是什么，其实就是用来区别函数的，两个函数怎么样认定是不同的两个函数呢，只有两个方面：</p><ol><li>函数名</li><li>参数</li></ol><p>有人说还有返回值啊，不行，返回值不能作为函数签名的一部分，因为你调用一个函数的时候，返回值根本不能帮助编译器来识别你用的是哪个函数，比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line">func();</span><br></pre></td></tr></table></figure><p>请问我使用的是哪个函数？你看返回值确实不行吧。</p><h2 id="多态"><a class="header-anchor" href="#多态"> </a>多态</h2><p>多态是面向对象编程的概念，你可以看看它的准确定义：</p><p><a href="https://en.wikipedia.org/wiki/Polymorphism_(computer_science)" target="_blank" rel="noopener">Polymorphism</a>。</p><p>定义很简短：polymorphism is the provision of a single interface to entities of different types.</p><p><a href="https://docs.oracle.com/javase/tutorial/java/IandI/polymorphism.html" target="_blank" rel="noopener">The Java™ Tutorials</a></p><p>如果父类有一个函数，子类也定义了一个完全相同的函数（函数签名相同），那么你可以用父类指针（或者说父类对象）作为统一的接口，来调用子类的方法。比如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(“Vehicles can move!!”);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MotorBike</span> <span class="title">extends</span> <span class="title">Vehicle</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(“MotorBike can move <span class="keyword">and</span> accelerate too!!”);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="title">extends</span> <span class="title">Vehicle</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(“Hi! I am a car!”);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Vehicle vh = <span class="keyword">new</span> MotorBike();</span><br><span class="line">        vh.move();    <span class="comment">// prints MotorBike can move and accelerate too!!</span></span><br><span class="line">        vh = <span class="keyword">new</span> Vehicle();</span><br><span class="line">        vh.move();    <span class="comment">// prints Vehicles can move!!</span></span><br><span class="line">        vh = <span class="keyword">new</span> Car();</span><br><span class="line">        vh.move();   <span class="comment">// prints Hi! I am a car!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多态的好处是可以扩展啊，比如我后来又多了个 truck 类，我不需要去动已经写好的代码，只要把 truck 模块写好，加进去就行了。</p><h2 id="override-overload-overwrite-的区别"><a class="header-anchor" href="#override-overload-overwrite-的区别"> </a>Override、Overload、Overwrite 的区别</h2><p>好了，知道了这两个概念，我们再来看看上面的那三个混在一起的东西：</p><ul><li>Override（推翻，对英文意思就是这个）subclass method overrides base class method means:<ul><li>in different range (in derived class and base class)</li><li>the same function signature</li><li>the base class method is virtual（if in C++）</li></ul></li><li>overload（超载）function overloading means:<ul><li>the same range (in the same class)</li><li>the same function name</li><li>but different function signature</li></ul></li><li>overwrite（重写）subclass method hides base class method means:<ul><li>in different range (in derived class and base class)</li><li>the same function name</li></ul></li></ul><p>我们应该记住只有 Override 才跟多态有关。</p><p>Overload 是本class 里面的不同函数（只不过函数名一样罢了，其实是两个不同的函数，看两个函数是否是同一个函数就看函数签名就行了），其实没啥稀奇的，不就是函数名一样嘛。函数签名一样，区分出是用父类还是子类的函数，这才是面向对象和多态要解决的问题。</p><h2 id="override-和-overwrite-的区别"><a class="header-anchor" href="#override-和-overwrite-的区别"> </a>Override 和 Overwrite 的区别</h2><blockquote><p>比较容易混淆的其实是 Override 和 Overwrite，但你只要死记住：Override 必须函数签名要一样，而 Overwrite 只需函数名一样即可。另外 C++ 中一定要用virtual才算 Override，而 Java 默认就是 Override，不需要修饰词。</p></blockquote><blockquote><p>这里关于 Java 和 C++ 面向对象的细节区别可以写一大堆，比如：C++ class 后面是要加分号的，而 Java 不需要；但 Java 的类名是和文件名要一致的，而且只能有一个 public 类，而 C<ins>不需要；Java 直接就能用 Override，而 C</ins>必须要使用 virtual 关键字才能使用 Override（虚函数）；Java 的抽象方法跟 C<ins>的纯虚函数对应。Java 是单继承，由接口来实现“多继承”，C</ins>是多继承，没有接口，只有抽象类。C++还有个虚基类的概念。具体的写法上还有很多的不同，多用这两种语言写面向对象的代码，就慢慢会知道了。</p></blockquote><p>C++ 有一个 virtual 关键字和 virtual table 这个概念，没有加 virtual 的父类函数是不可能形成多态的，如果这时候你碰到父类和子类两个里面有同名的函数，那么就属于 Overwrite 这个概念了，你其实也可以称这种覆盖掉父类函数的行为为：hide 隐藏。Java 这种语言里面没有 virtual 这一套，Java 也可以表现出 Overwrite，但要注意函数签名如果一样的话，那又不叫 Overwrite 了，应该叫 Override 了（Java 如果要在子类中使用父类的同函数签名方法，则必须使用 super 关键字）。而 C++ 不一样，即便是函数签名一样，如果前面不加 virtual 是不能叫 Override 的，仍然属于 Overwrite 的概念。请看下面的例子：</p><p>用 C++ 写的话：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"A"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"B"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A *a = <span class="keyword">new</span> B();</span><br><span class="line">    a-&gt;func(<span class="number">1</span>);</span><br><span class="line">    ((B*)a)-&gt;func(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">B</span><br></pre></td></tr></table></figure><p>可以看到，C<ins>必须要用子类类型的指针才能访问到子类的部分（建议看一本书，叫：Inside the C</ins> Object Model，中文叫：深入C++对象模型，里面讲对象的内存布局讲的很清楚），java 也一样，必须转成子类型的指针才能访问，否则 IDE 会报错提示你。</p><p>Java 代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"A"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="title">extends</span> <span class="title">A</span>&#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"B"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        test t = <span class="keyword">new</span> test();</span><br><span class="line">        A a = t.<span class="keyword">new</span> B();</span><br><span class="line">        a.fun(<span class="number">1</span>);</span><br><span class="line">        ((B)a).func(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">B</span><br></pre></td></tr></table></figure><p>为什么 Java 代码里不像 C++ 代码里面那样，使用两个函数签名相同的函数？因为前面说过了，那样的话就变成 Override 了，只有在 C++ 里才能实现函数签名相同的 Overwrite（不使用virtual即可）。</p>]]></content>
      
      <categories>
          
          <category> 编程范式 </category>
          
          <category> 面向对象编程 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Inside the C++ Object Model 系列笔记 四 -- The Semantics of Function</title>
      <link href="/blog/2017/10/23/Inside-the-C++-Object-Model-%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0--The-Semantics-of-Function/"/>
      <url>/blog/2017/10/23/Inside-the-C++-Object-Model-%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0--The-Semantics-of-Function/</url>
      <content type="html"><![CDATA[<blockquote><p>c++支持三种类型的成员函数，分别为static,nostatic,virtual。每一种调用方式都不尽相同。</p></blockquote><h2 id="nonstatic-member-function"><a class="header-anchor" href="#nonstatic-member-function"> </a>nonstatic member function</h2><p>C++的设计准则之一就是:nonstatic member function至少必须和一般的nonmember function 有相同的效率。<br>实际上，nonstatic member function 会被编译器进行如下的转换，变成一个普通函数:</p><p>Type1 X::foo(Type2 arg1) { … }</p><p>会被转换为如下的普通函数:</p><p>void foo(X *const this, Type1 &amp;__result, Type2 arg1) { … }</p><p>改写函数原型，在参数中增加this指针，对每一个”nonstatic data member的存取操作”改为由this指针来存取</p><p>将member function重写为一个外部函数，经过”mangling”处理（不需要处理的加上 extern “C”）</p><p>实际上，普通函数、普通成员函数、静态成员函数到最后都会变成与C语言函数类似的普通函数，只是编译器在这些不同类型的函数身上做了不同的扩展，并放在不同的 scope 里面而已。</p><p>编译器内部会将成员函数等价转换为非成员函数，具体是这样做的:</p><p>1.改写成员函数的签名，使得其可以接受一个额外参数，这个额外参数即是this指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> Point::X();</span><br><span class="line"><span class="comment">//成员函数X被插入额外参数this</span></span><br><span class="line"><span class="keyword">float</span> Point:: X(Point* <span class="keyword">this</span> );</span><br></pre></td></tr></table></figure><p>当然如果成员函数是const的，插入的参数类型将为 const Point* 类型。</p><p>2.将每一个对非静态数据成员的操作都改写为经过this操作。</p><p>3.将成员函数写成一个外部函数，对函数名进行“mangling”处理，使之成为独一无二的名称。</p><p>可以看出，将一个成员函数改写成一个外部函数的关键在于两点，一是给函数提供一个可以直接读写成员数据的通道；<br>二是解决好有可能带来的名字冲突。第一点通过给函数提供一个额外的指针参数来解决，第二点则是通过一定的规则将名字转换，使之独一无二。</p><p>于是在VC中对于上面的例子中的成员函数的调用将发生如下的转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//p-&gt;X();被转化为</span></span><br><span class="line">?X@Point@@QAEMXZ(p);</span><br><span class="line"><span class="comment">//obj.X();被转化为</span></span><br><span class="line">?X@Point@@QAEMXZ(&amp;obj);</span><br></pre></td></tr></table></figure><p>覆盖（override）、重载（overload）、隐藏（hide, overwrite）的区别：</p><ul><li>覆盖（也叫重写）是指在派生类中重新对基类中的虚函数（注意是虚函数）重新实现。即函数名和参数都一样（函数签名一样），只是函数的实现体不一样。</li><li>重载是指 <strong>在同一个类中</strong> 不同的函数使用相同的函数名，但是函数的参数个数或类型不同。调用的时候根据函数的参数来区别不同的函数。</li><li>隐藏是指派生类中的函数把基类中相同名字的函数屏蔽掉了。隐藏与另外两个概念表面上看来很像，很难区分，其实他们的关键区别就是在多态的实现上。</li></ul><blockquote><p>C++多态（polymorphism）表示”以一个public base class的指针（或者reference），寻址出一个derived class object”</p></blockquote><p>我专门写了一篇关于这些容易弄混的概念的文章：<a href="../2017/11/14/Override-Overload-Overwrite">Override Overload Overwrite</a></p><h2 id="virtual-member-function"><a class="header-anchor" href="#virtual-member-function"> </a>Virtual Member Function</h2><p>如果function()是一个虚拟函数，那么用指针或引用进行的调用将发生一点特别的转换——一个中间层被引入进来。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p-&gt;function()</span></span><br><span class="line"><span class="comment">//将转化为</span></span><br><span class="line">(*p-&gt;vptr[<span class="number">1</span>])(p);</span><br></pre></td></tr></table></figure><ul><li>其中vptr为指向虚函数表的指针，它由编译器产生。vptr也要进行名字处理，因为一个继承体系可能有多个vptr。</li><li>1是虚函数在虚函数表中的索引，通过它关联到虚函数function().</li></ul><p>何时发生这种转换？答案是在必需的时候 – 一个再熟悉不过的答案。当通过指针调用的时候，要调用的函数实体无法在编译期决定，必需待到执行期才能获得，所以上面引入一个间接层的转换必不可少。但是当我们通过对象（不是引用，也不是指针）来调用的时候，<br>进行上面的转换就显得多余了，因为在编译器要调用的函数实体已经被决定。此时调用发生的转换，与一个非静态成员函数(Nonstatic Member Functions)调用发生的转换一致。p.function()的处理就跟非静态成员函数一样了。</p><h2 id="static-member-function"><a class="header-anchor" href="#static-member-function"> </a>Static Member Function</h2><ul><li>不能够直接存取其类中的非静态成员（nostatic members），包括不能调用非静态成员函数(Nonstatic Member Functions)。</li><li>不能声明为const、volatile或virtual</li><li>参数没有this</li><li>可以不用对象访问，直接 类名::静态成员函数 访问，当然，通过对象调用也被允许</li></ul><p>需要注意的是通过一个表达式或函数对静态成员函数进行调用，被C++ Standard要求对表达式进行求值。如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(a+=b).static_fuc();</span><br><span class="line">func().static_fuc();</span><br></pre></td></tr></table></figure><p>虽然省去对a+b求值对于static_fuc()的调用并没有影响，但是程序员肯定会认为表达式a+=b已经执行，一旦编译器为了效率省去了这一步，很难说会浪费多少程序员多少时间去查找这个bug。这无疑是一个明智的规定。func()返回一个对象。</p><p>vtable的内容：</p><ul><li>virtual class offset（有虚基类才有）</li><li>topoffset</li><li>typeinfo</li><li>继承基类所声明的虚函数实例，或者是覆盖（override）基类的虚函数</li><li>新的虚函数（或者是纯虚函数占位）</li></ul><p>虚函数表的构造挺简单的：</p><p><img src="https://i.loli.net/2018/04/25/5ae01bb4b32a9.gif" alt="虚函数表的构造"></p><p>从内存布局的角度看，类对象继承基类的时候只把基类的 nonstatic data member和member function（函数入口，也可以说是函数指针） 放进自己内存里，static data member和static function都在global address里面。然后就是虚函数表是复制了一份基类的虚函数表，然后把virtual实现了的部分替换掉，没实现的就不改，依然用父类的。然后虚函数表指针自然也要不一样，毕竟指向的内存地址不一样，对吧。</p>]]></content>
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 《Inside the C++ Object Model》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Inside the C++ Object Model 系列笔记 三 -- The Semantics of Data</title>
      <link href="/blog/2017/10/21/Inside-the-C++-Object-Model-%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0--The-Semantics-of-Data/"/>
      <url>/blog/2017/10/21/Inside-the-C++-Object-Model-%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0--The-Semantics-of-Data/</url>
      <content type="html"><![CDATA[<p>C++对象模型的细节，讨论了 data members 的处理。</p><h2 id="空类在内存中有空间吗"><a class="header-anchor" href="#空类在内存中有空间吗"> </a>空类在内存中有空间吗</h2><p>一个实例引出的思考：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>&#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> X&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Z</span>:</span><span class="keyword">virtual</span> <span class="keyword">public</span> X&#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span><span class="keyword">public</span> Y, <span class="keyword">public</span> Z&#123;&#125;;</span><br></pre></td></tr></table></figure><p>猜猜sizeof上面各个类都为多少？</p><p>Lippman的一个法国读者的结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sizeof X yielded 1</span><br><span class="line">sizeof Y yielded 8</span><br><span class="line">sizeof Z yielded 8</span><br><span class="line">sizeof A yielded 12</span><br></pre></td></tr></table></figure><p>Lippman自己的结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sizeof X yielded 1</span><br><span class="line">sizeof Y yielded 4</span><br><span class="line">sizeof Z yielded 4</span><br><span class="line">sizeof A yielded 8</span><br></pre></td></tr></table></figure><p>事实上，对于像X这样的一个空类，编译器会对其动点手脚——隐晦的插入一个字节。为什么要这样做呢？插入了这一个字节，那么X的每一个对象都将有一个独一无二的地址。<br>如果不插入这一个字节呢？哼哼，那对X的对象取地址的结果是什么？两个不同的X对象间地址的比较怎么办？</p><p>我们再来看Y和Z。首先我们要明白的是实现虚继承，将要带来一些额外的负担——额外需要一个某种形式的指针。到目前为止，对于一个32位的机器来说Y、Z的大小应该为5，而不是8或者4。我们需要再考虑两点因素：内存对齐（alignment—）和编译器的优化。</p><p>空类也有1Byte的大小，因为这样才能使得这个class的2个objects在内存中有独一无二的地址。</p><h2 id="the-binding-of-a-data-member"><a class="header-anchor" href="#the-binding-of-a-data-member"> </a>The Binding of a Data Member</h2><p>考虑下面这样的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">float</span> x;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">truePoint3d(<span class="keyword">float</span>, <span class="keyword">float</span>, <span class="keyword">float</span>);</span><br><span class="line">true<span class="comment">//问题是 x 到底是哪个 x 呢</span></span><br><span class="line">true<span class="function"><span class="keyword">float</span> <span class="title">X</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> x;&#125;</span><br><span class="line">true<span class="function"><span class="keyword">void</span> <span class="title">X</span><span class="params">(<span class="keyword">float</span> new_x)</span> <span class="keyword">const</span></span>&#123;x = new_x;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">true<span class="keyword">float</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对member functions本身的分析会直到整个class的声明都出现了才开始（直到看到代表 class 结束的}右大括号）。所以class的 member functions 可以引用声明在后面的成员，C 语言就做不到。</p><p>和member functions对比，需要十分注意的一点是:<br>class中的typedef并不具备这个性质。<br>因此，类中的 typedef 的影响会受到函数与 typedef 的先后顺序的影响。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> length;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point3d</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">true<span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(length l)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; l &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">true<span class="keyword">typedef</span> <span class="built_in">string</span> length;</span><br><span class="line">true<span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(length l)</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; l &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样 f1 绑定的 length 类型是 int;<br>而 f2 绑定的 length 类型才是 string。</p><p>所以，对于 typedef 需要防御性的程序风格:<br>始终把 nested type 声明(即 typedef)放在 class 起始处!</p><h2 id="data-member-layout"><a class="header-anchor" href="#data-member-layout"> </a>Data Member Layout</h2><p>C<ins>只保证处于同一个 access section（也就是private,public,protected片段）的数据，一定会以声明的次序出现在内存布局当中(要求较晚出现的数据成员处在较大的内存地址中)。<br>C</ins>标准只提供了这一点点的保证。<br>允许编译器将多个Acess Section的顺序自由排列，而不必在乎它们的声明次序。但似乎没有编译器这样做。<br>对于继承类，C++标准并未指定是其基类成员在前还是自己的成员在前。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="keyword">int</span> k;</span><br><span class="line">   <span class="keyword">int</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据 i 一定在 j 之前，k 一定在 n 之前。具体什么顺序就看编译器了。</p><p>传统上，vptr被安放在所有被明确声明的member的最后，不过也有些编译器把vptr放在最前面(MSVC<ins>就是把 vptr 放在最前面，而 G</ins> 是把 vptr 放在最后面)。</p><h2 id="access-of-a-data-member"><a class="header-anchor" href="#access-of-a-data-member"> </a>Access of a Data Member</h2><p>在C++中，直观上来说，由一个对象存取一个member会比由一个指针存取一个member更快捷。<br>但是对于经由一个对象来存取和由一个指针来存取一个静态的 member 来说，是完全一样的，都会被编译器所扩展。</p><p>经由 member selection operators（也就是 “.” 运算符）对一个 static data member 进行存取操作只是一种语法上的便宜行事而已。member 其实并不在 class object 中，因此存取并不需要通过 class object。</p><p>经由一个函数调用的结果来存取静态成员，C++标准要求编译器必须对这个函数进行求值，虽然这个求值的结果并无用处。</p><p>foo().static_member = 100;</p><p>foo()返回一个类型为 X 的对象，含有一个 static_member，foo()其实可以不用求值而直接访 问这个静态成员，但是 C++标准保证了 foo()会被求值，可能的代码扩展为:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">void</span>) foo();</span><br><span class="line">X::static_member = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><h2 id="static-data-members"><a class="header-anchor" href="#static-data-members"> </a>static data members</h2><p>如果有两个 class ，每个都声明了一个 static member freelist，那么当他们都被放在程序的 data segment时，就会导致名称冲突。编译器的解决方法是暗中对每一个 static data member 编码（这种手法有个很美的名称：name-mangling），以获得一个独一无二的程序识别代码。有多少种编译器就有多少种 name-mangling 做法！通常不外乎是表格啦，语法措辞啦等等。任何 name-mangling 都有两个要点：</p><ol><li>一种算法，推导出独一无二的名称。</li><li>万一编译系统（或环境工具）必须和使用者交谈，那些独一无二的名称可以轻易被推导回原来的名称。</li></ol><h2 id="nonstatic-data-members"><a class="header-anchor" href="#nonstatic-data-members"> </a>nonstatic data members</h2><p>Nonstatic data members are stored directly within each class object and cannot be accessed except through an explicit or implicit class object. An implicit class object is present whenever the programmer directly accesses a nonstatic data member within a member function. For example, in the following code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Point3d</span><br><span class="line">Point3d::translate( <span class="keyword">const</span> Point3d &amp;pt ) &#123;</span><br><span class="line">   x += pt.x;</span><br><span class="line">   y += pt.y;</span><br><span class="line">   z += pt.z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>the seemingly direct access of x, y, and z is actually carried out through an implicit class object represented<br>by the this pointer. Internally, the function is augmented as follows:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// internal augmentation of member function</span></span><br><span class="line">  Point3d</span><br><span class="line">  Point3d::translate( <span class="keyword">const</span> Point3d* <span class="keyword">this</span>, <span class="keyword">const</span> Point3d &amp;pt ) &#123;</span><br><span class="line">     <span class="keyword">this</span>-&gt;x += pt.x;</span><br><span class="line">     <span class="keyword">this</span>-&gt;y += pt.y;</span><br><span class="line">     <span class="keyword">this</span>-&gt;z += pt.z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>地址：&amp;origin._y;和&amp;origin + ( &amp;Point3d::_y - 1 );是一样的。指向 data member 的指针，其 offset 值总是被加上1。这样可以使编译系统区分出 “一个指针 data member 的指针，用以指向 class 的第一个 member”和“一个指向 data member 的指针，但是没有指向任何 member”两种情况(成员指针也需要有个表示 NULL 的方式，0 相当于用来表示 NULL 了，其它的就都要加上 1 了)。</p><h2 id="inheritance-and-the-data-member"><a class="header-anchor" href="#inheritance-and-the-data-member"> </a>Inheritance and the Data Member</h2><p>C++ Standard 保证:“出现在派生类中的 base class subobject 有其完整原样性!” 子类会被放在父类的对齐空白字节之后，因为父类的完整性必须得以保证，父类的对齐空白字节 也是父类的一部分，也是不可分割的。</p><p>请看下面例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X2</span>:</span><span class="keyword">public</span> X</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span>  c2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>X2的布局应当是x(4),c(1),c2(1),这么说来sizeof(X2)的值应该是8？错了，实际上是12。原因在于X后面的三个字节的填充空白不能为c2所用。也就是说X2的大小实际上为：X(8)+c2(1)+填补（3）=12。这样看来编译器似乎是那么的呆板，其实不然，看一下下面的语句会发生什么？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X2 x2;</span><br><span class="line">X x;</span><br><span class="line">x2=x;</span><br></pre></td></tr></table></figure><p>如果X后面的填充空白可以被c2使用的话，那么X2和X都将是8字节。上面的语句执行后x2.c2的值会是多少？一个不确定的值！这样的结果肯定不是我们想要的。</p><p>在多重继承的派生体系中，将派生类的地址转换为第 1 基类时成本与单继承是相同的，只需要改换地址的解释方式而已；而对于转换为非第 1 基类的情况，则需要对地址进行一定的 offset 操作 才行。<br>C++ Standard 并未明确 base classes 的特定排列次序，但是目前的编译器都是按照声明的次序来安放他们的。(有一个优化:如果第 1 基类没有 vtable 而后继基类有，则可能把它们调 个位置)。<br>多重继承中，可能会有多个 vptr 指针，视其继承体系而定:派生类中 vptr 的数目最多等于所有基<br>类的 vptr 数目的总和。</p>]]></content>
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 《Inside the C++ Object Model》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Inside the C++ Object Model 系列笔记 二 -- The Semantics of constructors</title>
      <link href="/blog/2017/10/19/Inside-the-C++-Object-Model-%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0--The-Semantics-of-constructors/"/>
      <url>/blog/2017/10/19/Inside-the-C++-Object-Model-%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0--The-Semantics-of-constructors/</url>
      <content type="html"><![CDATA[<p>这一章详细的讨论了 constructor 如何工作，讨论构造一个对象的过程以及构造一个对象给程序带来的影响。</p><h2 id="区分trivial和notrivial"><a class="header-anchor" href="#区分trivial和notrivial"> </a>区分trivial和notrivial</h2><ol><li>只有编译器需要的时候(为什么会需要?后面讲的很清楚)，合成操作才是nontrivial的， 这样的函数才会被真正的合成出来;</li><li>如果编译器不需要，而程序员又没有提供，这时的默认构造函数就是trivial的。虽然它在概念上存在，但是编译器实际上根本不会去合成出来，因为他不做任何没有意义的事情，所以当然可以忽略它不去合成。trivial 的函数只存在于概念上，实际上不存在这个函数。</li></ol><h2 id="default-constructor"><a class="header-anchor" href="#default-constructor"> </a>default constructor</h2><p>A default constructor is a constructor which can be called with no arguments (either defined with an empty parameter list, or with default arguments provided for every parameter).</p><h3 id="通常很多c-程序员存在两种误解"><a class="header-anchor" href="#通常很多c-程序员存在两种误解"> </a>通常很多C++程序员存在两种误解</h3><ul><li>没有定义默认构造函数的类都会被编译器生成一个默认构造函数。</li><li>编译器生成的默认构造函数会明确初始化类中每一个数据成员。</li></ul><p><strong>被声明：declared，被定义：defined</strong>。声明代表分配内存空间，定义代表初始化，也就是分配具体的值。</p><p>所以所有成员都在声明的时候被分配内存，构造函数的作用是初始化它们，non-object 成员需要程序员自己初始化，编译器不帮忙。</p><p>C++中对于默认构造函数的解释是:<br><strong>默认的构造函数会在需要的时候被编译器产生出来。</strong><br>这里非常重要的一点是:<br>谁需要?是程序的需要还是编译器的需要?如果是程序的需要，那是程序员的责任;<br>只有在是编译器的需要时，默认构造函数才会被编译器产生出来，而且被产生出来的默认构造函数只会执行编译器所需要的行动，而且这个产生操作只有在默认构造函数真正被调用时才会进行合成。</p><p>例如:成员变量初始化为 0 操作，这个操作就是程序的需要，而不是编译器的需要。</p><p>总结变量的初始化:</p><p>Global objects are guaranteed to have their associated memory “zeroed out” at program start-up. Local objects allocated on the program stack and heap objects allocated on the free-store do not have their associated memory zeroed out; rather, the memory retains the arbitrary bit pattern of its previous use.</p><p>只有全局变量和静态变量才会保证初始化，其中静态变量可以视为全局变量的一种，因为静态变量也是保存在全局变量的存储空间上的。<br>Golbal objects 的内存保证会在程序激活的时候被清 0；Local objects 配置于程序的堆栈中，Heap objects 配置于自由空间中，都不一定会被清为 0,它们的内容将是内存上次被使用后的痕迹!</p><p>全局变量和静态变量都放在 global data Segment 上，且在类被声明的时候就已经分配内存和初始化，也就是 <strong>在任何对象被定义之前静态变量就已经存在了（即使该 class 没有任何 object 实体，static data members也已经存在）。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span> <span class="keyword">public</span>: <span class="keyword">int</span> val; Foo *pnext; &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo_bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// Oops:  program needs bar's members zeroed out</span></span><br><span class="line">   Foo bar;</span><br><span class="line">   <span class="keyword">if</span> ( bar.val || bar.pnext )</span><br><span class="line">      <span class="comment">// ... do something</span></span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>When is a default constructor synthesized, then? Only when the implementation needs it. Moreover, the synthesized constructor performs only those activities required by the implementation. That is, even if there were a need to synthesize a default constructor for class Foo, that constructor would not include code to zero out the two data members val and pnext. For the previous program fragment to execute correctly, the designer of class Foo needs to provide an explicit default constructor that properly initializes the class’s two members.</p><p>意思是初始化 val 和 pnext 是程序员的责任，编译器不负责，所以你这里不初始化它们，它们存储的结果就是内存遗留的痕迹。</p><h3 id="什么时候编译器会给你生成默认构造函数"><a class="header-anchor" href="#什么时候编译器会给你生成默认构造函数"> </a>什么时候编译器会给你生成默认构造函数</h3><p>首先你得没有写默认构造函数，编译器才会给你生成。有四类情况，编译器会给你加代码：</p><ol><li>类中有一个对象（成员变量），这个对象包含了默认构造函数</li><li>继承自带有默认构造函数的基类的类</li><li>带有虚函数的类</li><li>继承自虚基类的类</li></ol><p>如果class A内含一个或以上的member objects，那么A的constructor必须调用每一个 member class 的默认构造函数。<br>具体方法是:编译器会扩张 constructors（注意：是所有的构造函数，不仅仅是默认构造函数会被扩张），在其中安插代码使得在 user code 被调用之前先调 用 member objects 的默认构造函数(当然如果需要调用基类的默认构造函数，则放在基类的 默认构造函数调用之后:基类构造函数-&gt;成员构造函数-&gt;user code)。<br>C++要求以“member objects 在 class 中的声明次序”来调用各个 construtors。这就是声明的次序决定了初始化次序(构造函数初始化列表一直要求以声明顺序来初始化)的根本原因!<br>所以你打乱 member initialization list 的顺序根本没有用哦~</p><p>理解了初始化列表中的实际执行顺序中“以 member 声明的次序”来决定的，就可以理解一些很 微妙的错误了。比如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A() : i(<span class="number">99</span>), j(<span class="number">66</span>), value(foo()) &#123;... &#125;</span><br><span class="line"><span class="keyword">int</span> i, value, j;</span><br></pre></td></tr></table></figure><p>这会不会产生错误取决于成员函数 foo()是依赖于 i 还是 j:<br>如果 foo 依赖于 i，由于 i 声明在 value 之前，所以不会产生错误;<br>如果 foo 依赖于 j，由于 j 声明在 value 之后，就产生了使用未初始化成员的错误。</p><p>带有virtual functions的类的默认构造函数毫无疑问是nontrivial的，需要编译器安插额外的<br>成员 vptr 并在构造函数中正确的设置好 vptr，这是编译器的重要职责之一。<br>继承自 virtual base class 的类的默认构造函数同样也毫无疑问的 nontrivial，编译器需要正确设置相关的信息以使得这些虚基类的信息能够在执行时准备妥当，这些设置取决于编译器实现虚基类的手法。</p><p>编译器有4种情况会使得编译器真正的为class生成nontrivial的默认构造函数，这个 nontrivial 的默认构造函数只满足编译器的需要(调用 member objects 或 base class 的默认构造函数、初始化 virtual function 或 virutal base class 机制)。其它情况时，类在概念上拥有默认构造函数，但是实际上根本不会被产生出来(前面的区分 trivial 和 nontrivial)。</p><p>对于一个trivial默认构造函数，编译器的态度是，既然它全无用处，干脆就不合成它。在这儿要厘清的是概念与实现的差别，概念上追求缜密完善，在实现上则追求效率，可以不要的东西就不要。</p><h2 id="copy-constructor"><a class="header-anchor" href="#copy-constructor"> </a>copy constructor</h2><p>有一个参数的类型是其类类型的构造函数是为拷贝构造函数。如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">X::X( <span class="keyword">const</span> X&amp; x);</span><br><span class="line">Y::Y( <span class="keyword">const</span> Y&amp; y, <span class="keyword">int</span> =<span class="number">0</span> );</span><br><span class="line"><span class="comment">//可以是多参数形式，但其第二个即后继参数都有一个默认值</span></span><br></pre></td></tr></table></figure><h3 id="什么时候编译器会给你生成拷贝构造函数"><a class="header-anchor" href="#什么时候编译器会给你生成拷贝构造函数"> </a>什么时候编译器会给你生成拷贝构造函数</h3><blockquote><p>其实和前面默认构造函数一样，四种情况</p></blockquote><p>如果一个类没有定义拷贝构造函数，通常按照“成员逐一初始化(Default Memberwise Initialization)”的手法来解决“一个类对象以另一个同类实体作为初值”——也就是说把内建或派生的数据成员从某一个对象拷贝到另一个对象身上，如果数据成员是一个对象，则递归使用“成员逐一初始化(Default Memberwise Initialization)”的手法。</p><p>成员逐一初始化(Default Memberwise Initialization)具体的实现方式则是位逐次拷贝（Bitwise copy semantics）</p><p>Copy constructors和默认构造函数一样，只有在必须的时候才会被产生出来，对于大部分的class 来说，拷贝构造函数仅仅需要按位拷贝就可以。满足 bitwise copy semantics 的拷贝构造函数是 trivial 的，就不会真正被合成出来(与默认构造函数一样，只有 nontrivial 的拷贝构 造函数才会被真正合成出来)。对大多数类按位拷贝就够了，什么时候一个 class 不展现出 bitwise copy semantics 呢? 分为 4 种情况，前 2 种很明显，后 2 种是由于编译器必须保证正确设置虚机制而引起的。</p><ul><li>当class内含一个member object而后者声明了(也可能由于nontrivial语意从而编译器 真正合成出来的)一个 copy constructor 时;</li><li>当class继承自一个存在有copy constructor的base class(同样也可能是合成)时;</li><li>当class声明了一个或多个virtual functions时;(vf影响了位语意，进而影响效率)</li><li>当class派生自一个继承串链，其中一个或多个virtual base classes时。</li></ul><p>对于前两种情况，不论是基类还是对象成员，既然后者声明有拷贝构造函数时，就表明其类的设计者或者编译器希望以其声明的拷贝构造函数来完成“一个类对象以另一个同类实体作为初值”的工作，而设计者或编译器这样做——声明拷贝构造函数，总有它们的理由，而通常最直接的原因莫过于因为他们想要做一些额外的工作或“位逐次拷贝”无法胜任。</p><p>对于有虚函数的类，如果两个对象的类型相同那么位逐次拷贝其实是可以胜任的。但问题将出现在，如果基类由其继承类进行初始化时，此时若按照位逐次拷贝来完成这个工作，那么基类的vptr将指向其继承类的虚函数表，这将导致无法预料的后果——调用一个错误的虚函数实体是无法避免的，轻则带来程序崩溃，更糟糕的问题可能是这个错误被隐藏了。所以对于有虚函数的类编译器将会明确的使被初始化的对象的vptr指向正确的虚函数表。因此有虚函数的类没有声明拷贝构造函数，编译将为之合成一个，来完成上述工作，以及初始化各数据成员，声明有拷贝构造函数的话也会被插入完成上述工作的代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"A::f()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"B::f()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  B b;</span><br><span class="line">  b.i=<span class="number">1</span>;</span><br><span class="line">  A a = b;</span><br><span class="line">  A *p = &amp;a;</span><br><span class="line">  p-&gt;f();</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; p-&gt;i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子可以看出，如果 A a = b;是 bitwise copy semantics 的话，a 内放置的就是 b 的 vptr。但其实不是，编译器给 a 生成了拷贝构造函数，初始化了 a 的 vptr。b 的 vptr 是由编译器给 b 生成的默认构造函数初始化的。但对于其他成员变量 bitwise copy semantics依然有效，所以 i 的结果是1。我在做这个试验的时候发现了一个有趣的现象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"A::f()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"B::f()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  B b;</span><br><span class="line">  b.i=<span class="number">1</span>;</span><br><span class="line">  A a = b;</span><br><span class="line">  A *p = &amp;a;</span><br><span class="line">  p-&gt;f();</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; p-&gt;i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个 i 不是同一个 i，b.i=1;优先给 b 中的同名变量赋值了。这样的代码简直可怕。那么怎么访问到从 A 继承来的成员变量 i 呢，请看：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"A::f()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123; <span class="built_in">cout</span> &lt;&lt; <span class="string">"B::f()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  B b;</span><br><span class="line">  b.A::i=<span class="number">6</span>;</span><br><span class="line">  b.B::i=<span class="number">1</span>;</span><br><span class="line">  A a = b;</span><br><span class="line">  A *p = &amp;a;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; p-&gt;i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="命名返回值优化"><a class="header-anchor" href="#命名返回值优化"> </a>命名返回值优化</h2><p>对于一个如foo()这样的函数，它的每一个返回分支都返回相同的对象，编译器有可能对其做Named return Value优化（下文都简称NRV优化），方法是以一个参数result取代返回对象。</p><p>foo()的原型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    X xx;</span><br><span class="line">    <span class="keyword">if</span>(...)</span><br><span class="line">        <span class="keyword">return</span> xx;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化后的foo()以result取代xx：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>  <span class="title">foo</span><span class="params">(X &amp;result)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    result.X::X();</span><br><span class="line">    <span class="keyword">if</span>(...)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//直接处理result</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//直接处理result</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对比优化前与优化后的代码可以看出，对于一句类似于X a = foo()这样的代码，NRV优化后的代码相较于原代码节省了一个临时对象的空间（省略了xx）,同时减少了两次函数调用（减少xx对象的默认构造函数和析构函数，以及一次拷贝构造函数的调用，增加了一次对a的默认构造函数的调用）。</p>]]></content>
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 《Inside the C++ Object Model》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Inside the C++ Object Model 系列笔记 一 -- Object Lessons</title>
      <link href="/blog/2017/10/19/Inside-the-C++-Object-Model-%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0--Object-Lessons/"/>
      <url>/blog/2017/10/19/Inside-the-C++-Object-Model-%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0--Object-Lessons/</url>
      <content type="html"><![CDATA[<blockquote><p>多态：统一的接口，不同的实现</p></blockquote><p><strong>C++多态（polymorphism）</strong> 表示”以一个public base class的指针（或者reference），寻址出一个derived class object”</p><h2 id="layout-costs-for-adding-encapsulation-封装"><a class="header-anchor" href="#layout-costs-for-adding-encapsulation-封装"> </a>Layout Costs for Adding Encapsulation(封装)</h2><p>第一章 Object Lessons 介绍了 C++如何在背后实现一个对象，内存中的布局以及空间上的关系。</p><p><strong>在计算机的原理中，要实现某个机制，我们总能找到很多种实现方式</strong>（对比着学习，多思考每种实现方法的利弊），C++的类的实现也不例外，让我们对比以下三种实现方式：</p><h3 id="三种对象实现模式"><a class="header-anchor" href="#三种对象实现模式"> </a>三种对象实现模式</h3><h4 id="a-simple-object-model"><a class="header-anchor" href="#a-simple-object-model"> </a>A Simple Object Model</h4><p><img src="https://wx4.sinaimg.cn/mw690/006zFO3ggy1fknaq5739jj30nu0l4jsy.jpg" alt="A Simple Object Model"></p><p>可以看到，简单对象模型把所有的data member和member function（函数指针）都放在对象里了。</p><h4 id="a-table-driven-object-model"><a class="header-anchor" href="#a-table-driven-object-model"> </a>A Table-driven Object Model</h4><p><img src="https://wx4.sinaimg.cn/mw690/006zFO3ggy1fmxnb321f6j30n80kemzy.jpg" alt="A Table-driven Object Model"></p><p>表驱动模型把member分为data和function两类，用两个指针分别指向两个表，一个存放所有的data member，一个存放所有的function指针。</p><h4 id="the-c-object-model"><a class="header-anchor" href="#the-c-object-model"> </a>The C++ Object Model</h4><p><img src="https://wx3.sinaimg.cn/mw690/006zFO3ggy1fmxnd1t7ucj30ua0ju0wu.jpg" alt="The C++ Object Model"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Type</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Point3d</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Point3d(Type x, Type y, Type z) : x_(x), y_(y), z_(z) &#123;&#125;</span><br><span class="line">    <span class="function">Type <span class="title">x</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> x_; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Type x_, y_, z_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的 C++ 类并不会比 C 语言 的struct 耗费更多的内存空间，三个 data members 直接内含于 Object 中，member functions 则放在 Object 外。</p><p>C++的 data members 有两种：<strong>static 和 nonstatic</strong></p><p>C++的 member functions 有三种：<strong>static 、nonstatic 、virtual</strong></p><blockquote><p>放在 Object 中的只有 nonstatic data members，其他的统统是放在 Object 外。</p></blockquote><p>一个对象的内存布局大小(通常由 3 部分组成):</p><ul><li>其 nonstatic data member 的总和大小;</li><li>任何由于位对齐所需要的填补上去的空间;(关于内存对齐，自己查)</li><li>加上了为了支持virtual机制而引起的额外负担。</li></ul><h3 id="data-members-在内存中的布局"><a class="header-anchor" href="#data-members-在内存中的布局"> </a>data members 在内存中的布局</h3><p>C<ins>只保证处于同一个 access section（也就是private,public,protected片段）的数据，一定会以声明的次序出现在内存布局当中(要求较晚出现的数据成员处在较大的内存地址中)。<br>C</ins>标准只提供了这一点点的保证。<br>允许编译器将多个Acess Section的顺序自由排列，而不必在乎它们的声明次序。但似乎没有编译器这样做。<br>对于继承类，C++标准并未指定是其基类成员在前还是自己的成员在前。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="keyword">int</span> j;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="keyword">int</span> k;</span><br><span class="line">   <span class="keyword">int</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据 i 一定在 j 之前，k 一定在 n 之前。具体什么顺序就看编译器了。</p><h3 id="virtual-table-vtbl-vtable-和-vptr"><a class="header-anchor" href="#virtual-table-vtbl-vtable-和-vptr"> </a>Virtual Table(vtbl, vtable) 和 vptr</h3><p>Virtual function 机制由以下2个步骤来支持：</p><ol><li>每个 class 产生的 Virtual function 的指针放在 Virtual Table 中</li><li>编译器给每个 class object 添加一个指针 vptr，指向相应的 vtable</li></ol><p>一个 vtable 对应一个 class，一个 vptr 才对应一个 class object，必须区分开这 2 个概念。vtable 独立于对象，就跟函数独立于对象一样。<br>这样所有对象才能共享它们，就像 static data members 被共享一样。</p><p>RTTI(run-time type identification):一般来说，每一个 class 相关联的 type_info 对象的指针通常也保存在 vtable 的第一个 slot 中。关于 type_info 是什么，可以自己查。</p><h3 id="引入继承后的对象模型成本"><a class="header-anchor" href="#引入继承后的对象模型成本"> </a>引入继承后的对象模型成本</h3><ul><li>如果是普通继承，父对象被直接包含在子对象里面，这样父对象的存取也是直接进行的，没有额外的指针成本。</li><li>如果是虚拟继承，父对象由一个指针指出来，这样父对象的存取就必须由指针访问，添加了一层间接性。</li></ul><p>virtual base class，用以实现 “多次出现在继承体系中的base class，有一个单一而被共享的实例”</p><p><img src="https://wx3.sinaimg.cn/mw690/006zFO3gly1fknlhzg45wj30bs0asq3w.jpg" alt="虚基类"></p><p><img src="https://wx1.sinaimg.cn/mw690/006zFO3gly1fknli0837fj317w0mmhao.jpg" alt="虚拟多重继承"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span> <span class="keyword">public</span>: <span class="function"><span class="keyword">void</span> <span class="title">Foo</span><span class="params">()</span> </span>&#123;&#125; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> A &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> A &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>我觉得这里有个问题，class D继承class B和class C的时候并不是虚继承，所以何不将B和C直接放在D中呢？这样就省了两次指针。</p></blockquote><h2 id="struct-和-class-关键字的区别"><a class="header-anchor" href="#struct-和-class-关键字的区别"> </a>struct 和 class 关键字的区别</h2><p>总共就两个区别：</p><ul><li>struct defaults to public access and class defaults to private access.</li><li>When inheriting, struct defaults to public inheritance and class defaults to private inheritance. (Ironically, as with so many things in C++, the default is backwards: public inheritance is by far the more common choice, but people rarely declare structs just to save on typing the “public” keyword). 哈哈，我觉得这么做的目的无非就是提醒你注意封装，不要给外部暴露没必要的东西，所以才把默认搞成private。</li></ul><p>除此之外 struct 和 class 一样。</p><p>struct 用来表现那些只有数据的集合体 POD(Plain Old Data)、而 class则希望表达的是<code>ADT(abstract data type)</code>的思想。</p><blockquote><p>POD stands for Plain Old Data - that is, a class (whether defined with the keyword struct or the keyword class) without constructors, destructors and virtual members functions.</p></blockquote><p>由于这2个关键字在本质上无区别，所以class并没有必须要引入，但是引入它的确非常令人满意，因为这个语言所引入的不止是这个关键字，还有它所支持的封装和继承的哲学。可以这样想象:struct只剩下方便C程序员迁徙到C++的用途了。</p><h2 id="programming-paradigms"><a class="header-anchor" href="#programming-paradigms"> </a>programming paradigms</h2><p>C++支持三种形式的编程风格(或称典范 paradigm):</p><ul><li>面向过程的风格（procedural model）:就像C一样，一条语句接一条语句的执行或者函数跳转;</li><li>抽象数据类型模型(abstract data type model，ADT):仅仅使用了class的封装，很多人都是 在用基于对象的风格却误以为自己在使用面向对象的风格;</li><li>面向对象的风格(object-oriented):使用了class的封装和多态的编程思维(多态才是 真正的面向对象的特征)。</li></ul><p>纯粹以一种paradigm写程序，有助于整体行为的良好稳固。</p><blockquote><p>一个 reference 通常是以一个指针来实现的，所以 point 和 reference 并没有本质的区别，reference 和 const 指针的区别就是，你取 reference 指针的地址的时候，取到的是数据的地址，const 指针取地址取到的是指针的地址。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> &amp;b=a;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; &amp;b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; &amp;p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说你取不到 b 的地址。所以说引用相当于一个 <code>别名</code>。引用常用在函数调用里，可以直接操作原有对象，这样就可以不用写指针的指针这种绕弯的东西了。</p><blockquote><p>函数的实参传递给形参是值传递，也就是一个 copy，形参在函数里将是一个局部变量。这个特性是许多新手面临的大坑。一道经典的考察题目便是，实现一个 C 语言的 swap 函数，由于 C 语言没有引用，你就只能用指针来操作原有对象了。</p></blockquote><h2 id="指针的类型"><a class="header-anchor" href="#指针的类型"> </a>指针的类型</h2><ul><li>对于内存来说，不同类型的指针并没有什么不同。它们都是占用一个word的大小（所以word的大小决定了内存可访问空间的大小，32位系统是4字节，64位系统是8字节），包含一个数字，这个数字代表内存中的一个地址;</li><li>指针的类型是编译器的概念，对于硬件来说，并没有什么指针类型的概念;</li><li>转型操作也只是一种编译器的指令，它改变的是编译器对被指内存的解释方式而已!</li><li>void*指针只能够持有一个地址（一个字节），而不能通过它操作所指向的object</li></ul>]]></content>
      
      <categories>
          
          <category> 读书笔记 </category>
          
          <category> 《Inside the C++ Object Model》 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我读大学时候的一些思考</title>
      <link href="/blog/2017/02/06/%E6%88%91%E8%AF%BB%E5%A4%A7%E5%AD%A6%E6%97%B6%E5%80%99%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/"/>
      <url>/blog/2017/02/06/%E6%88%91%E8%AF%BB%E5%A4%A7%E5%AD%A6%E6%97%B6%E5%80%99%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</url>
      <content type="html"><![CDATA[<p>我上大学之前一直是一个各科都学的很好的学生，文科成绩非常好，而且是个很感性的人，喜欢凭直觉，写一些无病呻吟的小文章，但是我之后毅然决然的选择了理科，并对理科产生了浓厚的兴趣，想去探究事物背后的原理，我高三时候经常问老师一些让老师都犯怵的难题（包括物理的、生物的），后来进大学学了计算机，编程思维对我产生了很大影响，我现在喜欢事事讲逻辑，讲原因，作总结，写东西也希望要言之有物，满满的思考和干货。</p><p>下面是我学生时期的一点思考，希望分享给大家，同时我也觉得需要提醒一下，人的成长多半靠经历和阅历，伟人不光是书读得多，他们的人生经历也是波澜壮阔（如果你觉得你的人生经历平平，那么就要警醒自己了），面对不确定的事要保持兴奋感，因为不确定代表着机遇（就像互联网上的超链接），一个人一生只要把握一个大机遇就非常好了，有时间我也要多出去走走，多接触些人和事物，行他个万里路，然而这需要一定的经济基础，不然只能出去要饭。</p><h2 id="读计算机专业给我带来的思考"><a class="header-anchor" href="#读计算机专业给我带来的思考"> </a>读计算机专业给我带来的思考</h2><h3 id="做事形式化-规范化"><a class="header-anchor" href="#做事形式化-规范化"> </a>做事形式化，规范化</h3><p>做事形式化其实并不是坏事，这个世界的运行体制就是形式化，也必须要形式化的，只有这样才可以高效稳定的运行起来。行有行规，做人做事都要有原则，与人与物打交道都要有协议有规定，所谓规章制度，并不是拿来消遣人的，出发点是更好的促进沟通交流。一个东西一旦规范起来，那么出漏子的情况就变得相当低了。比如出门前必定要学会检查自己要带哪些东西（都带上），要关掉哪些东西（都关掉，灯，窗，门等等。），这些都要养成习惯。而习惯的形成也正是为了减少大脑多余的思考，跟规章制度可以节约社会资源一样，不用每次都重新探讨重新设计一遍。所以优秀的习惯是可以让人轻松的保持脑力体力，做好真正需要做的、想的事，避免被小事琐事打搅，消耗脑力体力。一个人的习惯决定了一个人。这里引用一句名言：</p><p>播种一种思想（态度），收获一种行为；播种一种行为，收获一种习惯；播种一种习惯，收获一种性格；播种一种性格，收获一种人生。</p><p>其实习惯和性格是相辅相成的，性格反过来也会影响到习惯，加强习惯。而你的想法，也就是态度，会影响你的行为。所以总的来说态度（想法），行动力和习惯是最重要的三个东西。态度和行动力可以生成习惯，而习惯将决定你的未来，习惯是强大的，习惯就是力量。而想要改变自己，首先就得 <strong>端正态度</strong>。</p><h3 id="把事物信息化"><a class="header-anchor" href="#把事物信息化"> </a>把事物信息化</h3><p>要想管理好事物，就要将其信息化。这并不是现代才有的思想，古已有之。譬如政府的户籍制度，一个产品的说明书，都是各成体系，规范（这又说到了第一点：规范化）。其实规范化，也就是信息化。把事物的属性抽象出来列出清单，把操作统一规范好，这样只要懂规则的人只需一点功夫就能把握某件事物，而且丝毫不落下什么。学信息技术，学计算机，给我带来的最大的收获其实就是这个。当我发现这个世界其实无非就是信息的堆叠，这个世界的本质就是信息，而信息所能创造的不仅仅是这个世界，它能创造任意世界，事物。我们生活的这个世界有可能是用计算机模拟出来的，而我们将来也许也有能力模拟出一个复杂的世界，其实某些游戏，譬如minecraft就已经是在模拟我们这个世界了，只是比较简单罢了。现在信息技术越来越发达，各行各业的信息壁垒也越来越高，如果你不懂规则，就无法理解。而信息化思维正是帮助人轻松消化这些规则，打破信息壁垒的。只要你有了信息化思维的习惯，还有大量信息化思维和做事的经验，在这个世界，在各个行业领域都能轻松遨游，游刃有余。譬如写协议，这是件很能锻炼信息化思维的事。写代码，写程序也有此类功效。还有在国家政府机关、法律部门工作也有此类功效。这些事都让你去读懂一个规则，或者创造一个规则，这个过程中各种边角情况（corner cases）都要考虑周全，这跟你写出无bug的程序不是异曲同工之妙吗。</p><p>这里说一下我个人对能力提升的理解，一个人能力的高低完全取决于他的经验。只有经验是成功之母（而非失败），这是我一直以来信奉的观念。失败和成功都只是小插曲罢了，重要的是经验，成功有成功的经验，失败有失败的经验。另外，提一下我对人生的一点理解，人生由什么决定，很多人说由自己决定，也对，也不对，不对的地方是什么呢。人生下来其实就不是由自己决定的，什么样的环境造就什么样的人，当然同样的环境可能产出不同的结果，但不同的结果也是这个环境所造就出来的，这点我们谁也不能否认。所以环境是人生最重要的一个东西。</p><blockquote><p>我这是典型的外倾直觉，关于人的性格分析，有不少的模型，典型的有MBTI，参考：<a href="https://zh.wikipedia.org/wiki/%E9%82%81%E7%88%BE%E6%96%AF-%E5%B8%83%E9%87%8C%E6%A0%BC%E6%96%AF%E6%80%A7%E6%A0%BC%E5%88%86%E9%A1%9E%E6%B3%95" target="_blank" rel="noopener">迈尔斯-布里格斯性格分类法</a>。事实上内倾直觉的人会认为自己是不会被环境所改变的，他们倾向于不断的去探寻自我，发现本我，并坚持自己的内心。就像硬币的两面，当你开始重视到环境的时候，就是外倾直觉，而对觉得无论怎样的环境都差不多的时候，不影响到自己的时候，就是内倾直觉。从这个角度看，这两种型格是各有利弊的，外倾直觉的人更容易因环境而改变，但这种改变有好有坏。</p></blockquote><p>微观上有人想用量子的瞬间位置和速度来模拟这个世界，这样就能确定世界的下一个状态，但是量子力学中量子的速度和位置是不能同时确定的，只能确定其一，这个世界宏观上是连续的，微观上是离散的不连续的，连空间都有最小的普朗克常量。宏观上的连续是微观的不连续堆叠起来的，这一点跟计算机不能无限精确的表示一个无限不循环小数有异曲同工之妙，所以我们世界有可能是计算机模拟出来的因为这种相同的不连续性。学过多媒体之后，对于模拟数据和数字数据我有了更深的理解，数字化精确到一定程度可以取代模拟量！用人的感官更加容易实现这个，譬如视网膜屏的分辨率，其实像素点是不连续的，是有穷的，数字的，但在我们眼里是连续的，无穷的，模拟的。</p><h2 id="环境决定一个人"><a class="header-anchor" href="#环境决定一个人"> </a>环境决定一个人</h2><p>虽然人各有决定，意外时常发生，但是这并不代表环境不重要，相反环境相当重要，因为不定性是有概率的，而环境是确定的，你不能过分指望在同样一个环境里产生跟别人不一样的决定（就像理论上你能用量子态穿过一堵墙，但那个概率就实在太低了），特别是从一出生以来，那时候人带的基本是人的自然反应和决定。而现在的你的状态也和这一路走来你的环境有着莫大的关系（基本是一个确定态），什么样的环境造就什么样的人，这并不是一句空话。记得以前看过一个真实故事（不信可以自己去观察）：几个背景不同的年轻人去同样一家公司实习，经理通过观察就能判断他们父母是做什么的（因为父母对人的影响很大）。你看这里只是选取了环境的主要因素就已经基本给一个人定型了。而回顾我自己，我也是大为吃惊，自己的性格，自己现在的状态都可以从以前的环境找到原因，就像一种无形的束缚和枷锁。</p><p>我现在正在努力根据我以前的家庭环境来核对自己的性格，并努力向不同环境背景的人学习，比如由公务员家庭所继承下来的做事谨慎，妥当的性格。我也努力改善自己的环境，因为在合适的环境中能迅速培养这种环境所产生的性格习惯，而对抗环境去形成相反的性格习惯是特别困难和低效的。有句名言叫：出淤泥而不染。其实这描述的是一种特殊的现象，大部分人是应验了这句：近朱者赤近墨者黑。而我现在深知这其中的道理，我也知道我并不能做到出淤泥而不染，那还是去改变或者选择自己想要的环境吧，那样离自己的梦想更近一些。</p><p>人生就像一场游戏，在这场游戏里你不能决定你的出生，而出生其实反而是最重要的，在一个没有女权的地方，女孩子生活的有多不容易，而如果你出生就是奴隶，这又会是怎样的一生。出生在山沟沟里的孩子，很可能永远看不到城里孩子的世界。很多人说视野决定人生的高低，我上面也说了经验是成功之母。其实这些都可以归为一句话来讲，环境决定一个人。我很庆幸在这么年轻的时候就深刻认识到了这个定理。（虽然很多人都知道这一点，但如同知识你学了不一定会用一样，其实是没有用的，你不能在绝大多数该用到这个知识的时候都能想起这个）。但是出生这种环境是不能改变的，我们也不能消极的看待这一点。相反在认识到这一点后我变得更加积极了，我知道哪些是能改变的，哪些是不能改变的。那么就努力去改变我们能改变的。</p><p>在这个信息时代，人的视野更加开阔了，以前信息不发达的时候你最大的梦想很可能就是像村里王大爷一样，家里20多亩地，几十头猪牛，但现在我们可以看到更远的事物，人的现实处境和梦想的沟壑变的更大了（人的梦想总是跟最大欲望有关，最大欲望又局限于视野之内），这是一件好事，但也是个不幸的事，当我们发现原来还有人活的那么潇洒那么漂亮，而我们可以成为跟他们一样的人，拥有一样漂亮的人生，但却要为此付出无比艰辛的努力，有很多人选择了放弃，选择了自我安慰和自我麻醉，到生命的尽头时才后悔不已。人生而为了梦想。困难，险阻，恐惧这些虽然难克服，但是如果真的一辈子这么龟缩着在自己的角落里真的有意思吗，每当我有困难的时候，每当我恐惧不已，惴惴不安的时候，都应该用这句话激励自己，“如果真的一辈子这么龟缩着在自己的一片小角落里真的有意思吗！！”。</p><p>当然不要因此学会去抱怨环境，环境能改变就改变，不能改变就要靠自己努力去改变，人有主观能动性。</p><h3 id="心理学的一点小分析"><a class="header-anchor" href="#心理学的一点小分析"> </a>心理学的一点小分析</h3><p>所有的过度改变都是痛苦的，这是人的天性。一尘不变和太过简单是无趣的，一点点改变是有趣的，稍强一点的改变是累人的，过度的改变就是痛苦的了。当一个学渣励志要变成学霸，从原来的睡到中午12点到现在的早上6点起床，这是极为痛苦的。当一个学渣要去学一些虽然不是很难，对什么都不会，没有基础的他而言，很难的东西，他是痛苦的。而要克服这两类痛苦（改变的痛苦和复杂的痛苦）主要靠习惯和方法，当你是高三学生的时候，你不会觉得高三很辛苦（人的忍耐，甚至人的所有情感都是有弹性的，不是个定值），反而觉得自己不够努力。而到了大学再要你像高三那样高强度的学习，你会觉得痛苦不堪。学霸并不觉得自己的生活很苦，他们觉得轻松自在，理所当然。这都是因为习惯了，习惯可以减轻很多负担。当你例行公事的去刷牙洗脸，你一点都不觉的难，人的习惯是人最大的助手。习惯一养成，一切都OK。当这种习惯一尘不变时可以稍作改变，变为有趣，例子：刷牙买新牙膏。习惯的养成刚开始都是痛苦的，巨大的改变所带来的痛苦要挺过去。长痛不如短痛，这是对付改变的痛苦的方法。对付复杂带来的痛苦的方法更简单，把复杂程度降到一点点的时候，痛苦变为有趣。这里我还写了点有关学习方法的建议：<a href="../../../01/02/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93">学习方法总结</a>。</p><p>最后附上我喜欢的一张壁纸，愿每个人都如这个月夜攀登者一样执着和无畏：</p><p><img src="https://upload-images.jianshu.io/upload_images/3690260-23096abf961e2cfb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="月夜攀登者"></p><h2 id="曾今的思考笔记"><a class="header-anchor" href="#曾今的思考笔记"> </a>曾今的思考笔记</h2><h3 id="人生的动与静"><a class="header-anchor" href="#人生的动与静"> </a>人生的动与静</h3><p>本来很早就想写这个话题了，这个想法是我在逛长沙市博物馆看画展的时候想到的，现在我连那个画家叫什么名字都忘了，但那一天出去走的时候去了很多地方，包括创客展，长沙市一中，烈士公园，等等。看完老先生的画作后我突然有一种感觉，就是人生不应该只呆在一个老地方过完这一辈子，那样当你回想起来的时候，发现每天都过得差不多，也就了无生趣了，生活应该是动态的有活力的，世界那么大，应该出去看看。人生那么长，应该多经历一些有趣的事。记得以前看过一篇文章，是讲什么叫有趣，什么叫舒适，有趣就是复杂，舒适就是简单，过于复杂让人渴望简单，过于简单，人又觉得无趣。所以生活就是在这两者之间取舍。累了就歇着，无聊了就找些稍复杂、有挑战性的事来做。</p><blockquote><p>叔本华的观点是，人生就是在疲惫和无聊中来回摆动。</p></blockquote><p>我的观点是人生在宏观上来看应该是动态的，在微观上是静态的。人需要不断的用新鲜事物来刺激自己，所谓生活每一天都很新鲜，就是这个道理。但过于奔波劳累，就又让人心生疲惫和厌倦。所以在动的过程中，也要让每一段经历沉下心去，过好那一段。这种感觉是很美好的。<br>每次出去走走，头脑都会清新好多，好像突然跳出了原来那个时空，以一种更宽广的视野看待现在的自己，人生的轨迹，想做的事仿佛又清晰了一些。所以要不时的出去走走，或者换一换环境，不要呆在寝室，一天下来只干了一堆琐事。</p><p>明白自己真正想要什么，然后动手去做。人生才会精彩。</p><p>参差多态乃幸福本源。去经历一些新奇的事，有趣的事。不要每天都一成不变。</p><h3 id="少收藏-多消化"><a class="header-anchor" href="#少收藏-多消化"> </a>少收藏，多消化</h3><p>这个世界上所有的东西都是有生命周期的（有寿命的），那些好用的工具，美好的东西也是如此。<br>今天清理了一下手机，又想起了umano（一款英语新闻听书软件，由专业的播讲人讲述新闻时事，附带新闻稿，曾经是我用来练习泛听的最爱），突然感悟到这世界上所有的东西都是有自己的期限的。以前也想过这个问题，就是要趁着那些美好的事物还在的时候去好好体验一下，见证他们的存在，王小波说希望这一生经历一些有趣的事，懂得一些道理。我觉得很对。但是反过来，既然所有的东西都是有寿命的，那么我现在手机上用的这些应用，这些工具也许有一天也终将没落。有太多的例子了，天涯，猫扑，衰败何其快，这个世界发展的太快了。微信也是才出不久就如日中天了。我应该好好去利用这些工具，但同时又不被他们绑架。</p><blockquote><p>现在的知乎也变味了（2018-11-02）</p></blockquote><p>不要在收着藏着了，那不是你自己的东西，也不会成为你自己的东西。我曾今非常喜欢在用chrome浏览网页的时候收藏网页，随着时间的推移我收藏的网页变得越来越多，心理负担也变得越来越重，我不断的想花个时间去给我的书签分个类，我后来确实做到了，为了尽可能的细分管理，分了很多类别。但总有感觉不对劲的地方，最终我放弃了书签，而是改用搜索，最开始的理由是为了锻炼自己的搜索能力（因为我觉得曾今找到过一次的网页，今后也应该有能力找到才对），后来我渐渐明白收藏癖对自己的压力有多大，尤其是你心里总是惦记着自己的收藏夹的时候，不是你的终究不是你的，收藏了不看和没收藏实际上是一样的，但留在那里却给自己造成了无形的压力，注重消化和吸收，并做好记录和总结吧。</p><h3 id="积极的人生态度"><a class="header-anchor" href="#积极的人生态度"> </a>积极的人生态度</h3><p>在这里我要强调，若想人生过得精彩，过得开心，一定要培养一种积极的人生态度。毛泽东就是一个典型的例子，豪气冲天，自信积极，人生无比精彩，会当击水三千里，自信人生二百年。这不是我以前所向往的生活吗？对，生活理当如此，一个人怎么能苟且的活着，那样还有什么意思呢。消极是失意人生之源。想想七龙珠里面的热血，火影，海贼王，莫不是有梦想之人的奋斗史。曾今的少年就真的被打败了吗，就真的甘于被生活和现实打败了吗，那这样下去接下来的人生可还有什么意义可言，无梦想，无热血，无积极的生活态度，可以去死矣。自卑是一种傻逼的生活方式，想想曾今电影王牌大贱谍2中的奥斯汀，人长得丑，矮，那又怎样，看看他的人生多精彩。人生唯爱情和美食不可辜负。爱情和美食你都经历过吗。<br>人生只有血凉与热的区别。火苗再小，也要反复点燃。</p><blockquote><p>我现在觉得热血并不完全可取，很多时候热血是伴随着一时的冲动，一般很难维持。而我们真正需要的是一种持续努力的状态，因为任何事都不是一蹴而就的。而这种持续努力的状态无关热血，是一种习以为常的生活态度，我记得我曾今拥有过，在高一的时候，那时候事事想着做最好的自己，把生活当成一个新鲜的旅程。那时候最喜欢的电视剧就是仙剑1了，最喜欢的歌是杀破狼，虽然没有看完，但我觉得正是因为没看完，对于后面的剧情不甚了解，所以充满希望和期待，生活也理应如此，上进和新鲜劲理应是一种生活态度。（2018-11-02）</p></blockquote><h3 id="做好规划"><a class="header-anchor" href="#做好规划"> </a>做好规划</h3><p>今天晚上7点去参加深圳双选会，看宣传片的时候突然脑子里蹦出一个念头，而且感觉越来越强烈。一个人究竟能走多远？我曾今以为自己能走很远，走到天涯海角， 既去做研究，当教授，又去赚大钱，做老板，所有美好的事全都在我身上。可是现在呢？呵呵，现在的处境离想象实在太远了。现在连找工作都是个问题。我们都知道企业做项目要有规划，一个国家发展要有规划，很多事都要有规划，而且越重要的事规划就越是严密，漏洞很少，并且都一一实现了。人生这么重要的一趟旅程又怎能随波逐流呢？很多人说随心随性，到头来这旅程又真的是你想要的吗？大多数人都是被生活推着走，没有人生规划的人更是如行尸走肉，如随风飘荡的落叶不知去向何方。年轻时的壮志，梦想，或者幻想，最终都一一破灭，成为遥不可及的东西。回头看我的人生轨迹，可以说我自己从来没有规划过，小的时候基本上是父母，社会，学校在规划我的轨迹，现在到了大学，自己有了能力和权力规划自己的人生（其实小的时候就可以规划，可惜没有这种意识，就算是大学的前三年，也不依旧没这意识吗）。想追求什么，可能我现在还不明白自己真的想追求什么，我一无所长，没有热爱。想追求什么也并不是想想就可以实现的，必须对此作出规划，才知道原来人生，原来生命并不是有无限可能，无限可能说出来都是骗人的。当你真的着手去规划，你才发现，要达到目的是要付出多大的努力，耗费多大的时间。而人生区区几十年，又能完成多少你所想的壮志和梦想呢。恐怕不多。这提醒我们，再不规划，再随风飘荡，恐怕连一件想要做的事也完不成，人生留下的将尽是无奈和事与愿违。比如一件小事，复习操作系统，你是直接就开始拿起课本复习，还是有规划的复习。没有规划，你知道自己几时能看完吗？你知道自己能在多长时间内看到多少程度吗？恐怕到最后要花很长时间，但是你当初没想到，恐怕你没有计划地想什么时候看两眼就看两眼，不想看就扔一边，最后只看了一点点就放弃了。这就是随性的最可怕的地方。你根本没有去预计自己会到达什么地方，你的预算能力将变得很弱，你的生活和人生将失去控制不由你主宰。看了人生7年the up series，才知道人生何其短暂，要达成自己梦想的成就根本没多少时间可以用。如果不从现在开始规划，7年后的你是什么样子呢。</p><p>规划的关注点不应该是自己的时间，而应该是具体的任务，对于许多长期目标来说，花多少时间去做事不重要，做完你要做的事才重要，做的不好不要紧，坚持去做。</p><blockquote><p>我现在觉得规划应该只是一个大方向，不用具体到特别细的细节，特别细的计划也不用把每天的时间都塞满。真正需要做的应该是集中自己的发展方向，就像玩炉石传说一样，有职业之分，有搭配很好的卡组套路，在玩冒险模式的时候，技能点和卡组的选择要沿着一个方向纵深发展，卡牌之间相辅相成，如果散漫的乱选一些无关的卡组，什么都想要最终往往什么都得不到。我们在现实生活中的职业和人生发展也是如此，就和猴子下山一个道理，什么都想要往往什么都得不到，而且你是很难同时深入学习多个东西的，如果真的想拥有多个技能，也应该是一个一个深入学习，<strong>因为只有深入才不会容易丢掉</strong>，随便学学，分散精力是最容易遗忘的。（2018-11-02）</p></blockquote><h3 id="注意自己的性格"><a class="header-anchor" href="#注意自己的性格"> </a>注意自己的性格</h3><p>今天中午2点去华为笔试，做了一个性格测试，这是我第一次认认真真做性格测试，我突然发现自己的性格很有问题，于我对自己的的期望，幻想中的自己区别很大。可以肯定的说，以我目前的性格，恐怕无法实现我的梦想，让自己的能力和地位达到想象中的高度。如果我想要做一个领导，我需要哪些品质，又需要怎样去培养？如果我要让自己更受欢迎，我需要哪些品质，又需要怎样去培养？这些都是很重要的问题，平时如果不注意，对自己的梦想只是想想罢了，那到时候就会发现自己也真的只是想想罢了。有句话很经典，播种一种思想，收获一种行为，播种一种行为，收获一种习惯，播种一种习惯，收获一种性格，播种一种性格，收获一种人生。性格决定一个人的行为，而行为习惯又在巩固性格，或者形成性格。性格决定人的取舍和行为方式的例子屡见不鲜。性格将决定一个人的命运。但这也是个顽固的东西，很难改变，需要坚持。我觉得自己应该多问问自己今天做的这类性格测试中的问题，这些都是一个人的基本性格，世界观和价值取向，一个人灵魂的体现。我发现自己的性格很差，基本像一张白纸，没有自己的主张，有的全是懦弱，老好人，这跟我从小的经历有关。关于性格的培养，今后要有详细的规划才行。</p><h2 id="你的迷茫值得吗？"><a class="header-anchor" href="#你的迷茫值得吗？"> </a>你的迷茫值得吗？</h2><p>我们都想让自己的人生达到最优解，对此我推荐贪心算法（动态规划不可取，因为你无法归因，人生是向前的，你无法回到过去重来），我相信只要人生的每个阶段都最优化，整个人生的解一定不会差（相反，你如果每个阶段都混得很差，怎么指望活出人生的最优）。</p><p>这是我学生时期写的一篇关于怎么找准努力方向，走对正确的路，以及高效的学习和进步的一点思考。当时我正为自己的专业学的不好而感到恐慌和自卑，为自己遇到各种不懂的问题而不得解感到烦躁，继而封闭自己，企图逃避。高中到大学的跨越始终太大，有些人四年之中一直是迷茫的，这种深深的不适是教育体制造成的，但是这种改变也是必要的，因为你的人生你要自己负责，带你高三的老师班主任不会为这负责，不要被桎梏久了就忘了外面精彩的世界和自由的人生。</p><p>从被动到主动，也许只需要一个观念的转变，也许对于许多人来说却是千折百回、痛苦煎熬。愿你不要再做一个被动的人。</p><h3 id="学习不难-合适的路径获得难"><a class="header-anchor" href="#学习不难-合适的路径获得难"> </a>学习不难，合适的路径获得难</h3><p>有时候是教材没有讲得浅显易懂，有时候是自己没有潜心去看。还有时候是根本没有教材，也就是根本没有人带，苦苦摸索耗费你巨大精力，有种要死的感觉（深深的无力感往往伴随着最深的绝望），大学的学习难于高中大概也是这种感觉（在上大学之前所有的知识都是老师一口一口喂的，大学里我所有的专业知识都是自学的，老师无异于一个摆设）。其实这个道理十分广泛，可以改成前进不难，找对路子难。关于学习方法，可以参考我这篇：<a href="../../../01/02/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93">学习方法总结</a></p><p>最近一直感慨没有前人带路，走得步履维艰，回头看看自己走过的路。最后悔的莫过于没有参加ACM，没有任何竞赛，也没有奖学金，还有很多原本能做到的东西都没有去做。没有人提醒自己，教自己，不管是技术上的还是生活规划等等。我知道是自己以前都被别人规划好了，小的时候有家人带路，九年义务教育的时候有老师带路，何况我妈还是我小学老师呢，使得我从小备受关注和照顾。现在才发现以前的那种生活状态才是不合理的，现在过的是生活的本质的样子。想要回头看的时候不那么后悔一定要得到全局视角，要跳出来看。去主动争取，去联系前辈们，去获得过来人的建议和第三视角的指导，不要把自己框在现时现地，当然也不能只听一家之言，要有足够多的样本，然后应对现在，应对未来。</p><h3 id="意识很重要"><a class="header-anchor" href="#意识很重要"> </a>意识很重要</h3><p>自己终于意识到了，摸着石头过河是愚蠢的，是不必要的，前人早就有了经验，这条路并不是新的。但是生活中又有多少的东西是我还没有意识到的呢？突然有点恐慌。仔细思考一下，发现。其实意识不到是很正常的，你没有处于那个环境之下，没有经历和经验，始终是意识不到的。换句话说，意识不能凭空产生。要么自己经历了，要么别人经历了，然后告诉你，然后你获得了新的思考，恍然大悟，如获新生。 对的，意识不能凭空产生。那么节省时间的方法就是，去跟别人交流吧，去获得别人的经历和经验。去不断增强自己的见识，拓宽自己的视野。意识，思考，思想会源源不断的产生。 把自己闷在自己的思考里，并不能获得多少新的东西。</p><h3 id="不要想当然-事情可能根本不是这样"><a class="header-anchor" href="#不要想当然-事情可能根本不是这样"> </a>不要想当然，事情可能根本不是这样</h3><p>高中的时候以为成绩最重要，到了大学也继续这样认为，直到被现实打破，才知道了能力很重要（如果你在985大学，建议还是一定要刷好绩点，因为可以保研，而且还是保到很不错的学校，我自己就认为不注重成绩是我大学里做的最失败的一件事，因为相对考研来讲，平时的考试要拿高分确实简单不少）。可能到了工作中，我们还一直奉行能力很重要这一条，但是现实又会告诉我们关系很重要。可能我们觉得现在可以单身，不谈恋爱，到了工作后一定年纪觉得当时自己真的傻透了。就这样我们一直想当然，自以为是。现实会粉碎你的想当然，让你痛苦万分，后悔不已。可以大胆猜测，但是不要默默地就把它当成真理。 还是前面说的，我们应该去问问经历过的人，做大量数据统计分析。然后才能得出合乎事实的东西。补充：（大学里成绩同样很重要，保研和奖学金都靠成绩，即使考试很水，但判断学生的基本条件是成绩，而且认真的态度在哪都是最重要的，态度决定高度。我相信很多人身边都有这种人，他们就是凭着一股认真的劲儿，大学生活才如此丰富多彩。另外能力确实很重要，在中国并不是有关系就行。工作看的是业绩，那么能力就是重要的。可以说学习是学生的天职，那么成绩就是重要的，读研可能就是研究水平，就是发的paper的多少了，这些都是简单的就可以推理出来的，并不是想当然。而大学谈恋爱确实不怎么好，因为可能根本找不到我喜欢的女孩子也喜欢我的情况，将就只会让自己更加不快乐。要谈恋爱首先得正确的认识自己，然后看看自己的眼光和自己的水平是否匹配，眼光高水平低那就注孤生啊。）</p><h3 id="获得局外视角的途径"><a class="header-anchor" href="#获得局外视角的途径"> </a>获得局外视角的途径</h3><p>前面讲的三条都指向同一点：不要闭门造车，要找前辈，获得局外视角。所谓当局者迷，旁观者清。所谓经历过了才懂得。所以接下来我记下怎样去找。</p><p>找导师，导师再介绍师兄师姐。<br>进论坛，找工作多年的前辈。（因为即将步入工作，可以问问工作中什么最重要，怎样让这个最重要的方面成为自己的强项）<br>搜索各种群，进群找工作经验丰富的前辈。<br>这里补充一句，现在的话，学计算机专业的同学可以找我啊，我们可以一起进步，共同成长，人类一直都是以共同话题和爱好而相聚在一起的，我相信未来的互联网的社区化会越来越成熟。</p><h2 id="信息时代的一点思考"><a class="header-anchor" href="#信息时代的一点思考"> </a>信息时代的一点思考</h2><p>这个时代的最大特征就是信息爆炸，人类每天面临着海量的信息，但有多少是有用的呢，这还真不敢恭维，其实有意义的东西就那么多，人类所有的智慧加起来也就那么多，学个大部分完全是可以的。所以面对信息爆炸最好的方法就是不要去接触那些杂七杂八的信息，而是转过头去学习最本质的人类智慧，看看新闻可以、一些基本的娱乐常识可以了解，但没必要懂那么多，只要算个融入社会的现代人就行了，网上流行的东西更迭那么快，没必要主动去接触，被动的去接受就行了，只要你处在那个环境中，只要一件事很火，你自然而然就从身边的人那里得知了，而且这些都是没有价值的信息，只是为了塑造一种圈内认同感，就是我们都是现代社会互联网八卦这个圈内的人。要学习、要搜索，主动去接触有价值的信息，规避泛滥的没有价值的信息。 比如各种广告，软文，比如打开有道词典各种推荐，千万不要点进去啊，比如知乎各种垃圾提问，粗浅的回答，抖机灵的回答，大部分其实也都是些无意义的信息，比如QQ聊天其实都挺没意义的。只要自己往前，不要回头（志同道合的可以稍微聊聊）。什么破公众号其实也没啥意思。这么看来我以前自我提升那么慢，进步那么慢，甚至退步，这些的最根本原因就在于被信息爆炸炸到了，被很多无意义的信息淹没了，感觉每天都很忙，其实都在浪费时间，都在消耗自己，都在做没有价值的事。幸好现在终于幡然醒悟。好好把新概念英语看的滚瓜烂熟，不要看知乎了，想学人生经验，心理学，哲学，经济学，法律，摄影等等，完全应该主动的去学，而不是被动的去每天刷知乎，这种学法完全错误，也就是说知乎是用来搜的，不是用来每天被动接受信息的。可以按领域和话题搜索学习，也可以按人来学习，比如大V，肥肥猫，轮子哥，公众号罗辑思维可以听，因为这是聚合信息，王小波全集可以看，这两个都是按人来划分学习的。所以要么按话题领域，要么按人，来进行有效学习。少听点歌，多学点乐理。少看点电视剧，多学点写故事，小说。即有目的地做事，而不是无目的的消遣。即便再好的材料，你囫囵吞枣能尝出什么味道出来，你只是消遣能学到什么，看完了什么收获都没有那跟没看有什么区别呢？不要消遣和漫不经心啊，人必须要成长，提升，否则虚耗光阴，人生也就平淡无奇。信息爆炸带来的后果，就是无意义的信息大大增加，占信息总比越来越大，新出的游戏层出不穷，新出的影视剧层出不穷，新出的小说层出不穷，新出的音乐层出不穷，人们的时间正在越来越多的被这些东西夺取，游戏无非是一些逻辑加循环，循环多一点，故事也无非是一些逻辑加循环，循环少一点，背后的原理才是有意义的信息，而故事和游戏本身并不是那么重要，因为它们本身都是千千万万，根本看不完。现代社会有一个词应用而生：娱乐至死，这其实是信息爆炸带来的结果之一，也是人类生产力提高的后果，越来越多的工作交给了机器和自然能源，人空闲下来就开始找乐子，娱乐的东西现在每天充斥着我们的生活，刺激着我们的神经，而且虚拟的东西制作的越来越好，我们就用虚拟的东西去完成自己的梦想，但虚拟的始终是虚拟的。</p><p>伴随着信息爆炸，应该要更好的信息处理技术，处理海量数据，要更好的交互技术，来帮助人机之间无障碍的沟通，最后完全可以做到记录人们每天的所有信息，所有想法。</p>]]></content>
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Macbook</title>
      <link href="/blog/2017/02/03/Macbook/"/>
      <url>/blog/2017/02/03/Macbook/</url>
      <content type="html"><![CDATA[<p>好的工具可以使人事半功倍，回顾整个人类史，又何尝不是一个工具史呢，从用石器到用火，从铁器到火药，从蒸汽机到内燃机，从汽车到电脑，我们在使用工具、利用自然规律，从而让自身变得越来越强大。</p><h2 id="为什么推荐-macbook"><a class="header-anchor" href="#为什么推荐-macbook"> </a>为什么推荐 Macbook</h2><p>我使用macbook pro 15 retina 已经一年了，感觉非常好（之前用过惠普的一个笔记本，加过内存条，折腾过固态硬盘，但最后还是受不了那风扇呼呼转）。现在我手头上同时还有一个surface pro 4 m3，M3也就是不带风扇的那款，性能一般，当初买是为了那支笔，能在电脑上写写画画，结果现在买了之后很少用这个surface，但是转手卖了又觉得亏本了，可惜，只好留在家里，留着以后做古董吧。</p><p>mac机器的亮点：</p><ul><li>轻薄</li><li>另外触摸板真的很好用，我已经很久没用过鼠标了</li><li>retina屏也是非常养眼</li><li>立体声也十分不错</li><li>细节做得很好，充电口是磁性的，正反两面都能充，指示灯是能显示是否充满的（用过surface pro 4 的对比一下就知道，什么叫做细心），键盘背光，铝制机身，最后外观简洁美观。</li></ul><p>OS X的最大亮点：</p><ul><li>GUI(Graphical User Interface，图形用户界面)和CLI(Command-Line Interface，命令行界面)的完美结合</li><li>优化的很好，系统耗电少。</li><li>开机速度非常快，另外不用老是关机，我很多时候一个星期都不关机。</li></ul><p>缺点：</p><ol><li>冬天用MacBook寒气逼人啊，把手放上面就知道了（南方，没有暖气，一般也不怎么开空调）</li></ol><p>可以说这是一个不错的工具，无论是对普通用户来说，还是对程序员来说。最大的缺点无疑是：太贵啦。</p><p>所谓一分价钱一分货，3份价钱5分货，10分价钱7分货。意思就是，太便宜的东西往往质量很低，不便宜又不贵的往往性价比很高，特别贵的虽然确实质量非常好，但性价比却低了。</p><p>我秉承的一个观点是，如果一样东西属于易耗品，如：袜子，内衣裤。我们就应该买性价比高的，大众一点的，我还记得有一次傻逼的去优衣库买了双14块钱的船袜，结果穿了一次就起球了，气得要死啊，还不如买便宜的。如果是非易耗品，如：笔记本电脑，手机，西装，皮鞋，钱包，背包等等。我们就应该在能承担的价格内，尽可能的买质量好的（尤其是你注重这个东西的品质的时候）。我特别注重电脑和手机的流畅性，所以我选择了Macbook pro 和 iphone，我打算至少用个5、6年吧（现在的电子设备产品迭代这么快，能用5、6年真的相当不错了）。另外我的双肩背包一定会买非常结实的帆布的款式（而且功能要多），我现在这个背包就背了3年多了，看起来有点旧，但仍然很好用（有考虑换新的双肩背包了，但是还没找到满意的，这种东西还是不能随便买，就跟你闲置在柜子里的衣服一样，买了不喜欢，不穿，浪费钱，而且通常我们只有一个背包，这就更要精挑细选了）。</p><p>好了接下来就开始推荐MacBook的软件了：</p><h2 id="软件列表"><a class="header-anchor" href="#软件列表"> </a>软件列表</h2><h3 id="国内的常用娱乐软件"><a class="header-anchor" href="#国内的常用娱乐软件"> </a>国内的常用娱乐软件</h3><ul><li>Mac QQ，社交</li><li>网易云音乐，真的做的不是一般好，相比于其他的什么酷狗、多米。网易云音乐还有Linux版哦，UWP版（Universal Windows Platform）做的也很不错。这里要批评一下网易云音乐，Mac 版的分享是没办法给其他社交网络上的好友贴链接的（连 Linux 版都有的功能），我每次想分享出去都要打开 Chrome 使用网页版的网易云音乐，那我要你客户端干啥？已经提了 issue，看看网易云音乐的 Mac 工作组能不能加上这个功能吧，对程序员来说这就是顺手的事，做产品关键还是要用心啊。</li><li>新浪微博，这个我很少用，微博也刷的少，于是就卸载了，等以后学会高效使用新浪微博了估计会装一个。</li><li>百度云，比起Windows版的不知道难用到哪里去了，好在一直在进步。</li><li>迅雷，没有广告，比Windows的迅雷爽多了，每次打开Windows的迅雷9都有种想哭的感觉，各种广告视频自动播放，好抢眼啊。</li><li>leanote（蚂蚁笔记），现在的笔记软件都开始收费了，如：印象笔记、为知笔记，还有这个蚂蚁笔记也收费了。庆幸的是我现在不写笔记了，我写博客，热衷分享，帮助新人，提高声望。</li><li>为知笔记，为知笔记总体来说是最棒的，现在也收费了，但也阻止不了我用它。</li><li>有道词典</li><li>优酷客户端</li><li>爱奇艺客户端，亲们，这两个客户端放视频没有广告！！！，真是太赞了。</li><li>腾讯视频客户端，这个是新出的，同样没有广告，还可以看蓝光</li><li>阿里旺旺</li><li>每日英语听力</li></ul><p>MacBook进阶软件：</p><ul><li>homebrew/brew cask（mac的软件源，让你可以像玩linux一样，用命令安装软件）</li><li>Chrome，Chrome和Firefox，最经典也是最好用的两个浏览器。不过在MacBook上，safari的性能确实比chrome要好，另外safari可以强制使用HTML5播放视频哦，这样MacBook在看视频的时候就不会发热啦。</li><li>Atom，github推出的指定码农编辑器，MacBook上很好用，Windows上开启有点慢。（温馨提示，码字的时候，开着markdown previewer，打字会很卡，刚开始的时候我差点因为这个莫名的卡顿，而放弃Atom了，后来找到了原因😄）</li><li>calibre，可以看各种电子书，转格式</li><li>LICEcap，使用gif格式录制你鼠标的操作。</li><li>Pocket，把文章收藏起来慢慢看的一个软件</li><li>iStat Menus，显示电脑的各种硬件状态</li><li>TeamViewer，跟QQ远程桌面控制类似，不过这个更专业。</li><li>Blu-ray Player，蓝光视频播放器，要收费，付不起钱只好在每次打开的时候把注册窗口叉掉。</li><li>Irvue，更换壁纸软件</li><li>Sip，取像素点的颜色软件</li><li>VMware Fusion，MacBook专用虚拟机</li><li>The unarchiver，解压缩软件</li><li>Keka，压缩和解压缩软件</li><li>OmniDiskSweeper，查找大文件</li><li>Bartender 2，把MacBook的顶层工具栏里的图标藏起来</li><li>Bartender 2效果截图</li></ul><p><img src="http://wx2.sinaimg.cn/mw690/006zFO3ggy1fcd4m7je0qj31kw0zk4ax.jpg" alt="Bartender 2效果截图"></p><p>程序员往这里看：</p><ul><li>Xcode，相当于Windows上的Visual Studio吧，主要用来开发苹果平台上的软件，平常可以用来写写C/C++</li><li>iTerm2，超好用的终端软件</li><li>oh-my-zsh，超好用的shell</li><li>dash，文档，内容相当丰富，连LaTeX和markdown的文档都有，不过有时候要等7秒钟才让你看文档。</li><li>FileZilla，FTP利器</li><li>github desktop，git的桌面版，很少用，程序员还是多用命令行吧，要不然让你搞Linux服务器，记不起git命令就显得low逼了。</li><li>Pycharm，jetbrains家的IDE个个都好用，这个是用来写Python的</li><li>Intellj IDEA，jetbrains家的IDE个个都好用，这个是用来写Java的</li><li>Android Studio，jetbrains家的IDE个个都好用，这个是用来写Android的</li><li>RubyMine，jetbrains家的IDE个个都好用，这个是用来写ruby的</li><li>CLion，jetbrains家的IDE个个都好用，这个是用来写C、C++的</li><li>jetbrains家的IDE</li></ul><p><img src="http://wx2.sinaimg.cn/mw690/006zFO3ggy1fcd4vbx60yj31kw0zkqez.jpg" alt="jetbrains家的IDE"></p><p>如何顺利的从Windows使用习惯迁移到macbook使用习惯，我写了一篇文章：<a href="../2017/01/01/%E4%BB%8Ewindows%E8%BD%AC%E7%94%A8macOSX%E8%AE%B0%E5%BD%95">从 Windows 转用 Mac OS X 记录</a></p><p>另外建议买东西不要贪小便宜，一定要买正版，我的 Macbook 是在淘宝上买的比较便宜的，结果屏幕涂层脱落了，商家也不给赔偿，送苹果 genius bar 查出我的机器不是正版，也不给修。最后换屏（非官方渠道，要1500人民币）</p>]]></content>
      
      <categories>
          
          <category> 数码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>游戏人生--探险者的人生手册</title>
      <link href="/blog/2017/01/26/%E6%B8%B8%E6%88%8F%E4%BA%BA%E7%94%9F--%E6%8E%A2%E9%99%A9%E8%80%85%E7%9A%84%E4%BA%BA%E7%94%9F%E6%89%8B%E5%86%8C/"/>
      <url>/blog/2017/01/26/%E6%B8%B8%E6%88%8F%E4%BA%BA%E7%94%9F--%E6%8E%A2%E9%99%A9%E8%80%85%E7%9A%84%E4%BA%BA%E7%94%9F%E6%89%8B%E5%86%8C/</url>
      <content type="html"><![CDATA[<h2 id="人生没有意义"><a class="header-anchor" href="#人生没有意义"> </a>人生没有意义</h2><p>人喜欢讲意义，但似乎是件很可笑的事情，因为意义是人虚构出来的东西，这个世界上有些东西存在就是存在，不讲道理的存在，没有意义的存在。不信你去问问宇宙存在有什么意义？宇宙之外有没有意义？时间有什么意义？人生又有什么意义？哪怕你想破脑袋也没用。别拿意义去套你的人生了，百年之后终归尘土。就像泰戈尔写的诗：鸟在天空划过，不留下任何痕迹。马克思哲学也说：新事物终将取代旧事物，历史车轮曲折前进。这里是说你会死，就算你不会死又能怎样，永远活下去就能找到人生的意义？嗯，如果能做到同宇宙同岁也许可以，但别瞎想了，在你有生之年都不可能实现。</p><p>没有一个终极意义你会慌乱吗？</p><h2 id="游戏-vs-人生"><a class="header-anchor" href="#游戏-vs-人生"> </a>游戏 vs. 人生</h2><p>人都是喜欢游戏的，人可以进行没有实际奖励的游戏，人甚至可以进行不为输赢的游戏。很奇怪吧，当你小时候和小伙伴玩泥巴，当你打着坦克，玩着超级玛丽，当你打着魔兽、DOTA、英雄联盟，炉石传说，当你在Minecraft、饥荒里面一玩就忘了时间。你想想你到底在干嘛？你有为了某个意义去玩游戏吗？你也许会抱怨，人生为什么这么枯燥，人生为什么不像游戏？</p><ul><li>简单可行</li><li>及时反馈</li><li>无限尝试</li><li>公平竞技</li></ul><p>发现没有，人生跟这四个属性一个都不挨边。 谁的人生是简单可行的？谁的人生是及时反馈的？谁的人生可以无限尝试，不服再来？谁的人生是生活在公平之中？</p><p>一个复杂无比、充满未知的人生，一个慢慢长途、平淡无奇的人生；一个只有一次、甚至其中的很多阶段、很多事都只有一次的人生；一个连公平都做不到无比艰辛的人生。你想不想说一句life is a shit! 同志啊，这句话我早就想说了。</p><p>来来来，对着上面这四条，你仔细想想：</p><ul><li>有多少人一辈子为生计奔走、迷茫、看不见未来、与机会擦肩而过？</li><li>有多少人不停焦虑、制定计划、却不能坚持、始终碌碌无为？</li><li>有多少事错了就不能再重来？</li><li>有多少人，生来就缺乏竞争力？</li></ul><p>想通了吗？想通了就OK，你要是不能忍上面这四条，却依然厚着脸皮说你喜欢人生、热爱生活，我要骂你：真他妈能装逼，真是厚脸皮！那你要说，不然呢？我生下来就已经是这个样了啊，怪我咯！其实你是正确的，如果你还有活着的欲望，没有急着去死，那么你就该热爱你的生活，罗素有句话叫做：只有一种英雄主义，就是在认清生活真相之后，依然热爱生活。因为这是你的生活，你别无选择。</p><p>大学的同学不用再抱怨大学了，不就迷茫了四年嘛，你没发现你其实上大学之前也只是在幻想人生的美事吗？你没发现你上大学之前一直是被安排着忙忙碌碌吗？大学打破了你的美梦，很好，大学让你迷茫，很好，大学让你又闲又焦虑不堪，这更好，大学让你有时间开始思考人生，简直完美！</p><p>其实你忘了，小学的时候你也被老师的抄写课文后的生字词这种作业，弄的死去活来，每讲到新的一课，就从第一课抄到这一课（PS：这就是我真实的童年）。其实你也忘了，上高中的时候，做不完的题，做题做到想吐，从此落下对做题的厌恶感这种奇怪的病根。</p><p>现在我们只关心一点，人生到底还有没有救。</p><p>简单可行？到底是否可以做到？在你学英语的时候，在你健身的时候，在你打工赚钱的时候。很显然这三件事都不简单，你不应该再过多的考虑这种复杂的事情了。生活中当然有简单的事情，只是你看不上它们罢了，或者你觉着它们的意义太低。比如背一篇新概念3的文章，不算太难，如果觉着太难，那就背一段好了，但是你会想一些看起来很合理，实际上很荒唐的事情，你会想：背了又怎样，有什么用呢？或者我知道背了有点小用，坚持下去背很多就更是有大用了，但这太漫长了，没人能坚持下去。这就牵涉到及时反馈了，你急需立竿见影的效果，否则会在一次又一次的考虑中丧失你的动机。</p><p>及时反馈？那你怎么及时反馈？背一篇新概念的文章的一段，对你学好英语的作用就是微乎其微，从这个角度来讲，你需要其他来源的反馈。</p><p>无限尝试是不可能了，但有限的 多次模拟 还是可以的。</p><p>公平竞技也是不可能的，这一点没有办法（很多英语国家的人不用死命学英语啊，长大成人了谁不会说母语？有些人出生就含着金钥匙啊，富二代官二代），我们只能靠自己，你也可以反过来想，起点很低，却靠自己的智慧变得很厉害，是不是更有成就感（强行安慰自己）。</p><h2 id="把人生游戏化的方法"><a class="header-anchor" href="#把人生游戏化的方法"> </a>把人生游戏化的方法</h2><p>从上面的分析可以看出人生非常难以游戏化，但我们不能坐以待毙，下面我来讲讲我自己的一些想法吧。</p><p>我自己是学计算机的，在外行看来，计算机是非常神秘的领域，就像某种魔法一样，事实上即便是我们这种内行，如果不清楚具体的实现过程，那么被抽象封装的部分依然是很神秘的，魔幻的。所以我们不妨把计算机技术当成一种现代魔法，而我们学计算机的都是魔法师，像Linus Torvalds、吴恩达这样的则是大法师。我们人区别于动物的地方是什么呢？</p><ol><li>知识</li><li>合作</li></ol><p>我们能达成上百万人的合作（比如：波音飞机的整个生产过程，有人搞理论，有人设计，有人组装），我们能快速习得知识技能而不用依赖遗传和自然选择。知识+合作=文明。</p><p>怎样变成一个更优秀的人？</p><ol><li>习得更多的知识</li><li>拥有更强的合作技巧和能力</li></ol><p>我们接受教育，不停学习，就是习得更多的知识，我们和人交友，加入公司，获取财富和资本，创业，拉投资，就是拥有更强的合作能力。</p><p>游戏是没有一个确定目的的（很多游戏可以有多种玩法和目的），即便很多游戏有一个终极目标，有一个通关的路径，但游戏的意义却非仅此而已，如果仅有一个最终目标，达成目标之后就变得无趣了。游戏拥有一个有趣的过程，让人沉浸其中。所以你可以给你的人生设定一个伟大的目标，但不要忘了，生活的意义不仅在于此，生活的意义还在于你生活的每一年，每一个月，每一天。</p><p>把事情变得简单可行，就是要分割和量化目标，提供及时反馈就是要量化成果，得到激励。无限尝试，就是要不停模拟实践。公平竞技，算了吧，不谈这个(你可以从比你基础更差的人身上获取安慰，你想啊至少你的出身没有差到那个地步，是吧)。</p>]]></content>
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>百度贴吧ID挖掘机</title>
      <link href="/blog/2017/01/12/%E7%99%BE%E5%BA%A6%E8%B4%B4%E5%90%A7ID%E6%8C%96%E6%8E%98%E6%9C%BA/"/>
      <url>/blog/2017/01/12/%E7%99%BE%E5%BA%A6%E8%B4%B4%E5%90%A7ID%E6%8C%96%E6%8E%98%E6%9C%BA/</url>
      <content type="html"><![CDATA[<p>去年我开了一个minecraft服务器，想拉点人进去玩，就想到要出去打广告啊，怎么办呢，我的好朋友<code>lianera</code>就跟我说，他以前在贴吧里面批量@别人，嗯，这是个不错的方法，他当时还给我看了他写的一个百度贴吧ID挖掘机，但不是用python写的，<a href="https://github.com/lianera/archives/tree/master/tieba-digger" target="_blank" rel="noopener">第一版C语言</a>，<a href="https://github.com/lianera/archives/tree/master/tbot" target="_blank" rel="noopener">第二版java</a>。不过后来这件事没有做成，因为现在百度贴吧禁止批量@了。</p><p>后来我就想学点python，因为据说python代码特别简洁，这对于我这种极简主义者是很有诱惑力的，正所谓 – “人生苦短，我用python”（来源于：life is short, you need python）。另外python爬虫很有名啊，python玩数据很方便啊。数据时代怎么能不玩数据呢！于是我就一门心思想学python（其实还有一个原因，因为xx-net（一款翻墙软件）是用python写的，迟迟不出移动端的，我的手机也要翻墙啊，摔！我打算自己把xx-net移植到ios和安卓上，首先需要读懂代码啊，所以我还是需要学python，但后来lianera找了个便宜的VPS，并搭了shadowsocks服务，我们就一起用他搞的VPS翻墙了。。。）。</p><p>想着不能光看python语法而不做实事，我就重新造这个百度贴吧ID挖掘机轮子了。</p><p>先推荐<a href="https://github.com/liuqinh2s" target="_blank" rel="noopener">我的github</a>欢迎各位follow和指教，（程序员之间多多联系还是有必要的，大家可以讨论技术啊，除了技术还可以聊人生啊，电影啊，抱歉我以前是个文青，文科成绩一直很好，嗯，也爱科学）。</p><p>项目地址：<a href="https://github.com/liuqinh2s/Python" target="_blank" rel="noopener">https://github.com/liuqinh2s/Python</a></p><p>一开始我是用python2，然后想着python3才是未来，然后就想改点代码就升级了呗，但是python2和python3真的是有点不一样，改得有点蛋疼，不过最后还是弄好了。</p><p>代码写的不好的地方请指出来哈。</p><p>下面我讲讲思路：</p><ol><li>首先定义了一个BaiDuTieBa类，用来获取HTML源代码，然后用正则表达式匹配抽取出用户ID，然后我用了一个全局的dict变量存放ID，最后把dict中的ID全部写入文件就可以啦。其中必不可少的要用到urllib库，re（regex, regular expression，正则表达式）库。</li><li>然后我就想啊，单线程爬的这么慢简直不能忍，于是就搞个多线程吧，至少把我的网速和带宽占的满满的。这里我使用了任务队列和线程池，简单讲就是把任务都放进任务队列里面，然后线程放线程池里面，线程呢不断的去取任务，做完一个取一个，直到任务队列为空。线程池代码是从网上借鉴来的，管他呢自己改改能用就OK。这里用了threading库，queue库。</li></ol><p>然后爬的时候，你看看自己的网络，反正我的是瞬间飙升到几兆每秒了。</p><p>代码很初级，关键的地方都有注释哦，看不懂的地方私信我，我会在文章最后贴出常见的问题，并详细讲解。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">    这是python3版本的，看文件名，TieBaID3.py，这个3啊就是python3，懂了伐。</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">__author__ = <span class="string">'liuqin'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line">IDdict = &#123;&#125;</span><br><span class="line"><span class="comment">#百度贴吧爬取用户ID，以minecraft吧为例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaiDuTieBa</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, kw, pn)</span>:</span></span><br><span class="line">        self.baseurl = <span class="string">"http://tieba.baidu.com/f/like/manage/list?"</span></span><br><span class="line">        self.userAgent = <span class="string">"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36"</span></span><br><span class="line">        self.headers = &#123;<span class="string">'User-Agent'</span>: self.userAgent&#125;</span><br><span class="line">        self.kw = kw</span><br><span class="line">        self.pn = pn</span><br><span class="line">        self.IDdict = IDdict</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getHTML</span><span class="params">(self)</span>:</span></span><br><span class="line">        url = self.baseurl + <span class="string">'kw='</span> + self.kw + <span class="string">'&amp;'</span> + <span class="string">'pn='</span> + str(self.pn)</span><br><span class="line">        request = urllib.request.urlopen(url)</span><br><span class="line">        <span class="comment"># 注意这里网页源码编码是：GBK，用decode解码时要选择gbk</span></span><br><span class="line">        pageHTML = request.read().decode(<span class="string">'gbk'</span>)</span><br><span class="line">        <span class="keyword">return</span> pageHTML</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getUserID</span><span class="params">(self)</span>:</span></span><br><span class="line">        regex = re.compile(<span class="string">'.*?username="(.*?)".*?'</span>)</span><br><span class="line">        pageHTML = self.getHTML()</span><br><span class="line">        UserID = re.findall(regex, pageHTML)</span><br><span class="line">        <span class="keyword">return</span> UserID</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">writeIDinDict</span><span class="params">(self)</span>:</span></span><br><span class="line">        UserID = self.getUserID()</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> id <span class="keyword">in</span> UserID:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            self.IDdict[count + self.pn * <span class="number">20</span>] = id</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.getUserID()</span><br><span class="line">        self.writeIDinDict()</span><br><span class="line">        print(<span class="string">u'写入第%d页用户ID'</span> % (self.pn))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writeInFile</span><span class="params">()</span>:</span></span><br><span class="line">    file = open(<span class="string">u'./百度贴吧minecraft吧用户ID.txt'</span>, <span class="string">'a+'</span>, encoding=<span class="string">'UTF-8'</span>)</span><br><span class="line">    <span class="comment"># print(file.encoding)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> IDdict:</span><br><span class="line">        file.write(IDdict[i]+<span class="string">'\n'</span>)</span><br><span class="line">    file.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#具体要做的任务</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_job</span><span class="params">(kw, pn)</span>:</span></span><br><span class="line">    spider = BaiDuTieBa(kw, pn)</span><br><span class="line">    spider.start()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">do_job1</span><span class="params">(kw, pn)</span>:</span></span><br><span class="line">    spider = BaiDuTieBa(kw, pn)</span><br><span class="line">    <span class="keyword">return</span> spider</span><br><span class="line"></span><br><span class="line"><span class="comment"># 单线程爬虫</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">NoThreads</span><span class="params">(kw, pn)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, pn+<span class="number">1</span>):</span><br><span class="line">        do_job(kw, i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 有多少任务创建多少线程，每个任务执行完就销毁相应线程，这种有点太恐怖，哈哈，任务数太多就爆炸了</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread_spider</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, kw, pn)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.pn = pn</span><br><span class="line">        self.kw = kw</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        do_job(self.kw, self.pn)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MultiThreads</span><span class="params">(kw, pn)</span>:</span></span><br><span class="line">    threads1 = [Thread_spider(kw, i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, pn+<span class="number">1</span>)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> threads1:</span><br><span class="line">        i.start()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> threads1:</span><br><span class="line">        <span class="keyword">if</span> i.is_alive: i.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用线程池和任务队列</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkManager</span><span class="params">(object)</span>:</span><span class="comment"># 这是一个线程管理器</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, kw, work_num, thread_num)</span>:</span></span><br><span class="line">        self.task_queue = queue.Queue()</span><br><span class="line">        self.threads = []</span><br><span class="line">        self.kw = kw</span><br><span class="line">        self.__init_task_queue(work_num)</span><br><span class="line">        self.__init_thread_pool(thread_num)</span><br><span class="line">        self.start_task()</span><br><span class="line"></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        添加一项工作入队</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_job</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        self.task_queue.put(func)  <span class="comment"># 任务入队，Queue内部实现了同步机制</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        初始化任务队列</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init_task_queue</span><span class="params">(self, jobs_num)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, jobs_num + <span class="number">1</span>):</span><br><span class="line">            self.add_job(do_job1(self.kw, i))</span><br><span class="line"></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        初始化线程池</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init_thread_pool</span><span class="params">(self,thread_num)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,thread_num+<span class="number">1</span>):</span><br><span class="line">            self.threads.append(Work(self.task_queue))</span><br><span class="line"></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        开始执行任务</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_task</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> self.threads:</span><br><span class="line">            i.setDaemon(<span class="number">1</span>)</span><br><span class="line">            i.start()</span><br><span class="line"></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">        等待所有线程运行完毕</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wait_allcomplete</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> self.threads:</span><br><span class="line">            item.join(<span class="number">1</span>)  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Work</span><span class="params">(threading.Thread)</span>:</span><span class="comment"># 这是线程类</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, task_queue)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.task_queue = task_queue</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> self.task_queue.empty():</span><br><span class="line">            self.task_queue.get().start()<span class="comment"># 任务异步出队，Queue内部实现了同步机制</span></span><br><span class="line">            self.task_queue.task_done()  <span class="comment"># 通知系统任务完成</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    kw = <span class="string">'minecraft'</span>  <span class="comment"># 贴吧名称</span></span><br><span class="line">    pn = <span class="number">1000</span> <span class="comment"># 页面数</span></span><br><span class="line">    <span class="comment"># 不用多线程模式</span></span><br><span class="line">    <span class="comment"># NoThreads(kw, pn)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 即时创建即时销毁，多线程模式</span></span><br><span class="line">    <span class="comment"># MultiThreads(kw, pn)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 任务队列线程池模式：（任务数：1000，线程：100）</span></span><br><span class="line">    threads_num = <span class="number">100</span></span><br><span class="line">    work_manager =  WorkManager(kw, pn, threads_num)</span><br><span class="line">    work_manager.wait_allcomplete()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"hello world"</span>)</span><br><span class="line">    writeInFile()</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 爬虫 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>那些年我读过的好故事</title>
      <link href="/blog/2017/01/10/%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E8%AF%BB%E8%BF%87%E7%9A%84%E5%A5%BD%E6%95%85%E4%BA%8B/"/>
      <url>/blog/2017/01/10/%E9%82%A3%E4%BA%9B%E5%B9%B4%E6%88%91%E8%AF%BB%E8%BF%87%E7%9A%84%E5%A5%BD%E6%95%85%E4%BA%8B/</url>
      <content type="html"><![CDATA[<p>现代人们每天接触的信息量太过庞大，我们都试图把自己的时间花在有意义的、美好的事上和有效的信息上。所以我打算总结一下自己看过的一些作品，无论是电影、小说、连续剧、游戏、音乐都一并算上吧。影视剧和小说都属于 故事 类，音乐属于 艺术，游戏则是带有 故事的艺术（循环元素越多，信息含量越低，越消磨人的时间，而遗憾的是大多数游戏中的循环元素太多，而且含有上瘾设计元素，毕竟人家要挣钱，让你上瘾是在许多游戏厂商考虑之内的事）。</p><blockquote><p>许多游戏其实有上瘾成分，所以含有上瘾设计元素的游戏，建议慎重考虑，不要入坑，这里点名：红色警戒、魔兽世界、魔兽争霸、英雄联盟、王者荣耀、炉石传说，这些游戏都非常容易上瘾，特别是跟小伙伴一起玩的时候，另外电子游戏跟传统游戏最大的区别就是：你随时都可以开始玩，这是很可怕的，如果你把所有时间都花在游戏上，那么就会耽误很多事。所以请相信下面我要说的这句话：如果你长时间沉浸式的玩游戏，游戏将抽空你所有的注意力，让你睡觉的时候脑子里都是这个东西，你甚至没有时间吃饭，拿衣服去洗衣机里洗。其实像：饥荒、我的世界这类游戏沉浸感也很强，玩游戏嘛就是等你玩出一种沉浸感，然后就开始轻度上瘾了，年轻人为啥喜欢玩游戏，这就跟老人下象棋是一样的，就是时间太多了，就用游戏消遣掉了，你听过中年人打游戏颓废掉的吗，应该很少吧，但我还是发现了一个游戏中的清流：纪念碑谷，这完全算艺术的范畴了，我通关后完全没有一点上瘾的感觉，只有过瘾的感觉，真是一场视觉和创意的盛宴，时间和钱都花的值了，我只玩了一遍，就像看电影一样，很多电影你也只会看一遍。</p></blockquote><p>我们人就是喜欢听故事，好的故事更是令人神往，同时也能卖到好价钱，这一篇重点说故事类的作品，书籍类的记录到一定数量就新开一篇推荐。</p><blockquote><p>好的作品可以陶冶人的性格，构建气质的最底层。</p></blockquote><p>这里我列出来的每一部都是我自己看过的，为了纪念那个时候的时光吧。</p><p>当你列出来这么多看过的东西的时候，真的有种惊讶的感觉，我们总说时间太短、太少，其实我们花在了其他空间，在这些作品中，我们把自己带入进去，从而度过了短暂而精彩的一生。人生和这些电影相比有太多的冗杂和琐事，太多的、太漫长的过程，而人都是短视的、急功近利的、我们浮躁、我们想要精炼的一辈子，其实我们都错了，人生不过是一个过程，谁都逃不过一死，把自己沉淀下来，享受过程，缓慢的生长。</p><blockquote><p>以过程为导向才是正确的人生态度，结果只是一瞬，你的人生应该也必须由过程组成。</p></blockquote><h2 id="电影"><a class="header-anchor" href="#电影"> </a>电影</h2><h3 id="印度电影"><a class="header-anchor" href="#印度电影"> </a>印度电影</h3><ul><li>三傻大闹宝莱坞 3 Idiots (2009)</li><li>小萝莉的猴神大叔 (2015)</li><li>外星醉汉PK地球神 (2014)</li><li>摔跤吧，爸爸（2017）</li></ul><p>然后是豆瓣上评出的经典影片：</p><p>经典永远不会老去</p><ul><li>海上钢琴师 La leggenda del pianista sull’oceano (1998)</li><li>肖申克的救赎 The Shawshank Redemption (1994)</li><li>盗梦空间 Inception (2010)</li><li>楚门的世界 The True man Show (1998)</li><li>阿甘正传 Forrest Gump (1994)</li><li>当幸福来敲门 The Pursuit of Happyness (2006)</li><li>V字仇杀队 V for Vendetta (2005)</li><li>黑客帝国 The Matrix (1999) 三部</li><li>布达佩斯大饭店 The Grand Budapest Hotel (2014)</li><li>霸王别姬 (1993)</li><li>这个杀手不太冷 Léon (1994)</li><li>罗马假日 Roman Holiday (1953)</li><li>泰坦尼克号 Titanic (1997)</li><li>辛德勒的名单 Schindler’s List (1993)</li><li>天堂电影院 Nuovo Cinema Paradiso (1988)</li></ul><p>然后是我最爱的科幻片、悬疑片类型：</p><ul><li>黑侠</li><li>这个男人来自地球 The Man from Earth (2007)</li><li>超时空接触 Contact (1997)</li><li>星际穿越 Interstellar (2014)</li><li>源代码 Source Code (2011)</li><li>蝴蝶效应 The Butterfly Effect (2004)</li><li>致命魔术 The Prestige (2006)</li><li>阿凡达 Avatar (2009)</li><li>恐怖游轮 Triangle (2009)</li><li>生化危机系列</li><li>异次元骇客 The thirteenth floor (1999)</li><li>异星战场</li><li>复仇者联盟 The Avengers (2012)</li><li>钢铁侠系列</li><li>绿巨人系列</li><li>大鱼</li><li>无姓之人</li><li>土拨鼠之日</li></ul><p>然后是反正好看系列：</p><ul><li>冰雪奇缘 Frozen (2013)</li><li>疯狂动物城</li><li>暮光之城系列</li><li>哈利波特系列</li><li>速度与激情系列</li><li>魔戒三部曲</li><li>驯龙高手1、2</li><li>疯狂的麦克斯4：狂暴之路 Mad Max: Fury Road (2015)</li><li>空中监狱 Con Air (1997)</li></ul><p>国产电影：</p><ul><li>翻滚吧！阿信 (2011)</li><li>夏日乐悠悠 (2011)</li><li>破风 (2015)</li></ul><p>没错，三部里面都有彭于晏</p><h2 id="连续剧"><a class="header-anchor" href="#连续剧"> </a>连续剧</h2><h3 id="美剧-英剧"><a class="header-anchor" href="#美剧-英剧"> </a>美剧 &amp;&amp; 英剧</h3><h4 id="美剧"><a class="header-anchor" href="#美剧"> </a>美剧</h4><ul><li>冰与火之歌，又名：权力的游戏，A Song of Ice and Fire: Game of Thrones</li><li>行尸走肉，the walking dead（刚开始看是新鲜，后来就没啥价值了，无非是讲人性罢了）</li><li>西部世界，westworld</li><li>硅谷</li><li>达芬奇密码</li></ul><h4 id="英剧"><a class="header-anchor" href="#英剧"> </a>英剧</h4><ul><li>神探夏洛克</li><li>黑镜</li></ul><h3 id="日剧"><a class="header-anchor" href="#日剧"> </a>日剧</h3><ul><li>legal high（胜者即正义）</li><li>半泽直树</li><li>逃避可耻但有用</li></ul><h3 id="国产电视剧"><a class="header-anchor" href="#国产电视剧"> </a>国产电视剧</h3><ul><li>琅琊榜</li><li>大好时光（并不值得看，当时看这个完全是奔着胡歌去的，看这个剧有种白开水的味道，有种淡淡的生活味儿，另外这个剧传递给你一种极正的三观）</li><li>李小龙传奇</li><li>恰同学少年</li><li>仙剑1，3</li></ul><h4 id="偶像剧"><a class="header-anchor" href="#偶像剧"> </a>偶像剧</h4><p>微微一笑很倾城（并不值得看，除了让你羡慕嫉妒恨，或者活在梦里，没什么太大的意义，主角都太过完美了）</p><h4 id="网剧"><a class="header-anchor" href="#网剧"> </a>网剧</h4><ul><li>一起同过窗（并不值得看，大学过完了才看这个剧，对学生时代总有种意犹未尽的感觉，这个剧带你再次体验那些鸡毛蒜皮的青春时光）</li><li>白夜追凶</li><li>太子妃升职记（你要是想猎个奇，那就试试，其实没啥好看的，不推荐）</li></ul><h3 id="韩剧"><a class="header-anchor" href="#韩剧"> </a>韩剧</h3><ul><li>爱在哈佛</li><li>太阳的后裔</li><li>W 两个世界</li></ul><h2 id="纪录片"><a class="header-anchor" href="#纪录片"> </a>纪录片</h2><ul><li>人生7年，the up series</li><li>互联网时代（央视）(2014)</li><li>互联网之子 The Internet’s Own Boy: The Story of Aaron Swartz (2014)</li><li>史蒂夫·乔布斯：遗失的访谈 Steve Jobs: The Lost Interview (2012)</li><li>舌尖上的中国</li><li>wild China，美丽中国，BBC产的</li><li>小森林（春夏秋冬）</li></ul><h2 id="动漫"><a class="header-anchor" href="#动漫"> </a>动漫</h2><h3 id="国产"><a class="header-anchor" href="#国产"> </a>国产</h3><ul><li>秦时明月</li><li>天行九歌</li><li>我是白小飞</li></ul><h3 id="日本动漫"><a class="header-anchor" href="#日本动漫"> </a>日本动漫</h3><ul><li>火影忍者</li><li>海贼王</li><li>东京食尸鬼</li><li>寄生兽</li><li>进击的巨人</li><li>宫崎骏系列</li><li>天空之城</li><li>龙猫</li><li>千与千寻</li><li>风之谷</li><li>哈尔的移动城堡</li><li>起风了</li><li>萤火之森</li></ul><h2 id="小说"><a class="header-anchor" href="#小说"> </a>小说</h2><ul><li>三体</li><li>缥缈之旅（修真小说的鼻祖，在喜马拉雅上听完的，并没有看文字小说，另外很多时候听着睡着了，不停的打怪升级而已吧，太长了）</li><li>王小波全集（我主要关注的是他这个人，所以他的所有作品都值得看看，我主要看了《沉默的大多数》）</li><li>和空姐同居的日子、第一次亲密接触。这两个也是听的广播剧，男女双人广播剧，言情类型的，不过也是红极一时的作品。在夜里温暖单身狗的小心脏。</li><li>陈二狗的妖孽人生（YY小说，在喜马拉雅上听的，同时也看了点网剧）</li></ul><h2 id="书籍"><a class="header-anchor" href="#书籍"> </a>书籍</h2><p>时间管理的幸福学</p>]]></content>
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>学习方法总结</title>
      <link href="/blog/2017/01/02/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/blog/2017/01/02/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>我把自己以前的多个思考笔记综合成了这一篇，有关于学习的方法论，怎么学英语，怎么背单词，怎么做笔记，以及自我管理</p><p>你要坚信做任何事都不能蛮干，做每件事有每件事的方法，不要在错误的道路上越走越远</p><p>我把学习分为三个维度：重复、理解性学习、教别人</p><h2 id="重复重复再重复"><a class="header-anchor" href="#重复重复再重复"> </a>重复重复再重复</h2><p>你可能知道条件反射，即便是动物也具备的一种学习方法，马戏团天天在证明这一点，通过不断的重复（训练、奖励、惩罚），猪都会钻火圈。无论是学母语，还是学英语，基石都是重复。</p><h2 id="构建认知网络"><a class="header-anchor" href="#构建认知网络"> </a>构建认知网络</h2><p>人的认知是一张一直在不停编织的网络，很多知识，抽象出来的结论、认知，都是相通的（类似的），人通过联想来举一反三，并通过这种联系轻松的记忆学习。</p><p>所以死记硬背是低效的，因为你试图孤立你所学的知识，而孤立的东西难以被人记起，你可以回想一下自己是不是经常忘记熟人的名字，如果熟人的名字都能忘（你是不是仅靠重复使用来记忆别人的名字，而不是通过联系其他事物呢？），忘掉知识不是很正常吗。</p><p>所谓理解性学习，就是用原有的认知去解释新事物，以至于新的认知变得水到渠成，你可以从很多条路子记起这个知识，那么你就内化了这个认知，这才学到了位。</p><p>构建自己的认知网络，就是理解性学习，学习来不得半点生硬，重复重复再重复，固然有用，但时间久了依然会忘记，并且很多知识都是需要灵活应用的，你要把它跟其他东西联系，而且你必须这样做，否则一个孤立的知识，你记得或者不记得没有任何区别。在已经构建好的认知上添砖加瓦，并不断试图从多个不同角度去应用它，让它指导你的其他思维和行为，这样才能慢慢内化。</p><p>不要因此而有了不努力去重复的练习和学习的借口，认真在任何时候都是首要的精神</p><h3 id="理解性学习的不可跳跃"><a class="header-anchor" href="#理解性学习的不可跳跃"> </a>理解性学习的不可跳跃</h3><p>学习其实不难，你觉得难，觉得不懂，原因只有一个：如果一个结论得出来你无法理解，那就是从前提到结论这个过程你无法理解，为什么无法理解，原因也很简单：这其中暗含着一些前提，而这些暗含的前提你是不知道的，或者还没理解，这造成了一个跳跃，而学习和理解是不能跳跃的，你在这里断了链条，那么就会无法继续前进，或者云里雾里，一处不懂处处不懂。</p><p>学习是有路径的，一个初学者你给他看高深的理论，中间越过很多步骤，他是根本无法学会的。你必须一步一个脚印，也只有一步一个脚印才能学的会，学得好，学得精通。很多人由于觉得难就很烦躁，产生畏难情绪，觉得累，想要放下或者放弃。其实就是因为没有找到属于你的学习路径。必须要把中间的那些暗含的前提找到弄懂，然后你就理解了，就可以继续上路。判断一个学习资料是否合适，就要看这份学习资料，对你是不是太难，太难肯定学不下去，太简单又浪费你的时间。</p><blockquote><p>所以好的学习资料都是循循善诱，详细、系统的解释，让你真正的了解。这就跟我读CSAPP和APUE时候的感觉一样。（2018-11-02）</p></blockquote><h2 id="费曼学习法"><a class="header-anchor" href="#费曼学习法"> </a>费曼学习法</h2><p>费曼学习法的精髓就是通过教授别人来强化学习，在教别人的时候你对所学的东西的理解会进一步巩固加深。</p><p>其实你教别人的时候就是在解构理解的过程，也是在重复理解的过程，你讲的越是清晰明了，别人一听就懂，就证明你自己的理解过程越成功越细致，何况你自己还在重复，所以用这个方法来复习是非常棒的，效率很高。</p><blockquote><p>因为你不断的尝试着用跟学生一样的经历和认知去解释这个新知识，甚至从多个角度去解读刻画，最终就能全面的认识，并牢牢的掌握这个知识。(2018-11-02)</p></blockquote><h2 id="怎么学英语"><a class="header-anchor" href="#怎么学英语"> </a>怎么学英语</h2><p>学英语应该是很多国人的痛点，因为学了很多年都没学好，有些从小学开始学，有些从初中开始学，但直到大学本科毕业，英语还是很差。我知道这种苦楚与恐惧，也曾想学好英语，但一直没成功，我在思考这里面的原因，又加上看了一些人的见解，我总结如下：没有环境，这是根源，记忆是靠重复加强，靠关联其他记忆来内化。学习语言尤其要重复，可能因为语言是人类表达的根基，主要是靠死记硬背和疯狂输出，你总不能靠推理来学习语言。所以我们学英语的强度还远远不够，我们没有环境，如果有语言环境，那你在无形之间就已经达到一个高强度的状态，所以我们只能靠自己去打造这种高强度的环境。至少你每天都在学英语用英语吗，如果你做到了，你的英语肯定稳步提升。问题就出在这儿。当你看到英文时是不是恐惧性的跳过不看，当你看到不认识的单词你是不是没有去查，就这还想学好英语，你自己内心里都不会相信吧。这还只是初步的，你有没有刻意去输出呢，输入还算有点环境，毕竟英语的资源一不小心就接触到，但输出好像还真没机会。模仿造句应该被当做像你打游戏中的做日常任务，每造一个句子你都该记录下来，作为游戏日志，累积财富，写文章应该当做下艰难副本，每写一篇你都该奖励自己。对语言的热爱是重要的一个环节，去了解英语文化是有好处的，但另一个重要的环节是坚持，坚持属于长期控制，跟你的短期利益其实没多大关系（所以没几个人能坚持做一件事，随时可能放弃），真正能控制你做一件事的就是 及时反馈，就像很多人打游戏会上瘾，这是人的先天特征，短期利益永远重要，及时的反馈才能刺激我们的神经，坚持学英语也应该建立短期目标，提供及时反馈。这和新东方英语老师朱伟所说的：”多一些不为什么的坚持，少一些功利主义的追求“，其实是一样的，说的就是 长期目标无法让人坚持，心怀大志的去做甚至还不如莫名其妙，毫无理由的去做，有句古话很伤人，叫：“小人常立志，君子立志长”，我曾经就被这句话伤过，因为一直是一个有抱负有理想的青年，曾今有过很多远大的理想，但现在依然没什么值得说的成就，而且我经常会遇到与自己对立起来的情况，想要坚持，但又坚持不了，这其实不应该怪自己，就像你饿了要吃饭，而不是怪自己要吃饭，人应该多多发现自己的本性，而不要去对抗，在进行意志力对抗赛中我们应该常打胜仗，而不是去打必定失败的仗，比如你可以定一个小目标，跑1万米，雨中登山，这种短期的较量，只要你肯对自己下狠心，一定可以做成（而不是制定一个过于长远的计划），而且事后会极大的提升自己的自信，而人一天不是每时每刻都斗志满满，在脆弱的时候支撑你的绝不会是你的意志力，而是习惯，我们所做的所谓坚持，往往毫无胜算，而且不断地一次又一次的伤害到自己，不断的消磨意志力而不是提升，最后只会自己和自己对立起来变成一个真正的屌丝和loser，真的是会有自暴自弃的那一天，只是你现在还年轻，但你仍然会发现岁月不曾停一刻地磨平你的棱角和骄傲，这大概是很多人经历过的吧。我们不应该用自己不多的意志力去打一场不可能赢的仗，我们应该用习惯，用及时反馈，用短期利益，和短期突进训练计划（强迫自己在一个较短的时间内做完某件困难的事，比如跑1万米，看完某个难懂的书的一章，需要查阅大量资料补全理解过程）。初时，随心所欲，以至于放荡不羁，堕落而颓废；中时，勤于律己，结果自我对立，苦不堪言；末了，依旧随心所欲，而不逾矩，如列子乘奔御风，逍遥自在，内心合一。这大概就是看山依旧是山的境界吧。我们需要的只是一个系统的及时反馈方法，和一个一个短时间的小目标（把一个大的计划分解成小目标是有道理的，人可以在短时间内强迫自己，熬一熬就过去了，相信你的意志力）。我这里并没有谈具体的技巧，想看具体技巧可以看接下来的 背单词”。</p><h3 id="背单词"><a class="header-anchor" href="#背单词"> </a>背单词</h3><p>做一件事，首先要证明他是否对你有用，否则不去做（这里我想说说对于游戏的态度，大多数人生来都喜欢玩游戏，但很明显很多人玩游戏上了瘾耽误了不少事，导致生活过的很糟心，我指的是大多数大学生哦，其实你有没有想过不是你在玩游戏，而是游戏在玩你）。背单词是学习英语的一个重大话题。有人说不用去背单词，因为背了单词却不会使用这样的大有人在，应该去广泛的阅读，在文章中记住单词的意思；有人说应该去背句子，用句子串起单词，这样就知道单词的用法；也有人说在阅读中增长词汇量太费时间，背单词是增长词汇量的捷径。<br>我发表一下我自己总结出来的一套看法：</p><ol><li>做任何事都要有正确的方法才能事半功倍，英语学习也是一样，我们可以科学地把学习语言分为：输入和输出，听、读是输入，说、写是输出，输出是输入的巩固和保障，没有输出，英语很难学好，事倍功半。这就是为什么我们大多数中国人总是学不好英语的原因，没有输出环境，输入环境倒是还可以。解决办法就是补上这个输出环节，方法无非是：强迫自己写作，学习地道的写作，地道的英语表达，强迫自己去说，学习地道的口语。</li><li>做事情慢比做错好，背单词首先要保证至少背的是正确的意思（无论是中文还是英文释义），在这个对的基础上，背了总比没背要好。</li><li>其次关于对背了单词却不会使用的问题，背单词属于输入，使用单词属于输出，你只是背单词当然不一定会使用，使用还得靠说，靠写。而架起输入和输出的桥梁就是模仿，再粗陋一点就是背诵然后一字不改的输出来。多背好句子，长句也好，短句也好，当然这个句子必须有亮点，要不然你自己都能写出来，就没有意义，比如全世界人都会说：I love you<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>. 要明白自己的起点，少做一些无用功。然后就是模仿造句，就像小时候学习中文的时候的造句练习。写短文，然后同样是模仿练习。这里说的背诵并不是要求你过多久都还记得背了什么，而是作为一个模仿对象，帮助自己正确的输出自己想要表达的东西，请问你小时候背过的文章你还记得几篇？关键不在于记忆故事、内容，而在于内化英文表达，形成语感。所以这里的背诵也可以理解为熟读，模仿。</li><li>我最想说的一点就是，我们很多人的词汇其实也不算低，但说英语根本没词，没话可说，或者说出来一堆的中式英语表达。原因在于，一门语言背后往往承载着一个相应的文化，就像我们中国不同地方的方言的表达也是不一样的。普通话说：行，河南话说：中。中西方文化差异造成了，即便你认识很多单词，知道很多语法，你依然不知道怎么去描述一件事，表达一种意思。因为别人文化里的表达方式和你的不一样。我们说：毫无睡意，英文表示则是：wide awake。请问这个表达是你直接能想到的吗，我们讲睡，他们讲醒。我们大多数人可能喜欢从字面上，一字一字翻译，这完全是错的，真正的翻译应该是一个意思对应一个意思的翻译，假如英文中有个意思中文里没有怎么办，这就是极考验翻译水平的地方，你要用简单易懂的方式进行类比式的解释，必要时甚至可以创造一个舶来词。记单词并不是全部，背表达方式才能真正学会一门语言。</li><li>既然背单词是可以有的，那么背单词该怎么背，我推荐用词频<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>，按照语言掌握的一般规律，先背最常见的，再背次常见的，以此类推。一般柯林斯的词频就行了，网上也是很容易找到，柯林斯选出了1万多的词，把这些词总共分了5类，用五角星标记，五颗星的是最常见的，比如词频排名第一的the，就在这里面，依此类推，一颗星的是词频最低的，当然还有不带星的，那种单词就更少用到了，所以也不用急着去背。按词频背单词可以让你精确定位常用单词，避免学了一堆不常用的，这种安排其实也发生在我们学英语的整个过程，比如小学单词比初中单词常见，初中的又比高中的常见，高考的又比大学四六级的常见，大学四六级的又比考研、托福、雅思、GRE新增的词汇常见。按词频背单词还有一个好处就是可以查漏补缺，你可以清楚的知道自己哪些单词还稍微陌生，还有哪些重要的单词还完全不认识，这是靠阅读学单词花费大量时间也无法办到的。这叫针对性。当然阅读中学单词是有用的，一般来说我们可以在阅读中巩固对单词的记忆，用法等等，用起来的单词更容易记住，因为“用”这个词，代表你在反复强化你脑中的那些相应的神经元路径<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>，而且增添更多的应用场景（新的神经元路径），让你记得更牢，更生动。</li></ol><h2 id="结合互联网的现代化笔记法"><a class="header-anchor" href="#结合互联网的现代化笔记法"> </a>结合互联网的现代化笔记法</h2><p>今天对于记笔记又有了点新想法，结合以前的，总结如下：</p><ol><li>所有笔记都不可靠，最终要记在脑子里，内化成自己可以随时调用的资料和意识。笔记只是为了便于复习回顾，没有内化它就不是你的，只是一团外在的信息，对你来说也就跟没有一样，你还是你，当笔记是身外之物的时候它是不可靠的，只有当知识、技巧和思维方法内化进你大脑的神经回路里，它才真正成为你身体的一部分，是自我意识的一部分，你也因此变得更加强大起来，然而很多人学的知识是死的，不能用于帮助自己解释和理解这个世界以及身边发生的各种事，那你学这些东西又有什么意义呢，你面对这个纷繁复杂的现象宇宙，鸟还是鸟，花草树木还是花草树木，月亮还是月亮，感性统治着你，所有知识和理性全都被封锁起来，你看不透这个世界，也没有借助自己所学去帮助自己看透这个世界，于是你忘了你学的东西。自始至终都没有用到它们，忘掉是很自然的。但其实它们就在你身边，无时无刻不在，只是你没发现它们，没有有意识地去看见它们。这样的学习学一辈子都是竹篮打水一场空，白白虚耗了时光。少年，想获得力量吗，那就去做个有心人吧，把知识用起来，让它成为你大脑的一部分。</li><li>笔记一定要电子化，书籍也电子化，因为电子化便于携带，传输，查阅，搜索，检索。就算先写在纸上，但之后也要拍照整理成电子的（并附加上关键词，摘要），数据不应该流失，遇到半熟的知识，第一反应查笔记，第二反应上互联网搜，并把学到的用自己的语言记在笔记里。</li><li>善于找别人记下的笔记和总结，同时利用起像百度百科和维基百科和各种人的博客等等东西，前两者比较稳定，所以贴链接即可，后者不稳定一定要截图，或者复制粘贴。这样做是尽量保证笔记的持久性，其实这么久的持久性也没啥用，因为你势必要在相对较短的时间内消化知识，你不消化它就会淡忘，你不用起来它就相当于没有，你也就白学了。比如我一直想整理出一份完整的系统的数学笔记，但我其实没有必要一笔一笔写下这个笔记，而且我也没有这个时间去干这件事，而且说到底笔记只是用来协助内化记忆，本身就只是一个附带性工作，真正要下功夫做的是记忆，运用（做题，解题中应用知识），并结合生活这本无字大书。别人的笔记不完整，这不要紧，你自己立好框架，然后以添加URL链接的方式把这些内容接入你的框架。比如今天我找柯西中值定理的证明，我忘了怎么推导这个定理，我去谷歌搜索了，维基百科里有完整的证明，我只需在笔记中柯西中值定理证明这一处添加一个链接，或做个注释。这是因为只要在有互联网和手机的时候我就可以立即查阅，互联网是一个非常便利的云端，信息不用随身携带，增强了每一个现代人的移动性（这一重要属性在罗辑思维里，吴伯凡总结过，生物的一个基本属性就是移动性，越高等的生物移动属性越高），这就是结合网络的笔记法，整个网络都是你的信息仓库，你只需要做个链接就可迅速找到。</li><li>由此便可得出 只列框架和名词的高度精简笔记（甚至框架也可以在互联网上找到合适的，但每个人都有自己的知识树，另外框架是个索引性的东西，你自己必须非常熟悉，如果索引都依赖于外部，你自己还剩下些什么呢，特别是重要的索引，一定得是非常熟悉的）。</li><li>由于互联网上的许多内容不一定正确（甚至有的时候会误导你），还有就是不一定完整。而书籍和传统出版物相对来说靠谱，所以做笔记时强烈建议考虑内容的质量，尽量找权威的，最好是出版物（电子书）或者官方文档。</li><li>学习的几个基本要素：</li></ol><ul><li>概念</li><li>应用场景</li><li>发现背景</li><li>证明推导过程</li><li>习题</li></ul><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>英语和汉语的共同点就是主谓宾的顺序是一致的，不同点在于修饰，英语的修饰习惯后置，汉语的修饰从不后置，一定是放在前面的 <a href="#fnref1" class="footnote-backref">↩</a></p></li><li id="fn2" class="footnote-item"><p>词频号，代表词出现在词频排名中的位置，比如the的词频号是1，代表它在语料库中出现频率最高，排名第一。 <a href="#fnref2" class="footnote-backref">↩</a></p></li><li id="fn3" class="footnote-item"><p>人脑记忆的物理特点：靠神经元的链接，电脑存储的特点：靠电子元件的电位固定地，精确地存储。有时候你忘了一样东西，并不是他消失了，而是它在你脑中的神经元连接路径太弱、太少，你搜索不到它。所以我们记忆有两个特点：一个是不断重复强化，加强这条路径；一个是把要记忆的东西跟很多已经在你脑海里最常用的记忆联系起来，也就是并入你的记忆主堡，那你将快速的找到它，这也是理解性记忆的根源，因为理解代表与你的已有认知不悖，也就是可以由已有定理推出要学习的定理，如果推导一个定理可以有很多方法，或者有一个非常容易想到的方法，那么这条定理顺理成章的就被你记下来了。死记硬背则是用的第一种方法，不断的重复强化，但效果不佳，原因很简单，我们的大脑天生喜欢第二种方法，这是大脑的物理结构决定的，物理基础决定上层建筑，只有把一个东西并入你的知识树，内化成自己的日常认知习惯，它就牢牢的钉在你的脑子里，成为你随时可以调取的记忆，而这也是靠死记硬背无法真正学透的原因，因为死记硬背没有使这个知识和其他东西联系起来，就像你是一个瓶子一个瓶子的装知识，其间泾渭分隔，发散性很差，那么你根本不会在很多要用的时候想起它来，也就无法学以致用。 <a href="#fnref3" class="footnote-backref">↩</a></p></li></ol></section>]]></content>
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>从 windows 转用 mac OS X 记录</title>
      <link href="/blog/2017/01/01/%E4%BB%8Ewindows%E8%BD%AC%E7%94%A8macOSX%E8%AE%B0%E5%BD%95/"/>
      <url>/blog/2017/01/01/%E4%BB%8Ewindows%E8%BD%AC%E7%94%A8macOSX%E8%AE%B0%E5%BD%95/</url>
      <content type="html"><![CDATA[<p>这篇文章我想讲讲我从用 Windows 到用 mac OS X 的过程中遇到的困难和解决方法。</p><p>由于我本人是学计算机的，电脑用的多，喜欢用一些设计的好的快捷键，所以我分为两部分吧，第一部分讲给普通用户，第二部分讲给程序员。</p><p>先告诉你们一个通用小技巧，众所周知，flash视频非常让电脑发热，而看HTML5视频则一点都不热。safari有个伪装成iPad或者iPhone的功能，可以把视频强制用HTML5播放。你的MacBook就再也不会在看视频的时候发烫了。</p><p><img src="https://wx4.sinaimg.cn/mw690/006zFO3ggy1fcd4d2uzibj31kw0zkdug.jpg" alt="safari强制使用HTML5播放视频"></p><p>时至今日（2017.9.9），很多网站都可以使用 HTML5播放视频了，如：bilibili，中国大学MOOC，使用 HTML5播放视频是未来的方向。</p><h2 id="普通用户使用mac指南"><a class="header-anchor" href="#普通用户使用mac指南"> </a>普通用户使用mac指南</h2><h3 id="浏览器"><a class="header-anchor" href="#浏览器"> </a>浏览器</h3><p>找不到浏览器吗？点击像指南针图标的那个safari，那个应用就是浏览器。</p><h3 id="输入法"><a class="header-anchor" href="#输入法"> </a>输入法</h3><p>和初次使用Linux一样，一上来我们肯定就要碰到输入法的难题，mac切换输入法的快捷键是command+space（空格），一般的系统或者软件都是支持自定义快捷键的，你可以修改快捷键。对于用惯了搜狗输入法的同学，这里我推荐使用搜狗输入法，它可以记住用户习惯。</p><p><img src="https://wx4.sinaimg.cn/mw690/006zFO3ggy1fcceny2wsuj31kw0zkdku.jpg" alt="mac输入法截图"></p><p>搜狗默认的通用中英文切换键是 shift。</p><h3 id="触摸板"><a class="header-anchor" href="#触摸板"> </a>触摸板</h3><p>mac的触摸板应该是所有笔记本电脑触摸板的宗师吧，而且也是最好用的触摸板。我用mac的时候，除了玩游戏，完全用不着鼠标。</p><p>没有鼠标，那么左右键怎么办？很简单：一指单击触摸板，就是左键，两指单击触摸板，就是右键。记得将轻触触摸板设置为点击，这样可以延长触摸板的寿命，而且点起来也舒服多了。</p><p>五指合拢，你可以看到你电脑上安装好的应用，这个界面叫做：launchpad。</p><p><img src="https://wx2.sinaimg.cn/mw690/006zFO3ggy1fccexd55wpj31kw0zktgg.jpg" alt="launchpad截图"></p><p>五指弹开，如果你处在launchpad界面，五指弹开就会回到原先五指合拢之前的那个界面，回到这个界面之后，再用一次五指弹开，就是弹开所有应用，让你看到桌面（如果你当前窗口是全屏模式，则此法失效）。</p><p><img src="https://wx3.sinaimg.cn/mw690/006zFO3ggy1fccf5tp4rpj31kw0zkjwj.jpg" alt="弹开应用看到桌面"></p><p>三指上推，可以看到所有打开的窗口的缩略图。</p><p><img src="https://wx4.sinaimg.cn/mw690/006zFO3ggy1fccf0mfcanj31kw0zkqcm.jpg" alt="窗口缩略图"></p><p>三指横扫，可以在全屏之间切换，这是我最喜欢的设计之一。</p><h3 id="安装应用"><a class="header-anchor" href="#安装应用"> </a>安装应用</h3><p>去官网下好应用，通常是.dmg后缀的安装包，打开，拖拽到Applications文件夹就完成了安装，比Windows爽多了吧。</p><h3 id="文件管理器finder"><a class="header-anchor" href="#文件管理器finder"> </a>文件管理器Finder</h3><p>调整默认Finder窗口大小，可以按住option，然后进行拖动，窗口的大小就可以保留下来了。</p><p>command+shift+.可以显示隐藏文件，关闭显示隐藏文件也是这个快捷键。</p><p>右键之后，没有新建文件选项。</p><p>你只能先打开应用，然后在应用中新建文件。</p><p>记住在Windows上用的很爽的ctrl+a、ctrl+s、ctrl+c、ctrl+v、ctrl+f等等，在mac上统统把ctrl换成command就OK了。</p><p>command+x不能剪切文件和文件夹是吧。</p><p>解决办法是：先command+c，然后command+option+v，成功的完成文件的剪切和粘贴。</p><p>普通用户的指南到此结束，如果有什么问题，请私信我的知乎，我博客头像下面有个知乎的知的图标，点击就能到我的知乎个人主页。</p><h2 id="程序员mac指南"><a class="header-anchor" href="#程序员mac指南"> </a>程序员mac指南</h2><p>先上几个零碎的小技巧：</p><p>触摸板双指双击，放大（我觉得其实没啥卵用）</p><p>在应用窗口顶栏双击，缩放窗口（这个Windows也有的）</p><h3 id="文件管理器finder-v2"><a class="header-anchor" href="#文件管理器finder-v2"> </a>文件管理器Finder</h3><p>首先讲Finder，这是mac 系统，也就是OS X系统的文件管理器，和windows的文件管理器对比有点不同，最不方便的地方在于点击右键没有新建文件选项，如果你会Linux，可以用命令touch 文件名来新建文件，如果你不会命令，可以先打开文本编辑器，再新建文本文件，它的设计哲学是，你要新建什么文件，就先打开与这个文件相关的软件，再在这个软件里新建这个类型的文件，不过不方便就是不方便。再讲讲优秀的地方，Finder可以打开多级目录。</p><p><img src="https://ww4.sinaimg.cn/mw690/005DrjN1gw1fbgxqax4waj316s0o8n0e.jpg" alt="Finder多级目录"></p><p>另外可以 按空格键预览，这个预览功能现在 Windows 也有了。</p><p>Finder还有tag系统，你可以通过tag来访问属于同一个tag的文件</p><p><img src="https://ww3.sinaimg.cn/mw690/005DrjN1gw1fbgxwxxpobj316s0o8ad8.jpg" alt="Finder的tag功能"></p><h3 id="快捷键"><a class="header-anchor" href="#快捷键"> </a>快捷键</h3><blockquote><p>快捷键肯定是最重要的啦！</p></blockquote><p>然后讲讲快捷键设计，我在windows下已经有了些使用快捷键的习惯，比如：</p><p>win+E是打开文件管理器</p><p>win+D是显示桌面（也就是将所有窗口最小化）</p><p>win+L锁屏</p><p>ctrl+S保存</p><p>ctrl+A全选</p><p>ctrl+C复制</p><p>ctrl+X剪切</p><p>ctrl+V粘贴</p><p>ctrl+F查找</p><p>当我来到OS X下的时候，我同样先摸索了一番快捷键。设计快捷键的哲学就是通用，这样就可以节省记忆成本，mac上的cmd基本上承担了windows上ctrl的职能，常用的快捷键有：</p><p>cmd+S保存</p><p>cmd+A全选</p><p>cmd+C复制</p><p>cmd+X剪切</p><p>cmd+V粘贴</p><p>cmd+F查找</p><p>cmd+D制作副本</p><p>按住option+command，拖动文件，可以产生快捷方式，也就是链接。</p><p>cmd+, 打开preferance也就是打开设置界面，这个快捷键简直不要太爽，希望 Windows 上也弄一个</p><p>cmd+N 打开新窗口</p><p>cmd+W 关闭窗口</p><p>cmd+H 隐藏窗口</p><p>cmd+Q 退出程序</p><p>cmd+ctrl+F 全屏和退出全屏，播放视频时候退出全屏一般是 ESC 键</p><p>cmd+Tab切换程序</p><p>你用了Finder之后可能会恼火没有剪切文件的功能，但其实是有的，只是快捷键不一样，剪切文件的快捷键是，先cmd+C复制，然后cmd+option+V粘贴。</p><p>这是我常用的几个快捷键。总之快捷键不用记很多，按你自己的需要，记住常用的就行。</p><p>Command+Option+D 控制Dock的显示与隐藏，我还是喜欢留着 Dock。</p><p>Command+Option+H 隐藏所有其他窗口</p><p>Shift+音量 会有声音，直接按音量默认是不出声</p><p>Command+I 显示简介（在Finder中），然后就 可以修改打开一个文件的默认APP</p><p>Command+Control+N 新建一个文件夹，并归类你选中的所有文件</p><h4 id="编辑文本的快捷键"><a class="header-anchor" href="#编辑文本的快捷键"> </a>编辑文本的快捷键</h4><p>Command+Space 切换输入法</p><p>Command+left 让光标跳到最前面，相当于windows下的home键</p><p>Command+right 让光标跳到最后，相当于windows下的end键</p><p>Command+up 让光标跳到整个文本的最开头</p><p>Command+down 让光标跳到整个文本的最后</p><p>Command+delete 删除当前行，相当于windows下的home，shift+end（选中，从行头到行尾），backspace，这三个操作的组合。这个快捷键会让你相当爽的。</p><h4 id="截图快捷键"><a class="header-anchor" href="#截图快捷键"> </a>截图快捷键</h4><p>Command+Shift+3 截取整个桌面，并把截图作为一个文件存储在桌面上</p><p>Command+Shift+4 截取一个区域，并把截图作为一个文件存储在桌面上</p><p>Command+Shift+Ctrl+3 截取整个桌面，并复制到剪切板</p><p>Command+Shift+Ctrl+4 截取一个区域，并复制到剪切板</p><p>Command+Shift+4 然后按Space就会截取一个窗口。这样截图会自带阴影效果。如果不想自带阴影效果，可以按住option再点触摸板。</p><p>Command+Ctrl+A mac QQ 截图快捷键，由于屏幕分辨率太高，mac系统快捷键截出来的图都太大了，而macQQ截出来的图大小正合适。</p><h4 id="chrome浏览器快捷键"><a class="header-anchor" href="#chrome浏览器快捷键"> </a>Chrome浏览器快捷键</h4><p>这个应该是与操作系统无关的（有些快捷键还是不一样的），但在Mac下养成了用快捷键的习惯，所以Chrome的快捷键都是在Mac上学的，在windows下注意用Ctrl替换Command键就行了。</p><p>Command+R 刷新</p><p>Command+L 将窗口焦点锁定到浏览器的地址栏，不用移动鼠标哦</p><p>Command+T 打开一个新Tab</p><p>Command+Shift+T 打开一个之前被关闭的Tab</p><p>Command+Shift+J 打开下载页面</p><p>Command+Shift+C 打开“检查(spectator)”，鼠标右键可以看到这个选项，一般是程序员使用的高级功能，但不能再次使用快捷键关闭。</p><p>Command+Shift+I 同样是打开spectator，使用开发人员工具，但可以再次使用快捷键关闭。</p><p>Command+Shift+B 打开或关闭书签栏</p><p>Command+Option+B 打开书签管理器</p><p>Command+Y 打开历史记录</p><p>Command+Option+左右方向键 切换标签页</p><p>Command+D 收藏此页为书签</p><p>Command+Shift+D 将所有标签页加书签</p><p>Command+上下方向键 跳到页面顶部或底部</p><p>Command+Option+J 打开javascript控制台</p><p>按住Command后点击链接，在新Tab（标签页）中打开这条链接。</p><p>Command+Shift再点击链接，在新标签页中打开并切换到新标签页</p><p>Command+Shift+N 用隐身模式打开新窗口</p><p>Command+Shift+W 关闭当前窗口</p><p>Command+[ 或者 ] 前进或者回退</p><p>Command+左右方向键 前进或者后退</p><p>Command+Option+U 查看网页源代码</p><h4 id="iterm2快捷键"><a class="header-anchor" href="#iterm2快捷键"> </a>iTerm2快捷键</h4><p>iTerm2中的文本，选中即复制，这个其实没必要，我现在都习惯了选中后 cmd+c，而且当你选择替换目标时候由于这个选中即复制，会覆盖掉你的剪切板</p><p>Command+D 水平分隔出一个终端</p><p>Command+Shift+D 垂直分割出一个终端</p><p>可以配置透明度，Command+U快速切换透明与否</p><p>可以配置全局唤出快捷键，我自己配置的是Command+U</p><p>可以配置快捷悬浮，Hotkey window</p><p>Command+Shift+H 查看复制历史</p><p>Command+Enter 快速切换全屏与否</p><h4 id="cli-命令行-快捷键"><a class="header-anchor" href="#cli-命令行-快捷键"> </a>CLI(命令行)快捷键</h4><p>Mac本身的特点就是GUI和CLI的完美结合（很多Linux的爱好者，又不想被Linux的桌面、各种驱动、不兼容等等杂七杂八的问题折腾的，大可选择Mac）。</p><p>首先教一个最重要的东西<br>记住按Tab补全，这是命令行用的爽的根源。</p><p>Ctrl+A 回到行首</p><p>Ctrl+E 到行末</p><p>Ctrl+U 删除一行</p><h2 id="格式转换"><a class="header-anchor" href="#格式转换"> </a>格式转换</h2><p>有时候需要把 png 等格式的图片转成 jpg 的格式，于是有同学就去到处找格式转换软件了。<br>其实在 Mac 中直接更改图片的扩展名，即可自动转成相应地格式~试试吧，如果你改格式前看了文件修改日期，改完格式后你会发现修改日期依然没变，至于原因是什么，需要你有图片的文件格式的相关知识。</p><h2 id="launchpad与dock"><a class="header-anchor" href="#launchpad与dock"> </a>Launchpad与Dock</h2><p>Launchpad是指，你在触摸板上用五指向中间收拢，出现的全是APP的页面，半透明的。</p><p>Dock是指，最下方的摆满APP的一栏，在Dock上你可以放上最常用的APP。</p><p>调整launchpad的图标大小：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//把行数重定义成6</span><br><span class="line">delete write com.apple.dock springboard-rows -int 6</span><br><span class="line">//把行数充定义成默认</span><br><span class="line">defaults write com.apple.dock springboard-rows Default</span><br><span class="line">//删除定义好的行数（恢复默认）</span><br><span class="line">defaults delete com.apple.dock springboard-rows</span><br><span class="line">//把列数定义成默认</span><br><span class="line">defaults write com.apple.dock springboard-columns Default</span><br><span class="line">//重置 Launchpad，效果就是 launchpad 的布局全给你打乱了，而第一页恢复默认，建议不要使用</span><br><span class="line">defaults write com.apple.dock ResetLaunchPad -bool TRUE</span><br><span class="line">//重启 Launchpad，并使你前面的设置生效</span><br><span class="line">killall Dock</span><br></pre></td></tr></table></figure><p>在appstore下载一个软件到一半，然后在Application删除了该软件，结果在launchpad中留下了一个垃圾残留空图标。<br>删除launchpad中的垃圾残留图标，只需拖拽到下载文件夹。其他方法都试过（无效），比如按住图标几秒，出现一个叉，点击叉，删除，没用。在Application找到相应项删除没用。</p><h2 id="option的妙用"><a class="header-anchor" href="#option的妙用"> </a>Option的妙用</h2><p>下面再讲些不常用但是有意思的：</p><p>除了cmd是常用的，option键也值得我们关注，下面讲几个option的妙用：</p><p>按住option+shift可以微调（1/4微调）音量、键盘背光亮度和屏幕亮度，按住option再按其他字母键等，会出现奇怪的字符¥©<br>©œ∑®†¥åß©≈ç等等。</p><p>按住option再把鼠标移到Dock上的APP上，你会发现退出变成了强制退出，怎么样option键还是挺强大的吧。</p><h3 id="数学符号"><a class="header-anchor" href="#数学符号"> </a>数学符号</h3><p>约等于: Option + X = ≈<br>度数: Shift + Option + 8 = °<br>除号: Option + / = ÷<br>无穷: Option + 5 = ∞<br>大于等于和小于等于: Option + , 和 Option + . = ≤ 和 ≥<br>不等于: Option + = = ≠<br>圆周率: Option + P = π<br>加减: Shift + Option + = = ±<br>开方: Option + V = √<br>求和符号: Option + W = ∑</p><h3 id="输入特殊符号"><a class="header-anchor" href="#输入特殊符号"> </a>输入特殊符号</h3><p>版权符号: Option + G = ©</p><p>人民币符号: Option + Y = ¥</p>]]></content>
      
      <categories>
          
          <category> 数码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>线性代数笔记--基础篇：行列式、矩阵的本质</title>
      <link href="/blog/2016/09/30/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0--%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%9A%E8%A1%8C%E5%88%97%E5%BC%8F%E3%80%81%E7%9F%A9%E9%98%B5%E7%9A%84%E6%9C%AC%E8%B4%A8/"/>
      <url>/blog/2016/09/30/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0--%E5%9F%BA%E7%A1%80%E7%AF%87%EF%BC%9A%E8%A1%8C%E5%88%97%E5%BC%8F%E3%80%81%E7%9F%A9%E9%98%B5%E7%9A%84%E6%9C%AC%E8%B4%A8/</url>
      <content type="html"><![CDATA[<p>线性：量和量之间的关系是一次的<br>线性代数的核心研究对象：<strong>向量</strong></p><h2 id="行列式的本质定义"><a class="header-anchor" href="#行列式的本质定义"> </a>行列式的本质定义</h2><p>（行列式的绝对值）是n维向量所构成的图形的面积或体积（面积和体积分别是二唯和三维的说法，更高维数依次类推）。<br>determinant（行列式）</p><h2 id="行列式的性质"><a class="header-anchor" href="#行列式的性质"> </a>行列式的性质</h2><ol><li>$D_n=|A|中某行元素全为0\Rightarrow |A|=0$,因为有一个向量为0，所以构成的图形比n少一维，所以体积为0。</li><li>$D_n=|A|中某两行元素对应成比例\Rightarrow |A|=0$,因为有两个向量是平行的，所以构成的图形体积为0.</li><li>（互换）$|A|$中某两行元素互换$\Rightarrow|A|$变号(即得到$-|A|$),两向量的夹角变了，$\sin (\alpha-\beta)=-\sin (\beta-\alpha)$,所以体积变号。</li><li>（倍乘）乘k，就把k乘到任意一行或者列，同理如果某行或者列可以提出k倍也行。因为某向量乘k倍，体积变为k倍。<strong>这里要区别于矩阵的倍乘，矩阵是用来表达系统信息的数表，每个元素都要乘k倍。</strong></li><li>（倍加）某行乘k倍加到另一行上，行列式结果不变，几何表述：**因为这两个向量构成的平行四边形同底同高，面积不变，所以体积也不变。**可拆性表述：拆成两个行列式，其中一个行列式为0，因为它某两行对应成比例。</li><li>单行可拆（加）性</li><li>$|A|=|A^T|$，行列等价，前六个性质同样适用于列。</li></ol><h3 id="重要观点"><a class="header-anchor" href="#重要观点"> </a>重要观点</h3><ol><li>$D_n=|A|\neq0\Rightarrow S\neq0\Rightarrow 组成行列式的向量全独立$</li><li>$D_n=|A|=0\Rightarrow 组成行列式的向量至少有一个多余$<br><strong>行列式=0还是$\neq$0才是关键，而不是管它等于多少</strong><br><strong>向量与向量之间要么独立要么多余</strong></li></ol><h2 id="矩阵的本质"><a class="header-anchor" href="#矩阵的本质"> </a>矩阵的本质</h2><ol><li>表面上，矩阵是表达系统信息的数表</li><li>本质上，矩阵也是由向量构成的，矩阵的核心是矩阵的<strong>秩</strong>，而秩的本质是组成矩阵的独立向量的个数；矩阵是一种<strong>运算</strong>，一种对应法则，把一个线性代数研究对象变换成另一个的手段；<strong>矩阵还是方程组的系数表</strong>，决定了初等变换的性质（可以行对调，可以行倍加倍减，可以行倍乘）。</li></ol><p><strong>秩的本质</strong>：r(A)=k，则矩阵中有k个独立的向量</p><p><strong>台阶数=秩</strong>，因为台阶之间（向量之间）是独立的。</p><p><strong>行阶梯形矩阵</strong>：1）若有0行，全在下方，2）从行上看，自左边起，出现连续0的个数，自上而下严格单增。若还满足3）台角位置元素为1，4）台角上方元素全为0，称为<strong>行最简阶梯形矩阵</strong>。</p><p><strong>初等变换法：互换、倍乘、倍加</strong></p><p>解释：互换不影响方程组的解，不影响向量的独立性，倍乘不影响方程组的解，不影响向量的独立性，倍加不影响方程组的解，不影响向量的独立性。**矩阵进行初等变换不影响矩阵的秩，**不影响矩阵的本质意义，所以初等变换是可以大量广泛使用的。<br><strong>任何可逆矩阵一定可以通过若干次初等变换化成同阶单位阵</strong></p><h3 id="矩阵的乘法"><a class="header-anchor" href="#矩阵的乘法"> </a>矩阵的乘法</h3><p>AB=C</p><p>矩阵的乘法中，C中的每一个元素都是一个<strong>向量的内积</strong>，所以矩阵乘法可以看做向量内积的推广。另外矩阵的左乘代表行变换，矩阵的右乘代表列表换。矩阵的乘法也可以看做一种函数变换，因为矩阵乘法可以把一个线代对象，转换成另一个线代对象。</p><p><strong>乘法单位元素：</strong><br>1·a=a,a·1=a，其中1称为乘法单位元素，矩阵的乘法单位元素是E（单位矩阵）</p><p><strong>乘法反单位元素：</strong><br>$a\cdot\frac{1}{a}=1,\frac{1}{a}\cdot a=1$，其中$a$和$\frac{1}{a}$互称乘法反单位元素。矩阵$A$的乘法反单位元素是$A^{-1}$。<br>二阶逆矩阵，主对角线对调，次对角线取相反数。</p>]]></content>
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>线性代数笔记--线性代数复习核心思想</title>
      <link href="/blog/2016/09/30/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0--%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%A4%8D%E4%B9%A0%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3/"/>
      <url>/blog/2016/09/30/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%AC%94%E8%AE%B0--%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%A4%8D%E4%B9%A0%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3/</url>
      <content type="html"><![CDATA[<p>线性代数是一个整体，各个模块之间联系密不可分。</p><p>一、行列式、矩阵</p><p>二、向量组、方程组</p><p>三、特征值、二次型</p><p>命题重点在二和三。</p><p>难点在矩阵和向量组<br>秩的等式和不等式的研究、分块矩阵</p><p>例题：设n阶矩阵A、B乘积可交换，$\xi_1,\xi_2,\cdots,\xi_{r_1}、\eta_1,\eta_2,\cdots,\eta_{r_2}$分别是AX=0,BX=0的一个基础解系，且对于n阶矩阵C、D，有r(CA+DB)=n,<br>（I）证明$r\begin{pmatrix}A\B\end{pmatrix}=n$，且$\xi_1,\cdots,\xi_{r_1},\eta_1,\cdots,\eta_{r_2}$无关；<br>（II）证明$\xi_1,\cdots,\xi_{r_2},\eta_1,\cdots,\eta_{r_2}$是ABX=0的一个基础解系。<br>1.是解，2.无关，3.<strong>S=n-r，S是基础解系的个数，是自由变量的个数，也就是总变量-秩（有效方程个数，也即约束的个数）</strong><br><strong>矩阵越乘秩越小</strong><br>（I）<br>$n=r(CA+DB)=r\left((C D)\begin{pmatrix}A\B\end{pmatrix}\right)\leq r\begin{pmatrix}A\B\end{pmatrix}\leq n\Rightarrow r\begin{pmatrix}A\B\end{pmatrix}=n列满秩$</p><p>$\Rightarrow \begin{pmatrix}A\B\end{pmatrix}X=0只有零解\Rightarrow AX=0与BX=0没有非零公共解\Rightarrow \xi_i(i=1,2,\cdots,r_1)均不可由\eta_1,\eta_2,\cdots,\eta_{r_2}表出，因若不然，\xi_i=k_1\eta_1+k_2\eta_2+\cdots+k_{r_2}\eta_{r_2}，则有公共非零解，矛盾，同理可得，\eta_i(i=1,2,\cdots,r_1)均不可由\xi_1,\xi_2,\cdots,\xi_{r_2}表出，故\xi_1,\cdots,\xi_{r_1},\eta_1,\cdots,\eta_{r_2}$无关<br>（II）<br>显然，$B\eta_j=0,j=1,2,\cdots,r_2\Rightarrow AB\eta_j=0\Rightarrow\eta_j是ABX=0的解；又AB=BA，A\xi_i=0\Rightarrow BA\xi_i=AB\xi_i=0\Rightarrow\xi_i也是ABX=0的解$<br>$r(AB)\geq r(A)+r(B)-n=n-r_1+n-r_2-n=n-(r_1+r_2)$<br>$ABX=0的S=n-r(AB)\leq r_1+r_2，基础解系中至多r_1+r_2个向量，又根据第一问的证明，显然S\geq r_1+r_2，至少r_1+r_2个，恰有r_1+r_2个解向量$</p>]]></content>
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 线性代数 </category>
          
      </categories>
      
      
    </entry>
    
  
  
</search>
