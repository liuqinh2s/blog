<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>liuqinh2s&#39; blog</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://liuqinh2s.github.io/blog/"/>
  <updated>2022-07-10T16:48:16.505Z</updated>
  <id>https://liuqinh2s.github.io/blog/</id>
  
  <author>
    <name>liuqinh2s</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript原型和原型链</title>
    <link href="https://liuqinh2s.github.io/blog/2022/07/10/JavaScript%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>https://liuqinh2s.github.io/blog/2022/07/10/JavaScript原型和原型链/</id>
    <published>2022-07-09T16:00:00.000Z</published>
    <updated>2022-07-10T16:48:16.505Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mqyqingfeng/Blog/issues/2&quot;
        
      
    
    </summary>
    
      <category term="JavaScript" scheme="https://liuqinh2s.github.io/blog/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>TCP和UDP的区别</title>
    <link href="https://liuqinh2s.github.io/blog/2022/06/20/TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://liuqinh2s.github.io/blog/2022/06/20/TCP和UDP的区别/</id>
    <published>2022-06-19T16:00:00.000Z</published>
    <updated>2022-06-24T00:25:52.612Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;好久没回顾这个知识点了，我现在只记得 TCP 是有链接的，UDP 是无连接的；TCP 是可靠的，UDP 是不可靠的。技术细节已经全然忘光了，今天就来回顾一下。&lt;/p&gt;
&lt;p&gt;先说几个几点结论，然后再说说细节：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP 是有链接的，UDP 是无连接的&lt;/li&gt;
&lt;li&gt;TCP 可靠（无差错，不丢失不重复，按序到达），UDP 不可靠&lt;/li&gt;
&lt;li&gt;TCP 面向字节流，UDP 面向报文&lt;/li&gt;
&lt;li&gt;TCP 是一对一全双工，UDP 是 n 对 n&lt;/li&gt;
&lt;li&gt;TCP 的首部较大为 20 字节，UDP 首部只有 8 字节&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="计算机网络" scheme="https://liuqinh2s.github.io/blog/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>服务器重装系统</title>
    <link href="https://liuqinh2s.github.io/blog/2022/06/11/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%87%8D%E8%A3%85%E7%B3%BB%E7%BB%9F/"/>
    <id>https://liuqinh2s.github.io/blog/2022/06/11/服务器重装系统/</id>
    <published>2022-06-10T16:00:00.000Z</published>
    <updated>2022-06-12T01:39:39.164Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;今天我的 wordpress 数据库被攻击了，目前还不知道黑客用了什么手段，所以打算给服务器重装系统。我用的是搬瓦工的服务器，打开管理界面，我选择的是 centos-7-x86_64-bbr&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://liuqinh2s.github.io/blog/categories/Linux/"/>
    
    
  </entry>
  
  <entry>
    <title>浏览器上的几种xy坐标</title>
    <link href="https://liuqinh2s.github.io/blog/2022/06/09/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8A%E7%9A%84%E5%87%A0%E7%A7%8Dxy%E5%9D%90%E6%A0%87/"/>
    <id>https://liuqinh2s.github.io/blog/2022/06/09/浏览器上的几种xy坐标/</id>
    <published>2022-06-08T16:00:00.000Z</published>
    <updated>2022-06-11T04:30:57.063Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;有如下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/screenX&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;screenX&lt;/a&gt;, screenY&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/clientX&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;clientX&lt;/a&gt;, clientY&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/pageX&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pageX&lt;/a&gt;, pageY&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/offsetX&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;offsetX&lt;/a&gt;, offsetY&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="前端" scheme="https://liuqinh2s.github.io/blog/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>生成固定长度的字符串</title>
    <link href="https://liuqinh2s.github.io/blog/2022/06/09/%E7%94%9F%E6%88%90%E5%9B%BA%E5%AE%9A%E9%95%BF%E5%BA%A6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://liuqinh2s.github.io/blog/2022/06/09/生成固定长度的字符串/</id>
    <published>2022-06-08T16:00:00.000Z</published>
    <updated>2022-06-11T04:30:57.063Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;前端一般都要应对各种各样的用户输入，比如限制用户输入的字符串长度不超过 255 个字符。那么我自己测试的时候，去哪里弄个 256 长度的字符串呢，作为一个程序员，当然是自己写代码生成。下面我就来罗列一下有哪些方法可以实现这个需求。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="https://liuqinh2s.github.io/blog/categories/JavaScript/"/>
    
    
  </entry>
  
  <entry>
    <title>二分查找</title>
    <link href="https://liuqinh2s.github.io/blog/2022/06/08/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>https://liuqinh2s.github.io/blog/2022/06/08/二分查找/</id>
    <published>2022-06-07T16:00:00.000Z</published>
    <updated>2022-06-08T00:36:09.578Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;什么是二分查找：二分查找每次只查询 mid（数组最中间的数），如果没找到目标，就缩小区间，根据 mid 和目标数对比，只搜左半区间或右半区间。&lt;/p&gt;
&lt;p&gt;二分查找的前提：&lt;strong&gt;数据有序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;二分查找结束的条件：查找区间为空，或者找到元素&lt;/p&gt;
&lt;p&gt;二分查找的条件分支：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;nums[mid]==target&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nums[mid]&amp;lt;target&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nums[mid]&amp;gt;target&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;二分查找的搜索区间表示形式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;左闭右开（区间为空的条件是 left==right）&lt;/li&gt;
&lt;li&gt;左闭右闭（区间为空的条件是 left&amp;gt;right）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;二分查找有的时候我会写出死循环来，仔细思考了一下：&lt;strong&gt;必须每次收缩边界的时候，都排除掉 mid，完全避免 mid 被重复查的可能&lt;/strong&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://liuqinh2s.github.io/blog/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>浏览器 storage 事件</title>
    <link href="https://liuqinh2s.github.io/blog/2022/06/08/%E6%B5%8F%E8%A7%88%E5%99%A8storage%E4%BA%8B%E4%BB%B6/"/>
    <id>https://liuqinh2s.github.io/blog/2022/06/08/浏览器storage事件/</id>
    <published>2022-06-07T16:00:00.000Z</published>
    <updated>2022-06-11T04:30:57.063Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;官方文档：&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/Window/storage_event&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://developer.mozilla.org/zh-CN/docs/Web/API/Window/storage_event&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在使用 storage 事件的时候，我发现了两个不符合我直觉的特性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在本窗口修改存储区域（localStorage 或 sessionStorage）时，本窗口的监听无效&lt;/li&gt;
&lt;li&gt;必须写入与旧值不同的值，才能监听到&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我自己写代码测试了以上两个特点，但疑惑的是中文文档里面什么都没讲，原来英文文档里面说了这两点，MDN 的中文文档和英文文档并不是翻译关系，完全就是另写的。所以如果觉得文档有问题，还是切换到英文看吧。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://liuqinh2s.github.io/blog/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>如何学习</title>
    <link href="https://liuqinh2s.github.io/blog/2021/08/22/%E5%A6%82%E4%BD%95%E5%AD%A6%E4%B9%A0/"/>
    <id>https://liuqinh2s.github.io/blog/2021/08/22/如何学习/</id>
    <published>2021-08-21T16:00:00.000Z</published>
    <updated>2022-06-08T00:29:56.975Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章的思想来自于这位博主：&lt;a href=&quot;https://space.bilibili.com/344849038/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;bilibili-YJango&lt;/a&gt;，我觉得很受启发就将其简略写了下来。&lt;/p&gt;
&lt;h3 id=&quot;什么是学习？&quot;&gt;&lt;a href=&quot;#什么是学习？&quot; class=&quot;headerlink&quot; title=&quot;什么是学习？&quot;&gt;&lt;/a&gt;什么是学习？&lt;/h3&gt;&lt;p&gt;学习 vs 记忆&lt;/p&gt;
&lt;p&gt;记忆：容量有限、难以集齐&lt;/p&gt;
&lt;p&gt;学习：从有限的例子中找出问题和答案的规律：知识&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;费曼说：如果你没有办法用简单的语言描述所学的知识，你就没有真正学会它。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因为学习是用知识来压缩原本无限的信息&lt;/p&gt;
&lt;p&gt;学习：找出知识、压缩信息&lt;/p&gt;
    
    </summary>
    
      <category term="方法论" scheme="https://liuqinh2s.github.io/blog/categories/%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>快速排序最坏的情况啥时候出现</title>
    <link href="https://liuqinh2s.github.io/blog/2021/06/28/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E6%9C%80%E5%9D%8F%E7%9A%84%E6%83%85%E5%86%B5%E5%95%A5%E6%97%B6%E5%80%99%E5%87%BA%E7%8E%B0/"/>
    <id>https://liuqinh2s.github.io/blog/2021/06/28/快速排序最坏的情况啥时候出现/</id>
    <published>2021-06-27T16:00:00.000Z</published>
    <updated>2022-06-07T15:05:55.195Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;在面试富途的时候面试官问了这样一个问题：快速排序最坏的情况啥时候出现？当时没有答上来。实际上这个问题比较容易想清楚，思路如下，从快速排序的形式入手：$O(N*logN)$，N 代表单次排序的时间花销，logN
        
      
    
    </summary>
    
      <category term="算法" scheme="https://liuqinh2s.github.io/blog/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>智能合约入门</title>
    <link href="https://liuqinh2s.github.io/blog/2021/06/28/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%85%A5%E9%97%A8/"/>
    <id>https://liuqinh2s.github.io/blog/2021/06/28/智能合约入门/</id>
    <published>2021-06-27T16:00:00.000Z</published>
    <updated>2022-06-07T15:06:42.575Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;前言&lt;br&gt;从 2017 年开始买比特币的时候，我就想学习智能合约相关的开发，也曾想过要投身区块链行业，这一拖就是 4 年。我认真开始学起智能合约，最主要的原因其实是因为我离它更近了。这一轮牛市，DEFI 火爆，让我学会了使用钱包和公链。而在去年，我还是个只会在 OTC 入金的傻子，库币的 OTC 定价那么不合理都只会用 OTC 入金，后来我才发现原来 USDT 可以随意在链上转，而且波场免手续费，由此打开了新世界的大门。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="币圈" scheme="https://liuqinh2s.github.io/blog/categories/%E5%B8%81%E5%9C%88/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode每日一题：474. 一和零</title>
    <link href="https://liuqinh2s.github.io/blog/2021/06/06/leetcode-470-%E4%B8%80%E5%92%8C%E9%9B%B6/"/>
    <id>https://liuqinh2s.github.io/blog/2021/06/06/leetcode-470-一和零/</id>
    <published>2021-06-05T16:00:00.000Z</published>
    <updated>2022-06-07T14:14:52.792Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;474-一和零&quot;&gt;&lt;a href=&quot;#474-一和零&quot; class=&quot;headerlink&quot; title=&quot;474. 一和零&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/ones-and-zeroes/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;474. 一和零&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;一道动态规划题目。&lt;/p&gt;
&lt;p&gt;首先要明白这是一道背包问题，而且是双维度的，可以装0和1。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://liuqinh2s.github.io/blog/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode每日一题：203. 移除链表元素</title>
    <link href="https://liuqinh2s.github.io/blog/2021/06/05/leetcode-230-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0/"/>
    <id>https://liuqinh2s.github.io/blog/2021/06/05/leetcode-230-移除链表元素/</id>
    <published>2021-06-04T16:00:00.000Z</published>
    <updated>2022-06-07T14:14:52.792Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;203-移除链表元素&quot;&gt;&lt;a href=&quot;#203-移除链表元素&quot; class=&quot;headerlink&quot; title=&quot;203. 移除链表元素&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/remove-linked-list-elements/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;203. 移除链表元素&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;很简单的一道删除单链表节点题&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://liuqinh2s.github.io/blog/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode每日一题：160. 相交链表</title>
    <link href="https://liuqinh2s.github.io/blog/2021/06/04/leetcode-160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8/"/>
    <id>https://liuqinh2s.github.io/blog/2021/06/04/leetcode-160-相交链表/</id>
    <published>2021-06-03T16:00:00.000Z</published>
    <updated>2022-06-07T14:14:52.792Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;160-相交链表&quot;&gt;&lt;a href=&quot;#160-相交链表&quot; class=&quot;headerlink&quot; title=&quot;160. 相交链表&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/intersection-of-two-linked-lists/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;160. 相交链表&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;这题有两种解法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;哈希表记录指针&lt;/li&gt;
&lt;li&gt;双指针&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://liuqinh2s.github.io/blog/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode每日一题：525. 连续数组</title>
    <link href="https://liuqinh2s.github.io/blog/2021/06/03/leetcode-525-%E8%BF%9E%E7%BB%AD%E6%95%B0%E7%BB%84/"/>
    <id>https://liuqinh2s.github.io/blog/2021/06/03/leetcode-525-连续数组/</id>
    <published>2021-06-02T16:00:00.000Z</published>
    <updated>2022-06-07T14:14:52.792Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;凡是涉及到连续子数组的，都可以用前缀和+哈希表来解&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;525-连续数组&quot;&gt;&lt;a href=&quot;#525-连续数组&quot; class=&quot;headerlink&quot; title=&quot;525. 连续数组&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/contiguous-array/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;525. 连续数组&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;这题要注意的就是，因为要统计元素个数，所以要使用i+1。&lt;/p&gt;
&lt;p&gt;哈希表的key的含义是：当前遍历到的1与符合标准（一半是1）之间的差距，而记录的位置则必须是最小位置。所以只在初始化的时候赋值。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://liuqinh2s.github.io/blog/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode每日一题： 342. 4的幂</title>
    <link href="https://liuqinh2s.github.io/blog/2021/05/31/leetcode-342-4%E7%9A%84%E5%B9%82/"/>
    <id>https://liuqinh2s.github.io/blog/2021/05/31/leetcode-342-4的幂/</id>
    <published>2021-05-30T16:00:00.000Z</published>
    <updated>2022-06-07T14:14:52.792Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这个问题看起来是个简单题，其实可以从中学到位运算和一些数学知识。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;342-4的幂&quot;&gt;&lt;a href=&quot;#342-4的幂&quot; class=&quot;headerlink&quot; title=&quot;342. 4的幂&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/power-of-four/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;342. 4的幂&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;我自己的解法很简单易懂，但是不够高效：&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://liuqinh2s.github.io/blog/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode： 1074. 元素和为目标值的子矩阵数量</title>
    <link href="https://liuqinh2s.github.io/blog/2021/05/29/leetcode-1074-%E5%85%83%E7%B4%A0%E5%92%8C%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E5%AD%90%E7%9F%A9%E9%98%B5%E6%95%B0%E9%87%8F/"/>
    <id>https://liuqinh2s.github.io/blog/2021/05/29/leetcode-1074-元素和为目标值的子矩阵数量/</id>
    <published>2021-05-28T16:00:00.000Z</published>
    <updated>2022-06-07T14:14:52.791Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这个问题需要拆分出子问题才好解决，要不然没有思路。它的子问题是：&lt;a href=&quot;https://leetcode-cn.com/problems/subarray-sum-equals-k/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;560. 和为K的子数组&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1074-元素和为目标值的子矩阵数量&quot;&gt;&lt;a href=&quot;#1074-元素和为目标值的子矩阵数量&quot; class=&quot;headerlink&quot; title=&quot;1074. 元素和为目标值的子矩阵数量&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/number-of-submatrices-that-sum-to-target/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1074. 元素和为目标值的子矩阵数量&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;当你理解了子问题之后，我们来想想，怎么把这个问题转换到子问题上呢？也就是如何把二维问题变一维问题呢？&lt;/p&gt;
&lt;p&gt;我们想象把一个矩阵的列上的元素全部加起来，不就是一个一维数组了吗。这个一维数组可以等效的应用在这个问题上。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://liuqinh2s.github.io/blog/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode： 560. 和为K的子数组</title>
    <link href="https://liuqinh2s.github.io/blog/2021/05/29/leetcode-560-%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    <id>https://liuqinh2s.github.io/blog/2021/05/29/leetcode-560-和为K的子数组/</id>
    <published>2021-05-28T16:00:00.000Z</published>
    <updated>2022-06-07T14:14:52.792Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这题是在做每日一题中遇到的问题的子问题：&lt;a href=&quot;https://leetcode-cn.com/problems/number-of-submatrices-that-sum-to-target/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1074. 元素和为目标值的子矩阵数量&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;560-和为K的子数组&quot;&gt;&lt;a href=&quot;#560-和为K的子数组&quot; class=&quot;headerlink&quot; title=&quot;560. 和为K的子数组&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/subarray-sum-equals-k/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;560. 和为K的子数组&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;遇到这类问题，首先想的是复杂度，然后复杂度天然是跟问题规模有关的。遍历一遍肯定是必要的，当我们遍历到第n这个位置，我们怎么判断从0到n中有多少个解，进一步的，我们还只要增量数据，n-1的解不应该去重复计算。第n这个位置上的数是一定要考虑进去的，所以我们从后往前寻找。具体代码如下：&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://liuqinh2s.github.io/blog/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode每日一题： 477. 汉明距离总和</title>
    <link href="https://liuqinh2s.github.io/blog/2021/05/28/leetcode-477-%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB%E6%80%BB%E5%92%8C/"/>
    <id>https://liuqinh2s.github.io/blog/2021/05/28/leetcode-477-汉明距离总和/</id>
    <published>2021-05-27T16:00:00.000Z</published>
    <updated>2022-06-07T14:14:52.791Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;leetcode每日一题是leetcode中文版官方推出的活动，每日一题锻炼解决问题的思维能力。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;477-汉明距离总和&quot;&gt;&lt;a href=&quot;#477-汉明距离总和&quot; class=&quot;headerlink&quot; title=&quot;477. 汉明距离总和&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/total-hamming-distance/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;477. 汉明距离总和&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;这题初看上去特别简单，就是一个O(n^2)的遍历（组合），对每一组求汉明距离累加起来。不过我一开始就觉得可能会超时，提交后果然超时了。更优的做法是按位遍历，每一位上所有的数要么是0要么是1，把0和1的个数统计出来，相乘，就是这一位的汉明距离总和。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://liuqinh2s.github.io/blog/categories/leetcode/"/>
    
    
  </entry>
  
  <entry>
    <title>position sticky</title>
    <link href="https://liuqinh2s.github.io/blog/2021/05/28/position-sticky/"/>
    <id>https://liuqinh2s.github.io/blog/2021/05/28/position-sticky/</id>
    <published>2021-05-27T16:00:00.000Z</published>
    <updated>2022-06-07T15:05:28.823Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在做公司项目的过程中遇到一个问题：让表头固定，同时其宽度必须占满整个父元素。用 fixed，可以固定但是宽度无法撑开。最终用&lt;code&gt;position: sticky&lt;/code&gt;解决了问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://www.zhangxinxu.com/wordpress/2018/12/css-position-sticky/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;杀了个回马枪，还是说说 position:sticky 吧« 张鑫旭-鑫空间-鑫生活&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/CSS/position&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;position - CSS（层叠样式表） | MDN&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="css" scheme="https://liuqinh2s.github.io/blog/categories/css/"/>
    
    
  </entry>
  
  <entry>
    <title>leetcode每日一题： 1190. 反转每对括号间的子串</title>
    <link href="https://liuqinh2s.github.io/blog/2021/05/27/leetcode-1190-%E5%8F%8D%E8%BD%AC%E6%AF%8F%E5%AF%B9%E6%8B%AC%E5%8F%B7%E9%97%B4%E7%9A%84%E5%AD%90%E4%B8%B2/"/>
    <id>https://liuqinh2s.github.io/blog/2021/05/27/leetcode-1190-反转每对括号间的子串/</id>
    <published>2021-05-26T16:00:00.000Z</published>
    <updated>2022-06-07T14:14:52.791Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;写之前：&lt;br&gt;2020年整整一年没有写过博客了，沉痛的一年。&lt;br&gt;写博客还是继续下去吧，不管怎样。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;1190-反转每对括号间的子串&quot;&gt;&lt;a href=&quot;#1190-反转每对括号间的子串&quot; class=&quot;headerlink&quot; title=&quot;1190. 反转每对括号间的子串&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/reverse-substrings-between-each-pair-of-parentheses/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1190. 反转每对括号间的子串&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;这道题一看就知道用栈来解决，但具体到怎么做却依旧不容易想通。直到看过答案后，才发现，实际上真的只需要遍历一遍就能解决问题。&lt;/p&gt;
    
    </summary>
    
      <category term="leetcode" scheme="https://liuqinh2s.github.io/blog/categories/leetcode/"/>
    
    
  </entry>
  
</feed>
