<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>liuqinh2s&#39; blog</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://liuqinh2s.github.io/blog/"/>
  <updated>2019-02-19T11:52:51.701Z</updated>
  <id>http://liuqinh2s.github.io/blog/</id>
  
  <author>
    <name>liuqinh2s</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>快速排序</title>
    <link href="http://liuqinh2s.github.io/blog/2019/02/19/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://liuqinh2s.github.io/blog/2019/02/19/快速排序/</id>
    <published>2019-02-18T16:00:00.000Z</published>
    <updated>2019-02-19T11:52:51.701Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;快速排序算法是一个原理非常简单易懂的算法，但如果现场手写的话又有多少人能写得出来呢？我今天又试了一下，发现还是存在一些认知上的问题。首先我明白快排的核心操作是：&lt;strong&gt;选取一个中枢，然后把小于中枢的放到左边，大于中枢的放到右边&lt;/strong&gt;。但我发现时隔仅仅一年多，我居然已经忘了这个操作的英文名字了。直到我在写这篇文章的时候才突然想起来：partition操作。&lt;/p&gt;
&lt;p&gt;在使用partition操作的前提下，递归解决问题就OK了。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://liuqinh2s.github.io/blog/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://liuqinh2s.github.io/blog/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="http://liuqinh2s.github.io/blog/2019/01/19/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://liuqinh2s.github.io/blog/2019/01/19/并查集/</id>
    <published>2019-01-18T16:00:00.000Z</published>
    <updated>2019-02-19T10:52:20.034Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;并查集&quot;&gt;&lt;a href=&quot;#并查集&quot; class=&quot;headerlink&quot; title=&quot;并查集&quot;&gt;&lt;/a&gt;并查集&lt;/h2&gt;&lt;h3 id=&quot;什么是并查集&quot;&gt;&lt;a href=&quot;#什么是并查集&quot; class=&quot;headerlink&quot; title=&quot;什么是并查集&quot;&gt;&lt;/a&gt;什么是并查集&lt;/h3&gt;&lt;p&gt;并查集的核心是&lt;code&gt;parent&lt;/code&gt;指针，一个结点可以找到自己所属的结点。从而把结点&lt;strong&gt;归类&lt;/strong&gt;。有两个核心操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Union（用来合并两个并查集）&lt;/li&gt;
&lt;li&gt;Find（用于查找一个结点的&lt;code&gt;parent&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以并查集可以叫做：union-find data structure。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://liuqinh2s.github.io/blog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>KMP算法</title>
    <link href="http://liuqinh2s.github.io/blog/2019/01/17/KMP%E7%AE%97%E6%B3%95/"/>
    <id>http://liuqinh2s.github.io/blog/2019/01/17/KMP算法/</id>
    <published>2019-01-16T16:00:00.000Z</published>
    <updated>2019-02-19T10:52:20.034Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;KMP算法&quot;&gt;&lt;a href=&quot;#KMP算法&quot; class=&quot;headerlink&quot; title=&quot;KMP算法&quot;&gt;&lt;/a&gt;KMP算法&lt;/h2&gt;&lt;p&gt;KMP算法用来在一个文本中查找模式串，如下图所示：&lt;/p&gt;
&lt;p&gt;文本匹配例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/02/01/5c545a0ceea57.jpg#align=left&amp;amp;display=inline&amp;amp;height=78&amp;amp;linkTarget=_blank&amp;amp;originHeight=78&amp;amp;originWidth=392&amp;amp;width=392&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们把上面那个长字符串的称为&lt;strong&gt;文本&lt;/strong&gt;，下面这个短的称为&lt;strong&gt;模式串&lt;/strong&gt;。我们的目的是查看&lt;code&gt;ABADABAD&lt;/code&gt;是否出现在文本中。&lt;/p&gt;
&lt;p&gt;不必要的比较：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/02/01/5c545a0d27686.jpg#align=left&amp;amp;display=inline&amp;amp;height=100&amp;amp;linkTarget=_blank&amp;amp;originHeight=100&amp;amp;originWidth=418&amp;amp;width=418&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;跳过不必要的比较：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/02/01/5c545a0cf058c.jpg#align=left&amp;amp;display=inline&amp;amp;height=90&amp;amp;linkTarget=_blank&amp;amp;originHeight=90&amp;amp;originWidth=410&amp;amp;width=410&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;KMP算法的核心作用在于帮助模式串顺利的跳过很多不必要的比较（模式串没有任何前缀与文本匹配），直接后移到一部分前缀已经匹配的位置，开始下一次的比较。更准确的讲是移动到：最长真前后缀匹配的位置，如上图所示的&lt;code&gt;ABA&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://liuqinh2s.github.io/blog/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>蓄水池算法</title>
    <link href="http://liuqinh2s.github.io/blog/2019/01/15/%E8%93%84%E6%B0%B4%E6%B1%A0%E7%AE%97%E6%B3%95/"/>
    <id>http://liuqinh2s.github.io/blog/2019/01/15/蓄水池算法/</id>
    <published>2019-01-14T16:00:00.000Z</published>
    <updated>2019-02-19T10:52:20.034Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;蓄水池算法-Reservoir-Sampling&quot;&gt;&lt;a href=&quot;#蓄水池算法-Reservoir-Sampling&quot; class=&quot;headerlink&quot; title=&quot;蓄水池算法(Reservoir Sampling)&quot;&gt;&lt;/a&gt;蓄水池算法(Reservoir Sampling)&lt;/h2&gt;&lt;p&gt;这个算法真的很奇妙，它的核心是一个&lt;strong&gt;数学证明&lt;/strong&gt;。外延，或者说应用场景是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$C_n^k$，也就是从大小为n的样本集中随机取k个不同的样本&lt;/li&gt;
&lt;li&gt;流式数据，或者说无法直接根据索引拿到数据（更加不可能一遍加载到内存）&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="算法" scheme="http://liuqinh2s.github.io/blog/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>自己写json解释器</title>
    <link href="http://liuqinh2s.github.io/blog/2019/01/10/%E8%87%AA%E5%B7%B1%E5%86%99Json%E8%A7%A3%E9%87%8A%E5%99%A8/"/>
    <id>http://liuqinh2s.github.io/blog/2019/01/10/自己写Json解释器/</id>
    <published>2019-01-09T16:00:00.000Z</published>
    <updated>2019-02-19T10:52:20.034Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近发现自己似乎除了公司的项目外，基本没什么别的项目。有一个gitbook正在制作（严格来说并不是项目）：&lt;a href=&quot;https://liuqinh2s.gitbooks.io/leetcode/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;leetcode刷题笔记&lt;/a&gt;。最近一直在语雀上看阮一峰的每周分享，在第四期中看到这个：&lt;a href=&quot;http://seriot.ch/parsing_json.php#1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Douglas Crockford 的名片&lt;/a&gt;。想来想去，觉得可以做几个解析器，比如&lt;strong&gt;json解析器&lt;/strong&gt;，&lt;strong&gt;markdown解析器&lt;/strong&gt;，&lt;strong&gt;正则表达式解析器&lt;/strong&gt;等等，然后可以回过头再去看看编译原理，夯实基础。&lt;/p&gt;
&lt;p&gt;说干就干，先深入了解一下json，并看看别人如何实现json的解析。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.json.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.json.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/28049617&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/28049617&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="项目" scheme="http://liuqinh2s.github.io/blog/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
  </entry>
  
  <entry>
    <title>$\lim\limits_{x\rightarrow 0} \frac{\sin x}{x} = 1$的证明</title>
    <link href="http://liuqinh2s.github.io/blog/2019/01/07/%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%9E%81%E9%99%90%E7%9A%84%E8%AF%81%E6%98%8E/"/>
    <id>http://liuqinh2s.github.io/blog/2019/01/07/第一个极限的证明/</id>
    <published>2019-01-06T16:00:00.000Z</published>
    <updated>2019-02-19T10:52:20.034Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;高数中的第一个证明，可能就是这个$\lim\limits_{x\rightarrow 0} \frac{\sin x}{x} = 1$的证明了。下面给出这个极限的证明，用到了解析几何（作图法）。&lt;/p&gt;
    
    </summary>
    
      <category term="高数" scheme="http://liuqinh2s.github.io/blog/categories/%E9%AB%98%E6%95%B0/"/>
    
      <category term="证明" scheme="http://liuqinh2s.github.io/blog/categories/%E9%AB%98%E6%95%B0/%E8%AF%81%E6%98%8E/"/>
    
    
  </entry>
  
  <entry>
    <title>js实现sleep方法的最佳实践</title>
    <link href="http://liuqinh2s.github.io/blog/2018/11/22/js%E5%AE%9E%E7%8E%B0sleep%E6%96%B9%E6%B3%95%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>http://liuqinh2s.github.io/blog/2018/11/22/js实现sleep方法的最佳实践/</id>
    <published>2018-11-21T16:00:00.000Z</published>
    <updated>2019-02-19T10:52:20.033Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;setTimeout&lt;/code&gt;是异步的，跟其他语言里的&lt;code&gt;sleep&lt;/code&gt;和&lt;code&gt;delay&lt;/code&gt;并不一样，不能阻塞住程序。上网查了之后发现js没有自带的sleep方法，那么如何自己实现sleep方法呢？&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/951021/what-is-the-javascript-version-of-sleep&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;What is the JavaScript version of sleep()?&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://liuqinh2s.github.io/blog/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://liuqinh2s.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>编程珠玑系列笔记 -- 第二章 啊哈！算法</title>
    <link href="http://liuqinh2s.github.io/blog/2018/11/06/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B02/"/>
    <id>http://liuqinh2s.github.io/blog/2018/11/06/编程珠玑系列笔记2/</id>
    <published>2018-11-05T16:00:00.000Z</published>
    <updated>2019-02-19T10:52:20.033Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;本书的另一个中心思想显而易见：&lt;strong&gt;良好的算法是程序性能提升的关键。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面还是通过探讨几个实例，来领会一下算法的重要性。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://liuqinh2s.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《编程珠玑》" scheme="http://liuqinh2s.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91%E3%80%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>编程珠玑系列笔记 -- 第一章 开篇</title>
    <link href="http://liuqinh2s.github.io/blog/2018/11/05/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B01/"/>
    <id>http://liuqinh2s.github.io/blog/2018/11/05/编程珠玑系列笔记1/</id>
    <published>2018-11-04T16:00:00.000Z</published>
    <updated>2019-02-19T10:52:20.033Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;本书的中心思想：&lt;strong&gt;对实例研究的深入思考不仅有趣，而且可以获得实际的益处。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;规律和智慧都隐藏在实例之中，而我们通过实例来窥探它们。实例是道的载体。&lt;/p&gt;
&lt;h2 id=&quot;开篇&quot;&gt;&lt;a href=&quot;#开篇&quot; class=&quot;headerlink&quot; title=&quot;开篇&quot;&gt;&lt;/a&gt;开篇&lt;/h2&gt;&lt;p&gt;明确问题，一旦问题明确，这场战役就成功了90%。&lt;/p&gt;
&lt;p&gt;确定用户的真实需求是程序设计的根本。&lt;/p&gt;
&lt;p&gt;简单的程序通常比具有相同功能的复杂程序更可靠、更安全、更健壮、更高效，而且易于实现和维护。因为简单的程序往往更具有概括性、更抽象、更能洞悉问题的本质。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://liuqinh2s.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《编程珠玑》" scheme="http://liuqinh2s.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91%E3%80%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>什么是回调</title>
    <link href="http://liuqinh2s.github.io/blog/2018/11/04/%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E8%B0%83/"/>
    <id>http://liuqinh2s.github.io/blog/2018/11/04/什么是回调/</id>
    <published>2018-11-03T16:00:00.000Z</published>
    <updated>2019-02-19T10:52:20.032Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/04/5bdeaff01640b.png&quot; alt=&quot;回调2.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;打个比方，有一家旅馆提供叫醒服务，但是要求旅客自己决定叫醒的方法。可以是打客房电话，也可以是派服务员去敲门，睡得死怕耽误事的，还可以要求往自己头上浇盆水。这里，“叫醒”这个行为是旅馆提供的，相当于库函数，但是叫醒的方式是由旅客决定并告诉旅馆的，也就是回调函数。而旅客告诉旅馆怎么叫醒自己的动作，也就是把回调函数传入库函数的动作，称为登记回调函数（to register a callback function）。&lt;/p&gt;
&lt;p&gt;在回调中，我们利用某种方式，把回调函数像参数一样传入中间函数。可以这么理解，在传入一个回调函数之前，中间函数是不完整的。换句话说，程序可以在运行时，通过登记不同的回调函数，来决定、改变中间函数的行为。这就比简单的函数调用要灵活太多了。&lt;/p&gt;
    
    </summary>
    
      <category term="编程概念" scheme="http://liuqinh2s.github.io/blog/categories/%E7%BC%96%E7%A8%8B%E6%A6%82%E5%BF%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>熟练使用JetBrains家的IDE</title>
    <link href="http://liuqinh2s.github.io/blog/2018/11/04/%E7%86%9F%E7%BB%83%E4%BD%BF%E7%94%A8JetBrains%E5%AE%B6%E7%9A%84IDE/"/>
    <id>http://liuqinh2s.github.io/blog/2018/11/04/熟练使用JetBrains家的IDE/</id>
    <published>2018-11-03T16:00:00.000Z</published>
    <updated>2019-02-19T10:52:20.033Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;通用快捷键&quot;&gt;&lt;a href=&quot;#通用快捷键&quot; class=&quot;headerlink&quot; title=&quot;通用快捷键&quot;&gt;&lt;/a&gt;通用快捷键&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;格式化代码（reformat code）:&lt;br&gt;win: ctrl+alt+L&lt;br&gt;mac: command+option+L&lt;/li&gt;
&lt;li&gt;在一行的任意位置使用： shift + enter，新建下一行并跳到下一行。&lt;/li&gt;
&lt;li&gt;善用代码自动补全功能，变量名和方法名等可以用 enter 补全。导入包可以用 alt + enter。&lt;/li&gt;
&lt;li&gt;上下移动代码，ctrl+shift+上下键&lt;/li&gt;
&lt;li&gt;Android Studio 生成函数注释：你在方法前输入/**然后一回车，自动帮你生成方法和参数的注释。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="工具" scheme="http://liuqinh2s.github.io/blog/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="IDE" scheme="http://liuqinh2s.github.io/blog/categories/%E5%B7%A5%E5%85%B7/IDE/"/>
    
    
      <category term="IDE" scheme="http://liuqinh2s.github.io/blog/tags/IDE/"/>
    
  </entry>
  
  <entry>
    <title>精通一款编辑器之sublime text 3</title>
    <link href="http://liuqinh2s.github.io/blog/2018/11/04/%E7%B2%BE%E9%80%9A%E4%B8%80%E6%AC%BE%E7%BC%96%E8%BE%91%E5%99%A8%E4%B9%8Bsublime%20text%203/"/>
    <id>http://liuqinh2s.github.io/blog/2018/11/04/精通一款编辑器之sublime text 3/</id>
    <published>2018-11-03T16:00:00.000Z</published>
    <updated>2019-02-19T10:52:20.033Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;编辑器常用功能&quot;&gt;&lt;a href=&quot;#编辑器常用功能&quot; class=&quot;headerlink&quot; title=&quot;编辑器常用功能&quot;&gt;&lt;/a&gt;编辑器常用功能&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;格式化代码：格式化代码可以让你不用管代码的格式，可以放肆的写程序，你可以少敲很多空格，不用关心代码的格式问题，机器给出的代码格式风格统一且漂亮，一键解决你的格式问题，真是提高码代码效率的非常重要的功能。&lt;/li&gt;
&lt;li&gt;查找文件：查找文件是在集成开发的时候非常重要的功能，当文件多起来的时候，快速定位到文件可以节省很多时间，甚至有时候文件实在太多，你只能通过查找的方式找到那个文件。&lt;/li&gt;
&lt;li&gt;正则全文件查找和替换：轻松让你更改全局变量和配置，这是一个必须的功能，没有它简直无法想象工作量有多大。&lt;/li&gt;
&lt;li&gt;代码收缩和扩展：代码太长怎么办，收缩和扩展啊。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="工具" scheme="http://liuqinh2s.github.io/blog/categories/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="编辑器" scheme="http://liuqinh2s.github.io/blog/categories/%E5%B7%A5%E5%85%B7/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
    
      <category term="编辑器" scheme="http://liuqinh2s.github.io/blog/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>《CSAPP》读书笔记 -- 第4章：处理器体系结构</title>
    <link href="http://liuqinh2s.github.io/blog/2018/10/13/%E5%A4%84%E7%90%86%E5%99%A8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <id>http://liuqinh2s.github.io/blog/2018/10/13/处理器体系结构/</id>
    <published>2018-10-12T16:00:00.000Z</published>
    <updated>2019-02-19T10:52:20.032Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;阅读这篇文章必须要对汇编码有足够的了解，如果你对IA32汇编码还不够了解，可以先看看这篇文章：&lt;a href=&quot;../../08/程序的机器级表示&quot;&gt;程序的机器级表示&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;Y86指令集体系结构&quot;&gt;&lt;a href=&quot;#Y86指令集体系结构&quot; class=&quot;headerlink&quot; title=&quot;Y86指令集体系结构&quot;&gt;&lt;/a&gt;Y86指令集体系结构&lt;/h2&gt;&lt;p&gt;Y86指令集基本上是IA32指令集的一个子集。这个指令集就是我们处理器实现的目标。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;../../../../images/2018/Y86指令集.png&quot; alt=&quot;Y86指令集&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://liuqinh2s.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《CSAPP》" scheme="http://liuqinh2s.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8ACSAPP%E3%80%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>《CSAPP》读书笔记 -- 第3章：程序的机器级表示</title>
    <link href="http://liuqinh2s.github.io/blog/2018/10/08/%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E8%A1%A8%E7%A4%BA/"/>
    <id>http://liuqinh2s.github.io/blog/2018/10/08/程序的机器级表示/</id>
    <published>2018-10-07T16:00:00.000Z</published>
    <updated>2019-02-19T10:52:20.032Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;从编译C语言文件说起&quot;&gt;&lt;a href=&quot;#从编译C语言文件说起&quot; class=&quot;headerlink&quot; title=&quot;从编译C语言文件说起&quot;&gt;&lt;/a&gt;从编译C语言文件说起&lt;/h2&gt;&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ gcc &lt;span class=&quot;number&quot;&gt;-01&lt;/span&gt; -o p p1.c p2.c&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;使用了gcc命令来编译，也可以简单写作：&lt;code&gt;cc&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;优化层级为1，1级是最低的，层级越高程序优化越好，但增加了编译时间，也使调试变得更难，且跟源程序差异很大不便于理解。&lt;/p&gt;
&lt;p&gt;编译的流程是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;预处理器（preprocessor）把诸如：&lt;code&gt;#include&lt;/code&gt;、&lt;code&gt;#define&lt;/code&gt;、&lt;code&gt;#if&lt;/code&gt;、&lt;code&gt;#else&lt;/code&gt;、&lt;code&gt;#elif&lt;/code&gt;、&lt;code&gt;#ifdef&lt;/code&gt;、&lt;code&gt;#endif&lt;/code&gt;等预编译指令替换掉。&lt;/li&gt;
&lt;li&gt;编译器（compiler）把&lt;code&gt;.c&lt;/code&gt;源文件编译成&lt;code&gt;.s&lt;/code&gt;的汇编代码文件。&lt;/li&gt;
&lt;li&gt;汇编器（assembler）把汇编代码文件转换成相应的二进制目标文件&lt;code&gt;.o&lt;/code&gt;，目标文件已经是机器码了，只是没有填入全局变量的地址。&lt;/li&gt;
&lt;li&gt;链接器（linker），把多目标文件和库函数链接在一起，形成可执行文件。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://liuqinh2s.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《CSAPP》" scheme="http://liuqinh2s.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8ACSAPP%E3%80%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>《CSAPP》读书笔记 -- 第2章：浮点数原理（小专题）</title>
    <link href="http://liuqinh2s.github.io/blog/2018/09/27/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://liuqinh2s.github.io/blog/2018/09/27/浮点数原理/</id>
    <published>2018-09-26T16:00:00.000Z</published>
    <updated>2019-02-19T10:52:20.032Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;浮点数的作用&lt;/strong&gt;：区别于整形数，用来表示小数。可以用来表示很大的数，或者非常接近0的小数，或者近似的做实数计算，浮点数的一般形式：$x\times 2^y$。&lt;/p&gt;
&lt;p&gt;IEEE（pronounced “Eye-Triple-Eee”）浮点数标准。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;rounding&lt;/strong&gt;：when a number cannot be represented exactly in the format and hence must be adjusted upward or down- ward。可以翻译为：&lt;strong&gt;舍入&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;十进制的小数表示：$d&lt;em&gt;m d&lt;/em&gt;{m-1} \cdots d&lt;em&gt;1 d_0 . d&lt;/em&gt;{-1} d&lt;em&gt;{-2} \cdots d&lt;/em&gt;{-n}$，写成数学表达式：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
d = \sum_{i=-n}^m 10^i \times d_i&lt;/script&gt;&lt;p&gt;相应的，二进制也可以写成这种形式：&lt;/p&gt;
&lt;script type=&quot;math/tex; mode=display&quot;&gt;
b = \sum_{i=-n}^m 2^i \times b_i&lt;/script&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://liuqinh2s.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《CSAPP》" scheme="http://liuqinh2s.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8ACSAPP%E3%80%8B/"/>
    
    
      <category term="信息记法" scheme="http://liuqinh2s.github.io/blog/tags/%E4%BF%A1%E6%81%AF%E8%AE%B0%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>wsl oh my zsh 字符乱码问题</title>
    <link href="http://liuqinh2s.github.io/blog/2018/09/20/wsl%20oh%20my%20zsh%20%E5%AD%97%E4%BD%93%E9%97%AE%E9%A2%98/"/>
    <id>http://liuqinh2s.github.io/blog/2018/09/20/wsl oh my zsh 字体问题/</id>
    <published>2018-09-19T16:00:00.000Z</published>
    <updated>2019-02-19T10:52:20.032Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装-oh-my-zsh&quot;&gt;&lt;a href=&quot;#安装-oh-my-zsh&quot; class=&quot;headerlink&quot; title=&quot;安装 oh my zsh&quot;&gt;&lt;/a&gt;安装 oh my zsh&lt;/h2&gt;&lt;p&gt;首先检查自己有没有zsh：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;cat /etc/shells&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果有的话就下载&lt;a href=&quot;https://github.com/robbyrussell/oh-my-zsh&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;oh my zsh&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="解决的问题" scheme="http://liuqinh2s.github.io/blog/categories/%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="windows环境" scheme="http://liuqinh2s.github.io/blog/tags/windows%E7%8E%AF%E5%A2%83/"/>
    
      <category term="wsl" scheme="http://liuqinh2s.github.io/blog/tags/wsl/"/>
    
  </entry>
  
  <entry>
    <title>wsl修改右键bash图标</title>
    <link href="http://liuqinh2s.github.io/blog/2018/09/19/wsl%E4%BF%AE%E6%94%B9%E5%8F%B3%E9%94%AEbash%E5%9B%BE%E6%A0%87/"/>
    <id>http://liuqinh2s.github.io/blog/2018/09/19/wsl修改右键bash图标/</id>
    <published>2018-09-18T16:00:00.000Z</published>
    <updated>2019-02-19T10:52:20.031Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;使用 windows subsystem for linux (简称：WSL) 的时候，遇到一个小问题，在文件管理器中右键，唤出bash，发现图标不对：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/09/19/5ba25208ca7de.png&quot; alt=&quot;截图1&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="解决的问题" scheme="http://liuqinh2s.github.io/blog/categories/%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    
    
      <category term="windows环境" scheme="http://liuqinh2s.github.io/blog/tags/windows%E7%8E%AF%E5%A2%83/"/>
    
      <category term="wsl" scheme="http://liuqinh2s.github.io/blog/tags/wsl/"/>
    
  </entry>
  
  <entry>
    <title>《APUE-3rd》 读书笔记 -- File I/O</title>
    <link href="http://liuqinh2s.github.io/blog/2018/05/28/APUE-3rd-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--File-IO/"/>
    <id>http://liuqinh2s.github.io/blog/2018/05/28/APUE-3rd-读书笔记--File-IO/</id>
    <published>2018-05-27T16:00:00.000Z</published>
    <updated>2019-02-19T10:52:20.031Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;这章讲的是文件IO，其中有几个非常重要的概念：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;File Desriptors，文件描述符&lt;/li&gt;
&lt;li&gt;current file offset，当前文件偏移量&lt;/li&gt;
&lt;li&gt;File Sharing Data Structure，文件共享数据模型&lt;/li&gt;
&lt;li&gt;file descriptor flags ，文件描述位&lt;/li&gt;
&lt;li&gt;file status flags ，文件状态位&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://liuqinh2s.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《APUE-3rd》" scheme="http://liuqinh2s.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8AAPUE-3rd%E3%80%8B/"/>
    
    
      <category term="Unix" scheme="http://liuqinh2s.github.io/blog/tags/Unix/"/>
    
      <category term="Linux" scheme="http://liuqinh2s.github.io/blog/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>《APUE-3rd》 读书笔记 -- Unix System Overview</title>
    <link href="http://liuqinh2s.github.io/blog/2018/05/22/APUE-3rd-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0--Unix%20System%20Overview/"/>
    <id>http://liuqinh2s.github.io/blog/2018/05/22/APUE-3rd-读书笔记--Unix System Overview/</id>
    <published>2018-05-21T16:00:00.000Z</published>
    <updated>2019-02-19T10:52:20.031Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Unix系统中非常重要的概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内核&lt;/li&gt;
&lt;li&gt;系统调用&lt;/li&gt;
&lt;li&gt;库函数&lt;/li&gt;
&lt;li&gt;shell&lt;/li&gt;
&lt;li&gt;文件、目录、路径、工作路径、权限管理&lt;/li&gt;
&lt;li&gt;文件描述符&lt;/li&gt;
&lt;li&gt;进程、线程&lt;/li&gt;
&lt;li&gt;错误处理&lt;/li&gt;
&lt;li&gt;信号&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://liuqinh2s.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《APUE-3rd》" scheme="http://liuqinh2s.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8AAPUE-3rd%E3%80%8B/"/>
    
    
      <category term="Unix" scheme="http://liuqinh2s.github.io/blog/tags/Unix/"/>
    
      <category term="Linux" scheme="http://liuqinh2s.github.io/blog/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>mathjax常用公式记录</title>
    <link href="http://liuqinh2s.github.io/blog/2018/04/30/mathjax%E5%B8%B8%E7%94%A8%E5%85%AC%E5%BC%8F%E8%AE%B0%E5%BD%95/"/>
    <id>http://liuqinh2s.github.io/blog/2018/04/30/mathjax常用公式记录/</id>
    <published>2018-04-29T16:00:00.000Z</published>
    <updated>2019-02-19T10:52:20.030Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;角度记法&quot;&gt;&lt;a href=&quot;#角度记法&quot; class=&quot;headerlink&quot; title=&quot;角度记法&quot;&gt;&lt;/a&gt;角度记法&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;度数：&lt;script type=&quot;math/tex&quot;&gt;60^\circ&lt;/script&gt;，$60^\circ$&lt;/li&gt;
&lt;li&gt;度数分：&lt;script type=&quot;math/tex&quot;&gt;60^\prime&lt;/script&gt;，$60^\prime$&lt;/li&gt;
&lt;li&gt;弧度：&lt;script type=&quot;math/tex&quot;&gt;\frac{\pi}{2}&lt;/script&gt;，$\frac{\pi}{2}$&lt;/li&gt;
&lt;li&gt;角度记法：&lt;script type=&quot;math/tex&quot;&gt;\angle A&lt;/script&gt;，$\angle A$&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="LaTex" scheme="http://liuqinh2s.github.io/blog/categories/LaTex/"/>
    
    
  </entry>
  
</feed>
