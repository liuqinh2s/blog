<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>liuqinh2s&#39; blog</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://liuqinh2s.github.io/blog/"/>
  <updated>2019-03-28T08:19:08.269Z</updated>
  <id>http://liuqinh2s.github.io/blog/</id>
  
  <author>
    <name>liuqinh2s</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试题12：打印1到最大的n位数</title>
    <link href="http://liuqinh2s.github.io/blog/2019/03/05/%E9%9D%A2%E8%AF%95%E9%A2%9812%EF%BC%9A%E6%89%93%E5%8D%B01%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/"/>
    <id>http://liuqinh2s.github.io/blog/2019/03/05/面试题12：打印1到最大的n位数/</id>
    <published>2019-03-04T16:00:00.000Z</published>
    <updated>2019-03-28T08:19:08.269Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;输入数字n，按顺序打印出从1到最大的n位十进制数。比如输入3，则打印出1、2、3一直到最大的3位数999。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://liuqinh2s.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《剑指offer》" scheme="http://liuqinh2s.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>面试题11：数值的整数次方</title>
    <link href="http://liuqinh2s.github.io/blog/2019/03/05/%E9%9D%A2%E8%AF%95%E9%A2%9811%EF%BC%9A%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/"/>
    <id>http://liuqinh2s.github.io/blog/2019/03/05/面试题11：数值的整数次方/</id>
    <published>2019-03-04T16:00:00.000Z</published>
    <updated>2019-03-28T07:34:04.835Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;实现函数double Power(double base, int exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://liuqinh2s.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《剑指offer》" scheme="http://liuqinh2s.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>面试题10：二进制中1的个数</title>
    <link href="http://liuqinh2s.github.io/blog/2019/03/04/%E9%9D%A2%E8%AF%95%E9%A2%9810%EF%BC%9A%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>http://liuqinh2s.github.io/blog/2019/03/04/面试题10：二进制中1的个数/</id>
    <published>2019-03-03T16:00:00.000Z</published>
    <updated>2019-03-28T07:33:56.716Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。例如把9表示成二进制是1001，有2位是1。因此如果输入9，该函数输出2。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://liuqinh2s.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《剑指offer》" scheme="http://liuqinh2s.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>面试题8：旋转数组的最小数字</title>
    <link href="http://liuqinh2s.github.io/blog/2019/03/03/%E9%9D%A2%E8%AF%95%E9%A2%988%EF%BC%9A%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
    <id>http://liuqinh2s.github.io/blog/2019/03/03/面试题8：旋转数组的最小数字/</id>
    <published>2019-03-02T16:00:00.000Z</published>
    <updated>2019-03-28T07:36:33.235Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如数组&lt;code&gt;{3,4,5,1,2}&lt;/code&gt;为&lt;code&gt;{1,2,3,4,5}&lt;/code&gt;的一个旋转，该数组的最小值为1。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://liuqinh2s.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《剑指offer》" scheme="http://liuqinh2s.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>动态数组的分摊分析</title>
    <link href="http://liuqinh2s.github.io/blog/2019/03/03/%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%86%E6%91%8A%E5%88%86%E6%9E%90/"/>
    <id>http://liuqinh2s.github.io/blog/2019/03/03/动态数组的分摊分析/</id>
    <published>2019-03-02T16:00:00.000Z</published>
    <updated>2019-03-08T07:33:35.827Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;动态数组在每次容量用尽时，重新申请2倍于当前数组的空间，并将原数组中的内容拷贝到新的空间，然后释放原数组的内存空间。对于动态数组，每次插入的花费有两种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;容量够用，我们只需要存储新的元素&lt;/li&gt;
&lt;li&gt;容量不够用，创建新的空间，拷贝原数组进新的空间，再存储这个新的元素&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;分析方法有许多，统称为：amortized analysis（分摊分析）&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://liuqinh2s.github.io/blog/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>To be a publisher</title>
    <link href="http://liuqinh2s.github.io/blog/2019/03/03/To%20be%20a%20publisher/"/>
    <id>http://liuqinh2s.github.io/blog/2019/03/03/To be a publisher/</id>
    <published>2019-03-02T16:00:00.000Z</published>
    <updated>2019-03-28T07:51:37.721Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;这是我一直以来想写的文章，标题叫：To be a publisher，也就是做一个可以在互联网上产出内容的人。为什么我认为在互联网上产出内容这么重要呢？因为在未来，不能发声的人将无法融入互联网这个新的社会，即便融入了，也只能是那些能够发声的人的附庸。不能表达自己或不善于表达自己这是一件很可怕的事，这类人或许将成为互联网上的哑巴，被忽视的群体，沉默的大多数。&lt;/p&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://liuqinh2s.github.io/blog/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>面试题9：斐波那契数列</title>
    <link href="http://liuqinh2s.github.io/blog/2019/03/03/%E9%9D%A2%E8%AF%95%E9%A2%989%EF%BC%9A%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <id>http://liuqinh2s.github.io/blog/2019/03/03/面试题9：斐波那契数列/</id>
    <published>2019-03-02T16:00:00.000Z</published>
    <updated>2019-03-28T07:37:51.235Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;斐波那契数列的计算非常有意思，因为算法的时间复杂度可以连续优化，最优达到&lt;code&gt;O(logN)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;最简单的是递归计算，时间复杂度是：$O(2^n)$&lt;/p&gt;
&lt;p&gt;然后是迭代（也就是循环）计算，时间复杂度是：$O(n)$&lt;/p&gt;
&lt;p&gt;另外递归+备忘录也可以做到线性的时间复杂度。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://liuqinh2s.github.io/blog/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>面试题7：用两个栈实现队列</title>
    <link href="http://liuqinh2s.github.io/blog/2019/03/02/%E9%9D%A2%E8%AF%95%E9%A2%987%EF%BC%9A%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>http://liuqinh2s.github.io/blog/2019/03/02/面试题7：用两个栈实现队列/</id>
    <published>2019-03-01T16:00:00.000Z</published>
    <updated>2019-03-28T07:35:03.860Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;用两个栈实现一个队列。队列的声明如下，请实现它的两个函数&lt;code&gt;appendTail&lt;/code&gt;和&lt;code&gt;deleteHead&lt;/code&gt;，分别完成在队列尾部插入结点和在队列头部删除结点的功能。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://liuqinh2s.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《剑指offer》" scheme="http://liuqinh2s.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>面试题6：重建二叉树</title>
    <link href="http://liuqinh2s.github.io/blog/2019/03/02/%E9%9D%A2%E8%AF%95%E9%A2%986%EF%BC%9A%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://liuqinh2s.github.io/blog/2019/03/02/面试题6：重建二叉树/</id>
    <published>2019-03-01T16:00:00.000Z</published>
    <updated>2019-03-28T07:34:58.468Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列&lt;code&gt;{1,2,4,7,3,5,6,8}&lt;/code&gt;和中序遍历序列&lt;code&gt;{4,7,2,1,5,3,8,6}&lt;/code&gt;，则重建出图2.6所示的二叉树并输出它的头结点。二叉树定义如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TreeNode&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; val;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TreeNode left;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TreeNode right;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    TreeNode(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        val = x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://liuqinh2s.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《剑指offer》" scheme="http://liuqinh2s.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>面试题4：替换空格</title>
    <link href="http://liuqinh2s.github.io/blog/2019/03/01/%E9%9D%A2%E8%AF%95%E9%A2%984%EF%BC%9A%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
    <id>http://liuqinh2s.github.io/blog/2019/03/01/面试题4：替换空格/</id>
    <published>2019-02-28T16:00:00.000Z</published>
    <updated>2019-03-28T07:36:21.772Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;请实现一个函数，把字符串中的每个空格替换成“%20”。例如输入“We are happy.”，则输出“We%20are%20happy.”。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在网络编程中，如果URL参数中含有特殊字符，如空格、’#’等，可能导致服务器端无法获得正确的参数值。我们需要将这些字符转换为服务器可以识别的字符。转换规则是在’%’后面跟上ASCII码的两位十六进制表示。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://liuqinh2s.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《剑指offer》" scheme="http://liuqinh2s.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>面试题5：从尾到头打印链表</title>
    <link href="http://liuqinh2s.github.io/blog/2019/03/01/%E9%9D%A2%E8%AF%95%E9%A2%985%EF%BC%9A%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <id>http://liuqinh2s.github.io/blog/2019/03/01/面试题5：从尾到头打印链表/</id>
    <published>2019-02-28T16:00:00.000Z</published>
    <updated>2019-03-28T07:34:51.603Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;输入一个链表的头结点，从尾到头反过来打印出每个结点的值。&lt;/p&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://liuqinh2s.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《剑指offer》" scheme="http://liuqinh2s.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>面试题3：二维数组的二分查找</title>
    <link href="http://liuqinh2s.github.io/blog/2019/02/28/%E9%9D%A2%E8%AF%95%E9%A2%983%EF%BC%9A%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>http://liuqinh2s.github.io/blog/2019/02/28/面试题3：二维数组的二分查找/</id>
    <published>2019-02-27T16:00:00.000Z</published>
    <updated>2019-03-28T07:36:07.596Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个二维数组，每一行都是递增的，每一列也都是递增的，且每个数都唯一。然后给一个数，在这个二维数组中查找这个数，如果找到，返回坐标，如果没找到返回&lt;code&gt;(-1,-1)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1 2 6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4 5 9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7 8 10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://liuqinh2s.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《剑指offer》" scheme="http://liuqinh2s.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>岛屿的个数</title>
    <link href="http://liuqinh2s.github.io/blog/2019/02/28/%E5%B2%9B%E5%B1%BF%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>http://liuqinh2s.github.io/blog/2019/02/28/岛屿的个数/</id>
    <published>2019-02-27T16:00:00.000Z</published>
    <updated>2019-03-08T07:33:35.806Z</updated>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;这也是今天面试字节跳动的题目&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在一个 2 维数组中， 1 表示岛，0 表示水，求被水环绕的岛的数量。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;11000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11000&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;00100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;00011&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="算法" scheme="http://liuqinh2s.github.io/blog/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>剑指offer笔记系列--开篇简介</title>
    <link href="http://liuqinh2s.github.io/blog/2019/02/28/%E5%89%91%E6%8C%87offer%E7%AC%94%E8%AE%B0%E7%B3%BB%E5%88%97--%E5%BC%80%E7%AF%87%E7%AE%80%E4%BB%8B/"/>
    <id>http://liuqinh2s.github.io/blog/2019/02/28/剑指offer笔记系列--开篇简介/</id>
    <published>2019-02-27T16:00:00.000Z</published>
    <updated>2019-03-28T07:18:48.912Z</updated>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;今天面试字节跳动公司，问的第一题就是《剑指offer》中的面试题3。所以面试大公司的话最好先刷完这三本书，算法是绕不过去的一关：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《剑指offer》，国内特别喜欢出这个上面的题&lt;/li&gt;
&lt;li&gt;《编程之美》，微软出的&lt;/li&gt;
&lt;li&gt;《程序员面
        
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://liuqinh2s.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="《剑指offer》" scheme="http://liuqinh2s.github.io/blog/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="http://liuqinh2s.github.io/blog/2019/02/19/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://liuqinh2s.github.io/blog/2019/02/19/快速排序/</id>
    <published>2019-02-18T16:00:00.000Z</published>
    <updated>2019-03-08T07:33:35.793Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;快速排序算法是一个原理非常简单易懂的算法，但如果现场手写的话又有多少人能写得出来呢？我今天又试了一下，发现还是存在一些认知上的问题。首先我明白快排的核心操作是：&lt;strong&gt;选取一个中枢，然后把小于中枢的放到左边，大于中枢的放到右边&lt;/strong&gt;。但我发现时隔仅仅一年多，我居然已经忘了这个操作的英文名字了。直到我在写这篇文章的时候才突然想起来：partition操作。&lt;/p&gt;
&lt;p&gt;在使用partition操作的前提下，递归解决问题就OK了。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://liuqinh2s.github.io/blog/categories/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="http://liuqinh2s.github.io/blog/categories/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="http://liuqinh2s.github.io/blog/2019/01/19/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://liuqinh2s.github.io/blog/2019/01/19/并查集/</id>
    <published>2019-01-18T16:00:00.000Z</published>
    <updated>2019-03-08T07:33:35.785Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;并查集&quot;&gt;&lt;a href=&quot;#并查集&quot; class=&quot;headerlink&quot; title=&quot;并查集&quot;&gt;&lt;/a&gt;并查集&lt;/h2&gt;&lt;h3 id=&quot;什么是并查集&quot;&gt;&lt;a href=&quot;#什么是并查集&quot; class=&quot;headerlink&quot; title=&quot;什么是并查集&quot;&gt;&lt;/a&gt;什么是并查集&lt;/h3&gt;&lt;p&gt;并查集的核心是&lt;code&gt;parent&lt;/code&gt;指针，一个结点可以找到自己所属的结点。从而把结点&lt;strong&gt;归类&lt;/strong&gt;。有两个核心操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Union（用来合并两个并查集）&lt;/li&gt;
&lt;li&gt;Find（用于查找一个结点的&lt;code&gt;parent&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以并查集可以叫做：union-find data structure。&lt;/p&gt;
    
    </summary>
    
      <category term="数据结构" scheme="http://liuqinh2s.github.io/blog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
  </entry>
  
  <entry>
    <title>KMP算法</title>
    <link href="http://liuqinh2s.github.io/blog/2019/01/17/KMP%E7%AE%97%E6%B3%95/"/>
    <id>http://liuqinh2s.github.io/blog/2019/01/17/KMP算法/</id>
    <published>2019-01-16T16:00:00.000Z</published>
    <updated>2019-03-08T07:33:35.782Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;KMP算法&quot;&gt;&lt;a href=&quot;#KMP算法&quot; class=&quot;headerlink&quot; title=&quot;KMP算法&quot;&gt;&lt;/a&gt;KMP算法&lt;/h2&gt;&lt;p&gt;KMP算法用来在一个文本中查找模式串，如下图所示：&lt;/p&gt;
&lt;p&gt;文本匹配例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/02/01/5c545a0ceea57.jpg#align=left&amp;amp;display=inline&amp;amp;height=78&amp;amp;linkTarget=_blank&amp;amp;originHeight=78&amp;amp;originWidth=392&amp;amp;width=392&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们把上面那个长字符串的称为&lt;strong&gt;文本&lt;/strong&gt;，下面这个短的称为&lt;strong&gt;模式串&lt;/strong&gt;。我们的目的是查看&lt;code&gt;ABADABAD&lt;/code&gt;是否出现在文本中。&lt;/p&gt;
&lt;p&gt;不必要的比较：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/02/01/5c545a0d27686.jpg#align=left&amp;amp;display=inline&amp;amp;height=100&amp;amp;linkTarget=_blank&amp;amp;originHeight=100&amp;amp;originWidth=418&amp;amp;width=418&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;跳过不必要的比较：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/02/01/5c545a0cf058c.jpg#align=left&amp;amp;display=inline&amp;amp;height=90&amp;amp;linkTarget=_blank&amp;amp;originHeight=90&amp;amp;originWidth=410&amp;amp;width=410&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;KMP算法的核心作用在于帮助模式串顺利的跳过很多不必要的比较（模式串没有任何前缀与文本匹配），直接后移到一部分前缀已经匹配的位置，开始下一次的比较。更准确的讲是移动到：最长真前后缀匹配的位置，如上图所示的&lt;code&gt;ABA&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://liuqinh2s.github.io/blog/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>蓄水池算法</title>
    <link href="http://liuqinh2s.github.io/blog/2019/01/15/%E8%93%84%E6%B0%B4%E6%B1%A0%E7%AE%97%E6%B3%95/"/>
    <id>http://liuqinh2s.github.io/blog/2019/01/15/蓄水池算法/</id>
    <published>2019-01-14T16:00:00.000Z</published>
    <updated>2019-03-08T07:33:35.775Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;蓄水池算法-Reservoir-Sampling&quot;&gt;&lt;a href=&quot;#蓄水池算法-Reservoir-Sampling&quot; class=&quot;headerlink&quot; title=&quot;蓄水池算法(Reservoir Sampling)&quot;&gt;&lt;/a&gt;蓄水池算法(Reservoir Sampling)&lt;/h2&gt;&lt;p&gt;这个算法真的很奇妙，它的核心是一个&lt;strong&gt;数学证明&lt;/strong&gt;。外延，或者说应用场景是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$C_n^k$，也就是从大小为n的样本集中随机取k个不同的样本&lt;/li&gt;
&lt;li&gt;流式数据，或者说无法直接根据索引拿到数据（更加不可能一遍加载到内存）&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="算法" scheme="http://liuqinh2s.github.io/blog/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>自己写json解释器</title>
    <link href="http://liuqinh2s.github.io/blog/2019/01/10/%E8%87%AA%E5%B7%B1%E5%86%99Json%E8%A7%A3%E9%87%8A%E5%99%A8/"/>
    <id>http://liuqinh2s.github.io/blog/2019/01/10/自己写Json解释器/</id>
    <published>2019-01-09T16:00:00.000Z</published>
    <updated>2019-03-08T07:33:35.770Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近发现自己似乎除了公司的项目外，基本没什么别的项目。有一个gitbook正在制作（严格来说并不是项目）：&lt;a href=&quot;https://liuqinh2s.gitbooks.io/leetcode/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;leetcode刷题笔记&lt;/a&gt;。最近一直在语雀上看阮一峰的每周分享，在第四期中看到这个：&lt;a href=&quot;http://seriot.ch/parsing_json.php#1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Douglas Crockford 的名片&lt;/a&gt;。想来想去，觉得可以做几个解析器，比如&lt;strong&gt;json解析器&lt;/strong&gt;，&lt;strong&gt;markdown解析器&lt;/strong&gt;，&lt;strong&gt;正则表达式解析器&lt;/strong&gt;等等，然后可以回过头再去看看编译原理，夯实基础。&lt;/p&gt;
&lt;p&gt;说干就干，先深入了解一下json，并看看别人如何实现json的解析。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.json.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.json.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/28049617&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/28049617&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="动手实践" scheme="http://liuqinh2s.github.io/blog/categories/%E5%8A%A8%E6%89%8B%E5%AE%9E%E8%B7%B5/"/>
    
    
  </entry>
  
  <entry>
    <title>$\lim\limits_{x\rightarrow 0} \frac{\sin x}{x} = 1$的证明</title>
    <link href="http://liuqinh2s.github.io/blog/2019/01/07/%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%9E%81%E9%99%90%E7%9A%84%E8%AF%81%E6%98%8E/"/>
    <id>http://liuqinh2s.github.io/blog/2019/01/07/第一个极限的证明/</id>
    <published>2019-01-06T16:00:00.000Z</published>
    <updated>2019-03-08T07:33:35.764Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;高数中的第一个证明，可能就是这个$\lim\limits_{x\rightarrow 0} \frac{\sin x}{x} = 1$的证明了。下面给出这个极限的证明，用到了解析几何（作图法）。&lt;/p&gt;
    
    </summary>
    
      <category term="数学" scheme="http://liuqinh2s.github.io/blog/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
  </entry>
  
</feed>
