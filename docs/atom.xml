<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>liuqinh2s&#39; blog</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://liuqinh2s.github.io/blog/"/>
  <updated>2019-04-22T09:42:46.822Z</updated>
  <id>http://liuqinh2s.github.io/blog/</id>
  
  <author>
    <name>liuqinh2s</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机硬件结构</title>
    <link href="http://liuqinh2s.github.io/blog/2019/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <id>http://liuqinh2s.github.io/blog/2019/04/22/计算机硬件结构/</id>
    <published>2019-04-21T16:00:00.000Z</published>
    <updated>2019-04-22T09:42:46.822Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;冯·诺依曼结构&quot;&gt;&lt;a href=&quot;#冯·诺依曼结构&quot; class=&quot;headerlink&quot; title=&quot;冯·诺依曼结构&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%86%AF%C2%B7%E8%AF%BA%E4%BC%8A%E6%9B%BC%E7%BB%93%E6%9E%84&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;冯·诺依曼结构&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;冯·诺伊曼结构与 &lt;strong&gt;存储程序型计算机&lt;/strong&gt; 是互相通用的名词&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;哈佛结构&lt;/strong&gt; 是一种将程序数据与普通数据分开存储的设计概念，可以说是冯·诺依曼结构的一种。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;存储程序计算机在体系结构上主要特点有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以运算单元为中心&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;采用存储程序原理&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;存储器是按地址访问、线性编址的空间&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;控制流由指令流产生&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;指令由 &lt;strong&gt;操作码&lt;/strong&gt; 和 &lt;strong&gt;地址码&lt;/strong&gt; 组成&lt;/li&gt;
&lt;li&gt;数据以二进制编码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;五个组成部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存储器&lt;/li&gt;
&lt;li&gt;控制器&lt;/li&gt;
&lt;li&gt;运算器（算术逻辑单元）&lt;/li&gt;
&lt;li&gt;输入&lt;/li&gt;
&lt;li&gt;输出&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="从零开始学习计算机" scheme="http://liuqinh2s.github.io/blog/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>什么是字符集和编码</title>
    <link href="http://liuqinh2s.github.io/blog/2019/04/21/%E4%BB%80%E4%B9%88%E6%98%AF%E5%AD%97%E7%AC%A6%E9%9B%86%E5%92%8C%E7%BC%96%E7%A0%81/"/>
    <id>http://liuqinh2s.github.io/blog/2019/04/21/什么是字符集和编码/</id>
    <published>2019-04-20T16:00:00.000Z</published>
    <updated>2019-04-22T04:36:45.099Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;文本文件中，为了让比特表示文字，我们发明了字符集，让特定的比特序列对应特定的字符。&lt;/p&gt;
&lt;p&gt;常见的字符集有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/ASCII&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ASCII&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/EASCII&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;EASCII&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/GB_2312&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GB2312&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/%E6%B1%89%E5%AD%97%E5%86%85%E7%A0%81%E6%89%A9%E5%B1%95%E8%A7%84%E8%8C%83&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GBK&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/wiki/Unicode&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Unicode&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.wikipedia.org/zh/UTF-8&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;UTF-8&lt;/a&gt; （严格来说UTF-8只是Unicode的一种编码方式）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://baike.baidu.com/item/ANSI%E7%BC%96%E7%A0%81&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ANSI编码&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="从零开始学习计算机" scheme="http://liuqinh2s.github.io/blog/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>计算机中的信息</title>
    <link href="http://liuqinh2s.github.io/blog/2019/04/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF/"/>
    <id>http://liuqinh2s.github.io/blog/2019/04/21/计算机中的信息/</id>
    <published>2019-04-20T16:00:00.000Z</published>
    <updated>2019-04-22T02:44:55.996Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;信息的本质&quot;&gt;&lt;a href=&quot;#信息的本质&quot; class=&quot;headerlink&quot; title=&quot;信息的本质&quot;&gt;&lt;/a&gt;信息的本质&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;信息的本质是消除不确定性&lt;/strong&gt;：我们抛掷一枚硬币，然后用手盖住，出现正面朝上和反面朝上的概率都是二分之一。当我们偷看了结果，确定了是正面还是反面朝上，也就获得了信息。在这个例子中，我们消除的不确定性是一个二分之一的概率。在 &lt;strong&gt;&lt;a href=&quot;https://zh.wikipedia.org/zh-hans/%E5%85%8B%E5%8A%B3%E5%BE%B7%C2%B7%E9%A6%99%E5%86%9C&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;香农&lt;/a&gt;&lt;/strong&gt; 划时代的论文 &lt;strong&gt;&lt;a href=&quot;http://math.harvard.edu/~ctm/home/text/others/shannon/entropy/entropy.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;通信的数学原理&lt;/a&gt;&lt;/strong&gt; 中，首次提出了信息是可量化的，以及如何量化信息。我们以bit为信息的度量单位，一个bit可以是0或者1，我们每获得一个bit的信息，就会消除一个二分之一的不确定性。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;小思考题：如果我们抛掷的是一个骰子呢，当我们确定了一次投掷结果，我们获得多少信息（用bit为单位衡量）？&lt;br&gt;我们都知道，骰子有6个面，分别刻有1~6，我们有六分之一的概率得到其中任意一个面朝上。那么我们获得的信息应该是：$\log_2 6$。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="从零开始学习计算机" scheme="http://liuqinh2s.github.io/blog/categories/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
  </entry>
  
  <entry>
    <title>记录一些不错的网站</title>
    <link href="http://liuqinh2s.github.io/blog/2019/04/20/%E8%AE%B0%E5%BD%95%E4%B8%80%E4%BA%9B%E4%B8%8D%E9%94%99%E7%9A%84%E7%BD%91%E7%AB%99/"/>
    <id>http://liuqinh2s.github.io/blog/2019/04/20/记录一些不错的网站/</id>
    <published>2019-04-19T16:00:00.000Z</published>
    <updated>2019-04-22T02:34:22.153Z</updated>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.shuge.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;有品格的数字古籍图书馆&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://landgreen.github.io/physics/index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;physics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://tubeheartbeat.com/london/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Tube Heartbeat&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://winds.getstream.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;RSS聚合订阅网站&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://my-music-diary.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;My Music Diary&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.crypto101.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CRYPTO101&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://static.icybear.net/%5BCN%5DProgrammer%20competency%20matrix.htm&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Programmer Competency Matrix&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://thetreeographer.com/archive/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;世界上最古老的树有哪些&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://learnopengl-cn.github.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;OpenGL 入门&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://ctf-wiki.github.io/ctf-wiki/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CTF wiki&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://teachyourselfcs.com/#programming&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Teach Yourself Computer Science&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="推荐" scheme="http://liuqinh2s.github.io/blog/categories/%E6%8E%A8%E8%8D%90/"/>
    
      <category term="网站" scheme="http://liuqinh2s.github.io/blog/categories/%E6%8E%A8%E8%8D%90/%E7%BD%91%E7%AB%99/"/>
    
    
  </entry>
  
  <entry>
    <title>hexo把英文引号渲染成中文引号的问题</title>
    <link href="http://liuqinh2s.github.io/blog/2019/04/15/hexo%E6%8A%8A%E8%8B%B1%E6%96%87%E5%BC%95%E5%8F%B7%E6%B8%B2%E6%9F%93%E6%88%90%E4%B8%AD%E6%96%87%E5%BC%95%E5%8F%B7%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://liuqinh2s.github.io/blog/2019/04/15/hexo把英文引号渲染成中文引号的问题/</id>
    <published>2019-04-14T16:00:00.000Z</published>
    <updated>2019-04-22T02:34:22.150Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;其实这个问题我早就发现了，但一直没太在意，今天写博客的时候又看到这个难看的引号，终于忍不住想看看到底出了什么问题。&lt;/p&gt;
&lt;p&gt;首先我试了中文的单引号和英文的单引号，发现渲染效果都一样，然后想看看当我分别打中文单引号和英文单引号的时候，hexo的渲染结果到底是不是一样。&lt;/p&gt;
&lt;p&gt;打开chrome开发工具，发现页面上的英文单引号统一被渲染成了中文的单引号。&lt;/p&gt;
&lt;p&gt;然后我手动修改页面看了下英文单引号是什么样子，发现样式确实很不一样。&lt;/p&gt;
&lt;p&gt;那么问题就确定了：hexo把英文引号渲染成了中文引号。&lt;/p&gt;
    
    </summary>
    
    
      <category term="fixed issues" scheme="http://liuqinh2s.github.io/blog/tags/fixed-issues/"/>
    
  </entry>
  
  <entry>
    <title>C++ map的remove函数实现</title>
    <link href="http://liuqinh2s.github.io/blog/2019/04/15/C++%20map%E7%9A%84remove%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0/"/>
    <id>http://liuqinh2s.github.io/blog/2019/04/15/C++ map的remove函数实现/</id>
    <published>2019-04-14T16:00:00.000Z</published>
    <updated>2019-04-22T02:34:22.147Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;今天同学群里面讨论了这样一段代码，说是产品出了bug，现场急着修复。&lt;/p&gt;
    
    </summary>
    
    
      <category term="fixed issues" scheme="http://liuqinh2s.github.io/blog/tags/fixed-issues/"/>
    
  </entry>
  
  <entry>
    <title>To be a publisher</title>
    <link href="http://liuqinh2s.github.io/blog/2019/03/03/To%20be%20a%20publisher/"/>
    <id>http://liuqinh2s.github.io/blog/2019/03/03/To be a publisher/</id>
    <published>2019-03-02T16:00:00.000Z</published>
    <updated>2019-04-22T02:34:22.142Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;这是我一直以来想写的文章，标题叫：To be a publisher，也就是做一个可以在互联网上产出内容的人。为什么我认为在互联网上产出内容这么重要呢？因为在未来，不能发声的人将无法融入互联网这个新的社会，即便融入了，也只能是那些能够发声的人的附庸。不能表达自己或不善于表达自己这是一件很可怕的事，这类人或许将成为互联网上的哑巴，被忽视的群体，沉默的大多数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Methodology" scheme="http://liuqinh2s.github.io/blog/tags/Methodology/"/>
    
  </entry>
  
  <entry>
    <title>动态数组的分摊分析</title>
    <link href="http://liuqinh2s.github.io/blog/2019/03/03/%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%86%E6%91%8A%E5%88%86%E6%9E%90/"/>
    <id>http://liuqinh2s.github.io/blog/2019/03/03/动态数组的分摊分析/</id>
    <published>2019-03-02T16:00:00.000Z</published>
    <updated>2019-04-22T02:34:22.144Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;动态数组在每次容量用尽时，重新申请2倍于当前数组的空间，并将原数组中的内容拷贝到新的空间，然后释放原数组的内存空间。对于动态数组，每次插入的花费有两种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;容量够用，我们只需要存储新的元素&lt;/li&gt;
&lt;li&gt;容量不够用，创建新的空间，拷贝原数组进新的空间，再存储这个新的元素&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;分析方法有许多，统称为：amortized analysis（分摊分析）&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://liuqinh2s.github.io/blog/categories/Algorithm/"/>
    
      <category term="Analysis" scheme="http://liuqinh2s.github.io/blog/categories/Algorithm/Analysis/"/>
    
    
  </entry>
  
  <entry>
    <title>推荐一本不错的书：《剑指offer》</title>
    <link href="http://liuqinh2s.github.io/blog/2019/02/28/%E6%8E%A8%E8%8D%90%E4%B8%80%E6%9C%AC%E4%B8%8D%E9%94%99%E7%9A%84%E4%B9%A6%EF%BC%9A%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B/"/>
    <id>http://liuqinh2s.github.io/blog/2019/02/28/推荐一本不错的书：《剑指offer》/</id>
    <published>2019-02-27T16:00:00.000Z</published>
    <updated>2019-04-22T02:34:22.139Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;今天面试字节跳动公司，问的第一题就是《剑指offer》中的面试题3。所以面试大公司的话最好先刷完这三本书，算法是绕不过去的一关：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《剑指offer》，国内特别喜欢出这个上面的题&lt;/li&gt;
&lt;li&gt;《编程之美》，微软出的&lt;/li&gt;
&lt;li&gt;《程序员面试经典》，主要是面向北美和欧洲的程序员&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="推荐" scheme="http://liuqinh2s.github.io/blog/categories/%E6%8E%A8%E8%8D%90/"/>
    
      <category term="书籍" scheme="http://liuqinh2s.github.io/blog/categories/%E6%8E%A8%E8%8D%90/%E4%B9%A6%E7%B1%8D/"/>
    
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="http://liuqinh2s.github.io/blog/2019/02/19/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://liuqinh2s.github.io/blog/2019/02/19/快速排序/</id>
    <published>2019-02-18T16:00:00.000Z</published>
    <updated>2019-04-22T02:34:22.136Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;快速排序算法是一个原理非常简单易懂的算法，但如果现场手写的话又有多少人能写得出来呢？我今天又试了一下，发现还是存在一些认知上的问题。首先我明白快排的核心操作是：&lt;strong&gt;选取一个中枢，然后把小于中枢的放到左边，大于中枢的放到右边&lt;/strong&gt;。但我发现时隔仅仅一年多，我居然已经忘了这个操作的英文名字了。直到我在写这篇文章的时候才突然想起来：partition操作。&lt;/p&gt;
&lt;p&gt;在使用partition操作的前提下，递归解决问题就OK了。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://liuqinh2s.github.io/blog/categories/Algorithm/"/>
    
      <category term="Sort" scheme="http://liuqinh2s.github.io/blog/categories/Algorithm/Sort/"/>
    
    
  </entry>
  
  <entry>
    <title>并查集</title>
    <link href="http://liuqinh2s.github.io/blog/2019/01/19/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://liuqinh2s.github.io/blog/2019/01/19/并查集/</id>
    <published>2019-01-18T16:00:00.000Z</published>
    <updated>2019-04-22T02:34:22.134Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;并查集&quot;&gt;&lt;a href=&quot;#并查集&quot; class=&quot;headerlink&quot; title=&quot;并查集&quot;&gt;&lt;/a&gt;并查集&lt;/h2&gt;&lt;h3 id=&quot;什么是并查集&quot;&gt;&lt;a href=&quot;#什么是并查集&quot; class=&quot;headerlink&quot; title=&quot;什么是并查集&quot;&gt;&lt;/a&gt;什么是并查集&lt;/h3&gt;&lt;p&gt;并查集的核心是&lt;code&gt;parent&lt;/code&gt;指针，一个结点可以找到自己所属的结点。从而把结点&lt;strong&gt;归类&lt;/strong&gt;。有两个核心操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Union（用来合并两个并查集）&lt;/li&gt;
&lt;li&gt;Find（用于查找一个结点的&lt;code&gt;parent&lt;/code&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以并查集可以叫做：union-find data structure。&lt;/p&gt;
    
    </summary>
    
      <category term="Data Structure" scheme="http://liuqinh2s.github.io/blog/categories/Data-Structure/"/>
    
    
  </entry>
  
  <entry>
    <title>KMP算法</title>
    <link href="http://liuqinh2s.github.io/blog/2019/01/17/KMP%E7%AE%97%E6%B3%95/"/>
    <id>http://liuqinh2s.github.io/blog/2019/01/17/KMP算法/</id>
    <published>2019-01-16T16:00:00.000Z</published>
    <updated>2019-04-22T02:34:22.131Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;KMP算法&quot;&gt;&lt;a href=&quot;#KMP算法&quot; class=&quot;headerlink&quot; title=&quot;KMP算法&quot;&gt;&lt;/a&gt;KMP算法&lt;/h2&gt;&lt;p&gt;KMP算法用来在一个文本中查找模式串，如下图所示：&lt;/p&gt;
&lt;p&gt;文本匹配例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/02/01/5c545a0ceea57.jpg#align=left&amp;amp;display=inline&amp;amp;height=78&amp;amp;linkTarget=_blank&amp;amp;originHeight=78&amp;amp;originWidth=392&amp;amp;width=392&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;我们把上面那个长字符串的称为&lt;strong&gt;文本&lt;/strong&gt;，下面这个短的称为&lt;strong&gt;模式串&lt;/strong&gt;。我们的目的是查看&lt;code&gt;ABADABAD&lt;/code&gt;是否出现在文本中。&lt;/p&gt;
&lt;p&gt;不必要的比较：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/02/01/5c545a0d27686.jpg#align=left&amp;amp;display=inline&amp;amp;height=100&amp;amp;linkTarget=_blank&amp;amp;originHeight=100&amp;amp;originWidth=418&amp;amp;width=418&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;跳过不必要的比较：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/02/01/5c545a0cf058c.jpg#align=left&amp;amp;display=inline&amp;amp;height=90&amp;amp;linkTarget=_blank&amp;amp;originHeight=90&amp;amp;originWidth=410&amp;amp;width=410&quot; alt&gt;&lt;/p&gt;
&lt;p&gt;KMP算法的核心作用在于帮助模式串顺利的跳过很多不必要的比较（模式串没有任何前缀与文本匹配），直接后移到一部分前缀已经匹配的位置，开始下一次的比较。更准确的讲是移动到：最长真前后缀匹配的位置，如上图所示的&lt;code&gt;ABA&lt;/code&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://liuqinh2s.github.io/blog/categories/Algorithm/"/>
    
      <category term="String" scheme="http://liuqinh2s.github.io/blog/categories/Algorithm/String/"/>
    
    
  </entry>
  
  <entry>
    <title>蓄水池算法</title>
    <link href="http://liuqinh2s.github.io/blog/2019/01/15/%E8%93%84%E6%B0%B4%E6%B1%A0%E7%AE%97%E6%B3%95/"/>
    <id>http://liuqinh2s.github.io/blog/2019/01/15/蓄水池算法/</id>
    <published>2019-01-14T16:00:00.000Z</published>
    <updated>2019-04-22T02:34:22.129Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;蓄水池算法-Reservoir-Sampling&quot;&gt;&lt;a href=&quot;#蓄水池算法-Reservoir-Sampling&quot; class=&quot;headerlink&quot; title=&quot;蓄水池算法(Reservoir Sampling)&quot;&gt;&lt;/a&gt;蓄水池算法(Reservoir Sampling)&lt;/h2&gt;&lt;p&gt;这个算法真的很奇妙，它的核心是一个&lt;strong&gt;数学证明&lt;/strong&gt;。外延，或者说应用场景是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;$C_n^k$，也就是从大小为n的样本集中随机取k个不同的样本&lt;/li&gt;
&lt;li&gt;流式数据，或者说无法直接根据索引拿到数据（更加不可能一遍加载到内存）&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="http://liuqinh2s.github.io/blog/categories/Algorithm/"/>
    
      <category term="Sample" scheme="http://liuqinh2s.github.io/blog/categories/Algorithm/Sample/"/>
    
    
  </entry>
  
  <entry>
    <title>自己写json解释器</title>
    <link href="http://liuqinh2s.github.io/blog/2019/01/10/%E8%87%AA%E5%B7%B1%E5%86%99Json%E8%A7%A3%E9%87%8A%E5%99%A8/"/>
    <id>http://liuqinh2s.github.io/blog/2019/01/10/自己写Json解释器/</id>
    <published>2019-01-09T16:00:00.000Z</published>
    <updated>2019-04-22T02:34:22.088Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近发现自己似乎除了公司的项目外，基本没什么别的项目。有一个gitbook正在制作（严格来说并不是项目）：&lt;a href=&quot;https://liuqinh2s.gitbooks.io/leetcode/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;leetcode刷题笔记&lt;/a&gt;。最近一直在语雀上看阮一峰的每周分享，在第四期中看到这个：&lt;a href=&quot;http://seriot.ch/parsing_json.php#1&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Douglas Crockford 的名片&lt;/a&gt;。想来想去，觉得可以做几个解析器，比如&lt;strong&gt;json解析器&lt;/strong&gt;，&lt;strong&gt;markdown解析器&lt;/strong&gt;，&lt;strong&gt;正则表达式解析器&lt;/strong&gt;等等，然后可以回过头再去看看编译原理，夯实基础。&lt;/p&gt;
&lt;p&gt;说干就干，先深入了解一下json，并看看别人如何实现json的解析。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.json.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.json.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/28049617&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://zhuanlan.zhihu.com/p/28049617&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Compiler" scheme="http://liuqinh2s.github.io/blog/categories/Compiler/"/>
    
    
      <category term="DIY" scheme="http://liuqinh2s.github.io/blog/tags/DIY/"/>
    
  </entry>
  
  <entry>
    <title>$\lim\limits_{x\rightarrow 0} \frac{\sin x}{x} = 1$的证明</title>
    <link href="http://liuqinh2s.github.io/blog/2019/01/07/%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%9E%81%E9%99%90%E7%9A%84%E8%AF%81%E6%98%8E/"/>
    <id>http://liuqinh2s.github.io/blog/2019/01/07/第一个极限的证明/</id>
    <published>2019-01-06T16:00:00.000Z</published>
    <updated>2019-04-22T02:34:22.085Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;高数中的第一个证明，可能就是这个$\lim\limits_{x\rightarrow 0} \frac{\sin x}{x} = 1$的证明了。下面给出这个极限的证明，用到了解析几何（作图法）。&lt;/p&gt;
    
    </summary>
    
      <category term="Math" scheme="http://liuqinh2s.github.io/blog/categories/Math/"/>
    
      <category term="Calculus" scheme="http://liuqinh2s.github.io/blog/categories/Math/Calculus/"/>
    
    
      <category term="Math" scheme="http://liuqinh2s.github.io/blog/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>js实现sleep方法的最佳实践</title>
    <link href="http://liuqinh2s.github.io/blog/2018/11/22/js%E5%AE%9E%E7%8E%B0sleep%E6%96%B9%E6%B3%95%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>http://liuqinh2s.github.io/blog/2018/11/22/js实现sleep方法的最佳实践/</id>
    <published>2018-11-21T16:00:00.000Z</published>
    <updated>2019-04-22T02:34:22.082Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;setTimeout&lt;/code&gt;是异步的，跟其他语言里的&lt;code&gt;sleep&lt;/code&gt;和&lt;code&gt;delay&lt;/code&gt;并不一样，不能阻塞住程序。上网查了之后发现js没有自带的sleep方法，那么如何自己实现sleep方法呢？&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/951021/what-is-the-javascript-version-of-sleep&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;What is the JavaScript version of sleep()?&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Programming Language" scheme="http://liuqinh2s.github.io/blog/categories/Programming-Language/"/>
    
      <category term="JavaScript" scheme="http://liuqinh2s.github.io/blog/categories/Programming-Language/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://liuqinh2s.github.io/blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>编程珠玑系列笔记 -- 第二章 啊哈！算法</title>
    <link href="http://liuqinh2s.github.io/blog/2018/11/06/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B02/"/>
    <id>http://liuqinh2s.github.io/blog/2018/11/06/编程珠玑系列笔记2/</id>
    <published>2018-11-05T16:00:00.000Z</published>
    <updated>2019-04-22T02:34:22.071Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;本书的另一个中心思想显而易见：&lt;strong&gt;良好的算法是程序性能提升的关键。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下面还是通过探讨几个实例，来领会一下算法的重要性。&lt;/p&gt;
    
    </summary>
    
      <category term="Knowlege of CS" scheme="http://liuqinh2s.github.io/blog/categories/Knowlege-of-CS/"/>
    
    
  </entry>
  
  <entry>
    <title>编程珠玑系列笔记 -- 第一章 开篇</title>
    <link href="http://liuqinh2s.github.io/blog/2018/11/05/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B01/"/>
    <id>http://liuqinh2s.github.io/blog/2018/11/05/编程珠玑系列笔记1/</id>
    <published>2018-11-04T16:00:00.000Z</published>
    <updated>2019-04-22T02:34:22.069Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;本书的中心思想：&lt;strong&gt;对实例研究的深入思考不仅有趣，而且可以获得实际的益处。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;规律和智慧都隐藏在实例之中，而我们通过实例来窥探它们。实例是道的载体。&lt;/p&gt;
&lt;h2 id=&quot;开篇&quot;&gt;&lt;a href=&quot;#开篇&quot; class=&quot;headerlink&quot; title=&quot;开篇&quot;&gt;&lt;/a&gt;开篇&lt;/h2&gt;&lt;p&gt;明确问题，一旦问题明确，这场战役就成功了90%。&lt;/p&gt;
&lt;p&gt;确定用户的真实需求是程序设计的根本。&lt;/p&gt;
&lt;p&gt;简单的程序通常比具有相同功能的复杂程序更可靠、更安全、更健壮、更高效，而且易于实现和维护。因为简单的程序往往更具有概括性、更抽象、更能洞悉问题的本质。&lt;/p&gt;
    
    </summary>
    
      <category term="Knowlege of CS" scheme="http://liuqinh2s.github.io/blog/categories/Knowlege-of-CS/"/>
    
    
  </entry>
  
  <entry>
    <title>什么是回调</title>
    <link href="http://liuqinh2s.github.io/blog/2018/11/04/%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E8%B0%83/"/>
    <id>http://liuqinh2s.github.io/blog/2018/11/04/什么是回调/</id>
    <published>2018-11-03T16:00:00.000Z</published>
    <updated>2019-04-22T02:34:22.060Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://i.loli.net/2018/11/04/5bdeaff01640b.png&quot; alt=&quot;回调2.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;打个比方，有一家旅馆提供叫醒服务，但是要求旅客自己决定叫醒的方法。可以是打客房电话，也可以是派服务员去敲门，睡得死怕耽误事的，还可以要求往自己头上浇盆水。这里，“叫醒”这个行为是旅馆提供的，相当于库函数，但是叫醒的方式是由旅客决定并告诉旅馆的，也就是回调函数。而旅客告诉旅馆怎么叫醒自己的动作，也就是把回调函数传入库函数的动作，称为登记回调函数（to register a callback function）。&lt;/p&gt;
&lt;p&gt;在回调中，我们利用某种方式，把回调函数像参数一样传入中间函数。可以这么理解，在传入一个回调函数之前，中间函数是不完整的。换句话说，程序可以在运行时，通过登记不同的回调函数，来决定、改变中间函数的行为。这就比简单的函数调用要灵活太多了。&lt;/p&gt;
    
    </summary>
    
      <category term="Knowledge of CS" scheme="http://liuqinh2s.github.io/blog/categories/Knowledge-of-CS/"/>
    
    
  </entry>
  
  <entry>
    <title>熟练使用JetBrains家的IDE</title>
    <link href="http://liuqinh2s.github.io/blog/2018/11/04/%E7%86%9F%E7%BB%83%E4%BD%BF%E7%94%A8JetBrains%E5%AE%B6%E7%9A%84IDE/"/>
    <id>http://liuqinh2s.github.io/blog/2018/11/04/熟练使用JetBrains家的IDE/</id>
    <published>2018-11-03T16:00:00.000Z</published>
    <updated>2019-04-22T02:34:22.063Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;通用快捷键&quot;&gt;&lt;a href=&quot;#通用快捷键&quot; class=&quot;headerlink&quot; title=&quot;通用快捷键&quot;&gt;&lt;/a&gt;通用快捷键&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;格式化代码（reformat code）:&lt;br&gt;win: ctrl+alt+L&lt;br&gt;mac: command+option+L&lt;/li&gt;
&lt;li&gt;在一行的任意位置使用： shift + enter，新建下一行并跳到下一行。&lt;/li&gt;
&lt;li&gt;善用代码自动补全功能，变量名和方法名等可以用 enter 补全。导入包可以用 alt + enter。&lt;/li&gt;
&lt;li&gt;上下移动代码，ctrl+shift+上下键&lt;/li&gt;
&lt;li&gt;Android Studio 生成函数注释：你在方法前输入/**然后一回车，自动帮你生成方法和参数的注释。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Skills of Tools" scheme="http://liuqinh2s.github.io/blog/categories/Skills-of-Tools/"/>
    
      <category term="IDE" scheme="http://liuqinh2s.github.io/blog/categories/Skills-of-Tools/IDE/"/>
    
    
      <category term="IDE" scheme="http://liuqinh2s.github.io/blog/tags/IDE/"/>
    
  </entry>
  
</feed>
