{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1523930652086},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1523930652086},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1523930652086},{"_id":"themes/next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1523930652087},{"_id":"themes/next/.DS_Store","hash":"cd93e787c5c507b9da3f7b721b2a38ad7a94e57e","modified":1528550272093},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1523930652087},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1523930652087},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1523930652087},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1523930652088},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1523930652088},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1523930652088},{"_id":"themes/next/README.cn.md","hash":"2c766b3369ed477bce134a5450dab45bef161504","modified":1523930652088},{"_id":"themes/next/README.md","hash":"8ce60ce578963eb4e1eb5e33e1efc2fc4779af9c","modified":1523930652088},{"_id":"themes/next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1523930652089},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1523930652089},{"_id":"themes/next/_config.yml","hash":"2a2eb325246376cbe682677a523d7a8cd3583201","modified":1530405893765},{"_id":"themes/next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1523930652108},{"_id":"source/ComputerScience/index.md","hash":"bca5849def1f7cb335fcb90f023f433b7c63db26","modified":1527999867919},{"_id":"source/Life-Experience/index.md","hash":"6b39ff4b6b88003847e5c57ca89378cbedefed68","modified":1528001885641},{"_id":"source/Math/index.md","hash":"ad8b50ad9f1427b75fe9a20b63cc2302c65ede30","modified":1524816889130},{"_id":"source/_drafts/2018-06-12-《代码整洁之道》读书笔记-第3章-函数.md","hash":"8fa8187c2b7064f9466af9ce68fd0ebb34ec6e84","modified":1529114684311},{"_id":"source/_drafts/2018-06-23-《APUE》笔记-第二章：文件和目录.md","hash":"6a6818326d0c69dd77b9bc64d5099cfec7d8c851","modified":1529747312050},{"_id":"source/_drafts/2018-06-24-计算机专业修养.md","hash":"0dbbfafeb592b61d221c20e0432a5ec6aa2cfa7e","modified":1529848168347},{"_id":"source/_drafts/2018-08-07-Leetcode-804-Unique-Morse-Code-Words.md","hash":"1a698c5408bda9ca98b4907d5db7459b4cf42e93","modified":1533720855191},{"_id":"source/about/index.md","hash":"200d92bc513c9b89936762aa1897e41fb6c79326","modified":1528595357671},{"_id":"source/categories/index.md","hash":"96b3ff010a617bbc24557a7ce58a0bcad616226d","modified":1524532840127},{"_id":"source/tags/index.md","hash":"bf7fe7c3400a6ac05de3536f2bb810842f40bb40","modified":1524532915300},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1523930652086},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"50d48c47162817a3810a9d9ad51104e83947419a","modified":1523930652087},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1523930652087},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1523930652087},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1523930652089},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1523930652089},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1523930652089},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1523930652090},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1523930652090},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1523930652090},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1523930652090},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1523930652090},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1523930652091},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1523930652091},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1523930652091},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1523930652091},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1523930652091},{"_id":"themes/next/languages/zh-Hans.yml","hash":"16ef56d0dea94638de7d200984c90ae56f26b4fe","modified":1523930652092},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1523930652092},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1523930652092},{"_id":"themes/next/layout/_layout.swig","hash":"da0929166674ea637e0ad454f85ad0d7bac4aff2","modified":1523930652092},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1523930652107},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1523930652107},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1523930652107},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1523930652108},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1523930652108},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1523930652108},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1523930652108},{"_id":"themes/next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1523930652109},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1523930652109},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1523930652177},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1523930652178},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1523930652178},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1523930652133},{"_id":"source/_posts/2016/2016-09-30-线性代数笔记--基础篇：行列式、矩阵的本质.md","hash":"cd16a05a98281db0f2e1eeb31e71c2b4298b59fb","modified":1524644509677},{"_id":"source/_posts/2016/2016-09-30-线性代数笔记--线性代数复习核心思想.md","hash":"27cc535ae652db497f6f4fe8258882554d0d98c1","modified":1524652976319},{"_id":"source/_posts/2017/2017-01-01-从windows转用macOSX记录.md","hash":"95f142188969edd22a61379fe68ca1717fe96125","modified":1524642058796},{"_id":"source/_posts/2017/2017-01-02-学习方法总结.md","hash":"6f967f6af606ed2754af801881174b5e0edd0151","modified":1524642000331},{"_id":"source/_posts/2017/2017-01-10-那些年我读过的好故事.md","hash":"cc1316622a527487411b564d54e5afc9516af4d0","modified":1524641965083},{"_id":"source/_posts/2017/2017-01-12-百度贴吧ID挖掘机.md","hash":"5f4c8200e0b9911bc78faab4b8481241ec433649","modified":1524873933697},{"_id":"source/_posts/2017/2017-01-26-游戏人生--探险者的人生手册.md","hash":"400536b400c878962fff7aeef35744f9ed61ebde","modified":1524641958648},{"_id":"source/_posts/2017/2017-02-03-Macbook.md","hash":"1e9d3d02c8f48b0c46884aa3b1a122e13240013a","modified":1524642047091},{"_id":"source/_posts/2017/2017-02-06-我读大学时候的一些思考.md","hash":"edecc0663072eb3a6df1e57d459effbd944f1cff","modified":1524641985260},{"_id":"source/_posts/2017/2017-10-19-Inside-the-C++-Object-Model-系列笔记--Object-Lessons.md","hash":"e33068d6d8293dee2b39961fe50c9e3434a67eb1","modified":1528632175603},{"_id":"source/_posts/2017/2017-10-19-Inside-the-C++-Object-Model-系列笔记--The-Semantics-of-constructors.md","hash":"7e1cf81f9ed7cb9c889aed683c0917b454799570","modified":1528632187219},{"_id":"source/_posts/2017/2017-10-21-Inside-the-C++-Object-Model-系列笔记--The-Semantics-of-Data.md","hash":"b503894e90ba51743e86f7ed72cd7bc833673d4b","modified":1528632199763},{"_id":"source/_posts/2017/2017-10-23-Inside-the-C++-Object-Model-系列笔记--The-Semantics-of-Function.md","hash":"34bfa3df5de8c86a3c65d656ffddbf7492132134","modified":1528632209530},{"_id":"source/_posts/2017/2017-11-14-Override-Overload-Overwrite.md","hash":"c42f19b3f041584cd777b4b3cf7b7e038c09de35","modified":1528632227230},{"_id":"source/_posts/2018/2018-01-20-POJ-1001-Exponentiation.md","hash":"65a19306742fb3db37e9ddce33b3de382bf8b10e","modified":1528631933820},{"_id":"source/_posts/2018/2018-01-21-POJ-1002-487-3279.md","hash":"e18376f41e8120e07c8f551956df9b5ae75154e6","modified":1528631944971},{"_id":"source/_posts/2018/2018-01-21-POJ-1003-Hangover.md","hash":"0a9dcce81b587f9e6e8520e3dfce6fd37e8d7e27","modified":1528631951939},{"_id":"source/_posts/2018/2018-01-21-POJ-1004-Financial-Management.md","hash":"30c1677dfcfecf272d199f230a55f4a017e6a2b1","modified":1528631956818},{"_id":"source/_posts/2018/2018-01-21-POJ-1005-I-Think-I-Need-a-Houseboat.md","hash":"8f66a317c8b1a54848d9b4a8c7e29f23018952e2","modified":1528631961778},{"_id":"source/_posts/2018/2018-02-15-POJ-1006-Biorhythms.md","hash":"b9bb4f4df8d54f602ad474ee024294d7ca2d92dd","modified":1528631966770},{"_id":"source/_posts/2018/2018-02-21-POJ-1007-DNA-sorting.md","hash":"ef1550d0c3316c81a59a4781c5a4698aafeeac28","modified":1528631975570},{"_id":"source/_posts/2018/2018-02-22-POJ-1008-Maya-Calendar.md","hash":"ead9898404261a2de14b2b6d5cd06cac79947b0c","modified":1528631981465},{"_id":"source/_posts/2018/2018-02-24-POJ-1009-Edge-Detection.md","hash":"47b40cb28ec92f5d73c875d1a9e1fd051422af03","modified":1528631990207},{"_id":"source/_posts/2018/2018-02-25-新概念英语四-lesson-03-Matterhorn-Man.md","hash":"cf5b502b97a14fb32b561a3318c0f1ca8582c289","modified":1524492645534},{"_id":"source/_posts/2018/2018-02-27-Java-OutputStream-flush.md","hash":"536d8efd7ee7764a04668e3c1da2f8dbb74a7d51","modified":1524532211280},{"_id":"source/_posts/2018/2018-04-25-Hexo+Markdown+MathJax搭建个人博客.md","hash":"a98b003be258b58c28d214de2da39d3266ee74fe","modified":1524631940655},{"_id":"source/_posts/2018/2018-04-25-数学基础公式推导.md","hash":"ab3e6d07fb40adf76db525bd9b06d71d3191e7c9","modified":1524801626760},{"_id":"source/_posts/2018/2018-04-28-UML图.md","hash":"4cb75b78804bae41ae8bdc06d5e095acc5dfde1e","modified":1533643146704},{"_id":"source/_posts/2018/2018-04-30-Leetcode-Algorithm-274.H-Index.md","hash":"b4c0338bf05065250d9c8d49731cd6ad6d4b1532","modified":1525074077558},{"_id":"source/_posts/2018/2018-04-30-mathjax常用公式记录.md","hash":"0ffff3ed1c32eecb2809e465db7509842eab1193","modified":1525071438698},{"_id":"source/_posts/2018/2018-04-30-椭圆规.md","hash":"7c88836c64e4dbbf9599fef633aa956c0dd55035","modified":1525071068635},{"_id":"source/_posts/2018/2018-05-01-Java-Servlet-学习笔记.md","hash":"b2d4752dd931a67a78e4c09dc8a2630bd2ac988e","modified":1525165348929},{"_id":"source/_posts/2018/2018-05-03-Android通讯录深入研究.md","hash":"72952476ffafb32da0bec58420016eebdad8d87f","modified":1528592753024},{"_id":"source/_posts/2018/2018-05-03-Volley库StringRequest编码问题.md","hash":"fb9aa7bb92bc856a23d7643e540a9103d2256f03","modified":1525351723238},{"_id":"source/_posts/2018/2018-05-04-用ipfs发布博客.md","hash":"7ccb305b8c4bf5deb77f87300d93de917a014128","modified":1525667293734},{"_id":"source/_posts/2018/2018-05-07-对区块链以及未来的一些思考.md","hash":"3928f2da7172abb2e96e51cf4f8570acd4045157","modified":1525686178093},{"_id":"source/_posts/2018/2018-05-08-Linux-Shell-配色.md","hash":"501d4238a36102a23f3fdb8faecca44e5be6d6e8","modified":1525768435427},{"_id":"source/_posts/2018/2018-05-14-投奔vim系列之--NerdTree插件的使用.md","hash":"60ab457cc8036c208131a8e3aa55ef8dbcbb8d1e","modified":1526545387278},{"_id":"source/_posts/2018/2018-05-22-APUE读书笔记--Unix-System-Overview.md","hash":"d6fb4044054d295c20090f5551f6386ea06bf5b7","modified":1527239747231},{"_id":"source/_posts/2018/2018-05-28-APUE读书笔记—File-IO.md","hash":"939d193d3f335d8011da05f2ab85d3b94f48d261","modified":1527995984410},{"_id":"source/_posts/2018/2018-06-03-SQL必知必会.md","hash":"ca1ed64bb09f9bedd6307027e58daa5758f472fe","modified":1529309549007},{"_id":"source/_posts/2018/2018-06-03-哲学思考.md","hash":"1c3fe515836f6038c23f2d558b41862ae0ae2055","modified":1528001324520},{"_id":"source/_posts/2018/2018-06-10-《代码整洁之道》读书笔记-第2章-有意义的命名.md","hash":"1a56f505f24320eab9f73c1603b9644b8dabdd1d","modified":1528638623150},{"_id":"source/_posts/2018/2018-08-07-Leetcode-804-Unique-Morse-Code-Words.md","hash":"9162ffc618f4ac184ab4c88751b0955922a501af","modified":1533720831406},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1523930652092},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1523930652092},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1523930652093},{"_id":"themes/next/layout/_macro/post.swig","hash":"446a35a2cd389f8cfc3aa38973a9b44ad0740134","modified":1524125641084},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1523930652093},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1523930652093},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"6a54c3c85ff6b19d275827a327abbf4bd99b2ebf","modified":1523930652094},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1523930652094},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1523930652094},{"_id":"themes/next/layout/_partials/footer.swig","hash":"c4d6181f5d3db5365e622f78714af8cc58d7a45e","modified":1523935322532},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b94fe8f3279daea5623c49ef4bb35917ba57510","modified":1523930652095},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1523930652095},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1523930652096},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1523930652096},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1523930652096},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1523930652098},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1523930652098},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1523930652099},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1523930652104},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1523930652104},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1523930652104},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1523930652104},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1523930652105},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1523930652105},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1523930652105},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1523930652110},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1523930652110},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1523930652110},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1523930652110},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1523930652110},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1523930652110},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1523930652111},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1523930652111},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1523930652111},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1523930652133},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1523930652134},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1523930652134},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1523930652134},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1523930652134},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1523930652134},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1523930652135},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1523930652135},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1523930652135},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1523930652135},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1523930652135},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1523930652136},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1523930652136},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1523930652136},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1523930652136},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1523930652136},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1523930652136},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1523930652136},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1523930652137},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1523930652099},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1523930652099},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1523930652126},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1523930652126},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1523930652126},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1523930652132},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1523930652133},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1523930652095},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1523930652095},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1523930652096},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1523930652096},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1523930652097},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1523930652097},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1523930652097},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1523930652097},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1523930652098},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1523930652099},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1523930652099},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1523930652099},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1523930652100},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1523930652100},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1523930652100},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1523930652100},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1523930652100},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1523930652101},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1523930652101},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1523930652101},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1523930652101},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1523930652101},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1523930652102},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1523930652102},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1523930652102},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1523930652102},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1523930652102},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1523930652103},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1523930652103},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1523930652103},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1523930652103},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1523957088285},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1523930652104},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1523930652104},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1523930652106},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1523930652106},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1523930652107},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1523930652107},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1523930652126},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1523930652126},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1523930652126},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1523930652126},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1523930652132},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1523930652132},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1523930652133},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1523930652133},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1523930652137},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1523930652137},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1523930652137},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1523930652137},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1523930652138},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1523930652138},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1523930652138},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1523930652138},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1523930652139},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1523930652139},{"_id":"themes/next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1523930652139},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1523930652143},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1523930652146},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1523930652147},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1523930652147},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1523930652151},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1523930652151},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1523930652151},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1523930652151},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1523930652152},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1523930652152},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1523930652153},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1523930652153},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1523930652153},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1523930652147},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1523930652163},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1523930652164},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1523930652164},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1523930652164},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1523930652164},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1523930652164},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1523930652165},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1523930652165},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1523930652165},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1523930652166},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1523930652166},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1523930652166},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1523930652166},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1523930652166},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1523930652166},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1523930652167},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1523930652167},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1523930652167},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1523930652167},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1523930652167},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1523930652168},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1523930652168},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1523930652168},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1523930652168},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1523930652169},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1523930652169},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1523930652169},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1523930652173},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1523930652173},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1523930652177},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1523930652177},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1523930652177},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1523930652163},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1523930652106},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1523930652106},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1523930652111},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1523930652112},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1523930652112},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1523930652112},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1523930652112},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1523930652115},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1523930652120},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1523930652124},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1523930652125},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1523930652125},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1523930652125},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1523930652125},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1523930652125},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1523930652126},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1523930652127},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1523930652127},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1523930652127},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1523930652127},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1523930652128},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1523930652128},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1523930652128},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1523930652128},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1523930652129},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1523930652129},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4aac01962520d60b03b23022ab601ad4bd19c08c","modified":1523930652130},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1523930652130},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1523930652130},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1523930652131},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1523930652131},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1523930652131},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1523930652131},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1523930652132},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1523930652132},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1523930652138},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1523930652142},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1523930652143},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1523930652143},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1523930652147},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1523930652147},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1523930652148},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1523930652148},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1523930652148},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1523930652148},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1523930652150},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1523930652150},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1523930652151},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1523930652152},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1523930652152},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1523930652154},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1523930652154},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1523930652154},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1523930652173},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1523930652173},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1523930652142},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1523930652162},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1523930652162},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1523930652176},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1523930652112},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1523930652113},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1523930652113},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1523930652113},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1523930652113},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1523930652114},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1523930652114},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1523930652114},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1523930652114},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1523930652115},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1523930652115},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1523930652115},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1523930652115},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1523930652115},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1523930652116},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1523930652116},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1523930652116},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1523930652116},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1523930652116},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1523930652116},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1523930652117},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1523930652117},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1523930652117},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1523930652117},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1523930652117},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1523930652117},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1523930652117},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1523930652118},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1523930652118},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1523930652118},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1523930652118},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1523930652118},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1523930652119},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1523930652119},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1523930652119},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1523930652119},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1523930652119},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1523930652120},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1523930652120},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1523930652120},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1523930652120},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1523930652120},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1523930652121},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1523930652121},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1523930652121},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1523930652121},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1523930652122},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1523930652122},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1523930652122},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1523930652122},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1523930652123},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1523930652123},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1523930652123},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1523930652123},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1523930652123},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1523930652124},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1523930652124},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1523930652124},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1523930652129},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1523930652129},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1523930652130},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1523930652140},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1523930652140},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1523930652141},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1523930652141},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1523930652141},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1523930652149},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1523930652149},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1523930652149},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1523930652149},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1523930652150},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1523930652150},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1523930652157},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1523930652156},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1523930652161},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1523930652146},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1523930652172},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1523930652160},{"_id":"public/atom.xml","hash":"055b0beab2d70fccbaf3f74a1814c53fbed4b42f","modified":1536983438953},{"_id":"public/search.xml","hash":"3e1932d3a7acec5eb37343ec8e437406a1307275","modified":1536983438995},{"_id":"public/post-sitemap.xml","hash":"71e4bfd06058cfd019b941a535bce47779ede545","modified":1536983438995},{"_id":"public/page-sitemap.xml","hash":"1c9cb4d7f1471cafff56441e2f5ed089bee40668","modified":1536983438995},{"_id":"public/category-sitemap.xml","hash":"8ddd4fead360c34bc8571826aa74cc301449b22d","modified":1536983438995},{"_id":"public/tag-sitemap.xml","hash":"8170b643f71c482aacc9342b0cc87d966f484592","modified":1536983438995},{"_id":"public/sitemap.xsl","hash":"4321fa69dc1b8811d32b7a1478e5603e038cea1a","modified":1536983438996},{"_id":"public/sitemap.xml","hash":"8a4e1c6a07465c59cdc65f733729868913264994","modified":1536983438996},{"_id":"public/2018/05/03/Volley库StringRequest编码问题/index.html","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1536983439008},{"_id":"public/ComputerScience/index.html","hash":"a5ada9f41b4aa0bb84ccd904b9b8435aa7470697","modified":1536983439008},{"_id":"public/Life-Experience/index.html","hash":"cd587b537e602c5352d3eb65377d639088c4e6f8","modified":1536983439009},{"_id":"public/Math/index.html","hash":"2635da24178b734717c5b6e2cf871740594c5ad8","modified":1536983439009},{"_id":"public/about/index.html","hash":"25cdeccb23f422dbc7c5359d64001c42d2d69ed7","modified":1536983439009},{"_id":"public/categories/index.html","hash":"5ef9a62e470c80ab659307787786bd71af577a15","modified":1536983439009},{"_id":"public/tags/index.html","hash":"50fe9bb72158d5c603bcc85ee165438ff8729e23","modified":1536983439009},{"_id":"public/2018/08/08/Leetcode-804-Unique-Morse-Code-Words/index.html","hash":"95eb83d2c4b6459398872df63f1e6ff9ddf7c365","modified":1536983439009},{"_id":"public/2018/06/10/《代码整洁之道》读书笔记-第2章-有意义的命名/index.html","hash":"1935bbed2141b48736105df4ed712217965bf211","modified":1536983439009},{"_id":"public/2018/06/03/哲学思考/index.html","hash":"f03034913ee739237939d4da3039712793466ffd","modified":1536983439009},{"_id":"public/2018/06/03/SQL必知必会/index.html","hash":"7e87c596a1e2afb6cea6c25353d34db0b8664537","modified":1536983439009},{"_id":"public/2018/05/28/APUE读书笔记—File-IO/index.html","hash":"878dde7cb7690bc25618c46bb721943ba6ac3e2e","modified":1536983439009},{"_id":"public/2018/05/22/APUE读书笔记--Unix-System-Overview/index.html","hash":"43581d439c8d9f93ac68daa90d242f180ab365cb","modified":1536983439009},{"_id":"public/2018/05/14/投奔vim系列之--NerdTree插件的使用/index.html","hash":"77e8d91616540b13d4a888aed58b8c7749411d2d","modified":1536983439009},{"_id":"public/2018/05/08/Linux-Shell-配色/index.html","hash":"e7af1c8ad586b51be318cfcd2672d1b68509b7e0","modified":1536983439009},{"_id":"public/2018/05/07/对区块链以及未来的一些思考/index.html","hash":"ea89faf39fe141da37c8d6bef4f3118ecb7f1f31","modified":1536983439009},{"_id":"public/2018/05/04/用ipfs发布博客/index.html","hash":"c68e56868e853e2e9f28177e29c37a376ee07c50","modified":1536983439010},{"_id":"public/2018/05/03/Android通讯录深入研究/index.html","hash":"8f46a8e01ed6f1cc3b262fa9c42232845198d209","modified":1536983439010},{"_id":"public/2018/05/01/Java-Servlet-学习笔记/index.html","hash":"acb78290fb1affa4f5dc88da4239a42bd8dcb730","modified":1536983439010},{"_id":"public/2018/04/30/椭圆规/index.html","hash":"00f62e0e3c072a2dd05b3e4126f99ac8a8351d60","modified":1536983439010},{"_id":"public/2018/04/30/mathjax常用公式记录/index.html","hash":"93705fd5224ae75fada4390e868dec59c02d0d9d","modified":1536983439010},{"_id":"public/2018/04/30/Leetcode-Algorithm-274.H-Index/index.html","hash":"737b8f5bbc7eca31d34a954faffedcbd951ba765","modified":1536983439010},{"_id":"public/2018/04/28/UML图/index.html","hash":"2f72ca66e62478836ba7d56451e4bc6a903f9630","modified":1536983439010},{"_id":"public/2018/04/25/数学基础公式推导/index.html","hash":"f85c1bb4e6ecb082f2433f06ed02aedbf429c839","modified":1536983439010},{"_id":"public/2018/04/25/Hexo+Markdown+MathJax搭建个人博客/index.html","hash":"e429021646ca63a0edbde6e51a7478e2617a2ae2","modified":1536983439010},{"_id":"public/2018/02/27/Java-OutputStream-flush/index.html","hash":"bac3e156297a3541df423b8ab76d62dc636e9d1f","modified":1536983439010},{"_id":"public/2018/02/25/新概念英语四-lesson-03-Matterhorn-Man/index.html","hash":"f612639747eff42c211fa5f4c5249ccde7a12537","modified":1536983439010},{"_id":"public/2018/02/24/POJ-1009-Edge-Detection/index.html","hash":"27950fff3875daa84ea741cd328e4da78bdad448","modified":1536983439011},{"_id":"public/2018/02/22/POJ-1008-Maya-Calendar/index.html","hash":"32842b779a017e1200a404f10755d3045abb8273","modified":1536983439011},{"_id":"public/2018/02/21/POJ-1007-DNA-sorting/index.html","hash":"c812fe0907b19507d4b514af738370527c794a2a","modified":1536983439011},{"_id":"public/2018/02/15/POJ-1006-Biorhythms/index.html","hash":"0cc4d8d5deb5518661e28eff372129582166b37c","modified":1536983439011},{"_id":"public/2018/01/21/POJ-1005-I-Think-I-Need-a-Houseboat/index.html","hash":"dd5a7f944d41a3a765da8582651cbf3e30e34112","modified":1536983439011},{"_id":"public/2018/01/21/POJ-1004-Financial-Management/index.html","hash":"a16b5f3df783d338c5108092d7e2266b52675323","modified":1536983439011},{"_id":"public/2018/01/21/POJ-1003-Hangover/index.html","hash":"7079d958f1091998a5317d507b7a28293a299865","modified":1536983439011},{"_id":"public/2018/01/21/POJ-1002-487-3279/index.html","hash":"bbd9f3e54bbe9458dc9bf49fd05a24ee2c2f073d","modified":1536983439011},{"_id":"public/2018/01/20/POJ-1001-Exponentiation/index.html","hash":"7b5b0e9dad33ed57bee55df4e82b128cf4caedf1","modified":1536983439011},{"_id":"public/2017/11/14/Override-Overload-Overwrite/index.html","hash":"ca34923a8aa96fb453fb221994686edeb393892d","modified":1536983439011},{"_id":"public/2017/10/23/Inside-the-C++-Object-Model-系列笔记--The-Semantics-of-Function/index.html","hash":"f88a6cf3326e0db1fc8ab295c8a420156e063a09","modified":1536983439011},{"_id":"public/2017/10/21/Inside-the-C++-Object-Model-系列笔记--The-Semantics-of-Data/index.html","hash":"69e0df54f08e872589a767328d3a602c01bf8e8e","modified":1536983439011},{"_id":"public/2017/10/19/Inside-the-C++-Object-Model-系列笔记--The-Semantics-of-constructors/index.html","hash":"70c7448033895c269b88ec5fa97ff4de922882a0","modified":1536983439012},{"_id":"public/2017/10/19/Inside-the-C++-Object-Model-系列笔记--Object-Lessons/index.html","hash":"8a776692cfcebf7f30fd8289e936dee29073d46b","modified":1536983439012},{"_id":"public/2017/02/06/我读大学时候的一些思考/index.html","hash":"06dff0933aeb737f38554c7b81570557907085f1","modified":1536983439012},{"_id":"public/2017/02/03/Macbook/index.html","hash":"a17c28ea09c95f1b62e8cda05e998fea5216c190","modified":1536983439012},{"_id":"public/2017/01/26/游戏人生--探险者的人生手册/index.html","hash":"404ae62ca7dfa5e0c925a69dcd1349ca6f92cd7b","modified":1536983439012},{"_id":"public/2017/01/12/百度贴吧ID挖掘机/index.html","hash":"3e1b4db41e39da950b39bf2c784e2724e0ebf715","modified":1536983439012},{"_id":"public/2017/01/10/那些年我读过的好故事/index.html","hash":"dc686c7baa468e0ade4f15149e89baa5ebd7f384","modified":1536983439012},{"_id":"public/2017/01/02/学习方法总结/index.html","hash":"069fdfd941e79c8831b9c6787144860499a2532e","modified":1536983439012},{"_id":"public/2017/01/01/从windows转用macOSX记录/index.html","hash":"544c1a98590393ae7175b05dade1cc2b747e2cb0","modified":1536983439012},{"_id":"public/2016/09/30/线性代数笔记--线性代数复习核心思想/index.html","hash":"c96867da561b0c7d3e15116ebd39edc099a22f12","modified":1536983439012},{"_id":"public/2016/09/30/线性代数笔记--基础篇：行列式、矩阵的本质/index.html","hash":"f197e3c3fda35f5c98f7a641244b706556428e2d","modified":1536983439012},{"_id":"public/categories/读书笔记/index.html","hash":"15ba8ba0651ca5e91a0df0c39bb215673913041b","modified":1536983439013},{"_id":"public/categories/ACM/index.html","hash":"01f174b797d1c799b19cbcb231ebac869fe7ef81","modified":1536983439013},{"_id":"public/categories/ACM/page/2/index.html","hash":"0e641aa819e637515872d63e5db97ae5daba7473","modified":1536983439013},{"_id":"public/categories/读书笔记/《代码整洁之道》/index.html","hash":"679a44574b2193b1ee3df5e3b79d4088e8133476","modified":1536983439013},{"_id":"public/categories/ACM/Leetcode/index.html","hash":"25ed375544e782cae643aae95423d3b7dad3eec4","modified":1536983439013},{"_id":"public/categories/数学/index.html","hash":"b57514655d1b8df09ab6ebdb9a5a8d043dfd90f3","modified":1536983439013},{"_id":"public/categories/随笔/index.html","hash":"fe9bd7e021c0ce0fb574037f4fd553fcbd8049ae","modified":1536983439013},{"_id":"public/categories/数码/index.html","hash":"100518f6480c6c30cc4fbcf0259f578b8fa2b5f4","modified":1536983439013},{"_id":"public/categories/数学/线性代数/index.html","hash":"c9d1afdfd4d1e4603bd41db4620d94d2e89eb478","modified":1536983439013},{"_id":"public/categories/projects/index.html","hash":"0878f15b6751acfb41c803611de4603a08ec10b2","modified":1536983439013},{"_id":"public/categories/读书笔记/《Inside-the-C-Object-Model》/index.html","hash":"f38e32da68a58785c0076bb6febd66ceea50912d","modified":1536983439013},{"_id":"public/categories/编程范式/index.html","hash":"d294656085593aef26d5fdd558a151727f384072","modified":1536983439013},{"_id":"public/categories/ACM/POJ/index.html","hash":"316047694b76dcdd1a30b27e98c8fa1dd06b7be3","modified":1536983439013},{"_id":"public/categories/新概念英语四/index.html","hash":"83f396200f683e657b04fd452ad1e5bc2e3edf41","modified":1536983439013},{"_id":"public/categories/Java/index.html","hash":"d554d206416c383831423f94a536e41694649618","modified":1536983439014},{"_id":"public/categories/LaTex/index.html","hash":"5fc996c5c6e5f2794999aa0c39c91690ca9b4aa8","modified":1536983439014},{"_id":"public/categories/数学/解析几何/index.html","hash":"0b69710366151445f5ead20e562438134f368a14","modified":1536983439014},{"_id":"public/categories/Android/index.html","hash":"fe6ab1e338e6784ab5243575a0377b8ac05a7a41","modified":1536983439014},{"_id":"public/categories/编程范式/面向对象编程/index.html","hash":"81eef84bd4a39e8cacb9bf901f8849ddd4658c6b","modified":1536983439014},{"_id":"public/categories/区块链/index.html","hash":"2c69fd059295ea69abdda4cdcc05865872d22d61","modified":1536983439014},{"_id":"public/categories/Linux/index.html","hash":"5b740a8a7d4a219a6480c0bfbb940f651bfcd2c1","modified":1536983439014},{"_id":"public/categories/vim/index.html","hash":"de602761edafd56b568108ebcf7e3ae35367acdd","modified":1536983439014},{"_id":"public/categories/Unix/index.html","hash":"f1308373acf93eefa352acc3a0e5cb0831ed222f","modified":1536983439014},{"_id":"public/categories/SQL/index.html","hash":"b6f1dfa908cc5c0eac17c3794ac76a2c354fce49","modified":1536983439014},{"_id":"public/categories/哲学/index.html","hash":"1851e5a33028b1fc6197cbf2ce9c25b7272b4348","modified":1536983439014},{"_id":"public/categories/Java/Java-web/index.html","hash":"3f9f7a5a3eedd6352b8d36d69827a62678d33519","modified":1536983439014},{"_id":"public/categories/Android/通讯录/index.html","hash":"dcfd43ace4e846e188985db6d52f0aeb92ae555e","modified":1536983439014},{"_id":"public/categories/Android/Volley库/index.html","hash":"9599bbf7feea70a59755bb0e97c8dca766de7d84","modified":1536983439014},{"_id":"public/categories/区块链/ipfs/index.html","hash":"ceb90c18afe22f6f7420c4b30ca4063bcfb831a6","modified":1536983439015},{"_id":"public/archives/index.html","hash":"fc3ecafe7df8b7d6bb64e7819c67d8092229ffd6","modified":1536983439015},{"_id":"public/archives/page/2/index.html","hash":"1f09c21137dae2e111ffb8e01ca0fefdac49cea1","modified":1536983439015},{"_id":"public/archives/page/3/index.html","hash":"f6fce45a8c6d849853829b9765ad20975a0e95ab","modified":1536983439015},{"_id":"public/archives/page/4/index.html","hash":"523c829fdfbbe353c4f388e2fd721d78c41e9359","modified":1536983439015},{"_id":"public/archives/page/5/index.html","hash":"54d02590b88623651cb79b2f77e1c9c172293c7f","modified":1536983439015},{"_id":"public/archives/2016/index.html","hash":"c23903939123e88e16bde22f0da38e99317e206e","modified":1536983439015},{"_id":"public/archives/2016/09/index.html","hash":"96dbb4fba6f09f12dfdd4fd235199be3fa480fa9","modified":1536983439015},{"_id":"public/archives/2017/index.html","hash":"19548361c9630b43ed162cf9990b6e86a72bc6b3","modified":1536983439015},{"_id":"public/archives/2017/page/2/index.html","hash":"a013ffb40f344956844d650a2db10af165617a70","modified":1536983439015},{"_id":"public/archives/2017/01/index.html","hash":"19e4af342a865ff9d797e7ca7fe411d35b92606c","modified":1536983439015},{"_id":"public/archives/2017/02/index.html","hash":"775f9492cd214075cff67327253aa81762a892bc","modified":1536983439015},{"_id":"public/archives/2017/10/index.html","hash":"dff51288fe9243c1025d20cd31f82f9299be17fc","modified":1536983439015},{"_id":"public/archives/2017/11/index.html","hash":"0fbeb48a2cb91ae9d974f259be28234827ef9bff","modified":1536983439015},{"_id":"public/archives/2018/index.html","hash":"79cae322488f6931ecb230ffe0d21fb527475656","modified":1536983439016},{"_id":"public/archives/2018/page/2/index.html","hash":"399fdd1fb4def392ccde789155d04aa1208bdf42","modified":1536983439016},{"_id":"public/archives/2018/page/3/index.html","hash":"e6c4a11ad2f74c107e76280c48dead752ee6460c","modified":1536983439016},{"_id":"public/archives/2018/01/index.html","hash":"58066884d51ae85e47b0053923005d9577f3a647","modified":1536983439016},{"_id":"public/archives/2018/02/index.html","hash":"3dfc5927bea9995f8cef51a70d07a1d9f5ccb583","modified":1536983439016},{"_id":"public/archives/2018/04/index.html","hash":"637798e52d5d705b1268eaf7e40c4c6d15d59946","modified":1536983439016},{"_id":"public/archives/2018/05/index.html","hash":"e0313a97d39e4844787f33d1424a934075342bab","modified":1536983439016},{"_id":"public/archives/2018/06/index.html","hash":"f75e93d404541f110e44576dad75b1d764720858","modified":1536983439016},{"_id":"public/archives/2018/08/index.html","hash":"8fb47d51eca1d8bed02853a42b05152a22a7b8c8","modified":1536983439017},{"_id":"public/index.html","hash":"6c9dad1bb06eadf3671b530acd8a857dad8e15ca","modified":1536983439017},{"_id":"public/page/2/index.html","hash":"15303e5d6b9524618342eb37788d8d7e05f32264","modified":1536983439017},{"_id":"public/page/3/index.html","hash":"73f970287421c76222639ff5d280e5068530699a","modified":1536983439017},{"_id":"public/page/4/index.html","hash":"807a6e38a80bed87376a5c7fd9c46ffbe232f591","modified":1536983439018},{"_id":"public/page/5/index.html","hash":"80b57231fcd2096f1e2b6435bc9fe7fe31117010","modified":1536983439018},{"_id":"public/page/6/index.html","hash":"446616a404d1f456cdcb6587a43b35b748d70c36","modified":1536983439018},{"_id":"public/page/7/index.html","hash":"42e4529a8864b0c5c6ca23c39ffa6a01bea4b966","modified":1536983439018},{"_id":"public/page/8/index.html","hash":"ab10d55b14ef020074b8fe3cde0e1cb00190535c","modified":1536983439018},{"_id":"public/page/9/index.html","hash":"8d46a833e0a23d3b4cc1ee23a72bc0263f3dcf85","modified":1536983439018},{"_id":"public/tags/代码规范/index.html","hash":"aa01a8563ccc6595c452aa3fd75b714454e940a7","modified":1536983439018},{"_id":"public/tags/工具/index.html","hash":"d0bc1b02927a0e02bd1d05ff1ae6407681bb6278","modified":1536983439018},{"_id":"public/tags/爬虫/index.html","hash":"9c58a6ef013cfd362e5765356a17af6dee37052c","modified":1536983439018},{"_id":"public/tags/Python/index.html","hash":"704d5e003d873e0d96875a754fb381fbbe95f6be","modified":1536983439018},{"_id":"public/tags/C/index.html","hash":"1695fdbd98cb132b8a04e8918794dd24b3547af6","modified":1536983439019},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1536983439028},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1536983439028},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1536983439028},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1536983439028},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1536983439028},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1536983439028},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1536983439028},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1536983439028},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1536983439028},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1536983439028},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1536983439028},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1536983439028},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1536983439028},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1536983439028},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1536983439028},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1536983439028},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1536983439028},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1536983439028},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1536983439028},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1536983439028},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1536983439029},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1536983439029},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1536983439029},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1536983439029},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1536983439029},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1536983439029},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1536983439029},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1536983439029},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1536983439029},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1536983439029},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1536983439029},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1536983439029},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1536983439029},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1536983439511},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1536983439517},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1536983439593},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1536983439593},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1536983439593},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1536983439593},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1536983439593},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1536983439593},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1536983439593},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1536983439593},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1536983439593},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1536983439593},{"_id":"public/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1536983439594},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1536983439594},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1536983439594},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1536983439594},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1536983439594},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1536983439594},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1536983439594},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1536983439594},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1536983439594},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1536983439594},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1536983439594},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1536983439594},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1536983439594},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1536983439594},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1536983439594},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1536983439594},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1536983439594},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1536983439594},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1536983439594},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1536983439594},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1536983439595},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1536983439595},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1536983439595},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1536983439595},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1536983439595},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1536983439595},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1536983439595},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1536983439595},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1536983439595},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1536983439595},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1536983439595},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1536983439595},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1536983439595},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1536983439595},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1536983439595},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1536983439595},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1536983439595},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1536983439595},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1536983439595},{"_id":"public/css/main.css","hash":"75b621e79596b838f65596cd944aaf30b6fa1a20","modified":1536983439595},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1536983439596},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1536983439596},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1536983439596},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1536983439596},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1536983439596},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1536983439596},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1536983439596},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1536983439596},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1536983439596},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1536983439596},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1536983439596},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1536983439596},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1536983439596},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1536983439596},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1536983439596},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1536983439596},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1536983439596},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1536983439596},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1536983439597},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1536983439597},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1536983439597},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1536983439597},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1536983439597},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1536983439613}],"Category":[{"name":"读书笔记","_id":"cjm2w8d5k0004fgpxnh8sbwwe"},{"name":"ACM","_id":"cjm2w8d5s000dfgpx3f0egbog"},{"name":"《代码整洁之道》","parent":"cjm2w8d5k0004fgpxnh8sbwwe","_id":"cjm2w8d5t000ffgpx2med7t1r"},{"name":"《Advance Programming in the Unix Environment》","parent":"cjm2w8d5k0004fgpxnh8sbwwe","_id":"cjm2w8d5t000gfgpx6qq3woht"},{"name":"Leetcode","parent":"cjm2w8d5s000dfgpx3f0egbog","_id":"cjm2w8d5t000ifgpxv3u7ydlz"},{"name":"数学","_id":"cjm2w8dcp000sfgpxa2hwvknw"},{"name":"随笔","_id":"cjm2w8dcv0010fgpx5ikztkhc"},{"name":"数码","_id":"cjm2w8dcx0015fgpxh6xqgx44"},{"name":"线性代数","parent":"cjm2w8dcp000sfgpxa2hwvknw","_id":"cjm2w8dcz001bfgpx7plompga"},{"name":"projects","_id":"cjm2w8dd5001ofgpx30578chg"},{"name":"《Inside the C++ Object Model》","parent":"cjm2w8d5k0004fgpxnh8sbwwe","_id":"cjm2w8ddf002bfgpxr7nqzmdz"},{"name":"编程范式","_id":"cjm2w8ddo002tfgpxu4hmnv8d"},{"name":"POJ","parent":"cjm2w8d5s000dfgpx3f0egbog","_id":"cjm2w8ddq002zfgpx47hvkafw"},{"name":"新概念英语四","_id":"cjm2w8de40041fgpx5czj0u6t"},{"name":"Java","_id":"cjm2w8de50044fgpxz2vgeibn"},{"name":"LaTex","_id":"cjm2w8de6004afgpx5j0h27co"},{"name":"解析几何","parent":"cjm2w8dcp000sfgpxa2hwvknw","_id":"cjm2w8de6004efgpxwj749e16"},{"name":"Android","_id":"cjm2w8de7004jfgpx2rcfw0nr"},{"name":"面向对象编程","parent":"cjm2w8ddo002tfgpxu4hmnv8d","_id":"cjm2w8de8004mfgpxwpcl7168"},{"name":"区块链","_id":"cjm2w8de8004ofgpxsn3f6jtv"},{"name":"Linux","_id":"cjm2w8de9004sfgpxxw9ankj2"},{"name":"vim","_id":"cjm2w8dea004ufgpxbna4tjaw"},{"name":"Unix","_id":"cjm2w8dea004wfgpxltvam42m"},{"name":"SQL","_id":"cjm2w8dea004yfgpxc3ggj0pb"},{"name":"哲学","_id":"cjm2w8deb0051fgpxra38265k"},{"name":"Java web","parent":"cjm2w8de50044fgpxz2vgeibn","_id":"cjm2w8dec0055fgpxvxfbba6j"},{"name":"通讯录","parent":"cjm2w8de7004jfgpx2rcfw0nr","_id":"cjm2w8dec0058fgpx3izdnb2w"},{"name":"Volley库","parent":"cjm2w8de7004jfgpx2rcfw0nr","_id":"cjm2w8ded005bfgpxazc1iccn"},{"name":"ipfs","parent":"cjm2w8de8004ofgpxsn3f6jtv","_id":"cjm2w8dee005efgpxnszwl983"}],"Data":[],"Page":[{"title":"信息科学","date":"2018-04-17T02:40:39.000Z","_content":"\n信息科学是一门有趣的科学，我们的宇宙充满着各种各样的信息，而且信息量及其庞大，我觉得信息是宇宙、意识等复杂事物的本质（另一个本质是：量变与质变），虚拟世界与真实世界的唯一区别便是：\n\n1. 信息量的大小（目前来看完全不在一个数量级）\n2. 寄生关系（真实世界的真实这个属性并非绝对，而是相对，虚拟世界与所寄生的母世界相比，母世界的真实属性就更高）\n\n好了哲思就写到这里，让我们回到脚踏实地的现在，信息科学发展到现在，最突出的部分便是计算机的发展。一个码农和计算机的纪元正火热开启，条条大路通 Computer Science。现如今编程自然不用纸带+打孔，裸机跑程序。我们的工作建立在前人的工作之上。让我们看看我们现在要学习的是什么：\n\n## 基础理论课\n\n1. 数据结构和算法\n2. 操作系统\n3. 计算机组成原理与汇编\n4. 计算机网络\n\n我列出这四门课，是因为你国内本科结束之后，考研初试要考的就是这四门课。复试的话会涉及到更深入的一点东西，比如：编译原理、软件工程、人工智能、多媒体技术、信号处理。\n\n这里推荐一本书：\n\n中文叫：[深入理解计算机系统](https://book.douban.com/subject/5333562/)\n英文叫：[Computer Systems: A Programmer’s Perspective](https://book.douban.com/subject/26344642/)，简称 CSAPP。\n\n>1. 有能力的话，尽量看英文版\n>2. 看书要做笔记\n>3. 习题不要略过，一定要做\n\n这是 CMU（Carnegie Mellon University，卡内基梅隆大学）的计算机入门教材，这本教材对应的课程是 CS 213 ，是很多课程的先修课。\n\n![先修课](https://i.loli.net/2018/03/25/5ab6fab31181c.jpg)\n\n[如何阅读《深入理解计算机系统》这本书？](https://www.zhihu.com/question/20402534/answer/124950081)\n\n看完知乎答主的回答，我们需要注意的是这门课也有一个先修课，是一门编程语言 C0（C 语言的子集），对应的课程是 CS 122，或者你学 Python 也行。CMU一般是给大二学生开这个课，学过C以后就可以上了。\n\n这本书之所以成为圣经般的入门书，就是因为：\n\n1. 突出原理\n2. 知识点涵盖非常全\n3. 讲的非常棒（可以说计算机组成原理部分比专门讲这个的书讲的更好，操作系统部分比专门讲操作系统的书讲得好，这完全就是可怕的存在）\n\n## 理论之外\n\n然而仅仅是学习上面的理论是完全不够的。\n\n我这里要讲的是 ACM，`ACM国际大学生程序设计竞赛（ACM International Collegiate Programming Contest, ICPC）`的简称，由 ACM（Association for Computing Machinery，（美国）计算机协会）主办。\n\n![ACM logo](https://i.loli.net/2018/03/25/5ab6fdd8398c7.png)\n\n为什么 ACM 如此重要（以及 ACM 的大奖对本科生找工作的分量这么重），因为编程活动所要依赖的只有一个：抽象和逻辑能力，这就是为什么其实编程可以从小学开始（没有过高的知识门槛）。计算机科学的诸多课程，就是由先辈们靠着抽象和逻辑搭建起来的知识大厦，这些知识和经验是叶，而你抽象和逻辑能力（或者说依靠计算机解决问题的能力）是根。练习 ACM 就跟武术世界里面的李小龙每天练拳一样，是基本功。\n\n练习 ACM 一般用 Online Judge 系统，这里我推荐几个：\n\n- [北京大学的在线裁判系统，简称POJ](http://poj.org/)\n- [杭州电子科技大学的在线裁判系统](http://acm.hdu.edu.cn/)\n- [leetcode](https://leetcode.com/)\n\n## ACM之外\n\nACM自然跟真正的应用程序的编写是不一样的，当你真正步入开发的时候，你会发现还有非常多的东西要学，一个看似简单的APP，其架构却是非常复杂的，代码量也远超你的想象。那么如何上手学习呢，你也不可能一步登天，一上来就开发一款应用啊。答案自然是：**一个功能，一个功能的实现，慢慢积累，有点像搭积木**。你不要觉得仅实现一个功能会拿不出手，初学者就是这样积累起来的，所以你大可以把你实现的那些小东西都整理好（这也就是我下面会写到的，做好编程札记），**文档和代码都好好保存，因为编程最忌讳的就是重复工作，从零做起**。\n\n## 脱离 Windows 的襁褓\n\n很多人喜欢争论 Linux 和 Windows，就像各种语言之间的争论一样，无休无止。但同样很多人喜欢说，Windows 和 Linux 无所谓，真正的开发者都是什么好用用什么，主要看需求。\n\n而这里我要说的，跟这些都不一样，对于初学者我的建议一定是：**脱离 Windows 的襁褓**。否则你将很难对计算机的 CLI（Command Line Interface）产生直观性的体验。Linux 让你更贴近事物的原理，让你看的更加清楚，让你脱离不动脑子傻瓜式的鼠标点点点。而之所以那些高手喜欢说 Windows 很好用，没必要用 Linux，是因为他们都是脱离了低级层次，已经到达更高层次的人，他们当然无所谓，Windows 早已蒙蔽不了他们的双眼。这是一种看山还是山，看水还是水的境界。而你不经过历练，是不会到达这个境界的。\n\n不要一见到命令行就恐惧，正如你不应该一见到英文网站和资料就恐惧一样，这种回避绝对是有害的。\n\n对于初学者，Linux比mac os x好，因为mac也可以点点点。\n\n>当然如果你已经脱离了低级层次，那么我绝对更推荐你用windows，其次是mac，最后是linux。别问我为什么，原因简单到我不想说：支持力度哪家强？（这里说的支持力度包括操作系统层面和应用开发层面）\n\n## 编程心得\n\n其实我早就想写一个系列，就叫：**编程心得**，这个里面放上很多编程中的细节问题，就跟网上的笔试面试经典一样，其实这些东西虽然吸收的快，但有些东西还是必须经过亲力亲为才能真正体会到，但我并不反对直接看这种东西，否则我就不必花心思去写了。直接看前人总结的经验非常有好处，这就像武侠世界里的传输内力，人类之所以发展起了文明，就是因为知识的传递非常迅速而有效，我们根本不需要做任何事之前都需要自己做过一遍才知道怎么做，我们往往都借助他人的经验。\n\n说到这个话题，我觉得有必要强调一下，**编程札记** 这个东西，一直以来我都十分建议，不管是工作还是学习，都要做好记录，特别是重要的点，一定要记下来，比如实现一个东西的时候遇到的困难，以及如何解决的整个过程，有哪些关键点，等等。写这个东西是为了便于回顾，以及衡量自己的工作量。\n\n>学而时习之，不亦说乎\n\n目前免费的云笔记首推：有道云笔记，虽然用的没有为知笔记爽，对于穷学生来说还是比较友好的。另外人家后台是网易，而且跟网易云音乐、有道词典、网易公开课、网易云课堂、网易严选等等产品构成了一个网易的高口碑生态链，所以你一定程度上不用担心它关门倒闭。\n\n## LaTex 和 Markdown\n\n说到文档和笔记的编写，就得推这两个东西了：LaTex是学术界写论文的标准（现在微软的word软件似乎也有一席之地了，毕竟LaTex比word难用多了，特别是对非计算机类的学者来说），排版效果非常棒，我感觉，出版社出版，维基百科词条，也都用得上LaTex。Markdown是github上文档的标准，也是网络上各种野生博主的写作标准，最最关键的点是，mathjax这个组织，让Markdown的便捷和LaTex的强大结合起来了，你可以在Markdown中插入用LaTex书写的数学公式。**这也是我不用简书的原因，简书虽然有Markdown，却不支持mathjax，公式贴图可以啊，但你总不至于写个上下标都贴图吧。**\n\n关于LaTax的手册，我还是希望大家自己去找，在这个时代一定要把自己的搜索能力练起来，特别是寻找 **最权威的资料，最一手的信息**，因为这样你才有可能在比特币刚诞生不久的时候就了解到它，当然很多人会说其实他们早就知道这个东西，只不过一直不想去深入了解。\n\n当然我也不会吝啬于分享，我先讲讲我如何找这份资料：首先使用google搜索引擎，其次使用英文搜索，输入 `LaTex math symbols`，我得到的第一条就很不错：[LaTex Math Symbols](https://web.ift.uib.no/Teori/KURS/WRK/TeX/symALL.html)，第二条也不错：[LATEX Mathematical Symbols](https://reu.dimacs.rutgers.edu/Symbols.pdf)\n\n至于要不要把它们加进你的书签，我的建议是这类东西没必要加，你可以仔细思考一下这个搜索有什么特别的，对，他加了 `math` 这个关键信息，如果你只是单纯的搜索 `LaTex` 那么你将得到大量无关的信息，但其实你平常用的时候经常就只是用到数学方面的东西。\n\n## 访问全球网\n\n众所周知，我们处于一个国域网当中，如果你想看看外面的世界，必须要学会翻墙。互联网时代，这是必备技能。目前我用的是 **搬瓦工+shadowsocks**。\n\n\n\n## Java\n\n- [Java OutputStream flush](../2018/02/27/Java-OutputStream-flush)\n\n## C++\n\n- [Inside the C++ Object Model 系列笔记 一 -- Object Lessons](../2017/10/19/Inside-the-C++-Object-Model-系列笔记--Object-Lessons)\n- [Inside the C++ Object Model 系列笔记 二 -- The Semantics of constructors](../2017/10/19/Inside-the-C++-Object-Model-系列笔记--The-Semantics-of-constructors)\n- [Inside the C++ Object Model 系列笔记 三 -- The Semantics of Data](../2017/10/21/Inside-the-C++-Object-Model-系列笔记--The-Semantics-of-Data)\n- [Inside the C++ Object Model 系列笔记 四 -- The Semantics of Function](../2017/10/23/Inside-the-C++-Object-Model-系列笔记--The-Semantics-of-Function)\n\n## PeKing University Online Judge\n\n这个POJ相比于 leetcode 的不同就是：\n\n出现的年代比 leetcode 这种更早，考察的范围比 leetcode 更广\n需要自己处理输入输出，以及更宽泛的发挥空间（要编写一个完整的程序，包括头文件或者引用了哪些库），而 leetcode 则一般只给出一个函数，让你填写完整。\n\n- [POJ 1001 Exponentiation](../2018/01/20/POJ-1001-Exponentiation)\n- [POJ 1002 487 3279](../2018/01/21/POJ-1002-487-3279)\n- [POJ 1003 Hangover](../2018/01/21/POJ-1003-Hangover)\n- [POJ 1004 Financial Management](../2018/01/21/POJ-1004-Financial-Management)\n- [POJ 1005 I Think I Need a Houseboat](../2018/01/21/POJ-1005-I-Think-I-Need-a-Houseboat)\n- [POJ 1006 Biorhythms](../2018/02/15/POJ-1006-Biorhythms)\n- [POJ 1007 DNA sorting](../2018/02/21/POJ-1007-DNA-sorting)\n- [POJ 1008 Maya Calendar](../2018/02/22/POJ-1008-Maya-Calendar)\n- [POJ 1009 Edge Detection](../2018/02/24/POJ-1009-Edge-Detection)\n\n## leetcode 刷题\n\nleetcode是一个 Online Judge 网站，在线练习编程，尤其是练习数据结构和算法相关的题。\n\n刷OJ对于锻炼自己的计算机思维，算法能力，对常用编程语言的数据结构部分的熟练使用，都是非常有帮助的。\n\n这个系列中，我将提供leetcode上 **所有免费题目的答案**，并提供 **详细的解答思路**，所使用的编程语言有：**Python、C++、Java、JavaScript**。\n\n### 一些建议：\n\n1. 按照AC（accepted）率从高到低刷题，这样就会从易到难，提供一个进步的缓冲空间，不至于一上来就被打击到。不过其实 AC 率并不真实，因为 leetcode 比较出名的缘故，所以很多题都可以在网上找到答案和解题思路。leetcode给每道题都配备了难度信息，有 Easy、Medium、Hard 三个难度等级。你也可以按照这个从易到难刷题。\n2. 按照算法和数据结构体系，逐个模块的掌握，leetcode已经按照 **数据结构、公司、最受欢迎** 等等属性给题目做了划分，而且会提示哪些题目是类似的，另外网上也有不少按算法和数据结构总结的解答电子书可以参照。\n3. 做不出来的时候可以看leetcode网站上的 Discuss 和 Solutions ，有不少大神的解题方法和精简代码。当然也可以在互联网上搜索，有很多讲解leetcode的博客。\n\n我的这份教程将从 `String` 模块开始，按照 AC 率刷题。\n\n### String\n\n- [632. Smallest Range]()\n\n### 未整理部分\n\n- [2. Add Two Numbers]()\n- [3. Longest Substring Without Repeating Characters]()\n- [13. Roman to Integer]()\n- [22. Generate Parentheses]()\n- [34. Search for a Range]()\n- [383. Ransom Note]()\n- [541. Reverse String II]()\n- [583. Delete Operation for Two Strings]()\n- [606. Construct String from Binary Tree]()\n- [657. Judge Route Circle]()\n- [551. Student Attendance Record I]()","source":"ComputerScience/index.md","raw":"---\ntitle: 信息科学\ndate: 2018-04-17 10:40:39\n---\n\n信息科学是一门有趣的科学，我们的宇宙充满着各种各样的信息，而且信息量及其庞大，我觉得信息是宇宙、意识等复杂事物的本质（另一个本质是：量变与质变），虚拟世界与真实世界的唯一区别便是：\n\n1. 信息量的大小（目前来看完全不在一个数量级）\n2. 寄生关系（真实世界的真实这个属性并非绝对，而是相对，虚拟世界与所寄生的母世界相比，母世界的真实属性就更高）\n\n好了哲思就写到这里，让我们回到脚踏实地的现在，信息科学发展到现在，最突出的部分便是计算机的发展。一个码农和计算机的纪元正火热开启，条条大路通 Computer Science。现如今编程自然不用纸带+打孔，裸机跑程序。我们的工作建立在前人的工作之上。让我们看看我们现在要学习的是什么：\n\n## 基础理论课\n\n1. 数据结构和算法\n2. 操作系统\n3. 计算机组成原理与汇编\n4. 计算机网络\n\n我列出这四门课，是因为你国内本科结束之后，考研初试要考的就是这四门课。复试的话会涉及到更深入的一点东西，比如：编译原理、软件工程、人工智能、多媒体技术、信号处理。\n\n这里推荐一本书：\n\n中文叫：[深入理解计算机系统](https://book.douban.com/subject/5333562/)\n英文叫：[Computer Systems: A Programmer’s Perspective](https://book.douban.com/subject/26344642/)，简称 CSAPP。\n\n>1. 有能力的话，尽量看英文版\n>2. 看书要做笔记\n>3. 习题不要略过，一定要做\n\n这是 CMU（Carnegie Mellon University，卡内基梅隆大学）的计算机入门教材，这本教材对应的课程是 CS 213 ，是很多课程的先修课。\n\n![先修课](https://i.loli.net/2018/03/25/5ab6fab31181c.jpg)\n\n[如何阅读《深入理解计算机系统》这本书？](https://www.zhihu.com/question/20402534/answer/124950081)\n\n看完知乎答主的回答，我们需要注意的是这门课也有一个先修课，是一门编程语言 C0（C 语言的子集），对应的课程是 CS 122，或者你学 Python 也行。CMU一般是给大二学生开这个课，学过C以后就可以上了。\n\n这本书之所以成为圣经般的入门书，就是因为：\n\n1. 突出原理\n2. 知识点涵盖非常全\n3. 讲的非常棒（可以说计算机组成原理部分比专门讲这个的书讲的更好，操作系统部分比专门讲操作系统的书讲得好，这完全就是可怕的存在）\n\n## 理论之外\n\n然而仅仅是学习上面的理论是完全不够的。\n\n我这里要讲的是 ACM，`ACM国际大学生程序设计竞赛（ACM International Collegiate Programming Contest, ICPC）`的简称，由 ACM（Association for Computing Machinery，（美国）计算机协会）主办。\n\n![ACM logo](https://i.loli.net/2018/03/25/5ab6fdd8398c7.png)\n\n为什么 ACM 如此重要（以及 ACM 的大奖对本科生找工作的分量这么重），因为编程活动所要依赖的只有一个：抽象和逻辑能力，这就是为什么其实编程可以从小学开始（没有过高的知识门槛）。计算机科学的诸多课程，就是由先辈们靠着抽象和逻辑搭建起来的知识大厦，这些知识和经验是叶，而你抽象和逻辑能力（或者说依靠计算机解决问题的能力）是根。练习 ACM 就跟武术世界里面的李小龙每天练拳一样，是基本功。\n\n练习 ACM 一般用 Online Judge 系统，这里我推荐几个：\n\n- [北京大学的在线裁判系统，简称POJ](http://poj.org/)\n- [杭州电子科技大学的在线裁判系统](http://acm.hdu.edu.cn/)\n- [leetcode](https://leetcode.com/)\n\n## ACM之外\n\nACM自然跟真正的应用程序的编写是不一样的，当你真正步入开发的时候，你会发现还有非常多的东西要学，一个看似简单的APP，其架构却是非常复杂的，代码量也远超你的想象。那么如何上手学习呢，你也不可能一步登天，一上来就开发一款应用啊。答案自然是：**一个功能，一个功能的实现，慢慢积累，有点像搭积木**。你不要觉得仅实现一个功能会拿不出手，初学者就是这样积累起来的，所以你大可以把你实现的那些小东西都整理好（这也就是我下面会写到的，做好编程札记），**文档和代码都好好保存，因为编程最忌讳的就是重复工作，从零做起**。\n\n## 脱离 Windows 的襁褓\n\n很多人喜欢争论 Linux 和 Windows，就像各种语言之间的争论一样，无休无止。但同样很多人喜欢说，Windows 和 Linux 无所谓，真正的开发者都是什么好用用什么，主要看需求。\n\n而这里我要说的，跟这些都不一样，对于初学者我的建议一定是：**脱离 Windows 的襁褓**。否则你将很难对计算机的 CLI（Command Line Interface）产生直观性的体验。Linux 让你更贴近事物的原理，让你看的更加清楚，让你脱离不动脑子傻瓜式的鼠标点点点。而之所以那些高手喜欢说 Windows 很好用，没必要用 Linux，是因为他们都是脱离了低级层次，已经到达更高层次的人，他们当然无所谓，Windows 早已蒙蔽不了他们的双眼。这是一种看山还是山，看水还是水的境界。而你不经过历练，是不会到达这个境界的。\n\n不要一见到命令行就恐惧，正如你不应该一见到英文网站和资料就恐惧一样，这种回避绝对是有害的。\n\n对于初学者，Linux比mac os x好，因为mac也可以点点点。\n\n>当然如果你已经脱离了低级层次，那么我绝对更推荐你用windows，其次是mac，最后是linux。别问我为什么，原因简单到我不想说：支持力度哪家强？（这里说的支持力度包括操作系统层面和应用开发层面）\n\n## 编程心得\n\n其实我早就想写一个系列，就叫：**编程心得**，这个里面放上很多编程中的细节问题，就跟网上的笔试面试经典一样，其实这些东西虽然吸收的快，但有些东西还是必须经过亲力亲为才能真正体会到，但我并不反对直接看这种东西，否则我就不必花心思去写了。直接看前人总结的经验非常有好处，这就像武侠世界里的传输内力，人类之所以发展起了文明，就是因为知识的传递非常迅速而有效，我们根本不需要做任何事之前都需要自己做过一遍才知道怎么做，我们往往都借助他人的经验。\n\n说到这个话题，我觉得有必要强调一下，**编程札记** 这个东西，一直以来我都十分建议，不管是工作还是学习，都要做好记录，特别是重要的点，一定要记下来，比如实现一个东西的时候遇到的困难，以及如何解决的整个过程，有哪些关键点，等等。写这个东西是为了便于回顾，以及衡量自己的工作量。\n\n>学而时习之，不亦说乎\n\n目前免费的云笔记首推：有道云笔记，虽然用的没有为知笔记爽，对于穷学生来说还是比较友好的。另外人家后台是网易，而且跟网易云音乐、有道词典、网易公开课、网易云课堂、网易严选等等产品构成了一个网易的高口碑生态链，所以你一定程度上不用担心它关门倒闭。\n\n## LaTex 和 Markdown\n\n说到文档和笔记的编写，就得推这两个东西了：LaTex是学术界写论文的标准（现在微软的word软件似乎也有一席之地了，毕竟LaTex比word难用多了，特别是对非计算机类的学者来说），排版效果非常棒，我感觉，出版社出版，维基百科词条，也都用得上LaTex。Markdown是github上文档的标准，也是网络上各种野生博主的写作标准，最最关键的点是，mathjax这个组织，让Markdown的便捷和LaTex的强大结合起来了，你可以在Markdown中插入用LaTex书写的数学公式。**这也是我不用简书的原因，简书虽然有Markdown，却不支持mathjax，公式贴图可以啊，但你总不至于写个上下标都贴图吧。**\n\n关于LaTax的手册，我还是希望大家自己去找，在这个时代一定要把自己的搜索能力练起来，特别是寻找 **最权威的资料，最一手的信息**，因为这样你才有可能在比特币刚诞生不久的时候就了解到它，当然很多人会说其实他们早就知道这个东西，只不过一直不想去深入了解。\n\n当然我也不会吝啬于分享，我先讲讲我如何找这份资料：首先使用google搜索引擎，其次使用英文搜索，输入 `LaTex math symbols`，我得到的第一条就很不错：[LaTex Math Symbols](https://web.ift.uib.no/Teori/KURS/WRK/TeX/symALL.html)，第二条也不错：[LATEX Mathematical Symbols](https://reu.dimacs.rutgers.edu/Symbols.pdf)\n\n至于要不要把它们加进你的书签，我的建议是这类东西没必要加，你可以仔细思考一下这个搜索有什么特别的，对，他加了 `math` 这个关键信息，如果你只是单纯的搜索 `LaTex` 那么你将得到大量无关的信息，但其实你平常用的时候经常就只是用到数学方面的东西。\n\n## 访问全球网\n\n众所周知，我们处于一个国域网当中，如果你想看看外面的世界，必须要学会翻墙。互联网时代，这是必备技能。目前我用的是 **搬瓦工+shadowsocks**。\n\n\n\n## Java\n\n- [Java OutputStream flush](../2018/02/27/Java-OutputStream-flush)\n\n## C++\n\n- [Inside the C++ Object Model 系列笔记 一 -- Object Lessons](../2017/10/19/Inside-the-C++-Object-Model-系列笔记--Object-Lessons)\n- [Inside the C++ Object Model 系列笔记 二 -- The Semantics of constructors](../2017/10/19/Inside-the-C++-Object-Model-系列笔记--The-Semantics-of-constructors)\n- [Inside the C++ Object Model 系列笔记 三 -- The Semantics of Data](../2017/10/21/Inside-the-C++-Object-Model-系列笔记--The-Semantics-of-Data)\n- [Inside the C++ Object Model 系列笔记 四 -- The Semantics of Function](../2017/10/23/Inside-the-C++-Object-Model-系列笔记--The-Semantics-of-Function)\n\n## PeKing University Online Judge\n\n这个POJ相比于 leetcode 的不同就是：\n\n出现的年代比 leetcode 这种更早，考察的范围比 leetcode 更广\n需要自己处理输入输出，以及更宽泛的发挥空间（要编写一个完整的程序，包括头文件或者引用了哪些库），而 leetcode 则一般只给出一个函数，让你填写完整。\n\n- [POJ 1001 Exponentiation](../2018/01/20/POJ-1001-Exponentiation)\n- [POJ 1002 487 3279](../2018/01/21/POJ-1002-487-3279)\n- [POJ 1003 Hangover](../2018/01/21/POJ-1003-Hangover)\n- [POJ 1004 Financial Management](../2018/01/21/POJ-1004-Financial-Management)\n- [POJ 1005 I Think I Need a Houseboat](../2018/01/21/POJ-1005-I-Think-I-Need-a-Houseboat)\n- [POJ 1006 Biorhythms](../2018/02/15/POJ-1006-Biorhythms)\n- [POJ 1007 DNA sorting](../2018/02/21/POJ-1007-DNA-sorting)\n- [POJ 1008 Maya Calendar](../2018/02/22/POJ-1008-Maya-Calendar)\n- [POJ 1009 Edge Detection](../2018/02/24/POJ-1009-Edge-Detection)\n\n## leetcode 刷题\n\nleetcode是一个 Online Judge 网站，在线练习编程，尤其是练习数据结构和算法相关的题。\n\n刷OJ对于锻炼自己的计算机思维，算法能力，对常用编程语言的数据结构部分的熟练使用，都是非常有帮助的。\n\n这个系列中，我将提供leetcode上 **所有免费题目的答案**，并提供 **详细的解答思路**，所使用的编程语言有：**Python、C++、Java、JavaScript**。\n\n### 一些建议：\n\n1. 按照AC（accepted）率从高到低刷题，这样就会从易到难，提供一个进步的缓冲空间，不至于一上来就被打击到。不过其实 AC 率并不真实，因为 leetcode 比较出名的缘故，所以很多题都可以在网上找到答案和解题思路。leetcode给每道题都配备了难度信息，有 Easy、Medium、Hard 三个难度等级。你也可以按照这个从易到难刷题。\n2. 按照算法和数据结构体系，逐个模块的掌握，leetcode已经按照 **数据结构、公司、最受欢迎** 等等属性给题目做了划分，而且会提示哪些题目是类似的，另外网上也有不少按算法和数据结构总结的解答电子书可以参照。\n3. 做不出来的时候可以看leetcode网站上的 Discuss 和 Solutions ，有不少大神的解题方法和精简代码。当然也可以在互联网上搜索，有很多讲解leetcode的博客。\n\n我的这份教程将从 `String` 模块开始，按照 AC 率刷题。\n\n### String\n\n- [632. Smallest Range]()\n\n### 未整理部分\n\n- [2. Add Two Numbers]()\n- [3. Longest Substring Without Repeating Characters]()\n- [13. Roman to Integer]()\n- [22. Generate Parentheses]()\n- [34. Search for a Range]()\n- [383. Ransom Note]()\n- [541. Reverse String II]()\n- [583. Delete Operation for Two Strings]()\n- [606. Construct String from Binary Tree]()\n- [657. Judge Route Circle]()\n- [551. Student Attendance Record I]()","updated":"2018-06-03T04:24:27.919Z","path":"ComputerScience/index.html","comments":1,"layout":"page","_id":"cjm2w8d5e0000fgpxpqldrdt8","content":"<p>信息科学是一门有趣的科学，我们的宇宙充满着各种各样的信息，而且信息量及其庞大，我觉得信息是宇宙、意识等复杂事物的本质（另一个本质是：量变与质变），虚拟世界与真实世界的唯一区别便是：</p>\n<ol>\n<li>信息量的大小（目前来看完全不在一个数量级）</li>\n<li>寄生关系（真实世界的真实这个属性并非绝对，而是相对，虚拟世界与所寄生的母世界相比，母世界的真实属性就更高）</li>\n</ol>\n<p>好了哲思就写到这里，让我们回到脚踏实地的现在，信息科学发展到现在，最突出的部分便是计算机的发展。一个码农和计算机的纪元正火热开启，条条大路通 Computer Science。现如今编程自然不用纸带+打孔，裸机跑程序。我们的工作建立在前人的工作之上。让我们看看我们现在要学习的是什么：</p>\n<h2 id=\"基础理论课\"><a href=\"#基础理论课\" class=\"headerlink\" title=\"基础理论课\"></a>基础理论课</h2><ol>\n<li>数据结构和算法</li>\n<li>操作系统</li>\n<li>计算机组成原理与汇编</li>\n<li>计算机网络</li>\n</ol>\n<p>我列出这四门课，是因为你国内本科结束之后，考研初试要考的就是这四门课。复试的话会涉及到更深入的一点东西，比如：编译原理、软件工程、人工智能、多媒体技术、信号处理。</p>\n<p>这里推荐一本书：</p>\n<p>中文叫：<a href=\"https://book.douban.com/subject/5333562/\" target=\"_blank\" rel=\"noopener\">深入理解计算机系统</a><br>英文叫：<a href=\"https://book.douban.com/subject/26344642/\" target=\"_blank\" rel=\"noopener\">Computer Systems: A Programmer’s Perspective</a>，简称 CSAPP。</p>\n<blockquote>\n<ol>\n<li>有能力的话，尽量看英文版</li>\n<li>看书要做笔记</li>\n<li>习题不要略过，一定要做</li>\n</ol>\n</blockquote>\n<p>这是 CMU（Carnegie Mellon University，卡内基梅隆大学）的计算机入门教材，这本教材对应的课程是 CS 213 ，是很多课程的先修课。</p>\n<p><img src=\"https://i.loli.net/2018/03/25/5ab6fab31181c.jpg\" alt=\"先修课\"></p>\n<p><a href=\"https://www.zhihu.com/question/20402534/answer/124950081\" target=\"_blank\" rel=\"noopener\">如何阅读《深入理解计算机系统》这本书？</a></p>\n<p>看完知乎答主的回答，我们需要注意的是这门课也有一个先修课，是一门编程语言 C0（C 语言的子集），对应的课程是 CS 122，或者你学 Python 也行。CMU一般是给大二学生开这个课，学过C以后就可以上了。</p>\n<p>这本书之所以成为圣经般的入门书，就是因为：</p>\n<ol>\n<li>突出原理</li>\n<li>知识点涵盖非常全</li>\n<li>讲的非常棒（可以说计算机组成原理部分比专门讲这个的书讲的更好，操作系统部分比专门讲操作系统的书讲得好，这完全就是可怕的存在）</li>\n</ol>\n<h2 id=\"理论之外\"><a href=\"#理论之外\" class=\"headerlink\" title=\"理论之外\"></a>理论之外</h2><p>然而仅仅是学习上面的理论是完全不够的。</p>\n<p>我这里要讲的是 ACM，<code>ACM国际大学生程序设计竞赛（ACM International Collegiate Programming Contest, ICPC）</code>的简称，由 ACM（Association for Computing Machinery，（美国）计算机协会）主办。</p>\n<p><img src=\"https://i.loli.net/2018/03/25/5ab6fdd8398c7.png\" alt=\"ACM logo\"></p>\n<p>为什么 ACM 如此重要（以及 ACM 的大奖对本科生找工作的分量这么重），因为编程活动所要依赖的只有一个：抽象和逻辑能力，这就是为什么其实编程可以从小学开始（没有过高的知识门槛）。计算机科学的诸多课程，就是由先辈们靠着抽象和逻辑搭建起来的知识大厦，这些知识和经验是叶，而你抽象和逻辑能力（或者说依靠计算机解决问题的能力）是根。练习 ACM 就跟武术世界里面的李小龙每天练拳一样，是基本功。</p>\n<p>练习 ACM 一般用 Online Judge 系统，这里我推荐几个：</p>\n<ul>\n<li><a href=\"http://poj.org/\" target=\"_blank\" rel=\"noopener\">北京大学的在线裁判系统，简称POJ</a></li>\n<li><a href=\"http://acm.hdu.edu.cn/\" target=\"_blank\" rel=\"noopener\">杭州电子科技大学的在线裁判系统</a></li>\n<li><a href=\"https://leetcode.com/\" target=\"_blank\" rel=\"noopener\">leetcode</a></li>\n</ul>\n<h2 id=\"ACM之外\"><a href=\"#ACM之外\" class=\"headerlink\" title=\"ACM之外\"></a>ACM之外</h2><p>ACM自然跟真正的应用程序的编写是不一样的，当你真正步入开发的时候，你会发现还有非常多的东西要学，一个看似简单的APP，其架构却是非常复杂的，代码量也远超你的想象。那么如何上手学习呢，你也不可能一步登天，一上来就开发一款应用啊。答案自然是：<strong>一个功能，一个功能的实现，慢慢积累，有点像搭积木</strong>。你不要觉得仅实现一个功能会拿不出手，初学者就是这样积累起来的，所以你大可以把你实现的那些小东西都整理好（这也就是我下面会写到的，做好编程札记），<strong>文档和代码都好好保存，因为编程最忌讳的就是重复工作，从零做起</strong>。</p>\n<h2 id=\"脱离-Windows-的襁褓\"><a href=\"#脱离-Windows-的襁褓\" class=\"headerlink\" title=\"脱离 Windows 的襁褓\"></a>脱离 Windows 的襁褓</h2><p>很多人喜欢争论 Linux 和 Windows，就像各种语言之间的争论一样，无休无止。但同样很多人喜欢说，Windows 和 Linux 无所谓，真正的开发者都是什么好用用什么，主要看需求。</p>\n<p>而这里我要说的，跟这些都不一样，对于初学者我的建议一定是：<strong>脱离 Windows 的襁褓</strong>。否则你将很难对计算机的 CLI（Command Line Interface）产生直观性的体验。Linux 让你更贴近事物的原理，让你看的更加清楚，让你脱离不动脑子傻瓜式的鼠标点点点。而之所以那些高手喜欢说 Windows 很好用，没必要用 Linux，是因为他们都是脱离了低级层次，已经到达更高层次的人，他们当然无所谓，Windows 早已蒙蔽不了他们的双眼。这是一种看山还是山，看水还是水的境界。而你不经过历练，是不会到达这个境界的。</p>\n<p>不要一见到命令行就恐惧，正如你不应该一见到英文网站和资料就恐惧一样，这种回避绝对是有害的。</p>\n<p>对于初学者，Linux比mac os x好，因为mac也可以点点点。</p>\n<blockquote>\n<p>当然如果你已经脱离了低级层次，那么我绝对更推荐你用windows，其次是mac，最后是linux。别问我为什么，原因简单到我不想说：支持力度哪家强？（这里说的支持力度包括操作系统层面和应用开发层面）</p>\n</blockquote>\n<h2 id=\"编程心得\"><a href=\"#编程心得\" class=\"headerlink\" title=\"编程心得\"></a>编程心得</h2><p>其实我早就想写一个系列，就叫：<strong>编程心得</strong>，这个里面放上很多编程中的细节问题，就跟网上的笔试面试经典一样，其实这些东西虽然吸收的快，但有些东西还是必须经过亲力亲为才能真正体会到，但我并不反对直接看这种东西，否则我就不必花心思去写了。直接看前人总结的经验非常有好处，这就像武侠世界里的传输内力，人类之所以发展起了文明，就是因为知识的传递非常迅速而有效，我们根本不需要做任何事之前都需要自己做过一遍才知道怎么做，我们往往都借助他人的经验。</p>\n<p>说到这个话题，我觉得有必要强调一下，<strong>编程札记</strong> 这个东西，一直以来我都十分建议，不管是工作还是学习，都要做好记录，特别是重要的点，一定要记下来，比如实现一个东西的时候遇到的困难，以及如何解决的整个过程，有哪些关键点，等等。写这个东西是为了便于回顾，以及衡量自己的工作量。</p>\n<blockquote>\n<p>学而时习之，不亦说乎</p>\n</blockquote>\n<p>目前免费的云笔记首推：有道云笔记，虽然用的没有为知笔记爽，对于穷学生来说还是比较友好的。另外人家后台是网易，而且跟网易云音乐、有道词典、网易公开课、网易云课堂、网易严选等等产品构成了一个网易的高口碑生态链，所以你一定程度上不用担心它关门倒闭。</p>\n<h2 id=\"LaTex-和-Markdown\"><a href=\"#LaTex-和-Markdown\" class=\"headerlink\" title=\"LaTex 和 Markdown\"></a>LaTex 和 Markdown</h2><p>说到文档和笔记的编写，就得推这两个东西了：LaTex是学术界写论文的标准（现在微软的word软件似乎也有一席之地了，毕竟LaTex比word难用多了，特别是对非计算机类的学者来说），排版效果非常棒，我感觉，出版社出版，维基百科词条，也都用得上LaTex。Markdown是github上文档的标准，也是网络上各种野生博主的写作标准，最最关键的点是，mathjax这个组织，让Markdown的便捷和LaTex的强大结合起来了，你可以在Markdown中插入用LaTex书写的数学公式。<strong>这也是我不用简书的原因，简书虽然有Markdown，却不支持mathjax，公式贴图可以啊，但你总不至于写个上下标都贴图吧。</strong></p>\n<p>关于LaTax的手册，我还是希望大家自己去找，在这个时代一定要把自己的搜索能力练起来，特别是寻找 <strong>最权威的资料，最一手的信息</strong>，因为这样你才有可能在比特币刚诞生不久的时候就了解到它，当然很多人会说其实他们早就知道这个东西，只不过一直不想去深入了解。</p>\n<p>当然我也不会吝啬于分享，我先讲讲我如何找这份资料：首先使用google搜索引擎，其次使用英文搜索，输入 <code>LaTex math symbols</code>，我得到的第一条就很不错：<a href=\"https://web.ift.uib.no/Teori/KURS/WRK/TeX/symALL.html\" target=\"_blank\" rel=\"noopener\">LaTex Math Symbols</a>，第二条也不错：<a href=\"https://reu.dimacs.rutgers.edu/Symbols.pdf\" target=\"_blank\" rel=\"noopener\">LATEX Mathematical Symbols</a></p>\n<p>至于要不要把它们加进你的书签，我的建议是这类东西没必要加，你可以仔细思考一下这个搜索有什么特别的，对，他加了 <code>math</code> 这个关键信息，如果你只是单纯的搜索 <code>LaTex</code> 那么你将得到大量无关的信息，但其实你平常用的时候经常就只是用到数学方面的东西。</p>\n<h2 id=\"访问全球网\"><a href=\"#访问全球网\" class=\"headerlink\" title=\"访问全球网\"></a>访问全球网</h2><p>众所周知，我们处于一个国域网当中，如果你想看看外面的世界，必须要学会翻墙。互联网时代，这是必备技能。目前我用的是 <strong>搬瓦工+shadowsocks</strong>。</p>\n<h2 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java\"></a>Java</h2><ul>\n<li><a href=\"../2018/02/27/Java-OutputStream-flush\">Java OutputStream flush</a></li>\n</ul>\n<h2 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C++\"></a>C++</h2><ul>\n<li><a href=\"../2017/10/19/Inside-the-C++-Object-Model-系列笔记--Object-Lessons\">Inside the C++ Object Model 系列笔记 一 – Object Lessons</a></li>\n<li><a href=\"../2017/10/19/Inside-the-C++-Object-Model-系列笔记--The-Semantics-of-constructors\">Inside the C++ Object Model 系列笔记 二 – The Semantics of constructors</a></li>\n<li><a href=\"../2017/10/21/Inside-the-C++-Object-Model-系列笔记--The-Semantics-of-Data\">Inside the C++ Object Model 系列笔记 三 – The Semantics of Data</a></li>\n<li><a href=\"../2017/10/23/Inside-the-C++-Object-Model-系列笔记--The-Semantics-of-Function\">Inside the C++ Object Model 系列笔记 四 – The Semantics of Function</a></li>\n</ul>\n<h2 id=\"PeKing-University-Online-Judge\"><a href=\"#PeKing-University-Online-Judge\" class=\"headerlink\" title=\"PeKing University Online Judge\"></a>PeKing University Online Judge</h2><p>这个POJ相比于 leetcode 的不同就是：</p>\n<p>出现的年代比 leetcode 这种更早，考察的范围比 leetcode 更广<br>需要自己处理输入输出，以及更宽泛的发挥空间（要编写一个完整的程序，包括头文件或者引用了哪些库），而 leetcode 则一般只给出一个函数，让你填写完整。</p>\n<ul>\n<li><a href=\"../2018/01/20/POJ-1001-Exponentiation\">POJ 1001 Exponentiation</a></li>\n<li><a href=\"../2018/01/21/POJ-1002-487-3279\">POJ 1002 487 3279</a></li>\n<li><a href=\"../2018/01/21/POJ-1003-Hangover\">POJ 1003 Hangover</a></li>\n<li><a href=\"../2018/01/21/POJ-1004-Financial-Management\">POJ 1004 Financial Management</a></li>\n<li><a href=\"../2018/01/21/POJ-1005-I-Think-I-Need-a-Houseboat\">POJ 1005 I Think I Need a Houseboat</a></li>\n<li><a href=\"../2018/02/15/POJ-1006-Biorhythms\">POJ 1006 Biorhythms</a></li>\n<li><a href=\"../2018/02/21/POJ-1007-DNA-sorting\">POJ 1007 DNA sorting</a></li>\n<li><a href=\"../2018/02/22/POJ-1008-Maya-Calendar\">POJ 1008 Maya Calendar</a></li>\n<li><a href=\"../2018/02/24/POJ-1009-Edge-Detection\">POJ 1009 Edge Detection</a></li>\n</ul>\n<h2 id=\"leetcode-刷题\"><a href=\"#leetcode-刷题\" class=\"headerlink\" title=\"leetcode 刷题\"></a>leetcode 刷题</h2><p>leetcode是一个 Online Judge 网站，在线练习编程，尤其是练习数据结构和算法相关的题。</p>\n<p>刷OJ对于锻炼自己的计算机思维，算法能力，对常用编程语言的数据结构部分的熟练使用，都是非常有帮助的。</p>\n<p>这个系列中，我将提供leetcode上 <strong>所有免费题目的答案</strong>，并提供 <strong>详细的解答思路</strong>，所使用的编程语言有：<strong>Python、C++、Java、JavaScript</strong>。</p>\n<h3 id=\"一些建议：\"><a href=\"#一些建议：\" class=\"headerlink\" title=\"一些建议：\"></a>一些建议：</h3><ol>\n<li>按照AC（accepted）率从高到低刷题，这样就会从易到难，提供一个进步的缓冲空间，不至于一上来就被打击到。不过其实 AC 率并不真实，因为 leetcode 比较出名的缘故，所以很多题都可以在网上找到答案和解题思路。leetcode给每道题都配备了难度信息，有 Easy、Medium、Hard 三个难度等级。你也可以按照这个从易到难刷题。</li>\n<li>按照算法和数据结构体系，逐个模块的掌握，leetcode已经按照 <strong>数据结构、公司、最受欢迎</strong> 等等属性给题目做了划分，而且会提示哪些题目是类似的，另外网上也有不少按算法和数据结构总结的解答电子书可以参照。</li>\n<li>做不出来的时候可以看leetcode网站上的 Discuss 和 Solutions ，有不少大神的解题方法和精简代码。当然也可以在互联网上搜索，有很多讲解leetcode的博客。</li>\n</ol>\n<p>我的这份教程将从 <code>String</code> 模块开始，按照 AC 率刷题。</p>\n<h3 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h3><ul>\n<li><a href=\"\">632. Smallest Range</a></li>\n</ul>\n<h3 id=\"未整理部分\"><a href=\"#未整理部分\" class=\"headerlink\" title=\"未整理部分\"></a>未整理部分</h3><ul>\n<li><a href=\"\">2. Add Two Numbers</a></li>\n<li><a href=\"\">3. Longest Substring Without Repeating Characters</a></li>\n<li><a href=\"\">13. Roman to Integer</a></li>\n<li><a href=\"\">22. Generate Parentheses</a></li>\n<li><a href=\"\">34. Search for a Range</a></li>\n<li><a href=\"\">383. Ransom Note</a></li>\n<li><a href=\"\">541. Reverse String II</a></li>\n<li><a href=\"\">583. Delete Operation for Two Strings</a></li>\n<li><a href=\"\">606. Construct String from Binary Tree</a></li>\n<li><a href=\"\">657. Judge Route Circle</a></li>\n<li><a href=\"\">551. Student Attendance Record I</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>信息科学是一门有趣的科学，我们的宇宙充满着各种各样的信息，而且信息量及其庞大，我觉得信息是宇宙、意识等复杂事物的本质（另一个本质是：量变与质变），虚拟世界与真实世界的唯一区别便是：</p>\n<ol>\n<li>信息量的大小（目前来看完全不在一个数量级）</li>\n<li>寄生关系（真实世界的真实这个属性并非绝对，而是相对，虚拟世界与所寄生的母世界相比，母世界的真实属性就更高）</li>\n</ol>\n<p>好了哲思就写到这里，让我们回到脚踏实地的现在，信息科学发展到现在，最突出的部分便是计算机的发展。一个码农和计算机的纪元正火热开启，条条大路通 Computer Science。现如今编程自然不用纸带+打孔，裸机跑程序。我们的工作建立在前人的工作之上。让我们看看我们现在要学习的是什么：</p>\n<h2 id=\"基础理论课\"><a href=\"#基础理论课\" class=\"headerlink\" title=\"基础理论课\"></a>基础理论课</h2><ol>\n<li>数据结构和算法</li>\n<li>操作系统</li>\n<li>计算机组成原理与汇编</li>\n<li>计算机网络</li>\n</ol>\n<p>我列出这四门课，是因为你国内本科结束之后，考研初试要考的就是这四门课。复试的话会涉及到更深入的一点东西，比如：编译原理、软件工程、人工智能、多媒体技术、信号处理。</p>\n<p>这里推荐一本书：</p>\n<p>中文叫：<a href=\"https://book.douban.com/subject/5333562/\" target=\"_blank\" rel=\"noopener\">深入理解计算机系统</a><br>英文叫：<a href=\"https://book.douban.com/subject/26344642/\" target=\"_blank\" rel=\"noopener\">Computer Systems: A Programmer’s Perspective</a>，简称 CSAPP。</p>\n<blockquote>\n<ol>\n<li>有能力的话，尽量看英文版</li>\n<li>看书要做笔记</li>\n<li>习题不要略过，一定要做</li>\n</ol>\n</blockquote>\n<p>这是 CMU（Carnegie Mellon University，卡内基梅隆大学）的计算机入门教材，这本教材对应的课程是 CS 213 ，是很多课程的先修课。</p>\n<p><img src=\"https://i.loli.net/2018/03/25/5ab6fab31181c.jpg\" alt=\"先修课\"></p>\n<p><a href=\"https://www.zhihu.com/question/20402534/answer/124950081\" target=\"_blank\" rel=\"noopener\">如何阅读《深入理解计算机系统》这本书？</a></p>\n<p>看完知乎答主的回答，我们需要注意的是这门课也有一个先修课，是一门编程语言 C0（C 语言的子集），对应的课程是 CS 122，或者你学 Python 也行。CMU一般是给大二学生开这个课，学过C以后就可以上了。</p>\n<p>这本书之所以成为圣经般的入门书，就是因为：</p>\n<ol>\n<li>突出原理</li>\n<li>知识点涵盖非常全</li>\n<li>讲的非常棒（可以说计算机组成原理部分比专门讲这个的书讲的更好，操作系统部分比专门讲操作系统的书讲得好，这完全就是可怕的存在）</li>\n</ol>\n<h2 id=\"理论之外\"><a href=\"#理论之外\" class=\"headerlink\" title=\"理论之外\"></a>理论之外</h2><p>然而仅仅是学习上面的理论是完全不够的。</p>\n<p>我这里要讲的是 ACM，<code>ACM国际大学生程序设计竞赛（ACM International Collegiate Programming Contest, ICPC）</code>的简称，由 ACM（Association for Computing Machinery，（美国）计算机协会）主办。</p>\n<p><img src=\"https://i.loli.net/2018/03/25/5ab6fdd8398c7.png\" alt=\"ACM logo\"></p>\n<p>为什么 ACM 如此重要（以及 ACM 的大奖对本科生找工作的分量这么重），因为编程活动所要依赖的只有一个：抽象和逻辑能力，这就是为什么其实编程可以从小学开始（没有过高的知识门槛）。计算机科学的诸多课程，就是由先辈们靠着抽象和逻辑搭建起来的知识大厦，这些知识和经验是叶，而你抽象和逻辑能力（或者说依靠计算机解决问题的能力）是根。练习 ACM 就跟武术世界里面的李小龙每天练拳一样，是基本功。</p>\n<p>练习 ACM 一般用 Online Judge 系统，这里我推荐几个：</p>\n<ul>\n<li><a href=\"http://poj.org/\" target=\"_blank\" rel=\"noopener\">北京大学的在线裁判系统，简称POJ</a></li>\n<li><a href=\"http://acm.hdu.edu.cn/\" target=\"_blank\" rel=\"noopener\">杭州电子科技大学的在线裁判系统</a></li>\n<li><a href=\"https://leetcode.com/\" target=\"_blank\" rel=\"noopener\">leetcode</a></li>\n</ul>\n<h2 id=\"ACM之外\"><a href=\"#ACM之外\" class=\"headerlink\" title=\"ACM之外\"></a>ACM之外</h2><p>ACM自然跟真正的应用程序的编写是不一样的，当你真正步入开发的时候，你会发现还有非常多的东西要学，一个看似简单的APP，其架构却是非常复杂的，代码量也远超你的想象。那么如何上手学习呢，你也不可能一步登天，一上来就开发一款应用啊。答案自然是：<strong>一个功能，一个功能的实现，慢慢积累，有点像搭积木</strong>。你不要觉得仅实现一个功能会拿不出手，初学者就是这样积累起来的，所以你大可以把你实现的那些小东西都整理好（这也就是我下面会写到的，做好编程札记），<strong>文档和代码都好好保存，因为编程最忌讳的就是重复工作，从零做起</strong>。</p>\n<h2 id=\"脱离-Windows-的襁褓\"><a href=\"#脱离-Windows-的襁褓\" class=\"headerlink\" title=\"脱离 Windows 的襁褓\"></a>脱离 Windows 的襁褓</h2><p>很多人喜欢争论 Linux 和 Windows，就像各种语言之间的争论一样，无休无止。但同样很多人喜欢说，Windows 和 Linux 无所谓，真正的开发者都是什么好用用什么，主要看需求。</p>\n<p>而这里我要说的，跟这些都不一样，对于初学者我的建议一定是：<strong>脱离 Windows 的襁褓</strong>。否则你将很难对计算机的 CLI（Command Line Interface）产生直观性的体验。Linux 让你更贴近事物的原理，让你看的更加清楚，让你脱离不动脑子傻瓜式的鼠标点点点。而之所以那些高手喜欢说 Windows 很好用，没必要用 Linux，是因为他们都是脱离了低级层次，已经到达更高层次的人，他们当然无所谓，Windows 早已蒙蔽不了他们的双眼。这是一种看山还是山，看水还是水的境界。而你不经过历练，是不会到达这个境界的。</p>\n<p>不要一见到命令行就恐惧，正如你不应该一见到英文网站和资料就恐惧一样，这种回避绝对是有害的。</p>\n<p>对于初学者，Linux比mac os x好，因为mac也可以点点点。</p>\n<blockquote>\n<p>当然如果你已经脱离了低级层次，那么我绝对更推荐你用windows，其次是mac，最后是linux。别问我为什么，原因简单到我不想说：支持力度哪家强？（这里说的支持力度包括操作系统层面和应用开发层面）</p>\n</blockquote>\n<h2 id=\"编程心得\"><a href=\"#编程心得\" class=\"headerlink\" title=\"编程心得\"></a>编程心得</h2><p>其实我早就想写一个系列，就叫：<strong>编程心得</strong>，这个里面放上很多编程中的细节问题，就跟网上的笔试面试经典一样，其实这些东西虽然吸收的快，但有些东西还是必须经过亲力亲为才能真正体会到，但我并不反对直接看这种东西，否则我就不必花心思去写了。直接看前人总结的经验非常有好处，这就像武侠世界里的传输内力，人类之所以发展起了文明，就是因为知识的传递非常迅速而有效，我们根本不需要做任何事之前都需要自己做过一遍才知道怎么做，我们往往都借助他人的经验。</p>\n<p>说到这个话题，我觉得有必要强调一下，<strong>编程札记</strong> 这个东西，一直以来我都十分建议，不管是工作还是学习，都要做好记录，特别是重要的点，一定要记下来，比如实现一个东西的时候遇到的困难，以及如何解决的整个过程，有哪些关键点，等等。写这个东西是为了便于回顾，以及衡量自己的工作量。</p>\n<blockquote>\n<p>学而时习之，不亦说乎</p>\n</blockquote>\n<p>目前免费的云笔记首推：有道云笔记，虽然用的没有为知笔记爽，对于穷学生来说还是比较友好的。另外人家后台是网易，而且跟网易云音乐、有道词典、网易公开课、网易云课堂、网易严选等等产品构成了一个网易的高口碑生态链，所以你一定程度上不用担心它关门倒闭。</p>\n<h2 id=\"LaTex-和-Markdown\"><a href=\"#LaTex-和-Markdown\" class=\"headerlink\" title=\"LaTex 和 Markdown\"></a>LaTex 和 Markdown</h2><p>说到文档和笔记的编写，就得推这两个东西了：LaTex是学术界写论文的标准（现在微软的word软件似乎也有一席之地了，毕竟LaTex比word难用多了，特别是对非计算机类的学者来说），排版效果非常棒，我感觉，出版社出版，维基百科词条，也都用得上LaTex。Markdown是github上文档的标准，也是网络上各种野生博主的写作标准，最最关键的点是，mathjax这个组织，让Markdown的便捷和LaTex的强大结合起来了，你可以在Markdown中插入用LaTex书写的数学公式。<strong>这也是我不用简书的原因，简书虽然有Markdown，却不支持mathjax，公式贴图可以啊，但你总不至于写个上下标都贴图吧。</strong></p>\n<p>关于LaTax的手册，我还是希望大家自己去找，在这个时代一定要把自己的搜索能力练起来，特别是寻找 <strong>最权威的资料，最一手的信息</strong>，因为这样你才有可能在比特币刚诞生不久的时候就了解到它，当然很多人会说其实他们早就知道这个东西，只不过一直不想去深入了解。</p>\n<p>当然我也不会吝啬于分享，我先讲讲我如何找这份资料：首先使用google搜索引擎，其次使用英文搜索，输入 <code>LaTex math symbols</code>，我得到的第一条就很不错：<a href=\"https://web.ift.uib.no/Teori/KURS/WRK/TeX/symALL.html\" target=\"_blank\" rel=\"noopener\">LaTex Math Symbols</a>，第二条也不错：<a href=\"https://reu.dimacs.rutgers.edu/Symbols.pdf\" target=\"_blank\" rel=\"noopener\">LATEX Mathematical Symbols</a></p>\n<p>至于要不要把它们加进你的书签，我的建议是这类东西没必要加，你可以仔细思考一下这个搜索有什么特别的，对，他加了 <code>math</code> 这个关键信息，如果你只是单纯的搜索 <code>LaTex</code> 那么你将得到大量无关的信息，但其实你平常用的时候经常就只是用到数学方面的东西。</p>\n<h2 id=\"访问全球网\"><a href=\"#访问全球网\" class=\"headerlink\" title=\"访问全球网\"></a>访问全球网</h2><p>众所周知，我们处于一个国域网当中，如果你想看看外面的世界，必须要学会翻墙。互联网时代，这是必备技能。目前我用的是 <strong>搬瓦工+shadowsocks</strong>。</p>\n<h2 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java\"></a>Java</h2><ul>\n<li><a href=\"../2018/02/27/Java-OutputStream-flush\">Java OutputStream flush</a></li>\n</ul>\n<h2 id=\"C\"><a href=\"#C\" class=\"headerlink\" title=\"C++\"></a>C++</h2><ul>\n<li><a href=\"../2017/10/19/Inside-the-C++-Object-Model-系列笔记--Object-Lessons\">Inside the C++ Object Model 系列笔记 一 – Object Lessons</a></li>\n<li><a href=\"../2017/10/19/Inside-the-C++-Object-Model-系列笔记--The-Semantics-of-constructors\">Inside the C++ Object Model 系列笔记 二 – The Semantics of constructors</a></li>\n<li><a href=\"../2017/10/21/Inside-the-C++-Object-Model-系列笔记--The-Semantics-of-Data\">Inside the C++ Object Model 系列笔记 三 – The Semantics of Data</a></li>\n<li><a href=\"../2017/10/23/Inside-the-C++-Object-Model-系列笔记--The-Semantics-of-Function\">Inside the C++ Object Model 系列笔记 四 – The Semantics of Function</a></li>\n</ul>\n<h2 id=\"PeKing-University-Online-Judge\"><a href=\"#PeKing-University-Online-Judge\" class=\"headerlink\" title=\"PeKing University Online Judge\"></a>PeKing University Online Judge</h2><p>这个POJ相比于 leetcode 的不同就是：</p>\n<p>出现的年代比 leetcode 这种更早，考察的范围比 leetcode 更广<br>需要自己处理输入输出，以及更宽泛的发挥空间（要编写一个完整的程序，包括头文件或者引用了哪些库），而 leetcode 则一般只给出一个函数，让你填写完整。</p>\n<ul>\n<li><a href=\"../2018/01/20/POJ-1001-Exponentiation\">POJ 1001 Exponentiation</a></li>\n<li><a href=\"../2018/01/21/POJ-1002-487-3279\">POJ 1002 487 3279</a></li>\n<li><a href=\"../2018/01/21/POJ-1003-Hangover\">POJ 1003 Hangover</a></li>\n<li><a href=\"../2018/01/21/POJ-1004-Financial-Management\">POJ 1004 Financial Management</a></li>\n<li><a href=\"../2018/01/21/POJ-1005-I-Think-I-Need-a-Houseboat\">POJ 1005 I Think I Need a Houseboat</a></li>\n<li><a href=\"../2018/02/15/POJ-1006-Biorhythms\">POJ 1006 Biorhythms</a></li>\n<li><a href=\"../2018/02/21/POJ-1007-DNA-sorting\">POJ 1007 DNA sorting</a></li>\n<li><a href=\"../2018/02/22/POJ-1008-Maya-Calendar\">POJ 1008 Maya Calendar</a></li>\n<li><a href=\"../2018/02/24/POJ-1009-Edge-Detection\">POJ 1009 Edge Detection</a></li>\n</ul>\n<h2 id=\"leetcode-刷题\"><a href=\"#leetcode-刷题\" class=\"headerlink\" title=\"leetcode 刷题\"></a>leetcode 刷题</h2><p>leetcode是一个 Online Judge 网站，在线练习编程，尤其是练习数据结构和算法相关的题。</p>\n<p>刷OJ对于锻炼自己的计算机思维，算法能力，对常用编程语言的数据结构部分的熟练使用，都是非常有帮助的。</p>\n<p>这个系列中，我将提供leetcode上 <strong>所有免费题目的答案</strong>，并提供 <strong>详细的解答思路</strong>，所使用的编程语言有：<strong>Python、C++、Java、JavaScript</strong>。</p>\n<h3 id=\"一些建议：\"><a href=\"#一些建议：\" class=\"headerlink\" title=\"一些建议：\"></a>一些建议：</h3><ol>\n<li>按照AC（accepted）率从高到低刷题，这样就会从易到难，提供一个进步的缓冲空间，不至于一上来就被打击到。不过其实 AC 率并不真实，因为 leetcode 比较出名的缘故，所以很多题都可以在网上找到答案和解题思路。leetcode给每道题都配备了难度信息，有 Easy、Medium、Hard 三个难度等级。你也可以按照这个从易到难刷题。</li>\n<li>按照算法和数据结构体系，逐个模块的掌握，leetcode已经按照 <strong>数据结构、公司、最受欢迎</strong> 等等属性给题目做了划分，而且会提示哪些题目是类似的，另外网上也有不少按算法和数据结构总结的解答电子书可以参照。</li>\n<li>做不出来的时候可以看leetcode网站上的 Discuss 和 Solutions ，有不少大神的解题方法和精简代码。当然也可以在互联网上搜索，有很多讲解leetcode的博客。</li>\n</ol>\n<p>我的这份教程将从 <code>String</code> 模块开始，按照 AC 率刷题。</p>\n<h3 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h3><ul>\n<li><a href=\"\">632. Smallest Range</a></li>\n</ul>\n<h3 id=\"未整理部分\"><a href=\"#未整理部分\" class=\"headerlink\" title=\"未整理部分\"></a>未整理部分</h3><ul>\n<li><a href=\"\">2. Add Two Numbers</a></li>\n<li><a href=\"\">3. Longest Substring Without Repeating Characters</a></li>\n<li><a href=\"\">13. Roman to Integer</a></li>\n<li><a href=\"\">22. Generate Parentheses</a></li>\n<li><a href=\"\">34. Search for a Range</a></li>\n<li><a href=\"\">383. Ransom Note</a></li>\n<li><a href=\"\">541. Reverse String II</a></li>\n<li><a href=\"\">583. Delete Operation for Two Strings</a></li>\n<li><a href=\"\">606. Construct String from Binary Tree</a></li>\n<li><a href=\"\">657. Judge Route Circle</a></li>\n<li><a href=\"\">551. Student Attendance Record I</a></li>\n</ul>\n"},{"title":"人生经验","date":"2018-04-17T02:41:06.000Z","_content":"\n## 思考和总结\n\n- [我读大学时候的一些思考](../2017/02/06/我读大学时候的一些思考)\n- [游戏人生–探险者的人生手册](../2017/01/26/游戏人生--探险者的人生手册)\n- [学习方法总结](../2017/01/02/学习方法总结)\n- [哲学思考](../2018/06/03/哲学思考)\n\n## 推荐\n\n### 故事类\n\n- [那些年我读过的好故事](../2017/01/10/那些年我读过的好故事)    \n\n### 工具类\n\n- [Macbook](../2017/02/03/Macbook)\n- [从 Windows 转用 Mac OS X 记录](../2017/01/01/从windows转用macOSX记录)\n\n## 如何学习\n\n1. 概念学习法，这是我从罗胖那儿学来的，非常不错的方法，把要用到的概念明晰抓牢，人类不就是靠制造概念来传递知识的吗。\n2. 用最简单的方式学习，也就是联系已有的知识结构。\n\n  \n\n","source":"Life-Experience/index.md","raw":"---\ntitle: 人生经验\ndate: 2018-04-17 10:41:06\n---\n\n## 思考和总结\n\n- [我读大学时候的一些思考](../2017/02/06/我读大学时候的一些思考)\n- [游戏人生–探险者的人生手册](../2017/01/26/游戏人生--探险者的人生手册)\n- [学习方法总结](../2017/01/02/学习方法总结)\n- [哲学思考](../2018/06/03/哲学思考)\n\n## 推荐\n\n### 故事类\n\n- [那些年我读过的好故事](../2017/01/10/那些年我读过的好故事)    \n\n### 工具类\n\n- [Macbook](../2017/02/03/Macbook)\n- [从 Windows 转用 Mac OS X 记录](../2017/01/01/从windows转用macOSX记录)\n\n## 如何学习\n\n1. 概念学习法，这是我从罗胖那儿学来的，非常不错的方法，把要用到的概念明晰抓牢，人类不就是靠制造概念来传递知识的吗。\n2. 用最简单的方式学习，也就是联系已有的知识结构。\n\n  \n\n","updated":"2018-06-03T04:58:05.641Z","path":"Life-Experience/index.html","comments":1,"layout":"page","_id":"cjm2w8d5i0002fgpxr7aqzl48","content":"<h2 id=\"思考和总结\"><a href=\"#思考和总结\" class=\"headerlink\" title=\"思考和总结\"></a>思考和总结</h2><ul>\n<li><a href=\"../2017/02/06/我读大学时候的一些思考\">我读大学时候的一些思考</a></li>\n<li><a href=\"../2017/01/26/游戏人生--探险者的人生手册\">游戏人生–探险者的人生手册</a></li>\n<li><a href=\"../2017/01/02/学习方法总结\">学习方法总结</a></li>\n<li><a href=\"../2018/06/03/哲学思考\">哲学思考</a></li>\n</ul>\n<h2 id=\"推荐\"><a href=\"#推荐\" class=\"headerlink\" title=\"推荐\"></a>推荐</h2><h3 id=\"故事类\"><a href=\"#故事类\" class=\"headerlink\" title=\"故事类\"></a>故事类</h3><ul>\n<li><a href=\"../2017/01/10/那些年我读过的好故事\">那些年我读过的好故事</a>    </li>\n</ul>\n<h3 id=\"工具类\"><a href=\"#工具类\" class=\"headerlink\" title=\"工具类\"></a>工具类</h3><ul>\n<li><a href=\"../2017/02/03/Macbook\">Macbook</a></li>\n<li><a href=\"../2017/01/01/从windows转用macOSX记录\">从 Windows 转用 Mac OS X 记录</a></li>\n</ul>\n<h2 id=\"如何学习\"><a href=\"#如何学习\" class=\"headerlink\" title=\"如何学习\"></a>如何学习</h2><ol>\n<li>概念学习法，这是我从罗胖那儿学来的，非常不错的方法，把要用到的概念明晰抓牢，人类不就是靠制造概念来传递知识的吗。</li>\n<li>用最简单的方式学习，也就是联系已有的知识结构。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"思考和总结\"><a href=\"#思考和总结\" class=\"headerlink\" title=\"思考和总结\"></a>思考和总结</h2><ul>\n<li><a href=\"../2017/02/06/我读大学时候的一些思考\">我读大学时候的一些思考</a></li>\n<li><a href=\"../2017/01/26/游戏人生--探险者的人生手册\">游戏人生–探险者的人生手册</a></li>\n<li><a href=\"../2017/01/02/学习方法总结\">学习方法总结</a></li>\n<li><a href=\"../2018/06/03/哲学思考\">哲学思考</a></li>\n</ul>\n<h2 id=\"推荐\"><a href=\"#推荐\" class=\"headerlink\" title=\"推荐\"></a>推荐</h2><h3 id=\"故事类\"><a href=\"#故事类\" class=\"headerlink\" title=\"故事类\"></a>故事类</h3><ul>\n<li><a href=\"../2017/01/10/那些年我读过的好故事\">那些年我读过的好故事</a>    </li>\n</ul>\n<h3 id=\"工具类\"><a href=\"#工具类\" class=\"headerlink\" title=\"工具类\"></a>工具类</h3><ul>\n<li><a href=\"../2017/02/03/Macbook\">Macbook</a></li>\n<li><a href=\"../2017/01/01/从windows转用macOSX记录\">从 Windows 转用 Mac OS X 记录</a></li>\n</ul>\n<h2 id=\"如何学习\"><a href=\"#如何学习\" class=\"headerlink\" title=\"如何学习\"></a>如何学习</h2><ol>\n<li>概念学习法，这是我从罗胖那儿学来的，非常不错的方法，把要用到的概念明晰抓牢，人类不就是靠制造概念来传递知识的吗。</li>\n<li>用最简单的方式学习，也就是联系已有的知识结构。</li>\n</ol>\n"},{"title":"Math","date":"2018-04-27T08:07:48.000Z","_content":"\n>数学是科学的王冠\n\n抽象是人类智慧的体现。如果说有什么学问是非常完美的诠释了抽象，那么这么学问非数学莫属。\n\n## 大学数学基础\n\n1. 微积分\n2. 线性代数\n3. 概率论与数理统计\n\n>我一直觉得数学的第一要义是推导，你只需要不停的推导，得到一张数学图谱，那么我就会说你的数学学的好。\n\n下面是我的一些数学笔记：\n\n- [数学基础公式推导](../2018/04/25/数学基础公式推导)\n\n### 线性代数\n\n- [线性代数笔记--线性代数复习核心思想](../2016/09/30/线性代数笔记--线性代数复习核心思想)\n- [线性代数笔记--基础篇：行列式、矩阵的本质](../2016/09/30/线性代数笔记--基础篇：行列式、矩阵的本质)\n","source":"Math/index.md","raw":"---\ntitle: Math\ndate: 2018-04-27 16:07:48\n---\n\n>数学是科学的王冠\n\n抽象是人类智慧的体现。如果说有什么学问是非常完美的诠释了抽象，那么这么学问非数学莫属。\n\n## 大学数学基础\n\n1. 微积分\n2. 线性代数\n3. 概率论与数理统计\n\n>我一直觉得数学的第一要义是推导，你只需要不停的推导，得到一张数学图谱，那么我就会说你的数学学的好。\n\n下面是我的一些数学笔记：\n\n- [数学基础公式推导](../2018/04/25/数学基础公式推导)\n\n### 线性代数\n\n- [线性代数笔记--线性代数复习核心思想](../2016/09/30/线性代数笔记--线性代数复习核心思想)\n- [线性代数笔记--基础篇：行列式、矩阵的本质](../2016/09/30/线性代数笔记--基础篇：行列式、矩阵的本质)\n","updated":"2018-04-27T08:14:49.130Z","path":"Math/index.html","comments":1,"layout":"page","_id":"cjm2w8d5l0006fgpxnma5j5dh","content":"<blockquote>\n<p>数学是科学的王冠</p>\n</blockquote>\n<p>抽象是人类智慧的体现。如果说有什么学问是非常完美的诠释了抽象，那么这么学问非数学莫属。</p>\n<h2 id=\"大学数学基础\"><a href=\"#大学数学基础\" class=\"headerlink\" title=\"大学数学基础\"></a>大学数学基础</h2><ol>\n<li>微积分</li>\n<li>线性代数</li>\n<li>概率论与数理统计</li>\n</ol>\n<blockquote>\n<p>我一直觉得数学的第一要义是推导，你只需要不停的推导，得到一张数学图谱，那么我就会说你的数学学的好。</p>\n</blockquote>\n<p>下面是我的一些数学笔记：</p>\n<ul>\n<li><a href=\"../2018/04/25/数学基础公式推导\">数学基础公式推导</a></li>\n</ul>\n<h3 id=\"线性代数\"><a href=\"#线性代数\" class=\"headerlink\" title=\"线性代数\"></a>线性代数</h3><ul>\n<li><a href=\"../2016/09/30/线性代数笔记--线性代数复习核心思想\">线性代数笔记–线性代数复习核心思想</a></li>\n<li><a href=\"../2016/09/30/线性代数笔记--基础篇：行列式、矩阵的本质\">线性代数笔记–基础篇：行列式、矩阵的本质</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>数学是科学的王冠</p>\n</blockquote>\n<p>抽象是人类智慧的体现。如果说有什么学问是非常完美的诠释了抽象，那么这么学问非数学莫属。</p>\n<h2 id=\"大学数学基础\"><a href=\"#大学数学基础\" class=\"headerlink\" title=\"大学数学基础\"></a>大学数学基础</h2><ol>\n<li>微积分</li>\n<li>线性代数</li>\n<li>概率论与数理统计</li>\n</ol>\n<blockquote>\n<p>我一直觉得数学的第一要义是推导，你只需要不停的推导，得到一张数学图谱，那么我就会说你的数学学的好。</p>\n</blockquote>\n<p>下面是我的一些数学笔记：</p>\n<ul>\n<li><a href=\"../2018/04/25/数学基础公式推导\">数学基础公式推导</a></li>\n</ul>\n<h3 id=\"线性代数\"><a href=\"#线性代数\" class=\"headerlink\" title=\"线性代数\"></a>线性代数</h3><ul>\n<li><a href=\"../2016/09/30/线性代数笔记--线性代数复习核心思想\">线性代数笔记–线性代数复习核心思想</a></li>\n<li><a href=\"../2016/09/30/线性代数笔记--基础篇：行列式、矩阵的本质\">线性代数笔记–基础篇：行列式、矩阵的本质</a></li>\n</ul>\n"},{"title":"about","date":"2018-04-17T09:00:10.000Z","_content":"\n我叫刘钦，一个喜欢思考，不甘平凡的人。\n\n生于1994年，来自于湖南省一个小县城，2016年本科毕业于中南大学，在Arcsoft工作过一年。现就职于湖南衍金。\n\n去过的城市：\n\n- 长沙\n- 北京\n- 深圳\n- 杭州\n- 上海\n\n持有的币：\n\n- BTC\n- LBTC\n- BTS\n- EOS\n- IPFS\n\n## 我为什么要写博客\n\n人都是善于遗忘的，如果我们不做些记录，那么那些曾今做过的事就会被慢慢淡忘。你想想，如果人类不把自己的经验和知识口口相传，或者写成书籍流传于世，那么那些曾今摔过一遍的坑，做过的冒险，不就都失去了应有的价值了吗？为了给后来者一些建议，让他们知道，他们并不是一个人在战斗，同时为了记录自己曾今的那些时光，这就是我写博客的原因。\n\n## 兴趣爱好\n\n- 数学、物理、信息科学\n- 写作、科幻、人生经验、未来\n- 编程\n\n### 玩过的游戏\n\n- 俄罗斯方块\n- 贪食蛇\n- 魔塔\n- 植物大战僵尸\n- 愤怒的小鸟\n- 保卫萝卜\n- 红色警戒\n- 魔兽争霸\n- 英雄联盟\n- 王者荣耀\n- Dota\n- 炉石传说\n- 饥荒\n- Minecraft\n\n## 博客用户手册\n\n博客整体分为三块：\n\n1. 左侧，包括了博客的title：`liuqinh2s' blog`；网站目录：Home、About、信息科学、人生经验、数学。其中点击`Home`和点击`liuqinh2s's blog`的效果是一样的，都是回到首页。左侧的下半部分包括：站点概览和文章的目录。\n2. 站点概览里面可以看到我的头像，座右铭，以及三种分类：归档(posts)、分类(categories)、标签(tags)，点击可以进入相应的分类里面。下面是RSS，接下来是我常用的社交平台，最后是友链。\n2. 右边是博客的文章\n3. 底部是版权、站点访问量\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2018-04-17 17:00:10\n---\n\n我叫刘钦，一个喜欢思考，不甘平凡的人。\n\n生于1994年，来自于湖南省一个小县城，2016年本科毕业于中南大学，在Arcsoft工作过一年。现就职于湖南衍金。\n\n去过的城市：\n\n- 长沙\n- 北京\n- 深圳\n- 杭州\n- 上海\n\n持有的币：\n\n- BTC\n- LBTC\n- BTS\n- EOS\n- IPFS\n\n## 我为什么要写博客\n\n人都是善于遗忘的，如果我们不做些记录，那么那些曾今做过的事就会被慢慢淡忘。你想想，如果人类不把自己的经验和知识口口相传，或者写成书籍流传于世，那么那些曾今摔过一遍的坑，做过的冒险，不就都失去了应有的价值了吗？为了给后来者一些建议，让他们知道，他们并不是一个人在战斗，同时为了记录自己曾今的那些时光，这就是我写博客的原因。\n\n## 兴趣爱好\n\n- 数学、物理、信息科学\n- 写作、科幻、人生经验、未来\n- 编程\n\n### 玩过的游戏\n\n- 俄罗斯方块\n- 贪食蛇\n- 魔塔\n- 植物大战僵尸\n- 愤怒的小鸟\n- 保卫萝卜\n- 红色警戒\n- 魔兽争霸\n- 英雄联盟\n- 王者荣耀\n- Dota\n- 炉石传说\n- 饥荒\n- Minecraft\n\n## 博客用户手册\n\n博客整体分为三块：\n\n1. 左侧，包括了博客的title：`liuqinh2s' blog`；网站目录：Home、About、信息科学、人生经验、数学。其中点击`Home`和点击`liuqinh2s's blog`的效果是一样的，都是回到首页。左侧的下半部分包括：站点概览和文章的目录。\n2. 站点概览里面可以看到我的头像，座右铭，以及三种分类：归档(posts)、分类(categories)、标签(tags)，点击可以进入相应的分类里面。下面是RSS，接下来是我常用的社交平台，最后是友链。\n2. 右边是博客的文章\n3. 底部是版权、站点访问量\n","updated":"2018-06-10T01:49:17.671Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjm2w8d5n0008fgpxquy1yq9b","content":"<p>我叫刘钦，一个喜欢思考，不甘平凡的人。</p>\n<p>生于1994年，来自于湖南省一个小县城，2016年本科毕业于中南大学，在Arcsoft工作过一年。现就职于湖南衍金。</p>\n<p>去过的城市：</p>\n<ul>\n<li>长沙</li>\n<li>北京</li>\n<li>深圳</li>\n<li>杭州</li>\n<li>上海</li>\n</ul>\n<p>持有的币：</p>\n<ul>\n<li>BTC</li>\n<li>LBTC</li>\n<li>BTS</li>\n<li>EOS</li>\n<li>IPFS</li>\n</ul>\n<h2 id=\"我为什么要写博客\"><a href=\"#我为什么要写博客\" class=\"headerlink\" title=\"我为什么要写博客\"></a>我为什么要写博客</h2><p>人都是善于遗忘的，如果我们不做些记录，那么那些曾今做过的事就会被慢慢淡忘。你想想，如果人类不把自己的经验和知识口口相传，或者写成书籍流传于世，那么那些曾今摔过一遍的坑，做过的冒险，不就都失去了应有的价值了吗？为了给后来者一些建议，让他们知道，他们并不是一个人在战斗，同时为了记录自己曾今的那些时光，这就是我写博客的原因。</p>\n<h2 id=\"兴趣爱好\"><a href=\"#兴趣爱好\" class=\"headerlink\" title=\"兴趣爱好\"></a>兴趣爱好</h2><ul>\n<li>数学、物理、信息科学</li>\n<li>写作、科幻、人生经验、未来</li>\n<li>编程</li>\n</ul>\n<h3 id=\"玩过的游戏\"><a href=\"#玩过的游戏\" class=\"headerlink\" title=\"玩过的游戏\"></a>玩过的游戏</h3><ul>\n<li>俄罗斯方块</li>\n<li>贪食蛇</li>\n<li>魔塔</li>\n<li>植物大战僵尸</li>\n<li>愤怒的小鸟</li>\n<li>保卫萝卜</li>\n<li>红色警戒</li>\n<li>魔兽争霸</li>\n<li>英雄联盟</li>\n<li>王者荣耀</li>\n<li>Dota</li>\n<li>炉石传说</li>\n<li>饥荒</li>\n<li>Minecraft</li>\n</ul>\n<h2 id=\"博客用户手册\"><a href=\"#博客用户手册\" class=\"headerlink\" title=\"博客用户手册\"></a>博客用户手册</h2><p>博客整体分为三块：</p>\n<ol>\n<li>左侧，包括了博客的title：<code>liuqinh2s&#39; blog</code>；网站目录：Home、About、信息科学、人生经验、数学。其中点击<code>Home</code>和点击<code>liuqinh2s&#39;s blog</code>的效果是一样的，都是回到首页。左侧的下半部分包括：站点概览和文章的目录。</li>\n<li>站点概览里面可以看到我的头像，座右铭，以及三种分类：归档(posts)、分类(categories)、标签(tags)，点击可以进入相应的分类里面。下面是RSS，接下来是我常用的社交平台，最后是友链。</li>\n<li>右边是博客的文章</li>\n<li>底部是版权、站点访问量</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>我叫刘钦，一个喜欢思考，不甘平凡的人。</p>\n<p>生于1994年，来自于湖南省一个小县城，2016年本科毕业于中南大学，在Arcsoft工作过一年。现就职于湖南衍金。</p>\n<p>去过的城市：</p>\n<ul>\n<li>长沙</li>\n<li>北京</li>\n<li>深圳</li>\n<li>杭州</li>\n<li>上海</li>\n</ul>\n<p>持有的币：</p>\n<ul>\n<li>BTC</li>\n<li>LBTC</li>\n<li>BTS</li>\n<li>EOS</li>\n<li>IPFS</li>\n</ul>\n<h2 id=\"我为什么要写博客\"><a href=\"#我为什么要写博客\" class=\"headerlink\" title=\"我为什么要写博客\"></a>我为什么要写博客</h2><p>人都是善于遗忘的，如果我们不做些记录，那么那些曾今做过的事就会被慢慢淡忘。你想想，如果人类不把自己的经验和知识口口相传，或者写成书籍流传于世，那么那些曾今摔过一遍的坑，做过的冒险，不就都失去了应有的价值了吗？为了给后来者一些建议，让他们知道，他们并不是一个人在战斗，同时为了记录自己曾今的那些时光，这就是我写博客的原因。</p>\n<h2 id=\"兴趣爱好\"><a href=\"#兴趣爱好\" class=\"headerlink\" title=\"兴趣爱好\"></a>兴趣爱好</h2><ul>\n<li>数学、物理、信息科学</li>\n<li>写作、科幻、人生经验、未来</li>\n<li>编程</li>\n</ul>\n<h3 id=\"玩过的游戏\"><a href=\"#玩过的游戏\" class=\"headerlink\" title=\"玩过的游戏\"></a>玩过的游戏</h3><ul>\n<li>俄罗斯方块</li>\n<li>贪食蛇</li>\n<li>魔塔</li>\n<li>植物大战僵尸</li>\n<li>愤怒的小鸟</li>\n<li>保卫萝卜</li>\n<li>红色警戒</li>\n<li>魔兽争霸</li>\n<li>英雄联盟</li>\n<li>王者荣耀</li>\n<li>Dota</li>\n<li>炉石传说</li>\n<li>饥荒</li>\n<li>Minecraft</li>\n</ul>\n<h2 id=\"博客用户手册\"><a href=\"#博客用户手册\" class=\"headerlink\" title=\"博客用户手册\"></a>博客用户手册</h2><p>博客整体分为三块：</p>\n<ol>\n<li>左侧，包括了博客的title：<code>liuqinh2s&#39; blog</code>；网站目录：Home、About、信息科学、人生经验、数学。其中点击<code>Home</code>和点击<code>liuqinh2s&#39;s blog</code>的效果是一样的，都是回到首页。左侧的下半部分包括：站点概览和文章的目录。</li>\n<li>站点概览里面可以看到我的头像，座右铭，以及三种分类：归档(posts)、分类(categories)、标签(tags)，点击可以进入相应的分类里面。下面是RSS，接下来是我常用的社交平台，最后是友链。</li>\n<li>右边是博客的文章</li>\n<li>底部是版权、站点访问量</li>\n</ol>\n"},{"title":"categories","date":"2018-04-24T01:16:14.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2018-04-24 09:16:14\ntype: categories\n---\n","updated":"2018-04-24T01:20:40.127Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjm2w8dbf000ofgpxde8ac5hx","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2018-04-24T01:21:45.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-04-24 09:21:45\ntype: tags\n---\n","updated":"2018-04-24T01:21:55.300Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjm2w8dbg000pfgpxgjoy3dr5","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"2018-06-12-《代码整洁之道》读书笔记-第3章-函数","comments":1,"_content":"\n在编程的早年岁月，系统由程序和子程序组成。后来，在Fortran和PL/1的年代，系统由程序、子程序和函数组成。如今，只有函数存活下来。函数是所有程序中的第一组代码。\n\n>在计算机领域，很多问题都是历史原因引起的，比如千年虫。因为计算机的发展非常之迅速，特别是硬件行业的发展，使得原先的很多稀有资源：比如存储和算力变得越来越便宜。软件行业也就向着更平易近人、更大规模演进。\n\n看看下面的代码：\n\n```Java\npublic static String testableHtml(PageData pageData, boolean includeSuiteSetup) throws Exception {\n    WikiPage wikiPage = pageData.getWikiPage();\n    StringBuffer buffer = new StringBuffer();\n    if (pageData.hasAttribute(\"Test\")) {\n        if(includeSuiteSetup){\n            WikiPage suiteSetup = PageCrawlerImpl.getInheritedPage(SuiteResponder.SUITE_SETUP_NAME, wikiPage);\n            if(suiteSetup != null){\n                WikiPagePath pagePath = suiteSetup.getPageCrawler().getFullPath(suiteSetup);\n                String pagePathName = PathParser.render(pagePath);\n                buffer.append(\"!include -setup .\")\n                      .append(pagePathName)\n                      .append(\"\\n\");\n            }\n        }\n        WikiPage setup = PageCrawlerImpl.getInheritedPage(\"SetUp\", wikiPage);\n        if(setup != null){\n            WikiPagePath setupPath = wikiPage.getPageCrawler().getFullPath(setup);\n            String setupPathName = PathParser.render(setupPath);\n            buffer.append(\"!include -setup .\")\n                  .append(setupPathName)\n                  .append(\"\\n\");\n        }\n    }\n    buffer.append(pageData.getContent());\n    if(pageData.hasAttribute(\"Test\")){\n        WikiPage teardown = PageCrawlerImpl.getInheritedPage(\"TearDown\", wikiPage);\n        if(teardown!=null){\n            WikiPagePath tearDownPath = wikiPage.getPageCrawler().getFullPath(teardown);\n            String tearDownPathName = PathParser.render(tearDownPath);\n            buffer.append(\"!include -teardown .\")\n                  .append(tearDownPathName)\n                  .append(\"\\n\");\n        }\n        if(includeSuiteSetup){\n            WikiPage suiteTeardown = PageCrawlerImpl.getInheritedPage(SuiteReponder.SUITE_TEARDOWN_NAME, wikiPage);\n            if(suiteTeardown!=null){\n                WikiPagePath pagePath = suiteTeardown.getPageCrawler().getFullPath(suiteTeardown);\n                String pagePathName = PathParse.render(pagePath);\n                buffer.append(\"!include -teardown .\")\n                      .append(pagePathName)\n                      .append(\"\\n\");\n            }\n        }\n    }\n    pageData.setContent(buffer.toString());\n    return pageData.getHtml();\n}\n```\n\n搞懂这个函数了吗？大概没有。**有太多事发生，有太多不懂层级的抽象。奇怪的字符串和函数调用，混以双重嵌套、用标识来控制的if语句等，不一而足。**\n\n不过，只要做几个简单的方法抽离和重命名操作，加上一点点重构，就能在9行代码之内搞定。\n\n```Java\npublic static String renderPageWithSetupsAndTeardown(PageData pageData, boolean isSuite) throws Exception{\n    boolean isTestPage = pageData.hasAttribute(\"Test\");\n    if(isTestPage){\n        WikiPage testPage = pageData.getWikiPage();\n        StringBuffer newPageContent = new StringBuffer();\n        includeSetupPages(testPage, newPageContent, isSuite);\n        newPageContent.append(pageData.getContent());\n        includeTeardownPages(testPage, newPageContent, isSuite);\n        pageData.setContent(newPageContent.toString());\n    }\n    return pageData.getHtml();\n}\n```\n\n除非你正在研究FitNesse，否则就理解不了所有细节。不过，你大概能明白，该函数包含把一些设置和拆解页放入一个测试页面，再渲染为HTML的操作。如果你熟悉JUnit，或许会想到，该函数归属于某个基于Web的测试框架。\n\n## 短小\n\n**函数的第一规则是要短小。第二条规则还要更短小**。\n\n### 代码块和缩进\n\nif语句、else语句、while语句等，其中的代码块应该只有一行。该行大抵应该是一个函数调用语句。这样不但能保持函数短小，而且，因为块内调用的函数拥有较具说明性的名称，从而增加了文档上的价值。\n\n这也意味着函数不应该大到足以容纳嵌套结构。所以，函数的缩进层级不该多于一层或两层。当然，这样的函数易于阅读和理解。\n\n### 只做一件事\n\n函数应该做一件事。做好这件事。只做这一件事。","source":"_drafts/2018-06-12-《代码整洁之道》读书笔记-第3章-函数.md","raw":"---\ntitle: 2018-06-12-《代码整洁之道》读书笔记-第3章-函数\ntags:\n  - 代码规范\ncategories:\n  - 读书笔记\n  - 《代码整洁之道》\ncomments: true\n---\n\n在编程的早年岁月，系统由程序和子程序组成。后来，在Fortran和PL/1的年代，系统由程序、子程序和函数组成。如今，只有函数存活下来。函数是所有程序中的第一组代码。\n\n>在计算机领域，很多问题都是历史原因引起的，比如千年虫。因为计算机的发展非常之迅速，特别是硬件行业的发展，使得原先的很多稀有资源：比如存储和算力变得越来越便宜。软件行业也就向着更平易近人、更大规模演进。\n\n看看下面的代码：\n\n```Java\npublic static String testableHtml(PageData pageData, boolean includeSuiteSetup) throws Exception {\n    WikiPage wikiPage = pageData.getWikiPage();\n    StringBuffer buffer = new StringBuffer();\n    if (pageData.hasAttribute(\"Test\")) {\n        if(includeSuiteSetup){\n            WikiPage suiteSetup = PageCrawlerImpl.getInheritedPage(SuiteResponder.SUITE_SETUP_NAME, wikiPage);\n            if(suiteSetup != null){\n                WikiPagePath pagePath = suiteSetup.getPageCrawler().getFullPath(suiteSetup);\n                String pagePathName = PathParser.render(pagePath);\n                buffer.append(\"!include -setup .\")\n                      .append(pagePathName)\n                      .append(\"\\n\");\n            }\n        }\n        WikiPage setup = PageCrawlerImpl.getInheritedPage(\"SetUp\", wikiPage);\n        if(setup != null){\n            WikiPagePath setupPath = wikiPage.getPageCrawler().getFullPath(setup);\n            String setupPathName = PathParser.render(setupPath);\n            buffer.append(\"!include -setup .\")\n                  .append(setupPathName)\n                  .append(\"\\n\");\n        }\n    }\n    buffer.append(pageData.getContent());\n    if(pageData.hasAttribute(\"Test\")){\n        WikiPage teardown = PageCrawlerImpl.getInheritedPage(\"TearDown\", wikiPage);\n        if(teardown!=null){\n            WikiPagePath tearDownPath = wikiPage.getPageCrawler().getFullPath(teardown);\n            String tearDownPathName = PathParser.render(tearDownPath);\n            buffer.append(\"!include -teardown .\")\n                  .append(tearDownPathName)\n                  .append(\"\\n\");\n        }\n        if(includeSuiteSetup){\n            WikiPage suiteTeardown = PageCrawlerImpl.getInheritedPage(SuiteReponder.SUITE_TEARDOWN_NAME, wikiPage);\n            if(suiteTeardown!=null){\n                WikiPagePath pagePath = suiteTeardown.getPageCrawler().getFullPath(suiteTeardown);\n                String pagePathName = PathParse.render(pagePath);\n                buffer.append(\"!include -teardown .\")\n                      .append(pagePathName)\n                      .append(\"\\n\");\n            }\n        }\n    }\n    pageData.setContent(buffer.toString());\n    return pageData.getHtml();\n}\n```\n\n搞懂这个函数了吗？大概没有。**有太多事发生，有太多不懂层级的抽象。奇怪的字符串和函数调用，混以双重嵌套、用标识来控制的if语句等，不一而足。**\n\n不过，只要做几个简单的方法抽离和重命名操作，加上一点点重构，就能在9行代码之内搞定。\n\n```Java\npublic static String renderPageWithSetupsAndTeardown(PageData pageData, boolean isSuite) throws Exception{\n    boolean isTestPage = pageData.hasAttribute(\"Test\");\n    if(isTestPage){\n        WikiPage testPage = pageData.getWikiPage();\n        StringBuffer newPageContent = new StringBuffer();\n        includeSetupPages(testPage, newPageContent, isSuite);\n        newPageContent.append(pageData.getContent());\n        includeTeardownPages(testPage, newPageContent, isSuite);\n        pageData.setContent(newPageContent.toString());\n    }\n    return pageData.getHtml();\n}\n```\n\n除非你正在研究FitNesse，否则就理解不了所有细节。不过，你大概能明白，该函数包含把一些设置和拆解页放入一个测试页面，再渲染为HTML的操作。如果你熟悉JUnit，或许会想到，该函数归属于某个基于Web的测试框架。\n\n## 短小\n\n**函数的第一规则是要短小。第二条规则还要更短小**。\n\n### 代码块和缩进\n\nif语句、else语句、while语句等，其中的代码块应该只有一行。该行大抵应该是一个函数调用语句。这样不但能保持函数短小，而且，因为块内调用的函数拥有较具说明性的名称，从而增加了文档上的价值。\n\n这也意味着函数不应该大到足以容纳嵌套结构。所以，函数的缩进层级不该多于一层或两层。当然，这样的函数易于阅读和理解。\n\n### 只做一件事\n\n函数应该做一件事。做好这件事。只做这一件事。","slug":"2018-06-12-《代码整洁之道》读书笔记-第3章-函数","published":0,"date":"2018-06-12T13:00:04.641Z","updated":"2018-06-16T02:04:44.311Z","layout":"post","photos":[],"link":"","_id":"cjm2w8d5f0001fgpxl696hh7p","content":"<p>在编程的早年岁月，系统由程序和子程序组成。后来，在Fortran和PL/1的年代，系统由程序、子程序和函数组成。如今，只有函数存活下来。函数是所有程序中的第一组代码。</p>\n<blockquote>\n<p>在计算机领域，很多问题都是历史原因引起的，比如千年虫。因为计算机的发展非常之迅速，特别是硬件行业的发展，使得原先的很多稀有资源：比如存储和算力变得越来越便宜。软件行业也就向着更平易近人、更大规模演进。</p>\n</blockquote>\n<p>看看下面的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">testableHtml</span><span class=\"params\">(PageData pageData, <span class=\"keyword\">boolean</span> includeSuiteSetup)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    WikiPage wikiPage = pageData.getWikiPage();</span><br><span class=\"line\">    StringBuffer buffer = <span class=\"keyword\">new</span> StringBuffer();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pageData.hasAttribute(<span class=\"string\">\"Test\"</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(includeSuiteSetup)&#123;</span><br><span class=\"line\">            WikiPage suiteSetup = PageCrawlerImpl.getInheritedPage(SuiteResponder.SUITE_SETUP_NAME, wikiPage);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(suiteSetup != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                WikiPagePath pagePath = suiteSetup.getPageCrawler().getFullPath(suiteSetup);</span><br><span class=\"line\">                String pagePathName = PathParser.render(pagePath);</span><br><span class=\"line\">                buffer.append(<span class=\"string\">\"!include -setup .\"</span>)</span><br><span class=\"line\">                      .append(pagePathName)</span><br><span class=\"line\">                      .append(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        WikiPage setup = PageCrawlerImpl.getInheritedPage(<span class=\"string\">\"SetUp\"</span>, wikiPage);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(setup != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            WikiPagePath setupPath = wikiPage.getPageCrawler().getFullPath(setup);</span><br><span class=\"line\">            String setupPathName = PathParser.render(setupPath);</span><br><span class=\"line\">            buffer.append(<span class=\"string\">\"!include -setup .\"</span>)</span><br><span class=\"line\">                  .append(setupPathName)</span><br><span class=\"line\">                  .append(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    buffer.append(pageData.getContent());</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pageData.hasAttribute(<span class=\"string\">\"Test\"</span>))&#123;</span><br><span class=\"line\">        WikiPage teardown = PageCrawlerImpl.getInheritedPage(<span class=\"string\">\"TearDown\"</span>, wikiPage);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(teardown!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            WikiPagePath tearDownPath = wikiPage.getPageCrawler().getFullPath(teardown);</span><br><span class=\"line\">            String tearDownPathName = PathParser.render(tearDownPath);</span><br><span class=\"line\">            buffer.append(<span class=\"string\">\"!include -teardown .\"</span>)</span><br><span class=\"line\">                  .append(tearDownPathName)</span><br><span class=\"line\">                  .append(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(includeSuiteSetup)&#123;</span><br><span class=\"line\">            WikiPage suiteTeardown = PageCrawlerImpl.getInheritedPage(SuiteReponder.SUITE_TEARDOWN_NAME, wikiPage);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(suiteTeardown!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                WikiPagePath pagePath = suiteTeardown.getPageCrawler().getFullPath(suiteTeardown);</span><br><span class=\"line\">                String pagePathName = PathParse.render(pagePath);</span><br><span class=\"line\">                buffer.append(<span class=\"string\">\"!include -teardown .\"</span>)</span><br><span class=\"line\">                      .append(pagePathName)</span><br><span class=\"line\">                      .append(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pageData.setContent(buffer.toString());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pageData.getHtml();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>搞懂这个函数了吗？大概没有。<strong>有太多事发生，有太多不懂层级的抽象。奇怪的字符串和函数调用，混以双重嵌套、用标识来控制的if语句等，不一而足。</strong></p>\n<p>不过，只要做几个简单的方法抽离和重命名操作，加上一点点重构，就能在9行代码之内搞定。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">renderPageWithSetupsAndTeardown</span><span class=\"params\">(PageData pageData, <span class=\"keyword\">boolean</span> isSuite)</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> isTestPage = pageData.hasAttribute(<span class=\"string\">\"Test\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(isTestPage)&#123;</span><br><span class=\"line\">        WikiPage testPage = pageData.getWikiPage();</span><br><span class=\"line\">        StringBuffer newPageContent = <span class=\"keyword\">new</span> StringBuffer();</span><br><span class=\"line\">        includeSetupPages(testPage, newPageContent, isSuite);</span><br><span class=\"line\">        newPageContent.append(pageData.getContent());</span><br><span class=\"line\">        includeTeardownPages(testPage, newPageContent, isSuite);</span><br><span class=\"line\">        pageData.setContent(newPageContent.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pageData.getHtml();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>除非你正在研究FitNesse，否则就理解不了所有细节。不过，你大概能明白，该函数包含把一些设置和拆解页放入一个测试页面，再渲染为HTML的操作。如果你熟悉JUnit，或许会想到，该函数归属于某个基于Web的测试框架。</p>\n<h2 id=\"短小\"><a href=\"#短小\" class=\"headerlink\" title=\"短小\"></a>短小</h2><p><strong>函数的第一规则是要短小。第二条规则还要更短小</strong>。</p>\n<h3 id=\"代码块和缩进\"><a href=\"#代码块和缩进\" class=\"headerlink\" title=\"代码块和缩进\"></a>代码块和缩进</h3><p>if语句、else语句、while语句等，其中的代码块应该只有一行。该行大抵应该是一个函数调用语句。这样不但能保持函数短小，而且，因为块内调用的函数拥有较具说明性的名称，从而增加了文档上的价值。</p>\n<p>这也意味着函数不应该大到足以容纳嵌套结构。所以，函数的缩进层级不该多于一层或两层。当然，这样的函数易于阅读和理解。</p>\n<h3 id=\"只做一件事\"><a href=\"#只做一件事\" class=\"headerlink\" title=\"只做一件事\"></a>只做一件事</h3><p>函数应该做一件事。做好这件事。只做这一件事。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在编程的早年岁月，系统由程序和子程序组成。后来，在Fortran和PL/1的年代，系统由程序、子程序和函数组成。如今，只有函数存活下来。函数是所有程序中的第一组代码。</p>\n<blockquote>\n<p>在计算机领域，很多问题都是历史原因引起的，比如千年虫。因为计算机的发展非常之迅速，特别是硬件行业的发展，使得原先的很多稀有资源：比如存储和算力变得越来越便宜。软件行业也就向着更平易近人、更大规模演进。</p>\n</blockquote>\n<p>看看下面的代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">testableHtml</span><span class=\"params\">(PageData pageData, <span class=\"keyword\">boolean</span> includeSuiteSetup)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">    WikiPage wikiPage = pageData.getWikiPage();</span><br><span class=\"line\">    StringBuffer buffer = <span class=\"keyword\">new</span> StringBuffer();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (pageData.hasAttribute(<span class=\"string\">\"Test\"</span>)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(includeSuiteSetup)&#123;</span><br><span class=\"line\">            WikiPage suiteSetup = PageCrawlerImpl.getInheritedPage(SuiteResponder.SUITE_SETUP_NAME, wikiPage);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(suiteSetup != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                WikiPagePath pagePath = suiteSetup.getPageCrawler().getFullPath(suiteSetup);</span><br><span class=\"line\">                String pagePathName = PathParser.render(pagePath);</span><br><span class=\"line\">                buffer.append(<span class=\"string\">\"!include -setup .\"</span>)</span><br><span class=\"line\">                      .append(pagePathName)</span><br><span class=\"line\">                      .append(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        WikiPage setup = PageCrawlerImpl.getInheritedPage(<span class=\"string\">\"SetUp\"</span>, wikiPage);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(setup != <span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            WikiPagePath setupPath = wikiPage.getPageCrawler().getFullPath(setup);</span><br><span class=\"line\">            String setupPathName = PathParser.render(setupPath);</span><br><span class=\"line\">            buffer.append(<span class=\"string\">\"!include -setup .\"</span>)</span><br><span class=\"line\">                  .append(setupPathName)</span><br><span class=\"line\">                  .append(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    buffer.append(pageData.getContent());</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(pageData.hasAttribute(<span class=\"string\">\"Test\"</span>))&#123;</span><br><span class=\"line\">        WikiPage teardown = PageCrawlerImpl.getInheritedPage(<span class=\"string\">\"TearDown\"</span>, wikiPage);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(teardown!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">            WikiPagePath tearDownPath = wikiPage.getPageCrawler().getFullPath(teardown);</span><br><span class=\"line\">            String tearDownPathName = PathParser.render(tearDownPath);</span><br><span class=\"line\">            buffer.append(<span class=\"string\">\"!include -teardown .\"</span>)</span><br><span class=\"line\">                  .append(tearDownPathName)</span><br><span class=\"line\">                  .append(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(includeSuiteSetup)&#123;</span><br><span class=\"line\">            WikiPage suiteTeardown = PageCrawlerImpl.getInheritedPage(SuiteReponder.SUITE_TEARDOWN_NAME, wikiPage);</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(suiteTeardown!=<span class=\"keyword\">null</span>)&#123;</span><br><span class=\"line\">                WikiPagePath pagePath = suiteTeardown.getPageCrawler().getFullPath(suiteTeardown);</span><br><span class=\"line\">                String pagePathName = PathParse.render(pagePath);</span><br><span class=\"line\">                buffer.append(<span class=\"string\">\"!include -teardown .\"</span>)</span><br><span class=\"line\">                      .append(pagePathName)</span><br><span class=\"line\">                      .append(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    pageData.setContent(buffer.toString());</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pageData.getHtml();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>搞懂这个函数了吗？大概没有。<strong>有太多事发生，有太多不懂层级的抽象。奇怪的字符串和函数调用，混以双重嵌套、用标识来控制的if语句等，不一而足。</strong></p>\n<p>不过，只要做几个简单的方法抽离和重命名操作，加上一点点重构，就能在9行代码之内搞定。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">renderPageWithSetupsAndTeardown</span><span class=\"params\">(PageData pageData, <span class=\"keyword\">boolean</span> isSuite)</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> isTestPage = pageData.hasAttribute(<span class=\"string\">\"Test\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(isTestPage)&#123;</span><br><span class=\"line\">        WikiPage testPage = pageData.getWikiPage();</span><br><span class=\"line\">        StringBuffer newPageContent = <span class=\"keyword\">new</span> StringBuffer();</span><br><span class=\"line\">        includeSetupPages(testPage, newPageContent, isSuite);</span><br><span class=\"line\">        newPageContent.append(pageData.getContent());</span><br><span class=\"line\">        includeTeardownPages(testPage, newPageContent, isSuite);</span><br><span class=\"line\">        pageData.setContent(newPageContent.toString());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> pageData.getHtml();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>除非你正在研究FitNesse，否则就理解不了所有细节。不过，你大概能明白，该函数包含把一些设置和拆解页放入一个测试页面，再渲染为HTML的操作。如果你熟悉JUnit，或许会想到，该函数归属于某个基于Web的测试框架。</p>\n<h2 id=\"短小\"><a href=\"#短小\" class=\"headerlink\" title=\"短小\"></a>短小</h2><p><strong>函数的第一规则是要短小。第二条规则还要更短小</strong>。</p>\n<h3 id=\"代码块和缩进\"><a href=\"#代码块和缩进\" class=\"headerlink\" title=\"代码块和缩进\"></a>代码块和缩进</h3><p>if语句、else语句、while语句等，其中的代码块应该只有一行。该行大抵应该是一个函数调用语句。这样不但能保持函数短小，而且，因为块内调用的函数拥有较具说明性的名称，从而增加了文档上的价值。</p>\n<p>这也意味着函数不应该大到足以容纳嵌套结构。所以，函数的缩进层级不该多于一层或两层。当然，这样的函数易于阅读和理解。</p>\n<h3 id=\"只做一件事\"><a href=\"#只做一件事\" class=\"headerlink\" title=\"只做一件事\"></a>只做一件事</h3><p>函数应该做一件事。做好这件事。只做这一件事。</p>\n"},{"title":"《APUE》笔记--第二章：文件和目录","comments":1,"_content":"\n## 文件类型\n\n- 普通文件（regular file），包括文本文件和二进制文件。\n- 目录文件（directory file），目录文件包含了其他文件的名字以及指向这些文件有关信息的指针，对一个目录文件具有读权限的任何进程都可以读该目录的内容，但只有内核才能写目录文件。\n- 块特殊文件（block special file），块特殊文件提供对设备带缓冲的访问，每次访问以固定长度为单位进行。比如：磁盘。\n- 字符特殊文件（character special file），字符特殊文件提供对设备不带缓冲的访问，每次访问长度可变。**系统中的所有设备，要么是字符特殊文件，要么是块特殊文件**。\n- FIFO（first in first out），FIFO用于进程间通信，有时也将其称为：命名管道（named pipe）。\n- 套接字（socket），用于进程间的网络通信，也可用于在一台宿主机上进程之间的非网络通信。\n- 符号链接（symbolic link），符号链接指向另一个文件。\n\n可以使用表4-1中的宏确定文件类型，m是`stat`结构体的`st_mode`成员变量，此变量存放文件类型信息，返回0表示假，返回非0表示真：\n\n> 表4-1\t<sys/stat.h>中的文件类型宏\n\n| 宏          | 描述                   |\n| ----------- | ---------------------- |\n| S_ISREG(m)  | 判断是否是普通文件     |\n| S_ISDIR(m)  | 判断是否是目录文件     |\n| S_ISCHR(m)  | 判断是否是字符特殊文件 |\n| S_ISBLK(m)  | 判断是否是块特殊文件   |\n| S_ISFIFO(m) | 判断是否是FIFO         |\n| S_ISLNK(m)  | 判断是否是符号链接     |\n| S_ISSOCK(m) | 判断是否是套接字       |\n\nPOSIX.1允许实现将进程间通信（IPC，inter-process communication）对象（例如，消息队列和信号量等）表示为文件。表4-2中的宏可用来确定IPC对象的类型。这些宏的参数并非`st_mode`，而是指向`stat`结构体的指针。\n\n> 表4-2\t<sys/stat.h>中的IPC类型宏\n\n| 宏               | 描述                   |\n| ---------------- | ---------------------- |\n| S_TYPEISMQ(buf)  | 判断是否是消息队列     |\n| S_TYPEISSEM(buf) | 判断是否是信号量       |\n| S_TYPEISSHM(buf) | 判断是否是共享存储对象 |\n\n ```\n#include \"apue.h\"\nint main(int argc, char *argv[]){\n    int i;\n    struct stat buf;\n    char *ptr;\n    for(i=1;i<argc;i++){\n        prinft(\"%s: \",argv[i]);\n        if(lstat(argv[i], &buf)<0){\n            err_ret()\n        }\n    }\n}\n ```\n\n","source":"_drafts/2018-06-23-《APUE》笔记-第二章：文件和目录.md","raw":"---\ntitle: 《APUE》笔记--第二章：文件和目录\ntags: [操作系统]\ncategories: [读书笔记, 《Advance Programming in the Unix Environment》]\ncomments: true\n---\n\n## 文件类型\n\n- 普通文件（regular file），包括文本文件和二进制文件。\n- 目录文件（directory file），目录文件包含了其他文件的名字以及指向这些文件有关信息的指针，对一个目录文件具有读权限的任何进程都可以读该目录的内容，但只有内核才能写目录文件。\n- 块特殊文件（block special file），块特殊文件提供对设备带缓冲的访问，每次访问以固定长度为单位进行。比如：磁盘。\n- 字符特殊文件（character special file），字符特殊文件提供对设备不带缓冲的访问，每次访问长度可变。**系统中的所有设备，要么是字符特殊文件，要么是块特殊文件**。\n- FIFO（first in first out），FIFO用于进程间通信，有时也将其称为：命名管道（named pipe）。\n- 套接字（socket），用于进程间的网络通信，也可用于在一台宿主机上进程之间的非网络通信。\n- 符号链接（symbolic link），符号链接指向另一个文件。\n\n可以使用表4-1中的宏确定文件类型，m是`stat`结构体的`st_mode`成员变量，此变量存放文件类型信息，返回0表示假，返回非0表示真：\n\n> 表4-1\t<sys/stat.h>中的文件类型宏\n\n| 宏          | 描述                   |\n| ----------- | ---------------------- |\n| S_ISREG(m)  | 判断是否是普通文件     |\n| S_ISDIR(m)  | 判断是否是目录文件     |\n| S_ISCHR(m)  | 判断是否是字符特殊文件 |\n| S_ISBLK(m)  | 判断是否是块特殊文件   |\n| S_ISFIFO(m) | 判断是否是FIFO         |\n| S_ISLNK(m)  | 判断是否是符号链接     |\n| S_ISSOCK(m) | 判断是否是套接字       |\n\nPOSIX.1允许实现将进程间通信（IPC，inter-process communication）对象（例如，消息队列和信号量等）表示为文件。表4-2中的宏可用来确定IPC对象的类型。这些宏的参数并非`st_mode`，而是指向`stat`结构体的指针。\n\n> 表4-2\t<sys/stat.h>中的IPC类型宏\n\n| 宏               | 描述                   |\n| ---------------- | ---------------------- |\n| S_TYPEISMQ(buf)  | 判断是否是消息队列     |\n| S_TYPEISSEM(buf) | 判断是否是信号量       |\n| S_TYPEISSHM(buf) | 判断是否是共享存储对象 |\n\n ```\n#include \"apue.h\"\nint main(int argc, char *argv[]){\n    int i;\n    struct stat buf;\n    char *ptr;\n    for(i=1;i<argc;i++){\n        prinft(\"%s: \",argv[i]);\n        if(lstat(argv[i], &buf)<0){\n            err_ret()\n        }\n    }\n}\n ```\n\n","slug":"2018-06-23-《APUE》笔记-第二章：文件和目录","published":0,"date":"2018-06-23T04:01:40.491Z","updated":"2018-06-23T09:48:32.050Z","layout":"post","photos":[],"link":"","_id":"cjm2w8d5j0003fgpxmcfrf1i3","content":"<h2 id=\"文件类型\"><a href=\"#文件类型\" class=\"headerlink\" title=\"文件类型\"></a>文件类型</h2><ul>\n<li>普通文件（regular file），包括文本文件和二进制文件。</li>\n<li>目录文件（directory file），目录文件包含了其他文件的名字以及指向这些文件有关信息的指针，对一个目录文件具有读权限的任何进程都可以读该目录的内容，但只有内核才能写目录文件。</li>\n<li>块特殊文件（block special file），块特殊文件提供对设备带缓冲的访问，每次访问以固定长度为单位进行。比如：磁盘。</li>\n<li>字符特殊文件（character special file），字符特殊文件提供对设备不带缓冲的访问，每次访问长度可变。<strong>系统中的所有设备，要么是字符特殊文件，要么是块特殊文件</strong>。</li>\n<li>FIFO（first in first out），FIFO用于进程间通信，有时也将其称为：命名管道（named pipe）。</li>\n<li>套接字（socket），用于进程间的网络通信，也可用于在一台宿主机上进程之间的非网络通信。</li>\n<li>符号链接（symbolic link），符号链接指向另一个文件。</li>\n</ul>\n<p>可以使用表4-1中的宏确定文件类型，m是<code>stat</code>结构体的<code>st_mode</code>成员变量，此变量存放文件类型信息，返回0表示假，返回非0表示真：</p>\n<blockquote>\n<p>表4-1    &lt;sys/stat.h&gt;中的文件类型宏</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>宏</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>S_ISREG(m)</td>\n<td>判断是否是普通文件</td>\n</tr>\n<tr>\n<td>S_ISDIR(m)</td>\n<td>判断是否是目录文件</td>\n</tr>\n<tr>\n<td>S_ISCHR(m)</td>\n<td>判断是否是字符特殊文件</td>\n</tr>\n<tr>\n<td>S_ISBLK(m)</td>\n<td>判断是否是块特殊文件</td>\n</tr>\n<tr>\n<td>S_ISFIFO(m)</td>\n<td>判断是否是FIFO</td>\n</tr>\n<tr>\n<td>S_ISLNK(m)</td>\n<td>判断是否是符号链接</td>\n</tr>\n<tr>\n<td>S_ISSOCK(m)</td>\n<td>判断是否是套接字</td>\n</tr>\n</tbody>\n</table>\n<p>POSIX.1允许实现将进程间通信（IPC，inter-process communication）对象（例如，消息队列和信号量等）表示为文件。表4-2中的宏可用来确定IPC对象的类型。这些宏的参数并非<code>st_mode</code>，而是指向<code>stat</code>结构体的指针。</p>\n<blockquote>\n<p>表4-2    &lt;sys/stat.h&gt;中的IPC类型宏</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>宏</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>S_TYPEISMQ(buf)</td>\n<td>判断是否是消息队列</td>\n</tr>\n<tr>\n<td>S_TYPEISSEM(buf)</td>\n<td>判断是否是信号量</td>\n</tr>\n<tr>\n<td>S_TYPEISSHM(buf)</td>\n<td>判断是否是共享存储对象</td>\n</tr>\n</tbody>\n</table>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &quot;apue.h&quot;</span><br><span class=\"line\">int main(int argc, char *argv[])&#123;</span><br><span class=\"line\">    int i;</span><br><span class=\"line\">    struct stat buf;</span><br><span class=\"line\">    char *ptr;</span><br><span class=\"line\">    for(i=1;i&lt;argc;i++)&#123;</span><br><span class=\"line\">        prinft(&quot;%s: &quot;,argv[i]);</span><br><span class=\"line\">        if(lstat(argv[i], &amp;buf)&lt;0)&#123;</span><br><span class=\"line\">            err_ret()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"文件类型\"><a href=\"#文件类型\" class=\"headerlink\" title=\"文件类型\"></a>文件类型</h2><ul>\n<li>普通文件（regular file），包括文本文件和二进制文件。</li>\n<li>目录文件（directory file），目录文件包含了其他文件的名字以及指向这些文件有关信息的指针，对一个目录文件具有读权限的任何进程都可以读该目录的内容，但只有内核才能写目录文件。</li>\n<li>块特殊文件（block special file），块特殊文件提供对设备带缓冲的访问，每次访问以固定长度为单位进行。比如：磁盘。</li>\n<li>字符特殊文件（character special file），字符特殊文件提供对设备不带缓冲的访问，每次访问长度可变。<strong>系统中的所有设备，要么是字符特殊文件，要么是块特殊文件</strong>。</li>\n<li>FIFO（first in first out），FIFO用于进程间通信，有时也将其称为：命名管道（named pipe）。</li>\n<li>套接字（socket），用于进程间的网络通信，也可用于在一台宿主机上进程之间的非网络通信。</li>\n<li>符号链接（symbolic link），符号链接指向另一个文件。</li>\n</ul>\n<p>可以使用表4-1中的宏确定文件类型，m是<code>stat</code>结构体的<code>st_mode</code>成员变量，此变量存放文件类型信息，返回0表示假，返回非0表示真：</p>\n<blockquote>\n<p>表4-1    &lt;sys/stat.h&gt;中的文件类型宏</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>宏</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>S_ISREG(m)</td>\n<td>判断是否是普通文件</td>\n</tr>\n<tr>\n<td>S_ISDIR(m)</td>\n<td>判断是否是目录文件</td>\n</tr>\n<tr>\n<td>S_ISCHR(m)</td>\n<td>判断是否是字符特殊文件</td>\n</tr>\n<tr>\n<td>S_ISBLK(m)</td>\n<td>判断是否是块特殊文件</td>\n</tr>\n<tr>\n<td>S_ISFIFO(m)</td>\n<td>判断是否是FIFO</td>\n</tr>\n<tr>\n<td>S_ISLNK(m)</td>\n<td>判断是否是符号链接</td>\n</tr>\n<tr>\n<td>S_ISSOCK(m)</td>\n<td>判断是否是套接字</td>\n</tr>\n</tbody>\n</table>\n<p>POSIX.1允许实现将进程间通信（IPC，inter-process communication）对象（例如，消息队列和信号量等）表示为文件。表4-2中的宏可用来确定IPC对象的类型。这些宏的参数并非<code>st_mode</code>，而是指向<code>stat</code>结构体的指针。</p>\n<blockquote>\n<p>表4-2    &lt;sys/stat.h&gt;中的IPC类型宏</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>宏</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>S_TYPEISMQ(buf)</td>\n<td>判断是否是消息队列</td>\n</tr>\n<tr>\n<td>S_TYPEISSEM(buf)</td>\n<td>判断是否是信号量</td>\n</tr>\n<tr>\n<td>S_TYPEISSHM(buf)</td>\n<td>判断是否是共享存储对象</td>\n</tr>\n</tbody>\n</table>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &quot;apue.h&quot;</span><br><span class=\"line\">int main(int argc, char *argv[])&#123;</span><br><span class=\"line\">    int i;</span><br><span class=\"line\">    struct stat buf;</span><br><span class=\"line\">    char *ptr;</span><br><span class=\"line\">    for(i=1;i&lt;argc;i++)&#123;</span><br><span class=\"line\">        prinft(&quot;%s: &quot;,argv[i]);</span><br><span class=\"line\">        if(lstat(argv[i], &amp;buf)&lt;0)&#123;</span><br><span class=\"line\">            err_ret()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"计算机专业修养","_content":"\n","source":"_drafts/2018-06-24-计算机专业修养.md","raw":"---\ntitle: 计算机专业修养\ntags:\n---\n\n","slug":"2018-06-24-计算机专业修养","published":0,"date":"2018-06-24T13:41:58.970Z","updated":"2018-06-24T13:49:28.347Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjm2w8d5m0007fgpxhtzxgvlz","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Leetcode 804 Unique Morse Code Words","comments":1,"_content":"\n## 804. Unique Morse Code Words\n\nInternational Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: `\"a\"` maps to `\".-\"`, `\"b\"`maps to `\"-...\"`, `\"c\"` maps to `\"-.-.\"`, and so on.\n\nFor convenience, the full table for the 26 letters of the English alphabet is given below:\n\n```\n[\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\n```\n\nNow, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, \"cab\" can be written as \"-.-.-....-\", (which is the concatenation \"-.-.\" + \"-...\" + \".-\"). We'll call such a concatenation, the transformation of a word.\n\nReturn the number of different transformations among all words we have.\n\n```\nExample:\nInput: words = [\"gin\", \"zen\", \"gig\", \"msg\"]\nOutput: 2\nExplanation: \nThe transformation of each word is:\n\"gin\" -> \"--...-.\"\n\"zen\" -> \"--...-.\"\n\"gig\" -> \"--...--.\"\n\"msg\" -> \"--...--.\"\n\nThere are 2 different transformations, \"--...-.\" and \"--...--.\".\n```\n\nNote:\n\n- The length of `words` will be at most `100`.\n- Each `words[i]` will have length in range `[1, 12]`.\n- `words[i]` will only consist of lowercase letters.\n\n## Java Code\n\n```Java\nclass Solution{\n    public int uniqueMorseRepresentations(String[] words){\n        String[] Morse={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\n        Set<String> set = new HashSet();\n        for(String word : words){\n            StringBuilder code = new StringBuilder();\n            for(char c:word.toCharArray()){\n                code.append(Morse[c-'a']);\n            }\n            set.add(code.toString());\n        }\n        return set.size();\n    }\n}\n```\n\n这里用到的数据结构是`HashSet`，Set用来存放无序的、不重复的数据。","source":"_drafts/2018-08-07-Leetcode-804-Unique-Morse-Code-Words.md","raw":"---\ntitle: Leetcode 804 Unique Morse Code Words\ncategories: [ACM, Leetcode]\ncomments: true\n---\n\n## 804. Unique Morse Code Words\n\nInternational Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: `\"a\"` maps to `\".-\"`, `\"b\"`maps to `\"-...\"`, `\"c\"` maps to `\"-.-.\"`, and so on.\n\nFor convenience, the full table for the 26 letters of the English alphabet is given below:\n\n```\n[\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\n```\n\nNow, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, \"cab\" can be written as \"-.-.-....-\", (which is the concatenation \"-.-.\" + \"-...\" + \".-\"). We'll call such a concatenation, the transformation of a word.\n\nReturn the number of different transformations among all words we have.\n\n```\nExample:\nInput: words = [\"gin\", \"zen\", \"gig\", \"msg\"]\nOutput: 2\nExplanation: \nThe transformation of each word is:\n\"gin\" -> \"--...-.\"\n\"zen\" -> \"--...-.\"\n\"gig\" -> \"--...--.\"\n\"msg\" -> \"--...--.\"\n\nThere are 2 different transformations, \"--...-.\" and \"--...--.\".\n```\n\nNote:\n\n- The length of `words` will be at most `100`.\n- Each `words[i]` will have length in range `[1, 12]`.\n- `words[i]` will only consist of lowercase letters.\n\n## Java Code\n\n```Java\nclass Solution{\n    public int uniqueMorseRepresentations(String[] words){\n        String[] Morse={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\n        Set<String> set = new HashSet();\n        for(String word : words){\n            StringBuilder code = new StringBuilder();\n            for(char c:word.toCharArray()){\n                code.append(Morse[c-'a']);\n            }\n            set.add(code.toString());\n        }\n        return set.size();\n    }\n}\n```\n\n这里用到的数据结构是`HashSet`，Set用来存放无序的、不重复的数据。","slug":"2018-08-07-Leetcode-804-Unique-Morse-Code-Words","published":0,"date":"2018-08-08T09:34:15.191Z","updated":"2018-08-08T09:34:15.191Z","layout":"post","photos":[],"link":"","_id":"cjm2w8d5o0009fgpxztiscaqg","content":"<h2 id=\"804-Unique-Morse-Code-Words\"><a href=\"#804-Unique-Morse-Code-Words\" class=\"headerlink\" title=\"804. Unique Morse Code Words\"></a>804. Unique Morse Code Words</h2><p>International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: <code>&quot;a&quot;</code> maps to <code>&quot;.-&quot;</code>, <code>&quot;b&quot;</code>maps to <code>&quot;-...&quot;</code>, <code>&quot;c&quot;</code> maps to <code>&quot;-.-.&quot;</code>, and so on.</p>\n<p>For convenience, the full table for the 26 letters of the English alphabet is given below:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[&quot;.-&quot;,&quot;-...&quot;,&quot;-.-.&quot;,&quot;-..&quot;,&quot;.&quot;,&quot;..-.&quot;,&quot;--.&quot;,&quot;....&quot;,&quot;..&quot;,&quot;.---&quot;,&quot;-.-&quot;,&quot;.-..&quot;,&quot;--&quot;,&quot;-.&quot;,&quot;---&quot;,&quot;.--.&quot;,&quot;--.-&quot;,&quot;.-.&quot;,&quot;...&quot;,&quot;-&quot;,&quot;..-&quot;,&quot;...-&quot;,&quot;.--&quot;,&quot;-..-&quot;,&quot;-.--&quot;,&quot;--..&quot;]</span><br></pre></td></tr></table></figure>\n<p>Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, “cab” can be written as “-.-.-….-“, (which is the concatenation “-.-.” + “-…” + “.-“). We’ll call such a concatenation, the transformation of a word.</p>\n<p>Return the number of different transformations among all words we have.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Example:</span><br><span class=\"line\">Input: words = [&quot;gin&quot;, &quot;zen&quot;, &quot;gig&quot;, &quot;msg&quot;]</span><br><span class=\"line\">Output: 2</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">The transformation of each word is:</span><br><span class=\"line\">&quot;gin&quot; -&gt; &quot;--...-.&quot;</span><br><span class=\"line\">&quot;zen&quot; -&gt; &quot;--...-.&quot;</span><br><span class=\"line\">&quot;gig&quot; -&gt; &quot;--...--.&quot;</span><br><span class=\"line\">&quot;msg&quot; -&gt; &quot;--...--.&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">There are 2 different transformations, &quot;--...-.&quot; and &quot;--...--.&quot;.</span><br></pre></td></tr></table></figure>\n<p>Note:</p>\n<ul>\n<li>The length of <code>words</code> will be at most <code>100</code>.</li>\n<li>Each <code>words[i]</code> will have length in range <code>[1, 12]</code>.</li>\n<li><code>words[i]</code> will only consist of lowercase letters.</li>\n</ul>\n<h2 id=\"Java-Code\"><a href=\"#Java-Code\" class=\"headerlink\" title=\"Java Code\"></a>Java Code</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">uniqueMorseRepresentations</span><span class=\"params\">(String[] words)</span></span>&#123;</span><br><span class=\"line\">        String[] Morse=&#123;<span class=\"string\">\".-\"</span>,<span class=\"string\">\"-...\"</span>,<span class=\"string\">\"-.-.\"</span>,<span class=\"string\">\"-..\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\"..-.\"</span>,<span class=\"string\">\"--.\"</span>,<span class=\"string\">\"....\"</span>,<span class=\"string\">\"..\"</span>,<span class=\"string\">\".---\"</span>,<span class=\"string\">\"-.-\"</span>,<span class=\"string\">\".-..\"</span>,<span class=\"string\">\"--\"</span>,<span class=\"string\">\"-.\"</span>,<span class=\"string\">\"---\"</span>,<span class=\"string\">\".--.\"</span>,<span class=\"string\">\"--.-\"</span>,<span class=\"string\">\".-.\"</span>,<span class=\"string\">\"...\"</span>,<span class=\"string\">\"-\"</span>,<span class=\"string\">\"..-\"</span>,<span class=\"string\">\"...-\"</span>,<span class=\"string\">\".--\"</span>,<span class=\"string\">\"-..-\"</span>,<span class=\"string\">\"-.--\"</span>,<span class=\"string\">\"--..\"</span>&#125;;</span><br><span class=\"line\">        Set&lt;String&gt; set = <span class=\"keyword\">new</span> HashSet();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(String word : words)&#123;</span><br><span class=\"line\">            StringBuilder code = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">char</span> c:word.toCharArray())&#123;</span><br><span class=\"line\">                code.append(Morse[c-<span class=\"string\">'a'</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            set.add(code.toString());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> set.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里用到的数据结构是<code>HashSet</code>，Set用来存放无序的、不重复的数据。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"804-Unique-Morse-Code-Words\"><a href=\"#804-Unique-Morse-Code-Words\" class=\"headerlink\" title=\"804. Unique Morse Code Words\"></a>804. Unique Morse Code Words</h2><p>International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: <code>&quot;a&quot;</code> maps to <code>&quot;.-&quot;</code>, <code>&quot;b&quot;</code>maps to <code>&quot;-...&quot;</code>, <code>&quot;c&quot;</code> maps to <code>&quot;-.-.&quot;</code>, and so on.</p>\n<p>For convenience, the full table for the 26 letters of the English alphabet is given below:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[&quot;.-&quot;,&quot;-...&quot;,&quot;-.-.&quot;,&quot;-..&quot;,&quot;.&quot;,&quot;..-.&quot;,&quot;--.&quot;,&quot;....&quot;,&quot;..&quot;,&quot;.---&quot;,&quot;-.-&quot;,&quot;.-..&quot;,&quot;--&quot;,&quot;-.&quot;,&quot;---&quot;,&quot;.--.&quot;,&quot;--.-&quot;,&quot;.-.&quot;,&quot;...&quot;,&quot;-&quot;,&quot;..-&quot;,&quot;...-&quot;,&quot;.--&quot;,&quot;-..-&quot;,&quot;-.--&quot;,&quot;--..&quot;]</span><br></pre></td></tr></table></figure>\n<p>Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, “cab” can be written as “-.-.-….-“, (which is the concatenation “-.-.” + “-…” + “.-“). We’ll call such a concatenation, the transformation of a word.</p>\n<p>Return the number of different transformations among all words we have.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Example:</span><br><span class=\"line\">Input: words = [&quot;gin&quot;, &quot;zen&quot;, &quot;gig&quot;, &quot;msg&quot;]</span><br><span class=\"line\">Output: 2</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">The transformation of each word is:</span><br><span class=\"line\">&quot;gin&quot; -&gt; &quot;--...-.&quot;</span><br><span class=\"line\">&quot;zen&quot; -&gt; &quot;--...-.&quot;</span><br><span class=\"line\">&quot;gig&quot; -&gt; &quot;--...--.&quot;</span><br><span class=\"line\">&quot;msg&quot; -&gt; &quot;--...--.&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">There are 2 different transformations, &quot;--...-.&quot; and &quot;--...--.&quot;.</span><br></pre></td></tr></table></figure>\n<p>Note:</p>\n<ul>\n<li>The length of <code>words</code> will be at most <code>100</code>.</li>\n<li>Each <code>words[i]</code> will have length in range <code>[1, 12]</code>.</li>\n<li><code>words[i]</code> will only consist of lowercase letters.</li>\n</ul>\n<h2 id=\"Java-Code\"><a href=\"#Java-Code\" class=\"headerlink\" title=\"Java Code\"></a>Java Code</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">uniqueMorseRepresentations</span><span class=\"params\">(String[] words)</span></span>&#123;</span><br><span class=\"line\">        String[] Morse=&#123;<span class=\"string\">\".-\"</span>,<span class=\"string\">\"-...\"</span>,<span class=\"string\">\"-.-.\"</span>,<span class=\"string\">\"-..\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\"..-.\"</span>,<span class=\"string\">\"--.\"</span>,<span class=\"string\">\"....\"</span>,<span class=\"string\">\"..\"</span>,<span class=\"string\">\".---\"</span>,<span class=\"string\">\"-.-\"</span>,<span class=\"string\">\".-..\"</span>,<span class=\"string\">\"--\"</span>,<span class=\"string\">\"-.\"</span>,<span class=\"string\">\"---\"</span>,<span class=\"string\">\".--.\"</span>,<span class=\"string\">\"--.-\"</span>,<span class=\"string\">\".-.\"</span>,<span class=\"string\">\"...\"</span>,<span class=\"string\">\"-\"</span>,<span class=\"string\">\"..-\"</span>,<span class=\"string\">\"...-\"</span>,<span class=\"string\">\".--\"</span>,<span class=\"string\">\"-..-\"</span>,<span class=\"string\">\"-.--\"</span>,<span class=\"string\">\"--..\"</span>&#125;;</span><br><span class=\"line\">        Set&lt;String&gt; set = <span class=\"keyword\">new</span> HashSet();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(String word : words)&#123;</span><br><span class=\"line\">            StringBuilder code = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">char</span> c:word.toCharArray())&#123;</span><br><span class=\"line\">                code.append(Morse[c-<span class=\"string\">'a'</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            set.add(code.toString());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> set.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里用到的数据结构是<code>HashSet</code>，Set用来存放无序的、不重复的数据。</p>\n"},{"title":"线性代数笔记--基础篇：行列式、矩阵的本质","date":"2016-09-29T16:00:00.000Z","comments":1,"_content":"\n线性：量和量之间的关系是一次的\n线性代数的核心研究对象：**向量**\n\n## 行列式的本质定义\n\n（行列式的绝对值）是n维向量所构成的图形的面积或体积（面积和体积分别是二唯和三维的说法，更高维数依次类推）。\ndeterminant（行列式）\n\n## 行列式的性质\n\n1. $D_n=|A|中某行元素全为0\\Rightarrow |A|=0$,因为有一个向量为0，所以构成的图形比n少一维，所以体积为0。\n2. $D_n=|A|中某两行元素对应成比例\\Rightarrow |A|=0$,因为有两个向量是平行的，所以构成的图形体积为0.\n3. （互换）$|A|$中某两行元素互换$\\Rightarrow|A|$变号(即得到$-|A|$),两向量的夹角变了，$\\sin (\\alpha-\\beta)=-\\sin (\\beta-\\alpha)$,所以体积变号。\n4. （倍乘）乘k，就把k乘到任意一行或者列，同理如果某行或者列可以提出k倍也行。因为某向量乘k倍，体积变为k倍。**这里要区别于矩阵的倍乘，矩阵是用来表达系统信息的数表，每个元素都要乘k倍。**\n5. （倍加）某行乘k倍加到另一行上，行列式结果不变，几何表述：**因为这两个向量构成的平行四边形同底同高，面积不变，所以体积也不变。**可拆性表述：拆成两个行列式，其中一个行列式为0，因为它某两行对应成比例。\n6. 单行可拆（加）性\n7. $|A|=|A^T|$，行列等价，前六个性质同样适用于列。\n\n### 重要观点\n\n1. $D_n=|A|\\neq0\\Rightarrow S\\neq0\\Rightarrow 组成行列式的向量全独立$\n2. $D_n=|A|=0\\Rightarrow 组成行列式的向量至少有一个多余$\n**行列式=0还是$\\neq$0才是关键，而不是管它等于多少**\n**向量与向量之间要么独立要么多余**\n\n## 矩阵的本质\n1. 表面上，矩阵是表达系统信息的数表\n2. 本质上，矩阵也是由向量构成的，矩阵的核心是矩阵的**秩**，而秩的本质是组成矩阵的独立向量的个数；矩阵是一种**运算**，一种对应法则，把一个线性代数研究对象变换成另一个的手段；**矩阵还是方程组的系数表**，决定了初等变换的性质（可以行对调，可以行倍加倍减，可以行倍乘）。\n\n**秩的本质**：r(A)=k，则矩阵中有k个独立的向量\n\n**台阶数=秩**，因为台阶之间（向量之间）是独立的。\n\n**行阶梯形矩阵**：1）若有0行，全在下方，2）从行上看，自左边起，出现连续0的个数，自上而下严格单增。若还满足3）台角位置元素为1，4）台角上方元素全为0，称为**行最简阶梯形矩阵**。\n\n**初等变换法：互换、倍乘、倍加**\n\n解释：互换不影响方程组的解，不影响向量的独立性，倍乘不影响方程组的解，不影响向量的独立性，倍加不影响方程组的解，不影响向量的独立性。**矩阵进行初等变换不影响矩阵的秩，**不影响矩阵的本质意义，所以初等变换是可以大量广泛使用的。\n**任何可逆矩阵一定可以通过若干次初等变换化成同阶单位阵**\n\n### 矩阵的乘法\n\nAB=C\n\n矩阵的乘法中，C中的每一个元素都是一个**向量的内积**，所以矩阵乘法可以看做向量内积的推广。另外矩阵的左乘代表行变换，矩阵的右乘代表列表换。矩阵的乘法也可以看做一种函数变换，因为矩阵乘法可以把一个线代对象，转换成另一个线代对象。\n\n**乘法单位元素：**\n1·a=a,a·1=a，其中1称为乘法单位元素，矩阵的乘法单位元素是E（单位矩阵）\n\n**乘法反单位元素：**\n$a\\cdot\\frac{1}{a}=1,\\frac{1}{a}\\cdot a=1$，其中$a$和$\\frac{1}{a}$互称乘法反单位元素。矩阵$A$的乘法反单位元素是$A^{-1}$。\n二阶逆矩阵，主对角线对调，次对角线取相反数。\n","source":"_posts/2016/2016-09-30-线性代数笔记--基础篇：行列式、矩阵的本质.md","raw":"---\ntitle: 线性代数笔记--基础篇：行列式、矩阵的本质\ndate: 2016-09-30\ncategories: [数学, 线性代数]\ncomments: true\n---\n\n线性：量和量之间的关系是一次的\n线性代数的核心研究对象：**向量**\n\n## 行列式的本质定义\n\n（行列式的绝对值）是n维向量所构成的图形的面积或体积（面积和体积分别是二唯和三维的说法，更高维数依次类推）。\ndeterminant（行列式）\n\n## 行列式的性质\n\n1. $D_n=|A|中某行元素全为0\\Rightarrow |A|=0$,因为有一个向量为0，所以构成的图形比n少一维，所以体积为0。\n2. $D_n=|A|中某两行元素对应成比例\\Rightarrow |A|=0$,因为有两个向量是平行的，所以构成的图形体积为0.\n3. （互换）$|A|$中某两行元素互换$\\Rightarrow|A|$变号(即得到$-|A|$),两向量的夹角变了，$\\sin (\\alpha-\\beta)=-\\sin (\\beta-\\alpha)$,所以体积变号。\n4. （倍乘）乘k，就把k乘到任意一行或者列，同理如果某行或者列可以提出k倍也行。因为某向量乘k倍，体积变为k倍。**这里要区别于矩阵的倍乘，矩阵是用来表达系统信息的数表，每个元素都要乘k倍。**\n5. （倍加）某行乘k倍加到另一行上，行列式结果不变，几何表述：**因为这两个向量构成的平行四边形同底同高，面积不变，所以体积也不变。**可拆性表述：拆成两个行列式，其中一个行列式为0，因为它某两行对应成比例。\n6. 单行可拆（加）性\n7. $|A|=|A^T|$，行列等价，前六个性质同样适用于列。\n\n### 重要观点\n\n1. $D_n=|A|\\neq0\\Rightarrow S\\neq0\\Rightarrow 组成行列式的向量全独立$\n2. $D_n=|A|=0\\Rightarrow 组成行列式的向量至少有一个多余$\n**行列式=0还是$\\neq$0才是关键，而不是管它等于多少**\n**向量与向量之间要么独立要么多余**\n\n## 矩阵的本质\n1. 表面上，矩阵是表达系统信息的数表\n2. 本质上，矩阵也是由向量构成的，矩阵的核心是矩阵的**秩**，而秩的本质是组成矩阵的独立向量的个数；矩阵是一种**运算**，一种对应法则，把一个线性代数研究对象变换成另一个的手段；**矩阵还是方程组的系数表**，决定了初等变换的性质（可以行对调，可以行倍加倍减，可以行倍乘）。\n\n**秩的本质**：r(A)=k，则矩阵中有k个独立的向量\n\n**台阶数=秩**，因为台阶之间（向量之间）是独立的。\n\n**行阶梯形矩阵**：1）若有0行，全在下方，2）从行上看，自左边起，出现连续0的个数，自上而下严格单增。若还满足3）台角位置元素为1，4）台角上方元素全为0，称为**行最简阶梯形矩阵**。\n\n**初等变换法：互换、倍乘、倍加**\n\n解释：互换不影响方程组的解，不影响向量的独立性，倍乘不影响方程组的解，不影响向量的独立性，倍加不影响方程组的解，不影响向量的独立性。**矩阵进行初等变换不影响矩阵的秩，**不影响矩阵的本质意义，所以初等变换是可以大量广泛使用的。\n**任何可逆矩阵一定可以通过若干次初等变换化成同阶单位阵**\n\n### 矩阵的乘法\n\nAB=C\n\n矩阵的乘法中，C中的每一个元素都是一个**向量的内积**，所以矩阵乘法可以看做向量内积的推广。另外矩阵的左乘代表行变换，矩阵的右乘代表列表换。矩阵的乘法也可以看做一种函数变换，因为矩阵乘法可以把一个线代对象，转换成另一个线代对象。\n\n**乘法单位元素：**\n1·a=a,a·1=a，其中1称为乘法单位元素，矩阵的乘法单位元素是E（单位矩阵）\n\n**乘法反单位元素：**\n$a\\cdot\\frac{1}{a}=1,\\frac{1}{a}\\cdot a=1$，其中$a$和$\\frac{1}{a}$互称乘法反单位元素。矩阵$A$的乘法反单位元素是$A^{-1}$。\n二阶逆矩阵，主对角线对调，次对角线取相反数。\n","slug":"线性代数笔记--基础篇：行列式、矩阵的本质","published":1,"updated":"2018-04-25T08:21:49.677Z","layout":"post","photos":[],"link":"","_id":"cjm2w8dco000qfgpx3p9g254y","content":"<p>线性：量和量之间的关系是一次的<br>线性代数的核心研究对象：<strong>向量</strong></p>\n<h2 id=\"行列式的本质定义\"><a href=\"#行列式的本质定义\" class=\"headerlink\" title=\"行列式的本质定义\"></a>行列式的本质定义</h2><p>（行列式的绝对值）是n维向量所构成的图形的面积或体积（面积和体积分别是二唯和三维的说法，更高维数依次类推）。<br>determinant（行列式）</p>\n<h2 id=\"行列式的性质\"><a href=\"#行列式的性质\" class=\"headerlink\" title=\"行列式的性质\"></a>行列式的性质</h2><ol>\n<li>$D_n=|A|中某行元素全为0\\Rightarrow |A|=0$,因为有一个向量为0，所以构成的图形比n少一维，所以体积为0。</li>\n<li>$D_n=|A|中某两行元素对应成比例\\Rightarrow |A|=0$,因为有两个向量是平行的，所以构成的图形体积为0.</li>\n<li>（互换）$|A|$中某两行元素互换$\\Rightarrow|A|$变号(即得到$-|A|$),两向量的夹角变了，$\\sin (\\alpha-\\beta)=-\\sin (\\beta-\\alpha)$,所以体积变号。</li>\n<li>（倍乘）乘k，就把k乘到任意一行或者列，同理如果某行或者列可以提出k倍也行。因为某向量乘k倍，体积变为k倍。<strong>这里要区别于矩阵的倍乘，矩阵是用来表达系统信息的数表，每个元素都要乘k倍。</strong></li>\n<li>（倍加）某行乘k倍加到另一行上，行列式结果不变，几何表述：<strong>因为这两个向量构成的平行四边形同底同高，面积不变，所以体积也不变。</strong>可拆性表述：拆成两个行列式，其中一个行列式为0，因为它某两行对应成比例。</li>\n<li>单行可拆（加）性</li>\n<li>$|A|=|A^T|$，行列等价，前六个性质同样适用于列。</li>\n</ol>\n<h3 id=\"重要观点\"><a href=\"#重要观点\" class=\"headerlink\" title=\"重要观点\"></a>重要观点</h3><ol>\n<li>$D_n=|A|\\neq0\\Rightarrow S\\neq0\\Rightarrow 组成行列式的向量全独立$</li>\n<li>$D_n=|A|=0\\Rightarrow 组成行列式的向量至少有一个多余$<br><strong>行列式=0还是$\\neq$0才是关键，而不是管它等于多少</strong><br><strong>向量与向量之间要么独立要么多余</strong></li>\n</ol>\n<h2 id=\"矩阵的本质\"><a href=\"#矩阵的本质\" class=\"headerlink\" title=\"矩阵的本质\"></a>矩阵的本质</h2><ol>\n<li>表面上，矩阵是表达系统信息的数表</li>\n<li>本质上，矩阵也是由向量构成的，矩阵的核心是矩阵的<strong>秩</strong>，而秩的本质是组成矩阵的独立向量的个数；矩阵是一种<strong>运算</strong>，一种对应法则，把一个线性代数研究对象变换成另一个的手段；<strong>矩阵还是方程组的系数表</strong>，决定了初等变换的性质（可以行对调，可以行倍加倍减，可以行倍乘）。</li>\n</ol>\n<p><strong>秩的本质</strong>：r(A)=k，则矩阵中有k个独立的向量</p>\n<p><strong>台阶数=秩</strong>，因为台阶之间（向量之间）是独立的。</p>\n<p><strong>行阶梯形矩阵</strong>：1）若有0行，全在下方，2）从行上看，自左边起，出现连续0的个数，自上而下严格单增。若还满足3）台角位置元素为1，4）台角上方元素全为0，称为<strong>行最简阶梯形矩阵</strong>。</p>\n<p><strong>初等变换法：互换、倍乘、倍加</strong></p>\n<p>解释：互换不影响方程组的解，不影响向量的独立性，倍乘不影响方程组的解，不影响向量的独立性，倍加不影响方程组的解，不影响向量的独立性。<strong>矩阵进行初等变换不影响矩阵的秩，</strong>不影响矩阵的本质意义，所以初等变换是可以大量广泛使用的。<br><strong>任何可逆矩阵一定可以通过若干次初等变换化成同阶单位阵</strong></p>\n<h3 id=\"矩阵的乘法\"><a href=\"#矩阵的乘法\" class=\"headerlink\" title=\"矩阵的乘法\"></a>矩阵的乘法</h3><p>AB=C</p>\n<p>矩阵的乘法中，C中的每一个元素都是一个<strong>向量的内积</strong>，所以矩阵乘法可以看做向量内积的推广。另外矩阵的左乘代表行变换，矩阵的右乘代表列表换。矩阵的乘法也可以看做一种函数变换，因为矩阵乘法可以把一个线代对象，转换成另一个线代对象。</p>\n<p><strong>乘法单位元素：</strong><br>1·a=a,a·1=a，其中1称为乘法单位元素，矩阵的乘法单位元素是E（单位矩阵）</p>\n<p><strong>乘法反单位元素：</strong><br>$a\\cdot\\frac{1}{a}=1,\\frac{1}{a}\\cdot a=1$，其中$a$和$\\frac{1}{a}$互称乘法反单位元素。矩阵$A$的乘法反单位元素是$A^{-1}$。<br>二阶逆矩阵，主对角线对调，次对角线取相反数。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>线性：量和量之间的关系是一次的<br>线性代数的核心研究对象：<strong>向量</strong></p>\n<h2 id=\"行列式的本质定义\"><a href=\"#行列式的本质定义\" class=\"headerlink\" title=\"行列式的本质定义\"></a>行列式的本质定义</h2><p>（行列式的绝对值）是n维向量所构成的图形的面积或体积（面积和体积分别是二唯和三维的说法，更高维数依次类推）。<br>determinant（行列式）</p>\n<h2 id=\"行列式的性质\"><a href=\"#行列式的性质\" class=\"headerlink\" title=\"行列式的性质\"></a>行列式的性质</h2><ol>\n<li>$D_n=|A|中某行元素全为0\\Rightarrow |A|=0$,因为有一个向量为0，所以构成的图形比n少一维，所以体积为0。</li>\n<li>$D_n=|A|中某两行元素对应成比例\\Rightarrow |A|=0$,因为有两个向量是平行的，所以构成的图形体积为0.</li>\n<li>（互换）$|A|$中某两行元素互换$\\Rightarrow|A|$变号(即得到$-|A|$),两向量的夹角变了，$\\sin (\\alpha-\\beta)=-\\sin (\\beta-\\alpha)$,所以体积变号。</li>\n<li>（倍乘）乘k，就把k乘到任意一行或者列，同理如果某行或者列可以提出k倍也行。因为某向量乘k倍，体积变为k倍。<strong>这里要区别于矩阵的倍乘，矩阵是用来表达系统信息的数表，每个元素都要乘k倍。</strong></li>\n<li>（倍加）某行乘k倍加到另一行上，行列式结果不变，几何表述：<strong>因为这两个向量构成的平行四边形同底同高，面积不变，所以体积也不变。</strong>可拆性表述：拆成两个行列式，其中一个行列式为0，因为它某两行对应成比例。</li>\n<li>单行可拆（加）性</li>\n<li>$|A|=|A^T|$，行列等价，前六个性质同样适用于列。</li>\n</ol>\n<h3 id=\"重要观点\"><a href=\"#重要观点\" class=\"headerlink\" title=\"重要观点\"></a>重要观点</h3><ol>\n<li>$D_n=|A|\\neq0\\Rightarrow S\\neq0\\Rightarrow 组成行列式的向量全独立$</li>\n<li>$D_n=|A|=0\\Rightarrow 组成行列式的向量至少有一个多余$<br><strong>行列式=0还是$\\neq$0才是关键，而不是管它等于多少</strong><br><strong>向量与向量之间要么独立要么多余</strong></li>\n</ol>\n<h2 id=\"矩阵的本质\"><a href=\"#矩阵的本质\" class=\"headerlink\" title=\"矩阵的本质\"></a>矩阵的本质</h2><ol>\n<li>表面上，矩阵是表达系统信息的数表</li>\n<li>本质上，矩阵也是由向量构成的，矩阵的核心是矩阵的<strong>秩</strong>，而秩的本质是组成矩阵的独立向量的个数；矩阵是一种<strong>运算</strong>，一种对应法则，把一个线性代数研究对象变换成另一个的手段；<strong>矩阵还是方程组的系数表</strong>，决定了初等变换的性质（可以行对调，可以行倍加倍减，可以行倍乘）。</li>\n</ol>\n<p><strong>秩的本质</strong>：r(A)=k，则矩阵中有k个独立的向量</p>\n<p><strong>台阶数=秩</strong>，因为台阶之间（向量之间）是独立的。</p>\n<p><strong>行阶梯形矩阵</strong>：1）若有0行，全在下方，2）从行上看，自左边起，出现连续0的个数，自上而下严格单增。若还满足3）台角位置元素为1，4）台角上方元素全为0，称为<strong>行最简阶梯形矩阵</strong>。</p>\n<p><strong>初等变换法：互换、倍乘、倍加</strong></p>\n<p>解释：互换不影响方程组的解，不影响向量的独立性，倍乘不影响方程组的解，不影响向量的独立性，倍加不影响方程组的解，不影响向量的独立性。<strong>矩阵进行初等变换不影响矩阵的秩，</strong>不影响矩阵的本质意义，所以初等变换是可以大量广泛使用的。<br><strong>任何可逆矩阵一定可以通过若干次初等变换化成同阶单位阵</strong></p>\n<h3 id=\"矩阵的乘法\"><a href=\"#矩阵的乘法\" class=\"headerlink\" title=\"矩阵的乘法\"></a>矩阵的乘法</h3><p>AB=C</p>\n<p>矩阵的乘法中，C中的每一个元素都是一个<strong>向量的内积</strong>，所以矩阵乘法可以看做向量内积的推广。另外矩阵的左乘代表行变换，矩阵的右乘代表列表换。矩阵的乘法也可以看做一种函数变换，因为矩阵乘法可以把一个线代对象，转换成另一个线代对象。</p>\n<p><strong>乘法单位元素：</strong><br>1·a=a,a·1=a，其中1称为乘法单位元素，矩阵的乘法单位元素是E（单位矩阵）</p>\n<p><strong>乘法反单位元素：</strong><br>$a\\cdot\\frac{1}{a}=1,\\frac{1}{a}\\cdot a=1$，其中$a$和$\\frac{1}{a}$互称乘法反单位元素。矩阵$A$的乘法反单位元素是$A^{-1}$。<br>二阶逆矩阵，主对角线对调，次对角线取相反数。</p>\n"},{"title":"线性代数笔记--线性代数复习核心思想","date":"2016-09-29T16:00:00.000Z","comments":1,"_content":"\n线性代数是一个整体，各个模块之间联系密不可分。\n\n一、行列式、矩阵\n\n二、向量组、方程组\n\n三、特征值、二次型\n\n命题重点在二和三。\n\n难点在矩阵和向量组\n秩的等式和不等式的研究、分块矩阵\n\n例题：设n阶矩阵A、B乘积可交换，$\\xi_1,\\xi_2,\\cdots,\\xi_{r_1}、\\eta_1,\\eta_2,\\cdots,\\eta_{r_2}$分别是AX=0,BX=0的一个基础解系，且对于n阶矩阵C、D，有r(CA+DB)=n,\n（I）证明$r\\begin{pmatrix}A\\\\B\\end{pmatrix}=n$，且$\\xi_1,\\cdots,\\xi_{r_1},\\eta_1,\\cdots,\\eta_{r_2}$无关；\n（II）证明$\\xi_1,\\cdots,\\xi_{r_2},\\eta_1,\\cdots,\\eta_{r_2}$是ABX=0的一个基础解系。\n1.是解，2.无关，3.**S=n-r，S是基础解系的个数，是自由变量的个数，也就是总变量-秩（有效方程个数，也即约束的个数）**\n**矩阵越乘秩越小**\n（I）\n$n=r(CA+DB)=r\\left((C D)\\begin{pmatrix}A\\\\B\\end{pmatrix}\\right)\\leq r\\begin{pmatrix}A\\\\B\\end{pmatrix}\\leq n\\Rightarrow r\\begin{pmatrix}A\\\\B\\end{pmatrix}=n列满秩$\n\n$\\Rightarrow \\begin{pmatrix}A\\\\B\\end{pmatrix}X=0只有零解\\Rightarrow AX=0与BX=0没有非零公共解\\Rightarrow \\xi_i(i=1,2,\\cdots,r_1)均不可由\\eta_1,\\eta_2,\\cdots,\\eta_{r_2}表出，因若不然，\\xi_i=k_1\\eta_1+k_2\\eta_2+\\cdots+k_{r_2}\\eta_{r_2}，则有公共非零解，矛盾，同理可得，\\eta_i(i=1,2,\\cdots,r_1)均不可由\\xi_1,\\xi_2,\\cdots,\\xi_{r_2}表出，故\\xi_1,\\cdots,\\xi_{r_1},\\eta_1,\\cdots,\\eta_{r_2}$无关\n（II）\n显然，$B\\eta_j=0,j=1,2,\\cdots,r_2\\Rightarrow AB\\eta_j=0\\Rightarrow\\eta_j是ABX=0的解；又AB=BA，A\\xi_i=0\\Rightarrow BA\\xi_i=AB\\xi_i=0\\Rightarrow\\xi_i也是ABX=0的解$\n$r(AB)\\geq r(A)+r(B)-n=n-r_1+n-r_2-n=n-(r_1+r_2)$\n$ABX=0的S=n-r(AB)\\leq r_1+r_2，基础解系中至多r_1+r_2个向量，又根据第一问的证明，显然S\\geq r_1+r_2，至少r_1+r_2个，恰有r_1+r_2个解向量$\n","source":"_posts/2016/2016-09-30-线性代数笔记--线性代数复习核心思想.md","raw":"---\ntitle: 线性代数笔记--线性代数复习核心思想\ndate: 2016-09-30\ncategories: [数学, 线性代数]\ncomments: true\n---\n\n线性代数是一个整体，各个模块之间联系密不可分。\n\n一、行列式、矩阵\n\n二、向量组、方程组\n\n三、特征值、二次型\n\n命题重点在二和三。\n\n难点在矩阵和向量组\n秩的等式和不等式的研究、分块矩阵\n\n例题：设n阶矩阵A、B乘积可交换，$\\xi_1,\\xi_2,\\cdots,\\xi_{r_1}、\\eta_1,\\eta_2,\\cdots,\\eta_{r_2}$分别是AX=0,BX=0的一个基础解系，且对于n阶矩阵C、D，有r(CA+DB)=n,\n（I）证明$r\\begin{pmatrix}A\\\\B\\end{pmatrix}=n$，且$\\xi_1,\\cdots,\\xi_{r_1},\\eta_1,\\cdots,\\eta_{r_2}$无关；\n（II）证明$\\xi_1,\\cdots,\\xi_{r_2},\\eta_1,\\cdots,\\eta_{r_2}$是ABX=0的一个基础解系。\n1.是解，2.无关，3.**S=n-r，S是基础解系的个数，是自由变量的个数，也就是总变量-秩（有效方程个数，也即约束的个数）**\n**矩阵越乘秩越小**\n（I）\n$n=r(CA+DB)=r\\left((C D)\\begin{pmatrix}A\\\\B\\end{pmatrix}\\right)\\leq r\\begin{pmatrix}A\\\\B\\end{pmatrix}\\leq n\\Rightarrow r\\begin{pmatrix}A\\\\B\\end{pmatrix}=n列满秩$\n\n$\\Rightarrow \\begin{pmatrix}A\\\\B\\end{pmatrix}X=0只有零解\\Rightarrow AX=0与BX=0没有非零公共解\\Rightarrow \\xi_i(i=1,2,\\cdots,r_1)均不可由\\eta_1,\\eta_2,\\cdots,\\eta_{r_2}表出，因若不然，\\xi_i=k_1\\eta_1+k_2\\eta_2+\\cdots+k_{r_2}\\eta_{r_2}，则有公共非零解，矛盾，同理可得，\\eta_i(i=1,2,\\cdots,r_1)均不可由\\xi_1,\\xi_2,\\cdots,\\xi_{r_2}表出，故\\xi_1,\\cdots,\\xi_{r_1},\\eta_1,\\cdots,\\eta_{r_2}$无关\n（II）\n显然，$B\\eta_j=0,j=1,2,\\cdots,r_2\\Rightarrow AB\\eta_j=0\\Rightarrow\\eta_j是ABX=0的解；又AB=BA，A\\xi_i=0\\Rightarrow BA\\xi_i=AB\\xi_i=0\\Rightarrow\\xi_i也是ABX=0的解$\n$r(AB)\\geq r(A)+r(B)-n=n-r_1+n-r_2-n=n-(r_1+r_2)$\n$ABX=0的S=n-r(AB)\\leq r_1+r_2，基础解系中至多r_1+r_2个向量，又根据第一问的证明，显然S\\geq r_1+r_2，至少r_1+r_2个，恰有r_1+r_2个解向量$\n","slug":"线性代数笔记--线性代数复习核心思想","published":1,"updated":"2018-04-25T10:42:56.319Z","layout":"post","photos":[],"link":"","_id":"cjm2w8dcp000rfgpxz2a99uyi","content":"<p>线性代数是一个整体，各个模块之间联系密不可分。</p>\n<p>一、行列式、矩阵</p>\n<p>二、向量组、方程组</p>\n<p>三、特征值、二次型</p>\n<p>命题重点在二和三。</p>\n<p>难点在矩阵和向量组<br>秩的等式和不等式的研究、分块矩阵</p>\n<p>例题：设n阶矩阵A、B乘积可交换，$\\xi_1,\\xi_2,\\cdots,\\xi_{r_1}、\\eta_1,\\eta_2,\\cdots,\\eta_{r_2}$分别是AX=0,BX=0的一个基础解系，且对于n阶矩阵C、D，有r(CA+DB)=n,<br>（I）证明$r\\begin{pmatrix}A\\\\B\\end{pmatrix}=n$，且$\\xi_1,\\cdots,\\xi_{r_1},\\eta_1,\\cdots,\\eta_{r_2}$无关；<br>（II）证明$\\xi_1,\\cdots,\\xi_{r_2},\\eta_1,\\cdots,\\eta_{r_2}$是ABX=0的一个基础解系。<br>1.是解，2.无关，3.<strong>S=n-r，S是基础解系的个数，是自由变量的个数，也就是总变量-秩（有效方程个数，也即约束的个数）</strong><br><strong>矩阵越乘秩越小</strong><br>（I）<br>$n=r(CA+DB)=r\\left((C D)\\begin{pmatrix}A\\\\B\\end{pmatrix}\\right)\\leq r\\begin{pmatrix}A\\\\B\\end{pmatrix}\\leq n\\Rightarrow r\\begin{pmatrix}A\\\\B\\end{pmatrix}=n列满秩$</p>\n<p>$\\Rightarrow \\begin{pmatrix}A\\\\B\\end{pmatrix}X=0只有零解\\Rightarrow AX=0与BX=0没有非零公共解\\Rightarrow \\xi_i(i=1,2,\\cdots,r_1)均不可由\\eta_1,\\eta_2,\\cdots,\\eta_{r_2}表出，因若不然，\\xi_i=k_1\\eta_1+k_2\\eta_2+\\cdots+k_{r_2}\\eta_{r_2}，则有公共非零解，矛盾，同理可得，\\eta_i(i=1,2,\\cdots,r_1)均不可由\\xi_1,\\xi_2,\\cdots,\\xi_{r_2}表出，故\\xi_1,\\cdots,\\xi_{r_1},\\eta_1,\\cdots,\\eta_{r_2}$无关<br>（II）<br>显然，$B\\eta_j=0,j=1,2,\\cdots,r_2\\Rightarrow AB\\eta_j=0\\Rightarrow\\eta_j是ABX=0的解；又AB=BA，A\\xi_i=0\\Rightarrow BA\\xi_i=AB\\xi_i=0\\Rightarrow\\xi_i也是ABX=0的解$<br>$r(AB)\\geq r(A)+r(B)-n=n-r_1+n-r_2-n=n-(r_1+r_2)$<br>$ABX=0的S=n-r(AB)\\leq r_1+r_2，基础解系中至多r_1+r_2个向量，又根据第一问的证明，显然S\\geq r_1+r_2，至少r_1+r_2个，恰有r_1+r_2个解向量$</p>\n","site":{"data":{}},"excerpt":"","more":"<p>线性代数是一个整体，各个模块之间联系密不可分。</p>\n<p>一、行列式、矩阵</p>\n<p>二、向量组、方程组</p>\n<p>三、特征值、二次型</p>\n<p>命题重点在二和三。</p>\n<p>难点在矩阵和向量组<br>秩的等式和不等式的研究、分块矩阵</p>\n<p>例题：设n阶矩阵A、B乘积可交换，$\\xi_1,\\xi_2,\\cdots,\\xi_{r_1}、\\eta_1,\\eta_2,\\cdots,\\eta_{r_2}$分别是AX=0,BX=0的一个基础解系，且对于n阶矩阵C、D，有r(CA+DB)=n,<br>（I）证明$r\\begin{pmatrix}A\\\\B\\end{pmatrix}=n$，且$\\xi_1,\\cdots,\\xi_{r_1},\\eta_1,\\cdots,\\eta_{r_2}$无关；<br>（II）证明$\\xi_1,\\cdots,\\xi_{r_2},\\eta_1,\\cdots,\\eta_{r_2}$是ABX=0的一个基础解系。<br>1.是解，2.无关，3.<strong>S=n-r，S是基础解系的个数，是自由变量的个数，也就是总变量-秩（有效方程个数，也即约束的个数）</strong><br><strong>矩阵越乘秩越小</strong><br>（I）<br>$n=r(CA+DB)=r\\left((C D)\\begin{pmatrix}A\\\\B\\end{pmatrix}\\right)\\leq r\\begin{pmatrix}A\\\\B\\end{pmatrix}\\leq n\\Rightarrow r\\begin{pmatrix}A\\\\B\\end{pmatrix}=n列满秩$</p>\n<p>$\\Rightarrow \\begin{pmatrix}A\\\\B\\end{pmatrix}X=0只有零解\\Rightarrow AX=0与BX=0没有非零公共解\\Rightarrow \\xi_i(i=1,2,\\cdots,r_1)均不可由\\eta_1,\\eta_2,\\cdots,\\eta_{r_2}表出，因若不然，\\xi_i=k_1\\eta_1+k_2\\eta_2+\\cdots+k_{r_2}\\eta_{r_2}，则有公共非零解，矛盾，同理可得，\\eta_i(i=1,2,\\cdots,r_1)均不可由\\xi_1,\\xi_2,\\cdots,\\xi_{r_2}表出，故\\xi_1,\\cdots,\\xi_{r_1},\\eta_1,\\cdots,\\eta_{r_2}$无关<br>（II）<br>显然，$B\\eta_j=0,j=1,2,\\cdots,r_2\\Rightarrow AB\\eta_j=0\\Rightarrow\\eta_j是ABX=0的解；又AB=BA，A\\xi_i=0\\Rightarrow BA\\xi_i=AB\\xi_i=0\\Rightarrow\\xi_i也是ABX=0的解$<br>$r(AB)\\geq r(A)+r(B)-n=n-r_1+n-r_2-n=n-(r_1+r_2)$<br>$ABX=0的S=n-r(AB)\\leq r_1+r_2，基础解系中至多r_1+r_2个向量，又根据第一问的证明，显然S\\geq r_1+r_2，至少r_1+r_2个，恰有r_1+r_2个解向量$</p>\n"},{"title":"学习方法总结","date":"2017-01-01T16:00:00.000Z","comments":1,"_content":"\n我把自己以前的多个思考笔记综合成了这一篇，有关于学习的 方法论，怎么学英语，怎么背单词，怎么做笔记，以及自我管理\n\n你要坚信做任何事都不能蛮干，做每件事有每件事的方法，不要在错误的道路上越走越远\n\n我把学习分为三个境界：重复、理解性学习、教别人\n\n## 重复重复再重复\n\n你可能知道条件反射，即便是动物也具备的一种学习方法，马戏团天天在证明这一点，通过不断的重复（训练、奖励、惩罚），猪都会钻火圈。无论是学母语，还是学英语，基石都是重复。\n\n## 构建认知网络\n\n人的认知是一张一直在不停编织的网络，很多知识，抽象出来的结论、认知，都是相通的（类似的），人通过联想来举一反三，并通过这种联系轻松的记忆学习。\n\n所以死记硬背是低效的，因为你试图孤立你所学的知识，而孤立的东西难以被人记起，你可以回想一下自己是不是经常忘记熟人的名字，如果熟人的名字都能忘（你是不是仅靠重复使用来记忆别人的名字，而不是通过联系其他事物呢？），忘掉知识不是很正常吗。\n\n所谓理解性学习，就是用原有的认知去解释新事物，以至于新的认知变得水到渠成，你可以从很多条路子记起这个知识，那么你就内化了这个认知，这才学到了位。\n\n构建自己的认知网络，就是理解性学习，学习来不得半点生硬，重复重复再重复，固然有用，但时间久了依然会忘记，并且很多知识都是需要灵活应用的，你要把它跟其他东西联系，而且你必须这样做，否则一个孤立的知识，你记得或者不记得没有任何区别。在已经构建好的认知上添砖加瓦，并不断试图从多个不同角度去应用它，让它指导你的其他思维和行为，这样才能慢慢内化。\n\n不要因此而有了不努力去重复的练习和学习的借口，认真在任何时候都是首要的精神\n\n### 理解性学习的不可跳跃\n\n学习其实不难，你觉得难，觉得不懂，原因只有一个：如果一个结论得出来你无法理解，那就是从前提到结论这个过程你无法理解，为什么无法理解，原因也很简单：这其中暗含着一些前提，而这些暗含的前提你是不知道的，或者还没理解，这造成了一个跳跃，而学习和理解是不能跳跃的，你在这里断了链条，那么就会无法继续前进，或者云里雾里，一处不懂处处不懂。\n\n学习是有路径的，一个初学者你给他看高深的理论，中间越过很多步骤，他是根本无法学会的。你必须一步一个脚印，也只有一步一个脚印才能学的会，学的好，学的精通。很多人由于觉得难就很烦躁，产生畏难情绪，觉得累，想要放下或者放弃。其实就是因为没有找到属于你的学习路径。必须要把中间的那些暗含的前提找到弄懂，然后你就理解了，就可以继续上路。判断一个学习资料是否合适，就要看这份学习资料，对你是不是太难，太难肯定学不下去，太简单又浪费你的时间。\n\n## 费曼学习法\n\n费曼学习法的精髓就是通过教授来强化学习，在教别人的时候你对所学的东西的理解会进一步巩固加深。\n\n其实你教别人的时候就是在解构理解的过程，也是在重复理解的过程，你讲的越是清晰明了，别人一听就懂，就证明你自己的理解过程越成功越细致，何况你自己还在重复，所以用这个方法来复习是非常棒的，效率很高。\n\n## 怎么学英语\n\n学英语应该是很多国人的痛点，因为学了很多年都没学好，有些从小学开始学，有些从初中开始学，但直到大学本科毕业，英语还是很差。我知道这种苦楚与恐惧，也曾想学好英语，但一直没成功，我在思考这里面的原因，又加上看了一些人的见解，我总结如下：没有环境，这是根源，记忆是靠重复加强，靠关联其他记忆来内化。学习语言尤其要重复，可能因为语言是人类表达的根基，主要是靠死记硬背和疯狂输出，你总不能靠推理来学习语言。所以我们学英语的强度还远远不够，我们没有环境，如果有语言环境，那你在无形之间就已经达到一个高强度的状态，所以我们只能靠自己去打造这种高强度的环境。至少你每天都在学英语用英语吗，如果你做到了，你的英语肯定稳步提升。问题就出在这儿。当你看到英文时是不是恐惧性的跳过不看，当你看到不认识的单词你是不是没有去查，就这还想学好英语，你自己内心里都不会相信吧。这还只是初步的，你有没有刻意去输出呢，输入还算有点环境，毕竟英语的资源一不小心就接触到，但输出好像还真没机会。模仿造句应该被当做像你打游戏中的做日常任务，每造一个句子你都该记录下来，作为游戏日志，累积财富，写文章应该当做下艰难副本，每写一篇你都该奖励自己。对语言的热爱是重要的一个环节，去了解英语文化是有好处的，但另一个重要的环节是坚持，坚持属于长期控制，跟你的短期利益其实没多大关系（所以没几个人能坚持做一件事，随时可能放弃），真正能控制你做一件事的就是 及时反馈，就像很多人打游戏会上瘾，这是人的先天特征，短期利益永远重要，及时的反馈才能刺激我们的神经，坚持学英语也应该建立短期目标，提供及时反馈。这和新东方英语老师朱伟所说的：”多一些不为什么的坚持，少一些功利主义的追求“，其实是一样的，说的就是 长期目标无法让人坚持，心怀大志的去做甚至还不如莫名其妙，毫无理由的去做，有句古话很伤人，叫：“小人常立志，君子立志长”，我曾经就被这句话伤过，因为一直是一个有抱负有理想的青年，曾今有过很多远大的理想，但现在依然没什么值得说的成就，而且我经常会遇到与自己对立起来的情况，想要坚持，但又坚持不了，这其实不应该怪自己，就像你饿了要吃饭，而不是怪自己要吃饭，人应该多多发现自己的本性，而不要去对抗，在进行意志力对抗赛中我们应该常打胜仗，而不是去打必定失败的仗，比如你可以定一个小目标，跑1万米，雨中登山，这种短期的较量，只要你肯对自己下狠心，一定可以做成（而不是制定一个过于长远的计划），而且事后会极大的提升自己的自信，而人一天不是每时每刻都斗志满满，在脆弱的时候支撑你的绝不会是你的意志力，而是习惯，我们所做的所谓坚持，往往毫无胜算，而且不断地一次又一次的伤害到自己，不断的消磨意志力而不是提升，最后只会自己和自己对立起来变成一个真正的屌丝，和loser，真的是会有自暴自弃的那一天，只是你现在还年轻，但你仍然会发现岁月不曾停一刻地磨平你的棱角和骄傲，这大概是很多人经历过的吧。我们不应该用自己不多的意志力去打一场不可能赢的仗，我们应该用习惯，用及时反馈，用短期利益，和短期突进训练计划（强迫自己在一个较短的时间内做完某件困难的事，比如跑1万米，看完某个难懂的书的一章，需要查阅大量资料补全理解过程）。初时，随心所欲，以至于放荡不羁，堕落而颓废；中时，勤于律己，结果自我对立，苦不堪言；末了，依旧随心所欲，而不逾矩，如列子乘奔御风，逍遥自在，内心合一。这大概就是看山依旧是山的境界吧。我们需要的只是一个系统的及时反馈方法，和一个一个短时间的小目标（把一个大的计划分解成小目标是有道理的，人可以在短时间内强迫自己，熬一熬就过去了，相信你的意志力）。我这里并没有谈具体的技巧，想看具体技巧可以看接下来的 背单词”。\n\n### 背单词\n\n做一件事，首先要证明他是否对你有用，否则不去做（这里我想说说对于游戏的态度，大多数人生来都喜欢玩游戏，但很明显很多人玩游戏上了瘾耽误了不少事，导致生活过的很糟心，我指的是大多数大学生哦，其实你有没有想过不是你在玩游戏，而是游戏在玩你）。背单词是学习英语的一个重大话题。有人说不用去背单词，因为背了单词却不会使用这样的大有人在，应该去广泛的阅读，在文章中记住单词的意思；有人说应该去背句子，用句子串起单词，这样就知道单词的用法；也有人说在阅读中增长词汇量太费时间，背单词是增长词汇量的捷径。\n我发表一下我自己总结出来的一套看法：\n\n1. 做任何事都要有正确的方法才能事半功倍，英语学习也是一样，我们可以科学地把学习语言分为：输入和输出，听、读是输入，说、写是输出，输出是输入的巩固和保障，没有输出，英语很难学好，事倍功半。这就是为什么我们大多数中国人总是学不好英语的原因，没有输出环境，输入环境倒是还可以。解决办法就是补上这个输出环节，方法无非是：强迫自己写作，学习地道的写作，地道的英语表达，强迫自己去说，学习地道的口语。\n2. 做事情慢比做错好，背单词首先要保证至少背的是正确的意思（无论是中文还是英文释义），在这个对的基础上，背了总比没背要好。\n3. 其次关于对背了单词却不会使用的问题，背单词属于输入，使用单词属于输出，你只是背单词当然不一定会使用，使用还得靠说，靠写。而架起输入和输出的桥梁就是模仿，再粗陋一点就是背诵然后一字不改的输出来。多背好句子，长句也好，短句也好，当然这个句子必须有亮点，要不然你自己都能写出来，就没有意义，比如全世界人都会说：I love you.[^1]要明白自己的起点，少做一些无用功。然后就是模仿造句，就像小时候学习中文的时候的造句练习。写短文，然后同样是模仿练习。这里说的背诵并不是要求你过多久都还记得背了什么，而是作为一个模仿对象，帮助自己正确的输出自己想要表达的东西，请问你小时候背过的文章你还记得几篇？关键不在于记忆故事、内容，而在于内化英文表达，形成语感。所以这里的背诵也可以理解为熟读，模仿。\n4. 我最想说的一点就是，我们很多人的词汇其实也不算低，但说英语根本没词，没话可说，或者说出来一堆的中式英语表达。原因在于，一门语言背后往往承载着一个相应的文化，就像我们中国不同地方的方言的表达也是不一样的。普通话说：行，河南话说：中。中西方文化差异造成了，即便你认识很多单词，知道很多语法，你依然不知道怎么去描述一件事，表达一种意思。因为别人文化里的表达方式和你的不一样。我们说：毫无睡意，英文表示则是：wide awake。请问这个表达是你直接能想到的吗，我们大多数人可能喜欢从字面上，一字一字翻译，这完全是错的，真正的翻译应该是一个意思对应一个意思的翻译，假如英文中有个意思中文里没有怎么办，这就是极考验翻译水平的地方，你要用简单易懂的方式解释，甚至可以创造一个舶来词。记单词并不是全部，背表达方式才能真正的学会一门语言。\n5. 既然背单词是可以有的，那么背单词该怎么背，我推荐用词频[^2]，按照语言掌握的一般规律，先背最常见的，再背次常见的，以此类推。一般柯林斯的词频就行了，网上也是很容易找到，柯林斯选出了1万多的词，把这些词总共分了5类，用五角星标记，五颗星的是最常见的，比如词频排名第一的the，就在这里面，依此类推，一颗星的是词频最低的，当然还有不带星的，那种单词就更少用到了，所以也不用急着去背。按词频背单词可以让你精确定位常用单词，避免学了一堆不常用的，这种安排其实也发生在我们学英语的整个过程，比如小学单词比初中单词常见，初中的又比高中的常见，高考的又比大学四六级的常见，大学四六级的又比考研、托福、雅思、GRE新增的词汇常见。按词频背单词还有一个好处就是可以查漏补缺，你可以清楚的知道自己哪些单词还稍微陌生，还有哪些重要的单词还完全不认识，这是靠阅读学单词花费大量时间也无法办到的。这叫针对性。当然阅读中学单词是有用的，一般来说我们可以在阅读中巩固对单词的记忆，用法等等，用起来的单词更容易记住，因为“用”这个词，代表你在反复强化你脑中的那些相应的神经元路径[^3]，而且增添更多的应用场景（新的神经元路径），让你记得更牢，更生动。\n\n## 结合互联网的现代化笔记法\n\n今天对于记笔记又有了点新想法，结合以前的，总结如下：\n\n1. 所有笔记都不可靠，最终要记在脑子里，内化成自己可以随时调用的资料，和意识。笔记只是为了便于复习回顾，没有内化它就不是你的，只是一团外在的信息，对你来说也就跟没有一样，你还是你，当笔记是身外之物的时候它是不可靠的，只有当知识、技巧和思维方法内化进你大脑的神经回路里，它才真正成为你身体的一部分，是自我意识的一部分，你也因此变得更加强大起来，然而很多人学的知识是死的，不能用于帮助自己解释和理解这个世界，和身边发生的各种事，那你学这些东西又有什么意义呢，你面对这个纷繁复杂的现象宇宙，鸟还是鸟，花草树木还是花草树木，月亮还是月亮，感性统治着你，所有知识和理性全都被封锁起来，你看不透这个世界，也没有借助自己所学去帮助自己看透这个世界，于是你忘了你学的东西。自始至终都没有用到它们，忘掉是很自然的。但其实它们就在你身边，无时无刻不在，只是你没发现它们，没有有意识地去看见它们。这样的学习学一辈子都是竹篮打水（漏的跟打的一样多），到头来一场空，白白虚耗了时光。少年，想获得力量吗，那就去做个有心人吧，把知识用起来，让它成为你大脑的一部分。\n2. 笔记一定要电子化，书籍也电子化，因为电子化便于携带，传输，查阅，搜索，检索。就算先写在纸上，但之后也要拍照整理成电子的（并附加上关键词，摘要），数据不应该流失，遇到半熟的知识，第一反应查笔记，第二反应上互联网搜，并把学到的用自己的语言记在笔记里。\n3. 善于找别人记下的笔记和总结，同时利用起像百度百科和维基百科和各种人的博客等等东西，前两者比较稳定，所以可以贴链接即可，后者不稳定一定要截图，或者复制粘贴。这样做是尽量保证笔记的持久性，其实这么久的持久性也没啥用，因为你势必要在相对较短的时间内消化知识，你不消化它就会淡忘，你不用起来它就相当于没有，你也就白学了。比如我一直想整理出一份完整的系统的数学笔记，但我其实没有必要一笔一笔写下这个笔记，而且我也没有这个时间去干这件事，而且说到底笔记只是用来协助内化记忆，本身就只是一个附带性工作（当然也不能潦草敷衍，否则难起到应有的作用），何必如此执着，真正要下功夫做的是记忆，运用（做题，解题中应用知识），并结合生活这本无字大书。别人的笔记不完整，这不要紧，你自己立好框架，然后以添加URL链接的方式把这些内容接入你的框架。比如今天我找柯西中值定理的证明，我忘了怎么推导这个定理，我去谷歌搜索了，维基百科里有完整的证明，我只需在笔记中柯西中值定理证明这一处添加一个链接，或做个注释。如上所说，我只添了：证明，维基百科，这么几个字，这是因为只要在有互联网和手机的时候我就可以立即查阅，互联网是一个非常便利的云端，增强了每一个现代人的移动性（这一重要属性在罗辑思维里，吴伯凡总结过，生物的一个基本属性就是移动性，越高等的生物移动属性越高），这就是结合网络的笔记法，整个网络都是你的笔记，你只需要做个标记就可迅速找到。\n4. 由此便可得出 只列框架和名词的高度精简笔记（甚至框架也可以在互联网上找到合适的，但每个人都有自己的知识树，另外框架是个索引性的东西，你自己必须非常熟悉，如果索引都依赖于外部，你自己还剩下些什么呢，特别是重要的索引，一定得是非常熟悉的）：\n- 概念\n- 应用场景\n- 发现背景\n- 证明推导过程\n- 习题\n等等都以树状链接开来，有本地的拓展也有互联网的拓展部分。\n5. 由于互联网上的许多内容不一定正确（甚至有的时候会误导你），不一定完整，而书籍和传统出版物相对来说靠谱，所以做笔记时强烈建议考虑内容的质量。\n\n[^1]:英语和汉语的共同点就是主谓宾的顺序是一致的，不同点在于修饰，英语的修饰习惯后置，汉语的修饰从不后置，一定是放在前面的 ↩\n[^2]:词频号，代表词出现在词频排名中的位置，比如the的词频号是1，代表它在语料库中出现频率最高，排名第一。 ↩\n[^3]:人脑记忆的物理特点：靠神经元的链接，电脑存储的特点：靠电子元件的电位固定地，精确地存储。有时候你忘了一样东西，并不是他消失了，而是它在你脑中的神经元连接路径太弱、太少，你搜索不到它。所以我们记忆有两个特点：一个是不断重复强化，加强这条路径；一个是把要记忆的东西跟很多已经在你脑海里最常用的记忆联系起来，也就是并入你的记忆主堡，那你将快速的找到它，这也是理解性记忆的根源，因为理解代表与你的已有认知不悖，也就是可以由已有定理推出要学习的定理，如果推导一个定理可以有很多方法，或者有一个非常容易想到的方法，那么这条定理顺理成章的就被你记下来了。死记硬背则是用的第一种方法，不断的重复强化，但效果不佳，原因很简单，我们的大脑天生喜欢第二种方法，这是大脑的物理结构决定的，物理基础决定上层建筑，只有把一个东西并入你的知识树，内化成自己的日常认知习惯，它就牢牢的钉在你的脑子里，成为你随时可以调取的记忆，而这也是世上不存在靠死记硬背能真正学透的原因，因为死记硬背没有使这个知识和其他东西联系起来，就像你是一个瓶子一个瓶子的装知识，其间泾渭分隔，发散性很差，那么你根本不会在很多要用的时候想起它来，也就无法学以致用。 ↩\n","source":"_posts/2017/2017-01-02-学习方法总结.md","raw":"---\ntitle: 学习方法总结\ndate: 2017-01-02\ncategories: [随笔]\ncomments: true\n---\n\n我把自己以前的多个思考笔记综合成了这一篇，有关于学习的 方法论，怎么学英语，怎么背单词，怎么做笔记，以及自我管理\n\n你要坚信做任何事都不能蛮干，做每件事有每件事的方法，不要在错误的道路上越走越远\n\n我把学习分为三个境界：重复、理解性学习、教别人\n\n## 重复重复再重复\n\n你可能知道条件反射，即便是动物也具备的一种学习方法，马戏团天天在证明这一点，通过不断的重复（训练、奖励、惩罚），猪都会钻火圈。无论是学母语，还是学英语，基石都是重复。\n\n## 构建认知网络\n\n人的认知是一张一直在不停编织的网络，很多知识，抽象出来的结论、认知，都是相通的（类似的），人通过联想来举一反三，并通过这种联系轻松的记忆学习。\n\n所以死记硬背是低效的，因为你试图孤立你所学的知识，而孤立的东西难以被人记起，你可以回想一下自己是不是经常忘记熟人的名字，如果熟人的名字都能忘（你是不是仅靠重复使用来记忆别人的名字，而不是通过联系其他事物呢？），忘掉知识不是很正常吗。\n\n所谓理解性学习，就是用原有的认知去解释新事物，以至于新的认知变得水到渠成，你可以从很多条路子记起这个知识，那么你就内化了这个认知，这才学到了位。\n\n构建自己的认知网络，就是理解性学习，学习来不得半点生硬，重复重复再重复，固然有用，但时间久了依然会忘记，并且很多知识都是需要灵活应用的，你要把它跟其他东西联系，而且你必须这样做，否则一个孤立的知识，你记得或者不记得没有任何区别。在已经构建好的认知上添砖加瓦，并不断试图从多个不同角度去应用它，让它指导你的其他思维和行为，这样才能慢慢内化。\n\n不要因此而有了不努力去重复的练习和学习的借口，认真在任何时候都是首要的精神\n\n### 理解性学习的不可跳跃\n\n学习其实不难，你觉得难，觉得不懂，原因只有一个：如果一个结论得出来你无法理解，那就是从前提到结论这个过程你无法理解，为什么无法理解，原因也很简单：这其中暗含着一些前提，而这些暗含的前提你是不知道的，或者还没理解，这造成了一个跳跃，而学习和理解是不能跳跃的，你在这里断了链条，那么就会无法继续前进，或者云里雾里，一处不懂处处不懂。\n\n学习是有路径的，一个初学者你给他看高深的理论，中间越过很多步骤，他是根本无法学会的。你必须一步一个脚印，也只有一步一个脚印才能学的会，学的好，学的精通。很多人由于觉得难就很烦躁，产生畏难情绪，觉得累，想要放下或者放弃。其实就是因为没有找到属于你的学习路径。必须要把中间的那些暗含的前提找到弄懂，然后你就理解了，就可以继续上路。判断一个学习资料是否合适，就要看这份学习资料，对你是不是太难，太难肯定学不下去，太简单又浪费你的时间。\n\n## 费曼学习法\n\n费曼学习法的精髓就是通过教授来强化学习，在教别人的时候你对所学的东西的理解会进一步巩固加深。\n\n其实你教别人的时候就是在解构理解的过程，也是在重复理解的过程，你讲的越是清晰明了，别人一听就懂，就证明你自己的理解过程越成功越细致，何况你自己还在重复，所以用这个方法来复习是非常棒的，效率很高。\n\n## 怎么学英语\n\n学英语应该是很多国人的痛点，因为学了很多年都没学好，有些从小学开始学，有些从初中开始学，但直到大学本科毕业，英语还是很差。我知道这种苦楚与恐惧，也曾想学好英语，但一直没成功，我在思考这里面的原因，又加上看了一些人的见解，我总结如下：没有环境，这是根源，记忆是靠重复加强，靠关联其他记忆来内化。学习语言尤其要重复，可能因为语言是人类表达的根基，主要是靠死记硬背和疯狂输出，你总不能靠推理来学习语言。所以我们学英语的强度还远远不够，我们没有环境，如果有语言环境，那你在无形之间就已经达到一个高强度的状态，所以我们只能靠自己去打造这种高强度的环境。至少你每天都在学英语用英语吗，如果你做到了，你的英语肯定稳步提升。问题就出在这儿。当你看到英文时是不是恐惧性的跳过不看，当你看到不认识的单词你是不是没有去查，就这还想学好英语，你自己内心里都不会相信吧。这还只是初步的，你有没有刻意去输出呢，输入还算有点环境，毕竟英语的资源一不小心就接触到，但输出好像还真没机会。模仿造句应该被当做像你打游戏中的做日常任务，每造一个句子你都该记录下来，作为游戏日志，累积财富，写文章应该当做下艰难副本，每写一篇你都该奖励自己。对语言的热爱是重要的一个环节，去了解英语文化是有好处的，但另一个重要的环节是坚持，坚持属于长期控制，跟你的短期利益其实没多大关系（所以没几个人能坚持做一件事，随时可能放弃），真正能控制你做一件事的就是 及时反馈，就像很多人打游戏会上瘾，这是人的先天特征，短期利益永远重要，及时的反馈才能刺激我们的神经，坚持学英语也应该建立短期目标，提供及时反馈。这和新东方英语老师朱伟所说的：”多一些不为什么的坚持，少一些功利主义的追求“，其实是一样的，说的就是 长期目标无法让人坚持，心怀大志的去做甚至还不如莫名其妙，毫无理由的去做，有句古话很伤人，叫：“小人常立志，君子立志长”，我曾经就被这句话伤过，因为一直是一个有抱负有理想的青年，曾今有过很多远大的理想，但现在依然没什么值得说的成就，而且我经常会遇到与自己对立起来的情况，想要坚持，但又坚持不了，这其实不应该怪自己，就像你饿了要吃饭，而不是怪自己要吃饭，人应该多多发现自己的本性，而不要去对抗，在进行意志力对抗赛中我们应该常打胜仗，而不是去打必定失败的仗，比如你可以定一个小目标，跑1万米，雨中登山，这种短期的较量，只要你肯对自己下狠心，一定可以做成（而不是制定一个过于长远的计划），而且事后会极大的提升自己的自信，而人一天不是每时每刻都斗志满满，在脆弱的时候支撑你的绝不会是你的意志力，而是习惯，我们所做的所谓坚持，往往毫无胜算，而且不断地一次又一次的伤害到自己，不断的消磨意志力而不是提升，最后只会自己和自己对立起来变成一个真正的屌丝，和loser，真的是会有自暴自弃的那一天，只是你现在还年轻，但你仍然会发现岁月不曾停一刻地磨平你的棱角和骄傲，这大概是很多人经历过的吧。我们不应该用自己不多的意志力去打一场不可能赢的仗，我们应该用习惯，用及时反馈，用短期利益，和短期突进训练计划（强迫自己在一个较短的时间内做完某件困难的事，比如跑1万米，看完某个难懂的书的一章，需要查阅大量资料补全理解过程）。初时，随心所欲，以至于放荡不羁，堕落而颓废；中时，勤于律己，结果自我对立，苦不堪言；末了，依旧随心所欲，而不逾矩，如列子乘奔御风，逍遥自在，内心合一。这大概就是看山依旧是山的境界吧。我们需要的只是一个系统的及时反馈方法，和一个一个短时间的小目标（把一个大的计划分解成小目标是有道理的，人可以在短时间内强迫自己，熬一熬就过去了，相信你的意志力）。我这里并没有谈具体的技巧，想看具体技巧可以看接下来的 背单词”。\n\n### 背单词\n\n做一件事，首先要证明他是否对你有用，否则不去做（这里我想说说对于游戏的态度，大多数人生来都喜欢玩游戏，但很明显很多人玩游戏上了瘾耽误了不少事，导致生活过的很糟心，我指的是大多数大学生哦，其实你有没有想过不是你在玩游戏，而是游戏在玩你）。背单词是学习英语的一个重大话题。有人说不用去背单词，因为背了单词却不会使用这样的大有人在，应该去广泛的阅读，在文章中记住单词的意思；有人说应该去背句子，用句子串起单词，这样就知道单词的用法；也有人说在阅读中增长词汇量太费时间，背单词是增长词汇量的捷径。\n我发表一下我自己总结出来的一套看法：\n\n1. 做任何事都要有正确的方法才能事半功倍，英语学习也是一样，我们可以科学地把学习语言分为：输入和输出，听、读是输入，说、写是输出，输出是输入的巩固和保障，没有输出，英语很难学好，事倍功半。这就是为什么我们大多数中国人总是学不好英语的原因，没有输出环境，输入环境倒是还可以。解决办法就是补上这个输出环节，方法无非是：强迫自己写作，学习地道的写作，地道的英语表达，强迫自己去说，学习地道的口语。\n2. 做事情慢比做错好，背单词首先要保证至少背的是正确的意思（无论是中文还是英文释义），在这个对的基础上，背了总比没背要好。\n3. 其次关于对背了单词却不会使用的问题，背单词属于输入，使用单词属于输出，你只是背单词当然不一定会使用，使用还得靠说，靠写。而架起输入和输出的桥梁就是模仿，再粗陋一点就是背诵然后一字不改的输出来。多背好句子，长句也好，短句也好，当然这个句子必须有亮点，要不然你自己都能写出来，就没有意义，比如全世界人都会说：I love you.[^1]要明白自己的起点，少做一些无用功。然后就是模仿造句，就像小时候学习中文的时候的造句练习。写短文，然后同样是模仿练习。这里说的背诵并不是要求你过多久都还记得背了什么，而是作为一个模仿对象，帮助自己正确的输出自己想要表达的东西，请问你小时候背过的文章你还记得几篇？关键不在于记忆故事、内容，而在于内化英文表达，形成语感。所以这里的背诵也可以理解为熟读，模仿。\n4. 我最想说的一点就是，我们很多人的词汇其实也不算低，但说英语根本没词，没话可说，或者说出来一堆的中式英语表达。原因在于，一门语言背后往往承载着一个相应的文化，就像我们中国不同地方的方言的表达也是不一样的。普通话说：行，河南话说：中。中西方文化差异造成了，即便你认识很多单词，知道很多语法，你依然不知道怎么去描述一件事，表达一种意思。因为别人文化里的表达方式和你的不一样。我们说：毫无睡意，英文表示则是：wide awake。请问这个表达是你直接能想到的吗，我们大多数人可能喜欢从字面上，一字一字翻译，这完全是错的，真正的翻译应该是一个意思对应一个意思的翻译，假如英文中有个意思中文里没有怎么办，这就是极考验翻译水平的地方，你要用简单易懂的方式解释，甚至可以创造一个舶来词。记单词并不是全部，背表达方式才能真正的学会一门语言。\n5. 既然背单词是可以有的，那么背单词该怎么背，我推荐用词频[^2]，按照语言掌握的一般规律，先背最常见的，再背次常见的，以此类推。一般柯林斯的词频就行了，网上也是很容易找到，柯林斯选出了1万多的词，把这些词总共分了5类，用五角星标记，五颗星的是最常见的，比如词频排名第一的the，就在这里面，依此类推，一颗星的是词频最低的，当然还有不带星的，那种单词就更少用到了，所以也不用急着去背。按词频背单词可以让你精确定位常用单词，避免学了一堆不常用的，这种安排其实也发生在我们学英语的整个过程，比如小学单词比初中单词常见，初中的又比高中的常见，高考的又比大学四六级的常见，大学四六级的又比考研、托福、雅思、GRE新增的词汇常见。按词频背单词还有一个好处就是可以查漏补缺，你可以清楚的知道自己哪些单词还稍微陌生，还有哪些重要的单词还完全不认识，这是靠阅读学单词花费大量时间也无法办到的。这叫针对性。当然阅读中学单词是有用的，一般来说我们可以在阅读中巩固对单词的记忆，用法等等，用起来的单词更容易记住，因为“用”这个词，代表你在反复强化你脑中的那些相应的神经元路径[^3]，而且增添更多的应用场景（新的神经元路径），让你记得更牢，更生动。\n\n## 结合互联网的现代化笔记法\n\n今天对于记笔记又有了点新想法，结合以前的，总结如下：\n\n1. 所有笔记都不可靠，最终要记在脑子里，内化成自己可以随时调用的资料，和意识。笔记只是为了便于复习回顾，没有内化它就不是你的，只是一团外在的信息，对你来说也就跟没有一样，你还是你，当笔记是身外之物的时候它是不可靠的，只有当知识、技巧和思维方法内化进你大脑的神经回路里，它才真正成为你身体的一部分，是自我意识的一部分，你也因此变得更加强大起来，然而很多人学的知识是死的，不能用于帮助自己解释和理解这个世界，和身边发生的各种事，那你学这些东西又有什么意义呢，你面对这个纷繁复杂的现象宇宙，鸟还是鸟，花草树木还是花草树木，月亮还是月亮，感性统治着你，所有知识和理性全都被封锁起来，你看不透这个世界，也没有借助自己所学去帮助自己看透这个世界，于是你忘了你学的东西。自始至终都没有用到它们，忘掉是很自然的。但其实它们就在你身边，无时无刻不在，只是你没发现它们，没有有意识地去看见它们。这样的学习学一辈子都是竹篮打水（漏的跟打的一样多），到头来一场空，白白虚耗了时光。少年，想获得力量吗，那就去做个有心人吧，把知识用起来，让它成为你大脑的一部分。\n2. 笔记一定要电子化，书籍也电子化，因为电子化便于携带，传输，查阅，搜索，检索。就算先写在纸上，但之后也要拍照整理成电子的（并附加上关键词，摘要），数据不应该流失，遇到半熟的知识，第一反应查笔记，第二反应上互联网搜，并把学到的用自己的语言记在笔记里。\n3. 善于找别人记下的笔记和总结，同时利用起像百度百科和维基百科和各种人的博客等等东西，前两者比较稳定，所以可以贴链接即可，后者不稳定一定要截图，或者复制粘贴。这样做是尽量保证笔记的持久性，其实这么久的持久性也没啥用，因为你势必要在相对较短的时间内消化知识，你不消化它就会淡忘，你不用起来它就相当于没有，你也就白学了。比如我一直想整理出一份完整的系统的数学笔记，但我其实没有必要一笔一笔写下这个笔记，而且我也没有这个时间去干这件事，而且说到底笔记只是用来协助内化记忆，本身就只是一个附带性工作（当然也不能潦草敷衍，否则难起到应有的作用），何必如此执着，真正要下功夫做的是记忆，运用（做题，解题中应用知识），并结合生活这本无字大书。别人的笔记不完整，这不要紧，你自己立好框架，然后以添加URL链接的方式把这些内容接入你的框架。比如今天我找柯西中值定理的证明，我忘了怎么推导这个定理，我去谷歌搜索了，维基百科里有完整的证明，我只需在笔记中柯西中值定理证明这一处添加一个链接，或做个注释。如上所说，我只添了：证明，维基百科，这么几个字，这是因为只要在有互联网和手机的时候我就可以立即查阅，互联网是一个非常便利的云端，增强了每一个现代人的移动性（这一重要属性在罗辑思维里，吴伯凡总结过，生物的一个基本属性就是移动性，越高等的生物移动属性越高），这就是结合网络的笔记法，整个网络都是你的笔记，你只需要做个标记就可迅速找到。\n4. 由此便可得出 只列框架和名词的高度精简笔记（甚至框架也可以在互联网上找到合适的，但每个人都有自己的知识树，另外框架是个索引性的东西，你自己必须非常熟悉，如果索引都依赖于外部，你自己还剩下些什么呢，特别是重要的索引，一定得是非常熟悉的）：\n- 概念\n- 应用场景\n- 发现背景\n- 证明推导过程\n- 习题\n等等都以树状链接开来，有本地的拓展也有互联网的拓展部分。\n5. 由于互联网上的许多内容不一定正确（甚至有的时候会误导你），不一定完整，而书籍和传统出版物相对来说靠谱，所以做笔记时强烈建议考虑内容的质量。\n\n[^1]:英语和汉语的共同点就是主谓宾的顺序是一致的，不同点在于修饰，英语的修饰习惯后置，汉语的修饰从不后置，一定是放在前面的 ↩\n[^2]:词频号，代表词出现在词频排名中的位置，比如the的词频号是1，代表它在语料库中出现频率最高，排名第一。 ↩\n[^3]:人脑记忆的物理特点：靠神经元的链接，电脑存储的特点：靠电子元件的电位固定地，精确地存储。有时候你忘了一样东西，并不是他消失了，而是它在你脑中的神经元连接路径太弱、太少，你搜索不到它。所以我们记忆有两个特点：一个是不断重复强化，加强这条路径；一个是把要记忆的东西跟很多已经在你脑海里最常用的记忆联系起来，也就是并入你的记忆主堡，那你将快速的找到它，这也是理解性记忆的根源，因为理解代表与你的已有认知不悖，也就是可以由已有定理推出要学习的定理，如果推导一个定理可以有很多方法，或者有一个非常容易想到的方法，那么这条定理顺理成章的就被你记下来了。死记硬背则是用的第一种方法，不断的重复强化，但效果不佳，原因很简单，我们的大脑天生喜欢第二种方法，这是大脑的物理结构决定的，物理基础决定上层建筑，只有把一个东西并入你的知识树，内化成自己的日常认知习惯，它就牢牢的钉在你的脑子里，成为你随时可以调取的记忆，而这也是世上不存在靠死记硬背能真正学透的原因，因为死记硬背没有使这个知识和其他东西联系起来，就像你是一个瓶子一个瓶子的装知识，其间泾渭分隔，发散性很差，那么你根本不会在很多要用的时候想起它来，也就无法学以致用。 ↩\n","slug":"学习方法总结","published":1,"updated":"2018-04-25T07:40:00.331Z","layout":"post","photos":[],"link":"","_id":"cjm2w8dcq000tfgpxxh4qbd85","content":"<p>我把自己以前的多个思考笔记综合成了这一篇，有关于学习的 方法论，怎么学英语，怎么背单词，怎么做笔记，以及自我管理</p>\n<p>你要坚信做任何事都不能蛮干，做每件事有每件事的方法，不要在错误的道路上越走越远</p>\n<p>我把学习分为三个境界：重复、理解性学习、教别人</p>\n<h2 id=\"重复重复再重复\"><a href=\"#重复重复再重复\" class=\"headerlink\" title=\"重复重复再重复\"></a>重复重复再重复</h2><p>你可能知道条件反射，即便是动物也具备的一种学习方法，马戏团天天在证明这一点，通过不断的重复（训练、奖励、惩罚），猪都会钻火圈。无论是学母语，还是学英语，基石都是重复。</p>\n<h2 id=\"构建认知网络\"><a href=\"#构建认知网络\" class=\"headerlink\" title=\"构建认知网络\"></a>构建认知网络</h2><p>人的认知是一张一直在不停编织的网络，很多知识，抽象出来的结论、认知，都是相通的（类似的），人通过联想来举一反三，并通过这种联系轻松的记忆学习。</p>\n<p>所以死记硬背是低效的，因为你试图孤立你所学的知识，而孤立的东西难以被人记起，你可以回想一下自己是不是经常忘记熟人的名字，如果熟人的名字都能忘（你是不是仅靠重复使用来记忆别人的名字，而不是通过联系其他事物呢？），忘掉知识不是很正常吗。</p>\n<p>所谓理解性学习，就是用原有的认知去解释新事物，以至于新的认知变得水到渠成，你可以从很多条路子记起这个知识，那么你就内化了这个认知，这才学到了位。</p>\n<p>构建自己的认知网络，就是理解性学习，学习来不得半点生硬，重复重复再重复，固然有用，但时间久了依然会忘记，并且很多知识都是需要灵活应用的，你要把它跟其他东西联系，而且你必须这样做，否则一个孤立的知识，你记得或者不记得没有任何区别。在已经构建好的认知上添砖加瓦，并不断试图从多个不同角度去应用它，让它指导你的其他思维和行为，这样才能慢慢内化。</p>\n<p>不要因此而有了不努力去重复的练习和学习的借口，认真在任何时候都是首要的精神</p>\n<h3 id=\"理解性学习的不可跳跃\"><a href=\"#理解性学习的不可跳跃\" class=\"headerlink\" title=\"理解性学习的不可跳跃\"></a>理解性学习的不可跳跃</h3><p>学习其实不难，你觉得难，觉得不懂，原因只有一个：如果一个结论得出来你无法理解，那就是从前提到结论这个过程你无法理解，为什么无法理解，原因也很简单：这其中暗含着一些前提，而这些暗含的前提你是不知道的，或者还没理解，这造成了一个跳跃，而学习和理解是不能跳跃的，你在这里断了链条，那么就会无法继续前进，或者云里雾里，一处不懂处处不懂。</p>\n<p>学习是有路径的，一个初学者你给他看高深的理论，中间越过很多步骤，他是根本无法学会的。你必须一步一个脚印，也只有一步一个脚印才能学的会，学的好，学的精通。很多人由于觉得难就很烦躁，产生畏难情绪，觉得累，想要放下或者放弃。其实就是因为没有找到属于你的学习路径。必须要把中间的那些暗含的前提找到弄懂，然后你就理解了，就可以继续上路。判断一个学习资料是否合适，就要看这份学习资料，对你是不是太难，太难肯定学不下去，太简单又浪费你的时间。</p>\n<h2 id=\"费曼学习法\"><a href=\"#费曼学习法\" class=\"headerlink\" title=\"费曼学习法\"></a>费曼学习法</h2><p>费曼学习法的精髓就是通过教授来强化学习，在教别人的时候你对所学的东西的理解会进一步巩固加深。</p>\n<p>其实你教别人的时候就是在解构理解的过程，也是在重复理解的过程，你讲的越是清晰明了，别人一听就懂，就证明你自己的理解过程越成功越细致，何况你自己还在重复，所以用这个方法来复习是非常棒的，效率很高。</p>\n<h2 id=\"怎么学英语\"><a href=\"#怎么学英语\" class=\"headerlink\" title=\"怎么学英语\"></a>怎么学英语</h2><p>学英语应该是很多国人的痛点，因为学了很多年都没学好，有些从小学开始学，有些从初中开始学，但直到大学本科毕业，英语还是很差。我知道这种苦楚与恐惧，也曾想学好英语，但一直没成功，我在思考这里面的原因，又加上看了一些人的见解，我总结如下：没有环境，这是根源，记忆是靠重复加强，靠关联其他记忆来内化。学习语言尤其要重复，可能因为语言是人类表达的根基，主要是靠死记硬背和疯狂输出，你总不能靠推理来学习语言。所以我们学英语的强度还远远不够，我们没有环境，如果有语言环境，那你在无形之间就已经达到一个高强度的状态，所以我们只能靠自己去打造这种高强度的环境。至少你每天都在学英语用英语吗，如果你做到了，你的英语肯定稳步提升。问题就出在这儿。当你看到英文时是不是恐惧性的跳过不看，当你看到不认识的单词你是不是没有去查，就这还想学好英语，你自己内心里都不会相信吧。这还只是初步的，你有没有刻意去输出呢，输入还算有点环境，毕竟英语的资源一不小心就接触到，但输出好像还真没机会。模仿造句应该被当做像你打游戏中的做日常任务，每造一个句子你都该记录下来，作为游戏日志，累积财富，写文章应该当做下艰难副本，每写一篇你都该奖励自己。对语言的热爱是重要的一个环节，去了解英语文化是有好处的，但另一个重要的环节是坚持，坚持属于长期控制，跟你的短期利益其实没多大关系（所以没几个人能坚持做一件事，随时可能放弃），真正能控制你做一件事的就是 及时反馈，就像很多人打游戏会上瘾，这是人的先天特征，短期利益永远重要，及时的反馈才能刺激我们的神经，坚持学英语也应该建立短期目标，提供及时反馈。这和新东方英语老师朱伟所说的：”多一些不为什么的坚持，少一些功利主义的追求“，其实是一样的，说的就是 长期目标无法让人坚持，心怀大志的去做甚至还不如莫名其妙，毫无理由的去做，有句古话很伤人，叫：“小人常立志，君子立志长”，我曾经就被这句话伤过，因为一直是一个有抱负有理想的青年，曾今有过很多远大的理想，但现在依然没什么值得说的成就，而且我经常会遇到与自己对立起来的情况，想要坚持，但又坚持不了，这其实不应该怪自己，就像你饿了要吃饭，而不是怪自己要吃饭，人应该多多发现自己的本性，而不要去对抗，在进行意志力对抗赛中我们应该常打胜仗，而不是去打必定失败的仗，比如你可以定一个小目标，跑1万米，雨中登山，这种短期的较量，只要你肯对自己下狠心，一定可以做成（而不是制定一个过于长远的计划），而且事后会极大的提升自己的自信，而人一天不是每时每刻都斗志满满，在脆弱的时候支撑你的绝不会是你的意志力，而是习惯，我们所做的所谓坚持，往往毫无胜算，而且不断地一次又一次的伤害到自己，不断的消磨意志力而不是提升，最后只会自己和自己对立起来变成一个真正的屌丝，和loser，真的是会有自暴自弃的那一天，只是你现在还年轻，但你仍然会发现岁月不曾停一刻地磨平你的棱角和骄傲，这大概是很多人经历过的吧。我们不应该用自己不多的意志力去打一场不可能赢的仗，我们应该用习惯，用及时反馈，用短期利益，和短期突进训练计划（强迫自己在一个较短的时间内做完某件困难的事，比如跑1万米，看完某个难懂的书的一章，需要查阅大量资料补全理解过程）。初时，随心所欲，以至于放荡不羁，堕落而颓废；中时，勤于律己，结果自我对立，苦不堪言；末了，依旧随心所欲，而不逾矩，如列子乘奔御风，逍遥自在，内心合一。这大概就是看山依旧是山的境界吧。我们需要的只是一个系统的及时反馈方法，和一个一个短时间的小目标（把一个大的计划分解成小目标是有道理的，人可以在短时间内强迫自己，熬一熬就过去了，相信你的意志力）。我这里并没有谈具体的技巧，想看具体技巧可以看接下来的 背单词”。</p>\n<h3 id=\"背单词\"><a href=\"#背单词\" class=\"headerlink\" title=\"背单词\"></a>背单词</h3><p>做一件事，首先要证明他是否对你有用，否则不去做（这里我想说说对于游戏的态度，大多数人生来都喜欢玩游戏，但很明显很多人玩游戏上了瘾耽误了不少事，导致生活过的很糟心，我指的是大多数大学生哦，其实你有没有想过不是你在玩游戏，而是游戏在玩你）。背单词是学习英语的一个重大话题。有人说不用去背单词，因为背了单词却不会使用这样的大有人在，应该去广泛的阅读，在文章中记住单词的意思；有人说应该去背句子，用句子串起单词，这样就知道单词的用法；也有人说在阅读中增长词汇量太费时间，背单词是增长词汇量的捷径。<br>我发表一下我自己总结出来的一套看法：</p>\n<ol>\n<li>做任何事都要有正确的方法才能事半功倍，英语学习也是一样，我们可以科学地把学习语言分为：输入和输出，听、读是输入，说、写是输出，输出是输入的巩固和保障，没有输出，英语很难学好，事倍功半。这就是为什么我们大多数中国人总是学不好英语的原因，没有输出环境，输入环境倒是还可以。解决办法就是补上这个输出环节，方法无非是：强迫自己写作，学习地道的写作，地道的英语表达，强迫自己去说，学习地道的口语。</li>\n<li>做事情慢比做错好，背单词首先要保证至少背的是正确的意思（无论是中文还是英文释义），在这个对的基础上，背了总比没背要好。</li>\n<li>其次关于对背了单词却不会使用的问题，背单词属于输入，使用单词属于输出，你只是背单词当然不一定会使用，使用还得靠说，靠写。而架起输入和输出的桥梁就是模仿，再粗陋一点就是背诵然后一字不改的输出来。多背好句子，长句也好，短句也好，当然这个句子必须有亮点，要不然你自己都能写出来，就没有意义，比如全世界人都会说：I love you.[^1]要明白自己的起点，少做一些无用功。然后就是模仿造句，就像小时候学习中文的时候的造句练习。写短文，然后同样是模仿练习。这里说的背诵并不是要求你过多久都还记得背了什么，而是作为一个模仿对象，帮助自己正确的输出自己想要表达的东西，请问你小时候背过的文章你还记得几篇？关键不在于记忆故事、内容，而在于内化英文表达，形成语感。所以这里的背诵也可以理解为熟读，模仿。</li>\n<li>我最想说的一点就是，我们很多人的词汇其实也不算低，但说英语根本没词，没话可说，或者说出来一堆的中式英语表达。原因在于，一门语言背后往往承载着一个相应的文化，就像我们中国不同地方的方言的表达也是不一样的。普通话说：行，河南话说：中。中西方文化差异造成了，即便你认识很多单词，知道很多语法，你依然不知道怎么去描述一件事，表达一种意思。因为别人文化里的表达方式和你的不一样。我们说：毫无睡意，英文表示则是：wide awake。请问这个表达是你直接能想到的吗，我们大多数人可能喜欢从字面上，一字一字翻译，这完全是错的，真正的翻译应该是一个意思对应一个意思的翻译，假如英文中有个意思中文里没有怎么办，这就是极考验翻译水平的地方，你要用简单易懂的方式解释，甚至可以创造一个舶来词。记单词并不是全部，背表达方式才能真正的学会一门语言。</li>\n<li>既然背单词是可以有的，那么背单词该怎么背，我推荐用词频[^2]，按照语言掌握的一般规律，先背最常见的，再背次常见的，以此类推。一般柯林斯的词频就行了，网上也是很容易找到，柯林斯选出了1万多的词，把这些词总共分了5类，用五角星标记，五颗星的是最常见的，比如词频排名第一的the，就在这里面，依此类推，一颗星的是词频最低的，当然还有不带星的，那种单词就更少用到了，所以也不用急着去背。按词频背单词可以让你精确定位常用单词，避免学了一堆不常用的，这种安排其实也发生在我们学英语的整个过程，比如小学单词比初中单词常见，初中的又比高中的常见，高考的又比大学四六级的常见，大学四六级的又比考研、托福、雅思、GRE新增的词汇常见。按词频背单词还有一个好处就是可以查漏补缺，你可以清楚的知道自己哪些单词还稍微陌生，还有哪些重要的单词还完全不认识，这是靠阅读学单词花费大量时间也无法办到的。这叫针对性。当然阅读中学单词是有用的，一般来说我们可以在阅读中巩固对单词的记忆，用法等等，用起来的单词更容易记住，因为“用”这个词，代表你在反复强化你脑中的那些相应的神经元路径[^3]，而且增添更多的应用场景（新的神经元路径），让你记得更牢，更生动。</li>\n</ol>\n<h2 id=\"结合互联网的现代化笔记法\"><a href=\"#结合互联网的现代化笔记法\" class=\"headerlink\" title=\"结合互联网的现代化笔记法\"></a>结合互联网的现代化笔记法</h2><p>今天对于记笔记又有了点新想法，结合以前的，总结如下：</p>\n<ol>\n<li>所有笔记都不可靠，最终要记在脑子里，内化成自己可以随时调用的资料，和意识。笔记只是为了便于复习回顾，没有内化它就不是你的，只是一团外在的信息，对你来说也就跟没有一样，你还是你，当笔记是身外之物的时候它是不可靠的，只有当知识、技巧和思维方法内化进你大脑的神经回路里，它才真正成为你身体的一部分，是自我意识的一部分，你也因此变得更加强大起来，然而很多人学的知识是死的，不能用于帮助自己解释和理解这个世界，和身边发生的各种事，那你学这些东西又有什么意义呢，你面对这个纷繁复杂的现象宇宙，鸟还是鸟，花草树木还是花草树木，月亮还是月亮，感性统治着你，所有知识和理性全都被封锁起来，你看不透这个世界，也没有借助自己所学去帮助自己看透这个世界，于是你忘了你学的东西。自始至终都没有用到它们，忘掉是很自然的。但其实它们就在你身边，无时无刻不在，只是你没发现它们，没有有意识地去看见它们。这样的学习学一辈子都是竹篮打水（漏的跟打的一样多），到头来一场空，白白虚耗了时光。少年，想获得力量吗，那就去做个有心人吧，把知识用起来，让它成为你大脑的一部分。</li>\n<li>笔记一定要电子化，书籍也电子化，因为电子化便于携带，传输，查阅，搜索，检索。就算先写在纸上，但之后也要拍照整理成电子的（并附加上关键词，摘要），数据不应该流失，遇到半熟的知识，第一反应查笔记，第二反应上互联网搜，并把学到的用自己的语言记在笔记里。</li>\n<li>善于找别人记下的笔记和总结，同时利用起像百度百科和维基百科和各种人的博客等等东西，前两者比较稳定，所以可以贴链接即可，后者不稳定一定要截图，或者复制粘贴。这样做是尽量保证笔记的持久性，其实这么久的持久性也没啥用，因为你势必要在相对较短的时间内消化知识，你不消化它就会淡忘，你不用起来它就相当于没有，你也就白学了。比如我一直想整理出一份完整的系统的数学笔记，但我其实没有必要一笔一笔写下这个笔记，而且我也没有这个时间去干这件事，而且说到底笔记只是用来协助内化记忆，本身就只是一个附带性工作（当然也不能潦草敷衍，否则难起到应有的作用），何必如此执着，真正要下功夫做的是记忆，运用（做题，解题中应用知识），并结合生活这本无字大书。别人的笔记不完整，这不要紧，你自己立好框架，然后以添加URL链接的方式把这些内容接入你的框架。比如今天我找柯西中值定理的证明，我忘了怎么推导这个定理，我去谷歌搜索了，维基百科里有完整的证明，我只需在笔记中柯西中值定理证明这一处添加一个链接，或做个注释。如上所说，我只添了：证明，维基百科，这么几个字，这是因为只要在有互联网和手机的时候我就可以立即查阅，互联网是一个非常便利的云端，增强了每一个现代人的移动性（这一重要属性在罗辑思维里，吴伯凡总结过，生物的一个基本属性就是移动性，越高等的生物移动属性越高），这就是结合网络的笔记法，整个网络都是你的笔记，你只需要做个标记就可迅速找到。</li>\n<li>由此便可得出 只列框架和名词的高度精简笔记（甚至框架也可以在互联网上找到合适的，但每个人都有自己的知识树，另外框架是个索引性的东西，你自己必须非常熟悉，如果索引都依赖于外部，你自己还剩下些什么呢，特别是重要的索引，一定得是非常熟悉的）：</li>\n</ol>\n<ul>\n<li>概念</li>\n<li>应用场景</li>\n<li>发现背景</li>\n<li>证明推导过程</li>\n<li>习题<br>等等都以树状链接开来，有本地的拓展也有互联网的拓展部分。</li>\n</ul>\n<ol start=\"5\">\n<li>由于互联网上的许多内容不一定正确（甚至有的时候会误导你），不一定完整，而书籍和传统出版物相对来说靠谱，所以做笔记时强烈建议考虑内容的质量。</li>\n</ol>\n<p>[^1]:英语和汉语的共同点就是主谓宾的顺序是一致的，不同点在于修饰，英语的修饰习惯后置，汉语的修饰从不后置，一定是放在前面的 ↩<br>[^2]:词频号，代表词出现在词频排名中的位置，比如the的词频号是1，代表它在语料库中出现频率最高，排名第一。 ↩<br>[^3]:人脑记忆的物理特点：靠神经元的链接，电脑存储的特点：靠电子元件的电位固定地，精确地存储。有时候你忘了一样东西，并不是他消失了，而是它在你脑中的神经元连接路径太弱、太少，你搜索不到它。所以我们记忆有两个特点：一个是不断重复强化，加强这条路径；一个是把要记忆的东西跟很多已经在你脑海里最常用的记忆联系起来，也就是并入你的记忆主堡，那你将快速的找到它，这也是理解性记忆的根源，因为理解代表与你的已有认知不悖，也就是可以由已有定理推出要学习的定理，如果推导一个定理可以有很多方法，或者有一个非常容易想到的方法，那么这条定理顺理成章的就被你记下来了。死记硬背则是用的第一种方法，不断的重复强化，但效果不佳，原因很简单，我们的大脑天生喜欢第二种方法，这是大脑的物理结构决定的，物理基础决定上层建筑，只有把一个东西并入你的知识树，内化成自己的日常认知习惯，它就牢牢的钉在你的脑子里，成为你随时可以调取的记忆，而这也是世上不存在靠死记硬背能真正学透的原因，因为死记硬背没有使这个知识和其他东西联系起来，就像你是一个瓶子一个瓶子的装知识，其间泾渭分隔，发散性很差，那么你根本不会在很多要用的时候想起它来，也就无法学以致用。 ↩</p>\n","site":{"data":{}},"excerpt":"","more":"<p>我把自己以前的多个思考笔记综合成了这一篇，有关于学习的 方法论，怎么学英语，怎么背单词，怎么做笔记，以及自我管理</p>\n<p>你要坚信做任何事都不能蛮干，做每件事有每件事的方法，不要在错误的道路上越走越远</p>\n<p>我把学习分为三个境界：重复、理解性学习、教别人</p>\n<h2 id=\"重复重复再重复\"><a href=\"#重复重复再重复\" class=\"headerlink\" title=\"重复重复再重复\"></a>重复重复再重复</h2><p>你可能知道条件反射，即便是动物也具备的一种学习方法，马戏团天天在证明这一点，通过不断的重复（训练、奖励、惩罚），猪都会钻火圈。无论是学母语，还是学英语，基石都是重复。</p>\n<h2 id=\"构建认知网络\"><a href=\"#构建认知网络\" class=\"headerlink\" title=\"构建认知网络\"></a>构建认知网络</h2><p>人的认知是一张一直在不停编织的网络，很多知识，抽象出来的结论、认知，都是相通的（类似的），人通过联想来举一反三，并通过这种联系轻松的记忆学习。</p>\n<p>所以死记硬背是低效的，因为你试图孤立你所学的知识，而孤立的东西难以被人记起，你可以回想一下自己是不是经常忘记熟人的名字，如果熟人的名字都能忘（你是不是仅靠重复使用来记忆别人的名字，而不是通过联系其他事物呢？），忘掉知识不是很正常吗。</p>\n<p>所谓理解性学习，就是用原有的认知去解释新事物，以至于新的认知变得水到渠成，你可以从很多条路子记起这个知识，那么你就内化了这个认知，这才学到了位。</p>\n<p>构建自己的认知网络，就是理解性学习，学习来不得半点生硬，重复重复再重复，固然有用，但时间久了依然会忘记，并且很多知识都是需要灵活应用的，你要把它跟其他东西联系，而且你必须这样做，否则一个孤立的知识，你记得或者不记得没有任何区别。在已经构建好的认知上添砖加瓦，并不断试图从多个不同角度去应用它，让它指导你的其他思维和行为，这样才能慢慢内化。</p>\n<p>不要因此而有了不努力去重复的练习和学习的借口，认真在任何时候都是首要的精神</p>\n<h3 id=\"理解性学习的不可跳跃\"><a href=\"#理解性学习的不可跳跃\" class=\"headerlink\" title=\"理解性学习的不可跳跃\"></a>理解性学习的不可跳跃</h3><p>学习其实不难，你觉得难，觉得不懂，原因只有一个：如果一个结论得出来你无法理解，那就是从前提到结论这个过程你无法理解，为什么无法理解，原因也很简单：这其中暗含着一些前提，而这些暗含的前提你是不知道的，或者还没理解，这造成了一个跳跃，而学习和理解是不能跳跃的，你在这里断了链条，那么就会无法继续前进，或者云里雾里，一处不懂处处不懂。</p>\n<p>学习是有路径的，一个初学者你给他看高深的理论，中间越过很多步骤，他是根本无法学会的。你必须一步一个脚印，也只有一步一个脚印才能学的会，学的好，学的精通。很多人由于觉得难就很烦躁，产生畏难情绪，觉得累，想要放下或者放弃。其实就是因为没有找到属于你的学习路径。必须要把中间的那些暗含的前提找到弄懂，然后你就理解了，就可以继续上路。判断一个学习资料是否合适，就要看这份学习资料，对你是不是太难，太难肯定学不下去，太简单又浪费你的时间。</p>\n<h2 id=\"费曼学习法\"><a href=\"#费曼学习法\" class=\"headerlink\" title=\"费曼学习法\"></a>费曼学习法</h2><p>费曼学习法的精髓就是通过教授来强化学习，在教别人的时候你对所学的东西的理解会进一步巩固加深。</p>\n<p>其实你教别人的时候就是在解构理解的过程，也是在重复理解的过程，你讲的越是清晰明了，别人一听就懂，就证明你自己的理解过程越成功越细致，何况你自己还在重复，所以用这个方法来复习是非常棒的，效率很高。</p>\n<h2 id=\"怎么学英语\"><a href=\"#怎么学英语\" class=\"headerlink\" title=\"怎么学英语\"></a>怎么学英语</h2><p>学英语应该是很多国人的痛点，因为学了很多年都没学好，有些从小学开始学，有些从初中开始学，但直到大学本科毕业，英语还是很差。我知道这种苦楚与恐惧，也曾想学好英语，但一直没成功，我在思考这里面的原因，又加上看了一些人的见解，我总结如下：没有环境，这是根源，记忆是靠重复加强，靠关联其他记忆来内化。学习语言尤其要重复，可能因为语言是人类表达的根基，主要是靠死记硬背和疯狂输出，你总不能靠推理来学习语言。所以我们学英语的强度还远远不够，我们没有环境，如果有语言环境，那你在无形之间就已经达到一个高强度的状态，所以我们只能靠自己去打造这种高强度的环境。至少你每天都在学英语用英语吗，如果你做到了，你的英语肯定稳步提升。问题就出在这儿。当你看到英文时是不是恐惧性的跳过不看，当你看到不认识的单词你是不是没有去查，就这还想学好英语，你自己内心里都不会相信吧。这还只是初步的，你有没有刻意去输出呢，输入还算有点环境，毕竟英语的资源一不小心就接触到，但输出好像还真没机会。模仿造句应该被当做像你打游戏中的做日常任务，每造一个句子你都该记录下来，作为游戏日志，累积财富，写文章应该当做下艰难副本，每写一篇你都该奖励自己。对语言的热爱是重要的一个环节，去了解英语文化是有好处的，但另一个重要的环节是坚持，坚持属于长期控制，跟你的短期利益其实没多大关系（所以没几个人能坚持做一件事，随时可能放弃），真正能控制你做一件事的就是 及时反馈，就像很多人打游戏会上瘾，这是人的先天特征，短期利益永远重要，及时的反馈才能刺激我们的神经，坚持学英语也应该建立短期目标，提供及时反馈。这和新东方英语老师朱伟所说的：”多一些不为什么的坚持，少一些功利主义的追求“，其实是一样的，说的就是 长期目标无法让人坚持，心怀大志的去做甚至还不如莫名其妙，毫无理由的去做，有句古话很伤人，叫：“小人常立志，君子立志长”，我曾经就被这句话伤过，因为一直是一个有抱负有理想的青年，曾今有过很多远大的理想，但现在依然没什么值得说的成就，而且我经常会遇到与自己对立起来的情况，想要坚持，但又坚持不了，这其实不应该怪自己，就像你饿了要吃饭，而不是怪自己要吃饭，人应该多多发现自己的本性，而不要去对抗，在进行意志力对抗赛中我们应该常打胜仗，而不是去打必定失败的仗，比如你可以定一个小目标，跑1万米，雨中登山，这种短期的较量，只要你肯对自己下狠心，一定可以做成（而不是制定一个过于长远的计划），而且事后会极大的提升自己的自信，而人一天不是每时每刻都斗志满满，在脆弱的时候支撑你的绝不会是你的意志力，而是习惯，我们所做的所谓坚持，往往毫无胜算，而且不断地一次又一次的伤害到自己，不断的消磨意志力而不是提升，最后只会自己和自己对立起来变成一个真正的屌丝，和loser，真的是会有自暴自弃的那一天，只是你现在还年轻，但你仍然会发现岁月不曾停一刻地磨平你的棱角和骄傲，这大概是很多人经历过的吧。我们不应该用自己不多的意志力去打一场不可能赢的仗，我们应该用习惯，用及时反馈，用短期利益，和短期突进训练计划（强迫自己在一个较短的时间内做完某件困难的事，比如跑1万米，看完某个难懂的书的一章，需要查阅大量资料补全理解过程）。初时，随心所欲，以至于放荡不羁，堕落而颓废；中时，勤于律己，结果自我对立，苦不堪言；末了，依旧随心所欲，而不逾矩，如列子乘奔御风，逍遥自在，内心合一。这大概就是看山依旧是山的境界吧。我们需要的只是一个系统的及时反馈方法，和一个一个短时间的小目标（把一个大的计划分解成小目标是有道理的，人可以在短时间内强迫自己，熬一熬就过去了，相信你的意志力）。我这里并没有谈具体的技巧，想看具体技巧可以看接下来的 背单词”。</p>\n<h3 id=\"背单词\"><a href=\"#背单词\" class=\"headerlink\" title=\"背单词\"></a>背单词</h3><p>做一件事，首先要证明他是否对你有用，否则不去做（这里我想说说对于游戏的态度，大多数人生来都喜欢玩游戏，但很明显很多人玩游戏上了瘾耽误了不少事，导致生活过的很糟心，我指的是大多数大学生哦，其实你有没有想过不是你在玩游戏，而是游戏在玩你）。背单词是学习英语的一个重大话题。有人说不用去背单词，因为背了单词却不会使用这样的大有人在，应该去广泛的阅读，在文章中记住单词的意思；有人说应该去背句子，用句子串起单词，这样就知道单词的用法；也有人说在阅读中增长词汇量太费时间，背单词是增长词汇量的捷径。<br>我发表一下我自己总结出来的一套看法：</p>\n<ol>\n<li>做任何事都要有正确的方法才能事半功倍，英语学习也是一样，我们可以科学地把学习语言分为：输入和输出，听、读是输入，说、写是输出，输出是输入的巩固和保障，没有输出，英语很难学好，事倍功半。这就是为什么我们大多数中国人总是学不好英语的原因，没有输出环境，输入环境倒是还可以。解决办法就是补上这个输出环节，方法无非是：强迫自己写作，学习地道的写作，地道的英语表达，强迫自己去说，学习地道的口语。</li>\n<li>做事情慢比做错好，背单词首先要保证至少背的是正确的意思（无论是中文还是英文释义），在这个对的基础上，背了总比没背要好。</li>\n<li>其次关于对背了单词却不会使用的问题，背单词属于输入，使用单词属于输出，你只是背单词当然不一定会使用，使用还得靠说，靠写。而架起输入和输出的桥梁就是模仿，再粗陋一点就是背诵然后一字不改的输出来。多背好句子，长句也好，短句也好，当然这个句子必须有亮点，要不然你自己都能写出来，就没有意义，比如全世界人都会说：I love you.[^1]要明白自己的起点，少做一些无用功。然后就是模仿造句，就像小时候学习中文的时候的造句练习。写短文，然后同样是模仿练习。这里说的背诵并不是要求你过多久都还记得背了什么，而是作为一个模仿对象，帮助自己正确的输出自己想要表达的东西，请问你小时候背过的文章你还记得几篇？关键不在于记忆故事、内容，而在于内化英文表达，形成语感。所以这里的背诵也可以理解为熟读，模仿。</li>\n<li>我最想说的一点就是，我们很多人的词汇其实也不算低，但说英语根本没词，没话可说，或者说出来一堆的中式英语表达。原因在于，一门语言背后往往承载着一个相应的文化，就像我们中国不同地方的方言的表达也是不一样的。普通话说：行，河南话说：中。中西方文化差异造成了，即便你认识很多单词，知道很多语法，你依然不知道怎么去描述一件事，表达一种意思。因为别人文化里的表达方式和你的不一样。我们说：毫无睡意，英文表示则是：wide awake。请问这个表达是你直接能想到的吗，我们大多数人可能喜欢从字面上，一字一字翻译，这完全是错的，真正的翻译应该是一个意思对应一个意思的翻译，假如英文中有个意思中文里没有怎么办，这就是极考验翻译水平的地方，你要用简单易懂的方式解释，甚至可以创造一个舶来词。记单词并不是全部，背表达方式才能真正的学会一门语言。</li>\n<li>既然背单词是可以有的，那么背单词该怎么背，我推荐用词频[^2]，按照语言掌握的一般规律，先背最常见的，再背次常见的，以此类推。一般柯林斯的词频就行了，网上也是很容易找到，柯林斯选出了1万多的词，把这些词总共分了5类，用五角星标记，五颗星的是最常见的，比如词频排名第一的the，就在这里面，依此类推，一颗星的是词频最低的，当然还有不带星的，那种单词就更少用到了，所以也不用急着去背。按词频背单词可以让你精确定位常用单词，避免学了一堆不常用的，这种安排其实也发生在我们学英语的整个过程，比如小学单词比初中单词常见，初中的又比高中的常见，高考的又比大学四六级的常见，大学四六级的又比考研、托福、雅思、GRE新增的词汇常见。按词频背单词还有一个好处就是可以查漏补缺，你可以清楚的知道自己哪些单词还稍微陌生，还有哪些重要的单词还完全不认识，这是靠阅读学单词花费大量时间也无法办到的。这叫针对性。当然阅读中学单词是有用的，一般来说我们可以在阅读中巩固对单词的记忆，用法等等，用起来的单词更容易记住，因为“用”这个词，代表你在反复强化你脑中的那些相应的神经元路径[^3]，而且增添更多的应用场景（新的神经元路径），让你记得更牢，更生动。</li>\n</ol>\n<h2 id=\"结合互联网的现代化笔记法\"><a href=\"#结合互联网的现代化笔记法\" class=\"headerlink\" title=\"结合互联网的现代化笔记法\"></a>结合互联网的现代化笔记法</h2><p>今天对于记笔记又有了点新想法，结合以前的，总结如下：</p>\n<ol>\n<li>所有笔记都不可靠，最终要记在脑子里，内化成自己可以随时调用的资料，和意识。笔记只是为了便于复习回顾，没有内化它就不是你的，只是一团外在的信息，对你来说也就跟没有一样，你还是你，当笔记是身外之物的时候它是不可靠的，只有当知识、技巧和思维方法内化进你大脑的神经回路里，它才真正成为你身体的一部分，是自我意识的一部分，你也因此变得更加强大起来，然而很多人学的知识是死的，不能用于帮助自己解释和理解这个世界，和身边发生的各种事，那你学这些东西又有什么意义呢，你面对这个纷繁复杂的现象宇宙，鸟还是鸟，花草树木还是花草树木，月亮还是月亮，感性统治着你，所有知识和理性全都被封锁起来，你看不透这个世界，也没有借助自己所学去帮助自己看透这个世界，于是你忘了你学的东西。自始至终都没有用到它们，忘掉是很自然的。但其实它们就在你身边，无时无刻不在，只是你没发现它们，没有有意识地去看见它们。这样的学习学一辈子都是竹篮打水（漏的跟打的一样多），到头来一场空，白白虚耗了时光。少年，想获得力量吗，那就去做个有心人吧，把知识用起来，让它成为你大脑的一部分。</li>\n<li>笔记一定要电子化，书籍也电子化，因为电子化便于携带，传输，查阅，搜索，检索。就算先写在纸上，但之后也要拍照整理成电子的（并附加上关键词，摘要），数据不应该流失，遇到半熟的知识，第一反应查笔记，第二反应上互联网搜，并把学到的用自己的语言记在笔记里。</li>\n<li>善于找别人记下的笔记和总结，同时利用起像百度百科和维基百科和各种人的博客等等东西，前两者比较稳定，所以可以贴链接即可，后者不稳定一定要截图，或者复制粘贴。这样做是尽量保证笔记的持久性，其实这么久的持久性也没啥用，因为你势必要在相对较短的时间内消化知识，你不消化它就会淡忘，你不用起来它就相当于没有，你也就白学了。比如我一直想整理出一份完整的系统的数学笔记，但我其实没有必要一笔一笔写下这个笔记，而且我也没有这个时间去干这件事，而且说到底笔记只是用来协助内化记忆，本身就只是一个附带性工作（当然也不能潦草敷衍，否则难起到应有的作用），何必如此执着，真正要下功夫做的是记忆，运用（做题，解题中应用知识），并结合生活这本无字大书。别人的笔记不完整，这不要紧，你自己立好框架，然后以添加URL链接的方式把这些内容接入你的框架。比如今天我找柯西中值定理的证明，我忘了怎么推导这个定理，我去谷歌搜索了，维基百科里有完整的证明，我只需在笔记中柯西中值定理证明这一处添加一个链接，或做个注释。如上所说，我只添了：证明，维基百科，这么几个字，这是因为只要在有互联网和手机的时候我就可以立即查阅，互联网是一个非常便利的云端，增强了每一个现代人的移动性（这一重要属性在罗辑思维里，吴伯凡总结过，生物的一个基本属性就是移动性，越高等的生物移动属性越高），这就是结合网络的笔记法，整个网络都是你的笔记，你只需要做个标记就可迅速找到。</li>\n<li>由此便可得出 只列框架和名词的高度精简笔记（甚至框架也可以在互联网上找到合适的，但每个人都有自己的知识树，另外框架是个索引性的东西，你自己必须非常熟悉，如果索引都依赖于外部，你自己还剩下些什么呢，特别是重要的索引，一定得是非常熟悉的）：</li>\n</ol>\n<ul>\n<li>概念</li>\n<li>应用场景</li>\n<li>发现背景</li>\n<li>证明推导过程</li>\n<li>习题<br>等等都以树状链接开来，有本地的拓展也有互联网的拓展部分。</li>\n</ul>\n<ol start=\"5\">\n<li>由于互联网上的许多内容不一定正确（甚至有的时候会误导你），不一定完整，而书籍和传统出版物相对来说靠谱，所以做笔记时强烈建议考虑内容的质量。</li>\n</ol>\n<p>[^1]:英语和汉语的共同点就是主谓宾的顺序是一致的，不同点在于修饰，英语的修饰习惯后置，汉语的修饰从不后置，一定是放在前面的 ↩<br>[^2]:词频号，代表词出现在词频排名中的位置，比如the的词频号是1，代表它在语料库中出现频率最高，排名第一。 ↩<br>[^3]:人脑记忆的物理特点：靠神经元的链接，电脑存储的特点：靠电子元件的电位固定地，精确地存储。有时候你忘了一样东西，并不是他消失了，而是它在你脑中的神经元连接路径太弱、太少，你搜索不到它。所以我们记忆有两个特点：一个是不断重复强化，加强这条路径；一个是把要记忆的东西跟很多已经在你脑海里最常用的记忆联系起来，也就是并入你的记忆主堡，那你将快速的找到它，这也是理解性记忆的根源，因为理解代表与你的已有认知不悖，也就是可以由已有定理推出要学习的定理，如果推导一个定理可以有很多方法，或者有一个非常容易想到的方法，那么这条定理顺理成章的就被你记下来了。死记硬背则是用的第一种方法，不断的重复强化，但效果不佳，原因很简单，我们的大脑天生喜欢第二种方法，这是大脑的物理结构决定的，物理基础决定上层建筑，只有把一个东西并入你的知识树，内化成自己的日常认知习惯，它就牢牢的钉在你的脑子里，成为你随时可以调取的记忆，而这也是世上不存在靠死记硬背能真正学透的原因，因为死记硬背没有使这个知识和其他东西联系起来，就像你是一个瓶子一个瓶子的装知识，其间泾渭分隔，发散性很差，那么你根本不会在很多要用的时候想起它来，也就无法学以致用。 ↩</p>\n"},{"title":"从 windows 转用 mac OS X 记录","date":"2016-12-31T16:00:00.000Z","comments":1,"_content":"\n这篇文章我想讲讲我从用 Windows 到用 mac OS X 的过程中遇到的困难和解决方法。\n\n由于我本人是学计算机的，电脑用的多，喜欢用一些设计的好的快捷键，所以我分为两部分吧，第一部分讲给普通用户，第二部分讲给程序员。\n\n先告诉你们一个通用小技巧，众所周知，flash视频非常让电脑发热，而看HTML5视频则一点都不热。safari有个伪装成iPad或者iPhone的功能，可以把视频强制用HTML5播放。你的MacBook就再也不会在看视频的时候发烫了。\n\n![safari强制使用HTML5播放视频](https://wx4.sinaimg.cn/mw690/006zFO3ggy1fcd4d2uzibj31kw0zkdug.jpg)\n\n时至今日（2017.9.9），很多网站都可以使用 HTML5播放视频了，如：bilibili，中国大学MOOC，使用 HTML5播放视频是未来的方向。\n\n## 普通用户使用mac指南\n\n### 浏览器\n\n找不到浏览器吗？点击像指南针图标的那个safari，那个应用就是浏览器。\n\n### 输入法\n\n和初次使用Linux一样，一上来我们肯定就要碰到输入法的难题，mac切换输入法的快捷键是command+space（空格），一般的系统或者软件都是支持自定义快捷键的，你可以修改快捷键。对于用惯了搜狗输入法的同学，这里我推荐使用搜狗输入法，它可以记住用户习惯。\n\n![mac输入法截图](https://wx4.sinaimg.cn/mw690/006zFO3ggy1fcceny2wsuj31kw0zkdku.jpg)\n\n搜狗默认的通用中英文切换键是 shift。\n\n### 触摸板\n\nmac的触摸板应该是所有笔记本电脑触摸板的宗师吧，而且也是最好用的触摸板。我用mac的时候，除了玩游戏，完全用不着鼠标。\n\n没有鼠标，那么左右键怎么办？很简单：一指单击触摸板，就是左键，两指单击触摸板，就是右键。记得将轻触触摸板设置为点击，这样可以延长触摸板的寿命，而且点起来也舒服多了。\n\n五指合拢，你可以看到你电脑上安装好的应用，这个界面叫做：launchpad。\n\n![launchpad截图](https://wx2.sinaimg.cn/mw690/006zFO3ggy1fccexd55wpj31kw0zktgg.jpg)\n\n五指弹开，如果你处在launchpad界面，五指弹开就会回到原先五指合拢之前的那个界面，回到这个界面之后，再用一次五指弹开，就是弹开所有应用，让你看到桌面（如果你当前窗口是全屏模式，则此法失效）。\n\n![弹开应用看到桌面](https://wx3.sinaimg.cn/mw690/006zFO3ggy1fccf5tp4rpj31kw0zkjwj.jpg)\n\n三指上推，可以看到所有打开的窗口的缩略图。\n\n![窗口缩略图](https://wx4.sinaimg.cn/mw690/006zFO3ggy1fccf0mfcanj31kw0zkqcm.jpg)\n\n三指横扫，可以在全屏之间切换，这是我最喜欢的设计之一。\n\n### 安装应用\n\n去官网下好应用，通常是.dmg后缀的安装包，打开，拖拽到Applications文件夹就完成了安装，比Windows爽多了吧。\n\n### 文件管理器Finder\n\n调整默认Finder窗口大小，可以按住option，然后进行拖动，窗口的大小就可以保留下来了。\n\ncommand+shift+.可以显示隐藏文件，关闭显示隐藏文件也是这个快捷键。\n\n右键之后，没有新建文件选项。\n\n你只能先打开应用，然后在应用中新建文件。\n\n记住在Windows上用的很爽的ctrl+a、ctrl+s、ctrl+c、ctrl+v、ctrl+f等等，在mac上统统把ctrl换成command就OK了。\n\ncommand+x不能剪切文件和文件夹是吧。\n\n解决办法是：先command+c，然后command+option+v，成功的完成文件的剪切和粘贴。\n\n普通用户的指南到此结束，如果有什么问题，请私信我的知乎，我博客头像下面有个知乎的知的图标，点击就能到我的知乎个人主页。\n\n## 程序员mac指南\n\n先上几个零碎的小技巧：\n\n触摸板双指双击，放大（我觉得其实没啥卵用）\n\n在应用窗口顶栏双击，缩放窗口（这个Windows也有的）\n\n### 文件管理器Finder\n\n首先讲Finder，这是mac 系统，也就是OS X系统的文件管理器，和windows的文件管理器对比有点不同，最不方便的地方在于点击右键没有新建文件选项，如果你会Linux，可以用命令touch 文件名来新建文件，如果你不会命令，可以先打开文本编辑器，再新建文本文件，它的设计哲学是，你要新建什么文件，就先打开与这个文件相关的软件，再在这个软件里新建这个类型的文件，不过不方便就是不方便。再讲讲优秀的地方，Finder可以打开多级目录。\n\n![Finder多级目录](https://ww4.sinaimg.cn/mw690/005DrjN1gw1fbgxqax4waj316s0o8n0e.jpg)\n\n另外可以 按空格键预览，这个预览功能现在 Windows 也有了。\n\nFinder还有tag系统，你可以通过tag来访问属于同一个tag的文件\n\n![Finder的tag功能](https://ww3.sinaimg.cn/mw690/005DrjN1gw1fbgxwxxpobj316s0o8ad8.jpg)\n\n### 快捷键\n\n>快捷键肯定是最重要的啦！\n\n然后讲讲快捷键设计，我在windows下已经有了些使用快捷键的习惯，比如：\n\nwin+E是打开文件管理器\n\nwin+D是显示桌面（也就是将所有窗口最小化）\n\nwin+L锁屏\n\nctrl+S保存\n\nctrl+A全选\n\nctrl+C复制\n\nctrl+X剪切\n\nctrl+V粘贴\n\nctrl+F查找\n\n当我来到OS X下的时候，我同样先摸索了一番快捷键。设计快捷键的哲学就是通用，这样就可以节省记忆成本，mac上的cmd基本上承担了windows上ctrl的职能，常用的快捷键有：\n\ncmd+S保存\n\ncmd+A全选\n\ncmd+C复制\n\ncmd+X剪切\n\ncmd+V粘贴\n\ncmd+F查找\n\ncmd+D制作副本\n\n按住option+command，拖动文件，可以产生快捷方式，也就是链接。\n\ncmd+, 打开preferance也就是打开设置界面，这个快捷键简直不要太爽，希望 Windows 上也弄一个\n\ncmd+N 打开新窗口\n\ncmd+W 关闭窗口\n\ncmd+H 隐藏窗口\n\ncmd+Q 退出程序\n\ncmd+ctrl+F 全屏和退出全屏，播放视频时候退出全屏一般是 ESC 键\n\ncmd+Tab切换程序\n\n你用了Finder之后可能会恼火没有剪切文件的功能，但其实是有的，只是快捷键不一样，剪切文件的快捷键是，先cmd+C复制，然后cmd+option+V粘贴。\n\n这是我常用的几个快捷键。总之快捷键不用记很多，按你自己的需要，记住常用的就行。\n\nCommand+Option+D 控制Dock的显示与隐藏，我还是喜欢留着 Dock。\n\nCommand+Option+H 隐藏所有其他窗口\n\nShift+音量 会有声音，直接按音量默认是不出声\n\nCommand+I 显示简介（在Finder中），然后就 可以修改打开一个文件的默认APP\n\nCommand+Control+N 新建一个文件夹，并归类你选中的所有文件\n\n#### 编辑文本的快捷键\n\nCommand+Space 切换输入法\n\nCommand+left 让光标跳到最前面，相当于windows下的home键\n\nCommand+right 让光标跳到最后，相当于windows下的end键\n\nCommand+up 让光标跳到整个文本的最开头\n\nCommand+down 让光标跳到整个文本的最后\n\nCommand+delete 删除当前行，相当于windows下的home，shift+end（选中，从行头到行尾），backspace，这三个操作的组合。这个快捷键会让你相当爽的。\n\n#### 截图快捷键\n\nCommand+Shift+3 截取整个桌面，并把截图作为一个文件存储在桌面上\n\nCommand+Shift+4 截取一个区域，并把截图作为一个文件存储在桌面上\n\nCommand+Shift+Ctrl+3 截取整个桌面，并复制到剪切板\n\nCommand+Shift+Ctrl+4 截取一个区域，并复制到剪切板\n\nCommand+Shift+4 然后按Space就会截取一个窗口。这样截图会自带阴影效果。如果不想自带阴影效果，可以按住option再点触摸板。\n\nCommand+Ctrl+A mac QQ 截图快捷键，由于屏幕分辨率太高，mac系统快捷键截出来的图都太大了，而macQQ截出来的图大小正合适。\n\n#### Chrome浏览器快捷键\n\n这个应该是与操作系统无关的（有些快捷键还是不一样的），但在Mac下养成了用快捷键的习惯，所以Chrome的快捷键都是在Mac上学的，在windows下注意用Ctrl替换Command键就行了。\n\nCommand+R 刷新\n\nCommand+L 将窗口焦点锁定到浏览器的地址栏，不用移动鼠标哦\n\nCommand+T 打开一个新Tab\n\nCommand+Shift+T 打开一个之前被关闭的Tab\n\nCommand+Shift+J 打开下载页面\n\nCommand+Shift+C 打开“检查(spectator)”，鼠标右键可以看到这个选项，一般是程序员使用的高级功能，但不能再次使用快捷键关闭。\n\nCommand+Shift+I 同样是打开spectator，使用开发人员工具，但可以再次使用快捷键关闭。\n\nCommand+Shift+B 打开或关闭书签栏\n\nCommand+Option+B 打开书签管理器\n\nCommand+Y 打开历史记录\n\nCommand+Option+左右方向键 切换标签页\n\nCommand+D 收藏此页为书签\n\nCommand+Shift+D 将所有标签页加书签\n\nCommand+上下方向键 跳到页面顶部或底部\n\nCommand+Option+J 打开javascript控制台\n\n按住Command后点击链接，在新Tab（标签页）中打开这条链接。\n\nCommand+Shift再点击链接，在新标签页中打开并切换到新标签页\n\nCommand+Shift+N 用隐身模式打开新窗口\n\nCommand+Shift+W 关闭当前窗口\n\nCommand+[ 或者 ] 前进或者回退\n\nCommand+左右方向键 前进或者后退\n\nCommand+Option+U 查看网页源代码\n\n#### iTerm2快捷键\n\niTerm2中的文本，选中即复制，这个其实没必要，我现在都习惯了选中后 cmd+c，而且当你选择替换目标时候由于这个选中即复制，会覆盖掉你的剪切板\n\nCommand+D 水平分隔出一个终端\n\nCommand+Shift+D 垂直分割出一个终端\n\n可以配置透明度，Command+U快速切换透明与否\n\n可以配置全局唤出快捷键，我自己配置的是Command+U\n\n可以配置快捷悬浮，Hotkey window\n\nCommand+Shift+H 查看复制历史\n\nCommand+Enter 快速切换全屏与否\n\n#### CLI(命令行)快捷键\n\nMac本身的特点就是GUI和CLI的完美结合（很多Linux的爱好者，又不想被Linux的桌面、各种驱动、不兼容等等杂七杂八的问题折腾的，大可选择Mac）。\n\n首先教一个最重要的东西\n记住按Tab补全，这是命令行用的爽的根源。\n\nCtrl+A 回到行首\n\nCtrl+E 到行末\n\nCtrl+U 删除一行\n\n## 格式转换\n\n有时候需要把 png 等格式的图片转成 jpg 的格式，于是有同学就去到处找格式转换软件了。\n其实在 Mac 中直接更改图片的扩展名，即可自动转成相应地格式~试试吧，如果你改格式前看了文件修改日期，改完格式后你会发现修改日期依然没变，至于原因是什么，需要你有图片的文件格式的相关知识。\n\n## Launchpad与Dock\n\nLaunchpad是指，你在触摸板上用五指向中间收拢，出现的全是APP的页面，半透明的。\n\nDock是指，最下方的摆满APP的一栏，在Dock上你可以放上最常用的APP。\n\n调整launchpad的图标大小：\n\n```\n//把行数重定义成6\ndelete write com.apple.dock springboard-rows -int 6\n//把行数充定义成默认\ndefaults write com.apple.dock springboard-rows Default\n//删除定义好的行数（恢复默认）\ndefaults delete com.apple.dock springboard-rows\n//把列数定义成默认\ndefaults write com.apple.dock springboard-columns Default\n//重置 Launchpad，效果就是 launchpad 的布局全给你打乱了，而第一页恢复默认，建议不要使用\ndefaults write com.apple.dock ResetLaunchPad -bool TRUE\n//重启 Launchpad，并使你前面的设置生效\nkillall Dock\n```\n\n在appstore下载一个软件到一半，然后在Application删除了该软件，结果在launchpad中留下了一个垃圾残留空图标。\n删除launchpad中的垃圾残留图标，只需拖拽到下载文件夹。其他方法都试过（无效），比如按住图标几秒，出现一个叉，点击叉，删除，没用。在Application找到相应项删除没用。\n\n## Option的妙用\n\n下面再讲些不常用但是有意思的：\n\n除了cmd是常用的，option键也值得我们关注，下面讲几个option的妙用：\n\n按住option+shift可以微调（1/4微调）音量、键盘背光亮度和屏幕亮度，按住option再按其他字母键等，会出现奇怪的字符¥©\n©œ∑®†¥åß©≈ç等等。\n\n按住option再把鼠标移到Dock上的APP上，你会发现退出变成了强制退出，怎么样option键还是挺强大的吧。\n\n### 数学符号\n\n约等于: Option + X = ≈\n度数: Shift + Option + 8 = °\n除号: Option + / = ÷\n无穷: Option + 5 = ∞\n大于等于和小于等于: Option + , 和 Option + . = ≤ 和 ≥\n不等于: Option + = = ≠\n圆周率: Option + P = π\n加减: Shift + Option + = = ±\n开方: Option + V = √\n求和符号: Option + W = ∑\n\n### 输入特殊符号\n\n版权符号: Option + G = ©\n\n人民币符号: Option + Y = ¥\n","source":"_posts/2017/2017-01-01-从windows转用macOSX记录.md","raw":"---\ntitle: 从 windows 转用 mac OS X 记录\ndate: 2017-01-01\ncategories: [数码]\ntags: [工具]\ncomments: true\n---\n\n这篇文章我想讲讲我从用 Windows 到用 mac OS X 的过程中遇到的困难和解决方法。\n\n由于我本人是学计算机的，电脑用的多，喜欢用一些设计的好的快捷键，所以我分为两部分吧，第一部分讲给普通用户，第二部分讲给程序员。\n\n先告诉你们一个通用小技巧，众所周知，flash视频非常让电脑发热，而看HTML5视频则一点都不热。safari有个伪装成iPad或者iPhone的功能，可以把视频强制用HTML5播放。你的MacBook就再也不会在看视频的时候发烫了。\n\n![safari强制使用HTML5播放视频](https://wx4.sinaimg.cn/mw690/006zFO3ggy1fcd4d2uzibj31kw0zkdug.jpg)\n\n时至今日（2017.9.9），很多网站都可以使用 HTML5播放视频了，如：bilibili，中国大学MOOC，使用 HTML5播放视频是未来的方向。\n\n## 普通用户使用mac指南\n\n### 浏览器\n\n找不到浏览器吗？点击像指南针图标的那个safari，那个应用就是浏览器。\n\n### 输入法\n\n和初次使用Linux一样，一上来我们肯定就要碰到输入法的难题，mac切换输入法的快捷键是command+space（空格），一般的系统或者软件都是支持自定义快捷键的，你可以修改快捷键。对于用惯了搜狗输入法的同学，这里我推荐使用搜狗输入法，它可以记住用户习惯。\n\n![mac输入法截图](https://wx4.sinaimg.cn/mw690/006zFO3ggy1fcceny2wsuj31kw0zkdku.jpg)\n\n搜狗默认的通用中英文切换键是 shift。\n\n### 触摸板\n\nmac的触摸板应该是所有笔记本电脑触摸板的宗师吧，而且也是最好用的触摸板。我用mac的时候，除了玩游戏，完全用不着鼠标。\n\n没有鼠标，那么左右键怎么办？很简单：一指单击触摸板，就是左键，两指单击触摸板，就是右键。记得将轻触触摸板设置为点击，这样可以延长触摸板的寿命，而且点起来也舒服多了。\n\n五指合拢，你可以看到你电脑上安装好的应用，这个界面叫做：launchpad。\n\n![launchpad截图](https://wx2.sinaimg.cn/mw690/006zFO3ggy1fccexd55wpj31kw0zktgg.jpg)\n\n五指弹开，如果你处在launchpad界面，五指弹开就会回到原先五指合拢之前的那个界面，回到这个界面之后，再用一次五指弹开，就是弹开所有应用，让你看到桌面（如果你当前窗口是全屏模式，则此法失效）。\n\n![弹开应用看到桌面](https://wx3.sinaimg.cn/mw690/006zFO3ggy1fccf5tp4rpj31kw0zkjwj.jpg)\n\n三指上推，可以看到所有打开的窗口的缩略图。\n\n![窗口缩略图](https://wx4.sinaimg.cn/mw690/006zFO3ggy1fccf0mfcanj31kw0zkqcm.jpg)\n\n三指横扫，可以在全屏之间切换，这是我最喜欢的设计之一。\n\n### 安装应用\n\n去官网下好应用，通常是.dmg后缀的安装包，打开，拖拽到Applications文件夹就完成了安装，比Windows爽多了吧。\n\n### 文件管理器Finder\n\n调整默认Finder窗口大小，可以按住option，然后进行拖动，窗口的大小就可以保留下来了。\n\ncommand+shift+.可以显示隐藏文件，关闭显示隐藏文件也是这个快捷键。\n\n右键之后，没有新建文件选项。\n\n你只能先打开应用，然后在应用中新建文件。\n\n记住在Windows上用的很爽的ctrl+a、ctrl+s、ctrl+c、ctrl+v、ctrl+f等等，在mac上统统把ctrl换成command就OK了。\n\ncommand+x不能剪切文件和文件夹是吧。\n\n解决办法是：先command+c，然后command+option+v，成功的完成文件的剪切和粘贴。\n\n普通用户的指南到此结束，如果有什么问题，请私信我的知乎，我博客头像下面有个知乎的知的图标，点击就能到我的知乎个人主页。\n\n## 程序员mac指南\n\n先上几个零碎的小技巧：\n\n触摸板双指双击，放大（我觉得其实没啥卵用）\n\n在应用窗口顶栏双击，缩放窗口（这个Windows也有的）\n\n### 文件管理器Finder\n\n首先讲Finder，这是mac 系统，也就是OS X系统的文件管理器，和windows的文件管理器对比有点不同，最不方便的地方在于点击右键没有新建文件选项，如果你会Linux，可以用命令touch 文件名来新建文件，如果你不会命令，可以先打开文本编辑器，再新建文本文件，它的设计哲学是，你要新建什么文件，就先打开与这个文件相关的软件，再在这个软件里新建这个类型的文件，不过不方便就是不方便。再讲讲优秀的地方，Finder可以打开多级目录。\n\n![Finder多级目录](https://ww4.sinaimg.cn/mw690/005DrjN1gw1fbgxqax4waj316s0o8n0e.jpg)\n\n另外可以 按空格键预览，这个预览功能现在 Windows 也有了。\n\nFinder还有tag系统，你可以通过tag来访问属于同一个tag的文件\n\n![Finder的tag功能](https://ww3.sinaimg.cn/mw690/005DrjN1gw1fbgxwxxpobj316s0o8ad8.jpg)\n\n### 快捷键\n\n>快捷键肯定是最重要的啦！\n\n然后讲讲快捷键设计，我在windows下已经有了些使用快捷键的习惯，比如：\n\nwin+E是打开文件管理器\n\nwin+D是显示桌面（也就是将所有窗口最小化）\n\nwin+L锁屏\n\nctrl+S保存\n\nctrl+A全选\n\nctrl+C复制\n\nctrl+X剪切\n\nctrl+V粘贴\n\nctrl+F查找\n\n当我来到OS X下的时候，我同样先摸索了一番快捷键。设计快捷键的哲学就是通用，这样就可以节省记忆成本，mac上的cmd基本上承担了windows上ctrl的职能，常用的快捷键有：\n\ncmd+S保存\n\ncmd+A全选\n\ncmd+C复制\n\ncmd+X剪切\n\ncmd+V粘贴\n\ncmd+F查找\n\ncmd+D制作副本\n\n按住option+command，拖动文件，可以产生快捷方式，也就是链接。\n\ncmd+, 打开preferance也就是打开设置界面，这个快捷键简直不要太爽，希望 Windows 上也弄一个\n\ncmd+N 打开新窗口\n\ncmd+W 关闭窗口\n\ncmd+H 隐藏窗口\n\ncmd+Q 退出程序\n\ncmd+ctrl+F 全屏和退出全屏，播放视频时候退出全屏一般是 ESC 键\n\ncmd+Tab切换程序\n\n你用了Finder之后可能会恼火没有剪切文件的功能，但其实是有的，只是快捷键不一样，剪切文件的快捷键是，先cmd+C复制，然后cmd+option+V粘贴。\n\n这是我常用的几个快捷键。总之快捷键不用记很多，按你自己的需要，记住常用的就行。\n\nCommand+Option+D 控制Dock的显示与隐藏，我还是喜欢留着 Dock。\n\nCommand+Option+H 隐藏所有其他窗口\n\nShift+音量 会有声音，直接按音量默认是不出声\n\nCommand+I 显示简介（在Finder中），然后就 可以修改打开一个文件的默认APP\n\nCommand+Control+N 新建一个文件夹，并归类你选中的所有文件\n\n#### 编辑文本的快捷键\n\nCommand+Space 切换输入法\n\nCommand+left 让光标跳到最前面，相当于windows下的home键\n\nCommand+right 让光标跳到最后，相当于windows下的end键\n\nCommand+up 让光标跳到整个文本的最开头\n\nCommand+down 让光标跳到整个文本的最后\n\nCommand+delete 删除当前行，相当于windows下的home，shift+end（选中，从行头到行尾），backspace，这三个操作的组合。这个快捷键会让你相当爽的。\n\n#### 截图快捷键\n\nCommand+Shift+3 截取整个桌面，并把截图作为一个文件存储在桌面上\n\nCommand+Shift+4 截取一个区域，并把截图作为一个文件存储在桌面上\n\nCommand+Shift+Ctrl+3 截取整个桌面，并复制到剪切板\n\nCommand+Shift+Ctrl+4 截取一个区域，并复制到剪切板\n\nCommand+Shift+4 然后按Space就会截取一个窗口。这样截图会自带阴影效果。如果不想自带阴影效果，可以按住option再点触摸板。\n\nCommand+Ctrl+A mac QQ 截图快捷键，由于屏幕分辨率太高，mac系统快捷键截出来的图都太大了，而macQQ截出来的图大小正合适。\n\n#### Chrome浏览器快捷键\n\n这个应该是与操作系统无关的（有些快捷键还是不一样的），但在Mac下养成了用快捷键的习惯，所以Chrome的快捷键都是在Mac上学的，在windows下注意用Ctrl替换Command键就行了。\n\nCommand+R 刷新\n\nCommand+L 将窗口焦点锁定到浏览器的地址栏，不用移动鼠标哦\n\nCommand+T 打开一个新Tab\n\nCommand+Shift+T 打开一个之前被关闭的Tab\n\nCommand+Shift+J 打开下载页面\n\nCommand+Shift+C 打开“检查(spectator)”，鼠标右键可以看到这个选项，一般是程序员使用的高级功能，但不能再次使用快捷键关闭。\n\nCommand+Shift+I 同样是打开spectator，使用开发人员工具，但可以再次使用快捷键关闭。\n\nCommand+Shift+B 打开或关闭书签栏\n\nCommand+Option+B 打开书签管理器\n\nCommand+Y 打开历史记录\n\nCommand+Option+左右方向键 切换标签页\n\nCommand+D 收藏此页为书签\n\nCommand+Shift+D 将所有标签页加书签\n\nCommand+上下方向键 跳到页面顶部或底部\n\nCommand+Option+J 打开javascript控制台\n\n按住Command后点击链接，在新Tab（标签页）中打开这条链接。\n\nCommand+Shift再点击链接，在新标签页中打开并切换到新标签页\n\nCommand+Shift+N 用隐身模式打开新窗口\n\nCommand+Shift+W 关闭当前窗口\n\nCommand+[ 或者 ] 前进或者回退\n\nCommand+左右方向键 前进或者后退\n\nCommand+Option+U 查看网页源代码\n\n#### iTerm2快捷键\n\niTerm2中的文本，选中即复制，这个其实没必要，我现在都习惯了选中后 cmd+c，而且当你选择替换目标时候由于这个选中即复制，会覆盖掉你的剪切板\n\nCommand+D 水平分隔出一个终端\n\nCommand+Shift+D 垂直分割出一个终端\n\n可以配置透明度，Command+U快速切换透明与否\n\n可以配置全局唤出快捷键，我自己配置的是Command+U\n\n可以配置快捷悬浮，Hotkey window\n\nCommand+Shift+H 查看复制历史\n\nCommand+Enter 快速切换全屏与否\n\n#### CLI(命令行)快捷键\n\nMac本身的特点就是GUI和CLI的完美结合（很多Linux的爱好者，又不想被Linux的桌面、各种驱动、不兼容等等杂七杂八的问题折腾的，大可选择Mac）。\n\n首先教一个最重要的东西\n记住按Tab补全，这是命令行用的爽的根源。\n\nCtrl+A 回到行首\n\nCtrl+E 到行末\n\nCtrl+U 删除一行\n\n## 格式转换\n\n有时候需要把 png 等格式的图片转成 jpg 的格式，于是有同学就去到处找格式转换软件了。\n其实在 Mac 中直接更改图片的扩展名，即可自动转成相应地格式~试试吧，如果你改格式前看了文件修改日期，改完格式后你会发现修改日期依然没变，至于原因是什么，需要你有图片的文件格式的相关知识。\n\n## Launchpad与Dock\n\nLaunchpad是指，你在触摸板上用五指向中间收拢，出现的全是APP的页面，半透明的。\n\nDock是指，最下方的摆满APP的一栏，在Dock上你可以放上最常用的APP。\n\n调整launchpad的图标大小：\n\n```\n//把行数重定义成6\ndelete write com.apple.dock springboard-rows -int 6\n//把行数充定义成默认\ndefaults write com.apple.dock springboard-rows Default\n//删除定义好的行数（恢复默认）\ndefaults delete com.apple.dock springboard-rows\n//把列数定义成默认\ndefaults write com.apple.dock springboard-columns Default\n//重置 Launchpad，效果就是 launchpad 的布局全给你打乱了，而第一页恢复默认，建议不要使用\ndefaults write com.apple.dock ResetLaunchPad -bool TRUE\n//重启 Launchpad，并使你前面的设置生效\nkillall Dock\n```\n\n在appstore下载一个软件到一半，然后在Application删除了该软件，结果在launchpad中留下了一个垃圾残留空图标。\n删除launchpad中的垃圾残留图标，只需拖拽到下载文件夹。其他方法都试过（无效），比如按住图标几秒，出现一个叉，点击叉，删除，没用。在Application找到相应项删除没用。\n\n## Option的妙用\n\n下面再讲些不常用但是有意思的：\n\n除了cmd是常用的，option键也值得我们关注，下面讲几个option的妙用：\n\n按住option+shift可以微调（1/4微调）音量、键盘背光亮度和屏幕亮度，按住option再按其他字母键等，会出现奇怪的字符¥©\n©œ∑®†¥åß©≈ç等等。\n\n按住option再把鼠标移到Dock上的APP上，你会发现退出变成了强制退出，怎么样option键还是挺强大的吧。\n\n### 数学符号\n\n约等于: Option + X = ≈\n度数: Shift + Option + 8 = °\n除号: Option + / = ÷\n无穷: Option + 5 = ∞\n大于等于和小于等于: Option + , 和 Option + . = ≤ 和 ≥\n不等于: Option + = = ≠\n圆周率: Option + P = π\n加减: Shift + Option + = = ±\n开方: Option + V = √\n求和符号: Option + W = ∑\n\n### 输入特殊符号\n\n版权符号: Option + G = ©\n\n人民币符号: Option + Y = ¥\n","slug":"从windows转用macOSX记录","published":1,"updated":"2018-04-25T07:40:58.796Z","layout":"post","photos":[],"link":"","_id":"cjm2w8dcr000ufgpxquwx96om","content":"<p>这篇文章我想讲讲我从用 Windows 到用 mac OS X 的过程中遇到的困难和解决方法。</p>\n<p>由于我本人是学计算机的，电脑用的多，喜欢用一些设计的好的快捷键，所以我分为两部分吧，第一部分讲给普通用户，第二部分讲给程序员。</p>\n<p>先告诉你们一个通用小技巧，众所周知，flash视频非常让电脑发热，而看HTML5视频则一点都不热。safari有个伪装成iPad或者iPhone的功能，可以把视频强制用HTML5播放。你的MacBook就再也不会在看视频的时候发烫了。</p>\n<p><img src=\"https://wx4.sinaimg.cn/mw690/006zFO3ggy1fcd4d2uzibj31kw0zkdug.jpg\" alt=\"safari强制使用HTML5播放视频\"></p>\n<p>时至今日（2017.9.9），很多网站都可以使用 HTML5播放视频了，如：bilibili，中国大学MOOC，使用 HTML5播放视频是未来的方向。</p>\n<h2 id=\"普通用户使用mac指南\"><a href=\"#普通用户使用mac指南\" class=\"headerlink\" title=\"普通用户使用mac指南\"></a>普通用户使用mac指南</h2><h3 id=\"浏览器\"><a href=\"#浏览器\" class=\"headerlink\" title=\"浏览器\"></a>浏览器</h3><p>找不到浏览器吗？点击像指南针图标的那个safari，那个应用就是浏览器。</p>\n<h3 id=\"输入法\"><a href=\"#输入法\" class=\"headerlink\" title=\"输入法\"></a>输入法</h3><p>和初次使用Linux一样，一上来我们肯定就要碰到输入法的难题，mac切换输入法的快捷键是command+space（空格），一般的系统或者软件都是支持自定义快捷键的，你可以修改快捷键。对于用惯了搜狗输入法的同学，这里我推荐使用搜狗输入法，它可以记住用户习惯。</p>\n<p><img src=\"https://wx4.sinaimg.cn/mw690/006zFO3ggy1fcceny2wsuj31kw0zkdku.jpg\" alt=\"mac输入法截图\"></p>\n<p>搜狗默认的通用中英文切换键是 shift。</p>\n<h3 id=\"触摸板\"><a href=\"#触摸板\" class=\"headerlink\" title=\"触摸板\"></a>触摸板</h3><p>mac的触摸板应该是所有笔记本电脑触摸板的宗师吧，而且也是最好用的触摸板。我用mac的时候，除了玩游戏，完全用不着鼠标。</p>\n<p>没有鼠标，那么左右键怎么办？很简单：一指单击触摸板，就是左键，两指单击触摸板，就是右键。记得将轻触触摸板设置为点击，这样可以延长触摸板的寿命，而且点起来也舒服多了。</p>\n<p>五指合拢，你可以看到你电脑上安装好的应用，这个界面叫做：launchpad。</p>\n<p><img src=\"https://wx2.sinaimg.cn/mw690/006zFO3ggy1fccexd55wpj31kw0zktgg.jpg\" alt=\"launchpad截图\"></p>\n<p>五指弹开，如果你处在launchpad界面，五指弹开就会回到原先五指合拢之前的那个界面，回到这个界面之后，再用一次五指弹开，就是弹开所有应用，让你看到桌面（如果你当前窗口是全屏模式，则此法失效）。</p>\n<p><img src=\"https://wx3.sinaimg.cn/mw690/006zFO3ggy1fccf5tp4rpj31kw0zkjwj.jpg\" alt=\"弹开应用看到桌面\"></p>\n<p>三指上推，可以看到所有打开的窗口的缩略图。</p>\n<p><img src=\"https://wx4.sinaimg.cn/mw690/006zFO3ggy1fccf0mfcanj31kw0zkqcm.jpg\" alt=\"窗口缩略图\"></p>\n<p>三指横扫，可以在全屏之间切换，这是我最喜欢的设计之一。</p>\n<h3 id=\"安装应用\"><a href=\"#安装应用\" class=\"headerlink\" title=\"安装应用\"></a>安装应用</h3><p>去官网下好应用，通常是.dmg后缀的安装包，打开，拖拽到Applications文件夹就完成了安装，比Windows爽多了吧。</p>\n<h3 id=\"文件管理器Finder\"><a href=\"#文件管理器Finder\" class=\"headerlink\" title=\"文件管理器Finder\"></a>文件管理器Finder</h3><p>调整默认Finder窗口大小，可以按住option，然后进行拖动，窗口的大小就可以保留下来了。</p>\n<p>command+shift+.可以显示隐藏文件，关闭显示隐藏文件也是这个快捷键。</p>\n<p>右键之后，没有新建文件选项。</p>\n<p>你只能先打开应用，然后在应用中新建文件。</p>\n<p>记住在Windows上用的很爽的ctrl+a、ctrl+s、ctrl+c、ctrl+v、ctrl+f等等，在mac上统统把ctrl换成command就OK了。</p>\n<p>command+x不能剪切文件和文件夹是吧。</p>\n<p>解决办法是：先command+c，然后command+option+v，成功的完成文件的剪切和粘贴。</p>\n<p>普通用户的指南到此结束，如果有什么问题，请私信我的知乎，我博客头像下面有个知乎的知的图标，点击就能到我的知乎个人主页。</p>\n<h2 id=\"程序员mac指南\"><a href=\"#程序员mac指南\" class=\"headerlink\" title=\"程序员mac指南\"></a>程序员mac指南</h2><p>先上几个零碎的小技巧：</p>\n<p>触摸板双指双击，放大（我觉得其实没啥卵用）</p>\n<p>在应用窗口顶栏双击，缩放窗口（这个Windows也有的）</p>\n<h3 id=\"文件管理器Finder-1\"><a href=\"#文件管理器Finder-1\" class=\"headerlink\" title=\"文件管理器Finder\"></a>文件管理器Finder</h3><p>首先讲Finder，这是mac 系统，也就是OS X系统的文件管理器，和windows的文件管理器对比有点不同，最不方便的地方在于点击右键没有新建文件选项，如果你会Linux，可以用命令touch 文件名来新建文件，如果你不会命令，可以先打开文本编辑器，再新建文本文件，它的设计哲学是，你要新建什么文件，就先打开与这个文件相关的软件，再在这个软件里新建这个类型的文件，不过不方便就是不方便。再讲讲优秀的地方，Finder可以打开多级目录。</p>\n<p><img src=\"https://ww4.sinaimg.cn/mw690/005DrjN1gw1fbgxqax4waj316s0o8n0e.jpg\" alt=\"Finder多级目录\"></p>\n<p>另外可以 按空格键预览，这个预览功能现在 Windows 也有了。</p>\n<p>Finder还有tag系统，你可以通过tag来访问属于同一个tag的文件</p>\n<p><img src=\"https://ww3.sinaimg.cn/mw690/005DrjN1gw1fbgxwxxpobj316s0o8ad8.jpg\" alt=\"Finder的tag功能\"></p>\n<h3 id=\"快捷键\"><a href=\"#快捷键\" class=\"headerlink\" title=\"快捷键\"></a>快捷键</h3><blockquote>\n<p>快捷键肯定是最重要的啦！</p>\n</blockquote>\n<p>然后讲讲快捷键设计，我在windows下已经有了些使用快捷键的习惯，比如：</p>\n<p>win+E是打开文件管理器</p>\n<p>win+D是显示桌面（也就是将所有窗口最小化）</p>\n<p>win+L锁屏</p>\n<p>ctrl+S保存</p>\n<p>ctrl+A全选</p>\n<p>ctrl+C复制</p>\n<p>ctrl+X剪切</p>\n<p>ctrl+V粘贴</p>\n<p>ctrl+F查找</p>\n<p>当我来到OS X下的时候，我同样先摸索了一番快捷键。设计快捷键的哲学就是通用，这样就可以节省记忆成本，mac上的cmd基本上承担了windows上ctrl的职能，常用的快捷键有：</p>\n<p>cmd+S保存</p>\n<p>cmd+A全选</p>\n<p>cmd+C复制</p>\n<p>cmd+X剪切</p>\n<p>cmd+V粘贴</p>\n<p>cmd+F查找</p>\n<p>cmd+D制作副本</p>\n<p>按住option+command，拖动文件，可以产生快捷方式，也就是链接。</p>\n<p>cmd+, 打开preferance也就是打开设置界面，这个快捷键简直不要太爽，希望 Windows 上也弄一个</p>\n<p>cmd+N 打开新窗口</p>\n<p>cmd+W 关闭窗口</p>\n<p>cmd+H 隐藏窗口</p>\n<p>cmd+Q 退出程序</p>\n<p>cmd+ctrl+F 全屏和退出全屏，播放视频时候退出全屏一般是 ESC 键</p>\n<p>cmd+Tab切换程序</p>\n<p>你用了Finder之后可能会恼火没有剪切文件的功能，但其实是有的，只是快捷键不一样，剪切文件的快捷键是，先cmd+C复制，然后cmd+option+V粘贴。</p>\n<p>这是我常用的几个快捷键。总之快捷键不用记很多，按你自己的需要，记住常用的就行。</p>\n<p>Command+Option+D 控制Dock的显示与隐藏，我还是喜欢留着 Dock。</p>\n<p>Command+Option+H 隐藏所有其他窗口</p>\n<p>Shift+音量 会有声音，直接按音量默认是不出声</p>\n<p>Command+I 显示简介（在Finder中），然后就 可以修改打开一个文件的默认APP</p>\n<p>Command+Control+N 新建一个文件夹，并归类你选中的所有文件</p>\n<h4 id=\"编辑文本的快捷键\"><a href=\"#编辑文本的快捷键\" class=\"headerlink\" title=\"编辑文本的快捷键\"></a>编辑文本的快捷键</h4><p>Command+Space 切换输入法</p>\n<p>Command+left 让光标跳到最前面，相当于windows下的home键</p>\n<p>Command+right 让光标跳到最后，相当于windows下的end键</p>\n<p>Command+up 让光标跳到整个文本的最开头</p>\n<p>Command+down 让光标跳到整个文本的最后</p>\n<p>Command+delete 删除当前行，相当于windows下的home，shift+end（选中，从行头到行尾），backspace，这三个操作的组合。这个快捷键会让你相当爽的。</p>\n<h4 id=\"截图快捷键\"><a href=\"#截图快捷键\" class=\"headerlink\" title=\"截图快捷键\"></a>截图快捷键</h4><p>Command+Shift+3 截取整个桌面，并把截图作为一个文件存储在桌面上</p>\n<p>Command+Shift+4 截取一个区域，并把截图作为一个文件存储在桌面上</p>\n<p>Command+Shift+Ctrl+3 截取整个桌面，并复制到剪切板</p>\n<p>Command+Shift+Ctrl+4 截取一个区域，并复制到剪切板</p>\n<p>Command+Shift+4 然后按Space就会截取一个窗口。这样截图会自带阴影效果。如果不想自带阴影效果，可以按住option再点触摸板。</p>\n<p>Command+Ctrl+A mac QQ 截图快捷键，由于屏幕分辨率太高，mac系统快捷键截出来的图都太大了，而macQQ截出来的图大小正合适。</p>\n<h4 id=\"Chrome浏览器快捷键\"><a href=\"#Chrome浏览器快捷键\" class=\"headerlink\" title=\"Chrome浏览器快捷键\"></a>Chrome浏览器快捷键</h4><p>这个应该是与操作系统无关的（有些快捷键还是不一样的），但在Mac下养成了用快捷键的习惯，所以Chrome的快捷键都是在Mac上学的，在windows下注意用Ctrl替换Command键就行了。</p>\n<p>Command+R 刷新</p>\n<p>Command+L 将窗口焦点锁定到浏览器的地址栏，不用移动鼠标哦</p>\n<p>Command+T 打开一个新Tab</p>\n<p>Command+Shift+T 打开一个之前被关闭的Tab</p>\n<p>Command+Shift+J 打开下载页面</p>\n<p>Command+Shift+C 打开“检查(spectator)”，鼠标右键可以看到这个选项，一般是程序员使用的高级功能，但不能再次使用快捷键关闭。</p>\n<p>Command+Shift+I 同样是打开spectator，使用开发人员工具，但可以再次使用快捷键关闭。</p>\n<p>Command+Shift+B 打开或关闭书签栏</p>\n<p>Command+Option+B 打开书签管理器</p>\n<p>Command+Y 打开历史记录</p>\n<p>Command+Option+左右方向键 切换标签页</p>\n<p>Command+D 收藏此页为书签</p>\n<p>Command+Shift+D 将所有标签页加书签</p>\n<p>Command+上下方向键 跳到页面顶部或底部</p>\n<p>Command+Option+J 打开javascript控制台</p>\n<p>按住Command后点击链接，在新Tab（标签页）中打开这条链接。</p>\n<p>Command+Shift再点击链接，在新标签页中打开并切换到新标签页</p>\n<p>Command+Shift+N 用隐身模式打开新窗口</p>\n<p>Command+Shift+W 关闭当前窗口</p>\n<p>Command+[ 或者 ] 前进或者回退</p>\n<p>Command+左右方向键 前进或者后退</p>\n<p>Command+Option+U 查看网页源代码</p>\n<h4 id=\"iTerm2快捷键\"><a href=\"#iTerm2快捷键\" class=\"headerlink\" title=\"iTerm2快捷键\"></a>iTerm2快捷键</h4><p>iTerm2中的文本，选中即复制，这个其实没必要，我现在都习惯了选中后 cmd+c，而且当你选择替换目标时候由于这个选中即复制，会覆盖掉你的剪切板</p>\n<p>Command+D 水平分隔出一个终端</p>\n<p>Command+Shift+D 垂直分割出一个终端</p>\n<p>可以配置透明度，Command+U快速切换透明与否</p>\n<p>可以配置全局唤出快捷键，我自己配置的是Command+U</p>\n<p>可以配置快捷悬浮，Hotkey window</p>\n<p>Command+Shift+H 查看复制历史</p>\n<p>Command+Enter 快速切换全屏与否</p>\n<h4 id=\"CLI-命令行-快捷键\"><a href=\"#CLI-命令行-快捷键\" class=\"headerlink\" title=\"CLI(命令行)快捷键\"></a>CLI(命令行)快捷键</h4><p>Mac本身的特点就是GUI和CLI的完美结合（很多Linux的爱好者，又不想被Linux的桌面、各种驱动、不兼容等等杂七杂八的问题折腾的，大可选择Mac）。</p>\n<p>首先教一个最重要的东西<br>记住按Tab补全，这是命令行用的爽的根源。</p>\n<p>Ctrl+A 回到行首</p>\n<p>Ctrl+E 到行末</p>\n<p>Ctrl+U 删除一行</p>\n<h2 id=\"格式转换\"><a href=\"#格式转换\" class=\"headerlink\" title=\"格式转换\"></a>格式转换</h2><p>有时候需要把 png 等格式的图片转成 jpg 的格式，于是有同学就去到处找格式转换软件了。<br>其实在 Mac 中直接更改图片的扩展名，即可自动转成相应地格式~试试吧，如果你改格式前看了文件修改日期，改完格式后你会发现修改日期依然没变，至于原因是什么，需要你有图片的文件格式的相关知识。</p>\n<h2 id=\"Launchpad与Dock\"><a href=\"#Launchpad与Dock\" class=\"headerlink\" title=\"Launchpad与Dock\"></a>Launchpad与Dock</h2><p>Launchpad是指，你在触摸板上用五指向中间收拢，出现的全是APP的页面，半透明的。</p>\n<p>Dock是指，最下方的摆满APP的一栏，在Dock上你可以放上最常用的APP。</p>\n<p>调整launchpad的图标大小：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//把行数重定义成6</span><br><span class=\"line\">delete write com.apple.dock springboard-rows -int 6</span><br><span class=\"line\">//把行数充定义成默认</span><br><span class=\"line\">defaults write com.apple.dock springboard-rows Default</span><br><span class=\"line\">//删除定义好的行数（恢复默认）</span><br><span class=\"line\">defaults delete com.apple.dock springboard-rows</span><br><span class=\"line\">//把列数定义成默认</span><br><span class=\"line\">defaults write com.apple.dock springboard-columns Default</span><br><span class=\"line\">//重置 Launchpad，效果就是 launchpad 的布局全给你打乱了，而第一页恢复默认，建议不要使用</span><br><span class=\"line\">defaults write com.apple.dock ResetLaunchPad -bool TRUE</span><br><span class=\"line\">//重启 Launchpad，并使你前面的设置生效</span><br><span class=\"line\">killall Dock</span><br></pre></td></tr></table></figure>\n<p>在appstore下载一个软件到一半，然后在Application删除了该软件，结果在launchpad中留下了一个垃圾残留空图标。<br>删除launchpad中的垃圾残留图标，只需拖拽到下载文件夹。其他方法都试过（无效），比如按住图标几秒，出现一个叉，点击叉，删除，没用。在Application找到相应项删除没用。</p>\n<h2 id=\"Option的妙用\"><a href=\"#Option的妙用\" class=\"headerlink\" title=\"Option的妙用\"></a>Option的妙用</h2><p>下面再讲些不常用但是有意思的：</p>\n<p>除了cmd是常用的，option键也值得我们关注，下面讲几个option的妙用：</p>\n<p>按住option+shift可以微调（1/4微调）音量、键盘背光亮度和屏幕亮度，按住option再按其他字母键等，会出现奇怪的字符¥©<br>©œ∑®†¥åß©≈ç等等。</p>\n<p>按住option再把鼠标移到Dock上的APP上，你会发现退出变成了强制退出，怎么样option键还是挺强大的吧。</p>\n<h3 id=\"数学符号\"><a href=\"#数学符号\" class=\"headerlink\" title=\"数学符号\"></a>数学符号</h3><p>约等于: Option + X = ≈<br>度数: Shift + Option + 8 = °<br>除号: Option + / = ÷<br>无穷: Option + 5 = ∞<br>大于等于和小于等于: Option + , 和 Option + . = ≤ 和 ≥<br>不等于: Option + = = ≠<br>圆周率: Option + P = π<br>加减: Shift + Option + = = ±<br>开方: Option + V = √<br>求和符号: Option + W = ∑</p>\n<h3 id=\"输入特殊符号\"><a href=\"#输入特殊符号\" class=\"headerlink\" title=\"输入特殊符号\"></a>输入特殊符号</h3><p>版权符号: Option + G = ©</p>\n<p>人民币符号: Option + Y = ¥</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这篇文章我想讲讲我从用 Windows 到用 mac OS X 的过程中遇到的困难和解决方法。</p>\n<p>由于我本人是学计算机的，电脑用的多，喜欢用一些设计的好的快捷键，所以我分为两部分吧，第一部分讲给普通用户，第二部分讲给程序员。</p>\n<p>先告诉你们一个通用小技巧，众所周知，flash视频非常让电脑发热，而看HTML5视频则一点都不热。safari有个伪装成iPad或者iPhone的功能，可以把视频强制用HTML5播放。你的MacBook就再也不会在看视频的时候发烫了。</p>\n<p><img src=\"https://wx4.sinaimg.cn/mw690/006zFO3ggy1fcd4d2uzibj31kw0zkdug.jpg\" alt=\"safari强制使用HTML5播放视频\"></p>\n<p>时至今日（2017.9.9），很多网站都可以使用 HTML5播放视频了，如：bilibili，中国大学MOOC，使用 HTML5播放视频是未来的方向。</p>\n<h2 id=\"普通用户使用mac指南\"><a href=\"#普通用户使用mac指南\" class=\"headerlink\" title=\"普通用户使用mac指南\"></a>普通用户使用mac指南</h2><h3 id=\"浏览器\"><a href=\"#浏览器\" class=\"headerlink\" title=\"浏览器\"></a>浏览器</h3><p>找不到浏览器吗？点击像指南针图标的那个safari，那个应用就是浏览器。</p>\n<h3 id=\"输入法\"><a href=\"#输入法\" class=\"headerlink\" title=\"输入法\"></a>输入法</h3><p>和初次使用Linux一样，一上来我们肯定就要碰到输入法的难题，mac切换输入法的快捷键是command+space（空格），一般的系统或者软件都是支持自定义快捷键的，你可以修改快捷键。对于用惯了搜狗输入法的同学，这里我推荐使用搜狗输入法，它可以记住用户习惯。</p>\n<p><img src=\"https://wx4.sinaimg.cn/mw690/006zFO3ggy1fcceny2wsuj31kw0zkdku.jpg\" alt=\"mac输入法截图\"></p>\n<p>搜狗默认的通用中英文切换键是 shift。</p>\n<h3 id=\"触摸板\"><a href=\"#触摸板\" class=\"headerlink\" title=\"触摸板\"></a>触摸板</h3><p>mac的触摸板应该是所有笔记本电脑触摸板的宗师吧，而且也是最好用的触摸板。我用mac的时候，除了玩游戏，完全用不着鼠标。</p>\n<p>没有鼠标，那么左右键怎么办？很简单：一指单击触摸板，就是左键，两指单击触摸板，就是右键。记得将轻触触摸板设置为点击，这样可以延长触摸板的寿命，而且点起来也舒服多了。</p>\n<p>五指合拢，你可以看到你电脑上安装好的应用，这个界面叫做：launchpad。</p>\n<p><img src=\"https://wx2.sinaimg.cn/mw690/006zFO3ggy1fccexd55wpj31kw0zktgg.jpg\" alt=\"launchpad截图\"></p>\n<p>五指弹开，如果你处在launchpad界面，五指弹开就会回到原先五指合拢之前的那个界面，回到这个界面之后，再用一次五指弹开，就是弹开所有应用，让你看到桌面（如果你当前窗口是全屏模式，则此法失效）。</p>\n<p><img src=\"https://wx3.sinaimg.cn/mw690/006zFO3ggy1fccf5tp4rpj31kw0zkjwj.jpg\" alt=\"弹开应用看到桌面\"></p>\n<p>三指上推，可以看到所有打开的窗口的缩略图。</p>\n<p><img src=\"https://wx4.sinaimg.cn/mw690/006zFO3ggy1fccf0mfcanj31kw0zkqcm.jpg\" alt=\"窗口缩略图\"></p>\n<p>三指横扫，可以在全屏之间切换，这是我最喜欢的设计之一。</p>\n<h3 id=\"安装应用\"><a href=\"#安装应用\" class=\"headerlink\" title=\"安装应用\"></a>安装应用</h3><p>去官网下好应用，通常是.dmg后缀的安装包，打开，拖拽到Applications文件夹就完成了安装，比Windows爽多了吧。</p>\n<h3 id=\"文件管理器Finder\"><a href=\"#文件管理器Finder\" class=\"headerlink\" title=\"文件管理器Finder\"></a>文件管理器Finder</h3><p>调整默认Finder窗口大小，可以按住option，然后进行拖动，窗口的大小就可以保留下来了。</p>\n<p>command+shift+.可以显示隐藏文件，关闭显示隐藏文件也是这个快捷键。</p>\n<p>右键之后，没有新建文件选项。</p>\n<p>你只能先打开应用，然后在应用中新建文件。</p>\n<p>记住在Windows上用的很爽的ctrl+a、ctrl+s、ctrl+c、ctrl+v、ctrl+f等等，在mac上统统把ctrl换成command就OK了。</p>\n<p>command+x不能剪切文件和文件夹是吧。</p>\n<p>解决办法是：先command+c，然后command+option+v，成功的完成文件的剪切和粘贴。</p>\n<p>普通用户的指南到此结束，如果有什么问题，请私信我的知乎，我博客头像下面有个知乎的知的图标，点击就能到我的知乎个人主页。</p>\n<h2 id=\"程序员mac指南\"><a href=\"#程序员mac指南\" class=\"headerlink\" title=\"程序员mac指南\"></a>程序员mac指南</h2><p>先上几个零碎的小技巧：</p>\n<p>触摸板双指双击，放大（我觉得其实没啥卵用）</p>\n<p>在应用窗口顶栏双击，缩放窗口（这个Windows也有的）</p>\n<h3 id=\"文件管理器Finder-1\"><a href=\"#文件管理器Finder-1\" class=\"headerlink\" title=\"文件管理器Finder\"></a>文件管理器Finder</h3><p>首先讲Finder，这是mac 系统，也就是OS X系统的文件管理器，和windows的文件管理器对比有点不同，最不方便的地方在于点击右键没有新建文件选项，如果你会Linux，可以用命令touch 文件名来新建文件，如果你不会命令，可以先打开文本编辑器，再新建文本文件，它的设计哲学是，你要新建什么文件，就先打开与这个文件相关的软件，再在这个软件里新建这个类型的文件，不过不方便就是不方便。再讲讲优秀的地方，Finder可以打开多级目录。</p>\n<p><img src=\"https://ww4.sinaimg.cn/mw690/005DrjN1gw1fbgxqax4waj316s0o8n0e.jpg\" alt=\"Finder多级目录\"></p>\n<p>另外可以 按空格键预览，这个预览功能现在 Windows 也有了。</p>\n<p>Finder还有tag系统，你可以通过tag来访问属于同一个tag的文件</p>\n<p><img src=\"https://ww3.sinaimg.cn/mw690/005DrjN1gw1fbgxwxxpobj316s0o8ad8.jpg\" alt=\"Finder的tag功能\"></p>\n<h3 id=\"快捷键\"><a href=\"#快捷键\" class=\"headerlink\" title=\"快捷键\"></a>快捷键</h3><blockquote>\n<p>快捷键肯定是最重要的啦！</p>\n</blockquote>\n<p>然后讲讲快捷键设计，我在windows下已经有了些使用快捷键的习惯，比如：</p>\n<p>win+E是打开文件管理器</p>\n<p>win+D是显示桌面（也就是将所有窗口最小化）</p>\n<p>win+L锁屏</p>\n<p>ctrl+S保存</p>\n<p>ctrl+A全选</p>\n<p>ctrl+C复制</p>\n<p>ctrl+X剪切</p>\n<p>ctrl+V粘贴</p>\n<p>ctrl+F查找</p>\n<p>当我来到OS X下的时候，我同样先摸索了一番快捷键。设计快捷键的哲学就是通用，这样就可以节省记忆成本，mac上的cmd基本上承担了windows上ctrl的职能，常用的快捷键有：</p>\n<p>cmd+S保存</p>\n<p>cmd+A全选</p>\n<p>cmd+C复制</p>\n<p>cmd+X剪切</p>\n<p>cmd+V粘贴</p>\n<p>cmd+F查找</p>\n<p>cmd+D制作副本</p>\n<p>按住option+command，拖动文件，可以产生快捷方式，也就是链接。</p>\n<p>cmd+, 打开preferance也就是打开设置界面，这个快捷键简直不要太爽，希望 Windows 上也弄一个</p>\n<p>cmd+N 打开新窗口</p>\n<p>cmd+W 关闭窗口</p>\n<p>cmd+H 隐藏窗口</p>\n<p>cmd+Q 退出程序</p>\n<p>cmd+ctrl+F 全屏和退出全屏，播放视频时候退出全屏一般是 ESC 键</p>\n<p>cmd+Tab切换程序</p>\n<p>你用了Finder之后可能会恼火没有剪切文件的功能，但其实是有的，只是快捷键不一样，剪切文件的快捷键是，先cmd+C复制，然后cmd+option+V粘贴。</p>\n<p>这是我常用的几个快捷键。总之快捷键不用记很多，按你自己的需要，记住常用的就行。</p>\n<p>Command+Option+D 控制Dock的显示与隐藏，我还是喜欢留着 Dock。</p>\n<p>Command+Option+H 隐藏所有其他窗口</p>\n<p>Shift+音量 会有声音，直接按音量默认是不出声</p>\n<p>Command+I 显示简介（在Finder中），然后就 可以修改打开一个文件的默认APP</p>\n<p>Command+Control+N 新建一个文件夹，并归类你选中的所有文件</p>\n<h4 id=\"编辑文本的快捷键\"><a href=\"#编辑文本的快捷键\" class=\"headerlink\" title=\"编辑文本的快捷键\"></a>编辑文本的快捷键</h4><p>Command+Space 切换输入法</p>\n<p>Command+left 让光标跳到最前面，相当于windows下的home键</p>\n<p>Command+right 让光标跳到最后，相当于windows下的end键</p>\n<p>Command+up 让光标跳到整个文本的最开头</p>\n<p>Command+down 让光标跳到整个文本的最后</p>\n<p>Command+delete 删除当前行，相当于windows下的home，shift+end（选中，从行头到行尾），backspace，这三个操作的组合。这个快捷键会让你相当爽的。</p>\n<h4 id=\"截图快捷键\"><a href=\"#截图快捷键\" class=\"headerlink\" title=\"截图快捷键\"></a>截图快捷键</h4><p>Command+Shift+3 截取整个桌面，并把截图作为一个文件存储在桌面上</p>\n<p>Command+Shift+4 截取一个区域，并把截图作为一个文件存储在桌面上</p>\n<p>Command+Shift+Ctrl+3 截取整个桌面，并复制到剪切板</p>\n<p>Command+Shift+Ctrl+4 截取一个区域，并复制到剪切板</p>\n<p>Command+Shift+4 然后按Space就会截取一个窗口。这样截图会自带阴影效果。如果不想自带阴影效果，可以按住option再点触摸板。</p>\n<p>Command+Ctrl+A mac QQ 截图快捷键，由于屏幕分辨率太高，mac系统快捷键截出来的图都太大了，而macQQ截出来的图大小正合适。</p>\n<h4 id=\"Chrome浏览器快捷键\"><a href=\"#Chrome浏览器快捷键\" class=\"headerlink\" title=\"Chrome浏览器快捷键\"></a>Chrome浏览器快捷键</h4><p>这个应该是与操作系统无关的（有些快捷键还是不一样的），但在Mac下养成了用快捷键的习惯，所以Chrome的快捷键都是在Mac上学的，在windows下注意用Ctrl替换Command键就行了。</p>\n<p>Command+R 刷新</p>\n<p>Command+L 将窗口焦点锁定到浏览器的地址栏，不用移动鼠标哦</p>\n<p>Command+T 打开一个新Tab</p>\n<p>Command+Shift+T 打开一个之前被关闭的Tab</p>\n<p>Command+Shift+J 打开下载页面</p>\n<p>Command+Shift+C 打开“检查(spectator)”，鼠标右键可以看到这个选项，一般是程序员使用的高级功能，但不能再次使用快捷键关闭。</p>\n<p>Command+Shift+I 同样是打开spectator，使用开发人员工具，但可以再次使用快捷键关闭。</p>\n<p>Command+Shift+B 打开或关闭书签栏</p>\n<p>Command+Option+B 打开书签管理器</p>\n<p>Command+Y 打开历史记录</p>\n<p>Command+Option+左右方向键 切换标签页</p>\n<p>Command+D 收藏此页为书签</p>\n<p>Command+Shift+D 将所有标签页加书签</p>\n<p>Command+上下方向键 跳到页面顶部或底部</p>\n<p>Command+Option+J 打开javascript控制台</p>\n<p>按住Command后点击链接，在新Tab（标签页）中打开这条链接。</p>\n<p>Command+Shift再点击链接，在新标签页中打开并切换到新标签页</p>\n<p>Command+Shift+N 用隐身模式打开新窗口</p>\n<p>Command+Shift+W 关闭当前窗口</p>\n<p>Command+[ 或者 ] 前进或者回退</p>\n<p>Command+左右方向键 前进或者后退</p>\n<p>Command+Option+U 查看网页源代码</p>\n<h4 id=\"iTerm2快捷键\"><a href=\"#iTerm2快捷键\" class=\"headerlink\" title=\"iTerm2快捷键\"></a>iTerm2快捷键</h4><p>iTerm2中的文本，选中即复制，这个其实没必要，我现在都习惯了选中后 cmd+c，而且当你选择替换目标时候由于这个选中即复制，会覆盖掉你的剪切板</p>\n<p>Command+D 水平分隔出一个终端</p>\n<p>Command+Shift+D 垂直分割出一个终端</p>\n<p>可以配置透明度，Command+U快速切换透明与否</p>\n<p>可以配置全局唤出快捷键，我自己配置的是Command+U</p>\n<p>可以配置快捷悬浮，Hotkey window</p>\n<p>Command+Shift+H 查看复制历史</p>\n<p>Command+Enter 快速切换全屏与否</p>\n<h4 id=\"CLI-命令行-快捷键\"><a href=\"#CLI-命令行-快捷键\" class=\"headerlink\" title=\"CLI(命令行)快捷键\"></a>CLI(命令行)快捷键</h4><p>Mac本身的特点就是GUI和CLI的完美结合（很多Linux的爱好者，又不想被Linux的桌面、各种驱动、不兼容等等杂七杂八的问题折腾的，大可选择Mac）。</p>\n<p>首先教一个最重要的东西<br>记住按Tab补全，这是命令行用的爽的根源。</p>\n<p>Ctrl+A 回到行首</p>\n<p>Ctrl+E 到行末</p>\n<p>Ctrl+U 删除一行</p>\n<h2 id=\"格式转换\"><a href=\"#格式转换\" class=\"headerlink\" title=\"格式转换\"></a>格式转换</h2><p>有时候需要把 png 等格式的图片转成 jpg 的格式，于是有同学就去到处找格式转换软件了。<br>其实在 Mac 中直接更改图片的扩展名，即可自动转成相应地格式~试试吧，如果你改格式前看了文件修改日期，改完格式后你会发现修改日期依然没变，至于原因是什么，需要你有图片的文件格式的相关知识。</p>\n<h2 id=\"Launchpad与Dock\"><a href=\"#Launchpad与Dock\" class=\"headerlink\" title=\"Launchpad与Dock\"></a>Launchpad与Dock</h2><p>Launchpad是指，你在触摸板上用五指向中间收拢，出现的全是APP的页面，半透明的。</p>\n<p>Dock是指，最下方的摆满APP的一栏，在Dock上你可以放上最常用的APP。</p>\n<p>调整launchpad的图标大小：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//把行数重定义成6</span><br><span class=\"line\">delete write com.apple.dock springboard-rows -int 6</span><br><span class=\"line\">//把行数充定义成默认</span><br><span class=\"line\">defaults write com.apple.dock springboard-rows Default</span><br><span class=\"line\">//删除定义好的行数（恢复默认）</span><br><span class=\"line\">defaults delete com.apple.dock springboard-rows</span><br><span class=\"line\">//把列数定义成默认</span><br><span class=\"line\">defaults write com.apple.dock springboard-columns Default</span><br><span class=\"line\">//重置 Launchpad，效果就是 launchpad 的布局全给你打乱了，而第一页恢复默认，建议不要使用</span><br><span class=\"line\">defaults write com.apple.dock ResetLaunchPad -bool TRUE</span><br><span class=\"line\">//重启 Launchpad，并使你前面的设置生效</span><br><span class=\"line\">killall Dock</span><br></pre></td></tr></table></figure>\n<p>在appstore下载一个软件到一半，然后在Application删除了该软件，结果在launchpad中留下了一个垃圾残留空图标。<br>删除launchpad中的垃圾残留图标，只需拖拽到下载文件夹。其他方法都试过（无效），比如按住图标几秒，出现一个叉，点击叉，删除，没用。在Application找到相应项删除没用。</p>\n<h2 id=\"Option的妙用\"><a href=\"#Option的妙用\" class=\"headerlink\" title=\"Option的妙用\"></a>Option的妙用</h2><p>下面再讲些不常用但是有意思的：</p>\n<p>除了cmd是常用的，option键也值得我们关注，下面讲几个option的妙用：</p>\n<p>按住option+shift可以微调（1/4微调）音量、键盘背光亮度和屏幕亮度，按住option再按其他字母键等，会出现奇怪的字符¥©<br>©œ∑®†¥åß©≈ç等等。</p>\n<p>按住option再把鼠标移到Dock上的APP上，你会发现退出变成了强制退出，怎么样option键还是挺强大的吧。</p>\n<h3 id=\"数学符号\"><a href=\"#数学符号\" class=\"headerlink\" title=\"数学符号\"></a>数学符号</h3><p>约等于: Option + X = ≈<br>度数: Shift + Option + 8 = °<br>除号: Option + / = ÷<br>无穷: Option + 5 = ∞<br>大于等于和小于等于: Option + , 和 Option + . = ≤ 和 ≥<br>不等于: Option + = = ≠<br>圆周率: Option + P = π<br>加减: Shift + Option + = = ±<br>开方: Option + V = √<br>求和符号: Option + W = ∑</p>\n<h3 id=\"输入特殊符号\"><a href=\"#输入特殊符号\" class=\"headerlink\" title=\"输入特殊符号\"></a>输入特殊符号</h3><p>版权符号: Option + G = ©</p>\n<p>人民币符号: Option + Y = ¥</p>\n"},{"title":"那些年我读过的好故事","date":"2017-01-09T16:00:00.000Z","comments":1,"_content":"\n现代人们每天接触的信息量太过庞大，我们都试图把自己的时间花在有意义的、美好的事上和有效的信息上。所以我打算总结一下自己看过的一些作品，无论是电影、小说、连续剧、游戏、音乐都一并算上吧。影视剧和小说都属于 故事 类，音乐属于 艺术，游戏则是带有 故事的艺术（循环元素越多，信息含量越低，越消磨人的时间，而遗憾的是大多数游戏中的循环元素太多，而且含有上瘾设计元素，毕竟人家要挣钱，让你上瘾是在许多游戏厂商考虑之内的事）。\n\n>许多游戏其实有上瘾成分，所以含有上瘾设计元素的游戏，建议慎重考虑，不要入坑，这里点名：红色警戒、魔兽世界、魔兽争霸、英雄联盟、王者荣耀、炉石传说，这些游戏都非常容易上瘾，特别是跟小伙伴一起玩的时候，另外电子游戏跟传统游戏最大的区别就是：你随时都可以开始玩，这是很可怕的，如果你把所有时间都花在游戏上，那么就会耽误很多事。所以请相信下面我要说的这句话：如果你长时间沉浸式的玩游戏，游戏将抽空你所有的注意力，让你睡觉的时候脑子里都是这个东西，你甚至没有时间吃饭，拿衣服去洗衣机里洗。其实像：饥荒、我的世界这类游戏沉浸感也很强，玩游戏嘛就是等你玩出一种沉浸感，然后就开始轻度上瘾了，年轻人为啥喜欢玩游戏，这就跟老人下象棋是一样的，就是时间太多了，就用游戏消遣掉了，你听过中年人打游戏颓废掉的吗，应该很少吧，但我还是发现了一个游戏中的清流：纪念碑谷，这完全算艺术的范畴了，我通关后完全没有一点上瘾的感觉，只有过瘾的感觉，真是一场视觉和创意的盛宴，时间和钱都花的值了，我只玩了一遍，就像看电影一样，很多电影你也只会看一遍。\n\n我们人就是喜欢听故事，好的故事更是令人神往，同时也能卖到好价钱，这一篇重点说故事类的作品，书籍类的记录到一定数量就新开一篇推荐。\n\n>好的作品可以陶冶人的性格，构建气质的最底层。\n\n这里我列出来的每一部都是我自己看过的，为了纪念那个时候的时光吧。\n\n当你列出来这么多看过的东西的时候，真的有种惊讶的感觉，我们总说时间太短、太少，其实我们花在了其他空间，在这些作品中，我们把自己带入进去，从而度过了短暂而精彩的一生。人生和这些电影相比有太多的冗杂和琐事，太多的、太漫长的过程，而人都是短视的、急功近利的、我们浮躁、我们想要精炼的一辈子，其实我们都错了，人生不过是一个过程，谁都逃不过一死，把自己沉淀下来，享受过程，缓慢的生长。\n\n>以过程为导向才是正确的人生态度，结果只是一瞬，你的人生应该也必须由过程组成。\n\n## 电影\n\n### 印度电影\n\n- 三傻大闹宝莱坞 3 Idiots (2009)\n- 小萝莉的猴神大叔 (2015)\n- 外星醉汉PK地球神 (2014)\n- 摔跤吧，爸爸（2017）\n\n然后是豆瓣上评出的经典影片：\n\n经典永远不会老去\n\n- 海上钢琴师 La leggenda del pianista sull’oceano (1998)\n- 肖申克的救赎 The Shawshank Redemption (1994)\n- 盗梦空间 Inception (2010)\n- 楚门的世界 The True man Show (1998)\n- 阿甘正传 Forrest Gump (1994)\n- 当幸福来敲门 The Pursuit of Happyness (2006)\n- V字仇杀队 V for Vendetta (2005)\n- 黑客帝国 The Matrix (1999) 三部\n- 布达佩斯大饭店 The Grand Budapest Hotel (2014)\n- 霸王别姬 (1993)\n- 这个杀手不太冷 Léon (1994)\n- 罗马假日 Roman Holiday (1953)\n- 泰坦尼克号 Titanic (1997)\n- 辛德勒的名单 Schindler’s List (1993)\n- 天堂电影院 Nuovo Cinema Paradiso (1988)\n\n然后是我最爱的科幻片、悬疑片类型：\n\n- 黑侠\n- 这个男人来自地球 The Man from Earth (2007)\n- 超时空接触 Contact (1997)\n- 星际穿越 Interstellar (2014)\n- 源代码 Source Code (2011)\n- 蝴蝶效应 The Butterfly Effect (2004)\n- 致命魔术 The Prestige (2006)\n- 阿凡达 Avatar (2009)\n- 恐怖游轮 Triangle (2009)\n- 生化危机系列\n- 异次元骇客 The thirteenth floor (1999)\n- 异星战场\n- 复仇者联盟 The Avengers (2012)\n- 钢铁侠系列\n- 绿巨人系列\n- 大鱼\n- 无姓之人\n- 土拨鼠之日\n\n然后是反正好看系列：\n\n- 冰雪奇缘 Frozen (2013)\n- 疯狂动物城\n- 暮光之城系列\n- 哈利波特系列\n- 速度与激情系列\n- 魔戒三部曲\n- 驯龙高手1、2\n- 疯狂的麦克斯4：狂暴之路 Mad Max: Fury Road (2015)\n- 空中监狱 Con Air (1997)\n\n国产电影：\n\n- 翻滚吧！阿信 (2011)\n- 夏日乐悠悠 (2011)\n- 破风 (2015)\n\n没错，三部里面都有彭于晏\n\n## 连续剧\n\n### 美剧 && 英剧\n\n#### 美剧\n\n- 冰与火之歌，又名：权力的游戏，A Song of Ice and Fire: Game of Thrones\n- 行尸走肉，the walking dead（刚开始看是新鲜，后来就没啥价值了，无非是讲人性罢了）\n- 西部世界，westworld\n- 硅谷\n- 达芬奇密码\n\n#### 英剧\n\n- 神探夏洛克\n- 黑镜\n\n### 日剧\n\n- legal high（胜者即正义）\n- 半泽直树\n- 逃避可耻但有用\n\n### 国产电视剧\n\n- 琅琊榜\n- 大好时光（并不值得看，当时看这个完全是奔着胡歌去的，看这个剧有种白开水的味道，有种淡淡的生活味儿，另外这个剧传递给你一种极正的三观）\n- 李小龙传奇\n- 恰同学少年\n- 仙剑1，3\n\n#### 偶像剧\n\n微微一笑很倾城（并不值得看，除了让你羡慕嫉妒恨，或者活在梦里，没什么太大的意义，主角都太过完美了）\n\n#### 网剧\n\n- 一起同过窗（并不值得看，大学过完了才看这个剧，对学生时代总有种意犹未尽的感觉，这个剧带你再次体验那些鸡毛蒜皮的青春时光）\n- 白夜追凶\n- 太子妃升职记（你要是想猎个奇，那就试试，其实没啥好看的，不推荐）\n\n### 韩剧\n\n- 爱在哈佛\n- 太阳的后裔\n- W 两个世界\n\n## 纪录片\n\n- 人生7年，the up series\n- 互联网时代（央视）(2014)\n- 互联网之子 The Internet’s Own Boy: The Story of Aaron Swartz (2014)\n- 史蒂夫·乔布斯：遗失的访谈 Steve Jobs: The Lost Interview (2012)\n- 舌尖上的中国\n- wild China，美丽中国，BBC产的\n- 小森林（春夏秋冬）\n\n## 动漫\n\n### 国产\n\n- 秦时明月\n- 天行九歌\n- 我是白小飞\n\n### 日本动漫\n\n- 火影忍者\n- 海贼王\n- 东京食尸鬼\n- 寄生兽\n- 进击的巨人\n- 宫崎骏系列\n- 天空之城\n- 龙猫\n- 千与千寻\n- 风之谷\n- 哈尔的移动城堡\n- 起风了\n- 萤火之森\n\n## 小说\n\n- 三体\n- 缥缈之旅（修真小说的鼻祖，在喜马拉雅上听完的，并没有看文字小说，另外很多时候听着睡着了，不停的打怪升级而已吧，太长了）\n- 王小波全集（我主要关注的是他这个人，所以他的所有作品都值得看看，我主要看了《沉默的大多数》）\n- 和空姐同居的日子、第一次亲密接触。这两个也是听的广播剧，男女双人广播剧，言情类型的，不过也是红极一时的作品。在夜里温暖单身狗的小心脏。\n- 陈二狗的妖孽人生（YY小说，在喜马拉雅上听的，同时也看了点网剧）\n\n## 书籍\n\n时间管理的幸福学\n","source":"_posts/2017/2017-01-10-那些年我读过的好故事.md","raw":"---\ntitle: 那些年我读过的好故事\ndate: 2017-01-10\ncategories: [随笔]\ncomments: true\n---\n\n现代人们每天接触的信息量太过庞大，我们都试图把自己的时间花在有意义的、美好的事上和有效的信息上。所以我打算总结一下自己看过的一些作品，无论是电影、小说、连续剧、游戏、音乐都一并算上吧。影视剧和小说都属于 故事 类，音乐属于 艺术，游戏则是带有 故事的艺术（循环元素越多，信息含量越低，越消磨人的时间，而遗憾的是大多数游戏中的循环元素太多，而且含有上瘾设计元素，毕竟人家要挣钱，让你上瘾是在许多游戏厂商考虑之内的事）。\n\n>许多游戏其实有上瘾成分，所以含有上瘾设计元素的游戏，建议慎重考虑，不要入坑，这里点名：红色警戒、魔兽世界、魔兽争霸、英雄联盟、王者荣耀、炉石传说，这些游戏都非常容易上瘾，特别是跟小伙伴一起玩的时候，另外电子游戏跟传统游戏最大的区别就是：你随时都可以开始玩，这是很可怕的，如果你把所有时间都花在游戏上，那么就会耽误很多事。所以请相信下面我要说的这句话：如果你长时间沉浸式的玩游戏，游戏将抽空你所有的注意力，让你睡觉的时候脑子里都是这个东西，你甚至没有时间吃饭，拿衣服去洗衣机里洗。其实像：饥荒、我的世界这类游戏沉浸感也很强，玩游戏嘛就是等你玩出一种沉浸感，然后就开始轻度上瘾了，年轻人为啥喜欢玩游戏，这就跟老人下象棋是一样的，就是时间太多了，就用游戏消遣掉了，你听过中年人打游戏颓废掉的吗，应该很少吧，但我还是发现了一个游戏中的清流：纪念碑谷，这完全算艺术的范畴了，我通关后完全没有一点上瘾的感觉，只有过瘾的感觉，真是一场视觉和创意的盛宴，时间和钱都花的值了，我只玩了一遍，就像看电影一样，很多电影你也只会看一遍。\n\n我们人就是喜欢听故事，好的故事更是令人神往，同时也能卖到好价钱，这一篇重点说故事类的作品，书籍类的记录到一定数量就新开一篇推荐。\n\n>好的作品可以陶冶人的性格，构建气质的最底层。\n\n这里我列出来的每一部都是我自己看过的，为了纪念那个时候的时光吧。\n\n当你列出来这么多看过的东西的时候，真的有种惊讶的感觉，我们总说时间太短、太少，其实我们花在了其他空间，在这些作品中，我们把自己带入进去，从而度过了短暂而精彩的一生。人生和这些电影相比有太多的冗杂和琐事，太多的、太漫长的过程，而人都是短视的、急功近利的、我们浮躁、我们想要精炼的一辈子，其实我们都错了，人生不过是一个过程，谁都逃不过一死，把自己沉淀下来，享受过程，缓慢的生长。\n\n>以过程为导向才是正确的人生态度，结果只是一瞬，你的人生应该也必须由过程组成。\n\n## 电影\n\n### 印度电影\n\n- 三傻大闹宝莱坞 3 Idiots (2009)\n- 小萝莉的猴神大叔 (2015)\n- 外星醉汉PK地球神 (2014)\n- 摔跤吧，爸爸（2017）\n\n然后是豆瓣上评出的经典影片：\n\n经典永远不会老去\n\n- 海上钢琴师 La leggenda del pianista sull’oceano (1998)\n- 肖申克的救赎 The Shawshank Redemption (1994)\n- 盗梦空间 Inception (2010)\n- 楚门的世界 The True man Show (1998)\n- 阿甘正传 Forrest Gump (1994)\n- 当幸福来敲门 The Pursuit of Happyness (2006)\n- V字仇杀队 V for Vendetta (2005)\n- 黑客帝国 The Matrix (1999) 三部\n- 布达佩斯大饭店 The Grand Budapest Hotel (2014)\n- 霸王别姬 (1993)\n- 这个杀手不太冷 Léon (1994)\n- 罗马假日 Roman Holiday (1953)\n- 泰坦尼克号 Titanic (1997)\n- 辛德勒的名单 Schindler’s List (1993)\n- 天堂电影院 Nuovo Cinema Paradiso (1988)\n\n然后是我最爱的科幻片、悬疑片类型：\n\n- 黑侠\n- 这个男人来自地球 The Man from Earth (2007)\n- 超时空接触 Contact (1997)\n- 星际穿越 Interstellar (2014)\n- 源代码 Source Code (2011)\n- 蝴蝶效应 The Butterfly Effect (2004)\n- 致命魔术 The Prestige (2006)\n- 阿凡达 Avatar (2009)\n- 恐怖游轮 Triangle (2009)\n- 生化危机系列\n- 异次元骇客 The thirteenth floor (1999)\n- 异星战场\n- 复仇者联盟 The Avengers (2012)\n- 钢铁侠系列\n- 绿巨人系列\n- 大鱼\n- 无姓之人\n- 土拨鼠之日\n\n然后是反正好看系列：\n\n- 冰雪奇缘 Frozen (2013)\n- 疯狂动物城\n- 暮光之城系列\n- 哈利波特系列\n- 速度与激情系列\n- 魔戒三部曲\n- 驯龙高手1、2\n- 疯狂的麦克斯4：狂暴之路 Mad Max: Fury Road (2015)\n- 空中监狱 Con Air (1997)\n\n国产电影：\n\n- 翻滚吧！阿信 (2011)\n- 夏日乐悠悠 (2011)\n- 破风 (2015)\n\n没错，三部里面都有彭于晏\n\n## 连续剧\n\n### 美剧 && 英剧\n\n#### 美剧\n\n- 冰与火之歌，又名：权力的游戏，A Song of Ice and Fire: Game of Thrones\n- 行尸走肉，the walking dead（刚开始看是新鲜，后来就没啥价值了，无非是讲人性罢了）\n- 西部世界，westworld\n- 硅谷\n- 达芬奇密码\n\n#### 英剧\n\n- 神探夏洛克\n- 黑镜\n\n### 日剧\n\n- legal high（胜者即正义）\n- 半泽直树\n- 逃避可耻但有用\n\n### 国产电视剧\n\n- 琅琊榜\n- 大好时光（并不值得看，当时看这个完全是奔着胡歌去的，看这个剧有种白开水的味道，有种淡淡的生活味儿，另外这个剧传递给你一种极正的三观）\n- 李小龙传奇\n- 恰同学少年\n- 仙剑1，3\n\n#### 偶像剧\n\n微微一笑很倾城（并不值得看，除了让你羡慕嫉妒恨，或者活在梦里，没什么太大的意义，主角都太过完美了）\n\n#### 网剧\n\n- 一起同过窗（并不值得看，大学过完了才看这个剧，对学生时代总有种意犹未尽的感觉，这个剧带你再次体验那些鸡毛蒜皮的青春时光）\n- 白夜追凶\n- 太子妃升职记（你要是想猎个奇，那就试试，其实没啥好看的，不推荐）\n\n### 韩剧\n\n- 爱在哈佛\n- 太阳的后裔\n- W 两个世界\n\n## 纪录片\n\n- 人生7年，the up series\n- 互联网时代（央视）(2014)\n- 互联网之子 The Internet’s Own Boy: The Story of Aaron Swartz (2014)\n- 史蒂夫·乔布斯：遗失的访谈 Steve Jobs: The Lost Interview (2012)\n- 舌尖上的中国\n- wild China，美丽中国，BBC产的\n- 小森林（春夏秋冬）\n\n## 动漫\n\n### 国产\n\n- 秦时明月\n- 天行九歌\n- 我是白小飞\n\n### 日本动漫\n\n- 火影忍者\n- 海贼王\n- 东京食尸鬼\n- 寄生兽\n- 进击的巨人\n- 宫崎骏系列\n- 天空之城\n- 龙猫\n- 千与千寻\n- 风之谷\n- 哈尔的移动城堡\n- 起风了\n- 萤火之森\n\n## 小说\n\n- 三体\n- 缥缈之旅（修真小说的鼻祖，在喜马拉雅上听完的，并没有看文字小说，另外很多时候听着睡着了，不停的打怪升级而已吧，太长了）\n- 王小波全集（我主要关注的是他这个人，所以他的所有作品都值得看看，我主要看了《沉默的大多数》）\n- 和空姐同居的日子、第一次亲密接触。这两个也是听的广播剧，男女双人广播剧，言情类型的，不过也是红极一时的作品。在夜里温暖单身狗的小心脏。\n- 陈二狗的妖孽人生（YY小说，在喜马拉雅上听的，同时也看了点网剧）\n\n## 书籍\n\n时间管理的幸福学\n","slug":"那些年我读过的好故事","published":1,"updated":"2018-04-25T07:39:25.083Z","layout":"post","photos":[],"link":"","_id":"cjm2w8dcs000vfgpxcaoa7hxy","content":"<p>现代人们每天接触的信息量太过庞大，我们都试图把自己的时间花在有意义的、美好的事上和有效的信息上。所以我打算总结一下自己看过的一些作品，无论是电影、小说、连续剧、游戏、音乐都一并算上吧。影视剧和小说都属于 故事 类，音乐属于 艺术，游戏则是带有 故事的艺术（循环元素越多，信息含量越低，越消磨人的时间，而遗憾的是大多数游戏中的循环元素太多，而且含有上瘾设计元素，毕竟人家要挣钱，让你上瘾是在许多游戏厂商考虑之内的事）。</p>\n<blockquote>\n<p>许多游戏其实有上瘾成分，所以含有上瘾设计元素的游戏，建议慎重考虑，不要入坑，这里点名：红色警戒、魔兽世界、魔兽争霸、英雄联盟、王者荣耀、炉石传说，这些游戏都非常容易上瘾，特别是跟小伙伴一起玩的时候，另外电子游戏跟传统游戏最大的区别就是：你随时都可以开始玩，这是很可怕的，如果你把所有时间都花在游戏上，那么就会耽误很多事。所以请相信下面我要说的这句话：如果你长时间沉浸式的玩游戏，游戏将抽空你所有的注意力，让你睡觉的时候脑子里都是这个东西，你甚至没有时间吃饭，拿衣服去洗衣机里洗。其实像：饥荒、我的世界这类游戏沉浸感也很强，玩游戏嘛就是等你玩出一种沉浸感，然后就开始轻度上瘾了，年轻人为啥喜欢玩游戏，这就跟老人下象棋是一样的，就是时间太多了，就用游戏消遣掉了，你听过中年人打游戏颓废掉的吗，应该很少吧，但我还是发现了一个游戏中的清流：纪念碑谷，这完全算艺术的范畴了，我通关后完全没有一点上瘾的感觉，只有过瘾的感觉，真是一场视觉和创意的盛宴，时间和钱都花的值了，我只玩了一遍，就像看电影一样，很多电影你也只会看一遍。</p>\n</blockquote>\n<p>我们人就是喜欢听故事，好的故事更是令人神往，同时也能卖到好价钱，这一篇重点说故事类的作品，书籍类的记录到一定数量就新开一篇推荐。</p>\n<blockquote>\n<p>好的作品可以陶冶人的性格，构建气质的最底层。</p>\n</blockquote>\n<p>这里我列出来的每一部都是我自己看过的，为了纪念那个时候的时光吧。</p>\n<p>当你列出来这么多看过的东西的时候，真的有种惊讶的感觉，我们总说时间太短、太少，其实我们花在了其他空间，在这些作品中，我们把自己带入进去，从而度过了短暂而精彩的一生。人生和这些电影相比有太多的冗杂和琐事，太多的、太漫长的过程，而人都是短视的、急功近利的、我们浮躁、我们想要精炼的一辈子，其实我们都错了，人生不过是一个过程，谁都逃不过一死，把自己沉淀下来，享受过程，缓慢的生长。</p>\n<blockquote>\n<p>以过程为导向才是正确的人生态度，结果只是一瞬，你的人生应该也必须由过程组成。</p>\n</blockquote>\n<h2 id=\"电影\"><a href=\"#电影\" class=\"headerlink\" title=\"电影\"></a>电影</h2><h3 id=\"印度电影\"><a href=\"#印度电影\" class=\"headerlink\" title=\"印度电影\"></a>印度电影</h3><ul>\n<li>三傻大闹宝莱坞 3 Idiots (2009)</li>\n<li>小萝莉的猴神大叔 (2015)</li>\n<li>外星醉汉PK地球神 (2014)</li>\n<li>摔跤吧，爸爸（2017）</li>\n</ul>\n<p>然后是豆瓣上评出的经典影片：</p>\n<p>经典永远不会老去</p>\n<ul>\n<li>海上钢琴师 La leggenda del pianista sull’oceano (1998)</li>\n<li>肖申克的救赎 The Shawshank Redemption (1994)</li>\n<li>盗梦空间 Inception (2010)</li>\n<li>楚门的世界 The True man Show (1998)</li>\n<li>阿甘正传 Forrest Gump (1994)</li>\n<li>当幸福来敲门 The Pursuit of Happyness (2006)</li>\n<li>V字仇杀队 V for Vendetta (2005)</li>\n<li>黑客帝国 The Matrix (1999) 三部</li>\n<li>布达佩斯大饭店 The Grand Budapest Hotel (2014)</li>\n<li>霸王别姬 (1993)</li>\n<li>这个杀手不太冷 Léon (1994)</li>\n<li>罗马假日 Roman Holiday (1953)</li>\n<li>泰坦尼克号 Titanic (1997)</li>\n<li>辛德勒的名单 Schindler’s List (1993)</li>\n<li>天堂电影院 Nuovo Cinema Paradiso (1988)</li>\n</ul>\n<p>然后是我最爱的科幻片、悬疑片类型：</p>\n<ul>\n<li>黑侠</li>\n<li>这个男人来自地球 The Man from Earth (2007)</li>\n<li>超时空接触 Contact (1997)</li>\n<li>星际穿越 Interstellar (2014)</li>\n<li>源代码 Source Code (2011)</li>\n<li>蝴蝶效应 The Butterfly Effect (2004)</li>\n<li>致命魔术 The Prestige (2006)</li>\n<li>阿凡达 Avatar (2009)</li>\n<li>恐怖游轮 Triangle (2009)</li>\n<li>生化危机系列</li>\n<li>异次元骇客 The thirteenth floor (1999)</li>\n<li>异星战场</li>\n<li>复仇者联盟 The Avengers (2012)</li>\n<li>钢铁侠系列</li>\n<li>绿巨人系列</li>\n<li>大鱼</li>\n<li>无姓之人</li>\n<li>土拨鼠之日</li>\n</ul>\n<p>然后是反正好看系列：</p>\n<ul>\n<li>冰雪奇缘 Frozen (2013)</li>\n<li>疯狂动物城</li>\n<li>暮光之城系列</li>\n<li>哈利波特系列</li>\n<li>速度与激情系列</li>\n<li>魔戒三部曲</li>\n<li>驯龙高手1、2</li>\n<li>疯狂的麦克斯4：狂暴之路 Mad Max: Fury Road (2015)</li>\n<li>空中监狱 Con Air (1997)</li>\n</ul>\n<p>国产电影：</p>\n<ul>\n<li>翻滚吧！阿信 (2011)</li>\n<li>夏日乐悠悠 (2011)</li>\n<li>破风 (2015)</li>\n</ul>\n<p>没错，三部里面都有彭于晏</p>\n<h2 id=\"连续剧\"><a href=\"#连续剧\" class=\"headerlink\" title=\"连续剧\"></a>连续剧</h2><h3 id=\"美剧-amp-amp-英剧\"><a href=\"#美剧-amp-amp-英剧\" class=\"headerlink\" title=\"美剧 &amp;&amp; 英剧\"></a>美剧 &amp;&amp; 英剧</h3><h4 id=\"美剧\"><a href=\"#美剧\" class=\"headerlink\" title=\"美剧\"></a>美剧</h4><ul>\n<li>冰与火之歌，又名：权力的游戏，A Song of Ice and Fire: Game of Thrones</li>\n<li>行尸走肉，the walking dead（刚开始看是新鲜，后来就没啥价值了，无非是讲人性罢了）</li>\n<li>西部世界，westworld</li>\n<li>硅谷</li>\n<li>达芬奇密码</li>\n</ul>\n<h4 id=\"英剧\"><a href=\"#英剧\" class=\"headerlink\" title=\"英剧\"></a>英剧</h4><ul>\n<li>神探夏洛克</li>\n<li>黑镜</li>\n</ul>\n<h3 id=\"日剧\"><a href=\"#日剧\" class=\"headerlink\" title=\"日剧\"></a>日剧</h3><ul>\n<li>legal high（胜者即正义）</li>\n<li>半泽直树</li>\n<li>逃避可耻但有用</li>\n</ul>\n<h3 id=\"国产电视剧\"><a href=\"#国产电视剧\" class=\"headerlink\" title=\"国产电视剧\"></a>国产电视剧</h3><ul>\n<li>琅琊榜</li>\n<li>大好时光（并不值得看，当时看这个完全是奔着胡歌去的，看这个剧有种白开水的味道，有种淡淡的生活味儿，另外这个剧传递给你一种极正的三观）</li>\n<li>李小龙传奇</li>\n<li>恰同学少年</li>\n<li>仙剑1，3</li>\n</ul>\n<h4 id=\"偶像剧\"><a href=\"#偶像剧\" class=\"headerlink\" title=\"偶像剧\"></a>偶像剧</h4><p>微微一笑很倾城（并不值得看，除了让你羡慕嫉妒恨，或者活在梦里，没什么太大的意义，主角都太过完美了）</p>\n<h4 id=\"网剧\"><a href=\"#网剧\" class=\"headerlink\" title=\"网剧\"></a>网剧</h4><ul>\n<li>一起同过窗（并不值得看，大学过完了才看这个剧，对学生时代总有种意犹未尽的感觉，这个剧带你再次体验那些鸡毛蒜皮的青春时光）</li>\n<li>白夜追凶</li>\n<li>太子妃升职记（你要是想猎个奇，那就试试，其实没啥好看的，不推荐）</li>\n</ul>\n<h3 id=\"韩剧\"><a href=\"#韩剧\" class=\"headerlink\" title=\"韩剧\"></a>韩剧</h3><ul>\n<li>爱在哈佛</li>\n<li>太阳的后裔</li>\n<li>W 两个世界</li>\n</ul>\n<h2 id=\"纪录片\"><a href=\"#纪录片\" class=\"headerlink\" title=\"纪录片\"></a>纪录片</h2><ul>\n<li>人生7年，the up series</li>\n<li>互联网时代（央视）(2014)</li>\n<li>互联网之子 The Internet’s Own Boy: The Story of Aaron Swartz (2014)</li>\n<li>史蒂夫·乔布斯：遗失的访谈 Steve Jobs: The Lost Interview (2012)</li>\n<li>舌尖上的中国</li>\n<li>wild China，美丽中国，BBC产的</li>\n<li>小森林（春夏秋冬）</li>\n</ul>\n<h2 id=\"动漫\"><a href=\"#动漫\" class=\"headerlink\" title=\"动漫\"></a>动漫</h2><h3 id=\"国产\"><a href=\"#国产\" class=\"headerlink\" title=\"国产\"></a>国产</h3><ul>\n<li>秦时明月</li>\n<li>天行九歌</li>\n<li>我是白小飞</li>\n</ul>\n<h3 id=\"日本动漫\"><a href=\"#日本动漫\" class=\"headerlink\" title=\"日本动漫\"></a>日本动漫</h3><ul>\n<li>火影忍者</li>\n<li>海贼王</li>\n<li>东京食尸鬼</li>\n<li>寄生兽</li>\n<li>进击的巨人</li>\n<li>宫崎骏系列</li>\n<li>天空之城</li>\n<li>龙猫</li>\n<li>千与千寻</li>\n<li>风之谷</li>\n<li>哈尔的移动城堡</li>\n<li>起风了</li>\n<li>萤火之森</li>\n</ul>\n<h2 id=\"小说\"><a href=\"#小说\" class=\"headerlink\" title=\"小说\"></a>小说</h2><ul>\n<li>三体</li>\n<li>缥缈之旅（修真小说的鼻祖，在喜马拉雅上听完的，并没有看文字小说，另外很多时候听着睡着了，不停的打怪升级而已吧，太长了）</li>\n<li>王小波全集（我主要关注的是他这个人，所以他的所有作品都值得看看，我主要看了《沉默的大多数》）</li>\n<li>和空姐同居的日子、第一次亲密接触。这两个也是听的广播剧，男女双人广播剧，言情类型的，不过也是红极一时的作品。在夜里温暖单身狗的小心脏。</li>\n<li>陈二狗的妖孽人生（YY小说，在喜马拉雅上听的，同时也看了点网剧）</li>\n</ul>\n<h2 id=\"书籍\"><a href=\"#书籍\" class=\"headerlink\" title=\"书籍\"></a>书籍</h2><p>时间管理的幸福学</p>\n","site":{"data":{}},"excerpt":"","more":"<p>现代人们每天接触的信息量太过庞大，我们都试图把自己的时间花在有意义的、美好的事上和有效的信息上。所以我打算总结一下自己看过的一些作品，无论是电影、小说、连续剧、游戏、音乐都一并算上吧。影视剧和小说都属于 故事 类，音乐属于 艺术，游戏则是带有 故事的艺术（循环元素越多，信息含量越低，越消磨人的时间，而遗憾的是大多数游戏中的循环元素太多，而且含有上瘾设计元素，毕竟人家要挣钱，让你上瘾是在许多游戏厂商考虑之内的事）。</p>\n<blockquote>\n<p>许多游戏其实有上瘾成分，所以含有上瘾设计元素的游戏，建议慎重考虑，不要入坑，这里点名：红色警戒、魔兽世界、魔兽争霸、英雄联盟、王者荣耀、炉石传说，这些游戏都非常容易上瘾，特别是跟小伙伴一起玩的时候，另外电子游戏跟传统游戏最大的区别就是：你随时都可以开始玩，这是很可怕的，如果你把所有时间都花在游戏上，那么就会耽误很多事。所以请相信下面我要说的这句话：如果你长时间沉浸式的玩游戏，游戏将抽空你所有的注意力，让你睡觉的时候脑子里都是这个东西，你甚至没有时间吃饭，拿衣服去洗衣机里洗。其实像：饥荒、我的世界这类游戏沉浸感也很强，玩游戏嘛就是等你玩出一种沉浸感，然后就开始轻度上瘾了，年轻人为啥喜欢玩游戏，这就跟老人下象棋是一样的，就是时间太多了，就用游戏消遣掉了，你听过中年人打游戏颓废掉的吗，应该很少吧，但我还是发现了一个游戏中的清流：纪念碑谷，这完全算艺术的范畴了，我通关后完全没有一点上瘾的感觉，只有过瘾的感觉，真是一场视觉和创意的盛宴，时间和钱都花的值了，我只玩了一遍，就像看电影一样，很多电影你也只会看一遍。</p>\n</blockquote>\n<p>我们人就是喜欢听故事，好的故事更是令人神往，同时也能卖到好价钱，这一篇重点说故事类的作品，书籍类的记录到一定数量就新开一篇推荐。</p>\n<blockquote>\n<p>好的作品可以陶冶人的性格，构建气质的最底层。</p>\n</blockquote>\n<p>这里我列出来的每一部都是我自己看过的，为了纪念那个时候的时光吧。</p>\n<p>当你列出来这么多看过的东西的时候，真的有种惊讶的感觉，我们总说时间太短、太少，其实我们花在了其他空间，在这些作品中，我们把自己带入进去，从而度过了短暂而精彩的一生。人生和这些电影相比有太多的冗杂和琐事，太多的、太漫长的过程，而人都是短视的、急功近利的、我们浮躁、我们想要精炼的一辈子，其实我们都错了，人生不过是一个过程，谁都逃不过一死，把自己沉淀下来，享受过程，缓慢的生长。</p>\n<blockquote>\n<p>以过程为导向才是正确的人生态度，结果只是一瞬，你的人生应该也必须由过程组成。</p>\n</blockquote>\n<h2 id=\"电影\"><a href=\"#电影\" class=\"headerlink\" title=\"电影\"></a>电影</h2><h3 id=\"印度电影\"><a href=\"#印度电影\" class=\"headerlink\" title=\"印度电影\"></a>印度电影</h3><ul>\n<li>三傻大闹宝莱坞 3 Idiots (2009)</li>\n<li>小萝莉的猴神大叔 (2015)</li>\n<li>外星醉汉PK地球神 (2014)</li>\n<li>摔跤吧，爸爸（2017）</li>\n</ul>\n<p>然后是豆瓣上评出的经典影片：</p>\n<p>经典永远不会老去</p>\n<ul>\n<li>海上钢琴师 La leggenda del pianista sull’oceano (1998)</li>\n<li>肖申克的救赎 The Shawshank Redemption (1994)</li>\n<li>盗梦空间 Inception (2010)</li>\n<li>楚门的世界 The True man Show (1998)</li>\n<li>阿甘正传 Forrest Gump (1994)</li>\n<li>当幸福来敲门 The Pursuit of Happyness (2006)</li>\n<li>V字仇杀队 V for Vendetta (2005)</li>\n<li>黑客帝国 The Matrix (1999) 三部</li>\n<li>布达佩斯大饭店 The Grand Budapest Hotel (2014)</li>\n<li>霸王别姬 (1993)</li>\n<li>这个杀手不太冷 Léon (1994)</li>\n<li>罗马假日 Roman Holiday (1953)</li>\n<li>泰坦尼克号 Titanic (1997)</li>\n<li>辛德勒的名单 Schindler’s List (1993)</li>\n<li>天堂电影院 Nuovo Cinema Paradiso (1988)</li>\n</ul>\n<p>然后是我最爱的科幻片、悬疑片类型：</p>\n<ul>\n<li>黑侠</li>\n<li>这个男人来自地球 The Man from Earth (2007)</li>\n<li>超时空接触 Contact (1997)</li>\n<li>星际穿越 Interstellar (2014)</li>\n<li>源代码 Source Code (2011)</li>\n<li>蝴蝶效应 The Butterfly Effect (2004)</li>\n<li>致命魔术 The Prestige (2006)</li>\n<li>阿凡达 Avatar (2009)</li>\n<li>恐怖游轮 Triangle (2009)</li>\n<li>生化危机系列</li>\n<li>异次元骇客 The thirteenth floor (1999)</li>\n<li>异星战场</li>\n<li>复仇者联盟 The Avengers (2012)</li>\n<li>钢铁侠系列</li>\n<li>绿巨人系列</li>\n<li>大鱼</li>\n<li>无姓之人</li>\n<li>土拨鼠之日</li>\n</ul>\n<p>然后是反正好看系列：</p>\n<ul>\n<li>冰雪奇缘 Frozen (2013)</li>\n<li>疯狂动物城</li>\n<li>暮光之城系列</li>\n<li>哈利波特系列</li>\n<li>速度与激情系列</li>\n<li>魔戒三部曲</li>\n<li>驯龙高手1、2</li>\n<li>疯狂的麦克斯4：狂暴之路 Mad Max: Fury Road (2015)</li>\n<li>空中监狱 Con Air (1997)</li>\n</ul>\n<p>国产电影：</p>\n<ul>\n<li>翻滚吧！阿信 (2011)</li>\n<li>夏日乐悠悠 (2011)</li>\n<li>破风 (2015)</li>\n</ul>\n<p>没错，三部里面都有彭于晏</p>\n<h2 id=\"连续剧\"><a href=\"#连续剧\" class=\"headerlink\" title=\"连续剧\"></a>连续剧</h2><h3 id=\"美剧-amp-amp-英剧\"><a href=\"#美剧-amp-amp-英剧\" class=\"headerlink\" title=\"美剧 &amp;&amp; 英剧\"></a>美剧 &amp;&amp; 英剧</h3><h4 id=\"美剧\"><a href=\"#美剧\" class=\"headerlink\" title=\"美剧\"></a>美剧</h4><ul>\n<li>冰与火之歌，又名：权力的游戏，A Song of Ice and Fire: Game of Thrones</li>\n<li>行尸走肉，the walking dead（刚开始看是新鲜，后来就没啥价值了，无非是讲人性罢了）</li>\n<li>西部世界，westworld</li>\n<li>硅谷</li>\n<li>达芬奇密码</li>\n</ul>\n<h4 id=\"英剧\"><a href=\"#英剧\" class=\"headerlink\" title=\"英剧\"></a>英剧</h4><ul>\n<li>神探夏洛克</li>\n<li>黑镜</li>\n</ul>\n<h3 id=\"日剧\"><a href=\"#日剧\" class=\"headerlink\" title=\"日剧\"></a>日剧</h3><ul>\n<li>legal high（胜者即正义）</li>\n<li>半泽直树</li>\n<li>逃避可耻但有用</li>\n</ul>\n<h3 id=\"国产电视剧\"><a href=\"#国产电视剧\" class=\"headerlink\" title=\"国产电视剧\"></a>国产电视剧</h3><ul>\n<li>琅琊榜</li>\n<li>大好时光（并不值得看，当时看这个完全是奔着胡歌去的，看这个剧有种白开水的味道，有种淡淡的生活味儿，另外这个剧传递给你一种极正的三观）</li>\n<li>李小龙传奇</li>\n<li>恰同学少年</li>\n<li>仙剑1，3</li>\n</ul>\n<h4 id=\"偶像剧\"><a href=\"#偶像剧\" class=\"headerlink\" title=\"偶像剧\"></a>偶像剧</h4><p>微微一笑很倾城（并不值得看，除了让你羡慕嫉妒恨，或者活在梦里，没什么太大的意义，主角都太过完美了）</p>\n<h4 id=\"网剧\"><a href=\"#网剧\" class=\"headerlink\" title=\"网剧\"></a>网剧</h4><ul>\n<li>一起同过窗（并不值得看，大学过完了才看这个剧，对学生时代总有种意犹未尽的感觉，这个剧带你再次体验那些鸡毛蒜皮的青春时光）</li>\n<li>白夜追凶</li>\n<li>太子妃升职记（你要是想猎个奇，那就试试，其实没啥好看的，不推荐）</li>\n</ul>\n<h3 id=\"韩剧\"><a href=\"#韩剧\" class=\"headerlink\" title=\"韩剧\"></a>韩剧</h3><ul>\n<li>爱在哈佛</li>\n<li>太阳的后裔</li>\n<li>W 两个世界</li>\n</ul>\n<h2 id=\"纪录片\"><a href=\"#纪录片\" class=\"headerlink\" title=\"纪录片\"></a>纪录片</h2><ul>\n<li>人生7年，the up series</li>\n<li>互联网时代（央视）(2014)</li>\n<li>互联网之子 The Internet’s Own Boy: The Story of Aaron Swartz (2014)</li>\n<li>史蒂夫·乔布斯：遗失的访谈 Steve Jobs: The Lost Interview (2012)</li>\n<li>舌尖上的中国</li>\n<li>wild China，美丽中国，BBC产的</li>\n<li>小森林（春夏秋冬）</li>\n</ul>\n<h2 id=\"动漫\"><a href=\"#动漫\" class=\"headerlink\" title=\"动漫\"></a>动漫</h2><h3 id=\"国产\"><a href=\"#国产\" class=\"headerlink\" title=\"国产\"></a>国产</h3><ul>\n<li>秦时明月</li>\n<li>天行九歌</li>\n<li>我是白小飞</li>\n</ul>\n<h3 id=\"日本动漫\"><a href=\"#日本动漫\" class=\"headerlink\" title=\"日本动漫\"></a>日本动漫</h3><ul>\n<li>火影忍者</li>\n<li>海贼王</li>\n<li>东京食尸鬼</li>\n<li>寄生兽</li>\n<li>进击的巨人</li>\n<li>宫崎骏系列</li>\n<li>天空之城</li>\n<li>龙猫</li>\n<li>千与千寻</li>\n<li>风之谷</li>\n<li>哈尔的移动城堡</li>\n<li>起风了</li>\n<li>萤火之森</li>\n</ul>\n<h2 id=\"小说\"><a href=\"#小说\" class=\"headerlink\" title=\"小说\"></a>小说</h2><ul>\n<li>三体</li>\n<li>缥缈之旅（修真小说的鼻祖，在喜马拉雅上听完的，并没有看文字小说，另外很多时候听着睡着了，不停的打怪升级而已吧，太长了）</li>\n<li>王小波全集（我主要关注的是他这个人，所以他的所有作品都值得看看，我主要看了《沉默的大多数》）</li>\n<li>和空姐同居的日子、第一次亲密接触。这两个也是听的广播剧，男女双人广播剧，言情类型的，不过也是红极一时的作品。在夜里温暖单身狗的小心脏。</li>\n<li>陈二狗的妖孽人生（YY小说，在喜马拉雅上听的，同时也看了点网剧）</li>\n</ul>\n<h2 id=\"书籍\"><a href=\"#书籍\" class=\"headerlink\" title=\"书籍\"></a>书籍</h2><p>时间管理的幸福学</p>\n"},{"layout":"post","title":"百度贴吧ID挖掘机","date":"2017-01-11T16:00:00.000Z","comments":1,"_content":"\n去年我开了一个minecraft服务器，想拉点人进去玩，就想到要出去打广告啊，怎么办呢，我的好朋友`lianera`就跟我说，他以前在贴吧里面批量@别人，嗯，这是个不错的方法，他当时还给我看了他写的一个百度贴吧ID挖掘机，但不是用python写的，[第一版C语言](https://github.com/lianera/archives/tree/master/tieba-digger)，[第二版java](https://github.com/lianera/archives/tree/master/tbot)。不过后来这件事没有做成，因为现在百度贴吧禁止批量@了。\n\n后来我就想学点python，因为据说python代码特别简洁，这对于我这种极简主义者是很有诱惑力的，正所谓 -- “人生苦短，我用python”（来源于：life is short, you need python）。另外python爬虫很有名啊，python玩数据很方便啊。数据时代怎么能不玩数据呢！于是我就一门心思想学python（其实还有一个原因，因为xx-net（一款翻墙软件）是用python写的，迟迟不出移动端的，我的手机也要翻墙啊，摔！我打算自己把xx-net移植到ios和安卓上，首先需要读懂代码啊，所以我还是需要学python，但后来lianera找了个便宜的VPS，并搭了shadowsocks服务，我们就一起用他搞的VPS翻墙了。。。）。\n\n想着不能光看python语法而不做实事，我就重新造这个百度贴吧ID挖掘机轮子了。\n\n先推荐[我的github](https://github.com/liuqinh2s)欢迎各位follow和指教，（程序员之间多多联系还是有必要的，大家可以讨论技术啊，除了技术还可以聊人生啊，电影啊，抱歉我以前是个文青，文科成绩一直很好，嗯，也爱科学）。\n\n项目地址：[https://github.com/liuqinh2s/Python](https://github.com/liuqinh2s/Python)\n\n一开始我是用python2，然后想着python3才是未来，然后就想改点代码就升级了呗，但是python2和python3真的是有点不一样，改得有点蛋疼，不过最后还是弄好了。\n\n代码写的不好的地方请指出来哈。\n\n下面我讲讲思路：\n\n1. 首先定义了一个BaiDuTieBa类，用来获取HTML源代码，然后用正则表达式匹配抽取出用户ID，然后我用了一个全局的dict变量存放ID，最后把dict中的ID全部写入文件就可以啦。其中必不可少的要用到urllib库，re（regex, regular expression，正则表达式）库。\n2. 然后我就想啊，单线程爬的这么慢简直不能忍，于是就搞个多线程吧，至少把我的网速和带宽占的满满的。这里我使用了任务队列和线程池，简单讲就是把任务都放进任务队列里面，然后线程放线程池里面，线程呢不断的去取任务，做完一个取一个，直到任务队列为空。线程池代码是从网上借鉴来的，管他呢自己改改能用就OK。这里用了threading库，queue库。\n\n然后爬的时候，你看看自己的网络，反正我的是瞬间飙升到几兆每秒了。\n\n代码很初级，关键的地方都有注释哦，看不懂的地方私信我，我会在文章最后贴出常见的问题，并详细讲解。\n\n\n```python\n#!/usr/bin/env python3\n# coding=utf-8\n\n'''\n    这是python3版本的，看文件名，TieBaID3.py，这个3啊就是python3，懂了伐。\n'''\n\n__author__ = 'liuqin'\n\nimport urllib.request\nimport re\nimport threading\nimport queue\n\nIDdict = {}\n#百度贴吧爬取用户ID，以minecraft吧为例\nclass BaiDuTieBa():\n    def __init__(self, kw, pn):\n        self.baseurl = \"http://tieba.baidu.com/f/like/manage/list?\"\n        self.userAgent = \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36\"\n        self.headers = {'User-Agent': self.userAgent}\n        self.kw = kw\n        self.pn = pn\n        self.IDdict = IDdict\n\n    def getHTML(self):\n        url = self.baseurl + 'kw=' + self.kw + '&' + 'pn=' + str(self.pn)\n        request = urllib.request.urlopen(url)\n        # 注意这里网页源码编码是：GBK，用decode解码时要选择gbk\n        pageHTML = request.read().decode('gbk')\n        return pageHTML\n\n    def getUserID(self):\n        regex = re.compile('.*?username=\"(.*?)\".*?')\n        pageHTML = self.getHTML()\n        UserID = re.findall(regex, pageHTML)\n        return UserID\n\n    def writeIDinDict(self):\n        UserID = self.getUserID()\n        count = 0\n        for id in UserID:\n            count += 1\n            self.IDdict[count + self.pn * 20] = id\n\n    def start(self):\n        self.getUserID()\n        self.writeIDinDict()\n        print(u'写入第%d页用户ID' % (self.pn))\n\n\ndef writeInFile():\n    file = open(u'./百度贴吧minecraft吧用户ID.txt', 'a+', encoding='UTF-8')\n    # print(file.encoding)\n    for i in IDdict:\n        file.write(IDdict[i]+'\\n')\n    file.close()\n\n\n#具体要做的任务\ndef do_job(kw, pn):\n    spider = BaiDuTieBa(kw, pn)\n    spider.start()\n\ndef do_job1(kw, pn):\n    spider = BaiDuTieBa(kw, pn)\n    return spider\n\n# 单线程爬虫\ndef NoThreads(kw, pn):\n    for i in range(1, pn+1):\n        do_job(kw, i)\n\n\n# 有多少任务创建多少线程，每个任务执行完就销毁相应线程，这种有点太恐怖，哈哈，任务数太多就爆炸了\nclass Thread_spider(threading.Thread):\n\n    def __init__(self, kw, pn):\n        threading.Thread.__init__(self)\n        self.pn = pn\n        self.kw = kw\n    def run(self):\n        do_job(self.kw, self.pn)\n\ndef MultiThreads(kw, pn):\n    threads1 = [Thread_spider(kw, i) for i in range(1, pn+1)]\n    for i in threads1:\n        i.start()\n    for i in threads1:\n        if i.is_alive: i.join()\n\n\n# 用线程池和任务队列\nclass WorkManager(object):# 这是一个线程管理器\n    def __init__(self, kw, work_num, thread_num):\n        self.task_queue = queue.Queue()\n        self.threads = []\n        self.kw = kw\n        self.__init_task_queue(work_num)\n        self.__init_thread_pool(thread_num)\n        self.start_task()\n\n    \"\"\"\n        添加一项工作入队\n    \"\"\"\n    def add_job(self, func):\n        self.task_queue.put(func)  # 任务入队，Queue内部实现了同步机制\n\n    \"\"\"\n        初始化任务队列\n    \"\"\"\n    def __init_task_queue(self, jobs_num):\n        for i in range(1, jobs_num + 1):\n            self.add_job(do_job1(self.kw, i))\n\n    \"\"\"\n        初始化线程池\n    \"\"\"\n    def __init_thread_pool(self,thread_num):\n        for i in range(1,thread_num+1):\n            self.threads.append(Work(self.task_queue))\n\n    \"\"\"\n        开始执行任务\n    \"\"\"\n    def start_task(self):\n        for i in self.threads:\n            i.setDaemon(1)\n            i.start()\n\n    \"\"\"\n        等待所有线程运行完毕\n    \"\"\"\n    def wait_allcomplete(self):\n        for item in self.threads:\n            item.join(1)  \n\nclass Work(threading.Thread):# 这是线程类\n\n    def __init__(self, task_queue):\n        threading.Thread.__init__(self)\n        self.task_queue = task_queue\n\n    def run(self):\n        while not self.task_queue.empty():\n            self.task_queue.get().start()# 任务异步出队，Queue内部实现了同步机制\n            self.task_queue.task_done()  # 通知系统任务完成\n\n\nif __name__ == '__main__':\n    kw = 'minecraft'  # 贴吧名称\n    pn = 1000 # 页面数\n    # 不用多线程模式\n    # NoThreads(kw, pn)\n\n    # 即时创建即时销毁，多线程模式\n    # MultiThreads(kw, pn)\n\n    # 任务队列线程池模式：（任务数：1000，线程：100）\n    threads_num = 100\n    work_manager =  WorkManager(kw, pn, threads_num)\n    work_manager.wait_allcomplete()\n\n    print(\"hello world\")\n    writeInFile()\n```\n","source":"_posts/2017/2017-01-12-百度贴吧ID挖掘机.md","raw":"---\nlayout: post\ntitle: 百度贴吧ID挖掘机\ndate: 2017-01-12\ncategories: [projects]\ntags: [爬虫, Python]\ncomments: true\n---\n\n去年我开了一个minecraft服务器，想拉点人进去玩，就想到要出去打广告啊，怎么办呢，我的好朋友`lianera`就跟我说，他以前在贴吧里面批量@别人，嗯，这是个不错的方法，他当时还给我看了他写的一个百度贴吧ID挖掘机，但不是用python写的，[第一版C语言](https://github.com/lianera/archives/tree/master/tieba-digger)，[第二版java](https://github.com/lianera/archives/tree/master/tbot)。不过后来这件事没有做成，因为现在百度贴吧禁止批量@了。\n\n后来我就想学点python，因为据说python代码特别简洁，这对于我这种极简主义者是很有诱惑力的，正所谓 -- “人生苦短，我用python”（来源于：life is short, you need python）。另外python爬虫很有名啊，python玩数据很方便啊。数据时代怎么能不玩数据呢！于是我就一门心思想学python（其实还有一个原因，因为xx-net（一款翻墙软件）是用python写的，迟迟不出移动端的，我的手机也要翻墙啊，摔！我打算自己把xx-net移植到ios和安卓上，首先需要读懂代码啊，所以我还是需要学python，但后来lianera找了个便宜的VPS，并搭了shadowsocks服务，我们就一起用他搞的VPS翻墙了。。。）。\n\n想着不能光看python语法而不做实事，我就重新造这个百度贴吧ID挖掘机轮子了。\n\n先推荐[我的github](https://github.com/liuqinh2s)欢迎各位follow和指教，（程序员之间多多联系还是有必要的，大家可以讨论技术啊，除了技术还可以聊人生啊，电影啊，抱歉我以前是个文青，文科成绩一直很好，嗯，也爱科学）。\n\n项目地址：[https://github.com/liuqinh2s/Python](https://github.com/liuqinh2s/Python)\n\n一开始我是用python2，然后想着python3才是未来，然后就想改点代码就升级了呗，但是python2和python3真的是有点不一样，改得有点蛋疼，不过最后还是弄好了。\n\n代码写的不好的地方请指出来哈。\n\n下面我讲讲思路：\n\n1. 首先定义了一个BaiDuTieBa类，用来获取HTML源代码，然后用正则表达式匹配抽取出用户ID，然后我用了一个全局的dict变量存放ID，最后把dict中的ID全部写入文件就可以啦。其中必不可少的要用到urllib库，re（regex, regular expression，正则表达式）库。\n2. 然后我就想啊，单线程爬的这么慢简直不能忍，于是就搞个多线程吧，至少把我的网速和带宽占的满满的。这里我使用了任务队列和线程池，简单讲就是把任务都放进任务队列里面，然后线程放线程池里面，线程呢不断的去取任务，做完一个取一个，直到任务队列为空。线程池代码是从网上借鉴来的，管他呢自己改改能用就OK。这里用了threading库，queue库。\n\n然后爬的时候，你看看自己的网络，反正我的是瞬间飙升到几兆每秒了。\n\n代码很初级，关键的地方都有注释哦，看不懂的地方私信我，我会在文章最后贴出常见的问题，并详细讲解。\n\n\n```python\n#!/usr/bin/env python3\n# coding=utf-8\n\n'''\n    这是python3版本的，看文件名，TieBaID3.py，这个3啊就是python3，懂了伐。\n'''\n\n__author__ = 'liuqin'\n\nimport urllib.request\nimport re\nimport threading\nimport queue\n\nIDdict = {}\n#百度贴吧爬取用户ID，以minecraft吧为例\nclass BaiDuTieBa():\n    def __init__(self, kw, pn):\n        self.baseurl = \"http://tieba.baidu.com/f/like/manage/list?\"\n        self.userAgent = \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36\"\n        self.headers = {'User-Agent': self.userAgent}\n        self.kw = kw\n        self.pn = pn\n        self.IDdict = IDdict\n\n    def getHTML(self):\n        url = self.baseurl + 'kw=' + self.kw + '&' + 'pn=' + str(self.pn)\n        request = urllib.request.urlopen(url)\n        # 注意这里网页源码编码是：GBK，用decode解码时要选择gbk\n        pageHTML = request.read().decode('gbk')\n        return pageHTML\n\n    def getUserID(self):\n        regex = re.compile('.*?username=\"(.*?)\".*?')\n        pageHTML = self.getHTML()\n        UserID = re.findall(regex, pageHTML)\n        return UserID\n\n    def writeIDinDict(self):\n        UserID = self.getUserID()\n        count = 0\n        for id in UserID:\n            count += 1\n            self.IDdict[count + self.pn * 20] = id\n\n    def start(self):\n        self.getUserID()\n        self.writeIDinDict()\n        print(u'写入第%d页用户ID' % (self.pn))\n\n\ndef writeInFile():\n    file = open(u'./百度贴吧minecraft吧用户ID.txt', 'a+', encoding='UTF-8')\n    # print(file.encoding)\n    for i in IDdict:\n        file.write(IDdict[i]+'\\n')\n    file.close()\n\n\n#具体要做的任务\ndef do_job(kw, pn):\n    spider = BaiDuTieBa(kw, pn)\n    spider.start()\n\ndef do_job1(kw, pn):\n    spider = BaiDuTieBa(kw, pn)\n    return spider\n\n# 单线程爬虫\ndef NoThreads(kw, pn):\n    for i in range(1, pn+1):\n        do_job(kw, i)\n\n\n# 有多少任务创建多少线程，每个任务执行完就销毁相应线程，这种有点太恐怖，哈哈，任务数太多就爆炸了\nclass Thread_spider(threading.Thread):\n\n    def __init__(self, kw, pn):\n        threading.Thread.__init__(self)\n        self.pn = pn\n        self.kw = kw\n    def run(self):\n        do_job(self.kw, self.pn)\n\ndef MultiThreads(kw, pn):\n    threads1 = [Thread_spider(kw, i) for i in range(1, pn+1)]\n    for i in threads1:\n        i.start()\n    for i in threads1:\n        if i.is_alive: i.join()\n\n\n# 用线程池和任务队列\nclass WorkManager(object):# 这是一个线程管理器\n    def __init__(self, kw, work_num, thread_num):\n        self.task_queue = queue.Queue()\n        self.threads = []\n        self.kw = kw\n        self.__init_task_queue(work_num)\n        self.__init_thread_pool(thread_num)\n        self.start_task()\n\n    \"\"\"\n        添加一项工作入队\n    \"\"\"\n    def add_job(self, func):\n        self.task_queue.put(func)  # 任务入队，Queue内部实现了同步机制\n\n    \"\"\"\n        初始化任务队列\n    \"\"\"\n    def __init_task_queue(self, jobs_num):\n        for i in range(1, jobs_num + 1):\n            self.add_job(do_job1(self.kw, i))\n\n    \"\"\"\n        初始化线程池\n    \"\"\"\n    def __init_thread_pool(self,thread_num):\n        for i in range(1,thread_num+1):\n            self.threads.append(Work(self.task_queue))\n\n    \"\"\"\n        开始执行任务\n    \"\"\"\n    def start_task(self):\n        for i in self.threads:\n            i.setDaemon(1)\n            i.start()\n\n    \"\"\"\n        等待所有线程运行完毕\n    \"\"\"\n    def wait_allcomplete(self):\n        for item in self.threads:\n            item.join(1)  \n\nclass Work(threading.Thread):# 这是线程类\n\n    def __init__(self, task_queue):\n        threading.Thread.__init__(self)\n        self.task_queue = task_queue\n\n    def run(self):\n        while not self.task_queue.empty():\n            self.task_queue.get().start()# 任务异步出队，Queue内部实现了同步机制\n            self.task_queue.task_done()  # 通知系统任务完成\n\n\nif __name__ == '__main__':\n    kw = 'minecraft'  # 贴吧名称\n    pn = 1000 # 页面数\n    # 不用多线程模式\n    # NoThreads(kw, pn)\n\n    # 即时创建即时销毁，多线程模式\n    # MultiThreads(kw, pn)\n\n    # 任务队列线程池模式：（任务数：1000，线程：100）\n    threads_num = 100\n    work_manager =  WorkManager(kw, pn, threads_num)\n    work_manager.wait_allcomplete()\n\n    print(\"hello world\")\n    writeInFile()\n```\n","slug":"百度贴吧ID挖掘机","published":1,"updated":"2018-04-28T00:05:33.697Z","photos":[],"link":"","_id":"cjm2w8dct000yfgpxie7qatmd","content":"<p>去年我开了一个minecraft服务器，想拉点人进去玩，就想到要出去打广告啊，怎么办呢，我的好朋友<code>lianera</code>就跟我说，他以前在贴吧里面批量@别人，嗯，这是个不错的方法，他当时还给我看了他写的一个百度贴吧ID挖掘机，但不是用python写的，<a href=\"https://github.com/lianera/archives/tree/master/tieba-digger\" target=\"_blank\" rel=\"noopener\">第一版C语言</a>，<a href=\"https://github.com/lianera/archives/tree/master/tbot\" target=\"_blank\" rel=\"noopener\">第二版java</a>。不过后来这件事没有做成，因为现在百度贴吧禁止批量@了。</p>\n<p>后来我就想学点python，因为据说python代码特别简洁，这对于我这种极简主义者是很有诱惑力的，正所谓 – “人生苦短，我用python”（来源于：life is short, you need python）。另外python爬虫很有名啊，python玩数据很方便啊。数据时代怎么能不玩数据呢！于是我就一门心思想学python（其实还有一个原因，因为xx-net（一款翻墙软件）是用python写的，迟迟不出移动端的，我的手机也要翻墙啊，摔！我打算自己把xx-net移植到ios和安卓上，首先需要读懂代码啊，所以我还是需要学python，但后来lianera找了个便宜的VPS，并搭了shadowsocks服务，我们就一起用他搞的VPS翻墙了。。。）。</p>\n<p>想着不能光看python语法而不做实事，我就重新造这个百度贴吧ID挖掘机轮子了。</p>\n<p>先推荐<a href=\"https://github.com/liuqinh2s\" target=\"_blank\" rel=\"noopener\">我的github</a>欢迎各位follow和指教，（程序员之间多多联系还是有必要的，大家可以讨论技术啊，除了技术还可以聊人生啊，电影啊，抱歉我以前是个文青，文科成绩一直很好，嗯，也爱科学）。</p>\n<p>项目地址：<a href=\"https://github.com/liuqinh2s/Python\" target=\"_blank\" rel=\"noopener\">https://github.com/liuqinh2s/Python</a></p>\n<p>一开始我是用python2，然后想着python3才是未来，然后就想改点代码就升级了呗，但是python2和python3真的是有点不一样，改得有点蛋疼，不过最后还是弄好了。</p>\n<p>代码写的不好的地方请指出来哈。</p>\n<p>下面我讲讲思路：</p>\n<ol>\n<li>首先定义了一个BaiDuTieBa类，用来获取HTML源代码，然后用正则表达式匹配抽取出用户ID，然后我用了一个全局的dict变量存放ID，最后把dict中的ID全部写入文件就可以啦。其中必不可少的要用到urllib库，re（regex, regular expression，正则表达式）库。</li>\n<li>然后我就想啊，单线程爬的这么慢简直不能忍，于是就搞个多线程吧，至少把我的网速和带宽占的满满的。这里我使用了任务队列和线程池，简单讲就是把任务都放进任务队列里面，然后线程放线程池里面，线程呢不断的去取任务，做完一个取一个，直到任务队列为空。线程池代码是从网上借鉴来的，管他呢自己改改能用就OK。这里用了threading库，queue库。</li>\n</ol>\n<p>然后爬的时候，你看看自己的网络，反正我的是瞬间飙升到几兆每秒了。</p>\n<p>代码很初级，关键的地方都有注释哦，看不懂的地方私信我，我会在文章最后贴出常见的问题，并详细讲解。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python3</span></span><br><span class=\"line\"><span class=\"comment\"># coding=utf-8</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">    这是python3版本的，看文件名，TieBaID3.py，这个3啊就是python3，懂了伐。</span></span><br><span class=\"line\"><span class=\"string\">'''</span></span><br><span class=\"line\"></span><br><span class=\"line\">__author__ = <span class=\"string\">'liuqin'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> urllib.request</span><br><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"><span class=\"keyword\">import</span> threading</span><br><span class=\"line\"><span class=\"keyword\">import</span> queue</span><br><span class=\"line\"></span><br><span class=\"line\">IDdict = &#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">#百度贴吧爬取用户ID，以minecraft吧为例</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaiDuTieBa</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, kw, pn)</span>:</span></span><br><span class=\"line\">        self.baseurl = <span class=\"string\">\"http://tieba.baidu.com/f/like/manage/list?\"</span></span><br><span class=\"line\">        self.userAgent = <span class=\"string\">\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36\"</span></span><br><span class=\"line\">        self.headers = &#123;<span class=\"string\">'User-Agent'</span>: self.userAgent&#125;</span><br><span class=\"line\">        self.kw = kw</span><br><span class=\"line\">        self.pn = pn</span><br><span class=\"line\">        self.IDdict = IDdict</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getHTML</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        url = self.baseurl + <span class=\"string\">'kw='</span> + self.kw + <span class=\"string\">'&amp;'</span> + <span class=\"string\">'pn='</span> + str(self.pn)</span><br><span class=\"line\">        request = urllib.request.urlopen(url)</span><br><span class=\"line\">        <span class=\"comment\"># 注意这里网页源码编码是：GBK，用decode解码时要选择gbk</span></span><br><span class=\"line\">        pageHTML = request.read().decode(<span class=\"string\">'gbk'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pageHTML</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getUserID</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        regex = re.compile(<span class=\"string\">'.*?username=\"(.*?)\".*?'</span>)</span><br><span class=\"line\">        pageHTML = self.getHTML()</span><br><span class=\"line\">        UserID = re.findall(regex, pageHTML)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> UserID</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">writeIDinDict</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        UserID = self.getUserID()</span><br><span class=\"line\">        count = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> id <span class=\"keyword\">in</span> UserID:</span><br><span class=\"line\">            count += <span class=\"number\">1</span></span><br><span class=\"line\">            self.IDdict[count + self.pn * <span class=\"number\">20</span>] = id</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">start</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.getUserID()</span><br><span class=\"line\">        self.writeIDinDict()</span><br><span class=\"line\">        print(<span class=\"string\">u'写入第%d页用户ID'</span> % (self.pn))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">writeInFile</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    file = open(<span class=\"string\">u'./百度贴吧minecraft吧用户ID.txt'</span>, <span class=\"string\">'a+'</span>, encoding=<span class=\"string\">'UTF-8'</span>)</span><br><span class=\"line\">    <span class=\"comment\"># print(file.encoding)</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> IDdict:</span><br><span class=\"line\">        file.write(IDdict[i]+<span class=\"string\">'\\n'</span>)</span><br><span class=\"line\">    file.close()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#具体要做的任务</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">do_job</span><span class=\"params\">(kw, pn)</span>:</span></span><br><span class=\"line\">    spider = BaiDuTieBa(kw, pn)</span><br><span class=\"line\">    spider.start()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">do_job1</span><span class=\"params\">(kw, pn)</span>:</span></span><br><span class=\"line\">    spider = BaiDuTieBa(kw, pn)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> spider</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 单线程爬虫</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">NoThreads</span><span class=\"params\">(kw, pn)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, pn+<span class=\"number\">1</span>):</span><br><span class=\"line\">        do_job(kw, i)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 有多少任务创建多少线程，每个任务执行完就销毁相应线程，这种有点太恐怖，哈哈，任务数太多就爆炸了</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Thread_spider</span><span class=\"params\">(threading.Thread)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, kw, pn)</span>:</span></span><br><span class=\"line\">        threading.Thread.__init__(self)</span><br><span class=\"line\">        self.pn = pn</span><br><span class=\"line\">        self.kw = kw</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        do_job(self.kw, self.pn)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">MultiThreads</span><span class=\"params\">(kw, pn)</span>:</span></span><br><span class=\"line\">    threads1 = [Thread_spider(kw, i) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, pn+<span class=\"number\">1</span>)]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> threads1:</span><br><span class=\"line\">        i.start()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> threads1:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i.is_alive: i.join()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 用线程池和任务队列</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WorkManager</span><span class=\"params\">(object)</span>:</span><span class=\"comment\"># 这是一个线程管理器</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, kw, work_num, thread_num)</span>:</span></span><br><span class=\"line\">        self.task_queue = queue.Queue()</span><br><span class=\"line\">        self.threads = []</span><br><span class=\"line\">        self.kw = kw</span><br><span class=\"line\">        self.__init_task_queue(work_num)</span><br><span class=\"line\">        self.__init_thread_pool(thread_num)</span><br><span class=\"line\">        self.start_task()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        添加一项工作入队</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add_job</span><span class=\"params\">(self, func)</span>:</span></span><br><span class=\"line\">        self.task_queue.put(func)  <span class=\"comment\"># 任务入队，Queue内部实现了同步机制</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        初始化任务队列</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init_task_queue</span><span class=\"params\">(self, jobs_num)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, jobs_num + <span class=\"number\">1</span>):</span><br><span class=\"line\">            self.add_job(do_job1(self.kw, i))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        初始化线程池</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init_thread_pool</span><span class=\"params\">(self,thread_num)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,thread_num+<span class=\"number\">1</span>):</span><br><span class=\"line\">            self.threads.append(Work(self.task_queue))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        开始执行任务</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">start_task</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> self.threads:</span><br><span class=\"line\">            i.setDaemon(<span class=\"number\">1</span>)</span><br><span class=\"line\">            i.start()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        等待所有线程运行完毕</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wait_allcomplete</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> self.threads:</span><br><span class=\"line\">            item.join(<span class=\"number\">1</span>)  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Work</span><span class=\"params\">(threading.Thread)</span>:</span><span class=\"comment\"># 这是线程类</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, task_queue)</span>:</span></span><br><span class=\"line\">        threading.Thread.__init__(self)</span><br><span class=\"line\">        self.task_queue = task_queue</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"keyword\">not</span> self.task_queue.empty():</span><br><span class=\"line\">            self.task_queue.get().start()<span class=\"comment\"># 任务异步出队，Queue内部实现了同步机制</span></span><br><span class=\"line\">            self.task_queue.task_done()  <span class=\"comment\"># 通知系统任务完成</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    kw = <span class=\"string\">'minecraft'</span>  <span class=\"comment\"># 贴吧名称</span></span><br><span class=\"line\">    pn = <span class=\"number\">1000</span> <span class=\"comment\"># 页面数</span></span><br><span class=\"line\">    <span class=\"comment\"># 不用多线程模式</span></span><br><span class=\"line\">    <span class=\"comment\"># NoThreads(kw, pn)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 即时创建即时销毁，多线程模式</span></span><br><span class=\"line\">    <span class=\"comment\"># MultiThreads(kw, pn)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 任务队列线程池模式：（任务数：1000，线程：100）</span></span><br><span class=\"line\">    threads_num = <span class=\"number\">100</span></span><br><span class=\"line\">    work_manager =  WorkManager(kw, pn, threads_num)</span><br><span class=\"line\">    work_manager.wait_allcomplete()</span><br><span class=\"line\"></span><br><span class=\"line\">    print(<span class=\"string\">\"hello world\"</span>)</span><br><span class=\"line\">    writeInFile()</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>去年我开了一个minecraft服务器，想拉点人进去玩，就想到要出去打广告啊，怎么办呢，我的好朋友<code>lianera</code>就跟我说，他以前在贴吧里面批量@别人，嗯，这是个不错的方法，他当时还给我看了他写的一个百度贴吧ID挖掘机，但不是用python写的，<a href=\"https://github.com/lianera/archives/tree/master/tieba-digger\" target=\"_blank\" rel=\"noopener\">第一版C语言</a>，<a href=\"https://github.com/lianera/archives/tree/master/tbot\" target=\"_blank\" rel=\"noopener\">第二版java</a>。不过后来这件事没有做成，因为现在百度贴吧禁止批量@了。</p>\n<p>后来我就想学点python，因为据说python代码特别简洁，这对于我这种极简主义者是很有诱惑力的，正所谓 – “人生苦短，我用python”（来源于：life is short, you need python）。另外python爬虫很有名啊，python玩数据很方便啊。数据时代怎么能不玩数据呢！于是我就一门心思想学python（其实还有一个原因，因为xx-net（一款翻墙软件）是用python写的，迟迟不出移动端的，我的手机也要翻墙啊，摔！我打算自己把xx-net移植到ios和安卓上，首先需要读懂代码啊，所以我还是需要学python，但后来lianera找了个便宜的VPS，并搭了shadowsocks服务，我们就一起用他搞的VPS翻墙了。。。）。</p>\n<p>想着不能光看python语法而不做实事，我就重新造这个百度贴吧ID挖掘机轮子了。</p>\n<p>先推荐<a href=\"https://github.com/liuqinh2s\" target=\"_blank\" rel=\"noopener\">我的github</a>欢迎各位follow和指教，（程序员之间多多联系还是有必要的，大家可以讨论技术啊，除了技术还可以聊人生啊，电影啊，抱歉我以前是个文青，文科成绩一直很好，嗯，也爱科学）。</p>\n<p>项目地址：<a href=\"https://github.com/liuqinh2s/Python\" target=\"_blank\" rel=\"noopener\">https://github.com/liuqinh2s/Python</a></p>\n<p>一开始我是用python2，然后想着python3才是未来，然后就想改点代码就升级了呗，但是python2和python3真的是有点不一样，改得有点蛋疼，不过最后还是弄好了。</p>\n<p>代码写的不好的地方请指出来哈。</p>\n<p>下面我讲讲思路：</p>\n<ol>\n<li>首先定义了一个BaiDuTieBa类，用来获取HTML源代码，然后用正则表达式匹配抽取出用户ID，然后我用了一个全局的dict变量存放ID，最后把dict中的ID全部写入文件就可以啦。其中必不可少的要用到urllib库，re（regex, regular expression，正则表达式）库。</li>\n<li>然后我就想啊，单线程爬的这么慢简直不能忍，于是就搞个多线程吧，至少把我的网速和带宽占的满满的。这里我使用了任务队列和线程池，简单讲就是把任务都放进任务队列里面，然后线程放线程池里面，线程呢不断的去取任务，做完一个取一个，直到任务队列为空。线程池代码是从网上借鉴来的，管他呢自己改改能用就OK。这里用了threading库，queue库。</li>\n</ol>\n<p>然后爬的时候，你看看自己的网络，反正我的是瞬间飙升到几兆每秒了。</p>\n<p>代码很初级，关键的地方都有注释哦，看不懂的地方私信我，我会在文章最后贴出常见的问题，并详细讲解。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python3</span></span><br><span class=\"line\"><span class=\"comment\"># coding=utf-8</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">    这是python3版本的，看文件名，TieBaID3.py，这个3啊就是python3，懂了伐。</span></span><br><span class=\"line\"><span class=\"string\">'''</span></span><br><span class=\"line\"></span><br><span class=\"line\">__author__ = <span class=\"string\">'liuqin'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> urllib.request</span><br><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"><span class=\"keyword\">import</span> threading</span><br><span class=\"line\"><span class=\"keyword\">import</span> queue</span><br><span class=\"line\"></span><br><span class=\"line\">IDdict = &#123;&#125;</span><br><span class=\"line\"><span class=\"comment\">#百度贴吧爬取用户ID，以minecraft吧为例</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BaiDuTieBa</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, kw, pn)</span>:</span></span><br><span class=\"line\">        self.baseurl = <span class=\"string\">\"http://tieba.baidu.com/f/like/manage/list?\"</span></span><br><span class=\"line\">        self.userAgent = <span class=\"string\">\"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.95 Safari/537.36\"</span></span><br><span class=\"line\">        self.headers = &#123;<span class=\"string\">'User-Agent'</span>: self.userAgent&#125;</span><br><span class=\"line\">        self.kw = kw</span><br><span class=\"line\">        self.pn = pn</span><br><span class=\"line\">        self.IDdict = IDdict</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getHTML</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        url = self.baseurl + <span class=\"string\">'kw='</span> + self.kw + <span class=\"string\">'&amp;'</span> + <span class=\"string\">'pn='</span> + str(self.pn)</span><br><span class=\"line\">        request = urllib.request.urlopen(url)</span><br><span class=\"line\">        <span class=\"comment\"># 注意这里网页源码编码是：GBK，用decode解码时要选择gbk</span></span><br><span class=\"line\">        pageHTML = request.read().decode(<span class=\"string\">'gbk'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> pageHTML</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getUserID</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        regex = re.compile(<span class=\"string\">'.*?username=\"(.*?)\".*?'</span>)</span><br><span class=\"line\">        pageHTML = self.getHTML()</span><br><span class=\"line\">        UserID = re.findall(regex, pageHTML)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> UserID</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">writeIDinDict</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        UserID = self.getUserID()</span><br><span class=\"line\">        count = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> id <span class=\"keyword\">in</span> UserID:</span><br><span class=\"line\">            count += <span class=\"number\">1</span></span><br><span class=\"line\">            self.IDdict[count + self.pn * <span class=\"number\">20</span>] = id</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">start</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.getUserID()</span><br><span class=\"line\">        self.writeIDinDict()</span><br><span class=\"line\">        print(<span class=\"string\">u'写入第%d页用户ID'</span> % (self.pn))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">writeInFile</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    file = open(<span class=\"string\">u'./百度贴吧minecraft吧用户ID.txt'</span>, <span class=\"string\">'a+'</span>, encoding=<span class=\"string\">'UTF-8'</span>)</span><br><span class=\"line\">    <span class=\"comment\"># print(file.encoding)</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> IDdict:</span><br><span class=\"line\">        file.write(IDdict[i]+<span class=\"string\">'\\n'</span>)</span><br><span class=\"line\">    file.close()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#具体要做的任务</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">do_job</span><span class=\"params\">(kw, pn)</span>:</span></span><br><span class=\"line\">    spider = BaiDuTieBa(kw, pn)</span><br><span class=\"line\">    spider.start()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">do_job1</span><span class=\"params\">(kw, pn)</span>:</span></span><br><span class=\"line\">    spider = BaiDuTieBa(kw, pn)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> spider</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 单线程爬虫</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">NoThreads</span><span class=\"params\">(kw, pn)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, pn+<span class=\"number\">1</span>):</span><br><span class=\"line\">        do_job(kw, i)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 有多少任务创建多少线程，每个任务执行完就销毁相应线程，这种有点太恐怖，哈哈，任务数太多就爆炸了</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Thread_spider</span><span class=\"params\">(threading.Thread)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, kw, pn)</span>:</span></span><br><span class=\"line\">        threading.Thread.__init__(self)</span><br><span class=\"line\">        self.pn = pn</span><br><span class=\"line\">        self.kw = kw</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        do_job(self.kw, self.pn)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">MultiThreads</span><span class=\"params\">(kw, pn)</span>:</span></span><br><span class=\"line\">    threads1 = [Thread_spider(kw, i) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, pn+<span class=\"number\">1</span>)]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> threads1:</span><br><span class=\"line\">        i.start()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> threads1:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i.is_alive: i.join()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 用线程池和任务队列</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WorkManager</span><span class=\"params\">(object)</span>:</span><span class=\"comment\"># 这是一个线程管理器</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, kw, work_num, thread_num)</span>:</span></span><br><span class=\"line\">        self.task_queue = queue.Queue()</span><br><span class=\"line\">        self.threads = []</span><br><span class=\"line\">        self.kw = kw</span><br><span class=\"line\">        self.__init_task_queue(work_num)</span><br><span class=\"line\">        self.__init_thread_pool(thread_num)</span><br><span class=\"line\">        self.start_task()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        添加一项工作入队</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add_job</span><span class=\"params\">(self, func)</span>:</span></span><br><span class=\"line\">        self.task_queue.put(func)  <span class=\"comment\"># 任务入队，Queue内部实现了同步机制</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        初始化任务队列</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init_task_queue</span><span class=\"params\">(self, jobs_num)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, jobs_num + <span class=\"number\">1</span>):</span><br><span class=\"line\">            self.add_job(do_job1(self.kw, i))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        初始化线程池</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init_thread_pool</span><span class=\"params\">(self,thread_num)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,thread_num+<span class=\"number\">1</span>):</span><br><span class=\"line\">            self.threads.append(Work(self.task_queue))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        开始执行任务</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">start_task</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> self.threads:</span><br><span class=\"line\">            i.setDaemon(<span class=\"number\">1</span>)</span><br><span class=\"line\">            i.start()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"string\">\"\"\"</span></span><br><span class=\"line\"><span class=\"string\">        等待所有线程运行完毕</span></span><br><span class=\"line\"><span class=\"string\">    \"\"\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wait_allcomplete</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> self.threads:</span><br><span class=\"line\">            item.join(<span class=\"number\">1</span>)  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Work</span><span class=\"params\">(threading.Thread)</span>:</span><span class=\"comment\"># 这是线程类</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, task_queue)</span>:</span></span><br><span class=\"line\">        threading.Thread.__init__(self)</span><br><span class=\"line\">        self.task_queue = task_queue</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> <span class=\"keyword\">not</span> self.task_queue.empty():</span><br><span class=\"line\">            self.task_queue.get().start()<span class=\"comment\"># 任务异步出队，Queue内部实现了同步机制</span></span><br><span class=\"line\">            self.task_queue.task_done()  <span class=\"comment\"># 通知系统任务完成</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    kw = <span class=\"string\">'minecraft'</span>  <span class=\"comment\"># 贴吧名称</span></span><br><span class=\"line\">    pn = <span class=\"number\">1000</span> <span class=\"comment\"># 页面数</span></span><br><span class=\"line\">    <span class=\"comment\"># 不用多线程模式</span></span><br><span class=\"line\">    <span class=\"comment\"># NoThreads(kw, pn)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 即时创建即时销毁，多线程模式</span></span><br><span class=\"line\">    <span class=\"comment\"># MultiThreads(kw, pn)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 任务队列线程池模式：（任务数：1000，线程：100）</span></span><br><span class=\"line\">    threads_num = <span class=\"number\">100</span></span><br><span class=\"line\">    work_manager =  WorkManager(kw, pn, threads_num)</span><br><span class=\"line\">    work_manager.wait_allcomplete()</span><br><span class=\"line\"></span><br><span class=\"line\">    print(<span class=\"string\">\"hello world\"</span>)</span><br><span class=\"line\">    writeInFile()</span><br></pre></td></tr></table></figure>\n"},{"title":"游戏人生--探险者的人生手册","date":"2017-01-25T16:00:00.000Z","comments":1,"_content":"\n## 人生没有意义\n\n人喜欢讲意义，但似乎是件很可笑的事情，因为意义是人虚构出来的东西，这个世界上有些东西存在就是存在，不讲道理的存在，没有意义的存在。不信你去问问宇宙存在有什么意义？宇宙之外有没有意义？时间有什么意义？人生又有什么意义？哪怕你想破脑袋也没用。别拿意义去套你的人生了，百年之后终归尘土。就像泰戈尔写的诗：鸟在天空划过，不留下任何痕迹。马克思哲学也说：新事物终将取代旧事物，历史车轮曲折前进。这里是说你会死，就算你不会死又能怎样，永远活下去就能找到人生的意义？嗯，如果能做到同宇宙同岁也许可以，但别瞎想了，在你有生之年都不可能实现。\n\n没有一个终极意义你会慌乱吗？\n\n## 游戏 vs. 人生\n\n人都是喜欢游戏的，人可以进行没有实际奖励的游戏，人甚至可以进行不为输赢的游戏。很奇怪吧，当你小时候和小伙伴玩泥巴，当你打着坦克，玩着超级玛丽，当你打着魔兽、DOTA、英雄联盟，炉石传说，当你在Minecraft、饥荒里面一玩就忘了时间。你想想你到底在干嘛？你有为了某个意义去玩游戏吗？你也许会抱怨，人生为什么这么枯燥，人生为什么不像游戏？\n\n- 简单可行\n- 及时反馈\n- 无限尝试\n- 公平竞技\n\n发现没有，人生跟这四个属性一个都不挨边。 谁的人生是简单可行的？谁的人生是及时反馈的？谁的人生可以无限尝试，不服再来？谁的人生是生活在公平之中？\n\n一个复杂无比、充满未知的人生，一个慢慢长途、平淡无奇的人生；一个只有一次、甚至其中的很多阶段、很多事都只有一次的人生；一个连公平都做不到无比艰辛的人生。你想不想说一句life is a shit! 同志啊，这句话我早就想说了。\n\n来来来，对着上面这四条，你仔细想想：\n\n- 有多少人一辈子为生计奔走、迷茫、看不见未来、与机会擦肩而过？\n- 有多少人不停焦虑、制定计划、却不能坚持、始终碌碌无为？\n- 有多少事错了就不能再重来？\n- 有多少人，生来就缺乏竞争力？\n\n想通了吗？想通了就OK，你要是不能忍上面这四条，却依然厚着脸皮说你喜欢人生、热爱生活，我要骂你：真他妈能装逼，真是厚脸皮！那你要说，不然呢？我生下来就已经是这个样了啊，怪我咯！其实你是正确的，如果你还有活着的欲望，没有急着去死，那么你就该热爱你的生活，罗素有句话叫做：只有一种英雄主义，就是在认清生活真相之后，依然热爱生活。因为这是你的生活，你别无选择。\n\n大学的同学不用再抱怨大学了，不就迷茫了四年嘛，你没发现你其实上大学之前也只是在幻想人生的美事吗？你没发现你上大学之前一直是被安排着忙忙碌碌吗？大学打破了你的美梦，很好，大学让你迷茫，很好，大学让你又闲又焦虑不堪，这更好，大学让你有时间开始思考人生，简直完美！\n\n其实你忘了，小学的时候你也被老师的抄写课文后的生字词这种作业，弄的死去活来，每讲到新的一课，就从第一课抄到这一课（PS：这就是我真实的童年）。其实你也忘了，上高中的时候，做不完的题，做题做到想吐，从此落下对做题的厌恶感这种奇怪的病根。\n\n现在我们只关心一点，人生到底还有没有救。\n\n简单可行？到底是否可以做到？在你学英语的时候，在你健身的时候，在你打工赚钱的时候。很显然这三件事都不简单，你不应该再过多的考虑这种复杂的事情了。生活中当然有简单的事情，只是你看不上它们罢了，或者你觉着它们的意义太低。比如背一篇新概念3的文章，不算太难，如果觉着太难，那就背一段好了，但是你会想一些看起来很合理，实际上很荒唐的事情，你会想：背了又怎样，有什么用呢？或者我知道背了有点小用，坚持下去背很多就更是有大用了，但这太漫长了，没人能坚持下去。这就牵涉到及时反馈了，你急需立竿见影的效果，否则会在一次又一次的考虑中丧失你的动机。\n\n及时反馈？那你怎么及时反馈？背一篇新概念的文章的一段，对你学好英语的作用就是微乎其微，从这个角度来讲，你需要其他来源的反馈。\n\n无限尝试是不可能了，但有限的 多次模拟 还是可以的。\n\n公平竞技也是不可能的，这一点没有办法（很多英语国家的人不用死命学英语啊，长大成人了谁不会说母语？有些人出生就含着金钥匙啊，富二代官二代），我们只能靠自己，你也可以反过来想，起点很低，却靠自己的智慧变得很厉害，是不是更有成就感（强行安慰自己）。\n\n## 把人生游戏化的方法\n\n从上面的分析可以看出人生非常难以游戏化，但我们不能坐以待毙，下面我来讲讲我自己的一些想法吧。\n\n我自己是学计算机的，在外行看来，计算机是非常神秘的领域，就像某种魔法一样，事实上即便是我们这种内行，如果不清楚具体的实现过程，那么被抽象封装的部分依然是很神秘的，魔幻的。所以我们不妨把计算机技术当成一种现代魔法，而我们学计算机的都是魔法师，像Linus Torvalds、吴恩达这样的则是大法师。我们人区别于动物的地方是什么呢？\n\n1. 知识\n2. 合作\n\n我们能达成上百万人的合作（比如：波音飞机的整个生产过程，有人搞理论，有人设计，有人组装），我们能快速习得知识技能而不用依赖遗传和自然选择。知识+合作=文明。\n\n怎样变成一个更优秀的人？\n\n1. 习得更多的知识\n2. 拥有更强的合作技巧和能力\n\n我们接受教育，不停学习，就是习得更多的知识，我们和人交友，加入公司，获取财富和资本，创业，拉投资，就是拥有更强的合作能力。\n\n游戏是没有一个确定目的的（很多游戏可以有多种玩法和目的），即便很多游戏有一个终极目标，有一个通关的路径，但游戏的意义却非仅此而已，如果仅有一个最终目标，达成目标之后就变得无趣了。游戏拥有一个有趣的过程，让人沉浸其中。所以你可以给你的人生设定一个伟大的目标，但不要忘了，生活的意义不仅在于此，生活的意义还在于你生活的每一年，每一个月，每一天。\n\n把事情变得简单可行，就是要分割和量化目标，提供及时反馈就是要量化成果，得到激励。无限尝试，就是要不停模拟实践。公平竞技，算了吧，不谈这个(你可以从比你基础更差的人身上获取安慰，你想啊至少你的出身没有差到那个地步，是吧)。\n","source":"_posts/2017/2017-01-26-游戏人生--探险者的人生手册.md","raw":"---\ntitle: 游戏人生--探险者的人生手册\ndate: 2017-01-26\ncategories: [随笔]\ncomments: true\n---\n\n## 人生没有意义\n\n人喜欢讲意义，但似乎是件很可笑的事情，因为意义是人虚构出来的东西，这个世界上有些东西存在就是存在，不讲道理的存在，没有意义的存在。不信你去问问宇宙存在有什么意义？宇宙之外有没有意义？时间有什么意义？人生又有什么意义？哪怕你想破脑袋也没用。别拿意义去套你的人生了，百年之后终归尘土。就像泰戈尔写的诗：鸟在天空划过，不留下任何痕迹。马克思哲学也说：新事物终将取代旧事物，历史车轮曲折前进。这里是说你会死，就算你不会死又能怎样，永远活下去就能找到人生的意义？嗯，如果能做到同宇宙同岁也许可以，但别瞎想了，在你有生之年都不可能实现。\n\n没有一个终极意义你会慌乱吗？\n\n## 游戏 vs. 人生\n\n人都是喜欢游戏的，人可以进行没有实际奖励的游戏，人甚至可以进行不为输赢的游戏。很奇怪吧，当你小时候和小伙伴玩泥巴，当你打着坦克，玩着超级玛丽，当你打着魔兽、DOTA、英雄联盟，炉石传说，当你在Minecraft、饥荒里面一玩就忘了时间。你想想你到底在干嘛？你有为了某个意义去玩游戏吗？你也许会抱怨，人生为什么这么枯燥，人生为什么不像游戏？\n\n- 简单可行\n- 及时反馈\n- 无限尝试\n- 公平竞技\n\n发现没有，人生跟这四个属性一个都不挨边。 谁的人生是简单可行的？谁的人生是及时反馈的？谁的人生可以无限尝试，不服再来？谁的人生是生活在公平之中？\n\n一个复杂无比、充满未知的人生，一个慢慢长途、平淡无奇的人生；一个只有一次、甚至其中的很多阶段、很多事都只有一次的人生；一个连公平都做不到无比艰辛的人生。你想不想说一句life is a shit! 同志啊，这句话我早就想说了。\n\n来来来，对着上面这四条，你仔细想想：\n\n- 有多少人一辈子为生计奔走、迷茫、看不见未来、与机会擦肩而过？\n- 有多少人不停焦虑、制定计划、却不能坚持、始终碌碌无为？\n- 有多少事错了就不能再重来？\n- 有多少人，生来就缺乏竞争力？\n\n想通了吗？想通了就OK，你要是不能忍上面这四条，却依然厚着脸皮说你喜欢人生、热爱生活，我要骂你：真他妈能装逼，真是厚脸皮！那你要说，不然呢？我生下来就已经是这个样了啊，怪我咯！其实你是正确的，如果你还有活着的欲望，没有急着去死，那么你就该热爱你的生活，罗素有句话叫做：只有一种英雄主义，就是在认清生活真相之后，依然热爱生活。因为这是你的生活，你别无选择。\n\n大学的同学不用再抱怨大学了，不就迷茫了四年嘛，你没发现你其实上大学之前也只是在幻想人生的美事吗？你没发现你上大学之前一直是被安排着忙忙碌碌吗？大学打破了你的美梦，很好，大学让你迷茫，很好，大学让你又闲又焦虑不堪，这更好，大学让你有时间开始思考人生，简直完美！\n\n其实你忘了，小学的时候你也被老师的抄写课文后的生字词这种作业，弄的死去活来，每讲到新的一课，就从第一课抄到这一课（PS：这就是我真实的童年）。其实你也忘了，上高中的时候，做不完的题，做题做到想吐，从此落下对做题的厌恶感这种奇怪的病根。\n\n现在我们只关心一点，人生到底还有没有救。\n\n简单可行？到底是否可以做到？在你学英语的时候，在你健身的时候，在你打工赚钱的时候。很显然这三件事都不简单，你不应该再过多的考虑这种复杂的事情了。生活中当然有简单的事情，只是你看不上它们罢了，或者你觉着它们的意义太低。比如背一篇新概念3的文章，不算太难，如果觉着太难，那就背一段好了，但是你会想一些看起来很合理，实际上很荒唐的事情，你会想：背了又怎样，有什么用呢？或者我知道背了有点小用，坚持下去背很多就更是有大用了，但这太漫长了，没人能坚持下去。这就牵涉到及时反馈了，你急需立竿见影的效果，否则会在一次又一次的考虑中丧失你的动机。\n\n及时反馈？那你怎么及时反馈？背一篇新概念的文章的一段，对你学好英语的作用就是微乎其微，从这个角度来讲，你需要其他来源的反馈。\n\n无限尝试是不可能了，但有限的 多次模拟 还是可以的。\n\n公平竞技也是不可能的，这一点没有办法（很多英语国家的人不用死命学英语啊，长大成人了谁不会说母语？有些人出生就含着金钥匙啊，富二代官二代），我们只能靠自己，你也可以反过来想，起点很低，却靠自己的智慧变得很厉害，是不是更有成就感（强行安慰自己）。\n\n## 把人生游戏化的方法\n\n从上面的分析可以看出人生非常难以游戏化，但我们不能坐以待毙，下面我来讲讲我自己的一些想法吧。\n\n我自己是学计算机的，在外行看来，计算机是非常神秘的领域，就像某种魔法一样，事实上即便是我们这种内行，如果不清楚具体的实现过程，那么被抽象封装的部分依然是很神秘的，魔幻的。所以我们不妨把计算机技术当成一种现代魔法，而我们学计算机的都是魔法师，像Linus Torvalds、吴恩达这样的则是大法师。我们人区别于动物的地方是什么呢？\n\n1. 知识\n2. 合作\n\n我们能达成上百万人的合作（比如：波音飞机的整个生产过程，有人搞理论，有人设计，有人组装），我们能快速习得知识技能而不用依赖遗传和自然选择。知识+合作=文明。\n\n怎样变成一个更优秀的人？\n\n1. 习得更多的知识\n2. 拥有更强的合作技巧和能力\n\n我们接受教育，不停学习，就是习得更多的知识，我们和人交友，加入公司，获取财富和资本，创业，拉投资，就是拥有更强的合作能力。\n\n游戏是没有一个确定目的的（很多游戏可以有多种玩法和目的），即便很多游戏有一个终极目标，有一个通关的路径，但游戏的意义却非仅此而已，如果仅有一个最终目标，达成目标之后就变得无趣了。游戏拥有一个有趣的过程，让人沉浸其中。所以你可以给你的人生设定一个伟大的目标，但不要忘了，生活的意义不仅在于此，生活的意义还在于你生活的每一年，每一个月，每一天。\n\n把事情变得简单可行，就是要分割和量化目标，提供及时反馈就是要量化成果，得到激励。无限尝试，就是要不停模拟实践。公平竞技，算了吧，不谈这个(你可以从比你基础更差的人身上获取安慰，你想啊至少你的出身没有差到那个地步，是吧)。\n","slug":"游戏人生--探险者的人生手册","published":1,"updated":"2018-04-25T07:39:18.648Z","layout":"post","photos":[],"link":"","_id":"cjm2w8dcu000zfgpx9aipiej0","content":"<h2 id=\"人生没有意义\"><a href=\"#人生没有意义\" class=\"headerlink\" title=\"人生没有意义\"></a>人生没有意义</h2><p>人喜欢讲意义，但似乎是件很可笑的事情，因为意义是人虚构出来的东西，这个世界上有些东西存在就是存在，不讲道理的存在，没有意义的存在。不信你去问问宇宙存在有什么意义？宇宙之外有没有意义？时间有什么意义？人生又有什么意义？哪怕你想破脑袋也没用。别拿意义去套你的人生了，百年之后终归尘土。就像泰戈尔写的诗：鸟在天空划过，不留下任何痕迹。马克思哲学也说：新事物终将取代旧事物，历史车轮曲折前进。这里是说你会死，就算你不会死又能怎样，永远活下去就能找到人生的意义？嗯，如果能做到同宇宙同岁也许可以，但别瞎想了，在你有生之年都不可能实现。</p>\n<p>没有一个终极意义你会慌乱吗？</p>\n<h2 id=\"游戏-vs-人生\"><a href=\"#游戏-vs-人生\" class=\"headerlink\" title=\"游戏 vs. 人生\"></a>游戏 vs. 人生</h2><p>人都是喜欢游戏的，人可以进行没有实际奖励的游戏，人甚至可以进行不为输赢的游戏。很奇怪吧，当你小时候和小伙伴玩泥巴，当你打着坦克，玩着超级玛丽，当你打着魔兽、DOTA、英雄联盟，炉石传说，当你在Minecraft、饥荒里面一玩就忘了时间。你想想你到底在干嘛？你有为了某个意义去玩游戏吗？你也许会抱怨，人生为什么这么枯燥，人生为什么不像游戏？</p>\n<ul>\n<li>简单可行</li>\n<li>及时反馈</li>\n<li>无限尝试</li>\n<li>公平竞技</li>\n</ul>\n<p>发现没有，人生跟这四个属性一个都不挨边。 谁的人生是简单可行的？谁的人生是及时反馈的？谁的人生可以无限尝试，不服再来？谁的人生是生活在公平之中？</p>\n<p>一个复杂无比、充满未知的人生，一个慢慢长途、平淡无奇的人生；一个只有一次、甚至其中的很多阶段、很多事都只有一次的人生；一个连公平都做不到无比艰辛的人生。你想不想说一句life is a shit! 同志啊，这句话我早就想说了。</p>\n<p>来来来，对着上面这四条，你仔细想想：</p>\n<ul>\n<li>有多少人一辈子为生计奔走、迷茫、看不见未来、与机会擦肩而过？</li>\n<li>有多少人不停焦虑、制定计划、却不能坚持、始终碌碌无为？</li>\n<li>有多少事错了就不能再重来？</li>\n<li>有多少人，生来就缺乏竞争力？</li>\n</ul>\n<p>想通了吗？想通了就OK，你要是不能忍上面这四条，却依然厚着脸皮说你喜欢人生、热爱生活，我要骂你：真他妈能装逼，真是厚脸皮！那你要说，不然呢？我生下来就已经是这个样了啊，怪我咯！其实你是正确的，如果你还有活着的欲望，没有急着去死，那么你就该热爱你的生活，罗素有句话叫做：只有一种英雄主义，就是在认清生活真相之后，依然热爱生活。因为这是你的生活，你别无选择。</p>\n<p>大学的同学不用再抱怨大学了，不就迷茫了四年嘛，你没发现你其实上大学之前也只是在幻想人生的美事吗？你没发现你上大学之前一直是被安排着忙忙碌碌吗？大学打破了你的美梦，很好，大学让你迷茫，很好，大学让你又闲又焦虑不堪，这更好，大学让你有时间开始思考人生，简直完美！</p>\n<p>其实你忘了，小学的时候你也被老师的抄写课文后的生字词这种作业，弄的死去活来，每讲到新的一课，就从第一课抄到这一课（PS：这就是我真实的童年）。其实你也忘了，上高中的时候，做不完的题，做题做到想吐，从此落下对做题的厌恶感这种奇怪的病根。</p>\n<p>现在我们只关心一点，人生到底还有没有救。</p>\n<p>简单可行？到底是否可以做到？在你学英语的时候，在你健身的时候，在你打工赚钱的时候。很显然这三件事都不简单，你不应该再过多的考虑这种复杂的事情了。生活中当然有简单的事情，只是你看不上它们罢了，或者你觉着它们的意义太低。比如背一篇新概念3的文章，不算太难，如果觉着太难，那就背一段好了，但是你会想一些看起来很合理，实际上很荒唐的事情，你会想：背了又怎样，有什么用呢？或者我知道背了有点小用，坚持下去背很多就更是有大用了，但这太漫长了，没人能坚持下去。这就牵涉到及时反馈了，你急需立竿见影的效果，否则会在一次又一次的考虑中丧失你的动机。</p>\n<p>及时反馈？那你怎么及时反馈？背一篇新概念的文章的一段，对你学好英语的作用就是微乎其微，从这个角度来讲，你需要其他来源的反馈。</p>\n<p>无限尝试是不可能了，但有限的 多次模拟 还是可以的。</p>\n<p>公平竞技也是不可能的，这一点没有办法（很多英语国家的人不用死命学英语啊，长大成人了谁不会说母语？有些人出生就含着金钥匙啊，富二代官二代），我们只能靠自己，你也可以反过来想，起点很低，却靠自己的智慧变得很厉害，是不是更有成就感（强行安慰自己）。</p>\n<h2 id=\"把人生游戏化的方法\"><a href=\"#把人生游戏化的方法\" class=\"headerlink\" title=\"把人生游戏化的方法\"></a>把人生游戏化的方法</h2><p>从上面的分析可以看出人生非常难以游戏化，但我们不能坐以待毙，下面我来讲讲我自己的一些想法吧。</p>\n<p>我自己是学计算机的，在外行看来，计算机是非常神秘的领域，就像某种魔法一样，事实上即便是我们这种内行，如果不清楚具体的实现过程，那么被抽象封装的部分依然是很神秘的，魔幻的。所以我们不妨把计算机技术当成一种现代魔法，而我们学计算机的都是魔法师，像Linus Torvalds、吴恩达这样的则是大法师。我们人区别于动物的地方是什么呢？</p>\n<ol>\n<li>知识</li>\n<li>合作</li>\n</ol>\n<p>我们能达成上百万人的合作（比如：波音飞机的整个生产过程，有人搞理论，有人设计，有人组装），我们能快速习得知识技能而不用依赖遗传和自然选择。知识+合作=文明。</p>\n<p>怎样变成一个更优秀的人？</p>\n<ol>\n<li>习得更多的知识</li>\n<li>拥有更强的合作技巧和能力</li>\n</ol>\n<p>我们接受教育，不停学习，就是习得更多的知识，我们和人交友，加入公司，获取财富和资本，创业，拉投资，就是拥有更强的合作能力。</p>\n<p>游戏是没有一个确定目的的（很多游戏可以有多种玩法和目的），即便很多游戏有一个终极目标，有一个通关的路径，但游戏的意义却非仅此而已，如果仅有一个最终目标，达成目标之后就变得无趣了。游戏拥有一个有趣的过程，让人沉浸其中。所以你可以给你的人生设定一个伟大的目标，但不要忘了，生活的意义不仅在于此，生活的意义还在于你生活的每一年，每一个月，每一天。</p>\n<p>把事情变得简单可行，就是要分割和量化目标，提供及时反馈就是要量化成果，得到激励。无限尝试，就是要不停模拟实践。公平竞技，算了吧，不谈这个(你可以从比你基础更差的人身上获取安慰，你想啊至少你的出身没有差到那个地步，是吧)。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"人生没有意义\"><a href=\"#人生没有意义\" class=\"headerlink\" title=\"人生没有意义\"></a>人生没有意义</h2><p>人喜欢讲意义，但似乎是件很可笑的事情，因为意义是人虚构出来的东西，这个世界上有些东西存在就是存在，不讲道理的存在，没有意义的存在。不信你去问问宇宙存在有什么意义？宇宙之外有没有意义？时间有什么意义？人生又有什么意义？哪怕你想破脑袋也没用。别拿意义去套你的人生了，百年之后终归尘土。就像泰戈尔写的诗：鸟在天空划过，不留下任何痕迹。马克思哲学也说：新事物终将取代旧事物，历史车轮曲折前进。这里是说你会死，就算你不会死又能怎样，永远活下去就能找到人生的意义？嗯，如果能做到同宇宙同岁也许可以，但别瞎想了，在你有生之年都不可能实现。</p>\n<p>没有一个终极意义你会慌乱吗？</p>\n<h2 id=\"游戏-vs-人生\"><a href=\"#游戏-vs-人生\" class=\"headerlink\" title=\"游戏 vs. 人生\"></a>游戏 vs. 人生</h2><p>人都是喜欢游戏的，人可以进行没有实际奖励的游戏，人甚至可以进行不为输赢的游戏。很奇怪吧，当你小时候和小伙伴玩泥巴，当你打着坦克，玩着超级玛丽，当你打着魔兽、DOTA、英雄联盟，炉石传说，当你在Minecraft、饥荒里面一玩就忘了时间。你想想你到底在干嘛？你有为了某个意义去玩游戏吗？你也许会抱怨，人生为什么这么枯燥，人生为什么不像游戏？</p>\n<ul>\n<li>简单可行</li>\n<li>及时反馈</li>\n<li>无限尝试</li>\n<li>公平竞技</li>\n</ul>\n<p>发现没有，人生跟这四个属性一个都不挨边。 谁的人生是简单可行的？谁的人生是及时反馈的？谁的人生可以无限尝试，不服再来？谁的人生是生活在公平之中？</p>\n<p>一个复杂无比、充满未知的人生，一个慢慢长途、平淡无奇的人生；一个只有一次、甚至其中的很多阶段、很多事都只有一次的人生；一个连公平都做不到无比艰辛的人生。你想不想说一句life is a shit! 同志啊，这句话我早就想说了。</p>\n<p>来来来，对着上面这四条，你仔细想想：</p>\n<ul>\n<li>有多少人一辈子为生计奔走、迷茫、看不见未来、与机会擦肩而过？</li>\n<li>有多少人不停焦虑、制定计划、却不能坚持、始终碌碌无为？</li>\n<li>有多少事错了就不能再重来？</li>\n<li>有多少人，生来就缺乏竞争力？</li>\n</ul>\n<p>想通了吗？想通了就OK，你要是不能忍上面这四条，却依然厚着脸皮说你喜欢人生、热爱生活，我要骂你：真他妈能装逼，真是厚脸皮！那你要说，不然呢？我生下来就已经是这个样了啊，怪我咯！其实你是正确的，如果你还有活着的欲望，没有急着去死，那么你就该热爱你的生活，罗素有句话叫做：只有一种英雄主义，就是在认清生活真相之后，依然热爱生活。因为这是你的生活，你别无选择。</p>\n<p>大学的同学不用再抱怨大学了，不就迷茫了四年嘛，你没发现你其实上大学之前也只是在幻想人生的美事吗？你没发现你上大学之前一直是被安排着忙忙碌碌吗？大学打破了你的美梦，很好，大学让你迷茫，很好，大学让你又闲又焦虑不堪，这更好，大学让你有时间开始思考人生，简直完美！</p>\n<p>其实你忘了，小学的时候你也被老师的抄写课文后的生字词这种作业，弄的死去活来，每讲到新的一课，就从第一课抄到这一课（PS：这就是我真实的童年）。其实你也忘了，上高中的时候，做不完的题，做题做到想吐，从此落下对做题的厌恶感这种奇怪的病根。</p>\n<p>现在我们只关心一点，人生到底还有没有救。</p>\n<p>简单可行？到底是否可以做到？在你学英语的时候，在你健身的时候，在你打工赚钱的时候。很显然这三件事都不简单，你不应该再过多的考虑这种复杂的事情了。生活中当然有简单的事情，只是你看不上它们罢了，或者你觉着它们的意义太低。比如背一篇新概念3的文章，不算太难，如果觉着太难，那就背一段好了，但是你会想一些看起来很合理，实际上很荒唐的事情，你会想：背了又怎样，有什么用呢？或者我知道背了有点小用，坚持下去背很多就更是有大用了，但这太漫长了，没人能坚持下去。这就牵涉到及时反馈了，你急需立竿见影的效果，否则会在一次又一次的考虑中丧失你的动机。</p>\n<p>及时反馈？那你怎么及时反馈？背一篇新概念的文章的一段，对你学好英语的作用就是微乎其微，从这个角度来讲，你需要其他来源的反馈。</p>\n<p>无限尝试是不可能了，但有限的 多次模拟 还是可以的。</p>\n<p>公平竞技也是不可能的，这一点没有办法（很多英语国家的人不用死命学英语啊，长大成人了谁不会说母语？有些人出生就含着金钥匙啊，富二代官二代），我们只能靠自己，你也可以反过来想，起点很低，却靠自己的智慧变得很厉害，是不是更有成就感（强行安慰自己）。</p>\n<h2 id=\"把人生游戏化的方法\"><a href=\"#把人生游戏化的方法\" class=\"headerlink\" title=\"把人生游戏化的方法\"></a>把人生游戏化的方法</h2><p>从上面的分析可以看出人生非常难以游戏化，但我们不能坐以待毙，下面我来讲讲我自己的一些想法吧。</p>\n<p>我自己是学计算机的，在外行看来，计算机是非常神秘的领域，就像某种魔法一样，事实上即便是我们这种内行，如果不清楚具体的实现过程，那么被抽象封装的部分依然是很神秘的，魔幻的。所以我们不妨把计算机技术当成一种现代魔法，而我们学计算机的都是魔法师，像Linus Torvalds、吴恩达这样的则是大法师。我们人区别于动物的地方是什么呢？</p>\n<ol>\n<li>知识</li>\n<li>合作</li>\n</ol>\n<p>我们能达成上百万人的合作（比如：波音飞机的整个生产过程，有人搞理论，有人设计，有人组装），我们能快速习得知识技能而不用依赖遗传和自然选择。知识+合作=文明。</p>\n<p>怎样变成一个更优秀的人？</p>\n<ol>\n<li>习得更多的知识</li>\n<li>拥有更强的合作技巧和能力</li>\n</ol>\n<p>我们接受教育，不停学习，就是习得更多的知识，我们和人交友，加入公司，获取财富和资本，创业，拉投资，就是拥有更强的合作能力。</p>\n<p>游戏是没有一个确定目的的（很多游戏可以有多种玩法和目的），即便很多游戏有一个终极目标，有一个通关的路径，但游戏的意义却非仅此而已，如果仅有一个最终目标，达成目标之后就变得无趣了。游戏拥有一个有趣的过程，让人沉浸其中。所以你可以给你的人生设定一个伟大的目标，但不要忘了，生活的意义不仅在于此，生活的意义还在于你生活的每一年，每一个月，每一天。</p>\n<p>把事情变得简单可行，就是要分割和量化目标，提供及时反馈就是要量化成果，得到激励。无限尝试，就是要不停模拟实践。公平竞技，算了吧，不谈这个(你可以从比你基础更差的人身上获取安慰，你想啊至少你的出身没有差到那个地步，是吧)。</p>\n"},{"layout":"post","title":"Macbook","date":"2017-02-02T16:00:00.000Z","comments":1,"_content":"\n好的工具可以使人事半功倍，回顾整个人类史，又何尝不是一个工具史呢，从用石器到用火，从铁器到火药，从蒸汽机到内燃机，从汽车到电脑，我们在使用工具、利用自然规律，从而让自身变得越来越强大。\n\n## 为什么推荐 Macbook\n\n我使用macbook pro 15 retina 已经一年了，感觉非常好（之前用过惠普的一个笔记本，加过内存条，折腾过固态硬盘，但最后还是受不了那风扇呼呼转）。现在我手头上同时还有一个surface pro 4 m3，M3也就是不带风扇的那款，性能一般，当初买是为了那支笔，能在电脑上写写画画，结果现在买了之后很少用这个surface，但是转手卖了又觉得亏本了，可惜，只好留在家里，留着以后做古董吧。\n\nmac机器的亮点：\n\n- 轻薄\n- 另外触摸板真的很好用，我已经很久没用过鼠标了\n- retina屏也是非常养眼\n- 立体声也十分不错\n- 细节做得很好，充电口是磁性的，正反两面都能充，指示灯是能显示是否充满的（用过surface pro 4 的对比一下就知道，什么叫做细心），键盘背光，铝制机身，最后外观简洁美观。\n\nOS X的最大亮点：\n\n- GUI(Graphical User Interface，图形用户界面)和CLI(Command-Line Interface，命令行界面)的完美结合\n- 优化的很好，系统耗电少。\n- 开机速度非常快，另外不用老是关机，我很多时候一个星期都不关机。\n\n缺点：\n\n1. 冬天用MacBook寒气逼人啊，把手放上面就知道了（南方，没有暖气，一般也不怎么开空调）\n\n可以说这是一个不错的工具，无论是对普通用户来说，还是对程序员来说。最大的缺点无疑是：太贵啦。\n\n所谓一分价钱一分货，3份价钱5分货，10分价钱7分货。意思就是，太便宜的东西往往质量很低，不便宜又不贵的往往性价比很高，特别贵的虽然确实质量非常好，但性价比却低了。\n\n我秉承的一个观点是，如果一样东西属于易耗品，如：袜子，内衣裤。我们就应该买性价比高的，大众一点的，我还记得有一次傻逼的去优衣库买了双14块钱的船袜，结果穿了一次就起球了，气得要死啊，还不如买便宜的。如果是非易耗品，如：笔记本电脑，手机，西装，皮鞋，钱包，背包等等。我们就应该在能承担的价格内，尽可能的买质量好的（尤其是你注重这个东西的品质的时候）。我特别注重电脑和手机的流畅性，所以我选择了Macbook pro 和 iphone，我打算至少用个5、6年吧（现在的电子设备产品迭代这么快，能用5、6年真的相当不错了）。另外我的双肩背包一定会买非常结实的帆布的款式（而且功能要多），我现在这个背包就背了3年多了，看起来有点旧，但仍然很好用（有考虑换新的双肩背包了，但是还没找到满意的，这种东西还是不能随便买，就跟你闲置在柜子里的衣服一样，买了不喜欢，不穿，浪费钱，而且通常我们只有一个背包，这就更要精挑细选了）。\n\n好了接下来就开始推荐MacBook的软件了：\n\n## 软件列表\n\n### 国内的常用娱乐软件\n\n- Mac QQ，社交\n- 网易云音乐，真的做的不是一般好，相比于其他的什么酷狗、多米。网易云音乐还有Linux版哦，UWP版（Universal Windows Platform）做的也很不错。这里要批评一下网易云音乐，Mac 版的分享是没办法给其他社交网络上的好友贴链接的（连 Linux 版都有的功能），我每次想分享出去都要打开 Chrome 使用网页版的网易云音乐，那我要你客户端干啥？已经提了 issue，看看网易云音乐的 Mac 工作组能不能加上这个功能吧，对程序员来说这就是顺手的事，做产品关键还是要用心啊。\n- 新浪微博，这个我很少用，微博也刷的少，于是就卸载了，等以后学会高效使用新浪微博了估计会装一个。\n- 百度云，比起Windows版的不知道难用到哪里去了，好在一直在进步。\n- 迅雷，没有广告，比Windows的迅雷爽多了，每次打开Windows的迅雷9都有种想哭的感觉，各种广告视频自动播放，好抢眼啊。\n- leanote（蚂蚁笔记），现在的笔记软件都开始收费了，如：印象笔记、为知笔记，还有这个蚂蚁笔记也收费了。庆幸的是我现在不写笔记了，我写博客，热衷分享，帮助新人，提高声望。\n- 为知笔记，为知笔记总体来说是最棒的，现在也收费了，但也阻止不了我用它。\n- 有道词典\n- 优酷客户端\n- 爱奇艺客户端，亲们，这两个客户端放视频没有广告！！！，真是太赞了。\n- 腾讯视频客户端，这个是新出的，同样没有广告，还可以看蓝光\n- 阿里旺旺\n- 每日英语听力\n\nMacBook进阶软件：\n\n- homebrew/brew cask（mac的软件源，让你可以像玩linux一样，用命令安装软件）\n- Chrome，Chrome和Firefox，最经典也是最好用的两个浏览器。不过在MacBook上，safari的性能确实比chrome要好，另外safari可以强制使用HTML5播放视频哦，这样MacBook在看视频的时候就不会发热啦。\n- Atom，github推出的指定码农编辑器，MacBook上很好用，Windows上开启有点慢。（温馨提示，码字的时候，开着markdown previewer，打字会很卡，刚开始的时候我差点因为这个莫名的卡顿，而放弃Atom了，后来找到了原因😄）\n- calibre，可以看各种电子书，转格式\n- LICEcap，使用gif格式录制你鼠标的操作。\n- Pocket，把文章收藏起来慢慢看的一个软件\n- iStat Menus，显示电脑的各种硬件状态\n- TeamViewer，跟QQ远程桌面控制类似，不过这个更专业。\n- Blu-ray Player，蓝光视频播放器，要收费，付不起钱只好在每次打开的时候把注册窗口叉掉。\n- Irvue，更换壁纸软件\n- Sip，取像素点的颜色软件\n- VMware Fusion，MacBook专用虚拟机\n- The unarchiver，解压缩软件\n- Keka，压缩和解压缩软件\n- OmniDiskSweeper，查找大文件\n- Bartender 2，把MacBook的顶层工具栏里的图标藏起来\n- Bartender 2效果截图\n\n![Bartender 2效果截图](http://wx2.sinaimg.cn/mw690/006zFO3ggy1fcd4m7je0qj31kw0zk4ax.jpg)\n\n程序员往这里看：\n\n- Xcode，相当于Windows上的Visual Studio吧，主要用来开发苹果平台上的软件，平常可以用来写写C/C++\n- iTerm2，超好用的终端软件\n- oh-my-zsh，超好用的shell\n- dash，文档，内容相当丰富，连LaTeX和markdown的文档都有，不过有时候要等7秒钟才让你看文档。\n- FileZilla，FTP利器\n- github desktop，git的桌面版，很少用，程序员还是多用命令行吧，要不然让你搞Linux服务器，记不起git命令就显得low逼了。\n- Pycharm，jetbrains家的IDE个个都好用，这个是用来写Python的\n- Intellj IDEA，jetbrains家的IDE个个都好用，这个是用来写Java的\n- Android Studio，jetbrains家的IDE个个都好用，这个是用来写Android的\n- RubyMine，jetbrains家的IDE个个都好用，这个是用来写ruby的\n- CLion，jetbrains家的IDE个个都好用，这个是用来写C、C++的\n- jetbrains家的IDE\n\n![jetbrains家的IDE](http://wx2.sinaimg.cn/mw690/006zFO3ggy1fcd4vbx60yj31kw0zkqez.jpg)\n\n如何顺利的从Windows使用习惯迁移到macbook使用习惯，我写了一篇文章：[从 Windows 转用 Mac OS X 记录](../2017/01/01/从windows转用macOSX记录)\n\n另外建议买东西不要贪小便宜，一定要买正版，我的 Macbook 是在淘宝上买的比较便宜的，结果屏幕涂层脱落了，商家也不给赔偿，送苹果 genius bar 查出我的机器不是正版，也不给修。最后换屏（非官方渠道，要1500人民币）\n","source":"_posts/2017/2017-02-03-Macbook.md","raw":"---\nlayout: post\ntitle: Macbook\ndate: 2017-02-03\ncategories: [数码]\ntags: [工具]\ncomments: true\n---\n\n好的工具可以使人事半功倍，回顾整个人类史，又何尝不是一个工具史呢，从用石器到用火，从铁器到火药，从蒸汽机到内燃机，从汽车到电脑，我们在使用工具、利用自然规律，从而让自身变得越来越强大。\n\n## 为什么推荐 Macbook\n\n我使用macbook pro 15 retina 已经一年了，感觉非常好（之前用过惠普的一个笔记本，加过内存条，折腾过固态硬盘，但最后还是受不了那风扇呼呼转）。现在我手头上同时还有一个surface pro 4 m3，M3也就是不带风扇的那款，性能一般，当初买是为了那支笔，能在电脑上写写画画，结果现在买了之后很少用这个surface，但是转手卖了又觉得亏本了，可惜，只好留在家里，留着以后做古董吧。\n\nmac机器的亮点：\n\n- 轻薄\n- 另外触摸板真的很好用，我已经很久没用过鼠标了\n- retina屏也是非常养眼\n- 立体声也十分不错\n- 细节做得很好，充电口是磁性的，正反两面都能充，指示灯是能显示是否充满的（用过surface pro 4 的对比一下就知道，什么叫做细心），键盘背光，铝制机身，最后外观简洁美观。\n\nOS X的最大亮点：\n\n- GUI(Graphical User Interface，图形用户界面)和CLI(Command-Line Interface，命令行界面)的完美结合\n- 优化的很好，系统耗电少。\n- 开机速度非常快，另外不用老是关机，我很多时候一个星期都不关机。\n\n缺点：\n\n1. 冬天用MacBook寒气逼人啊，把手放上面就知道了（南方，没有暖气，一般也不怎么开空调）\n\n可以说这是一个不错的工具，无论是对普通用户来说，还是对程序员来说。最大的缺点无疑是：太贵啦。\n\n所谓一分价钱一分货，3份价钱5分货，10分价钱7分货。意思就是，太便宜的东西往往质量很低，不便宜又不贵的往往性价比很高，特别贵的虽然确实质量非常好，但性价比却低了。\n\n我秉承的一个观点是，如果一样东西属于易耗品，如：袜子，内衣裤。我们就应该买性价比高的，大众一点的，我还记得有一次傻逼的去优衣库买了双14块钱的船袜，结果穿了一次就起球了，气得要死啊，还不如买便宜的。如果是非易耗品，如：笔记本电脑，手机，西装，皮鞋，钱包，背包等等。我们就应该在能承担的价格内，尽可能的买质量好的（尤其是你注重这个东西的品质的时候）。我特别注重电脑和手机的流畅性，所以我选择了Macbook pro 和 iphone，我打算至少用个5、6年吧（现在的电子设备产品迭代这么快，能用5、6年真的相当不错了）。另外我的双肩背包一定会买非常结实的帆布的款式（而且功能要多），我现在这个背包就背了3年多了，看起来有点旧，但仍然很好用（有考虑换新的双肩背包了，但是还没找到满意的，这种东西还是不能随便买，就跟你闲置在柜子里的衣服一样，买了不喜欢，不穿，浪费钱，而且通常我们只有一个背包，这就更要精挑细选了）。\n\n好了接下来就开始推荐MacBook的软件了：\n\n## 软件列表\n\n### 国内的常用娱乐软件\n\n- Mac QQ，社交\n- 网易云音乐，真的做的不是一般好，相比于其他的什么酷狗、多米。网易云音乐还有Linux版哦，UWP版（Universal Windows Platform）做的也很不错。这里要批评一下网易云音乐，Mac 版的分享是没办法给其他社交网络上的好友贴链接的（连 Linux 版都有的功能），我每次想分享出去都要打开 Chrome 使用网页版的网易云音乐，那我要你客户端干啥？已经提了 issue，看看网易云音乐的 Mac 工作组能不能加上这个功能吧，对程序员来说这就是顺手的事，做产品关键还是要用心啊。\n- 新浪微博，这个我很少用，微博也刷的少，于是就卸载了，等以后学会高效使用新浪微博了估计会装一个。\n- 百度云，比起Windows版的不知道难用到哪里去了，好在一直在进步。\n- 迅雷，没有广告，比Windows的迅雷爽多了，每次打开Windows的迅雷9都有种想哭的感觉，各种广告视频自动播放，好抢眼啊。\n- leanote（蚂蚁笔记），现在的笔记软件都开始收费了，如：印象笔记、为知笔记，还有这个蚂蚁笔记也收费了。庆幸的是我现在不写笔记了，我写博客，热衷分享，帮助新人，提高声望。\n- 为知笔记，为知笔记总体来说是最棒的，现在也收费了，但也阻止不了我用它。\n- 有道词典\n- 优酷客户端\n- 爱奇艺客户端，亲们，这两个客户端放视频没有广告！！！，真是太赞了。\n- 腾讯视频客户端，这个是新出的，同样没有广告，还可以看蓝光\n- 阿里旺旺\n- 每日英语听力\n\nMacBook进阶软件：\n\n- homebrew/brew cask（mac的软件源，让你可以像玩linux一样，用命令安装软件）\n- Chrome，Chrome和Firefox，最经典也是最好用的两个浏览器。不过在MacBook上，safari的性能确实比chrome要好，另外safari可以强制使用HTML5播放视频哦，这样MacBook在看视频的时候就不会发热啦。\n- Atom，github推出的指定码农编辑器，MacBook上很好用，Windows上开启有点慢。（温馨提示，码字的时候，开着markdown previewer，打字会很卡，刚开始的时候我差点因为这个莫名的卡顿，而放弃Atom了，后来找到了原因😄）\n- calibre，可以看各种电子书，转格式\n- LICEcap，使用gif格式录制你鼠标的操作。\n- Pocket，把文章收藏起来慢慢看的一个软件\n- iStat Menus，显示电脑的各种硬件状态\n- TeamViewer，跟QQ远程桌面控制类似，不过这个更专业。\n- Blu-ray Player，蓝光视频播放器，要收费，付不起钱只好在每次打开的时候把注册窗口叉掉。\n- Irvue，更换壁纸软件\n- Sip，取像素点的颜色软件\n- VMware Fusion，MacBook专用虚拟机\n- The unarchiver，解压缩软件\n- Keka，压缩和解压缩软件\n- OmniDiskSweeper，查找大文件\n- Bartender 2，把MacBook的顶层工具栏里的图标藏起来\n- Bartender 2效果截图\n\n![Bartender 2效果截图](http://wx2.sinaimg.cn/mw690/006zFO3ggy1fcd4m7je0qj31kw0zk4ax.jpg)\n\n程序员往这里看：\n\n- Xcode，相当于Windows上的Visual Studio吧，主要用来开发苹果平台上的软件，平常可以用来写写C/C++\n- iTerm2，超好用的终端软件\n- oh-my-zsh，超好用的shell\n- dash，文档，内容相当丰富，连LaTeX和markdown的文档都有，不过有时候要等7秒钟才让你看文档。\n- FileZilla，FTP利器\n- github desktop，git的桌面版，很少用，程序员还是多用命令行吧，要不然让你搞Linux服务器，记不起git命令就显得low逼了。\n- Pycharm，jetbrains家的IDE个个都好用，这个是用来写Python的\n- Intellj IDEA，jetbrains家的IDE个个都好用，这个是用来写Java的\n- Android Studio，jetbrains家的IDE个个都好用，这个是用来写Android的\n- RubyMine，jetbrains家的IDE个个都好用，这个是用来写ruby的\n- CLion，jetbrains家的IDE个个都好用，这个是用来写C、C++的\n- jetbrains家的IDE\n\n![jetbrains家的IDE](http://wx2.sinaimg.cn/mw690/006zFO3ggy1fcd4vbx60yj31kw0zkqez.jpg)\n\n如何顺利的从Windows使用习惯迁移到macbook使用习惯，我写了一篇文章：[从 Windows 转用 Mac OS X 记录](../2017/01/01/从windows转用macOSX记录)\n\n另外建议买东西不要贪小便宜，一定要买正版，我的 Macbook 是在淘宝上买的比较便宜的，结果屏幕涂层脱落了，商家也不给赔偿，送苹果 genius bar 查出我的机器不是正版，也不给修。最后换屏（非官方渠道，要1500人民币）\n","slug":"Macbook","published":1,"updated":"2018-04-25T07:40:47.091Z","photos":[],"link":"","_id":"cjm2w8dcv0011fgpxukuwarth","content":"<p>好的工具可以使人事半功倍，回顾整个人类史，又何尝不是一个工具史呢，从用石器到用火，从铁器到火药，从蒸汽机到内燃机，从汽车到电脑，我们在使用工具、利用自然规律，从而让自身变得越来越强大。</p>\n<h2 id=\"为什么推荐-Macbook\"><a href=\"#为什么推荐-Macbook\" class=\"headerlink\" title=\"为什么推荐 Macbook\"></a>为什么推荐 Macbook</h2><p>我使用macbook pro 15 retina 已经一年了，感觉非常好（之前用过惠普的一个笔记本，加过内存条，折腾过固态硬盘，但最后还是受不了那风扇呼呼转）。现在我手头上同时还有一个surface pro 4 m3，M3也就是不带风扇的那款，性能一般，当初买是为了那支笔，能在电脑上写写画画，结果现在买了之后很少用这个surface，但是转手卖了又觉得亏本了，可惜，只好留在家里，留着以后做古董吧。</p>\n<p>mac机器的亮点：</p>\n<ul>\n<li>轻薄</li>\n<li>另外触摸板真的很好用，我已经很久没用过鼠标了</li>\n<li>retina屏也是非常养眼</li>\n<li>立体声也十分不错</li>\n<li>细节做得很好，充电口是磁性的，正反两面都能充，指示灯是能显示是否充满的（用过surface pro 4 的对比一下就知道，什么叫做细心），键盘背光，铝制机身，最后外观简洁美观。</li>\n</ul>\n<p>OS X的最大亮点：</p>\n<ul>\n<li>GUI(Graphical User Interface，图形用户界面)和CLI(Command-Line Interface，命令行界面)的完美结合</li>\n<li>优化的很好，系统耗电少。</li>\n<li>开机速度非常快，另外不用老是关机，我很多时候一个星期都不关机。</li>\n</ul>\n<p>缺点：</p>\n<ol>\n<li>冬天用MacBook寒气逼人啊，把手放上面就知道了（南方，没有暖气，一般也不怎么开空调）</li>\n</ol>\n<p>可以说这是一个不错的工具，无论是对普通用户来说，还是对程序员来说。最大的缺点无疑是：太贵啦。</p>\n<p>所谓一分价钱一分货，3份价钱5分货，10分价钱7分货。意思就是，太便宜的东西往往质量很低，不便宜又不贵的往往性价比很高，特别贵的虽然确实质量非常好，但性价比却低了。</p>\n<p>我秉承的一个观点是，如果一样东西属于易耗品，如：袜子，内衣裤。我们就应该买性价比高的，大众一点的，我还记得有一次傻逼的去优衣库买了双14块钱的船袜，结果穿了一次就起球了，气得要死啊，还不如买便宜的。如果是非易耗品，如：笔记本电脑，手机，西装，皮鞋，钱包，背包等等。我们就应该在能承担的价格内，尽可能的买质量好的（尤其是你注重这个东西的品质的时候）。我特别注重电脑和手机的流畅性，所以我选择了Macbook pro 和 iphone，我打算至少用个5、6年吧（现在的电子设备产品迭代这么快，能用5、6年真的相当不错了）。另外我的双肩背包一定会买非常结实的帆布的款式（而且功能要多），我现在这个背包就背了3年多了，看起来有点旧，但仍然很好用（有考虑换新的双肩背包了，但是还没找到满意的，这种东西还是不能随便买，就跟你闲置在柜子里的衣服一样，买了不喜欢，不穿，浪费钱，而且通常我们只有一个背包，这就更要精挑细选了）。</p>\n<p>好了接下来就开始推荐MacBook的软件了：</p>\n<h2 id=\"软件列表\"><a href=\"#软件列表\" class=\"headerlink\" title=\"软件列表\"></a>软件列表</h2><h3 id=\"国内的常用娱乐软件\"><a href=\"#国内的常用娱乐软件\" class=\"headerlink\" title=\"国内的常用娱乐软件\"></a>国内的常用娱乐软件</h3><ul>\n<li>Mac QQ，社交</li>\n<li>网易云音乐，真的做的不是一般好，相比于其他的什么酷狗、多米。网易云音乐还有Linux版哦，UWP版（Universal Windows Platform）做的也很不错。这里要批评一下网易云音乐，Mac 版的分享是没办法给其他社交网络上的好友贴链接的（连 Linux 版都有的功能），我每次想分享出去都要打开 Chrome 使用网页版的网易云音乐，那我要你客户端干啥？已经提了 issue，看看网易云音乐的 Mac 工作组能不能加上这个功能吧，对程序员来说这就是顺手的事，做产品关键还是要用心啊。</li>\n<li>新浪微博，这个我很少用，微博也刷的少，于是就卸载了，等以后学会高效使用新浪微博了估计会装一个。</li>\n<li>百度云，比起Windows版的不知道难用到哪里去了，好在一直在进步。</li>\n<li>迅雷，没有广告，比Windows的迅雷爽多了，每次打开Windows的迅雷9都有种想哭的感觉，各种广告视频自动播放，好抢眼啊。</li>\n<li>leanote（蚂蚁笔记），现在的笔记软件都开始收费了，如：印象笔记、为知笔记，还有这个蚂蚁笔记也收费了。庆幸的是我现在不写笔记了，我写博客，热衷分享，帮助新人，提高声望。</li>\n<li>为知笔记，为知笔记总体来说是最棒的，现在也收费了，但也阻止不了我用它。</li>\n<li>有道词典</li>\n<li>优酷客户端</li>\n<li>爱奇艺客户端，亲们，这两个客户端放视频没有广告！！！，真是太赞了。</li>\n<li>腾讯视频客户端，这个是新出的，同样没有广告，还可以看蓝光</li>\n<li>阿里旺旺</li>\n<li>每日英语听力</li>\n</ul>\n<p>MacBook进阶软件：</p>\n<ul>\n<li>homebrew/brew cask（mac的软件源，让你可以像玩linux一样，用命令安装软件）</li>\n<li>Chrome，Chrome和Firefox，最经典也是最好用的两个浏览器。不过在MacBook上，safari的性能确实比chrome要好，另外safari可以强制使用HTML5播放视频哦，这样MacBook在看视频的时候就不会发热啦。</li>\n<li>Atom，github推出的指定码农编辑器，MacBook上很好用，Windows上开启有点慢。（温馨提示，码字的时候，开着markdown previewer，打字会很卡，刚开始的时候我差点因为这个莫名的卡顿，而放弃Atom了，后来找到了原因😄）</li>\n<li>calibre，可以看各种电子书，转格式</li>\n<li>LICEcap，使用gif格式录制你鼠标的操作。</li>\n<li>Pocket，把文章收藏起来慢慢看的一个软件</li>\n<li>iStat Menus，显示电脑的各种硬件状态</li>\n<li>TeamViewer，跟QQ远程桌面控制类似，不过这个更专业。</li>\n<li>Blu-ray Player，蓝光视频播放器，要收费，付不起钱只好在每次打开的时候把注册窗口叉掉。</li>\n<li>Irvue，更换壁纸软件</li>\n<li>Sip，取像素点的颜色软件</li>\n<li>VMware Fusion，MacBook专用虚拟机</li>\n<li>The unarchiver，解压缩软件</li>\n<li>Keka，压缩和解压缩软件</li>\n<li>OmniDiskSweeper，查找大文件</li>\n<li>Bartender 2，把MacBook的顶层工具栏里的图标藏起来</li>\n<li>Bartender 2效果截图</li>\n</ul>\n<p><img src=\"http://wx2.sinaimg.cn/mw690/006zFO3ggy1fcd4m7je0qj31kw0zk4ax.jpg\" alt=\"Bartender 2效果截图\"></p>\n<p>程序员往这里看：</p>\n<ul>\n<li>Xcode，相当于Windows上的Visual Studio吧，主要用来开发苹果平台上的软件，平常可以用来写写C/C++</li>\n<li>iTerm2，超好用的终端软件</li>\n<li>oh-my-zsh，超好用的shell</li>\n<li>dash，文档，内容相当丰富，连LaTeX和markdown的文档都有，不过有时候要等7秒钟才让你看文档。</li>\n<li>FileZilla，FTP利器</li>\n<li>github desktop，git的桌面版，很少用，程序员还是多用命令行吧，要不然让你搞Linux服务器，记不起git命令就显得low逼了。</li>\n<li>Pycharm，jetbrains家的IDE个个都好用，这个是用来写Python的</li>\n<li>Intellj IDEA，jetbrains家的IDE个个都好用，这个是用来写Java的</li>\n<li>Android Studio，jetbrains家的IDE个个都好用，这个是用来写Android的</li>\n<li>RubyMine，jetbrains家的IDE个个都好用，这个是用来写ruby的</li>\n<li>CLion，jetbrains家的IDE个个都好用，这个是用来写C、C++的</li>\n<li>jetbrains家的IDE</li>\n</ul>\n<p><img src=\"http://wx2.sinaimg.cn/mw690/006zFO3ggy1fcd4vbx60yj31kw0zkqez.jpg\" alt=\"jetbrains家的IDE\"></p>\n<p>如何顺利的从Windows使用习惯迁移到macbook使用习惯，我写了一篇文章：<a href=\"../2017/01/01/从windows转用macOSX记录\">从 Windows 转用 Mac OS X 记录</a></p>\n<p>另外建议买东西不要贪小便宜，一定要买正版，我的 Macbook 是在淘宝上买的比较便宜的，结果屏幕涂层脱落了，商家也不给赔偿，送苹果 genius bar 查出我的机器不是正版，也不给修。最后换屏（非官方渠道，要1500人民币）</p>\n","site":{"data":{}},"excerpt":"","more":"<p>好的工具可以使人事半功倍，回顾整个人类史，又何尝不是一个工具史呢，从用石器到用火，从铁器到火药，从蒸汽机到内燃机，从汽车到电脑，我们在使用工具、利用自然规律，从而让自身变得越来越强大。</p>\n<h2 id=\"为什么推荐-Macbook\"><a href=\"#为什么推荐-Macbook\" class=\"headerlink\" title=\"为什么推荐 Macbook\"></a>为什么推荐 Macbook</h2><p>我使用macbook pro 15 retina 已经一年了，感觉非常好（之前用过惠普的一个笔记本，加过内存条，折腾过固态硬盘，但最后还是受不了那风扇呼呼转）。现在我手头上同时还有一个surface pro 4 m3，M3也就是不带风扇的那款，性能一般，当初买是为了那支笔，能在电脑上写写画画，结果现在买了之后很少用这个surface，但是转手卖了又觉得亏本了，可惜，只好留在家里，留着以后做古董吧。</p>\n<p>mac机器的亮点：</p>\n<ul>\n<li>轻薄</li>\n<li>另外触摸板真的很好用，我已经很久没用过鼠标了</li>\n<li>retina屏也是非常养眼</li>\n<li>立体声也十分不错</li>\n<li>细节做得很好，充电口是磁性的，正反两面都能充，指示灯是能显示是否充满的（用过surface pro 4 的对比一下就知道，什么叫做细心），键盘背光，铝制机身，最后外观简洁美观。</li>\n</ul>\n<p>OS X的最大亮点：</p>\n<ul>\n<li>GUI(Graphical User Interface，图形用户界面)和CLI(Command-Line Interface，命令行界面)的完美结合</li>\n<li>优化的很好，系统耗电少。</li>\n<li>开机速度非常快，另外不用老是关机，我很多时候一个星期都不关机。</li>\n</ul>\n<p>缺点：</p>\n<ol>\n<li>冬天用MacBook寒气逼人啊，把手放上面就知道了（南方，没有暖气，一般也不怎么开空调）</li>\n</ol>\n<p>可以说这是一个不错的工具，无论是对普通用户来说，还是对程序员来说。最大的缺点无疑是：太贵啦。</p>\n<p>所谓一分价钱一分货，3份价钱5分货，10分价钱7分货。意思就是，太便宜的东西往往质量很低，不便宜又不贵的往往性价比很高，特别贵的虽然确实质量非常好，但性价比却低了。</p>\n<p>我秉承的一个观点是，如果一样东西属于易耗品，如：袜子，内衣裤。我们就应该买性价比高的，大众一点的，我还记得有一次傻逼的去优衣库买了双14块钱的船袜，结果穿了一次就起球了，气得要死啊，还不如买便宜的。如果是非易耗品，如：笔记本电脑，手机，西装，皮鞋，钱包，背包等等。我们就应该在能承担的价格内，尽可能的买质量好的（尤其是你注重这个东西的品质的时候）。我特别注重电脑和手机的流畅性，所以我选择了Macbook pro 和 iphone，我打算至少用个5、6年吧（现在的电子设备产品迭代这么快，能用5、6年真的相当不错了）。另外我的双肩背包一定会买非常结实的帆布的款式（而且功能要多），我现在这个背包就背了3年多了，看起来有点旧，但仍然很好用（有考虑换新的双肩背包了，但是还没找到满意的，这种东西还是不能随便买，就跟你闲置在柜子里的衣服一样，买了不喜欢，不穿，浪费钱，而且通常我们只有一个背包，这就更要精挑细选了）。</p>\n<p>好了接下来就开始推荐MacBook的软件了：</p>\n<h2 id=\"软件列表\"><a href=\"#软件列表\" class=\"headerlink\" title=\"软件列表\"></a>软件列表</h2><h3 id=\"国内的常用娱乐软件\"><a href=\"#国内的常用娱乐软件\" class=\"headerlink\" title=\"国内的常用娱乐软件\"></a>国内的常用娱乐软件</h3><ul>\n<li>Mac QQ，社交</li>\n<li>网易云音乐，真的做的不是一般好，相比于其他的什么酷狗、多米。网易云音乐还有Linux版哦，UWP版（Universal Windows Platform）做的也很不错。这里要批评一下网易云音乐，Mac 版的分享是没办法给其他社交网络上的好友贴链接的（连 Linux 版都有的功能），我每次想分享出去都要打开 Chrome 使用网页版的网易云音乐，那我要你客户端干啥？已经提了 issue，看看网易云音乐的 Mac 工作组能不能加上这个功能吧，对程序员来说这就是顺手的事，做产品关键还是要用心啊。</li>\n<li>新浪微博，这个我很少用，微博也刷的少，于是就卸载了，等以后学会高效使用新浪微博了估计会装一个。</li>\n<li>百度云，比起Windows版的不知道难用到哪里去了，好在一直在进步。</li>\n<li>迅雷，没有广告，比Windows的迅雷爽多了，每次打开Windows的迅雷9都有种想哭的感觉，各种广告视频自动播放，好抢眼啊。</li>\n<li>leanote（蚂蚁笔记），现在的笔记软件都开始收费了，如：印象笔记、为知笔记，还有这个蚂蚁笔记也收费了。庆幸的是我现在不写笔记了，我写博客，热衷分享，帮助新人，提高声望。</li>\n<li>为知笔记，为知笔记总体来说是最棒的，现在也收费了，但也阻止不了我用它。</li>\n<li>有道词典</li>\n<li>优酷客户端</li>\n<li>爱奇艺客户端，亲们，这两个客户端放视频没有广告！！！，真是太赞了。</li>\n<li>腾讯视频客户端，这个是新出的，同样没有广告，还可以看蓝光</li>\n<li>阿里旺旺</li>\n<li>每日英语听力</li>\n</ul>\n<p>MacBook进阶软件：</p>\n<ul>\n<li>homebrew/brew cask（mac的软件源，让你可以像玩linux一样，用命令安装软件）</li>\n<li>Chrome，Chrome和Firefox，最经典也是最好用的两个浏览器。不过在MacBook上，safari的性能确实比chrome要好，另外safari可以强制使用HTML5播放视频哦，这样MacBook在看视频的时候就不会发热啦。</li>\n<li>Atom，github推出的指定码农编辑器，MacBook上很好用，Windows上开启有点慢。（温馨提示，码字的时候，开着markdown previewer，打字会很卡，刚开始的时候我差点因为这个莫名的卡顿，而放弃Atom了，后来找到了原因😄）</li>\n<li>calibre，可以看各种电子书，转格式</li>\n<li>LICEcap，使用gif格式录制你鼠标的操作。</li>\n<li>Pocket，把文章收藏起来慢慢看的一个软件</li>\n<li>iStat Menus，显示电脑的各种硬件状态</li>\n<li>TeamViewer，跟QQ远程桌面控制类似，不过这个更专业。</li>\n<li>Blu-ray Player，蓝光视频播放器，要收费，付不起钱只好在每次打开的时候把注册窗口叉掉。</li>\n<li>Irvue，更换壁纸软件</li>\n<li>Sip，取像素点的颜色软件</li>\n<li>VMware Fusion，MacBook专用虚拟机</li>\n<li>The unarchiver，解压缩软件</li>\n<li>Keka，压缩和解压缩软件</li>\n<li>OmniDiskSweeper，查找大文件</li>\n<li>Bartender 2，把MacBook的顶层工具栏里的图标藏起来</li>\n<li>Bartender 2效果截图</li>\n</ul>\n<p><img src=\"http://wx2.sinaimg.cn/mw690/006zFO3ggy1fcd4m7je0qj31kw0zk4ax.jpg\" alt=\"Bartender 2效果截图\"></p>\n<p>程序员往这里看：</p>\n<ul>\n<li>Xcode，相当于Windows上的Visual Studio吧，主要用来开发苹果平台上的软件，平常可以用来写写C/C++</li>\n<li>iTerm2，超好用的终端软件</li>\n<li>oh-my-zsh，超好用的shell</li>\n<li>dash，文档，内容相当丰富，连LaTeX和markdown的文档都有，不过有时候要等7秒钟才让你看文档。</li>\n<li>FileZilla，FTP利器</li>\n<li>github desktop，git的桌面版，很少用，程序员还是多用命令行吧，要不然让你搞Linux服务器，记不起git命令就显得low逼了。</li>\n<li>Pycharm，jetbrains家的IDE个个都好用，这个是用来写Python的</li>\n<li>Intellj IDEA，jetbrains家的IDE个个都好用，这个是用来写Java的</li>\n<li>Android Studio，jetbrains家的IDE个个都好用，这个是用来写Android的</li>\n<li>RubyMine，jetbrains家的IDE个个都好用，这个是用来写ruby的</li>\n<li>CLion，jetbrains家的IDE个个都好用，这个是用来写C、C++的</li>\n<li>jetbrains家的IDE</li>\n</ul>\n<p><img src=\"http://wx2.sinaimg.cn/mw690/006zFO3ggy1fcd4vbx60yj31kw0zkqez.jpg\" alt=\"jetbrains家的IDE\"></p>\n<p>如何顺利的从Windows使用习惯迁移到macbook使用习惯，我写了一篇文章：<a href=\"../2017/01/01/从windows转用macOSX记录\">从 Windows 转用 Mac OS X 记录</a></p>\n<p>另外建议买东西不要贪小便宜，一定要买正版，我的 Macbook 是在淘宝上买的比较便宜的，结果屏幕涂层脱落了，商家也不给赔偿，送苹果 genius bar 查出我的机器不是正版，也不给修。最后换屏（非官方渠道，要1500人民币）</p>\n"},{"title":"我读大学时候的一些思考","date":"2017-02-05T16:00:00.000Z","comments":1,"_content":"\n我上大学之前一直是一个各科都学的很好的学生，文科成绩非常好，而且是个很感性的人，喜欢凭直觉，写一些无病呻吟的小文章，但是我之后毅然决然的选择了理科，并对理科产生了浓厚的兴趣，想去探究事物背后的原理，我高三时候经常问老师一些让老师都犯怵的难题（包括物理的、生物的），后来进大学学了计算机，编程思维对我产生了很大影响，我现在喜欢事事讲逻辑，讲原因，作总结，写东西也希望除了讲究文笔，同时也要言之有物，满满的思考和干货。\n\n下面是我学生时期的一点思考，希望分享给大家，同时我也觉得需要提醒一下，人的成长多半靠经历和阅历，伟人不光是书读得多，他们的人生经历也是波澜壮阔（如果你觉得你的人生经历平平，那么就要警醒自己了），面对不确定的事要保持兴奋感，因为不确定代表着机遇（就像互联网上的超链接），一个人一生只要把握一个大机遇就非常好了，有时间我也要多出去走走，多接触些人和事物，行他个万里路，然而这需要一定的经济基础，不然只能出去要饭。\n\n## 读计算机专业给我带来的思考\n\n### 做事形式化，规范化\n\n做事形式化其实并不是坏事，这个世界的运行体制就是形式化，也必须要形式化的，只有这样才可以高效稳定的运行起来。行有行规家有家法，做人做事都要有原则，与人与物打交道都要有协议有规定，所谓规章制度，并不是拿来消遣人的，出发点是更好的促进沟通交流。一个东西一旦规范起来，那么出漏子的情况就变得相当低了。比如出门前必定要学会检查自己要带哪些东西（都带上），要关掉哪些东西（都关掉，灯，窗，门等等。），这些都要养成习惯。而习惯的形成也正是为了减少大脑多余的思考，跟规章制度可以节约社会资源一样，不用每次都重新设计一遍。所以优秀的习惯是可以让人轻松的保持脑力体力，做好真正需要做的想的事，避免被小事琐事打搅，消耗脑力体力。一个人的习惯决定了一个人。这里引用一句名言：\n\n播种一种思想（态度），收获一种行为；播种一种行为，收获一种习惯；播种一种习惯，收获一种性格；播种一种性格，收获一种人生。\n\n其实习惯和性格是相辅相成的，性格反过来也会影响到习惯，加强习惯。而你的想法，也就是态度，会影响你的行为。所以总的来说态度（想法），行动力和习惯是最重要的三个东西。态度和行动力可以生成习惯，而习惯将决定你的未来，习惯是强大的，习惯就是力量。\n\n### 把事物信息化\n\n要想管理好事物，就要将其信息化。这并不是现代才有的思想，古已有之。譬如政府的户籍制度，一个产品的说明书，都是各成体系，规范（这又说到了第一点：规范化）。其实规范化，也就是信息化。把事物的属性抽象出来列出清单，把操作统一规范好，这样只要懂规则的人只需一点功夫就能把握某件事物，而且丝毫不落下什么。学信息技术，学计算机，给我带来的最大的收获其实就是这个。当我发现这个世界其实无非就是信息的堆叠，这个世界的本质就是信息，而信息所能创造的不仅仅是这个世界，它能创造任意世界，事物。我们生活的这个世界有可能是用计算机模拟出来的，而我们将来也许也有能力模拟出一个复杂的世界，其实某些游戏，譬如minecraft就已经是在模拟我们这个世界了，只是比较简单罢了。现在信息技术越来越发达，各行各业的信息壁垒也越来越高，如果你不懂规则，就无法理解。而信息化思维正是帮助人轻松消化这些规则，打破信息壁垒的。只要你有了信息化思维的习惯，还有大量信息化思维和做事的经验，在这个世界，在各个行业领域都能轻松遨游，游刃有余。譬如写协议，这是件很能锻炼信息化思维的事。写代码，写程序也有此类功效。还有在国家政府机关、法律部门工作也有此类功效。这些事都让你去读懂一个规则，或者创造一个规则，这个过程中各种边角条件（corner cases）情况都要考虑周全，这跟你写出无bug的程序不是异曲同工之妙吗。\n\n这里说一下我个人对能力提升的理解，一个人能力的高低完全取决于他的经验。经验是成功之母，这是我一直以来信奉的观念。失败和成功都只是小插曲罢了，重要的是经验，成功有成功的经验，失败有失败的经验。另外，提一下我对人生的一点理解，人生由什么决定，很多人说由自己决定，也对，也不对，不对的地方是什么呢。人生下来其实就不是由自己决定的，什么样的环境造就什么样的人，当然同样的环境可能产出不同的结果，但不同的结果也是这个环境所造就出来的，这点我们谁也不能否认。所以环境是人生最重要的一个东西，除此之外就是决定，我们这个世界有确定的东西，也有不确定的因素，很明显这里环境所造成的个人决定是不确定的。\n\n微观上有人想用量子的瞬间位置和速度来模拟这个世界，这样就能确定世界的下一个状态，但是量子力学中量子的速度和位置是不能同时确定的，只能确定其一，这个世界宏观上是连续的，微观上是离散的不连续的，连空间都有最小的普朗克常量。宏观上的连续是微观的不连续堆叠起来的，这一点跟计算机不能无限精确的表示一个无限不循环小数有异曲同工之妙，所以我们世界有可能是计算机模拟出来的因为这种相同的不连续性。学过多媒体之后，对于模拟数据和数字数据我有了更深的理解，数字化精确到一定程度可以取代模拟量！用人的感官更加容易实现这个，譬如视网膜屏的分辨率，其实像素点是不连续的，是有穷的，数字的，但在我们眼里是连续的，无穷的，模拟的。再回到世界的非确定性本质，我觉得微观的非确定性也是从本质上导致了宏观的非确定性\n\n## 环境决定一个人\n\n虽然人各有决定，意外时常发生，但是这并不代表环境不重要，相反环境相当重要，因为不定性是有概率指标的，而环境是确定的，你不能过分指望在同样一个环境里产生跟别人不一样的决定（就像理论上你能用量子态穿过一堵墙，但那个概率就实在太低了），特别是从一出生以来，那时候人带的基本是人的自然反应和决定。而现在的你的状态也和这一路走来你的环境有着莫大的关系（基本是一个确定态），什么样的环境造就什么样的人，这并不是一句空话。记得以前看过一个真实故事（不信可以自己去观察）：几个背景不同的年轻人去同样一家公司实习，经理通过观察就能判断他们父母是做什么的。（因为父母对人的影响很大）。你看这里只是 选取了环境的主要因素就已经基本给一个人定型了。而回顾我自己，我也是大为吃惊，自己的性格，自己现在的状态都可以从以前的环境找到原因，就像一种无形的束缚和枷锁。\n\n我现在正在努力根据我以前的家庭环境来核对自己的性格，并努力向不同环境背景的人学习，比如由公务员家庭所继承下来的做事谨慎，妥当的性格。我也努力改善自己的环境，因为在合适的环境中能迅速培养这种环境所产生的性格习惯，而对抗环境去形成相反的性格习惯是特别困难和低效的。有句名言叫：出淤泥而不染。其实这描述的是一种特殊的现象，大部分人是应验了这句：近朱者赤近墨者黑。而我现在深知这其中的道理，我也知道我并不能做到出淤泥而不染，那还是去改变或者选择自己想要的环境吧，那样离自己的梦想更近一些。\n\n人生就像一场游戏，在这场游戏里你不能决定你的出生，而出生其实反而是最重要的，在一个没有女权的地方，女孩子生活的有多不容易，而如果你出生就是奴隶，这又会是怎样的一生。出生在山沟沟里的孩子，很可能永远看不到城里孩子的世界。很多人说视野决定人生的高低，我上面也说了经验是成功之母。其实这些都可以归为一句话来讲，环境决定一个人。我很庆幸在这么年轻的时候就深刻认识到了这个定理。（虽然很多人都知道这一点，但如同知识你学了不一定会用一样，其实是没有用的，你不能在绝大多数该用到这个知识的时候都能想起这个）。但是出生这种环境是不能改变的，我们也不能消极的看待这一点。相反在认识到这一点后我变得更加积极了，我知道哪些是能改变的，哪些是不能改变的。那么就努力去改变我们能改变的。\n\n在这个信息时代，人的视野更加开阔了，以前信息不发达的时候你最大的梦想很可能就是像村里王大爷一样，家里20多亩地，几十头猪牛，但现在我们可以看到更远的，人的现实处境和梦想的沟壑变的更大了，（人的梦想总是跟最大欲望有关，最大欲望又局限于视野之内），这是一件好事，但也是个不幸的事，当我们发现原来还有人活的那么潇洒那么漂亮，而我们可以成为跟他们一样的人，拥有一样漂亮的人生，但却要为此付出无比艰辛的努力，有很多人选择了放弃，选择了自我安慰和自我麻醉，到生命的尽头时才后悔不已。人生而为了梦想。困难，险阻，恐惧这些虽然难克服，但是如果真的一辈子这么龟缩着在自己的角落里真的有意思吗，每当我有困难的时候，每当我恐惧不已，惴惴不安的时候，都应该用这句话激励自己，“如果真的一辈子这么龟缩着在自己的一片小角落里真的有意思吗！！”。\n\n当然不要因此学会去抱怨环境，环境能改变就改变，不能改变就要靠自己努力去改变，人有主观能动性。\n\n### 心理学的一点小分析\n\n所有的过度改变都是痛苦的，这是人的天性。一尘不变和太过简单是无趣的，一点点改变是有趣的，稍强一点的改变是累人的，过度的改变就是痛苦的了。当一个学渣励志要变成学霸，从原来的睡到中午12点到现在的早上6点起床，这是极为痛苦的。当一个学渣要去学一些虽然不是很难，对什么都不会，没有基础的他而言，很难的东西，他是痛苦的。而要克服这两类痛苦（改变的痛苦和复杂的痛苦）主要靠习惯和方法，当你是高三学生的时候，你不会觉得高三很辛苦，（人的忍耐，甚至人的所有情感都是有弹性的，不是个定值），反而觉得自己不够努力。而到了大学再要你像高三那样高强度的学习，你会觉得痛苦不堪。学霸并不觉得自己的生活很苦，他们觉得轻松自在，理所当然。这都是因为习惯了，习惯可以减轻很多负担。当你例行公事的去刷牙洗脸，你一点都不觉的难，人的习惯是人最大的助手。习惯一养成，一切都OK。当这种习惯一尘不变时可以稍作改变，变为有趣，例子：刷牙买新牙膏。习惯的养成刚开始都是痛苦的，巨大的改变所带来的痛苦要挺过去。长痛不如短痛，这是对付改变的痛苦的方法。对付复杂带来的痛苦的方法更简单，把复杂程度降到一点点的时候，痛苦变为有趣。这里我还写了点有关学习方法的建议：学习方法总结。\n\n最后附上我喜欢的一张壁纸，愿每个人都如这个 月夜攀登者 一样执着：\n\n![月夜攀登者](https://upload-images.jianshu.io/upload_images/3690260-23096abf961e2cfb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 曾今的思考笔记\n\n### 人生的动与静：\n\n本来很早就想写这个话题了，这个想法是我在逛长沙市博物馆看画展的时候想到的，现在我连那个画家叫什么名字都忘了，但那一天出去走的时候去了很多地方，包括创客展，长沙市一中，烈士公园，等等。看完老先生的画作后我突然有一种感觉，就是人生不应该只呆在一个老地方过完这一辈子，那样当你回想起来的时候，发现每天都过得差不多，也就了无生趣了，生活应该是动态的有活力的，世界那么大，应该出去看看。人生那么长，应该多经历一些有趣的事。记得以前看过一篇文章，是讲什么叫有趣，什么叫舒适，有趣就是复杂，舒适就是简单，过于复杂让人渴望简单，过于简单，人又觉得无趣。所以生活就是在这两者之间取舍。累了就歇着，无聊了就找些稍复杂、有挑战性的事来做。\n\n我的观点是人生在宏观上来看应该是动态的，在微观上是静态的。人需要不断的用新鲜事物来刺激自己，所谓生活每一天都很新鲜，就是这个道理。但过于奔波劳累，就又让人心生疲惫和厌倦。所以在动的过程中，也要让每一段经历沉下心去，过好那一段。这种感觉是很美好的。\n每次出去走走，头脑都会清新好多，好像突然跳出了原来那个时空，以一种更宽广的视野看待现在的自己，人生的轨迹，想做的事仿佛又清晰了一些。所以要不时的出去走走，或者换一换环境，不要呆在寝室，一天下来只干了一堆琐事。\n\n明白自己真正想要什么，然后动手去做。人生才会精彩。\n\n参差多态乃幸福本源。去经历一些新奇的事，有趣的事。不要每天都一成不变。\n\n### 少收藏，多消化：\n\n这个世界上所有的东西都是有生命周期的（有寿命的），那些好用的工具，美好的东西也是如此。\n今天清理了一下手机，又想起了umano，突然感悟到这世界上所有的东西都是有自己的期限的。以前也想过这个问题，就是要趁着那些美好的事物还在的时候去好好体验一下，见证他们的存在，王小波说希望这一生经历一些有趣的事，懂得一些道理。我觉得很对。但是反过来，既然所有的东西都是有寿命的，那么我现在手机上用的这些应用，这些工具也许有一天也终将没落。有太多的例子了，天涯，猫扑，衰败何其快，这个世界发展的太快了。微信也是才出不久就如日中天了。我应该好好去利用这些工具，但同时又不被他们绑架。\n\n不要在收着藏着了，那不是你自己的东西，也不会成为你自己的东西。我曾今非常喜欢在用chrome浏览网页的时候收藏网页，随着时间的推移我收藏的网页变得越来越多，心理负担也变得越来越重，我不断的想花个时间去给我的书签分个类，我后来确实做到了，为了尽可能的细分管理，分了很多类别。但总有感觉不对劲的地方，最终我放弃了书签，而是改用搜索，最开始的理由是为了锻炼自己的搜索能力（因为我觉得曾今找到过一次的网页，今后也应该有能力找到才对），后来我渐渐明白收藏癖对自己的压力有多大，尤其是你心里总是惦记着自己的收藏夹的时候，不是你的终究不是你的，收藏了不看和没收藏实际上是一样的，但留在那里却给自己造成了无形的压力，注重消化和吸收，并做好记录和总结吧。\n\n### 积极的人生态度：\n\n在这里我要强调，若想人生过得精彩，过得开心，一定要培养一种积极的人生态度。毛泽东就是一个典型的例子，豪气冲天，自信积极，人生无比精彩，会当击水三千里，自信人生二百年。这不是我以前所向往的生活吗，对，生活理当如此，一个人怎么能苟且的活着，那样还有什么意思呢。消极是失意人生之源。想想七龙珠里面的热血，火影，海贼王，莫不是有梦想之人的奋斗史。曾今的少年就真的被打败了吗，就真的甘于被生活和现实打败了吗，那这样下去接下来的人生可还有什么意义可言，无梦想，无热血，无积极的生活态度，可以去死矣。自卑是一种傻逼的生活方式，想想曾今电影王牌大贱谍2中的奥斯汀，人长得丑，矮，那又怎样，看看他的人生多精彩。人生唯爱情和美食不可辜负。爱情和美食你都经历过吗。\n人生只有血凉与热的区别。火苗再小，也要反复点燃。\n\n### 做好规划：\n\n今天晚上7点去参加深圳双选会，看宣传片的时候突然脑子里蹦出一个念头，而且感觉越来越强烈。一个人究竟能走多远？我曾今以为自己能走很远，走到天涯海角， 既去做研究，当教授，又去赚大钱，做老板，所有美好的事全都在我身上。可是现在呢？呵呵，现在的处境离想象实在太远了。现在连找工作都是个问题。我们都知道企业做项目要有规划，一个国家发展要有规划，很多事都要有规划，而且越重要的事规划就越是严密，漏洞很少，并且都一一实现了。人生这么重要的一趟旅程又怎能随波逐流呢？很多人说随心随性，到头来这旅程又真的是你想要的吗？大多数人都是被生活推着走，没有人生规划的人更是如行尸走肉，如随风飘荡的落叶不知去向何方。年轻时的壮志，梦想，或者幻想，最终都一一破灭，成为遥不可及的东西。回头看我的人生轨迹，可以说我自己从来没有规划过，小的时候基本上是父母，社会，学校在规划我的轨迹，现在到了大学，自己有了能力和权力规划自己的人生（其实小的时候就可以规划，可惜没有这种意识，就算是大学的前三年，也不依旧没这意识吗）。想追求什么，可能我现在还不明白自己真的想追求什么，我一无所长，没有热爱。想追求什么也并不是想想就可以实现的，必须对此作出规划，才知道原来人生，原来生命并不是有无限可能，无限可能说出来都是骗人的。当你真的着手去规划，你才发现，要达到目的是要付出多大的努力，耗费多大的时间。而人生区区几十年，又能完成多少你所想的壮志和梦想呢。恐怕不多。这提醒我们，再不规划，再随风飘荡，恐怕连一件想要做的事也完不成，人生留下的将尽是无奈和事与愿违。比如一件小事，复习操作系统，你是直接就开始拿起课本复习，还是有规划的复习。没有规划，你知道自己几时能看完吗？你知道自己能在多长时间内看到多少程度吗？恐怕到最后要花很长时间，但是你当初没想到，恐怕你没有计划地想什么时候看两眼就看两眼，不想看就扔一边，最后只看了一点点就放弃了。这就是随性的最可怕的地方。你根本没有去预计自己会到达什么地方，你的预算能力将变得很弱，你的生活和人生将失去控制不由你主宰。看了人生7年the up series，才知道人生何其短暂，要达成自己梦想的成就根本没多少时间可以用。如果不从现在开始规划，7年后的你是什么样子呢。\n\n规划的关注点不应该是自己的时间，而应该是具体的任务，对于许多长期目标来说，花多少时间去做事不重要，做完你要做的事才重要，做的不好不要紧，坚持去做。\n\n### 注意自己的性格\n\n今天中午2点去华为笔试，做了一个性格测试，这是我第一次认认真真做性格测试，我突然发现自己的性格很有问题，于我对自己的的期望，幻想中的自己区别很大。可以肯定的说，以我目前的性格，恐怕无法实现我的梦想，让自己的能力和地位达到想象中的高度。如果我想要做一个领导，我需要哪些品质，又需要怎样去培养？如果我要让自己更受欢迎，我需要哪些品质，又需要怎样去培养？这些都是很重要的问题，平时如果不注意，对自己的梦想只是想想罢了，那到时候就会发现自己也真的只是想想罢了。有句话很经典，播种一种思想，收获一种行为，播种一种行为，收获一种习惯，播种一种习惯，收获一种性格，播种一种性格，收获一种人生。性格决定一个人的行为，而行为习惯又在巩固性格，或者形成性格。性格决定人的取舍和行为方式的例子屡见不鲜。性格将决定一个人的命运。但这也是个顽固的东西，很难改变，需要坚持。我觉得自己应该多问问自己今天做的这类性格测试中的问题，这些都是一个人的基本性格，世界观和价值取向，一个人灵魂的体现。我发现自己的性格很差，基本像一张白纸，没有自己的主张，有的全是懦弱，老好人，这跟我从小的经历有关。关于性格的培养，今后要有详细的规划才行。\n\n## 你的迷茫值得吗？\n\n我们都想让自己的人生达到最优解，对此我推荐贪心算法（动态规划不可取，因为你无法归因，人生是向前的，你无法回到过去重来），我相信只要人生的每个阶段都最优化，整个人生的解一定不会差（相反，你如果每个阶段都混得很差，怎么指望活出人生的最优）。\n\n这是我学生时期写的一篇关于怎么找准努力方向，走对正确的路，以及高效的学习和进步的一点思考。当时我正为自己的专业学的不好而感到恐慌和自卑，为自己遇到各种不懂的问题而不得解感到烦躁，继而封闭自己，企图逃避。高中到大学的跨越始终太大，有些人四年之中一直是迷茫的，这种深深的不适是教育体制造成的，但是这种改变也是必要的，因为你的人生你要自己负责，带你高三的老师班主任不会为这负责，不要被桎梏久了就忘了外面精彩的世界和人生。\n\n从被动到主动，也许只需要一个观念的转变，也许对于许多人来说却是千折百回、痛苦煎熬。愿你不要再做一个被动的人。\n\n### 学习不难，合适的路径获得难\n\n（有时候是教材没有讲得浅显易懂，有时候是自己没有潜心去看。还有时候是根本没有教材，也就是根本没有人带，苦苦摸索耗费你巨大精力，有种要死的感觉，大学的学习难于高中大概也是这种感觉（在上大学之前所有的知识都是老师一口一口喂的，大学里我所有的专业知识都是自学的，老师无异于一个摆设）。其实这个道理十分广泛，可以改成前进不难，找对路子难。关于学习方法，可以参考我这篇：学习方法总结）\n\n最近一直感慨没有前人带路，走的步履维艰，回头看看自己走过的路。最后悔的莫过于没有参加ACM，没有任何竞赛，也没有奖学金，还有很多原本能做到的东西都没有去做。没有人提醒自己，教自己，不管是技术上的还是生活规划等等。我知道是自己以前都被别人规划好了，小的时候有家人带路，九年义务教育的时候有老师带路，何况我妈还是我小学老师呢，使得我从小备受关注和提携。现在才发现以前的那种生活状态才是不合理的，现在过的是生活的本质的样子，想要回头看的时候不那么后悔一定要得到全局视角，要跳出来看。去主动争取，去联系前辈们， 去获得过来人的箴言和 第三视角的指导，不要把自己框在现时现地 当然不能只听一家之言，要做大数据统计分析，然后应对现在，应对未来。\n\n### 意识很重要\n\n自己终于意识到了，摸着石头过河是愚蠢的，是不必要的，前人早就有了经验，这条路并不是新的。但是生活中又有多少的东西是我还没有意识到的呢？突然有点恐慌。仔细思考一下，发现。其实意识不到是很正常的，你没有处于那个环境之下，没有经历和经验，始终是意识不到的。换句话说，意识不能凭空产生。要么自己经历了，要么别人经历了，然后告诉你，然后你获得了新的思考，恍然大悟，如获新生。 对的，意识不能凭空产生。那么节省时间的方法就是，去跟别人交流吧，去获得别人的经历，经验。去不断增强自己的见识，拓宽自己的视野。意识，思考，思想会源源不断的产生。 把自己闷在自己的思考里，并不能获得多少新的东西。\n\n### 不要想当然，事情可能根本不是这样\n\n高中的时候以为成绩最重要，到了大学也继续这样认为，直到被现实打破，才知道了能力很重要（如果你在985大学，建议还是一定要刷好绩点，因为可以保研，而且还是保到很不错的学校，我自己就认为不注重成绩是我大学里做的最失败的一件事，因为相对考研来讲，平时的考试要拿高分确实简单不少）。可能到了工作中，我们还一直奉行能力很重要这一条，但是现实又会告诉我们关系很重要。可能我们觉得现在可以单身，不谈恋爱，到了工作后一定年纪觉得当时自己真的傻透了。就这样我们一直想当然，自以为是。现实会粉碎你的想当然，让你痛苦万分，后悔不已。可以大胆猜测，但是不要默默地就把它当成真理。 还是前面说的，我们应该去问问经历过的人，做大量数据统计分析。然后才能得出合乎事实的东西。补充：（大学里成绩同样很重要，保研和奖学金都靠成绩，即使考试很水，但判断学生的基本条件是成绩，而且认真的态度在哪都是最重要的，态度决定高度。我相信很多人身边都有这种人，他们就是凭着一股认真的劲儿，大学生活才如此丰富多彩。另外能力确实很重要，在中国并不是有关系就行，工作看的是业绩，那么能力就是重要的。可以说学习是学生的天职，那么成绩就是重要的，读研可能就是研究水平，就是发的paper的多少了，这些都是简单的就可以推理出来的，并不是想当然。而大学谈恋爱确实不怎么好，因为可能根本找不到我喜欢的女孩子也喜欢我的情况，将就自己会更加不快乐。要谈恋爱首先得正确的认识自己，然后看看自己的眼光和自己的水平是否匹配，眼光高水平低那就注孤生啊。）\n\n### 获得局外视角的途径\n\n前面讲的三条都指向同一点：不要闭门造车，要找前辈，获得局外视角。所谓当局者迷，旁观者清。所谓经历过了才懂得。所以接下来我记下怎样去找。\n\n找导师，导师再介绍师兄师姐。\n进论坛，找工作多年的前辈。（因为即将步入工作，可以问问工作中什么最重要，怎样让这个最重要的方面成为自己的强项）\n搜索各种群，进群找工作经验丰富的前辈。\n这里补充一句，现在的话，学计算机专业的同学可以找我啊，我们可以一起进步，共同成长，人类一直都是以共同话题和爱好而相聚在一起的，我相信未来的互联网的社区化会越来越成熟。\n\n## 信息时代的一点思考\n\n这个时代的最大特征就是信息爆炸，人类每天面临着海量的信息，但有多少是有用的呢，这还真不敢恭维，其实有意义的东西就那么多，人类所有的智慧加起来也就那么多，学个大部分完全是可以的。所以面对信息爆炸最好的方法就是不要去接触那些杂七杂八的信息，而是 转过头去学习最本质的人类智慧，看看新闻可以、一些基本的娱乐常识可以了解，但没必要懂那么多，只要算个融入社会的现代人就行了，网上流行的东西更迭那么快，没必要主动去接触，被动的去接受就行了，只要你处在那个环境中，只要一件事很火，你自然而然就从身边的人那里得知了，而且这些都是没有价值的信息，只是为了塑造一种圈内认同感，就是我们都是现代社会互联网八卦这个圈内人。要学习、要搜索，主动去接触有价值的信息，规避泛滥的没有价值的信息。 比如各种广告，软文，比如打开有道词典各种推荐，千万不要点进去啊，比如知乎各种垃圾提问，粗浅的回答，抖机灵的回答，大部分其实也都是些无意义的信息，比如QQ聊天其实都挺没意义的。只要自己往前，不要回头（志同道合的可以稍微聊聊）。什么破公众号其实也没啥意思。这么看来我以前自我提升那么慢，进步那么慢，甚至退步，这些的最根本原因就在于被信息爆炸炸到了，被很多无意义的信息淹没了，感觉每天都很忙，其实都在浪费时间，都在消耗自己，都在做没有价值的事。幸好现在终于幡然醒悟。好好把新概念英语看的滚瓜烂熟，不要看知乎了，想学人生经验，心理学，哲学，经济学，法律，摄影等等，完全应该主动的去学，而不是被动的去每天刷知乎，这种学法完全错误，也就是说知乎是用来搜的，不是用来每天被动接受信息。可以按领域和话题搜索学习，也可以按人来学习，比如大V，肥肥猫，轮子哥，公众号罗辑思维可以听，因为这是聚合信息，王小波全集可以看，这两个都是按人来划分学习的。所以要么按话题领域，要么按人，来进行有效学习。少听点歌，多学点乐理。少看点电视剧，多学点写故事，小说。即有目的地做事，而不是无目的的消遣。即便再好的材料，你囫囵吞枣能尝出什么味道出来，你只是消遣能学到什么，看完了什么收获都没有那跟没看有什么区别呢？不要消遣和漫无目的啊，人必须要成长，提升，否则虚耗光阴，人生也就平淡无奇。信息爆炸带来的后果，就是无意义的信息大大增加，占信息总比越来越大，新出的游戏层出不穷，新出的影视剧层出不穷，新出的小说层出不穷，新出的音乐层出不穷，人们的时间正在越来越多的被这些东西夺取，游戏无非是一些逻辑加循环，循环多一点，故事也无非是一些逻辑加循环，循环少一点，背后的原理才是有意义的信息，而故事和游戏本身并不是那么重要，因为它们本身都是千千万万，根本看不完。现代社会有一个词应用而生：娱乐至死，这其实是信息爆炸带来的结果之一，也是人类生产力提高的后果，越来越多的工作交给了机器和自然能源，人空闲下来就开始找乐子，娱乐的东西现在每天充斥着我们的生活，刺激着我们的神经，而且虚拟的东西制作的越来越好，我们就用虚拟的东西去完成自己的梦想，但虚拟的始终是虚拟的。\n\n伴随着信息爆炸，应该要 更好的信息处理技术，处理海量数据，要更好的交互技术，来帮助人机之间无障碍的沟通，最后完全可以做到记录人们每天的所有信息，所有想法。\n","source":"_posts/2017/2017-02-06-我读大学时候的一些思考.md","raw":"---\ntitle: 我读大学时候的一些思考\ndate: 2017-02-06\ncategories: [随笔]\ncomments: true\n---\n\n我上大学之前一直是一个各科都学的很好的学生，文科成绩非常好，而且是个很感性的人，喜欢凭直觉，写一些无病呻吟的小文章，但是我之后毅然决然的选择了理科，并对理科产生了浓厚的兴趣，想去探究事物背后的原理，我高三时候经常问老师一些让老师都犯怵的难题（包括物理的、生物的），后来进大学学了计算机，编程思维对我产生了很大影响，我现在喜欢事事讲逻辑，讲原因，作总结，写东西也希望除了讲究文笔，同时也要言之有物，满满的思考和干货。\n\n下面是我学生时期的一点思考，希望分享给大家，同时我也觉得需要提醒一下，人的成长多半靠经历和阅历，伟人不光是书读得多，他们的人生经历也是波澜壮阔（如果你觉得你的人生经历平平，那么就要警醒自己了），面对不确定的事要保持兴奋感，因为不确定代表着机遇（就像互联网上的超链接），一个人一生只要把握一个大机遇就非常好了，有时间我也要多出去走走，多接触些人和事物，行他个万里路，然而这需要一定的经济基础，不然只能出去要饭。\n\n## 读计算机专业给我带来的思考\n\n### 做事形式化，规范化\n\n做事形式化其实并不是坏事，这个世界的运行体制就是形式化，也必须要形式化的，只有这样才可以高效稳定的运行起来。行有行规家有家法，做人做事都要有原则，与人与物打交道都要有协议有规定，所谓规章制度，并不是拿来消遣人的，出发点是更好的促进沟通交流。一个东西一旦规范起来，那么出漏子的情况就变得相当低了。比如出门前必定要学会检查自己要带哪些东西（都带上），要关掉哪些东西（都关掉，灯，窗，门等等。），这些都要养成习惯。而习惯的形成也正是为了减少大脑多余的思考，跟规章制度可以节约社会资源一样，不用每次都重新设计一遍。所以优秀的习惯是可以让人轻松的保持脑力体力，做好真正需要做的想的事，避免被小事琐事打搅，消耗脑力体力。一个人的习惯决定了一个人。这里引用一句名言：\n\n播种一种思想（态度），收获一种行为；播种一种行为，收获一种习惯；播种一种习惯，收获一种性格；播种一种性格，收获一种人生。\n\n其实习惯和性格是相辅相成的，性格反过来也会影响到习惯，加强习惯。而你的想法，也就是态度，会影响你的行为。所以总的来说态度（想法），行动力和习惯是最重要的三个东西。态度和行动力可以生成习惯，而习惯将决定你的未来，习惯是强大的，习惯就是力量。\n\n### 把事物信息化\n\n要想管理好事物，就要将其信息化。这并不是现代才有的思想，古已有之。譬如政府的户籍制度，一个产品的说明书，都是各成体系，规范（这又说到了第一点：规范化）。其实规范化，也就是信息化。把事物的属性抽象出来列出清单，把操作统一规范好，这样只要懂规则的人只需一点功夫就能把握某件事物，而且丝毫不落下什么。学信息技术，学计算机，给我带来的最大的收获其实就是这个。当我发现这个世界其实无非就是信息的堆叠，这个世界的本质就是信息，而信息所能创造的不仅仅是这个世界，它能创造任意世界，事物。我们生活的这个世界有可能是用计算机模拟出来的，而我们将来也许也有能力模拟出一个复杂的世界，其实某些游戏，譬如minecraft就已经是在模拟我们这个世界了，只是比较简单罢了。现在信息技术越来越发达，各行各业的信息壁垒也越来越高，如果你不懂规则，就无法理解。而信息化思维正是帮助人轻松消化这些规则，打破信息壁垒的。只要你有了信息化思维的习惯，还有大量信息化思维和做事的经验，在这个世界，在各个行业领域都能轻松遨游，游刃有余。譬如写协议，这是件很能锻炼信息化思维的事。写代码，写程序也有此类功效。还有在国家政府机关、法律部门工作也有此类功效。这些事都让你去读懂一个规则，或者创造一个规则，这个过程中各种边角条件（corner cases）情况都要考虑周全，这跟你写出无bug的程序不是异曲同工之妙吗。\n\n这里说一下我个人对能力提升的理解，一个人能力的高低完全取决于他的经验。经验是成功之母，这是我一直以来信奉的观念。失败和成功都只是小插曲罢了，重要的是经验，成功有成功的经验，失败有失败的经验。另外，提一下我对人生的一点理解，人生由什么决定，很多人说由自己决定，也对，也不对，不对的地方是什么呢。人生下来其实就不是由自己决定的，什么样的环境造就什么样的人，当然同样的环境可能产出不同的结果，但不同的结果也是这个环境所造就出来的，这点我们谁也不能否认。所以环境是人生最重要的一个东西，除此之外就是决定，我们这个世界有确定的东西，也有不确定的因素，很明显这里环境所造成的个人决定是不确定的。\n\n微观上有人想用量子的瞬间位置和速度来模拟这个世界，这样就能确定世界的下一个状态，但是量子力学中量子的速度和位置是不能同时确定的，只能确定其一，这个世界宏观上是连续的，微观上是离散的不连续的，连空间都有最小的普朗克常量。宏观上的连续是微观的不连续堆叠起来的，这一点跟计算机不能无限精确的表示一个无限不循环小数有异曲同工之妙，所以我们世界有可能是计算机模拟出来的因为这种相同的不连续性。学过多媒体之后，对于模拟数据和数字数据我有了更深的理解，数字化精确到一定程度可以取代模拟量！用人的感官更加容易实现这个，譬如视网膜屏的分辨率，其实像素点是不连续的，是有穷的，数字的，但在我们眼里是连续的，无穷的，模拟的。再回到世界的非确定性本质，我觉得微观的非确定性也是从本质上导致了宏观的非确定性\n\n## 环境决定一个人\n\n虽然人各有决定，意外时常发生，但是这并不代表环境不重要，相反环境相当重要，因为不定性是有概率指标的，而环境是确定的，你不能过分指望在同样一个环境里产生跟别人不一样的决定（就像理论上你能用量子态穿过一堵墙，但那个概率就实在太低了），特别是从一出生以来，那时候人带的基本是人的自然反应和决定。而现在的你的状态也和这一路走来你的环境有着莫大的关系（基本是一个确定态），什么样的环境造就什么样的人，这并不是一句空话。记得以前看过一个真实故事（不信可以自己去观察）：几个背景不同的年轻人去同样一家公司实习，经理通过观察就能判断他们父母是做什么的。（因为父母对人的影响很大）。你看这里只是 选取了环境的主要因素就已经基本给一个人定型了。而回顾我自己，我也是大为吃惊，自己的性格，自己现在的状态都可以从以前的环境找到原因，就像一种无形的束缚和枷锁。\n\n我现在正在努力根据我以前的家庭环境来核对自己的性格，并努力向不同环境背景的人学习，比如由公务员家庭所继承下来的做事谨慎，妥当的性格。我也努力改善自己的环境，因为在合适的环境中能迅速培养这种环境所产生的性格习惯，而对抗环境去形成相反的性格习惯是特别困难和低效的。有句名言叫：出淤泥而不染。其实这描述的是一种特殊的现象，大部分人是应验了这句：近朱者赤近墨者黑。而我现在深知这其中的道理，我也知道我并不能做到出淤泥而不染，那还是去改变或者选择自己想要的环境吧，那样离自己的梦想更近一些。\n\n人生就像一场游戏，在这场游戏里你不能决定你的出生，而出生其实反而是最重要的，在一个没有女权的地方，女孩子生活的有多不容易，而如果你出生就是奴隶，这又会是怎样的一生。出生在山沟沟里的孩子，很可能永远看不到城里孩子的世界。很多人说视野决定人生的高低，我上面也说了经验是成功之母。其实这些都可以归为一句话来讲，环境决定一个人。我很庆幸在这么年轻的时候就深刻认识到了这个定理。（虽然很多人都知道这一点，但如同知识你学了不一定会用一样，其实是没有用的，你不能在绝大多数该用到这个知识的时候都能想起这个）。但是出生这种环境是不能改变的，我们也不能消极的看待这一点。相反在认识到这一点后我变得更加积极了，我知道哪些是能改变的，哪些是不能改变的。那么就努力去改变我们能改变的。\n\n在这个信息时代，人的视野更加开阔了，以前信息不发达的时候你最大的梦想很可能就是像村里王大爷一样，家里20多亩地，几十头猪牛，但现在我们可以看到更远的，人的现实处境和梦想的沟壑变的更大了，（人的梦想总是跟最大欲望有关，最大欲望又局限于视野之内），这是一件好事，但也是个不幸的事，当我们发现原来还有人活的那么潇洒那么漂亮，而我们可以成为跟他们一样的人，拥有一样漂亮的人生，但却要为此付出无比艰辛的努力，有很多人选择了放弃，选择了自我安慰和自我麻醉，到生命的尽头时才后悔不已。人生而为了梦想。困难，险阻，恐惧这些虽然难克服，但是如果真的一辈子这么龟缩着在自己的角落里真的有意思吗，每当我有困难的时候，每当我恐惧不已，惴惴不安的时候，都应该用这句话激励自己，“如果真的一辈子这么龟缩着在自己的一片小角落里真的有意思吗！！”。\n\n当然不要因此学会去抱怨环境，环境能改变就改变，不能改变就要靠自己努力去改变，人有主观能动性。\n\n### 心理学的一点小分析\n\n所有的过度改变都是痛苦的，这是人的天性。一尘不变和太过简单是无趣的，一点点改变是有趣的，稍强一点的改变是累人的，过度的改变就是痛苦的了。当一个学渣励志要变成学霸，从原来的睡到中午12点到现在的早上6点起床，这是极为痛苦的。当一个学渣要去学一些虽然不是很难，对什么都不会，没有基础的他而言，很难的东西，他是痛苦的。而要克服这两类痛苦（改变的痛苦和复杂的痛苦）主要靠习惯和方法，当你是高三学生的时候，你不会觉得高三很辛苦，（人的忍耐，甚至人的所有情感都是有弹性的，不是个定值），反而觉得自己不够努力。而到了大学再要你像高三那样高强度的学习，你会觉得痛苦不堪。学霸并不觉得自己的生活很苦，他们觉得轻松自在，理所当然。这都是因为习惯了，习惯可以减轻很多负担。当你例行公事的去刷牙洗脸，你一点都不觉的难，人的习惯是人最大的助手。习惯一养成，一切都OK。当这种习惯一尘不变时可以稍作改变，变为有趣，例子：刷牙买新牙膏。习惯的养成刚开始都是痛苦的，巨大的改变所带来的痛苦要挺过去。长痛不如短痛，这是对付改变的痛苦的方法。对付复杂带来的痛苦的方法更简单，把复杂程度降到一点点的时候，痛苦变为有趣。这里我还写了点有关学习方法的建议：学习方法总结。\n\n最后附上我喜欢的一张壁纸，愿每个人都如这个 月夜攀登者 一样执着：\n\n![月夜攀登者](https://upload-images.jianshu.io/upload_images/3690260-23096abf961e2cfb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 曾今的思考笔记\n\n### 人生的动与静：\n\n本来很早就想写这个话题了，这个想法是我在逛长沙市博物馆看画展的时候想到的，现在我连那个画家叫什么名字都忘了，但那一天出去走的时候去了很多地方，包括创客展，长沙市一中，烈士公园，等等。看完老先生的画作后我突然有一种感觉，就是人生不应该只呆在一个老地方过完这一辈子，那样当你回想起来的时候，发现每天都过得差不多，也就了无生趣了，生活应该是动态的有活力的，世界那么大，应该出去看看。人生那么长，应该多经历一些有趣的事。记得以前看过一篇文章，是讲什么叫有趣，什么叫舒适，有趣就是复杂，舒适就是简单，过于复杂让人渴望简单，过于简单，人又觉得无趣。所以生活就是在这两者之间取舍。累了就歇着，无聊了就找些稍复杂、有挑战性的事来做。\n\n我的观点是人生在宏观上来看应该是动态的，在微观上是静态的。人需要不断的用新鲜事物来刺激自己，所谓生活每一天都很新鲜，就是这个道理。但过于奔波劳累，就又让人心生疲惫和厌倦。所以在动的过程中，也要让每一段经历沉下心去，过好那一段。这种感觉是很美好的。\n每次出去走走，头脑都会清新好多，好像突然跳出了原来那个时空，以一种更宽广的视野看待现在的自己，人生的轨迹，想做的事仿佛又清晰了一些。所以要不时的出去走走，或者换一换环境，不要呆在寝室，一天下来只干了一堆琐事。\n\n明白自己真正想要什么，然后动手去做。人生才会精彩。\n\n参差多态乃幸福本源。去经历一些新奇的事，有趣的事。不要每天都一成不变。\n\n### 少收藏，多消化：\n\n这个世界上所有的东西都是有生命周期的（有寿命的），那些好用的工具，美好的东西也是如此。\n今天清理了一下手机，又想起了umano，突然感悟到这世界上所有的东西都是有自己的期限的。以前也想过这个问题，就是要趁着那些美好的事物还在的时候去好好体验一下，见证他们的存在，王小波说希望这一生经历一些有趣的事，懂得一些道理。我觉得很对。但是反过来，既然所有的东西都是有寿命的，那么我现在手机上用的这些应用，这些工具也许有一天也终将没落。有太多的例子了，天涯，猫扑，衰败何其快，这个世界发展的太快了。微信也是才出不久就如日中天了。我应该好好去利用这些工具，但同时又不被他们绑架。\n\n不要在收着藏着了，那不是你自己的东西，也不会成为你自己的东西。我曾今非常喜欢在用chrome浏览网页的时候收藏网页，随着时间的推移我收藏的网页变得越来越多，心理负担也变得越来越重，我不断的想花个时间去给我的书签分个类，我后来确实做到了，为了尽可能的细分管理，分了很多类别。但总有感觉不对劲的地方，最终我放弃了书签，而是改用搜索，最开始的理由是为了锻炼自己的搜索能力（因为我觉得曾今找到过一次的网页，今后也应该有能力找到才对），后来我渐渐明白收藏癖对自己的压力有多大，尤其是你心里总是惦记着自己的收藏夹的时候，不是你的终究不是你的，收藏了不看和没收藏实际上是一样的，但留在那里却给自己造成了无形的压力，注重消化和吸收，并做好记录和总结吧。\n\n### 积极的人生态度：\n\n在这里我要强调，若想人生过得精彩，过得开心，一定要培养一种积极的人生态度。毛泽东就是一个典型的例子，豪气冲天，自信积极，人生无比精彩，会当击水三千里，自信人生二百年。这不是我以前所向往的生活吗，对，生活理当如此，一个人怎么能苟且的活着，那样还有什么意思呢。消极是失意人生之源。想想七龙珠里面的热血，火影，海贼王，莫不是有梦想之人的奋斗史。曾今的少年就真的被打败了吗，就真的甘于被生活和现实打败了吗，那这样下去接下来的人生可还有什么意义可言，无梦想，无热血，无积极的生活态度，可以去死矣。自卑是一种傻逼的生活方式，想想曾今电影王牌大贱谍2中的奥斯汀，人长得丑，矮，那又怎样，看看他的人生多精彩。人生唯爱情和美食不可辜负。爱情和美食你都经历过吗。\n人生只有血凉与热的区别。火苗再小，也要反复点燃。\n\n### 做好规划：\n\n今天晚上7点去参加深圳双选会，看宣传片的时候突然脑子里蹦出一个念头，而且感觉越来越强烈。一个人究竟能走多远？我曾今以为自己能走很远，走到天涯海角， 既去做研究，当教授，又去赚大钱，做老板，所有美好的事全都在我身上。可是现在呢？呵呵，现在的处境离想象实在太远了。现在连找工作都是个问题。我们都知道企业做项目要有规划，一个国家发展要有规划，很多事都要有规划，而且越重要的事规划就越是严密，漏洞很少，并且都一一实现了。人生这么重要的一趟旅程又怎能随波逐流呢？很多人说随心随性，到头来这旅程又真的是你想要的吗？大多数人都是被生活推着走，没有人生规划的人更是如行尸走肉，如随风飘荡的落叶不知去向何方。年轻时的壮志，梦想，或者幻想，最终都一一破灭，成为遥不可及的东西。回头看我的人生轨迹，可以说我自己从来没有规划过，小的时候基本上是父母，社会，学校在规划我的轨迹，现在到了大学，自己有了能力和权力规划自己的人生（其实小的时候就可以规划，可惜没有这种意识，就算是大学的前三年，也不依旧没这意识吗）。想追求什么，可能我现在还不明白自己真的想追求什么，我一无所长，没有热爱。想追求什么也并不是想想就可以实现的，必须对此作出规划，才知道原来人生，原来生命并不是有无限可能，无限可能说出来都是骗人的。当你真的着手去规划，你才发现，要达到目的是要付出多大的努力，耗费多大的时间。而人生区区几十年，又能完成多少你所想的壮志和梦想呢。恐怕不多。这提醒我们，再不规划，再随风飘荡，恐怕连一件想要做的事也完不成，人生留下的将尽是无奈和事与愿违。比如一件小事，复习操作系统，你是直接就开始拿起课本复习，还是有规划的复习。没有规划，你知道自己几时能看完吗？你知道自己能在多长时间内看到多少程度吗？恐怕到最后要花很长时间，但是你当初没想到，恐怕你没有计划地想什么时候看两眼就看两眼，不想看就扔一边，最后只看了一点点就放弃了。这就是随性的最可怕的地方。你根本没有去预计自己会到达什么地方，你的预算能力将变得很弱，你的生活和人生将失去控制不由你主宰。看了人生7年the up series，才知道人生何其短暂，要达成自己梦想的成就根本没多少时间可以用。如果不从现在开始规划，7年后的你是什么样子呢。\n\n规划的关注点不应该是自己的时间，而应该是具体的任务，对于许多长期目标来说，花多少时间去做事不重要，做完你要做的事才重要，做的不好不要紧，坚持去做。\n\n### 注意自己的性格\n\n今天中午2点去华为笔试，做了一个性格测试，这是我第一次认认真真做性格测试，我突然发现自己的性格很有问题，于我对自己的的期望，幻想中的自己区别很大。可以肯定的说，以我目前的性格，恐怕无法实现我的梦想，让自己的能力和地位达到想象中的高度。如果我想要做一个领导，我需要哪些品质，又需要怎样去培养？如果我要让自己更受欢迎，我需要哪些品质，又需要怎样去培养？这些都是很重要的问题，平时如果不注意，对自己的梦想只是想想罢了，那到时候就会发现自己也真的只是想想罢了。有句话很经典，播种一种思想，收获一种行为，播种一种行为，收获一种习惯，播种一种习惯，收获一种性格，播种一种性格，收获一种人生。性格决定一个人的行为，而行为习惯又在巩固性格，或者形成性格。性格决定人的取舍和行为方式的例子屡见不鲜。性格将决定一个人的命运。但这也是个顽固的东西，很难改变，需要坚持。我觉得自己应该多问问自己今天做的这类性格测试中的问题，这些都是一个人的基本性格，世界观和价值取向，一个人灵魂的体现。我发现自己的性格很差，基本像一张白纸，没有自己的主张，有的全是懦弱，老好人，这跟我从小的经历有关。关于性格的培养，今后要有详细的规划才行。\n\n## 你的迷茫值得吗？\n\n我们都想让自己的人生达到最优解，对此我推荐贪心算法（动态规划不可取，因为你无法归因，人生是向前的，你无法回到过去重来），我相信只要人生的每个阶段都最优化，整个人生的解一定不会差（相反，你如果每个阶段都混得很差，怎么指望活出人生的最优）。\n\n这是我学生时期写的一篇关于怎么找准努力方向，走对正确的路，以及高效的学习和进步的一点思考。当时我正为自己的专业学的不好而感到恐慌和自卑，为自己遇到各种不懂的问题而不得解感到烦躁，继而封闭自己，企图逃避。高中到大学的跨越始终太大，有些人四年之中一直是迷茫的，这种深深的不适是教育体制造成的，但是这种改变也是必要的，因为你的人生你要自己负责，带你高三的老师班主任不会为这负责，不要被桎梏久了就忘了外面精彩的世界和人生。\n\n从被动到主动，也许只需要一个观念的转变，也许对于许多人来说却是千折百回、痛苦煎熬。愿你不要再做一个被动的人。\n\n### 学习不难，合适的路径获得难\n\n（有时候是教材没有讲得浅显易懂，有时候是自己没有潜心去看。还有时候是根本没有教材，也就是根本没有人带，苦苦摸索耗费你巨大精力，有种要死的感觉，大学的学习难于高中大概也是这种感觉（在上大学之前所有的知识都是老师一口一口喂的，大学里我所有的专业知识都是自学的，老师无异于一个摆设）。其实这个道理十分广泛，可以改成前进不难，找对路子难。关于学习方法，可以参考我这篇：学习方法总结）\n\n最近一直感慨没有前人带路，走的步履维艰，回头看看自己走过的路。最后悔的莫过于没有参加ACM，没有任何竞赛，也没有奖学金，还有很多原本能做到的东西都没有去做。没有人提醒自己，教自己，不管是技术上的还是生活规划等等。我知道是自己以前都被别人规划好了，小的时候有家人带路，九年义务教育的时候有老师带路，何况我妈还是我小学老师呢，使得我从小备受关注和提携。现在才发现以前的那种生活状态才是不合理的，现在过的是生活的本质的样子，想要回头看的时候不那么后悔一定要得到全局视角，要跳出来看。去主动争取，去联系前辈们， 去获得过来人的箴言和 第三视角的指导，不要把自己框在现时现地 当然不能只听一家之言，要做大数据统计分析，然后应对现在，应对未来。\n\n### 意识很重要\n\n自己终于意识到了，摸着石头过河是愚蠢的，是不必要的，前人早就有了经验，这条路并不是新的。但是生活中又有多少的东西是我还没有意识到的呢？突然有点恐慌。仔细思考一下，发现。其实意识不到是很正常的，你没有处于那个环境之下，没有经历和经验，始终是意识不到的。换句话说，意识不能凭空产生。要么自己经历了，要么别人经历了，然后告诉你，然后你获得了新的思考，恍然大悟，如获新生。 对的，意识不能凭空产生。那么节省时间的方法就是，去跟别人交流吧，去获得别人的经历，经验。去不断增强自己的见识，拓宽自己的视野。意识，思考，思想会源源不断的产生。 把自己闷在自己的思考里，并不能获得多少新的东西。\n\n### 不要想当然，事情可能根本不是这样\n\n高中的时候以为成绩最重要，到了大学也继续这样认为，直到被现实打破，才知道了能力很重要（如果你在985大学，建议还是一定要刷好绩点，因为可以保研，而且还是保到很不错的学校，我自己就认为不注重成绩是我大学里做的最失败的一件事，因为相对考研来讲，平时的考试要拿高分确实简单不少）。可能到了工作中，我们还一直奉行能力很重要这一条，但是现实又会告诉我们关系很重要。可能我们觉得现在可以单身，不谈恋爱，到了工作后一定年纪觉得当时自己真的傻透了。就这样我们一直想当然，自以为是。现实会粉碎你的想当然，让你痛苦万分，后悔不已。可以大胆猜测，但是不要默默地就把它当成真理。 还是前面说的，我们应该去问问经历过的人，做大量数据统计分析。然后才能得出合乎事实的东西。补充：（大学里成绩同样很重要，保研和奖学金都靠成绩，即使考试很水，但判断学生的基本条件是成绩，而且认真的态度在哪都是最重要的，态度决定高度。我相信很多人身边都有这种人，他们就是凭着一股认真的劲儿，大学生活才如此丰富多彩。另外能力确实很重要，在中国并不是有关系就行，工作看的是业绩，那么能力就是重要的。可以说学习是学生的天职，那么成绩就是重要的，读研可能就是研究水平，就是发的paper的多少了，这些都是简单的就可以推理出来的，并不是想当然。而大学谈恋爱确实不怎么好，因为可能根本找不到我喜欢的女孩子也喜欢我的情况，将就自己会更加不快乐。要谈恋爱首先得正确的认识自己，然后看看自己的眼光和自己的水平是否匹配，眼光高水平低那就注孤生啊。）\n\n### 获得局外视角的途径\n\n前面讲的三条都指向同一点：不要闭门造车，要找前辈，获得局外视角。所谓当局者迷，旁观者清。所谓经历过了才懂得。所以接下来我记下怎样去找。\n\n找导师，导师再介绍师兄师姐。\n进论坛，找工作多年的前辈。（因为即将步入工作，可以问问工作中什么最重要，怎样让这个最重要的方面成为自己的强项）\n搜索各种群，进群找工作经验丰富的前辈。\n这里补充一句，现在的话，学计算机专业的同学可以找我啊，我们可以一起进步，共同成长，人类一直都是以共同话题和爱好而相聚在一起的，我相信未来的互联网的社区化会越来越成熟。\n\n## 信息时代的一点思考\n\n这个时代的最大特征就是信息爆炸，人类每天面临着海量的信息，但有多少是有用的呢，这还真不敢恭维，其实有意义的东西就那么多，人类所有的智慧加起来也就那么多，学个大部分完全是可以的。所以面对信息爆炸最好的方法就是不要去接触那些杂七杂八的信息，而是 转过头去学习最本质的人类智慧，看看新闻可以、一些基本的娱乐常识可以了解，但没必要懂那么多，只要算个融入社会的现代人就行了，网上流行的东西更迭那么快，没必要主动去接触，被动的去接受就行了，只要你处在那个环境中，只要一件事很火，你自然而然就从身边的人那里得知了，而且这些都是没有价值的信息，只是为了塑造一种圈内认同感，就是我们都是现代社会互联网八卦这个圈内人。要学习、要搜索，主动去接触有价值的信息，规避泛滥的没有价值的信息。 比如各种广告，软文，比如打开有道词典各种推荐，千万不要点进去啊，比如知乎各种垃圾提问，粗浅的回答，抖机灵的回答，大部分其实也都是些无意义的信息，比如QQ聊天其实都挺没意义的。只要自己往前，不要回头（志同道合的可以稍微聊聊）。什么破公众号其实也没啥意思。这么看来我以前自我提升那么慢，进步那么慢，甚至退步，这些的最根本原因就在于被信息爆炸炸到了，被很多无意义的信息淹没了，感觉每天都很忙，其实都在浪费时间，都在消耗自己，都在做没有价值的事。幸好现在终于幡然醒悟。好好把新概念英语看的滚瓜烂熟，不要看知乎了，想学人生经验，心理学，哲学，经济学，法律，摄影等等，完全应该主动的去学，而不是被动的去每天刷知乎，这种学法完全错误，也就是说知乎是用来搜的，不是用来每天被动接受信息。可以按领域和话题搜索学习，也可以按人来学习，比如大V，肥肥猫，轮子哥，公众号罗辑思维可以听，因为这是聚合信息，王小波全集可以看，这两个都是按人来划分学习的。所以要么按话题领域，要么按人，来进行有效学习。少听点歌，多学点乐理。少看点电视剧，多学点写故事，小说。即有目的地做事，而不是无目的的消遣。即便再好的材料，你囫囵吞枣能尝出什么味道出来，你只是消遣能学到什么，看完了什么收获都没有那跟没看有什么区别呢？不要消遣和漫无目的啊，人必须要成长，提升，否则虚耗光阴，人生也就平淡无奇。信息爆炸带来的后果，就是无意义的信息大大增加，占信息总比越来越大，新出的游戏层出不穷，新出的影视剧层出不穷，新出的小说层出不穷，新出的音乐层出不穷，人们的时间正在越来越多的被这些东西夺取，游戏无非是一些逻辑加循环，循环多一点，故事也无非是一些逻辑加循环，循环少一点，背后的原理才是有意义的信息，而故事和游戏本身并不是那么重要，因为它们本身都是千千万万，根本看不完。现代社会有一个词应用而生：娱乐至死，这其实是信息爆炸带来的结果之一，也是人类生产力提高的后果，越来越多的工作交给了机器和自然能源，人空闲下来就开始找乐子，娱乐的东西现在每天充斥着我们的生活，刺激着我们的神经，而且虚拟的东西制作的越来越好，我们就用虚拟的东西去完成自己的梦想，但虚拟的始终是虚拟的。\n\n伴随着信息爆炸，应该要 更好的信息处理技术，处理海量数据，要更好的交互技术，来帮助人机之间无障碍的沟通，最后完全可以做到记录人们每天的所有信息，所有想法。\n","slug":"我读大学时候的一些思考","published":1,"updated":"2018-04-25T07:39:45.260Z","layout":"post","photos":[],"link":"","_id":"cjm2w8dcw0014fgpx55zxmnpa","content":"<p>我上大学之前一直是一个各科都学的很好的学生，文科成绩非常好，而且是个很感性的人，喜欢凭直觉，写一些无病呻吟的小文章，但是我之后毅然决然的选择了理科，并对理科产生了浓厚的兴趣，想去探究事物背后的原理，我高三时候经常问老师一些让老师都犯怵的难题（包括物理的、生物的），后来进大学学了计算机，编程思维对我产生了很大影响，我现在喜欢事事讲逻辑，讲原因，作总结，写东西也希望除了讲究文笔，同时也要言之有物，满满的思考和干货。</p>\n<p>下面是我学生时期的一点思考，希望分享给大家，同时我也觉得需要提醒一下，人的成长多半靠经历和阅历，伟人不光是书读得多，他们的人生经历也是波澜壮阔（如果你觉得你的人生经历平平，那么就要警醒自己了），面对不确定的事要保持兴奋感，因为不确定代表着机遇（就像互联网上的超链接），一个人一生只要把握一个大机遇就非常好了，有时间我也要多出去走走，多接触些人和事物，行他个万里路，然而这需要一定的经济基础，不然只能出去要饭。</p>\n<h2 id=\"读计算机专业给我带来的思考\"><a href=\"#读计算机专业给我带来的思考\" class=\"headerlink\" title=\"读计算机专业给我带来的思考\"></a>读计算机专业给我带来的思考</h2><h3 id=\"做事形式化，规范化\"><a href=\"#做事形式化，规范化\" class=\"headerlink\" title=\"做事形式化，规范化\"></a>做事形式化，规范化</h3><p>做事形式化其实并不是坏事，这个世界的运行体制就是形式化，也必须要形式化的，只有这样才可以高效稳定的运行起来。行有行规家有家法，做人做事都要有原则，与人与物打交道都要有协议有规定，所谓规章制度，并不是拿来消遣人的，出发点是更好的促进沟通交流。一个东西一旦规范起来，那么出漏子的情况就变得相当低了。比如出门前必定要学会检查自己要带哪些东西（都带上），要关掉哪些东西（都关掉，灯，窗，门等等。），这些都要养成习惯。而习惯的形成也正是为了减少大脑多余的思考，跟规章制度可以节约社会资源一样，不用每次都重新设计一遍。所以优秀的习惯是可以让人轻松的保持脑力体力，做好真正需要做的想的事，避免被小事琐事打搅，消耗脑力体力。一个人的习惯决定了一个人。这里引用一句名言：</p>\n<p>播种一种思想（态度），收获一种行为；播种一种行为，收获一种习惯；播种一种习惯，收获一种性格；播种一种性格，收获一种人生。</p>\n<p>其实习惯和性格是相辅相成的，性格反过来也会影响到习惯，加强习惯。而你的想法，也就是态度，会影响你的行为。所以总的来说态度（想法），行动力和习惯是最重要的三个东西。态度和行动力可以生成习惯，而习惯将决定你的未来，习惯是强大的，习惯就是力量。</p>\n<h3 id=\"把事物信息化\"><a href=\"#把事物信息化\" class=\"headerlink\" title=\"把事物信息化\"></a>把事物信息化</h3><p>要想管理好事物，就要将其信息化。这并不是现代才有的思想，古已有之。譬如政府的户籍制度，一个产品的说明书，都是各成体系，规范（这又说到了第一点：规范化）。其实规范化，也就是信息化。把事物的属性抽象出来列出清单，把操作统一规范好，这样只要懂规则的人只需一点功夫就能把握某件事物，而且丝毫不落下什么。学信息技术，学计算机，给我带来的最大的收获其实就是这个。当我发现这个世界其实无非就是信息的堆叠，这个世界的本质就是信息，而信息所能创造的不仅仅是这个世界，它能创造任意世界，事物。我们生活的这个世界有可能是用计算机模拟出来的，而我们将来也许也有能力模拟出一个复杂的世界，其实某些游戏，譬如minecraft就已经是在模拟我们这个世界了，只是比较简单罢了。现在信息技术越来越发达，各行各业的信息壁垒也越来越高，如果你不懂规则，就无法理解。而信息化思维正是帮助人轻松消化这些规则，打破信息壁垒的。只要你有了信息化思维的习惯，还有大量信息化思维和做事的经验，在这个世界，在各个行业领域都能轻松遨游，游刃有余。譬如写协议，这是件很能锻炼信息化思维的事。写代码，写程序也有此类功效。还有在国家政府机关、法律部门工作也有此类功效。这些事都让你去读懂一个规则，或者创造一个规则，这个过程中各种边角条件（corner cases）情况都要考虑周全，这跟你写出无bug的程序不是异曲同工之妙吗。</p>\n<p>这里说一下我个人对能力提升的理解，一个人能力的高低完全取决于他的经验。经验是成功之母，这是我一直以来信奉的观念。失败和成功都只是小插曲罢了，重要的是经验，成功有成功的经验，失败有失败的经验。另外，提一下我对人生的一点理解，人生由什么决定，很多人说由自己决定，也对，也不对，不对的地方是什么呢。人生下来其实就不是由自己决定的，什么样的环境造就什么样的人，当然同样的环境可能产出不同的结果，但不同的结果也是这个环境所造就出来的，这点我们谁也不能否认。所以环境是人生最重要的一个东西，除此之外就是决定，我们这个世界有确定的东西，也有不确定的因素，很明显这里环境所造成的个人决定是不确定的。</p>\n<p>微观上有人想用量子的瞬间位置和速度来模拟这个世界，这样就能确定世界的下一个状态，但是量子力学中量子的速度和位置是不能同时确定的，只能确定其一，这个世界宏观上是连续的，微观上是离散的不连续的，连空间都有最小的普朗克常量。宏观上的连续是微观的不连续堆叠起来的，这一点跟计算机不能无限精确的表示一个无限不循环小数有异曲同工之妙，所以我们世界有可能是计算机模拟出来的因为这种相同的不连续性。学过多媒体之后，对于模拟数据和数字数据我有了更深的理解，数字化精确到一定程度可以取代模拟量！用人的感官更加容易实现这个，譬如视网膜屏的分辨率，其实像素点是不连续的，是有穷的，数字的，但在我们眼里是连续的，无穷的，模拟的。再回到世界的非确定性本质，我觉得微观的非确定性也是从本质上导致了宏观的非确定性</p>\n<h2 id=\"环境决定一个人\"><a href=\"#环境决定一个人\" class=\"headerlink\" title=\"环境决定一个人\"></a>环境决定一个人</h2><p>虽然人各有决定，意外时常发生，但是这并不代表环境不重要，相反环境相当重要，因为不定性是有概率指标的，而环境是确定的，你不能过分指望在同样一个环境里产生跟别人不一样的决定（就像理论上你能用量子态穿过一堵墙，但那个概率就实在太低了），特别是从一出生以来，那时候人带的基本是人的自然反应和决定。而现在的你的状态也和这一路走来你的环境有着莫大的关系（基本是一个确定态），什么样的环境造就什么样的人，这并不是一句空话。记得以前看过一个真实故事（不信可以自己去观察）：几个背景不同的年轻人去同样一家公司实习，经理通过观察就能判断他们父母是做什么的。（因为父母对人的影响很大）。你看这里只是 选取了环境的主要因素就已经基本给一个人定型了。而回顾我自己，我也是大为吃惊，自己的性格，自己现在的状态都可以从以前的环境找到原因，就像一种无形的束缚和枷锁。</p>\n<p>我现在正在努力根据我以前的家庭环境来核对自己的性格，并努力向不同环境背景的人学习，比如由公务员家庭所继承下来的做事谨慎，妥当的性格。我也努力改善自己的环境，因为在合适的环境中能迅速培养这种环境所产生的性格习惯，而对抗环境去形成相反的性格习惯是特别困难和低效的。有句名言叫：出淤泥而不染。其实这描述的是一种特殊的现象，大部分人是应验了这句：近朱者赤近墨者黑。而我现在深知这其中的道理，我也知道我并不能做到出淤泥而不染，那还是去改变或者选择自己想要的环境吧，那样离自己的梦想更近一些。</p>\n<p>人生就像一场游戏，在这场游戏里你不能决定你的出生，而出生其实反而是最重要的，在一个没有女权的地方，女孩子生活的有多不容易，而如果你出生就是奴隶，这又会是怎样的一生。出生在山沟沟里的孩子，很可能永远看不到城里孩子的世界。很多人说视野决定人生的高低，我上面也说了经验是成功之母。其实这些都可以归为一句话来讲，环境决定一个人。我很庆幸在这么年轻的时候就深刻认识到了这个定理。（虽然很多人都知道这一点，但如同知识你学了不一定会用一样，其实是没有用的，你不能在绝大多数该用到这个知识的时候都能想起这个）。但是出生这种环境是不能改变的，我们也不能消极的看待这一点。相反在认识到这一点后我变得更加积极了，我知道哪些是能改变的，哪些是不能改变的。那么就努力去改变我们能改变的。</p>\n<p>在这个信息时代，人的视野更加开阔了，以前信息不发达的时候你最大的梦想很可能就是像村里王大爷一样，家里20多亩地，几十头猪牛，但现在我们可以看到更远的，人的现实处境和梦想的沟壑变的更大了，（人的梦想总是跟最大欲望有关，最大欲望又局限于视野之内），这是一件好事，但也是个不幸的事，当我们发现原来还有人活的那么潇洒那么漂亮，而我们可以成为跟他们一样的人，拥有一样漂亮的人生，但却要为此付出无比艰辛的努力，有很多人选择了放弃，选择了自我安慰和自我麻醉，到生命的尽头时才后悔不已。人生而为了梦想。困难，险阻，恐惧这些虽然难克服，但是如果真的一辈子这么龟缩着在自己的角落里真的有意思吗，每当我有困难的时候，每当我恐惧不已，惴惴不安的时候，都应该用这句话激励自己，“如果真的一辈子这么龟缩着在自己的一片小角落里真的有意思吗！！”。</p>\n<p>当然不要因此学会去抱怨环境，环境能改变就改变，不能改变就要靠自己努力去改变，人有主观能动性。</p>\n<h3 id=\"心理学的一点小分析\"><a href=\"#心理学的一点小分析\" class=\"headerlink\" title=\"心理学的一点小分析\"></a>心理学的一点小分析</h3><p>所有的过度改变都是痛苦的，这是人的天性。一尘不变和太过简单是无趣的，一点点改变是有趣的，稍强一点的改变是累人的，过度的改变就是痛苦的了。当一个学渣励志要变成学霸，从原来的睡到中午12点到现在的早上6点起床，这是极为痛苦的。当一个学渣要去学一些虽然不是很难，对什么都不会，没有基础的他而言，很难的东西，他是痛苦的。而要克服这两类痛苦（改变的痛苦和复杂的痛苦）主要靠习惯和方法，当你是高三学生的时候，你不会觉得高三很辛苦，（人的忍耐，甚至人的所有情感都是有弹性的，不是个定值），反而觉得自己不够努力。而到了大学再要你像高三那样高强度的学习，你会觉得痛苦不堪。学霸并不觉得自己的生活很苦，他们觉得轻松自在，理所当然。这都是因为习惯了，习惯可以减轻很多负担。当你例行公事的去刷牙洗脸，你一点都不觉的难，人的习惯是人最大的助手。习惯一养成，一切都OK。当这种习惯一尘不变时可以稍作改变，变为有趣，例子：刷牙买新牙膏。习惯的养成刚开始都是痛苦的，巨大的改变所带来的痛苦要挺过去。长痛不如短痛，这是对付改变的痛苦的方法。对付复杂带来的痛苦的方法更简单，把复杂程度降到一点点的时候，痛苦变为有趣。这里我还写了点有关学习方法的建议：学习方法总结。</p>\n<p>最后附上我喜欢的一张壁纸，愿每个人都如这个 月夜攀登者 一样执着：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/3690260-23096abf961e2cfb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"月夜攀登者\"></p>\n<h2 id=\"曾今的思考笔记\"><a href=\"#曾今的思考笔记\" class=\"headerlink\" title=\"曾今的思考笔记\"></a>曾今的思考笔记</h2><h3 id=\"人生的动与静：\"><a href=\"#人生的动与静：\" class=\"headerlink\" title=\"人生的动与静：\"></a>人生的动与静：</h3><p>本来很早就想写这个话题了，这个想法是我在逛长沙市博物馆看画展的时候想到的，现在我连那个画家叫什么名字都忘了，但那一天出去走的时候去了很多地方，包括创客展，长沙市一中，烈士公园，等等。看完老先生的画作后我突然有一种感觉，就是人生不应该只呆在一个老地方过完这一辈子，那样当你回想起来的时候，发现每天都过得差不多，也就了无生趣了，生活应该是动态的有活力的，世界那么大，应该出去看看。人生那么长，应该多经历一些有趣的事。记得以前看过一篇文章，是讲什么叫有趣，什么叫舒适，有趣就是复杂，舒适就是简单，过于复杂让人渴望简单，过于简单，人又觉得无趣。所以生活就是在这两者之间取舍。累了就歇着，无聊了就找些稍复杂、有挑战性的事来做。</p>\n<p>我的观点是人生在宏观上来看应该是动态的，在微观上是静态的。人需要不断的用新鲜事物来刺激自己，所谓生活每一天都很新鲜，就是这个道理。但过于奔波劳累，就又让人心生疲惫和厌倦。所以在动的过程中，也要让每一段经历沉下心去，过好那一段。这种感觉是很美好的。<br>每次出去走走，头脑都会清新好多，好像突然跳出了原来那个时空，以一种更宽广的视野看待现在的自己，人生的轨迹，想做的事仿佛又清晰了一些。所以要不时的出去走走，或者换一换环境，不要呆在寝室，一天下来只干了一堆琐事。</p>\n<p>明白自己真正想要什么，然后动手去做。人生才会精彩。</p>\n<p>参差多态乃幸福本源。去经历一些新奇的事，有趣的事。不要每天都一成不变。</p>\n<h3 id=\"少收藏，多消化：\"><a href=\"#少收藏，多消化：\" class=\"headerlink\" title=\"少收藏，多消化：\"></a>少收藏，多消化：</h3><p>这个世界上所有的东西都是有生命周期的（有寿命的），那些好用的工具，美好的东西也是如此。<br>今天清理了一下手机，又想起了umano，突然感悟到这世界上所有的东西都是有自己的期限的。以前也想过这个问题，就是要趁着那些美好的事物还在的时候去好好体验一下，见证他们的存在，王小波说希望这一生经历一些有趣的事，懂得一些道理。我觉得很对。但是反过来，既然所有的东西都是有寿命的，那么我现在手机上用的这些应用，这些工具也许有一天也终将没落。有太多的例子了，天涯，猫扑，衰败何其快，这个世界发展的太快了。微信也是才出不久就如日中天了。我应该好好去利用这些工具，但同时又不被他们绑架。</p>\n<p>不要在收着藏着了，那不是你自己的东西，也不会成为你自己的东西。我曾今非常喜欢在用chrome浏览网页的时候收藏网页，随着时间的推移我收藏的网页变得越来越多，心理负担也变得越来越重，我不断的想花个时间去给我的书签分个类，我后来确实做到了，为了尽可能的细分管理，分了很多类别。但总有感觉不对劲的地方，最终我放弃了书签，而是改用搜索，最开始的理由是为了锻炼自己的搜索能力（因为我觉得曾今找到过一次的网页，今后也应该有能力找到才对），后来我渐渐明白收藏癖对自己的压力有多大，尤其是你心里总是惦记着自己的收藏夹的时候，不是你的终究不是你的，收藏了不看和没收藏实际上是一样的，但留在那里却给自己造成了无形的压力，注重消化和吸收，并做好记录和总结吧。</p>\n<h3 id=\"积极的人生态度：\"><a href=\"#积极的人生态度：\" class=\"headerlink\" title=\"积极的人生态度：\"></a>积极的人生态度：</h3><p>在这里我要强调，若想人生过得精彩，过得开心，一定要培养一种积极的人生态度。毛泽东就是一个典型的例子，豪气冲天，自信积极，人生无比精彩，会当击水三千里，自信人生二百年。这不是我以前所向往的生活吗，对，生活理当如此，一个人怎么能苟且的活着，那样还有什么意思呢。消极是失意人生之源。想想七龙珠里面的热血，火影，海贼王，莫不是有梦想之人的奋斗史。曾今的少年就真的被打败了吗，就真的甘于被生活和现实打败了吗，那这样下去接下来的人生可还有什么意义可言，无梦想，无热血，无积极的生活态度，可以去死矣。自卑是一种傻逼的生活方式，想想曾今电影王牌大贱谍2中的奥斯汀，人长得丑，矮，那又怎样，看看他的人生多精彩。人生唯爱情和美食不可辜负。爱情和美食你都经历过吗。<br>人生只有血凉与热的区别。火苗再小，也要反复点燃。</p>\n<h3 id=\"做好规划：\"><a href=\"#做好规划：\" class=\"headerlink\" title=\"做好规划：\"></a>做好规划：</h3><p>今天晚上7点去参加深圳双选会，看宣传片的时候突然脑子里蹦出一个念头，而且感觉越来越强烈。一个人究竟能走多远？我曾今以为自己能走很远，走到天涯海角， 既去做研究，当教授，又去赚大钱，做老板，所有美好的事全都在我身上。可是现在呢？呵呵，现在的处境离想象实在太远了。现在连找工作都是个问题。我们都知道企业做项目要有规划，一个国家发展要有规划，很多事都要有规划，而且越重要的事规划就越是严密，漏洞很少，并且都一一实现了。人生这么重要的一趟旅程又怎能随波逐流呢？很多人说随心随性，到头来这旅程又真的是你想要的吗？大多数人都是被生活推着走，没有人生规划的人更是如行尸走肉，如随风飘荡的落叶不知去向何方。年轻时的壮志，梦想，或者幻想，最终都一一破灭，成为遥不可及的东西。回头看我的人生轨迹，可以说我自己从来没有规划过，小的时候基本上是父母，社会，学校在规划我的轨迹，现在到了大学，自己有了能力和权力规划自己的人生（其实小的时候就可以规划，可惜没有这种意识，就算是大学的前三年，也不依旧没这意识吗）。想追求什么，可能我现在还不明白自己真的想追求什么，我一无所长，没有热爱。想追求什么也并不是想想就可以实现的，必须对此作出规划，才知道原来人生，原来生命并不是有无限可能，无限可能说出来都是骗人的。当你真的着手去规划，你才发现，要达到目的是要付出多大的努力，耗费多大的时间。而人生区区几十年，又能完成多少你所想的壮志和梦想呢。恐怕不多。这提醒我们，再不规划，再随风飘荡，恐怕连一件想要做的事也完不成，人生留下的将尽是无奈和事与愿违。比如一件小事，复习操作系统，你是直接就开始拿起课本复习，还是有规划的复习。没有规划，你知道自己几时能看完吗？你知道自己能在多长时间内看到多少程度吗？恐怕到最后要花很长时间，但是你当初没想到，恐怕你没有计划地想什么时候看两眼就看两眼，不想看就扔一边，最后只看了一点点就放弃了。这就是随性的最可怕的地方。你根本没有去预计自己会到达什么地方，你的预算能力将变得很弱，你的生活和人生将失去控制不由你主宰。看了人生7年the up series，才知道人生何其短暂，要达成自己梦想的成就根本没多少时间可以用。如果不从现在开始规划，7年后的你是什么样子呢。</p>\n<p>规划的关注点不应该是自己的时间，而应该是具体的任务，对于许多长期目标来说，花多少时间去做事不重要，做完你要做的事才重要，做的不好不要紧，坚持去做。</p>\n<h3 id=\"注意自己的性格\"><a href=\"#注意自己的性格\" class=\"headerlink\" title=\"注意自己的性格\"></a>注意自己的性格</h3><p>今天中午2点去华为笔试，做了一个性格测试，这是我第一次认认真真做性格测试，我突然发现自己的性格很有问题，于我对自己的的期望，幻想中的自己区别很大。可以肯定的说，以我目前的性格，恐怕无法实现我的梦想，让自己的能力和地位达到想象中的高度。如果我想要做一个领导，我需要哪些品质，又需要怎样去培养？如果我要让自己更受欢迎，我需要哪些品质，又需要怎样去培养？这些都是很重要的问题，平时如果不注意，对自己的梦想只是想想罢了，那到时候就会发现自己也真的只是想想罢了。有句话很经典，播种一种思想，收获一种行为，播种一种行为，收获一种习惯，播种一种习惯，收获一种性格，播种一种性格，收获一种人生。性格决定一个人的行为，而行为习惯又在巩固性格，或者形成性格。性格决定人的取舍和行为方式的例子屡见不鲜。性格将决定一个人的命运。但这也是个顽固的东西，很难改变，需要坚持。我觉得自己应该多问问自己今天做的这类性格测试中的问题，这些都是一个人的基本性格，世界观和价值取向，一个人灵魂的体现。我发现自己的性格很差，基本像一张白纸，没有自己的主张，有的全是懦弱，老好人，这跟我从小的经历有关。关于性格的培养，今后要有详细的规划才行。</p>\n<h2 id=\"你的迷茫值得吗？\"><a href=\"#你的迷茫值得吗？\" class=\"headerlink\" title=\"你的迷茫值得吗？\"></a>你的迷茫值得吗？</h2><p>我们都想让自己的人生达到最优解，对此我推荐贪心算法（动态规划不可取，因为你无法归因，人生是向前的，你无法回到过去重来），我相信只要人生的每个阶段都最优化，整个人生的解一定不会差（相反，你如果每个阶段都混得很差，怎么指望活出人生的最优）。</p>\n<p>这是我学生时期写的一篇关于怎么找准努力方向，走对正确的路，以及高效的学习和进步的一点思考。当时我正为自己的专业学的不好而感到恐慌和自卑，为自己遇到各种不懂的问题而不得解感到烦躁，继而封闭自己，企图逃避。高中到大学的跨越始终太大，有些人四年之中一直是迷茫的，这种深深的不适是教育体制造成的，但是这种改变也是必要的，因为你的人生你要自己负责，带你高三的老师班主任不会为这负责，不要被桎梏久了就忘了外面精彩的世界和人生。</p>\n<p>从被动到主动，也许只需要一个观念的转变，也许对于许多人来说却是千折百回、痛苦煎熬。愿你不要再做一个被动的人。</p>\n<h3 id=\"学习不难，合适的路径获得难\"><a href=\"#学习不难，合适的路径获得难\" class=\"headerlink\" title=\"学习不难，合适的路径获得难\"></a>学习不难，合适的路径获得难</h3><p>（有时候是教材没有讲得浅显易懂，有时候是自己没有潜心去看。还有时候是根本没有教材，也就是根本没有人带，苦苦摸索耗费你巨大精力，有种要死的感觉，大学的学习难于高中大概也是这种感觉（在上大学之前所有的知识都是老师一口一口喂的，大学里我所有的专业知识都是自学的，老师无异于一个摆设）。其实这个道理十分广泛，可以改成前进不难，找对路子难。关于学习方法，可以参考我这篇：学习方法总结）</p>\n<p>最近一直感慨没有前人带路，走的步履维艰，回头看看自己走过的路。最后悔的莫过于没有参加ACM，没有任何竞赛，也没有奖学金，还有很多原本能做到的东西都没有去做。没有人提醒自己，教自己，不管是技术上的还是生活规划等等。我知道是自己以前都被别人规划好了，小的时候有家人带路，九年义务教育的时候有老师带路，何况我妈还是我小学老师呢，使得我从小备受关注和提携。现在才发现以前的那种生活状态才是不合理的，现在过的是生活的本质的样子，想要回头看的时候不那么后悔一定要得到全局视角，要跳出来看。去主动争取，去联系前辈们， 去获得过来人的箴言和 第三视角的指导，不要把自己框在现时现地 当然不能只听一家之言，要做大数据统计分析，然后应对现在，应对未来。</p>\n<h3 id=\"意识很重要\"><a href=\"#意识很重要\" class=\"headerlink\" title=\"意识很重要\"></a>意识很重要</h3><p>自己终于意识到了，摸着石头过河是愚蠢的，是不必要的，前人早就有了经验，这条路并不是新的。但是生活中又有多少的东西是我还没有意识到的呢？突然有点恐慌。仔细思考一下，发现。其实意识不到是很正常的，你没有处于那个环境之下，没有经历和经验，始终是意识不到的。换句话说，意识不能凭空产生。要么自己经历了，要么别人经历了，然后告诉你，然后你获得了新的思考，恍然大悟，如获新生。 对的，意识不能凭空产生。那么节省时间的方法就是，去跟别人交流吧，去获得别人的经历，经验。去不断增强自己的见识，拓宽自己的视野。意识，思考，思想会源源不断的产生。 把自己闷在自己的思考里，并不能获得多少新的东西。</p>\n<h3 id=\"不要想当然，事情可能根本不是这样\"><a href=\"#不要想当然，事情可能根本不是这样\" class=\"headerlink\" title=\"不要想当然，事情可能根本不是这样\"></a>不要想当然，事情可能根本不是这样</h3><p>高中的时候以为成绩最重要，到了大学也继续这样认为，直到被现实打破，才知道了能力很重要（如果你在985大学，建议还是一定要刷好绩点，因为可以保研，而且还是保到很不错的学校，我自己就认为不注重成绩是我大学里做的最失败的一件事，因为相对考研来讲，平时的考试要拿高分确实简单不少）。可能到了工作中，我们还一直奉行能力很重要这一条，但是现实又会告诉我们关系很重要。可能我们觉得现在可以单身，不谈恋爱，到了工作后一定年纪觉得当时自己真的傻透了。就这样我们一直想当然，自以为是。现实会粉碎你的想当然，让你痛苦万分，后悔不已。可以大胆猜测，但是不要默默地就把它当成真理。 还是前面说的，我们应该去问问经历过的人，做大量数据统计分析。然后才能得出合乎事实的东西。补充：（大学里成绩同样很重要，保研和奖学金都靠成绩，即使考试很水，但判断学生的基本条件是成绩，而且认真的态度在哪都是最重要的，态度决定高度。我相信很多人身边都有这种人，他们就是凭着一股认真的劲儿，大学生活才如此丰富多彩。另外能力确实很重要，在中国并不是有关系就行，工作看的是业绩，那么能力就是重要的。可以说学习是学生的天职，那么成绩就是重要的，读研可能就是研究水平，就是发的paper的多少了，这些都是简单的就可以推理出来的，并不是想当然。而大学谈恋爱确实不怎么好，因为可能根本找不到我喜欢的女孩子也喜欢我的情况，将就自己会更加不快乐。要谈恋爱首先得正确的认识自己，然后看看自己的眼光和自己的水平是否匹配，眼光高水平低那就注孤生啊。）</p>\n<h3 id=\"获得局外视角的途径\"><a href=\"#获得局外视角的途径\" class=\"headerlink\" title=\"获得局外视角的途径\"></a>获得局外视角的途径</h3><p>前面讲的三条都指向同一点：不要闭门造车，要找前辈，获得局外视角。所谓当局者迷，旁观者清。所谓经历过了才懂得。所以接下来我记下怎样去找。</p>\n<p>找导师，导师再介绍师兄师姐。<br>进论坛，找工作多年的前辈。（因为即将步入工作，可以问问工作中什么最重要，怎样让这个最重要的方面成为自己的强项）<br>搜索各种群，进群找工作经验丰富的前辈。<br>这里补充一句，现在的话，学计算机专业的同学可以找我啊，我们可以一起进步，共同成长，人类一直都是以共同话题和爱好而相聚在一起的，我相信未来的互联网的社区化会越来越成熟。</p>\n<h2 id=\"信息时代的一点思考\"><a href=\"#信息时代的一点思考\" class=\"headerlink\" title=\"信息时代的一点思考\"></a>信息时代的一点思考</h2><p>这个时代的最大特征就是信息爆炸，人类每天面临着海量的信息，但有多少是有用的呢，这还真不敢恭维，其实有意义的东西就那么多，人类所有的智慧加起来也就那么多，学个大部分完全是可以的。所以面对信息爆炸最好的方法就是不要去接触那些杂七杂八的信息，而是 转过头去学习最本质的人类智慧，看看新闻可以、一些基本的娱乐常识可以了解，但没必要懂那么多，只要算个融入社会的现代人就行了，网上流行的东西更迭那么快，没必要主动去接触，被动的去接受就行了，只要你处在那个环境中，只要一件事很火，你自然而然就从身边的人那里得知了，而且这些都是没有价值的信息，只是为了塑造一种圈内认同感，就是我们都是现代社会互联网八卦这个圈内人。要学习、要搜索，主动去接触有价值的信息，规避泛滥的没有价值的信息。 比如各种广告，软文，比如打开有道词典各种推荐，千万不要点进去啊，比如知乎各种垃圾提问，粗浅的回答，抖机灵的回答，大部分其实也都是些无意义的信息，比如QQ聊天其实都挺没意义的。只要自己往前，不要回头（志同道合的可以稍微聊聊）。什么破公众号其实也没啥意思。这么看来我以前自我提升那么慢，进步那么慢，甚至退步，这些的最根本原因就在于被信息爆炸炸到了，被很多无意义的信息淹没了，感觉每天都很忙，其实都在浪费时间，都在消耗自己，都在做没有价值的事。幸好现在终于幡然醒悟。好好把新概念英语看的滚瓜烂熟，不要看知乎了，想学人生经验，心理学，哲学，经济学，法律，摄影等等，完全应该主动的去学，而不是被动的去每天刷知乎，这种学法完全错误，也就是说知乎是用来搜的，不是用来每天被动接受信息。可以按领域和话题搜索学习，也可以按人来学习，比如大V，肥肥猫，轮子哥，公众号罗辑思维可以听，因为这是聚合信息，王小波全集可以看，这两个都是按人来划分学习的。所以要么按话题领域，要么按人，来进行有效学习。少听点歌，多学点乐理。少看点电视剧，多学点写故事，小说。即有目的地做事，而不是无目的的消遣。即便再好的材料，你囫囵吞枣能尝出什么味道出来，你只是消遣能学到什么，看完了什么收获都没有那跟没看有什么区别呢？不要消遣和漫无目的啊，人必须要成长，提升，否则虚耗光阴，人生也就平淡无奇。信息爆炸带来的后果，就是无意义的信息大大增加，占信息总比越来越大，新出的游戏层出不穷，新出的影视剧层出不穷，新出的小说层出不穷，新出的音乐层出不穷，人们的时间正在越来越多的被这些东西夺取，游戏无非是一些逻辑加循环，循环多一点，故事也无非是一些逻辑加循环，循环少一点，背后的原理才是有意义的信息，而故事和游戏本身并不是那么重要，因为它们本身都是千千万万，根本看不完。现代社会有一个词应用而生：娱乐至死，这其实是信息爆炸带来的结果之一，也是人类生产力提高的后果，越来越多的工作交给了机器和自然能源，人空闲下来就开始找乐子，娱乐的东西现在每天充斥着我们的生活，刺激着我们的神经，而且虚拟的东西制作的越来越好，我们就用虚拟的东西去完成自己的梦想，但虚拟的始终是虚拟的。</p>\n<p>伴随着信息爆炸，应该要 更好的信息处理技术，处理海量数据，要更好的交互技术，来帮助人机之间无障碍的沟通，最后完全可以做到记录人们每天的所有信息，所有想法。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>我上大学之前一直是一个各科都学的很好的学生，文科成绩非常好，而且是个很感性的人，喜欢凭直觉，写一些无病呻吟的小文章，但是我之后毅然决然的选择了理科，并对理科产生了浓厚的兴趣，想去探究事物背后的原理，我高三时候经常问老师一些让老师都犯怵的难题（包括物理的、生物的），后来进大学学了计算机，编程思维对我产生了很大影响，我现在喜欢事事讲逻辑，讲原因，作总结，写东西也希望除了讲究文笔，同时也要言之有物，满满的思考和干货。</p>\n<p>下面是我学生时期的一点思考，希望分享给大家，同时我也觉得需要提醒一下，人的成长多半靠经历和阅历，伟人不光是书读得多，他们的人生经历也是波澜壮阔（如果你觉得你的人生经历平平，那么就要警醒自己了），面对不确定的事要保持兴奋感，因为不确定代表着机遇（就像互联网上的超链接），一个人一生只要把握一个大机遇就非常好了，有时间我也要多出去走走，多接触些人和事物，行他个万里路，然而这需要一定的经济基础，不然只能出去要饭。</p>\n<h2 id=\"读计算机专业给我带来的思考\"><a href=\"#读计算机专业给我带来的思考\" class=\"headerlink\" title=\"读计算机专业给我带来的思考\"></a>读计算机专业给我带来的思考</h2><h3 id=\"做事形式化，规范化\"><a href=\"#做事形式化，规范化\" class=\"headerlink\" title=\"做事形式化，规范化\"></a>做事形式化，规范化</h3><p>做事形式化其实并不是坏事，这个世界的运行体制就是形式化，也必须要形式化的，只有这样才可以高效稳定的运行起来。行有行规家有家法，做人做事都要有原则，与人与物打交道都要有协议有规定，所谓规章制度，并不是拿来消遣人的，出发点是更好的促进沟通交流。一个东西一旦规范起来，那么出漏子的情况就变得相当低了。比如出门前必定要学会检查自己要带哪些东西（都带上），要关掉哪些东西（都关掉，灯，窗，门等等。），这些都要养成习惯。而习惯的形成也正是为了减少大脑多余的思考，跟规章制度可以节约社会资源一样，不用每次都重新设计一遍。所以优秀的习惯是可以让人轻松的保持脑力体力，做好真正需要做的想的事，避免被小事琐事打搅，消耗脑力体力。一个人的习惯决定了一个人。这里引用一句名言：</p>\n<p>播种一种思想（态度），收获一种行为；播种一种行为，收获一种习惯；播种一种习惯，收获一种性格；播种一种性格，收获一种人生。</p>\n<p>其实习惯和性格是相辅相成的，性格反过来也会影响到习惯，加强习惯。而你的想法，也就是态度，会影响你的行为。所以总的来说态度（想法），行动力和习惯是最重要的三个东西。态度和行动力可以生成习惯，而习惯将决定你的未来，习惯是强大的，习惯就是力量。</p>\n<h3 id=\"把事物信息化\"><a href=\"#把事物信息化\" class=\"headerlink\" title=\"把事物信息化\"></a>把事物信息化</h3><p>要想管理好事物，就要将其信息化。这并不是现代才有的思想，古已有之。譬如政府的户籍制度，一个产品的说明书，都是各成体系，规范（这又说到了第一点：规范化）。其实规范化，也就是信息化。把事物的属性抽象出来列出清单，把操作统一规范好，这样只要懂规则的人只需一点功夫就能把握某件事物，而且丝毫不落下什么。学信息技术，学计算机，给我带来的最大的收获其实就是这个。当我发现这个世界其实无非就是信息的堆叠，这个世界的本质就是信息，而信息所能创造的不仅仅是这个世界，它能创造任意世界，事物。我们生活的这个世界有可能是用计算机模拟出来的，而我们将来也许也有能力模拟出一个复杂的世界，其实某些游戏，譬如minecraft就已经是在模拟我们这个世界了，只是比较简单罢了。现在信息技术越来越发达，各行各业的信息壁垒也越来越高，如果你不懂规则，就无法理解。而信息化思维正是帮助人轻松消化这些规则，打破信息壁垒的。只要你有了信息化思维的习惯，还有大量信息化思维和做事的经验，在这个世界，在各个行业领域都能轻松遨游，游刃有余。譬如写协议，这是件很能锻炼信息化思维的事。写代码，写程序也有此类功效。还有在国家政府机关、法律部门工作也有此类功效。这些事都让你去读懂一个规则，或者创造一个规则，这个过程中各种边角条件（corner cases）情况都要考虑周全，这跟你写出无bug的程序不是异曲同工之妙吗。</p>\n<p>这里说一下我个人对能力提升的理解，一个人能力的高低完全取决于他的经验。经验是成功之母，这是我一直以来信奉的观念。失败和成功都只是小插曲罢了，重要的是经验，成功有成功的经验，失败有失败的经验。另外，提一下我对人生的一点理解，人生由什么决定，很多人说由自己决定，也对，也不对，不对的地方是什么呢。人生下来其实就不是由自己决定的，什么样的环境造就什么样的人，当然同样的环境可能产出不同的结果，但不同的结果也是这个环境所造就出来的，这点我们谁也不能否认。所以环境是人生最重要的一个东西，除此之外就是决定，我们这个世界有确定的东西，也有不确定的因素，很明显这里环境所造成的个人决定是不确定的。</p>\n<p>微观上有人想用量子的瞬间位置和速度来模拟这个世界，这样就能确定世界的下一个状态，但是量子力学中量子的速度和位置是不能同时确定的，只能确定其一，这个世界宏观上是连续的，微观上是离散的不连续的，连空间都有最小的普朗克常量。宏观上的连续是微观的不连续堆叠起来的，这一点跟计算机不能无限精确的表示一个无限不循环小数有异曲同工之妙，所以我们世界有可能是计算机模拟出来的因为这种相同的不连续性。学过多媒体之后，对于模拟数据和数字数据我有了更深的理解，数字化精确到一定程度可以取代模拟量！用人的感官更加容易实现这个，譬如视网膜屏的分辨率，其实像素点是不连续的，是有穷的，数字的，但在我们眼里是连续的，无穷的，模拟的。再回到世界的非确定性本质，我觉得微观的非确定性也是从本质上导致了宏观的非确定性</p>\n<h2 id=\"环境决定一个人\"><a href=\"#环境决定一个人\" class=\"headerlink\" title=\"环境决定一个人\"></a>环境决定一个人</h2><p>虽然人各有决定，意外时常发生，但是这并不代表环境不重要，相反环境相当重要，因为不定性是有概率指标的，而环境是确定的，你不能过分指望在同样一个环境里产生跟别人不一样的决定（就像理论上你能用量子态穿过一堵墙，但那个概率就实在太低了），特别是从一出生以来，那时候人带的基本是人的自然反应和决定。而现在的你的状态也和这一路走来你的环境有着莫大的关系（基本是一个确定态），什么样的环境造就什么样的人，这并不是一句空话。记得以前看过一个真实故事（不信可以自己去观察）：几个背景不同的年轻人去同样一家公司实习，经理通过观察就能判断他们父母是做什么的。（因为父母对人的影响很大）。你看这里只是 选取了环境的主要因素就已经基本给一个人定型了。而回顾我自己，我也是大为吃惊，自己的性格，自己现在的状态都可以从以前的环境找到原因，就像一种无形的束缚和枷锁。</p>\n<p>我现在正在努力根据我以前的家庭环境来核对自己的性格，并努力向不同环境背景的人学习，比如由公务员家庭所继承下来的做事谨慎，妥当的性格。我也努力改善自己的环境，因为在合适的环境中能迅速培养这种环境所产生的性格习惯，而对抗环境去形成相反的性格习惯是特别困难和低效的。有句名言叫：出淤泥而不染。其实这描述的是一种特殊的现象，大部分人是应验了这句：近朱者赤近墨者黑。而我现在深知这其中的道理，我也知道我并不能做到出淤泥而不染，那还是去改变或者选择自己想要的环境吧，那样离自己的梦想更近一些。</p>\n<p>人生就像一场游戏，在这场游戏里你不能决定你的出生，而出生其实反而是最重要的，在一个没有女权的地方，女孩子生活的有多不容易，而如果你出生就是奴隶，这又会是怎样的一生。出生在山沟沟里的孩子，很可能永远看不到城里孩子的世界。很多人说视野决定人生的高低，我上面也说了经验是成功之母。其实这些都可以归为一句话来讲，环境决定一个人。我很庆幸在这么年轻的时候就深刻认识到了这个定理。（虽然很多人都知道这一点，但如同知识你学了不一定会用一样，其实是没有用的，你不能在绝大多数该用到这个知识的时候都能想起这个）。但是出生这种环境是不能改变的，我们也不能消极的看待这一点。相反在认识到这一点后我变得更加积极了，我知道哪些是能改变的，哪些是不能改变的。那么就努力去改变我们能改变的。</p>\n<p>在这个信息时代，人的视野更加开阔了，以前信息不发达的时候你最大的梦想很可能就是像村里王大爷一样，家里20多亩地，几十头猪牛，但现在我们可以看到更远的，人的现实处境和梦想的沟壑变的更大了，（人的梦想总是跟最大欲望有关，最大欲望又局限于视野之内），这是一件好事，但也是个不幸的事，当我们发现原来还有人活的那么潇洒那么漂亮，而我们可以成为跟他们一样的人，拥有一样漂亮的人生，但却要为此付出无比艰辛的努力，有很多人选择了放弃，选择了自我安慰和自我麻醉，到生命的尽头时才后悔不已。人生而为了梦想。困难，险阻，恐惧这些虽然难克服，但是如果真的一辈子这么龟缩着在自己的角落里真的有意思吗，每当我有困难的时候，每当我恐惧不已，惴惴不安的时候，都应该用这句话激励自己，“如果真的一辈子这么龟缩着在自己的一片小角落里真的有意思吗！！”。</p>\n<p>当然不要因此学会去抱怨环境，环境能改变就改变，不能改变就要靠自己努力去改变，人有主观能动性。</p>\n<h3 id=\"心理学的一点小分析\"><a href=\"#心理学的一点小分析\" class=\"headerlink\" title=\"心理学的一点小分析\"></a>心理学的一点小分析</h3><p>所有的过度改变都是痛苦的，这是人的天性。一尘不变和太过简单是无趣的，一点点改变是有趣的，稍强一点的改变是累人的，过度的改变就是痛苦的了。当一个学渣励志要变成学霸，从原来的睡到中午12点到现在的早上6点起床，这是极为痛苦的。当一个学渣要去学一些虽然不是很难，对什么都不会，没有基础的他而言，很难的东西，他是痛苦的。而要克服这两类痛苦（改变的痛苦和复杂的痛苦）主要靠习惯和方法，当你是高三学生的时候，你不会觉得高三很辛苦，（人的忍耐，甚至人的所有情感都是有弹性的，不是个定值），反而觉得自己不够努力。而到了大学再要你像高三那样高强度的学习，你会觉得痛苦不堪。学霸并不觉得自己的生活很苦，他们觉得轻松自在，理所当然。这都是因为习惯了，习惯可以减轻很多负担。当你例行公事的去刷牙洗脸，你一点都不觉的难，人的习惯是人最大的助手。习惯一养成，一切都OK。当这种习惯一尘不变时可以稍作改变，变为有趣，例子：刷牙买新牙膏。习惯的养成刚开始都是痛苦的，巨大的改变所带来的痛苦要挺过去。长痛不如短痛，这是对付改变的痛苦的方法。对付复杂带来的痛苦的方法更简单，把复杂程度降到一点点的时候，痛苦变为有趣。这里我还写了点有关学习方法的建议：学习方法总结。</p>\n<p>最后附上我喜欢的一张壁纸，愿每个人都如这个 月夜攀登者 一样执着：</p>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/3690260-23096abf961e2cfb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"月夜攀登者\"></p>\n<h2 id=\"曾今的思考笔记\"><a href=\"#曾今的思考笔记\" class=\"headerlink\" title=\"曾今的思考笔记\"></a>曾今的思考笔记</h2><h3 id=\"人生的动与静：\"><a href=\"#人生的动与静：\" class=\"headerlink\" title=\"人生的动与静：\"></a>人生的动与静：</h3><p>本来很早就想写这个话题了，这个想法是我在逛长沙市博物馆看画展的时候想到的，现在我连那个画家叫什么名字都忘了，但那一天出去走的时候去了很多地方，包括创客展，长沙市一中，烈士公园，等等。看完老先生的画作后我突然有一种感觉，就是人生不应该只呆在一个老地方过完这一辈子，那样当你回想起来的时候，发现每天都过得差不多，也就了无生趣了，生活应该是动态的有活力的，世界那么大，应该出去看看。人生那么长，应该多经历一些有趣的事。记得以前看过一篇文章，是讲什么叫有趣，什么叫舒适，有趣就是复杂，舒适就是简单，过于复杂让人渴望简单，过于简单，人又觉得无趣。所以生活就是在这两者之间取舍。累了就歇着，无聊了就找些稍复杂、有挑战性的事来做。</p>\n<p>我的观点是人生在宏观上来看应该是动态的，在微观上是静态的。人需要不断的用新鲜事物来刺激自己，所谓生活每一天都很新鲜，就是这个道理。但过于奔波劳累，就又让人心生疲惫和厌倦。所以在动的过程中，也要让每一段经历沉下心去，过好那一段。这种感觉是很美好的。<br>每次出去走走，头脑都会清新好多，好像突然跳出了原来那个时空，以一种更宽广的视野看待现在的自己，人生的轨迹，想做的事仿佛又清晰了一些。所以要不时的出去走走，或者换一换环境，不要呆在寝室，一天下来只干了一堆琐事。</p>\n<p>明白自己真正想要什么，然后动手去做。人生才会精彩。</p>\n<p>参差多态乃幸福本源。去经历一些新奇的事，有趣的事。不要每天都一成不变。</p>\n<h3 id=\"少收藏，多消化：\"><a href=\"#少收藏，多消化：\" class=\"headerlink\" title=\"少收藏，多消化：\"></a>少收藏，多消化：</h3><p>这个世界上所有的东西都是有生命周期的（有寿命的），那些好用的工具，美好的东西也是如此。<br>今天清理了一下手机，又想起了umano，突然感悟到这世界上所有的东西都是有自己的期限的。以前也想过这个问题，就是要趁着那些美好的事物还在的时候去好好体验一下，见证他们的存在，王小波说希望这一生经历一些有趣的事，懂得一些道理。我觉得很对。但是反过来，既然所有的东西都是有寿命的，那么我现在手机上用的这些应用，这些工具也许有一天也终将没落。有太多的例子了，天涯，猫扑，衰败何其快，这个世界发展的太快了。微信也是才出不久就如日中天了。我应该好好去利用这些工具，但同时又不被他们绑架。</p>\n<p>不要在收着藏着了，那不是你自己的东西，也不会成为你自己的东西。我曾今非常喜欢在用chrome浏览网页的时候收藏网页，随着时间的推移我收藏的网页变得越来越多，心理负担也变得越来越重，我不断的想花个时间去给我的书签分个类，我后来确实做到了，为了尽可能的细分管理，分了很多类别。但总有感觉不对劲的地方，最终我放弃了书签，而是改用搜索，最开始的理由是为了锻炼自己的搜索能力（因为我觉得曾今找到过一次的网页，今后也应该有能力找到才对），后来我渐渐明白收藏癖对自己的压力有多大，尤其是你心里总是惦记着自己的收藏夹的时候，不是你的终究不是你的，收藏了不看和没收藏实际上是一样的，但留在那里却给自己造成了无形的压力，注重消化和吸收，并做好记录和总结吧。</p>\n<h3 id=\"积极的人生态度：\"><a href=\"#积极的人生态度：\" class=\"headerlink\" title=\"积极的人生态度：\"></a>积极的人生态度：</h3><p>在这里我要强调，若想人生过得精彩，过得开心，一定要培养一种积极的人生态度。毛泽东就是一个典型的例子，豪气冲天，自信积极，人生无比精彩，会当击水三千里，自信人生二百年。这不是我以前所向往的生活吗，对，生活理当如此，一个人怎么能苟且的活着，那样还有什么意思呢。消极是失意人生之源。想想七龙珠里面的热血，火影，海贼王，莫不是有梦想之人的奋斗史。曾今的少年就真的被打败了吗，就真的甘于被生活和现实打败了吗，那这样下去接下来的人生可还有什么意义可言，无梦想，无热血，无积极的生活态度，可以去死矣。自卑是一种傻逼的生活方式，想想曾今电影王牌大贱谍2中的奥斯汀，人长得丑，矮，那又怎样，看看他的人生多精彩。人生唯爱情和美食不可辜负。爱情和美食你都经历过吗。<br>人生只有血凉与热的区别。火苗再小，也要反复点燃。</p>\n<h3 id=\"做好规划：\"><a href=\"#做好规划：\" class=\"headerlink\" title=\"做好规划：\"></a>做好规划：</h3><p>今天晚上7点去参加深圳双选会，看宣传片的时候突然脑子里蹦出一个念头，而且感觉越来越强烈。一个人究竟能走多远？我曾今以为自己能走很远，走到天涯海角， 既去做研究，当教授，又去赚大钱，做老板，所有美好的事全都在我身上。可是现在呢？呵呵，现在的处境离想象实在太远了。现在连找工作都是个问题。我们都知道企业做项目要有规划，一个国家发展要有规划，很多事都要有规划，而且越重要的事规划就越是严密，漏洞很少，并且都一一实现了。人生这么重要的一趟旅程又怎能随波逐流呢？很多人说随心随性，到头来这旅程又真的是你想要的吗？大多数人都是被生活推着走，没有人生规划的人更是如行尸走肉，如随风飘荡的落叶不知去向何方。年轻时的壮志，梦想，或者幻想，最终都一一破灭，成为遥不可及的东西。回头看我的人生轨迹，可以说我自己从来没有规划过，小的时候基本上是父母，社会，学校在规划我的轨迹，现在到了大学，自己有了能力和权力规划自己的人生（其实小的时候就可以规划，可惜没有这种意识，就算是大学的前三年，也不依旧没这意识吗）。想追求什么，可能我现在还不明白自己真的想追求什么，我一无所长，没有热爱。想追求什么也并不是想想就可以实现的，必须对此作出规划，才知道原来人生，原来生命并不是有无限可能，无限可能说出来都是骗人的。当你真的着手去规划，你才发现，要达到目的是要付出多大的努力，耗费多大的时间。而人生区区几十年，又能完成多少你所想的壮志和梦想呢。恐怕不多。这提醒我们，再不规划，再随风飘荡，恐怕连一件想要做的事也完不成，人生留下的将尽是无奈和事与愿违。比如一件小事，复习操作系统，你是直接就开始拿起课本复习，还是有规划的复习。没有规划，你知道自己几时能看完吗？你知道自己能在多长时间内看到多少程度吗？恐怕到最后要花很长时间，但是你当初没想到，恐怕你没有计划地想什么时候看两眼就看两眼，不想看就扔一边，最后只看了一点点就放弃了。这就是随性的最可怕的地方。你根本没有去预计自己会到达什么地方，你的预算能力将变得很弱，你的生活和人生将失去控制不由你主宰。看了人生7年the up series，才知道人生何其短暂，要达成自己梦想的成就根本没多少时间可以用。如果不从现在开始规划，7年后的你是什么样子呢。</p>\n<p>规划的关注点不应该是自己的时间，而应该是具体的任务，对于许多长期目标来说，花多少时间去做事不重要，做完你要做的事才重要，做的不好不要紧，坚持去做。</p>\n<h3 id=\"注意自己的性格\"><a href=\"#注意自己的性格\" class=\"headerlink\" title=\"注意自己的性格\"></a>注意自己的性格</h3><p>今天中午2点去华为笔试，做了一个性格测试，这是我第一次认认真真做性格测试，我突然发现自己的性格很有问题，于我对自己的的期望，幻想中的自己区别很大。可以肯定的说，以我目前的性格，恐怕无法实现我的梦想，让自己的能力和地位达到想象中的高度。如果我想要做一个领导，我需要哪些品质，又需要怎样去培养？如果我要让自己更受欢迎，我需要哪些品质，又需要怎样去培养？这些都是很重要的问题，平时如果不注意，对自己的梦想只是想想罢了，那到时候就会发现自己也真的只是想想罢了。有句话很经典，播种一种思想，收获一种行为，播种一种行为，收获一种习惯，播种一种习惯，收获一种性格，播种一种性格，收获一种人生。性格决定一个人的行为，而行为习惯又在巩固性格，或者形成性格。性格决定人的取舍和行为方式的例子屡见不鲜。性格将决定一个人的命运。但这也是个顽固的东西，很难改变，需要坚持。我觉得自己应该多问问自己今天做的这类性格测试中的问题，这些都是一个人的基本性格，世界观和价值取向，一个人灵魂的体现。我发现自己的性格很差，基本像一张白纸，没有自己的主张，有的全是懦弱，老好人，这跟我从小的经历有关。关于性格的培养，今后要有详细的规划才行。</p>\n<h2 id=\"你的迷茫值得吗？\"><a href=\"#你的迷茫值得吗？\" class=\"headerlink\" title=\"你的迷茫值得吗？\"></a>你的迷茫值得吗？</h2><p>我们都想让自己的人生达到最优解，对此我推荐贪心算法（动态规划不可取，因为你无法归因，人生是向前的，你无法回到过去重来），我相信只要人生的每个阶段都最优化，整个人生的解一定不会差（相反，你如果每个阶段都混得很差，怎么指望活出人生的最优）。</p>\n<p>这是我学生时期写的一篇关于怎么找准努力方向，走对正确的路，以及高效的学习和进步的一点思考。当时我正为自己的专业学的不好而感到恐慌和自卑，为自己遇到各种不懂的问题而不得解感到烦躁，继而封闭自己，企图逃避。高中到大学的跨越始终太大，有些人四年之中一直是迷茫的，这种深深的不适是教育体制造成的，但是这种改变也是必要的，因为你的人生你要自己负责，带你高三的老师班主任不会为这负责，不要被桎梏久了就忘了外面精彩的世界和人生。</p>\n<p>从被动到主动，也许只需要一个观念的转变，也许对于许多人来说却是千折百回、痛苦煎熬。愿你不要再做一个被动的人。</p>\n<h3 id=\"学习不难，合适的路径获得难\"><a href=\"#学习不难，合适的路径获得难\" class=\"headerlink\" title=\"学习不难，合适的路径获得难\"></a>学习不难，合适的路径获得难</h3><p>（有时候是教材没有讲得浅显易懂，有时候是自己没有潜心去看。还有时候是根本没有教材，也就是根本没有人带，苦苦摸索耗费你巨大精力，有种要死的感觉，大学的学习难于高中大概也是这种感觉（在上大学之前所有的知识都是老师一口一口喂的，大学里我所有的专业知识都是自学的，老师无异于一个摆设）。其实这个道理十分广泛，可以改成前进不难，找对路子难。关于学习方法，可以参考我这篇：学习方法总结）</p>\n<p>最近一直感慨没有前人带路，走的步履维艰，回头看看自己走过的路。最后悔的莫过于没有参加ACM，没有任何竞赛，也没有奖学金，还有很多原本能做到的东西都没有去做。没有人提醒自己，教自己，不管是技术上的还是生活规划等等。我知道是自己以前都被别人规划好了，小的时候有家人带路，九年义务教育的时候有老师带路，何况我妈还是我小学老师呢，使得我从小备受关注和提携。现在才发现以前的那种生活状态才是不合理的，现在过的是生活的本质的样子，想要回头看的时候不那么后悔一定要得到全局视角，要跳出来看。去主动争取，去联系前辈们， 去获得过来人的箴言和 第三视角的指导，不要把自己框在现时现地 当然不能只听一家之言，要做大数据统计分析，然后应对现在，应对未来。</p>\n<h3 id=\"意识很重要\"><a href=\"#意识很重要\" class=\"headerlink\" title=\"意识很重要\"></a>意识很重要</h3><p>自己终于意识到了，摸着石头过河是愚蠢的，是不必要的，前人早就有了经验，这条路并不是新的。但是生活中又有多少的东西是我还没有意识到的呢？突然有点恐慌。仔细思考一下，发现。其实意识不到是很正常的，你没有处于那个环境之下，没有经历和经验，始终是意识不到的。换句话说，意识不能凭空产生。要么自己经历了，要么别人经历了，然后告诉你，然后你获得了新的思考，恍然大悟，如获新生。 对的，意识不能凭空产生。那么节省时间的方法就是，去跟别人交流吧，去获得别人的经历，经验。去不断增强自己的见识，拓宽自己的视野。意识，思考，思想会源源不断的产生。 把自己闷在自己的思考里，并不能获得多少新的东西。</p>\n<h3 id=\"不要想当然，事情可能根本不是这样\"><a href=\"#不要想当然，事情可能根本不是这样\" class=\"headerlink\" title=\"不要想当然，事情可能根本不是这样\"></a>不要想当然，事情可能根本不是这样</h3><p>高中的时候以为成绩最重要，到了大学也继续这样认为，直到被现实打破，才知道了能力很重要（如果你在985大学，建议还是一定要刷好绩点，因为可以保研，而且还是保到很不错的学校，我自己就认为不注重成绩是我大学里做的最失败的一件事，因为相对考研来讲，平时的考试要拿高分确实简单不少）。可能到了工作中，我们还一直奉行能力很重要这一条，但是现实又会告诉我们关系很重要。可能我们觉得现在可以单身，不谈恋爱，到了工作后一定年纪觉得当时自己真的傻透了。就这样我们一直想当然，自以为是。现实会粉碎你的想当然，让你痛苦万分，后悔不已。可以大胆猜测，但是不要默默地就把它当成真理。 还是前面说的，我们应该去问问经历过的人，做大量数据统计分析。然后才能得出合乎事实的东西。补充：（大学里成绩同样很重要，保研和奖学金都靠成绩，即使考试很水，但判断学生的基本条件是成绩，而且认真的态度在哪都是最重要的，态度决定高度。我相信很多人身边都有这种人，他们就是凭着一股认真的劲儿，大学生活才如此丰富多彩。另外能力确实很重要，在中国并不是有关系就行，工作看的是业绩，那么能力就是重要的。可以说学习是学生的天职，那么成绩就是重要的，读研可能就是研究水平，就是发的paper的多少了，这些都是简单的就可以推理出来的，并不是想当然。而大学谈恋爱确实不怎么好，因为可能根本找不到我喜欢的女孩子也喜欢我的情况，将就自己会更加不快乐。要谈恋爱首先得正确的认识自己，然后看看自己的眼光和自己的水平是否匹配，眼光高水平低那就注孤生啊。）</p>\n<h3 id=\"获得局外视角的途径\"><a href=\"#获得局外视角的途径\" class=\"headerlink\" title=\"获得局外视角的途径\"></a>获得局外视角的途径</h3><p>前面讲的三条都指向同一点：不要闭门造车，要找前辈，获得局外视角。所谓当局者迷，旁观者清。所谓经历过了才懂得。所以接下来我记下怎样去找。</p>\n<p>找导师，导师再介绍师兄师姐。<br>进论坛，找工作多年的前辈。（因为即将步入工作，可以问问工作中什么最重要，怎样让这个最重要的方面成为自己的强项）<br>搜索各种群，进群找工作经验丰富的前辈。<br>这里补充一句，现在的话，学计算机专业的同学可以找我啊，我们可以一起进步，共同成长，人类一直都是以共同话题和爱好而相聚在一起的，我相信未来的互联网的社区化会越来越成熟。</p>\n<h2 id=\"信息时代的一点思考\"><a href=\"#信息时代的一点思考\" class=\"headerlink\" title=\"信息时代的一点思考\"></a>信息时代的一点思考</h2><p>这个时代的最大特征就是信息爆炸，人类每天面临着海量的信息，但有多少是有用的呢，这还真不敢恭维，其实有意义的东西就那么多，人类所有的智慧加起来也就那么多，学个大部分完全是可以的。所以面对信息爆炸最好的方法就是不要去接触那些杂七杂八的信息，而是 转过头去学习最本质的人类智慧，看看新闻可以、一些基本的娱乐常识可以了解，但没必要懂那么多，只要算个融入社会的现代人就行了，网上流行的东西更迭那么快，没必要主动去接触，被动的去接受就行了，只要你处在那个环境中，只要一件事很火，你自然而然就从身边的人那里得知了，而且这些都是没有价值的信息，只是为了塑造一种圈内认同感，就是我们都是现代社会互联网八卦这个圈内人。要学习、要搜索，主动去接触有价值的信息，规避泛滥的没有价值的信息。 比如各种广告，软文，比如打开有道词典各种推荐，千万不要点进去啊，比如知乎各种垃圾提问，粗浅的回答，抖机灵的回答，大部分其实也都是些无意义的信息，比如QQ聊天其实都挺没意义的。只要自己往前，不要回头（志同道合的可以稍微聊聊）。什么破公众号其实也没啥意思。这么看来我以前自我提升那么慢，进步那么慢，甚至退步，这些的最根本原因就在于被信息爆炸炸到了，被很多无意义的信息淹没了，感觉每天都很忙，其实都在浪费时间，都在消耗自己，都在做没有价值的事。幸好现在终于幡然醒悟。好好把新概念英语看的滚瓜烂熟，不要看知乎了，想学人生经验，心理学，哲学，经济学，法律，摄影等等，完全应该主动的去学，而不是被动的去每天刷知乎，这种学法完全错误，也就是说知乎是用来搜的，不是用来每天被动接受信息。可以按领域和话题搜索学习，也可以按人来学习，比如大V，肥肥猫，轮子哥，公众号罗辑思维可以听，因为这是聚合信息，王小波全集可以看，这两个都是按人来划分学习的。所以要么按话题领域，要么按人，来进行有效学习。少听点歌，多学点乐理。少看点电视剧，多学点写故事，小说。即有目的地做事，而不是无目的的消遣。即便再好的材料，你囫囵吞枣能尝出什么味道出来，你只是消遣能学到什么，看完了什么收获都没有那跟没看有什么区别呢？不要消遣和漫无目的啊，人必须要成长，提升，否则虚耗光阴，人生也就平淡无奇。信息爆炸带来的后果，就是无意义的信息大大增加，占信息总比越来越大，新出的游戏层出不穷，新出的影视剧层出不穷，新出的小说层出不穷，新出的音乐层出不穷，人们的时间正在越来越多的被这些东西夺取，游戏无非是一些逻辑加循环，循环多一点，故事也无非是一些逻辑加循环，循环少一点，背后的原理才是有意义的信息，而故事和游戏本身并不是那么重要，因为它们本身都是千千万万，根本看不完。现代社会有一个词应用而生：娱乐至死，这其实是信息爆炸带来的结果之一，也是人类生产力提高的后果，越来越多的工作交给了机器和自然能源，人空闲下来就开始找乐子，娱乐的东西现在每天充斥着我们的生活，刺激着我们的神经，而且虚拟的东西制作的越来越好，我们就用虚拟的东西去完成自己的梦想，但虚拟的始终是虚拟的。</p>\n<p>伴随着信息爆炸，应该要 更好的信息处理技术，处理海量数据，要更好的交互技术，来帮助人机之间无障碍的沟通，最后完全可以做到记录人们每天的所有信息，所有想法。</p>\n"},{"layout":"post","title":"Inside the C++ Object Model 系列笔记 一 -- Object Lessons","date":"2017-10-18T16:00:00.000Z","comments":1,"_content":"\n>多态：统一的接口，不同的实现\n\n**C++多态（polymorphism）** 表示”以一个public base class的指针（或者reference），寻址出一个derived class object”\n\n## Layout Costs for Adding Encapsulation(封装)\n\n第一章 Object Lessons 介绍了 C++如何在背后实现一个对象，内存中的布局以及空间上的关系。\n\n**在计算机的原理中，要实现某个机制，我们总能找到很多种实现方式**（对比着学习，多思考每种实现方法的利弊），C++的类的实现也不例外，让我们对比以下三种实现方式：\n\n### 三种对象实现模式\n\n#### A Simple Object Model\n\n![A Simple Object Model](https://wx4.sinaimg.cn/mw690/006zFO3ggy1fknaq5739jj30nu0l4jsy.jpg)\n\n可以看到，简单对象模型把所有的data member和member function（函数指针）都放在对象里了。\n\n#### A Table-driven Object Model\n\n![A Table-driven Object Model](https://wx4.sinaimg.cn/mw690/006zFO3ggy1fmxnb321f6j30n80kemzy.jpg)\n\n表驱动模型把member分为data和function两类，用两个指针分别指向两个表，一个存放所有的data member，一个存放所有的function指针。\n\n#### The C++ Object Model\n\n![The C++ Object Model](https://wx3.sinaimg.cn/mw690/006zFO3ggy1fmxnd1t7ucj30ua0ju0wu.jpg)\n\n```C++\ntemplate<class Type>\nclass Point3d{\npublic:\n    Point3d(Type x, Type y, Type z) : x_(x), y_(y), z_(z) {}\n    Type x() { return x_; }\nprivate:\n    Type x_, y_, z_;\n}\n```\n\n上面的 C++ 类并不会比 C 语言 的struct 耗费更多的内存空间，三个 data members 直接内含于 Object 中，member functions 则放在 Object 外。\n\nC++的 data members 有两种：**static 和 nonstatic**\n\nC++的 member functions 有三种：**static 、nonstatic 、virtual**\n\n>放在 Object 中的只有 nonstatic data members，其他的统统是放在 Object 外。\n\n一个对象的内存布局大小(通常由 3 部分组成):\n\n- 其 nonstatic data member 的总和大小;\n- 任何由于位对齐所需要的填补上去的空间;(关于内存对齐，自己查)\n- 加上了为了支持virtual机制而引起的额外负担。\n\n### data members 在内存中的布局\n\nC++只保证处于同一个 access section（也就是private,public,protected片段）的数据，一定会以声明的次序出现在内存布局当中(要求较晚出现的数据成员处在较大的内存地址中)。\nC++标准只提供了这一点点的保证。\n允许编译器将多个Acess Section的顺序自由排列，而不必在乎它们的声明次序。但似乎没有编译器这样做。\n对于继承类，C++标准并未指定是其基类成员在前还是自己的成员在前。\n\n```C++\nclass X {\npublic:\n   int i;\n   int j;\nprivate:\n   int k;\n   int n;\n}\n```\n\n数据 i 一定在 j 之前，k 一定在 n 之前。具体什么顺序就看编译器了。\n\n### Virtual Table(vtbl, vtable) 和 vptr\n\nVirtual function 机制由以下2个步骤来支持：\n\n1. 每个 class 产生的 Virtual function 的指针放在 Virtual Table 中\n2. 编译器给每个 class object 添加一个指针 vptr，指向相应的 vtable\n\n一个 vtable 对应一个 class，一个 vptr 才对应一个 class object，必须区分开这 2 个概念。vtable 独立于对象，就跟函数独立于对象一样。\n这样所有对象才能共享它们，就像 static data members 被共享一样。\n\nRTTI(run-time type identification):一般来说，每一个 class 相关联的 type_info 对象的指针通常也保存在 vtable 的第一个 slot 中。关于 type_info 是什么，可以自己查。\n\n### 引入继承后的对象模型成本\n\n- 如果是普通继承，父对象被直接包含在子对象里面，这样父对象的存取也是直接进行的，没有额外的指针成本。\n- 如果是虚拟继承，父对象由一个指针指出来，这样父对象的存取就必须由指针访问，添加了一层间接性。\n\nvirtual base class，用以实现 “多次出现在继承体系中的base class，有一个单一而被共享的实例”\n\n![虚基类](https://wx3.sinaimg.cn/mw690/006zFO3gly1fknlhzg45wj30bs0asq3w.jpg)\n\n![虚拟多重继承](https://wx1.sinaimg.cn/mw690/006zFO3gly1fknli0837fj317w0mmhao.jpg)\n\n```C++\nclass A { public: void Foo() {} };\nclass B : public virtual A {};\nclass C : public virtual A {};\nclass D : public B, public C {};\n```\n\n>我觉得这里有个问题，class D继承class B和class C的时候并不是虚继承，所以何不将B和C直接放在D中呢？这样就省了两次指针。\n\n## struct 和 class 关键字的区别\n\n总共就两个区别：\n\n- struct defaults to public access and class defaults to private access.\n- When inheriting, struct defaults to public inheritance and class defaults to private inheritance. (Ironically, as with so many things in C++, the default is backwards: public inheritance is by far the more common choice, but people rarely declare structs just to save on typing the “public” keyword). 哈哈，我觉得这么做的目的无非就是提醒你注意封装，不要给外部暴露没必要的东西，所以才把默认搞成private。\n\n除此之外 struct 和 class 一样。\n\nstruct 用来表现那些只有数据的集合体 POD(Plain Old Data)、而 class则希望表达的是`ADT(abstract data type)`的思想。\n\n>POD stands for Plain Old Data - that is, a class (whether defined with the keyword struct or the keyword class) without constructors, destructors and virtual members functions.\n\n由于这2个关键字在本质上无区别，所以class并没有必须要引入，但是引入它的确非常令人满意，因为这个语言所引入的不止是这个关键字，还有它所支持的封装和继承的哲学。可以这样想象:struct只剩下方便C程序员迁徙到C++的用途了。\n\n## programming paradigms\n\nC++支持三种形式的编程风格(或称典范 paradigm):\n\n- 面向过程的风格（procedural model）:就像C一样，一条语句接一条语句的执行或者函数跳转;\n- 抽象数据类型模型(abstract data type model，ADT):仅仅使用了class的封装，很多人都是 在用基于对象的风格却误以为自己在使用面向对象的风格;\n- 面向对象的风格(object-oriented):使用了class的封装和多态的编程思维(多态才是 真正的面向对象的特征)。\n\n纯粹以一种paradigm写程序，有助于整体行为的良好稳固。\n\n>一个 reference 通常是以一个指针来实现的，所以 point 和 reference 并没有本质的区别，reference 和 const 指针的区别就是，你取 reference 指针的地址的时候，取到的是数据的地址，const 指针取地址取到的是指针的地址。\n\n```C++\n#include <iostream>\n\nusing namespace std;\n\nint main(){\n  int a=1;\n  int &b=a;\n  const int *p = &a;\n  cout << &b << endl;\n  cout << p << endl;\n  cout << &p << endl;\n}\n```\n\n也就是说你取不到 b 的地址。所以说引用相当于一个 `别名`。引用常用在函数调用里，可以直接操作原有对象，这样就可以不用写指针的指针这种绕弯的东西了。\n\n>函数的实参传递给形参是值传递，也就是一个 copy，形参在函数里将是一个局部变量。这个特性是许多新手面临的大坑。一道经典的考察题目便是，实现一个 C 语言的 swap 函数，由于 C 语言没有引用，你就只能用指针来操作原有对象了。\n\n## 指针的类型\n\n- 对于内存来说，不同类型的指针并没有什么不同。它们都是占用一个word的大小（所以word的大小决定了内存可访问空间的大小，32位系统是4字节，64位系统是8字节），包含一个数字，这个数字代表内存中的一个地址;\n- 指针的类型是编译器的概念，对于硬件来说，并没有什么指针类型的概念;\n- 转型操作也只是一种编译器的指令，它改变的是编译器对被指内存的解释方式而已!\n- void*指针只能够持有一个地址（一个字节），而不能通过它操作所指向的object\n","source":"_posts/2017/2017-10-19-Inside-the-C++-Object-Model-系列笔记--Object-Lessons.md","raw":"---\nlayout: post\ntitle: Inside the C++ Object Model 系列笔记 一 -- Object Lessons\ndate: 2017-10-19\ncategories: [读书笔记, 《Inside the C++ Object Model》]\ntags: [C++]\ncomments: true\n---\n\n>多态：统一的接口，不同的实现\n\n**C++多态（polymorphism）** 表示”以一个public base class的指针（或者reference），寻址出一个derived class object”\n\n## Layout Costs for Adding Encapsulation(封装)\n\n第一章 Object Lessons 介绍了 C++如何在背后实现一个对象，内存中的布局以及空间上的关系。\n\n**在计算机的原理中，要实现某个机制，我们总能找到很多种实现方式**（对比着学习，多思考每种实现方法的利弊），C++的类的实现也不例外，让我们对比以下三种实现方式：\n\n### 三种对象实现模式\n\n#### A Simple Object Model\n\n![A Simple Object Model](https://wx4.sinaimg.cn/mw690/006zFO3ggy1fknaq5739jj30nu0l4jsy.jpg)\n\n可以看到，简单对象模型把所有的data member和member function（函数指针）都放在对象里了。\n\n#### A Table-driven Object Model\n\n![A Table-driven Object Model](https://wx4.sinaimg.cn/mw690/006zFO3ggy1fmxnb321f6j30n80kemzy.jpg)\n\n表驱动模型把member分为data和function两类，用两个指针分别指向两个表，一个存放所有的data member，一个存放所有的function指针。\n\n#### The C++ Object Model\n\n![The C++ Object Model](https://wx3.sinaimg.cn/mw690/006zFO3ggy1fmxnd1t7ucj30ua0ju0wu.jpg)\n\n```C++\ntemplate<class Type>\nclass Point3d{\npublic:\n    Point3d(Type x, Type y, Type z) : x_(x), y_(y), z_(z) {}\n    Type x() { return x_; }\nprivate:\n    Type x_, y_, z_;\n}\n```\n\n上面的 C++ 类并不会比 C 语言 的struct 耗费更多的内存空间，三个 data members 直接内含于 Object 中，member functions 则放在 Object 外。\n\nC++的 data members 有两种：**static 和 nonstatic**\n\nC++的 member functions 有三种：**static 、nonstatic 、virtual**\n\n>放在 Object 中的只有 nonstatic data members，其他的统统是放在 Object 外。\n\n一个对象的内存布局大小(通常由 3 部分组成):\n\n- 其 nonstatic data member 的总和大小;\n- 任何由于位对齐所需要的填补上去的空间;(关于内存对齐，自己查)\n- 加上了为了支持virtual机制而引起的额外负担。\n\n### data members 在内存中的布局\n\nC++只保证处于同一个 access section（也就是private,public,protected片段）的数据，一定会以声明的次序出现在内存布局当中(要求较晚出现的数据成员处在较大的内存地址中)。\nC++标准只提供了这一点点的保证。\n允许编译器将多个Acess Section的顺序自由排列，而不必在乎它们的声明次序。但似乎没有编译器这样做。\n对于继承类，C++标准并未指定是其基类成员在前还是自己的成员在前。\n\n```C++\nclass X {\npublic:\n   int i;\n   int j;\nprivate:\n   int k;\n   int n;\n}\n```\n\n数据 i 一定在 j 之前，k 一定在 n 之前。具体什么顺序就看编译器了。\n\n### Virtual Table(vtbl, vtable) 和 vptr\n\nVirtual function 机制由以下2个步骤来支持：\n\n1. 每个 class 产生的 Virtual function 的指针放在 Virtual Table 中\n2. 编译器给每个 class object 添加一个指针 vptr，指向相应的 vtable\n\n一个 vtable 对应一个 class，一个 vptr 才对应一个 class object，必须区分开这 2 个概念。vtable 独立于对象，就跟函数独立于对象一样。\n这样所有对象才能共享它们，就像 static data members 被共享一样。\n\nRTTI(run-time type identification):一般来说，每一个 class 相关联的 type_info 对象的指针通常也保存在 vtable 的第一个 slot 中。关于 type_info 是什么，可以自己查。\n\n### 引入继承后的对象模型成本\n\n- 如果是普通继承，父对象被直接包含在子对象里面，这样父对象的存取也是直接进行的，没有额外的指针成本。\n- 如果是虚拟继承，父对象由一个指针指出来，这样父对象的存取就必须由指针访问，添加了一层间接性。\n\nvirtual base class，用以实现 “多次出现在继承体系中的base class，有一个单一而被共享的实例”\n\n![虚基类](https://wx3.sinaimg.cn/mw690/006zFO3gly1fknlhzg45wj30bs0asq3w.jpg)\n\n![虚拟多重继承](https://wx1.sinaimg.cn/mw690/006zFO3gly1fknli0837fj317w0mmhao.jpg)\n\n```C++\nclass A { public: void Foo() {} };\nclass B : public virtual A {};\nclass C : public virtual A {};\nclass D : public B, public C {};\n```\n\n>我觉得这里有个问题，class D继承class B和class C的时候并不是虚继承，所以何不将B和C直接放在D中呢？这样就省了两次指针。\n\n## struct 和 class 关键字的区别\n\n总共就两个区别：\n\n- struct defaults to public access and class defaults to private access.\n- When inheriting, struct defaults to public inheritance and class defaults to private inheritance. (Ironically, as with so many things in C++, the default is backwards: public inheritance is by far the more common choice, but people rarely declare structs just to save on typing the “public” keyword). 哈哈，我觉得这么做的目的无非就是提醒你注意封装，不要给外部暴露没必要的东西，所以才把默认搞成private。\n\n除此之外 struct 和 class 一样。\n\nstruct 用来表现那些只有数据的集合体 POD(Plain Old Data)、而 class则希望表达的是`ADT(abstract data type)`的思想。\n\n>POD stands for Plain Old Data - that is, a class (whether defined with the keyword struct or the keyword class) without constructors, destructors and virtual members functions.\n\n由于这2个关键字在本质上无区别，所以class并没有必须要引入，但是引入它的确非常令人满意，因为这个语言所引入的不止是这个关键字，还有它所支持的封装和继承的哲学。可以这样想象:struct只剩下方便C程序员迁徙到C++的用途了。\n\n## programming paradigms\n\nC++支持三种形式的编程风格(或称典范 paradigm):\n\n- 面向过程的风格（procedural model）:就像C一样，一条语句接一条语句的执行或者函数跳转;\n- 抽象数据类型模型(abstract data type model，ADT):仅仅使用了class的封装，很多人都是 在用基于对象的风格却误以为自己在使用面向对象的风格;\n- 面向对象的风格(object-oriented):使用了class的封装和多态的编程思维(多态才是 真正的面向对象的特征)。\n\n纯粹以一种paradigm写程序，有助于整体行为的良好稳固。\n\n>一个 reference 通常是以一个指针来实现的，所以 point 和 reference 并没有本质的区别，reference 和 const 指针的区别就是，你取 reference 指针的地址的时候，取到的是数据的地址，const 指针取地址取到的是指针的地址。\n\n```C++\n#include <iostream>\n\nusing namespace std;\n\nint main(){\n  int a=1;\n  int &b=a;\n  const int *p = &a;\n  cout << &b << endl;\n  cout << p << endl;\n  cout << &p << endl;\n}\n```\n\n也就是说你取不到 b 的地址。所以说引用相当于一个 `别名`。引用常用在函数调用里，可以直接操作原有对象，这样就可以不用写指针的指针这种绕弯的东西了。\n\n>函数的实参传递给形参是值传递，也就是一个 copy，形参在函数里将是一个局部变量。这个特性是许多新手面临的大坑。一道经典的考察题目便是，实现一个 C 语言的 swap 函数，由于 C 语言没有引用，你就只能用指针来操作原有对象了。\n\n## 指针的类型\n\n- 对于内存来说，不同类型的指针并没有什么不同。它们都是占用一个word的大小（所以word的大小决定了内存可访问空间的大小，32位系统是4字节，64位系统是8字节），包含一个数字，这个数字代表内存中的一个地址;\n- 指针的类型是编译器的概念，对于硬件来说，并没有什么指针类型的概念;\n- 转型操作也只是一种编译器的指令，它改变的是编译器对被指内存的解释方式而已!\n- void*指针只能够持有一个地址（一个字节），而不能通过它操作所指向的object\n","slug":"Inside-the-C++-Object-Model-系列笔记--Object-Lessons","published":1,"updated":"2018-06-10T12:02:55.603Z","photos":[],"link":"","_id":"cjm2w8dcx0017fgpxk24spqpg","content":"<blockquote>\n<p>多态：统一的接口，不同的实现</p>\n</blockquote>\n<p><strong>C++多态（polymorphism）</strong> 表示”以一个public base class的指针（或者reference），寻址出一个derived class object”</p>\n<h2 id=\"Layout-Costs-for-Adding-Encapsulation-封装\"><a href=\"#Layout-Costs-for-Adding-Encapsulation-封装\" class=\"headerlink\" title=\"Layout Costs for Adding Encapsulation(封装)\"></a>Layout Costs for Adding Encapsulation(封装)</h2><p>第一章 Object Lessons 介绍了 C++如何在背后实现一个对象，内存中的布局以及空间上的关系。</p>\n<p><strong>在计算机的原理中，要实现某个机制，我们总能找到很多种实现方式</strong>（对比着学习，多思考每种实现方法的利弊），C++的类的实现也不例外，让我们对比以下三种实现方式：</p>\n<h3 id=\"三种对象实现模式\"><a href=\"#三种对象实现模式\" class=\"headerlink\" title=\"三种对象实现模式\"></a>三种对象实现模式</h3><h4 id=\"A-Simple-Object-Model\"><a href=\"#A-Simple-Object-Model\" class=\"headerlink\" title=\"A Simple Object Model\"></a>A Simple Object Model</h4><p><img src=\"https://wx4.sinaimg.cn/mw690/006zFO3ggy1fknaq5739jj30nu0l4jsy.jpg\" alt=\"A Simple Object Model\"></p>\n<p>可以看到，简单对象模型把所有的data member和member function（函数指针）都放在对象里了。</p>\n<h4 id=\"A-Table-driven-Object-Model\"><a href=\"#A-Table-driven-Object-Model\" class=\"headerlink\" title=\"A Table-driven Object Model\"></a>A Table-driven Object Model</h4><p><img src=\"https://wx4.sinaimg.cn/mw690/006zFO3ggy1fmxnb321f6j30n80kemzy.jpg\" alt=\"A Table-driven Object Model\"></p>\n<p>表驱动模型把member分为data和function两类，用两个指针分别指向两个表，一个存放所有的data member，一个存放所有的function指针。</p>\n<h4 id=\"The-C-Object-Model\"><a href=\"#The-C-Object-Model\" class=\"headerlink\" title=\"The C++ Object Model\"></a>The C++ Object Model</h4><p><img src=\"https://wx3.sinaimg.cn/mw690/006zFO3ggy1fmxnd1t7ucj30ua0ju0wu.jpg\" alt=\"The C++ Object Model\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Type</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">Point3d</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Point3d(Type x, Type y, Type z) : x_(x), y_(y), z_(z) &#123;&#125;</span><br><span class=\"line\">    <span class=\"function\">Type <span class=\"title\">x</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> x_; &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    Type x_, y_, z_;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的 C++ 类并不会比 C 语言 的struct 耗费更多的内存空间，三个 data members 直接内含于 Object 中，member functions 则放在 Object 外。</p>\n<p>C++的 data members 有两种：<strong>static 和 nonstatic</strong></p>\n<p>C++的 member functions 有三种：<strong>static 、nonstatic 、virtual</strong></p>\n<blockquote>\n<p>放在 Object 中的只有 nonstatic data members，其他的统统是放在 Object 外。</p>\n</blockquote>\n<p>一个对象的内存布局大小(通常由 3 部分组成):</p>\n<ul>\n<li>其 nonstatic data member 的总和大小;</li>\n<li>任何由于位对齐所需要的填补上去的空间;(关于内存对齐，自己查)</li>\n<li>加上了为了支持virtual机制而引起的额外负担。</li>\n</ul>\n<h3 id=\"data-members-在内存中的布局\"><a href=\"#data-members-在内存中的布局\" class=\"headerlink\" title=\"data members 在内存中的布局\"></a>data members 在内存中的布局</h3><p>C++只保证处于同一个 access section（也就是private,public,protected片段）的数据，一定会以声明的次序出现在内存布局当中(要求较晚出现的数据成员处在较大的内存地址中)。<br>C++标准只提供了这一点点的保证。<br>允许编译器将多个Acess Section的顺序自由排列，而不必在乎它们的声明次序。但似乎没有编译器这样做。<br>对于继承类，C++标准并未指定是其基类成员在前还是自己的成员在前。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">X</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">   <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> j;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">   <span class=\"keyword\">int</span> k;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>数据 i 一定在 j 之前，k 一定在 n 之前。具体什么顺序就看编译器了。</p>\n<h3 id=\"Virtual-Table-vtbl-vtable-和-vptr\"><a href=\"#Virtual-Table-vtbl-vtable-和-vptr\" class=\"headerlink\" title=\"Virtual Table(vtbl, vtable) 和 vptr\"></a>Virtual Table(vtbl, vtable) 和 vptr</h3><p>Virtual function 机制由以下2个步骤来支持：</p>\n<ol>\n<li>每个 class 产生的 Virtual function 的指针放在 Virtual Table 中</li>\n<li>编译器给每个 class object 添加一个指针 vptr，指向相应的 vtable</li>\n</ol>\n<p>一个 vtable 对应一个 class，一个 vptr 才对应一个 class object，必须区分开这 2 个概念。vtable 独立于对象，就跟函数独立于对象一样。<br>这样所有对象才能共享它们，就像 static data members 被共享一样。</p>\n<p>RTTI(run-time type identification):一般来说，每一个 class 相关联的 type_info 对象的指针通常也保存在 vtable 的第一个 slot 中。关于 type_info 是什么，可以自己查。</p>\n<h3 id=\"引入继承后的对象模型成本\"><a href=\"#引入继承后的对象模型成本\" class=\"headerlink\" title=\"引入继承后的对象模型成本\"></a>引入继承后的对象模型成本</h3><ul>\n<li>如果是普通继承，父对象被直接包含在子对象里面，这样父对象的存取也是直接进行的，没有额外的指针成本。</li>\n<li>如果是虚拟继承，父对象由一个指针指出来，这样父对象的存取就必须由指针访问，添加了一层间接性。</li>\n</ul>\n<p>virtual base class，用以实现 “多次出现在继承体系中的base class，有一个单一而被共享的实例”</p>\n<p><img src=\"https://wx3.sinaimg.cn/mw690/006zFO3gly1fknlhzg45wj30bs0asq3w.jpg\" alt=\"虚基类\"></p>\n<p><img src=\"https://wx1.sinaimg.cn/mw690/006zFO3gly1fknli0837fj317w0mmhao.jpg\" alt=\"虚拟多重继承\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> &#123;</span> <span class=\"keyword\">public</span>: <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Foo</span><span class=\"params\">()</span> </span>&#123;&#125; &#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> :</span> <span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> A &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> :</span> <span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> A &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D</span> :</span> <span class=\"keyword\">public</span> B, <span class=\"keyword\">public</span> C &#123;&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>我觉得这里有个问题，class D继承class B和class C的时候并不是虚继承，所以何不将B和C直接放在D中呢？这样就省了两次指针。</p>\n</blockquote>\n<h2 id=\"struct-和-class-关键字的区别\"><a href=\"#struct-和-class-关键字的区别\" class=\"headerlink\" title=\"struct 和 class 关键字的区别\"></a>struct 和 class 关键字的区别</h2><p>总共就两个区别：</p>\n<ul>\n<li>struct defaults to public access and class defaults to private access.</li>\n<li>When inheriting, struct defaults to public inheritance and class defaults to private inheritance. (Ironically, as with so many things in C++, the default is backwards: public inheritance is by far the more common choice, but people rarely declare structs just to save on typing the “public” keyword). 哈哈，我觉得这么做的目的无非就是提醒你注意封装，不要给外部暴露没必要的东西，所以才把默认搞成private。</li>\n</ul>\n<p>除此之外 struct 和 class 一样。</p>\n<p>struct 用来表现那些只有数据的集合体 POD(Plain Old Data)、而 class则希望表达的是<code>ADT(abstract data type)</code>的思想。</p>\n<blockquote>\n<p>POD stands for Plain Old Data - that is, a class (whether defined with the keyword struct or the keyword class) without constructors, destructors and virtual members functions.</p>\n</blockquote>\n<p>由于这2个关键字在本质上无区别，所以class并没有必须要引入，但是引入它的确非常令人满意，因为这个语言所引入的不止是这个关键字，还有它所支持的封装和继承的哲学。可以这样想象:struct只剩下方便C程序员迁徙到C++的用途了。</p>\n<h2 id=\"programming-paradigms\"><a href=\"#programming-paradigms\" class=\"headerlink\" title=\"programming paradigms\"></a>programming paradigms</h2><p>C++支持三种形式的编程风格(或称典范 paradigm):</p>\n<ul>\n<li>面向过程的风格（procedural model）:就像C一样，一条语句接一条语句的执行或者函数跳转;</li>\n<li>抽象数据类型模型(abstract data type model，ADT):仅仅使用了class的封装，很多人都是 在用基于对象的风格却误以为自己在使用面向对象的风格;</li>\n<li>面向对象的风格(object-oriented):使用了class的封装和多态的编程思维(多态才是 真正的面向对象的特征)。</li>\n</ul>\n<p>纯粹以一种paradigm写程序，有助于整体行为的良好稳固。</p>\n<blockquote>\n<p>一个 reference 通常是以一个指针来实现的，所以 point 和 reference 并没有本质的区别，reference 和 const 指针的区别就是，你取 reference 指针的地址的时候，取到的是数据的地址，const 指针取地址取到的是指针的地址。</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> a=<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> &amp;b=a;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *p = &amp;a;</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; &amp;b &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; p &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; &amp;p &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也就是说你取不到 b 的地址。所以说引用相当于一个 <code>别名</code>。引用常用在函数调用里，可以直接操作原有对象，这样就可以不用写指针的指针这种绕弯的东西了。</p>\n<blockquote>\n<p>函数的实参传递给形参是值传递，也就是一个 copy，形参在函数里将是一个局部变量。这个特性是许多新手面临的大坑。一道经典的考察题目便是，实现一个 C 语言的 swap 函数，由于 C 语言没有引用，你就只能用指针来操作原有对象了。</p>\n</blockquote>\n<h2 id=\"指针的类型\"><a href=\"#指针的类型\" class=\"headerlink\" title=\"指针的类型\"></a>指针的类型</h2><ul>\n<li>对于内存来说，不同类型的指针并没有什么不同。它们都是占用一个word的大小（所以word的大小决定了内存可访问空间的大小，32位系统是4字节，64位系统是8字节），包含一个数字，这个数字代表内存中的一个地址;</li>\n<li>指针的类型是编译器的概念，对于硬件来说，并没有什么指针类型的概念;</li>\n<li>转型操作也只是一种编译器的指令，它改变的是编译器对被指内存的解释方式而已!</li>\n<li>void*指针只能够持有一个地址（一个字节），而不能通过它操作所指向的object</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>多态：统一的接口，不同的实现</p>\n</blockquote>\n<p><strong>C++多态（polymorphism）</strong> 表示”以一个public base class的指针（或者reference），寻址出一个derived class object”</p>\n<h2 id=\"Layout-Costs-for-Adding-Encapsulation-封装\"><a href=\"#Layout-Costs-for-Adding-Encapsulation-封装\" class=\"headerlink\" title=\"Layout Costs for Adding Encapsulation(封装)\"></a>Layout Costs for Adding Encapsulation(封装)</h2><p>第一章 Object Lessons 介绍了 C++如何在背后实现一个对象，内存中的布局以及空间上的关系。</p>\n<p><strong>在计算机的原理中，要实现某个机制，我们总能找到很多种实现方式</strong>（对比着学习，多思考每种实现方法的利弊），C++的类的实现也不例外，让我们对比以下三种实现方式：</p>\n<h3 id=\"三种对象实现模式\"><a href=\"#三种对象实现模式\" class=\"headerlink\" title=\"三种对象实现模式\"></a>三种对象实现模式</h3><h4 id=\"A-Simple-Object-Model\"><a href=\"#A-Simple-Object-Model\" class=\"headerlink\" title=\"A Simple Object Model\"></a>A Simple Object Model</h4><p><img src=\"https://wx4.sinaimg.cn/mw690/006zFO3ggy1fknaq5739jj30nu0l4jsy.jpg\" alt=\"A Simple Object Model\"></p>\n<p>可以看到，简单对象模型把所有的data member和member function（函数指针）都放在对象里了。</p>\n<h4 id=\"A-Table-driven-Object-Model\"><a href=\"#A-Table-driven-Object-Model\" class=\"headerlink\" title=\"A Table-driven Object Model\"></a>A Table-driven Object Model</h4><p><img src=\"https://wx4.sinaimg.cn/mw690/006zFO3ggy1fmxnb321f6j30n80kemzy.jpg\" alt=\"A Table-driven Object Model\"></p>\n<p>表驱动模型把member分为data和function两类，用两个指针分别指向两个表，一个存放所有的data member，一个存放所有的function指针。</p>\n<h4 id=\"The-C-Object-Model\"><a href=\"#The-C-Object-Model\" class=\"headerlink\" title=\"The C++ Object Model\"></a>The C++ Object Model</h4><p><img src=\"https://wx3.sinaimg.cn/mw690/006zFO3ggy1fmxnd1t7ucj30ua0ju0wu.jpg\" alt=\"The C++ Object Model\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">template</span>&lt;<span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Type</span>&gt;</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">class</span> <span class=\"title\">Point3d</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    Point3d(Type x, Type y, Type z) : x_(x), y_(y), z_(z) &#123;&#125;</span><br><span class=\"line\">    <span class=\"function\">Type <span class=\"title\">x</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> x_; &#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">    Type x_, y_, z_;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面的 C++ 类并不会比 C 语言 的struct 耗费更多的内存空间，三个 data members 直接内含于 Object 中，member functions 则放在 Object 外。</p>\n<p>C++的 data members 有两种：<strong>static 和 nonstatic</strong></p>\n<p>C++的 member functions 有三种：<strong>static 、nonstatic 、virtual</strong></p>\n<blockquote>\n<p>放在 Object 中的只有 nonstatic data members，其他的统统是放在 Object 外。</p>\n</blockquote>\n<p>一个对象的内存布局大小(通常由 3 部分组成):</p>\n<ul>\n<li>其 nonstatic data member 的总和大小;</li>\n<li>任何由于位对齐所需要的填补上去的空间;(关于内存对齐，自己查)</li>\n<li>加上了为了支持virtual机制而引起的额外负担。</li>\n</ul>\n<h3 id=\"data-members-在内存中的布局\"><a href=\"#data-members-在内存中的布局\" class=\"headerlink\" title=\"data members 在内存中的布局\"></a>data members 在内存中的布局</h3><p>C++只保证处于同一个 access section（也就是private,public,protected片段）的数据，一定会以声明的次序出现在内存布局当中(要求较晚出现的数据成员处在较大的内存地址中)。<br>C++标准只提供了这一点点的保证。<br>允许编译器将多个Acess Section的顺序自由排列，而不必在乎它们的声明次序。但似乎没有编译器这样做。<br>对于继承类，C++标准并未指定是其基类成员在前还是自己的成员在前。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">X</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">   <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> j;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">   <span class=\"keyword\">int</span> k;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>数据 i 一定在 j 之前，k 一定在 n 之前。具体什么顺序就看编译器了。</p>\n<h3 id=\"Virtual-Table-vtbl-vtable-和-vptr\"><a href=\"#Virtual-Table-vtbl-vtable-和-vptr\" class=\"headerlink\" title=\"Virtual Table(vtbl, vtable) 和 vptr\"></a>Virtual Table(vtbl, vtable) 和 vptr</h3><p>Virtual function 机制由以下2个步骤来支持：</p>\n<ol>\n<li>每个 class 产生的 Virtual function 的指针放在 Virtual Table 中</li>\n<li>编译器给每个 class object 添加一个指针 vptr，指向相应的 vtable</li>\n</ol>\n<p>一个 vtable 对应一个 class，一个 vptr 才对应一个 class object，必须区分开这 2 个概念。vtable 独立于对象，就跟函数独立于对象一样。<br>这样所有对象才能共享它们，就像 static data members 被共享一样。</p>\n<p>RTTI(run-time type identification):一般来说，每一个 class 相关联的 type_info 对象的指针通常也保存在 vtable 的第一个 slot 中。关于 type_info 是什么，可以自己查。</p>\n<h3 id=\"引入继承后的对象模型成本\"><a href=\"#引入继承后的对象模型成本\" class=\"headerlink\" title=\"引入继承后的对象模型成本\"></a>引入继承后的对象模型成本</h3><ul>\n<li>如果是普通继承，父对象被直接包含在子对象里面，这样父对象的存取也是直接进行的，没有额外的指针成本。</li>\n<li>如果是虚拟继承，父对象由一个指针指出来，这样父对象的存取就必须由指针访问，添加了一层间接性。</li>\n</ul>\n<p>virtual base class，用以实现 “多次出现在继承体系中的base class，有一个单一而被共享的实例”</p>\n<p><img src=\"https://wx3.sinaimg.cn/mw690/006zFO3gly1fknlhzg45wj30bs0asq3w.jpg\" alt=\"虚基类\"></p>\n<p><img src=\"https://wx1.sinaimg.cn/mw690/006zFO3gly1fknli0837fj317w0mmhao.jpg\" alt=\"虚拟多重继承\"></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> &#123;</span> <span class=\"keyword\">public</span>: <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Foo</span><span class=\"params\">()</span> </span>&#123;&#125; &#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> :</span> <span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> A &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">C</span> :</span> <span class=\"keyword\">public</span> <span class=\"keyword\">virtual</span> A &#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">D</span> :</span> <span class=\"keyword\">public</span> B, <span class=\"keyword\">public</span> C &#123;&#125;;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>我觉得这里有个问题，class D继承class B和class C的时候并不是虚继承，所以何不将B和C直接放在D中呢？这样就省了两次指针。</p>\n</blockquote>\n<h2 id=\"struct-和-class-关键字的区别\"><a href=\"#struct-和-class-关键字的区别\" class=\"headerlink\" title=\"struct 和 class 关键字的区别\"></a>struct 和 class 关键字的区别</h2><p>总共就两个区别：</p>\n<ul>\n<li>struct defaults to public access and class defaults to private access.</li>\n<li>When inheriting, struct defaults to public inheritance and class defaults to private inheritance. (Ironically, as with so many things in C++, the default is backwards: public inheritance is by far the more common choice, but people rarely declare structs just to save on typing the “public” keyword). 哈哈，我觉得这么做的目的无非就是提醒你注意封装，不要给外部暴露没必要的东西，所以才把默认搞成private。</li>\n</ul>\n<p>除此之外 struct 和 class 一样。</p>\n<p>struct 用来表现那些只有数据的集合体 POD(Plain Old Data)、而 class则希望表达的是<code>ADT(abstract data type)</code>的思想。</p>\n<blockquote>\n<p>POD stands for Plain Old Data - that is, a class (whether defined with the keyword struct or the keyword class) without constructors, destructors and virtual members functions.</p>\n</blockquote>\n<p>由于这2个关键字在本质上无区别，所以class并没有必须要引入，但是引入它的确非常令人满意，因为这个语言所引入的不止是这个关键字，还有它所支持的封装和继承的哲学。可以这样想象:struct只剩下方便C程序员迁徙到C++的用途了。</p>\n<h2 id=\"programming-paradigms\"><a href=\"#programming-paradigms\" class=\"headerlink\" title=\"programming paradigms\"></a>programming paradigms</h2><p>C++支持三种形式的编程风格(或称典范 paradigm):</p>\n<ul>\n<li>面向过程的风格（procedural model）:就像C一样，一条语句接一条语句的执行或者函数跳转;</li>\n<li>抽象数据类型模型(abstract data type model，ADT):仅仅使用了class的封装，很多人都是 在用基于对象的风格却误以为自己在使用面向对象的风格;</li>\n<li>面向对象的风格(object-oriented):使用了class的封装和多态的编程思维(多态才是 真正的面向对象的特征)。</li>\n</ul>\n<p>纯粹以一种paradigm写程序，有助于整体行为的良好稳固。</p>\n<blockquote>\n<p>一个 reference 通常是以一个指针来实现的，所以 point 和 reference 并没有本质的区别，reference 和 const 指针的区别就是，你取 reference 指针的地址的时候，取到的是数据的地址，const 指针取地址取到的是指针的地址。</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> a=<span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> &amp;b=a;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *p = &amp;a;</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; &amp;b &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; p &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; &amp;p &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>也就是说你取不到 b 的地址。所以说引用相当于一个 <code>别名</code>。引用常用在函数调用里，可以直接操作原有对象，这样就可以不用写指针的指针这种绕弯的东西了。</p>\n<blockquote>\n<p>函数的实参传递给形参是值传递，也就是一个 copy，形参在函数里将是一个局部变量。这个特性是许多新手面临的大坑。一道经典的考察题目便是，实现一个 C 语言的 swap 函数，由于 C 语言没有引用，你就只能用指针来操作原有对象了。</p>\n</blockquote>\n<h2 id=\"指针的类型\"><a href=\"#指针的类型\" class=\"headerlink\" title=\"指针的类型\"></a>指针的类型</h2><ul>\n<li>对于内存来说，不同类型的指针并没有什么不同。它们都是占用一个word的大小（所以word的大小决定了内存可访问空间的大小，32位系统是4字节，64位系统是8字节），包含一个数字，这个数字代表内存中的一个地址;</li>\n<li>指针的类型是编译器的概念，对于硬件来说，并没有什么指针类型的概念;</li>\n<li>转型操作也只是一种编译器的指令，它改变的是编译器对被指内存的解释方式而已!</li>\n<li>void*指针只能够持有一个地址（一个字节），而不能通过它操作所指向的object</li>\n</ul>\n"},{"layout":"post","title":"Inside the C++ Object Model 系列笔记 二 -- The Semantics of constructors","date":"2017-10-18T16:00:00.000Z","comments":1,"_content":"\n这一章详细的讨论了 constructor 如何工作，讨论构造一个对象的过程以及构造一个对象给程序带来的影响。\n\n## 区分trivial和notrivial\n\n1. 只有编译器需要的时候(为什么会需要?后面讲的很清楚)，合成操作才是nontrivial的， 这样的函数才会被真正的合成出来;\n2. 如果编译器不需要，而程序员又没有提供，这时的默认构造函数就是trivial的。虽然它在概念上存在，但是编译器实际上根本不会去合成出来，因为他不做任何没有意义的事情，所以当然可以忽略它不去合成。trivial 的函数只存在于概念上，实际上不存在这个函数。\n\n## default constructor\n\nA default constructor is a constructor which can be called with no arguments (either defined with an empty parameter list, or with default arguments provided for every parameter).\n\n### 通常很多C++程序员存在两种误解\n\n- 没有定义默认构造函数的类都会被编译器生成一个默认构造函数。\n- 编译器生成的默认构造函数会明确初始化类中每一个数据成员。\n\n**被声明：declared，被定义：defined**。声明代表分配内存空间，定义代表初始化，也就是分配具体的值。\n\n所以所有成员都在声明的时候被分配内存，构造函数的作用是初始化它们，non-object 成员需要程序员自己初始化，编译器不帮忙。\n\nC++中对于默认构造函数的解释是:\n**默认的构造函数会在需要的时候被编译器产生出来。**\n这里非常重要的一点是:\n谁需要?是程序的需要还是编译器的需要?如果是程序的需要，那是程序员的责任;\n只有在是编译器的需要时，默认构造函数才会被编译器产生出来，而且被产生出来的默认构造函数只会执行编译器所需要的行动，而且这个产生操作只有在默认构造函数真正被调用时才会进行合成。\n\n例如:成员变量初始化为 0 操作，这个操作就是程序的需要，而不是编译器的需要。\n\n总结变量的初始化:\n\nGlobal objects are guaranteed to have their associated memory “zeroed out” at program start-up. Local objects allocated on the program stack and heap objects allocated on the free-store do not have their associated memory zeroed out; rather, the memory retains the arbitrary bit pattern of its previous use.\n\n只有全局变量和静态变量才会保证初始化，其中静态变量可以视为全局变量的一种，因为静态变量也是保存在全局变量的存储空间上的。\nGolbal objects 的内存保证会在程序激活的时候被清 0；Local objects 配置于程序的堆栈中，Heap objects 配置于自由空间中，都不一定会被清为 0,它们的内容将是内存上次被使用后的痕迹!\n\n全局变量和静态变量都放在 global data Segment 上，且在类被声明的时候就已经分配内存和初始化，也就是 **在任何对象被定义之前静态变量就已经存在了（即使该 class 没有任何 object 实体，static data members也已经存在）。**\n\n```C++\nclass Foo { public: int val; Foo *pnext; };\nvoid foo_bar()\n{\n   // Oops:  program needs bar's members zeroed out\n   Foo bar;\n   if ( bar.val || bar.pnext )\n      // ... do something\n   // ...\n}\n```\n\nWhen is a default constructor synthesized, then? Only when the implementation needs it. Moreover, the synthesized constructor performs only those activities required by the implementation. That is, even if there were a need to synthesize a default constructor for class Foo, that constructor would not include code to zero out the two data members val and pnext. For the previous program fragment to execute correctly, the designer of class Foo needs to provide an explicit default constructor that properly initializes the class’s two members.\n\n意思是初始化 val 和 pnext 是程序员的责任，编译器不负责，所以你这里不初始化它们，它们存储的结果就是内存遗留的痕迹。\n\n### 什么时候编译器会给你生成默认构造函数\n\n首先你得没有写默认构造函数，编译器才会给你生成。有四类情况，编译器会给你加代码：\n\n1. 类中有一个对象（成员变量），这个对象包含了默认构造函数\n2. 继承自带有默认构造函数的基类的类\n3. 带有虚函数的类\n4. 继承自虚基类的类\n\n如果class A内含一个或以上的member objects，那么A的constructor必须调用每一个 member class 的默认构造函数。\n具体方法是:编译器会扩张 constructors（注意：是所有的构造函数，不仅仅是默认构造函数会被扩张），在其中安插代码使得在 user code 被调用之前先调 用 member objects 的默认构造函数(当然如果需要调用基类的默认构造函数，则放在基类的 默认构造函数调用之后:基类构造函数->成员构造函数->user code)。\nC++要求以“member objects 在 class 中的声明次序”来调用各个 construtors。这就是声明的次序决定了初始化次序(构造函数初始化列表一直要求以声明顺序来初始化)的根本原因!\n所以你打乱 member initialization list 的顺序根本没有用哦~\n\n理解了初始化列表中的实际执行顺序中“以 member 声明的次序”来决定的，就可以理解一些很 微妙的错误了。比如:\n\n```C++\nA() : i(99), j(66), value(foo()) {... }\nint i, value, j;\n```\n\n这会不会产生错误取决于成员函数 foo()是依赖于 i 还是 j:\n如果 foo 依赖于 i，由于 i 声明在 value 之前，所以不会产生错误;\n如果 foo 依赖于 j，由于 j 声明在 value 之后，就产生了使用未初始化成员的错误。\n\n带有virtual functions的类的默认构造函数毫无疑问是nontrivial的，需要编译器安插额外的\n成员 vptr 并在构造函数中正确的设置好 vptr，这是编译器的重要职责之一。\n继承自 virtual base class 的类的默认构造函数同样也毫无疑问的 nontrivial，编译器需要正确设置相关的信息以使得这些虚基类的信息能够在执行时准备妥当，这些设置取决于编译器实现虚基类的手法。\n\n编译器有4种情况会使得编译器真正的为class生成nontrivial的默认构造函数，这个 nontrivial 的默认构造函数只满足编译器的需要(调用 member objects 或 base class 的默认构造函数、初始化 virtual function 或 virutal base class 机制)。其它情况时，类在概念上拥有默认构造函数，但是实际上根本不会被产生出来(前面的区分 trivial 和 nontrivial)。\n\n对于一个trivial默认构造函数，编译器的态度是，既然它全无用处，干脆就不合成它。在这儿要厘清的是概念与实现的差别，概念上追求缜密完善，在实现上则追求效率，可以不要的东西就不要。\n\n## copy constructor\n\n有一个参数的类型是其类类型的构造函数是为拷贝构造函数。如下：\n\n```C++\nX::X( const X& x);\nY::Y( const Y& y, int =0 );\n//可以是多参数形式，但其第二个即后继参数都有一个默认值\n```\n\n### 什么时候编译器会给你生成拷贝构造函数\n\n>其实和前面默认构造函数一样，四种情况\n\n如果一个类没有定义拷贝构造函数，通常按照“成员逐一初始化(Default Memberwise Initialization)”的手法来解决“一个类对象以另一个同类实体作为初值”——也就是说把内建或派生的数据成员从某一个对象拷贝到另一个对象身上，如果数据成员是一个对象，则递归使用“成员逐一初始化(Default Memberwise Initialization)”的手法。\n\n成员逐一初始化(Default Memberwise Initialization)具体的实现方式则是位逐次拷贝（Bitwise copy semantics）\n\nCopy constructors和默认构造函数一样，只有在必须的时候才会被产生出来，对于大部分的class 来说，拷贝构造函数仅仅需要按位拷贝就可以。满足 bitwise copy semantics 的拷贝构造函数是 trivial 的，就不会真正被合成出来(与默认构造函数一样，只有 nontrivial 的拷贝构 造函数才会被真正合成出来)。对大多数类按位拷贝就够了，什么时候一个 class 不展现出 bitwise copy semantics 呢? 分为 4 种情况，前 2 种很明显，后 2 种是由于编译器必须保证正确设置虚机制而引起的。\n\n- 当class内含一个member object而后者声明了(也可能由于nontrivial语意从而编译器 真正合成出来的)一个 copy constructor 时;\n- 当class继承自一个存在有copy constructor的base class(同样也可能是合成)时;\n- 当class声明了一个或多个virtual functions时;(vf影响了位语意，进而影响效率)\n- 当class派生自一个继承串链，其中一个或多个virtual base classes时。\n\n对于前两种情况，不论是基类还是对象成员，既然后者声明有拷贝构造函数时，就表明其类的设计者或者编译器希望以其声明的拷贝构造函数来完成“一个类对象以另一个同类实体作为初值”的工作，而设计者或编译器这样做——声明拷贝构造函数，总有它们的理由，而通常最直接的原因莫过于因为他们想要做一些额外的工作或“位逐次拷贝”无法胜任。\n\n对于有虚函数的类，如果两个对象的类型相同那么位逐次拷贝其实是可以胜任的。但问题将出现在，如果基类由其继承类进行初始化时，此时若按照位逐次拷贝来完成这个工作，那么基类的vptr将指向其继承类的虚函数表，这将导致无法预料的后果——调用一个错误的虚函数实体是无法避免的，轻则带来程序崩溃，更糟糕的问题可能是这个错误被隐藏了。所以对于有虚函数的类编译器将会明确的使被初始化的对象的vptr指向正确的虚函数表。因此有虚函数的类没有声明拷贝构造函数，编译将为之合成一个，来完成上述工作，以及初始化各数据成员，声明有拷贝构造函数的话也会被插入完成上述工作的代码。\n\n```C++\n#include <iostream>\nusing namespace std;\n\nclass A {\npublic:\n  virtual void f() { cout << \"A::f()\" << endl; }\n  int i;\n};\n\nclass B : public A {\npublic:\n  void f(){ cout << \"B::f()\" << endl; }\n};\nint main(int argc, char const *argv[])\n{\n  B b;\n  b.i=1;\n  A a = b;\n  A *p = &a;\n  p->f();\n  cout << p->i << endl;\n  return 0;\n}\n```\n\n上面例子可以看出，如果 A a = b;是 bitwise copy semantics 的话，a 内放置的就是 b 的 vptr。但其实不是，编译器给 a 生成了拷贝构造函数，初始化了 a 的 vptr。b 的 vptr 是由编译器给 b 生成的默认构造函数初始化的。但对于其他成员变量 bitwise copy semantics依然有效，所以 i 的结果是1。我在做这个试验的时候发现了一个有趣的现象：\n\n```C++\n#include <iostream>\nusing namespace std;\n\nclass A {\npublic:\n  virtual void f() { cout << \"A::f()\" << endl; }\n  int i;\n};\n\nclass B : public A {\npublic:\n  void f(){ cout << \"B::f()\" << endl; }\n  int i;\n};\nint main(int argc, char const *argv[])\n{\n  B b;\n  b.i=1;\n  A a = b;\n  A *p = &a;\n  p->f();\n  cout << p->i << endl;\n  return 0;\n}\n```\n\n两个 i 不是同一个 i，b.i=1;优先给 b 中的同名变量赋值了。这样的代码简直可怕。那么怎么访问到从 A 继承来的成员变量 i 呢，请看：\n\n```C++\n#include <iostream>\nusing namespace std;\n\nclass A {\npublic:\n  virtual void f() { cout << \"A::f()\" << endl; }\n  int i;\n};\n\nclass B : public A {\npublic:\n  void f(){ cout << \"B::f()\" << endl; }\n  int i;\n};\nint main(int argc, char const *argv[])\n{\n  B b;\n  b.A::i=6;\n  b.B::i=1;\n  A a = b;\n  A *p = &a;\n  cout << p->i << endl;\n  return 0;\n}\n```\n\n## 命名返回值优化\n\n对于一个如foo()这样的函数，它的每一个返回分支都返回相同的对象，编译器有可能对其做Named return Value优化（下文都简称NRV优化），方法是以一个参数result取代返回对象。\n\nfoo()的原型：\n\n```C++\nX foo()\n{\n    X xx;\n    if(...)\n        return xx;\n    else\n        return xx;\n}\n```\n\n优化后的foo()以result取代xx：\n\n```C++\nvoid  foo(X &result)\n{\n    result.X::X();\n    if(...)\n    {\n        //直接处理result\n        return;\n    }\n    else\n    {\n        //直接处理result\n        return;\n    }\n}\n```\n\n对比优化前与优化后的代码可以看出，对于一句类似于X a = foo()这样的代码，NRV优化后的代码相较于原代码节省了一个临时对象的空间（省略了xx）,同时减少了两次函数调用（减少xx对象的默认构造函数和析构函数，以及一次拷贝构造函数的调用，增加了一次对a的默认构造函数的调用）。\n","source":"_posts/2017/2017-10-19-Inside-the-C++-Object-Model-系列笔记--The-Semantics-of-constructors.md","raw":"---\nlayout: post\ntitle: Inside the C++ Object Model 系列笔记 二 -- The Semantics of constructors\ndate: 2017-10-19\ncategories: [读书笔记, 《Inside the C++ Object Model》]\ntags: [C++]\ncomments: true\n---\n\n这一章详细的讨论了 constructor 如何工作，讨论构造一个对象的过程以及构造一个对象给程序带来的影响。\n\n## 区分trivial和notrivial\n\n1. 只有编译器需要的时候(为什么会需要?后面讲的很清楚)，合成操作才是nontrivial的， 这样的函数才会被真正的合成出来;\n2. 如果编译器不需要，而程序员又没有提供，这时的默认构造函数就是trivial的。虽然它在概念上存在，但是编译器实际上根本不会去合成出来，因为他不做任何没有意义的事情，所以当然可以忽略它不去合成。trivial 的函数只存在于概念上，实际上不存在这个函数。\n\n## default constructor\n\nA default constructor is a constructor which can be called with no arguments (either defined with an empty parameter list, or with default arguments provided for every parameter).\n\n### 通常很多C++程序员存在两种误解\n\n- 没有定义默认构造函数的类都会被编译器生成一个默认构造函数。\n- 编译器生成的默认构造函数会明确初始化类中每一个数据成员。\n\n**被声明：declared，被定义：defined**。声明代表分配内存空间，定义代表初始化，也就是分配具体的值。\n\n所以所有成员都在声明的时候被分配内存，构造函数的作用是初始化它们，non-object 成员需要程序员自己初始化，编译器不帮忙。\n\nC++中对于默认构造函数的解释是:\n**默认的构造函数会在需要的时候被编译器产生出来。**\n这里非常重要的一点是:\n谁需要?是程序的需要还是编译器的需要?如果是程序的需要，那是程序员的责任;\n只有在是编译器的需要时，默认构造函数才会被编译器产生出来，而且被产生出来的默认构造函数只会执行编译器所需要的行动，而且这个产生操作只有在默认构造函数真正被调用时才会进行合成。\n\n例如:成员变量初始化为 0 操作，这个操作就是程序的需要，而不是编译器的需要。\n\n总结变量的初始化:\n\nGlobal objects are guaranteed to have their associated memory “zeroed out” at program start-up. Local objects allocated on the program stack and heap objects allocated on the free-store do not have their associated memory zeroed out; rather, the memory retains the arbitrary bit pattern of its previous use.\n\n只有全局变量和静态变量才会保证初始化，其中静态变量可以视为全局变量的一种，因为静态变量也是保存在全局变量的存储空间上的。\nGolbal objects 的内存保证会在程序激活的时候被清 0；Local objects 配置于程序的堆栈中，Heap objects 配置于自由空间中，都不一定会被清为 0,它们的内容将是内存上次被使用后的痕迹!\n\n全局变量和静态变量都放在 global data Segment 上，且在类被声明的时候就已经分配内存和初始化，也就是 **在任何对象被定义之前静态变量就已经存在了（即使该 class 没有任何 object 实体，static data members也已经存在）。**\n\n```C++\nclass Foo { public: int val; Foo *pnext; };\nvoid foo_bar()\n{\n   // Oops:  program needs bar's members zeroed out\n   Foo bar;\n   if ( bar.val || bar.pnext )\n      // ... do something\n   // ...\n}\n```\n\nWhen is a default constructor synthesized, then? Only when the implementation needs it. Moreover, the synthesized constructor performs only those activities required by the implementation. That is, even if there were a need to synthesize a default constructor for class Foo, that constructor would not include code to zero out the two data members val and pnext. For the previous program fragment to execute correctly, the designer of class Foo needs to provide an explicit default constructor that properly initializes the class’s two members.\n\n意思是初始化 val 和 pnext 是程序员的责任，编译器不负责，所以你这里不初始化它们，它们存储的结果就是内存遗留的痕迹。\n\n### 什么时候编译器会给你生成默认构造函数\n\n首先你得没有写默认构造函数，编译器才会给你生成。有四类情况，编译器会给你加代码：\n\n1. 类中有一个对象（成员变量），这个对象包含了默认构造函数\n2. 继承自带有默认构造函数的基类的类\n3. 带有虚函数的类\n4. 继承自虚基类的类\n\n如果class A内含一个或以上的member objects，那么A的constructor必须调用每一个 member class 的默认构造函数。\n具体方法是:编译器会扩张 constructors（注意：是所有的构造函数，不仅仅是默认构造函数会被扩张），在其中安插代码使得在 user code 被调用之前先调 用 member objects 的默认构造函数(当然如果需要调用基类的默认构造函数，则放在基类的 默认构造函数调用之后:基类构造函数->成员构造函数->user code)。\nC++要求以“member objects 在 class 中的声明次序”来调用各个 construtors。这就是声明的次序决定了初始化次序(构造函数初始化列表一直要求以声明顺序来初始化)的根本原因!\n所以你打乱 member initialization list 的顺序根本没有用哦~\n\n理解了初始化列表中的实际执行顺序中“以 member 声明的次序”来决定的，就可以理解一些很 微妙的错误了。比如:\n\n```C++\nA() : i(99), j(66), value(foo()) {... }\nint i, value, j;\n```\n\n这会不会产生错误取决于成员函数 foo()是依赖于 i 还是 j:\n如果 foo 依赖于 i，由于 i 声明在 value 之前，所以不会产生错误;\n如果 foo 依赖于 j，由于 j 声明在 value 之后，就产生了使用未初始化成员的错误。\n\n带有virtual functions的类的默认构造函数毫无疑问是nontrivial的，需要编译器安插额外的\n成员 vptr 并在构造函数中正确的设置好 vptr，这是编译器的重要职责之一。\n继承自 virtual base class 的类的默认构造函数同样也毫无疑问的 nontrivial，编译器需要正确设置相关的信息以使得这些虚基类的信息能够在执行时准备妥当，这些设置取决于编译器实现虚基类的手法。\n\n编译器有4种情况会使得编译器真正的为class生成nontrivial的默认构造函数，这个 nontrivial 的默认构造函数只满足编译器的需要(调用 member objects 或 base class 的默认构造函数、初始化 virtual function 或 virutal base class 机制)。其它情况时，类在概念上拥有默认构造函数，但是实际上根本不会被产生出来(前面的区分 trivial 和 nontrivial)。\n\n对于一个trivial默认构造函数，编译器的态度是，既然它全无用处，干脆就不合成它。在这儿要厘清的是概念与实现的差别，概念上追求缜密完善，在实现上则追求效率，可以不要的东西就不要。\n\n## copy constructor\n\n有一个参数的类型是其类类型的构造函数是为拷贝构造函数。如下：\n\n```C++\nX::X( const X& x);\nY::Y( const Y& y, int =0 );\n//可以是多参数形式，但其第二个即后继参数都有一个默认值\n```\n\n### 什么时候编译器会给你生成拷贝构造函数\n\n>其实和前面默认构造函数一样，四种情况\n\n如果一个类没有定义拷贝构造函数，通常按照“成员逐一初始化(Default Memberwise Initialization)”的手法来解决“一个类对象以另一个同类实体作为初值”——也就是说把内建或派生的数据成员从某一个对象拷贝到另一个对象身上，如果数据成员是一个对象，则递归使用“成员逐一初始化(Default Memberwise Initialization)”的手法。\n\n成员逐一初始化(Default Memberwise Initialization)具体的实现方式则是位逐次拷贝（Bitwise copy semantics）\n\nCopy constructors和默认构造函数一样，只有在必须的时候才会被产生出来，对于大部分的class 来说，拷贝构造函数仅仅需要按位拷贝就可以。满足 bitwise copy semantics 的拷贝构造函数是 trivial 的，就不会真正被合成出来(与默认构造函数一样，只有 nontrivial 的拷贝构 造函数才会被真正合成出来)。对大多数类按位拷贝就够了，什么时候一个 class 不展现出 bitwise copy semantics 呢? 分为 4 种情况，前 2 种很明显，后 2 种是由于编译器必须保证正确设置虚机制而引起的。\n\n- 当class内含一个member object而后者声明了(也可能由于nontrivial语意从而编译器 真正合成出来的)一个 copy constructor 时;\n- 当class继承自一个存在有copy constructor的base class(同样也可能是合成)时;\n- 当class声明了一个或多个virtual functions时;(vf影响了位语意，进而影响效率)\n- 当class派生自一个继承串链，其中一个或多个virtual base classes时。\n\n对于前两种情况，不论是基类还是对象成员，既然后者声明有拷贝构造函数时，就表明其类的设计者或者编译器希望以其声明的拷贝构造函数来完成“一个类对象以另一个同类实体作为初值”的工作，而设计者或编译器这样做——声明拷贝构造函数，总有它们的理由，而通常最直接的原因莫过于因为他们想要做一些额外的工作或“位逐次拷贝”无法胜任。\n\n对于有虚函数的类，如果两个对象的类型相同那么位逐次拷贝其实是可以胜任的。但问题将出现在，如果基类由其继承类进行初始化时，此时若按照位逐次拷贝来完成这个工作，那么基类的vptr将指向其继承类的虚函数表，这将导致无法预料的后果——调用一个错误的虚函数实体是无法避免的，轻则带来程序崩溃，更糟糕的问题可能是这个错误被隐藏了。所以对于有虚函数的类编译器将会明确的使被初始化的对象的vptr指向正确的虚函数表。因此有虚函数的类没有声明拷贝构造函数，编译将为之合成一个，来完成上述工作，以及初始化各数据成员，声明有拷贝构造函数的话也会被插入完成上述工作的代码。\n\n```C++\n#include <iostream>\nusing namespace std;\n\nclass A {\npublic:\n  virtual void f() { cout << \"A::f()\" << endl; }\n  int i;\n};\n\nclass B : public A {\npublic:\n  void f(){ cout << \"B::f()\" << endl; }\n};\nint main(int argc, char const *argv[])\n{\n  B b;\n  b.i=1;\n  A a = b;\n  A *p = &a;\n  p->f();\n  cout << p->i << endl;\n  return 0;\n}\n```\n\n上面例子可以看出，如果 A a = b;是 bitwise copy semantics 的话，a 内放置的就是 b 的 vptr。但其实不是，编译器给 a 生成了拷贝构造函数，初始化了 a 的 vptr。b 的 vptr 是由编译器给 b 生成的默认构造函数初始化的。但对于其他成员变量 bitwise copy semantics依然有效，所以 i 的结果是1。我在做这个试验的时候发现了一个有趣的现象：\n\n```C++\n#include <iostream>\nusing namespace std;\n\nclass A {\npublic:\n  virtual void f() { cout << \"A::f()\" << endl; }\n  int i;\n};\n\nclass B : public A {\npublic:\n  void f(){ cout << \"B::f()\" << endl; }\n  int i;\n};\nint main(int argc, char const *argv[])\n{\n  B b;\n  b.i=1;\n  A a = b;\n  A *p = &a;\n  p->f();\n  cout << p->i << endl;\n  return 0;\n}\n```\n\n两个 i 不是同一个 i，b.i=1;优先给 b 中的同名变量赋值了。这样的代码简直可怕。那么怎么访问到从 A 继承来的成员变量 i 呢，请看：\n\n```C++\n#include <iostream>\nusing namespace std;\n\nclass A {\npublic:\n  virtual void f() { cout << \"A::f()\" << endl; }\n  int i;\n};\n\nclass B : public A {\npublic:\n  void f(){ cout << \"B::f()\" << endl; }\n  int i;\n};\nint main(int argc, char const *argv[])\n{\n  B b;\n  b.A::i=6;\n  b.B::i=1;\n  A a = b;\n  A *p = &a;\n  cout << p->i << endl;\n  return 0;\n}\n```\n\n## 命名返回值优化\n\n对于一个如foo()这样的函数，它的每一个返回分支都返回相同的对象，编译器有可能对其做Named return Value优化（下文都简称NRV优化），方法是以一个参数result取代返回对象。\n\nfoo()的原型：\n\n```C++\nX foo()\n{\n    X xx;\n    if(...)\n        return xx;\n    else\n        return xx;\n}\n```\n\n优化后的foo()以result取代xx：\n\n```C++\nvoid  foo(X &result)\n{\n    result.X::X();\n    if(...)\n    {\n        //直接处理result\n        return;\n    }\n    else\n    {\n        //直接处理result\n        return;\n    }\n}\n```\n\n对比优化前与优化后的代码可以看出，对于一句类似于X a = foo()这样的代码，NRV优化后的代码相较于原代码节省了一个临时对象的空间（省略了xx）,同时减少了两次函数调用（减少xx对象的默认构造函数和析构函数，以及一次拷贝构造函数的调用，增加了一次对a的默认构造函数的调用）。\n","slug":"Inside-the-C++-Object-Model-系列笔记--The-Semantics-of-constructors","published":1,"updated":"2018-06-10T12:03:07.219Z","photos":[],"link":"","_id":"cjm2w8dcy0019fgpx9onep9pk","content":"<p>这一章详细的讨论了 constructor 如何工作，讨论构造一个对象的过程以及构造一个对象给程序带来的影响。</p>\n<h2 id=\"区分trivial和notrivial\"><a href=\"#区分trivial和notrivial\" class=\"headerlink\" title=\"区分trivial和notrivial\"></a>区分trivial和notrivial</h2><ol>\n<li>只有编译器需要的时候(为什么会需要?后面讲的很清楚)，合成操作才是nontrivial的， 这样的函数才会被真正的合成出来;</li>\n<li>如果编译器不需要，而程序员又没有提供，这时的默认构造函数就是trivial的。虽然它在概念上存在，但是编译器实际上根本不会去合成出来，因为他不做任何没有意义的事情，所以当然可以忽略它不去合成。trivial 的函数只存在于概念上，实际上不存在这个函数。</li>\n</ol>\n<h2 id=\"default-constructor\"><a href=\"#default-constructor\" class=\"headerlink\" title=\"default constructor\"></a>default constructor</h2><p>A default constructor is a constructor which can be called with no arguments (either defined with an empty parameter list, or with default arguments provided for every parameter).</p>\n<h3 id=\"通常很多C-程序员存在两种误解\"><a href=\"#通常很多C-程序员存在两种误解\" class=\"headerlink\" title=\"通常很多C++程序员存在两种误解\"></a>通常很多C++程序员存在两种误解</h3><ul>\n<li>没有定义默认构造函数的类都会被编译器生成一个默认构造函数。</li>\n<li>编译器生成的默认构造函数会明确初始化类中每一个数据成员。</li>\n</ul>\n<p><strong>被声明：declared，被定义：defined</strong>。声明代表分配内存空间，定义代表初始化，也就是分配具体的值。</p>\n<p>所以所有成员都在声明的时候被分配内存，构造函数的作用是初始化它们，non-object 成员需要程序员自己初始化，编译器不帮忙。</p>\n<p>C++中对于默认构造函数的解释是:<br><strong>默认的构造函数会在需要的时候被编译器产生出来。</strong><br>这里非常重要的一点是:<br>谁需要?是程序的需要还是编译器的需要?如果是程序的需要，那是程序员的责任;<br>只有在是编译器的需要时，默认构造函数才会被编译器产生出来，而且被产生出来的默认构造函数只会执行编译器所需要的行动，而且这个产生操作只有在默认构造函数真正被调用时才会进行合成。</p>\n<p>例如:成员变量初始化为 0 操作，这个操作就是程序的需要，而不是编译器的需要。</p>\n<p>总结变量的初始化:</p>\n<p>Global objects are guaranteed to have their associated memory “zeroed out” at program start-up. Local objects allocated on the program stack and heap objects allocated on the free-store do not have their associated memory zeroed out; rather, the memory retains the arbitrary bit pattern of its previous use.</p>\n<p>只有全局变量和静态变量才会保证初始化，其中静态变量可以视为全局变量的一种，因为静态变量也是保存在全局变量的存储空间上的。<br>Golbal objects 的内存保证会在程序激活的时候被清 0；Local objects 配置于程序的堆栈中，Heap objects 配置于自由空间中，都不一定会被清为 0,它们的内容将是内存上次被使用后的痕迹!</p>\n<p>全局变量和静态变量都放在 global data Segment 上，且在类被声明的时候就已经分配内存和初始化，也就是 <strong>在任何对象被定义之前静态变量就已经存在了（即使该 class 没有任何 object 实体，static data members也已经存在）。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> &#123;</span> <span class=\"keyword\">public</span>: <span class=\"keyword\">int</span> val; Foo *pnext; &#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo_bar</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// Oops:  program needs bar's members zeroed out</span></span><br><span class=\"line\">   Foo bar;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> ( bar.val || bar.pnext )</span><br><span class=\"line\">      <span class=\"comment\">// ... do something</span></span><br><span class=\"line\">   <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>When is a default constructor synthesized, then? Only when the implementation needs it. Moreover, the synthesized constructor performs only those activities required by the implementation. That is, even if there were a need to synthesize a default constructor for class Foo, that constructor would not include code to zero out the two data members val and pnext. For the previous program fragment to execute correctly, the designer of class Foo needs to provide an explicit default constructor that properly initializes the class’s two members.</p>\n<p>意思是初始化 val 和 pnext 是程序员的责任，编译器不负责，所以你这里不初始化它们，它们存储的结果就是内存遗留的痕迹。</p>\n<h3 id=\"什么时候编译器会给你生成默认构造函数\"><a href=\"#什么时候编译器会给你生成默认构造函数\" class=\"headerlink\" title=\"什么时候编译器会给你生成默认构造函数\"></a>什么时候编译器会给你生成默认构造函数</h3><p>首先你得没有写默认构造函数，编译器才会给你生成。有四类情况，编译器会给你加代码：</p>\n<ol>\n<li>类中有一个对象（成员变量），这个对象包含了默认构造函数</li>\n<li>继承自带有默认构造函数的基类的类</li>\n<li>带有虚函数的类</li>\n<li>继承自虚基类的类</li>\n</ol>\n<p>如果class A内含一个或以上的member objects，那么A的constructor必须调用每一个 member class 的默认构造函数。<br>具体方法是:编译器会扩张 constructors（注意：是所有的构造函数，不仅仅是默认构造函数会被扩张），在其中安插代码使得在 user code 被调用之前先调 用 member objects 的默认构造函数(当然如果需要调用基类的默认构造函数，则放在基类的 默认构造函数调用之后:基类构造函数-&gt;成员构造函数-&gt;user code)。<br>C++要求以“member objects 在 class 中的声明次序”来调用各个 construtors。这就是声明的次序决定了初始化次序(构造函数初始化列表一直要求以声明顺序来初始化)的根本原因!<br>所以你打乱 member initialization list 的顺序根本没有用哦~</p>\n<p>理解了初始化列表中的实际执行顺序中“以 member 声明的次序”来决定的，就可以理解一些很 微妙的错误了。比如:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A() : i(<span class=\"number\">99</span>), j(<span class=\"number\">66</span>), value(foo()) &#123;... &#125;</span><br><span class=\"line\"><span class=\"keyword\">int</span> i, value, j;</span><br></pre></td></tr></table></figure>\n<p>这会不会产生错误取决于成员函数 foo()是依赖于 i 还是 j:<br>如果 foo 依赖于 i，由于 i 声明在 value 之前，所以不会产生错误;<br>如果 foo 依赖于 j，由于 j 声明在 value 之后，就产生了使用未初始化成员的错误。</p>\n<p>带有virtual functions的类的默认构造函数毫无疑问是nontrivial的，需要编译器安插额外的<br>成员 vptr 并在构造函数中正确的设置好 vptr，这是编译器的重要职责之一。<br>继承自 virtual base class 的类的默认构造函数同样也毫无疑问的 nontrivial，编译器需要正确设置相关的信息以使得这些虚基类的信息能够在执行时准备妥当，这些设置取决于编译器实现虚基类的手法。</p>\n<p>编译器有4种情况会使得编译器真正的为class生成nontrivial的默认构造函数，这个 nontrivial 的默认构造函数只满足编译器的需要(调用 member objects 或 base class 的默认构造函数、初始化 virtual function 或 virutal base class 机制)。其它情况时，类在概念上拥有默认构造函数，但是实际上根本不会被产生出来(前面的区分 trivial 和 nontrivial)。</p>\n<p>对于一个trivial默认构造函数，编译器的态度是，既然它全无用处，干脆就不合成它。在这儿要厘清的是概念与实现的差别，概念上追求缜密完善，在实现上则追求效率，可以不要的东西就不要。</p>\n<h2 id=\"copy-constructor\"><a href=\"#copy-constructor\" class=\"headerlink\" title=\"copy constructor\"></a>copy constructor</h2><p>有一个参数的类型是其类类型的构造函数是为拷贝构造函数。如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">X::X( <span class=\"keyword\">const</span> X&amp; x);</span><br><span class=\"line\">Y::Y( <span class=\"keyword\">const</span> Y&amp; y, <span class=\"keyword\">int</span> =<span class=\"number\">0</span> );</span><br><span class=\"line\"><span class=\"comment\">//可以是多参数形式，但其第二个即后继参数都有一个默认值</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"什么时候编译器会给你生成拷贝构造函数\"><a href=\"#什么时候编译器会给你生成拷贝构造函数\" class=\"headerlink\" title=\"什么时候编译器会给你生成拷贝构造函数\"></a>什么时候编译器会给你生成拷贝构造函数</h3><blockquote>\n<p>其实和前面默认构造函数一样，四种情况</p>\n</blockquote>\n<p>如果一个类没有定义拷贝构造函数，通常按照“成员逐一初始化(Default Memberwise Initialization)”的手法来解决“一个类对象以另一个同类实体作为初值”——也就是说把内建或派生的数据成员从某一个对象拷贝到另一个对象身上，如果数据成员是一个对象，则递归使用“成员逐一初始化(Default Memberwise Initialization)”的手法。</p>\n<p>成员逐一初始化(Default Memberwise Initialization)具体的实现方式则是位逐次拷贝（Bitwise copy semantics）</p>\n<p>Copy constructors和默认构造函数一样，只有在必须的时候才会被产生出来，对于大部分的class 来说，拷贝构造函数仅仅需要按位拷贝就可以。满足 bitwise copy semantics 的拷贝构造函数是 trivial 的，就不会真正被合成出来(与默认构造函数一样，只有 nontrivial 的拷贝构 造函数才会被真正合成出来)。对大多数类按位拷贝就够了，什么时候一个 class 不展现出 bitwise copy semantics 呢? 分为 4 种情况，前 2 种很明显，后 2 种是由于编译器必须保证正确设置虚机制而引起的。</p>\n<ul>\n<li>当class内含一个member object而后者声明了(也可能由于nontrivial语意从而编译器 真正合成出来的)一个 copy constructor 时;</li>\n<li>当class继承自一个存在有copy constructor的base class(同样也可能是合成)时;</li>\n<li>当class声明了一个或多个virtual functions时;(vf影响了位语意，进而影响效率)</li>\n<li>当class派生自一个继承串链，其中一个或多个virtual base classes时。</li>\n</ul>\n<p>对于前两种情况，不论是基类还是对象成员，既然后者声明有拷贝构造函数时，就表明其类的设计者或者编译器希望以其声明的拷贝构造函数来完成“一个类对象以另一个同类实体作为初值”的工作，而设计者或编译器这样做——声明拷贝构造函数，总有它们的理由，而通常最直接的原因莫过于因为他们想要做一些额外的工作或“位逐次拷贝”无法胜任。</p>\n<p>对于有虚函数的类，如果两个对象的类型相同那么位逐次拷贝其实是可以胜任的。但问题将出现在，如果基类由其继承类进行初始化时，此时若按照位逐次拷贝来完成这个工作，那么基类的vptr将指向其继承类的虚函数表，这将导致无法预料的后果——调用一个错误的虚函数实体是无法避免的，轻则带来程序崩溃，更糟糕的问题可能是这个错误被隐藏了。所以对于有虚函数的类编译器将会明确的使被初始化的对象的vptr指向正确的虚函数表。因此有虚函数的类没有声明拷贝构造函数，编译将为之合成一个，来完成上述工作，以及初始化各数据成员，声明有拷贝构造函数的话也会被插入完成上述工作的代码。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123; <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"A::f()\"</span> &lt;&lt; <span class=\"built_in\">endl</span>; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> :</span> <span class=\"keyword\">public</span> A &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span></span>&#123; <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"B::f()\"</span> &lt;&lt; <span class=\"built_in\">endl</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  B b;</span><br><span class=\"line\">  b.i=<span class=\"number\">1</span>;</span><br><span class=\"line\">  A a = b;</span><br><span class=\"line\">  A *p = &amp;a;</span><br><span class=\"line\">  p-&gt;f();</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; p-&gt;i &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面例子可以看出，如果 A a = b;是 bitwise copy semantics 的话，a 内放置的就是 b 的 vptr。但其实不是，编译器给 a 生成了拷贝构造函数，初始化了 a 的 vptr。b 的 vptr 是由编译器给 b 生成的默认构造函数初始化的。但对于其他成员变量 bitwise copy semantics依然有效，所以 i 的结果是1。我在做这个试验的时候发现了一个有趣的现象：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123; <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"A::f()\"</span> &lt;&lt; <span class=\"built_in\">endl</span>; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> :</span> <span class=\"keyword\">public</span> A &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span></span>&#123; <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"B::f()\"</span> &lt;&lt; <span class=\"built_in\">endl</span>; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  B b;</span><br><span class=\"line\">  b.i=<span class=\"number\">1</span>;</span><br><span class=\"line\">  A a = b;</span><br><span class=\"line\">  A *p = &amp;a;</span><br><span class=\"line\">  p-&gt;f();</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; p-&gt;i &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>两个 i 不是同一个 i，b.i=1;优先给 b 中的同名变量赋值了。这样的代码简直可怕。那么怎么访问到从 A 继承来的成员变量 i 呢，请看：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123; <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"A::f()\"</span> &lt;&lt; <span class=\"built_in\">endl</span>; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> :</span> <span class=\"keyword\">public</span> A &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span></span>&#123; <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"B::f()\"</span> &lt;&lt; <span class=\"built_in\">endl</span>; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  B b;</span><br><span class=\"line\">  b.A::i=<span class=\"number\">6</span>;</span><br><span class=\"line\">  b.B::i=<span class=\"number\">1</span>;</span><br><span class=\"line\">  A a = b;</span><br><span class=\"line\">  A *p = &amp;a;</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; p-&gt;i &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"命名返回值优化\"><a href=\"#命名返回值优化\" class=\"headerlink\" title=\"命名返回值优化\"></a>命名返回值优化</h2><p>对于一个如foo()这样的函数，它的每一个返回分支都返回相同的对象，编译器有可能对其做Named return Value优化（下文都简称NRV优化），方法是以一个参数result取代返回对象。</p>\n<p>foo()的原型：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">X <span class=\"title\">foo</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    X xx;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(...)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> xx;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> xx;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>优化后的foo()以result取代xx：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span>  <span class=\"title\">foo</span><span class=\"params\">(X &amp;result)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    result.X::X();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(...)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//直接处理result</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//直接处理result</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对比优化前与优化后的代码可以看出，对于一句类似于X a = foo()这样的代码，NRV优化后的代码相较于原代码节省了一个临时对象的空间（省略了xx）,同时减少了两次函数调用（减少xx对象的默认构造函数和析构函数，以及一次拷贝构造函数的调用，增加了一次对a的默认构造函数的调用）。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这一章详细的讨论了 constructor 如何工作，讨论构造一个对象的过程以及构造一个对象给程序带来的影响。</p>\n<h2 id=\"区分trivial和notrivial\"><a href=\"#区分trivial和notrivial\" class=\"headerlink\" title=\"区分trivial和notrivial\"></a>区分trivial和notrivial</h2><ol>\n<li>只有编译器需要的时候(为什么会需要?后面讲的很清楚)，合成操作才是nontrivial的， 这样的函数才会被真正的合成出来;</li>\n<li>如果编译器不需要，而程序员又没有提供，这时的默认构造函数就是trivial的。虽然它在概念上存在，但是编译器实际上根本不会去合成出来，因为他不做任何没有意义的事情，所以当然可以忽略它不去合成。trivial 的函数只存在于概念上，实际上不存在这个函数。</li>\n</ol>\n<h2 id=\"default-constructor\"><a href=\"#default-constructor\" class=\"headerlink\" title=\"default constructor\"></a>default constructor</h2><p>A default constructor is a constructor which can be called with no arguments (either defined with an empty parameter list, or with default arguments provided for every parameter).</p>\n<h3 id=\"通常很多C-程序员存在两种误解\"><a href=\"#通常很多C-程序员存在两种误解\" class=\"headerlink\" title=\"通常很多C++程序员存在两种误解\"></a>通常很多C++程序员存在两种误解</h3><ul>\n<li>没有定义默认构造函数的类都会被编译器生成一个默认构造函数。</li>\n<li>编译器生成的默认构造函数会明确初始化类中每一个数据成员。</li>\n</ul>\n<p><strong>被声明：declared，被定义：defined</strong>。声明代表分配内存空间，定义代表初始化，也就是分配具体的值。</p>\n<p>所以所有成员都在声明的时候被分配内存，构造函数的作用是初始化它们，non-object 成员需要程序员自己初始化，编译器不帮忙。</p>\n<p>C++中对于默认构造函数的解释是:<br><strong>默认的构造函数会在需要的时候被编译器产生出来。</strong><br>这里非常重要的一点是:<br>谁需要?是程序的需要还是编译器的需要?如果是程序的需要，那是程序员的责任;<br>只有在是编译器的需要时，默认构造函数才会被编译器产生出来，而且被产生出来的默认构造函数只会执行编译器所需要的行动，而且这个产生操作只有在默认构造函数真正被调用时才会进行合成。</p>\n<p>例如:成员变量初始化为 0 操作，这个操作就是程序的需要，而不是编译器的需要。</p>\n<p>总结变量的初始化:</p>\n<p>Global objects are guaranteed to have their associated memory “zeroed out” at program start-up. Local objects allocated on the program stack and heap objects allocated on the free-store do not have their associated memory zeroed out; rather, the memory retains the arbitrary bit pattern of its previous use.</p>\n<p>只有全局变量和静态变量才会保证初始化，其中静态变量可以视为全局变量的一种，因为静态变量也是保存在全局变量的存储空间上的。<br>Golbal objects 的内存保证会在程序激活的时候被清 0；Local objects 配置于程序的堆栈中，Heap objects 配置于自由空间中，都不一定会被清为 0,它们的内容将是内存上次被使用后的痕迹!</p>\n<p>全局变量和静态变量都放在 global data Segment 上，且在类被声明的时候就已经分配内存和初始化，也就是 <strong>在任何对象被定义之前静态变量就已经存在了（即使该 class 没有任何 object 实体，static data members也已经存在）。</strong></p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Foo</span> &#123;</span> <span class=\"keyword\">public</span>: <span class=\"keyword\">int</span> val; Foo *pnext; &#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">foo_bar</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   <span class=\"comment\">// Oops:  program needs bar's members zeroed out</span></span><br><span class=\"line\">   Foo bar;</span><br><span class=\"line\">   <span class=\"keyword\">if</span> ( bar.val || bar.pnext )</span><br><span class=\"line\">      <span class=\"comment\">// ... do something</span></span><br><span class=\"line\">   <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>When is a default constructor synthesized, then? Only when the implementation needs it. Moreover, the synthesized constructor performs only those activities required by the implementation. That is, even if there were a need to synthesize a default constructor for class Foo, that constructor would not include code to zero out the two data members val and pnext. For the previous program fragment to execute correctly, the designer of class Foo needs to provide an explicit default constructor that properly initializes the class’s two members.</p>\n<p>意思是初始化 val 和 pnext 是程序员的责任，编译器不负责，所以你这里不初始化它们，它们存储的结果就是内存遗留的痕迹。</p>\n<h3 id=\"什么时候编译器会给你生成默认构造函数\"><a href=\"#什么时候编译器会给你生成默认构造函数\" class=\"headerlink\" title=\"什么时候编译器会给你生成默认构造函数\"></a>什么时候编译器会给你生成默认构造函数</h3><p>首先你得没有写默认构造函数，编译器才会给你生成。有四类情况，编译器会给你加代码：</p>\n<ol>\n<li>类中有一个对象（成员变量），这个对象包含了默认构造函数</li>\n<li>继承自带有默认构造函数的基类的类</li>\n<li>带有虚函数的类</li>\n<li>继承自虚基类的类</li>\n</ol>\n<p>如果class A内含一个或以上的member objects，那么A的constructor必须调用每一个 member class 的默认构造函数。<br>具体方法是:编译器会扩张 constructors（注意：是所有的构造函数，不仅仅是默认构造函数会被扩张），在其中安插代码使得在 user code 被调用之前先调 用 member objects 的默认构造函数(当然如果需要调用基类的默认构造函数，则放在基类的 默认构造函数调用之后:基类构造函数-&gt;成员构造函数-&gt;user code)。<br>C++要求以“member objects 在 class 中的声明次序”来调用各个 construtors。这就是声明的次序决定了初始化次序(构造函数初始化列表一直要求以声明顺序来初始化)的根本原因!<br>所以你打乱 member initialization list 的顺序根本没有用哦~</p>\n<p>理解了初始化列表中的实际执行顺序中“以 member 声明的次序”来决定的，就可以理解一些很 微妙的错误了。比如:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A() : i(<span class=\"number\">99</span>), j(<span class=\"number\">66</span>), value(foo()) &#123;... &#125;</span><br><span class=\"line\"><span class=\"keyword\">int</span> i, value, j;</span><br></pre></td></tr></table></figure>\n<p>这会不会产生错误取决于成员函数 foo()是依赖于 i 还是 j:<br>如果 foo 依赖于 i，由于 i 声明在 value 之前，所以不会产生错误;<br>如果 foo 依赖于 j，由于 j 声明在 value 之后，就产生了使用未初始化成员的错误。</p>\n<p>带有virtual functions的类的默认构造函数毫无疑问是nontrivial的，需要编译器安插额外的<br>成员 vptr 并在构造函数中正确的设置好 vptr，这是编译器的重要职责之一。<br>继承自 virtual base class 的类的默认构造函数同样也毫无疑问的 nontrivial，编译器需要正确设置相关的信息以使得这些虚基类的信息能够在执行时准备妥当，这些设置取决于编译器实现虚基类的手法。</p>\n<p>编译器有4种情况会使得编译器真正的为class生成nontrivial的默认构造函数，这个 nontrivial 的默认构造函数只满足编译器的需要(调用 member objects 或 base class 的默认构造函数、初始化 virtual function 或 virutal base class 机制)。其它情况时，类在概念上拥有默认构造函数，但是实际上根本不会被产生出来(前面的区分 trivial 和 nontrivial)。</p>\n<p>对于一个trivial默认构造函数，编译器的态度是，既然它全无用处，干脆就不合成它。在这儿要厘清的是概念与实现的差别，概念上追求缜密完善，在实现上则追求效率，可以不要的东西就不要。</p>\n<h2 id=\"copy-constructor\"><a href=\"#copy-constructor\" class=\"headerlink\" title=\"copy constructor\"></a>copy constructor</h2><p>有一个参数的类型是其类类型的构造函数是为拷贝构造函数。如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">X::X( <span class=\"keyword\">const</span> X&amp; x);</span><br><span class=\"line\">Y::Y( <span class=\"keyword\">const</span> Y&amp; y, <span class=\"keyword\">int</span> =<span class=\"number\">0</span> );</span><br><span class=\"line\"><span class=\"comment\">//可以是多参数形式，但其第二个即后继参数都有一个默认值</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"什么时候编译器会给你生成拷贝构造函数\"><a href=\"#什么时候编译器会给你生成拷贝构造函数\" class=\"headerlink\" title=\"什么时候编译器会给你生成拷贝构造函数\"></a>什么时候编译器会给你生成拷贝构造函数</h3><blockquote>\n<p>其实和前面默认构造函数一样，四种情况</p>\n</blockquote>\n<p>如果一个类没有定义拷贝构造函数，通常按照“成员逐一初始化(Default Memberwise Initialization)”的手法来解决“一个类对象以另一个同类实体作为初值”——也就是说把内建或派生的数据成员从某一个对象拷贝到另一个对象身上，如果数据成员是一个对象，则递归使用“成员逐一初始化(Default Memberwise Initialization)”的手法。</p>\n<p>成员逐一初始化(Default Memberwise Initialization)具体的实现方式则是位逐次拷贝（Bitwise copy semantics）</p>\n<p>Copy constructors和默认构造函数一样，只有在必须的时候才会被产生出来，对于大部分的class 来说，拷贝构造函数仅仅需要按位拷贝就可以。满足 bitwise copy semantics 的拷贝构造函数是 trivial 的，就不会真正被合成出来(与默认构造函数一样，只有 nontrivial 的拷贝构 造函数才会被真正合成出来)。对大多数类按位拷贝就够了，什么时候一个 class 不展现出 bitwise copy semantics 呢? 分为 4 种情况，前 2 种很明显，后 2 种是由于编译器必须保证正确设置虚机制而引起的。</p>\n<ul>\n<li>当class内含一个member object而后者声明了(也可能由于nontrivial语意从而编译器 真正合成出来的)一个 copy constructor 时;</li>\n<li>当class继承自一个存在有copy constructor的base class(同样也可能是合成)时;</li>\n<li>当class声明了一个或多个virtual functions时;(vf影响了位语意，进而影响效率)</li>\n<li>当class派生自一个继承串链，其中一个或多个virtual base classes时。</li>\n</ul>\n<p>对于前两种情况，不论是基类还是对象成员，既然后者声明有拷贝构造函数时，就表明其类的设计者或者编译器希望以其声明的拷贝构造函数来完成“一个类对象以另一个同类实体作为初值”的工作，而设计者或编译器这样做——声明拷贝构造函数，总有它们的理由，而通常最直接的原因莫过于因为他们想要做一些额外的工作或“位逐次拷贝”无法胜任。</p>\n<p>对于有虚函数的类，如果两个对象的类型相同那么位逐次拷贝其实是可以胜任的。但问题将出现在，如果基类由其继承类进行初始化时，此时若按照位逐次拷贝来完成这个工作，那么基类的vptr将指向其继承类的虚函数表，这将导致无法预料的后果——调用一个错误的虚函数实体是无法避免的，轻则带来程序崩溃，更糟糕的问题可能是这个错误被隐藏了。所以对于有虚函数的类编译器将会明确的使被初始化的对象的vptr指向正确的虚函数表。因此有虚函数的类没有声明拷贝构造函数，编译将为之合成一个，来完成上述工作，以及初始化各数据成员，声明有拷贝构造函数的话也会被插入完成上述工作的代码。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123; <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"A::f()\"</span> &lt;&lt; <span class=\"built_in\">endl</span>; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> :</span> <span class=\"keyword\">public</span> A &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span></span>&#123; <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"B::f()\"</span> &lt;&lt; <span class=\"built_in\">endl</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  B b;</span><br><span class=\"line\">  b.i=<span class=\"number\">1</span>;</span><br><span class=\"line\">  A a = b;</span><br><span class=\"line\">  A *p = &amp;a;</span><br><span class=\"line\">  p-&gt;f();</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; p-&gt;i &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面例子可以看出，如果 A a = b;是 bitwise copy semantics 的话，a 内放置的就是 b 的 vptr。但其实不是，编译器给 a 生成了拷贝构造函数，初始化了 a 的 vptr。b 的 vptr 是由编译器给 b 生成的默认构造函数初始化的。但对于其他成员变量 bitwise copy semantics依然有效，所以 i 的结果是1。我在做这个试验的时候发现了一个有趣的现象：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123; <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"A::f()\"</span> &lt;&lt; <span class=\"built_in\">endl</span>; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> :</span> <span class=\"keyword\">public</span> A &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span></span>&#123; <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"B::f()\"</span> &lt;&lt; <span class=\"built_in\">endl</span>; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  B b;</span><br><span class=\"line\">  b.i=<span class=\"number\">1</span>;</span><br><span class=\"line\">  A a = b;</span><br><span class=\"line\">  A *p = &amp;a;</span><br><span class=\"line\">  p-&gt;f();</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; p-&gt;i &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>两个 i 不是同一个 i，b.i=1;优先给 b 中的同名变量赋值了。这样的代码简直可怕。那么怎么访问到从 A 继承来的成员变量 i 呢，请看：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">virtual</span> <span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123; <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"A::f()\"</span> &lt;&lt; <span class=\"built_in\">endl</span>; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> :</span> <span class=\"keyword\">public</span> A &#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f</span><span class=\"params\">()</span></span>&#123; <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"B::f()\"</span> &lt;&lt; <span class=\"built_in\">endl</span>; &#125;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> <span class=\"keyword\">const</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  B b;</span><br><span class=\"line\">  b.A::i=<span class=\"number\">6</span>;</span><br><span class=\"line\">  b.B::i=<span class=\"number\">1</span>;</span><br><span class=\"line\">  A a = b;</span><br><span class=\"line\">  A *p = &amp;a;</span><br><span class=\"line\">  <span class=\"built_in\">cout</span> &lt;&lt; p-&gt;i &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"命名返回值优化\"><a href=\"#命名返回值优化\" class=\"headerlink\" title=\"命名返回值优化\"></a>命名返回值优化</h2><p>对于一个如foo()这样的函数，它的每一个返回分支都返回相同的对象，编译器有可能对其做Named return Value优化（下文都简称NRV优化），方法是以一个参数result取代返回对象。</p>\n<p>foo()的原型：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">X <span class=\"title\">foo</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    X xx;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(...)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> xx;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> xx;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>优化后的foo()以result取代xx：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span>  <span class=\"title\">foo</span><span class=\"params\">(X &amp;result)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    result.X::X();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(...)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//直接处理result</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"comment\">//直接处理result</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对比优化前与优化后的代码可以看出，对于一句类似于X a = foo()这样的代码，NRV优化后的代码相较于原代码节省了一个临时对象的空间（省略了xx）,同时减少了两次函数调用（减少xx对象的默认构造函数和析构函数，以及一次拷贝构造函数的调用，增加了一次对a的默认构造函数的调用）。</p>\n"},{"layout":"post","title":"Inside the C++ Object Model 系列笔记 三 -- The Semantics of Data","date":"2017-10-20T16:00:00.000Z","comments":1,"_content":"\nC++对象模型的细节，讨论了 data members 的处理。\n\n## 空类在内存中有空间吗\n\n一个实例引出的思考：\n\n```C++\nclass X{};\nclass Y:virtual public X{};\nclass Z:virtual public X{};\nclass A:public Y, public Z{};\n```\n\n猜猜sizeof上面各个类都为多少？\n\nLippman的一个法国读者的结果是：\n\n```\nsizeof X yielded 1\nsizeof Y yielded 8\nsizeof Z yielded 8\nsizeof A yielded 12\n```\n\nLippman自己的结果是：\n\n```\nsizeof X yielded 1\nsizeof Y yielded 4\nsizeof Z yielded 4\nsizeof A yielded 8\n```\n\n事实上，对于像X这样的一个空类，编译器会对其动点手脚——隐晦的插入一个字节。为什么要这样做呢？插入了这一个字节，那么X的每一个对象都将有一个独一无二的地址。\n如果不插入这一个字节呢？哼哼，那对X的对象取地址的结果是什么？两个不同的X对象间地址的比较怎么办？\n\n我们再来看Y和Z。首先我们要明白的是实现虚继承，将要带来一些额外的负担——额外需要一个某种形式的指针。到目前为止，对于一个32位的机器来说Y、Z的大小应该为5，而不是8或者4。我们需要再考虑两点因素：内存对齐（alignment—）和编译器的优化。\n\n空类也有1Byte的大小，因为这样才能使得这个class的2个objects在内存中有独一无二的地址。\n\n## The Binding of a Data Member\n\n考虑下面这样的代码：\n\n```C++\nextern float x;\n\nclass Point3d{\npublic:\n\tPoint3d(float, float, float);\n\t//问题是 x 到底是哪个 x 呢\n\tfloat X() const {return x;}\n\tvoid X(float new_x) const{x = new_x;}\nprivate:\n\tfloat x;\n}\n```\n\n对member functions本身的分析会直到整个class的声明都出现了才开始（直到看到代表 class 结束的}右大括号）。所以class的 member functions 可以引用声明在后面的成员，C 语言就做不到。\n\n和member functions对比，需要十分注意的一点是:\nclass中的typedef并不具备这个性质。\n因此，类中的 typedef 的影响会受到函数与 typedef 的先后顺序的影响。\n\n```C++\ntypedef int length;\nclass Point3d{\npublic:\n\tvoid f1(length l){ cout << l << endl; }\n\ttypedef string length;\n\tvoid f2(length l){ cout << l << endl; }\n};\n```\n\n这样 f1 绑定的 length 类型是 int;\n而 f2 绑定的 length 类型才是 string。\n\n所以，对于 typedef 需要防御性的程序风格:\n始终把 nested type 声明(即 typedef)放在 class 起始处!\n\n## Data Member Layout\n\nC++只保证处于同一个 access section（也就是private,public,protected片段）的数据，一定会以声明的次序出现在内存布局当中(要求较晚出现的数据成员处在较大的内存地址中)。\nC++标准只提供了这一点点的保证。\n允许编译器将多个Acess Section的顺序自由排列，而不必在乎它们的声明次序。但似乎没有编译器这样做。\n对于继承类，C++标准并未指定是其基类成员在前还是自己的成员在前。\n\n```C++\nclass X {\npublic:\n   int i;\n   int j;\nprivate:\n   int k;\n   int n;\n}\n```\n\n数据 i 一定在 j 之前，k 一定在 n 之前。具体什么顺序就看编译器了。\n\n传统上，vptr被安放在所有被明确声明的member的最后，不过也有些编译器把vptr放在最前面(MSVC++就是把 vptr 放在最前面，而 G++ 是把 vptr 放在最后面)。\n\n## Access of a Data Member\n\n在C++中，直观上来说，由一个对象存取一个member会比由一个指针存取一个member更快捷。\n但是对于经由一个对象来存取和由一个指针来存取一个静态的 member 来说，是完全一样的，都会被编译器所扩展。\n\n经由 member selection operators（也就是 “.” 运算符）对一个 static data member 进行存取操作只是一种语法上的便宜行事而已。member 其实并不在 class object 中，因此存取并不需要通过 class object。\n\n经由一个函数调用的结果来存取静态成员，C++标准要求编译器必须对这个函数进行求值，虽然这个求值的结果并无用处。\n\nfoo().static_member = 100;\n\nfoo()返回一个类型为 X 的对象，含有一个 static_member，foo()其实可以不用求值而直接访 问这个静态成员，但是 C++标准保证了 foo()会被求值，可能的代码扩展为:\n\n```C++\n(void) foo();\nX::static_member = 100;\n```\n\n## static data members\n\n如果有两个 class ，每个都声明了一个 static member freelist，那么当他们都被放在程序的 data segment时，就会导致名称冲突。编译器的解决方法是暗中对每一个 static data member 编码（这种手法有个很美的名称：name-mangling），以获得一个独一无二的程序识别代码。有多少种编译器就有多少种 name-mangling 做法！通常不外乎是表格啦，语法措辞啦等等。任何 name-mangling 都有两个要点：\n\n1. 一种算法，推导出独一无二的名称。\n2. 万一编译系统（或环境工具）必须和使用者交谈，那些独一无二的名称可以轻易被推导回原来的名称。\n\n## nonstatic data members\n\nNonstatic data members are stored directly within each class object and cannot be accessed except through an explicit or implicit class object. An implicit class object is present whenever the programmer directly accesses a nonstatic data member within a member function. For example, in the following code:\n\n```C++\nPoint3d\nPoint3d::translate( const Point3d &pt ) {\n   x += pt.x;\n   y += pt.y;\n   z += pt.z;\n}\n```\n\nthe seemingly direct access of x, y, and z is actually carried out through an implicit class object represented\nby the this pointer. Internally, the function is augmented as follows:\n\n```C++\n// internal augmentation of member function\n  Point3d\n  Point3d::translate( const Point3d* this, const Point3d &pt ) {\n     this->x += pt.x;\n     this->y += pt.y;\n     this->z += pt.z;\n}\n```\n\n地址：&origin._y;和&origin + ( &Point3d::_y - 1 );是一样的。指向 data member 的指针，其 offset 值总是被加上1。这样可以使编译系统区分出 “一个指针 data member 的指针，用以指向 class 的第一个 member”和“一个指向 data member 的指针，但是没有指向任何 member”两种情况(成员指针也需要有个表示 NULL 的方式，0 相当于用来表示 NULL 了，其它的就都要加上 1 了)。\n\n## Inheritance and the Data Member\n\nC++ Standard 保证:“出现在派生类中的 base class subobject 有其完整原样性!” 子类会被放在父类的对齐空白字节之后，因为父类的完整性必须得以保证，父类的对齐空白字节 也是父类的一部分，也是不可分割的。\n\n请看下面例子：\n\n```C++\nclass X{\npublic:\n    int x;\n    char c;\n};\nclass X2:public X\n{\npublic:\n    char  c2;\n};\n```\n\nX2的布局应当是x(4),c(1),c2(1),这么说来sizeof(X2)的值应该是8？错了，实际上是12。原因在于X后面的三个字节的填充空白不能为c2所用。也就是说X2的大小实际上为：X(8)+c2(1)+填补（3）=12。这样看来编译器似乎是那么的呆板，其实不然，看一下下面的语句会发生什么？\n\n```C++\nX2 x2;\nX x;\nx2=x;\n```\n\n如果X后面的填充空白可以被c2使用的话，那么X2和X都将是8字节。上面的语句执行后x2.c2的值会是多少？一个不确定的值！这样的结果肯定不是我们想要的。\n\n在多重继承的派生体系中，将派生类的地址转换为第 1 基类时成本与单继承是相同的，只需要改换地址的解释方式而已；而对于转换为非第 1 基类的情况，则需要对地址进行一定的 offset 操作 才行。\nC++ Standard 并未明确 base classes 的特定排列次序，但是目前的编译器都是按照声明的次序来安放他们的。(有一个优化:如果第 1 基类没有 vtable 而后继基类有，则可能把它们调 个位置)。\n多重继承中，可能会有多个 vptr 指针，视其继承体系而定:派生类中 vptr 的数目最多等于所有基\n类的 vptr 数目的总和。\n","source":"_posts/2017/2017-10-21-Inside-the-C++-Object-Model-系列笔记--The-Semantics-of-Data.md","raw":"---\nlayout: post\ntitle: Inside the C++ Object Model 系列笔记 三 -- The Semantics of Data\ndate: 2017-10-21\ncategories: [读书笔记, 《Inside the C++ Object Model》]\ntags: [C++]\ncomments: true\n---\n\nC++对象模型的细节，讨论了 data members 的处理。\n\n## 空类在内存中有空间吗\n\n一个实例引出的思考：\n\n```C++\nclass X{};\nclass Y:virtual public X{};\nclass Z:virtual public X{};\nclass A:public Y, public Z{};\n```\n\n猜猜sizeof上面各个类都为多少？\n\nLippman的一个法国读者的结果是：\n\n```\nsizeof X yielded 1\nsizeof Y yielded 8\nsizeof Z yielded 8\nsizeof A yielded 12\n```\n\nLippman自己的结果是：\n\n```\nsizeof X yielded 1\nsizeof Y yielded 4\nsizeof Z yielded 4\nsizeof A yielded 8\n```\n\n事实上，对于像X这样的一个空类，编译器会对其动点手脚——隐晦的插入一个字节。为什么要这样做呢？插入了这一个字节，那么X的每一个对象都将有一个独一无二的地址。\n如果不插入这一个字节呢？哼哼，那对X的对象取地址的结果是什么？两个不同的X对象间地址的比较怎么办？\n\n我们再来看Y和Z。首先我们要明白的是实现虚继承，将要带来一些额外的负担——额外需要一个某种形式的指针。到目前为止，对于一个32位的机器来说Y、Z的大小应该为5，而不是8或者4。我们需要再考虑两点因素：内存对齐（alignment—）和编译器的优化。\n\n空类也有1Byte的大小，因为这样才能使得这个class的2个objects在内存中有独一无二的地址。\n\n## The Binding of a Data Member\n\n考虑下面这样的代码：\n\n```C++\nextern float x;\n\nclass Point3d{\npublic:\n\tPoint3d(float, float, float);\n\t//问题是 x 到底是哪个 x 呢\n\tfloat X() const {return x;}\n\tvoid X(float new_x) const{x = new_x;}\nprivate:\n\tfloat x;\n}\n```\n\n对member functions本身的分析会直到整个class的声明都出现了才开始（直到看到代表 class 结束的}右大括号）。所以class的 member functions 可以引用声明在后面的成员，C 语言就做不到。\n\n和member functions对比，需要十分注意的一点是:\nclass中的typedef并不具备这个性质。\n因此，类中的 typedef 的影响会受到函数与 typedef 的先后顺序的影响。\n\n```C++\ntypedef int length;\nclass Point3d{\npublic:\n\tvoid f1(length l){ cout << l << endl; }\n\ttypedef string length;\n\tvoid f2(length l){ cout << l << endl; }\n};\n```\n\n这样 f1 绑定的 length 类型是 int;\n而 f2 绑定的 length 类型才是 string。\n\n所以，对于 typedef 需要防御性的程序风格:\n始终把 nested type 声明(即 typedef)放在 class 起始处!\n\n## Data Member Layout\n\nC++只保证处于同一个 access section（也就是private,public,protected片段）的数据，一定会以声明的次序出现在内存布局当中(要求较晚出现的数据成员处在较大的内存地址中)。\nC++标准只提供了这一点点的保证。\n允许编译器将多个Acess Section的顺序自由排列，而不必在乎它们的声明次序。但似乎没有编译器这样做。\n对于继承类，C++标准并未指定是其基类成员在前还是自己的成员在前。\n\n```C++\nclass X {\npublic:\n   int i;\n   int j;\nprivate:\n   int k;\n   int n;\n}\n```\n\n数据 i 一定在 j 之前，k 一定在 n 之前。具体什么顺序就看编译器了。\n\n传统上，vptr被安放在所有被明确声明的member的最后，不过也有些编译器把vptr放在最前面(MSVC++就是把 vptr 放在最前面，而 G++ 是把 vptr 放在最后面)。\n\n## Access of a Data Member\n\n在C++中，直观上来说，由一个对象存取一个member会比由一个指针存取一个member更快捷。\n但是对于经由一个对象来存取和由一个指针来存取一个静态的 member 来说，是完全一样的，都会被编译器所扩展。\n\n经由 member selection operators（也就是 “.” 运算符）对一个 static data member 进行存取操作只是一种语法上的便宜行事而已。member 其实并不在 class object 中，因此存取并不需要通过 class object。\n\n经由一个函数调用的结果来存取静态成员，C++标准要求编译器必须对这个函数进行求值，虽然这个求值的结果并无用处。\n\nfoo().static_member = 100;\n\nfoo()返回一个类型为 X 的对象，含有一个 static_member，foo()其实可以不用求值而直接访 问这个静态成员，但是 C++标准保证了 foo()会被求值，可能的代码扩展为:\n\n```C++\n(void) foo();\nX::static_member = 100;\n```\n\n## static data members\n\n如果有两个 class ，每个都声明了一个 static member freelist，那么当他们都被放在程序的 data segment时，就会导致名称冲突。编译器的解决方法是暗中对每一个 static data member 编码（这种手法有个很美的名称：name-mangling），以获得一个独一无二的程序识别代码。有多少种编译器就有多少种 name-mangling 做法！通常不外乎是表格啦，语法措辞啦等等。任何 name-mangling 都有两个要点：\n\n1. 一种算法，推导出独一无二的名称。\n2. 万一编译系统（或环境工具）必须和使用者交谈，那些独一无二的名称可以轻易被推导回原来的名称。\n\n## nonstatic data members\n\nNonstatic data members are stored directly within each class object and cannot be accessed except through an explicit or implicit class object. An implicit class object is present whenever the programmer directly accesses a nonstatic data member within a member function. For example, in the following code:\n\n```C++\nPoint3d\nPoint3d::translate( const Point3d &pt ) {\n   x += pt.x;\n   y += pt.y;\n   z += pt.z;\n}\n```\n\nthe seemingly direct access of x, y, and z is actually carried out through an implicit class object represented\nby the this pointer. Internally, the function is augmented as follows:\n\n```C++\n// internal augmentation of member function\n  Point3d\n  Point3d::translate( const Point3d* this, const Point3d &pt ) {\n     this->x += pt.x;\n     this->y += pt.y;\n     this->z += pt.z;\n}\n```\n\n地址：&origin._y;和&origin + ( &Point3d::_y - 1 );是一样的。指向 data member 的指针，其 offset 值总是被加上1。这样可以使编译系统区分出 “一个指针 data member 的指针，用以指向 class 的第一个 member”和“一个指向 data member 的指针，但是没有指向任何 member”两种情况(成员指针也需要有个表示 NULL 的方式，0 相当于用来表示 NULL 了，其它的就都要加上 1 了)。\n\n## Inheritance and the Data Member\n\nC++ Standard 保证:“出现在派生类中的 base class subobject 有其完整原样性!” 子类会被放在父类的对齐空白字节之后，因为父类的完整性必须得以保证，父类的对齐空白字节 也是父类的一部分，也是不可分割的。\n\n请看下面例子：\n\n```C++\nclass X{\npublic:\n    int x;\n    char c;\n};\nclass X2:public X\n{\npublic:\n    char  c2;\n};\n```\n\nX2的布局应当是x(4),c(1),c2(1),这么说来sizeof(X2)的值应该是8？错了，实际上是12。原因在于X后面的三个字节的填充空白不能为c2所用。也就是说X2的大小实际上为：X(8)+c2(1)+填补（3）=12。这样看来编译器似乎是那么的呆板，其实不然，看一下下面的语句会发生什么？\n\n```C++\nX2 x2;\nX x;\nx2=x;\n```\n\n如果X后面的填充空白可以被c2使用的话，那么X2和X都将是8字节。上面的语句执行后x2.c2的值会是多少？一个不确定的值！这样的结果肯定不是我们想要的。\n\n在多重继承的派生体系中，将派生类的地址转换为第 1 基类时成本与单继承是相同的，只需要改换地址的解释方式而已；而对于转换为非第 1 基类的情况，则需要对地址进行一定的 offset 操作 才行。\nC++ Standard 并未明确 base classes 的特定排列次序，但是目前的编译器都是按照声明的次序来安放他们的。(有一个优化:如果第 1 基类没有 vtable 而后继基类有，则可能把它们调 个位置)。\n多重继承中，可能会有多个 vptr 指针，视其继承体系而定:派生类中 vptr 的数目最多等于所有基\n类的 vptr 数目的总和。\n","slug":"Inside-the-C++-Object-Model-系列笔记--The-Semantics-of-Data","published":1,"updated":"2018-06-10T12:03:19.763Z","photos":[],"link":"","_id":"cjm2w8dcz001cfgpx7ac2uv93","content":"<p>C++对象模型的细节，讨论了 data members 的处理。</p>\n<h2 id=\"空类在内存中有空间吗\"><a href=\"#空类在内存中有空间吗\" class=\"headerlink\" title=\"空类在内存中有空间吗\"></a>空类在内存中有空间吗</h2><p>一个实例引出的思考：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">X</span>&#123;</span>&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Y</span>:</span><span class=\"keyword\">virtual</span> <span class=\"keyword\">public</span> X&#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Z</span>:</span><span class=\"keyword\">virtual</span> <span class=\"keyword\">public</span> X&#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>:</span><span class=\"keyword\">public</span> Y, <span class=\"keyword\">public</span> Z&#123;&#125;;</span><br></pre></td></tr></table></figure>\n<p>猜猜sizeof上面各个类都为多少？</p>\n<p>Lippman的一个法国读者的结果是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sizeof X yielded 1</span><br><span class=\"line\">sizeof Y yielded 8</span><br><span class=\"line\">sizeof Z yielded 8</span><br><span class=\"line\">sizeof A yielded 12</span><br></pre></td></tr></table></figure>\n<p>Lippman自己的结果是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sizeof X yielded 1</span><br><span class=\"line\">sizeof Y yielded 4</span><br><span class=\"line\">sizeof Z yielded 4</span><br><span class=\"line\">sizeof A yielded 8</span><br></pre></td></tr></table></figure>\n<p>事实上，对于像X这样的一个空类，编译器会对其动点手脚——隐晦的插入一个字节。为什么要这样做呢？插入了这一个字节，那么X的每一个对象都将有一个独一无二的地址。<br>如果不插入这一个字节呢？哼哼，那对X的对象取地址的结果是什么？两个不同的X对象间地址的比较怎么办？</p>\n<p>我们再来看Y和Z。首先我们要明白的是实现虚继承，将要带来一些额外的负担——额外需要一个某种形式的指针。到目前为止，对于一个32位的机器来说Y、Z的大小应该为5，而不是8或者4。我们需要再考虑两点因素：内存对齐（alignment—）和编译器的优化。</p>\n<p>空类也有1Byte的大小，因为这样才能使得这个class的2个objects在内存中有独一无二的地址。</p>\n<h2 id=\"The-Binding-of-a-Data-Member\"><a href=\"#The-Binding-of-a-Data-Member\" class=\"headerlink\" title=\"The Binding of a Data Member\"></a>The Binding of a Data Member</h2><p>考虑下面这样的代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">float</span> x;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point3d</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">truePoint3d(<span class=\"keyword\">float</span>, <span class=\"keyword\">float</span>, <span class=\"keyword\">float</span>);</span><br><span class=\"line\">true<span class=\"comment\">//问题是 x 到底是哪个 x 呢</span></span><br><span class=\"line\">true<span class=\"function\"><span class=\"keyword\">float</span> <span class=\"title\">X</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;<span class=\"keyword\">return</span> x;&#125;</span><br><span class=\"line\">true<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">X</span><span class=\"params\">(<span class=\"keyword\">float</span> new_x)</span> <span class=\"keyword\">const</span></span>&#123;x = new_x;&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">true<span class=\"keyword\">float</span> x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对member functions本身的分析会直到整个class的声明都出现了才开始（直到看到代表 class 结束的}右大括号）。所以class的 member functions 可以引用声明在后面的成员，C 语言就做不到。</p>\n<p>和member functions对比，需要十分注意的一点是:<br>class中的typedef并不具备这个性质。<br>因此，类中的 typedef 的影响会受到函数与 typedef 的先后顺序的影响。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> length;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point3d</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">true<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f1</span><span class=\"params\">(length l)</span></span>&#123; <span class=\"built_in\">cout</span> &lt;&lt; l &lt;&lt; <span class=\"built_in\">endl</span>; &#125;</span><br><span class=\"line\">true<span class=\"keyword\">typedef</span> <span class=\"built_in\">string</span> length;</span><br><span class=\"line\">true<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f2</span><span class=\"params\">(length l)</span></span>&#123; <span class=\"built_in\">cout</span> &lt;&lt; l &lt;&lt; <span class=\"built_in\">endl</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这样 f1 绑定的 length 类型是 int;<br>而 f2 绑定的 length 类型才是 string。</p>\n<p>所以，对于 typedef 需要防御性的程序风格:<br>始终把 nested type 声明(即 typedef)放在 class 起始处!</p>\n<h2 id=\"Data-Member-Layout\"><a href=\"#Data-Member-Layout\" class=\"headerlink\" title=\"Data Member Layout\"></a>Data Member Layout</h2><p>C++只保证处于同一个 access section（也就是private,public,protected片段）的数据，一定会以声明的次序出现在内存布局当中(要求较晚出现的数据成员处在较大的内存地址中)。<br>C++标准只提供了这一点点的保证。<br>允许编译器将多个Acess Section的顺序自由排列，而不必在乎它们的声明次序。但似乎没有编译器这样做。<br>对于继承类，C++标准并未指定是其基类成员在前还是自己的成员在前。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">X</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">   <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> j;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">   <span class=\"keyword\">int</span> k;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>数据 i 一定在 j 之前，k 一定在 n 之前。具体什么顺序就看编译器了。</p>\n<p>传统上，vptr被安放在所有被明确声明的member的最后，不过也有些编译器把vptr放在最前面(MSVC++就是把 vptr 放在最前面，而 G++ 是把 vptr 放在最后面)。</p>\n<h2 id=\"Access-of-a-Data-Member\"><a href=\"#Access-of-a-Data-Member\" class=\"headerlink\" title=\"Access of a Data Member\"></a>Access of a Data Member</h2><p>在C++中，直观上来说，由一个对象存取一个member会比由一个指针存取一个member更快捷。<br>但是对于经由一个对象来存取和由一个指针来存取一个静态的 member 来说，是完全一样的，都会被编译器所扩展。</p>\n<p>经由 member selection operators（也就是 “.” 运算符）对一个 static data member 进行存取操作只是一种语法上的便宜行事而已。member 其实并不在 class object 中，因此存取并不需要通过 class object。</p>\n<p>经由一个函数调用的结果来存取静态成员，C++标准要求编译器必须对这个函数进行求值，虽然这个求值的结果并无用处。</p>\n<p>foo().static_member = 100;</p>\n<p>foo()返回一个类型为 X 的对象，含有一个 static_member，foo()其实可以不用求值而直接访 问这个静态成员，但是 C++标准保证了 foo()会被求值，可能的代码扩展为:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"keyword\">void</span>) foo();</span><br><span class=\"line\">X::static_member = <span class=\"number\">100</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"static-data-members\"><a href=\"#static-data-members\" class=\"headerlink\" title=\"static data members\"></a>static data members</h2><p>如果有两个 class ，每个都声明了一个 static member freelist，那么当他们都被放在程序的 data segment时，就会导致名称冲突。编译器的解决方法是暗中对每一个 static data member 编码（这种手法有个很美的名称：name-mangling），以获得一个独一无二的程序识别代码。有多少种编译器就有多少种 name-mangling 做法！通常不外乎是表格啦，语法措辞啦等等。任何 name-mangling 都有两个要点：</p>\n<ol>\n<li>一种算法，推导出独一无二的名称。</li>\n<li>万一编译系统（或环境工具）必须和使用者交谈，那些独一无二的名称可以轻易被推导回原来的名称。</li>\n</ol>\n<h2 id=\"nonstatic-data-members\"><a href=\"#nonstatic-data-members\" class=\"headerlink\" title=\"nonstatic data members\"></a>nonstatic data members</h2><p>Nonstatic data members are stored directly within each class object and cannot be accessed except through an explicit or implicit class object. An implicit class object is present whenever the programmer directly accesses a nonstatic data member within a member function. For example, in the following code:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Point3d</span><br><span class=\"line\">Point3d::translate( <span class=\"keyword\">const</span> Point3d &amp;pt ) &#123;</span><br><span class=\"line\">   x += pt.x;</span><br><span class=\"line\">   y += pt.y;</span><br><span class=\"line\">   z += pt.z;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>the seemingly direct access of x, y, and z is actually carried out through an implicit class object represented<br>by the this pointer. Internally, the function is augmented as follows:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// internal augmentation of member function</span></span><br><span class=\"line\">  Point3d</span><br><span class=\"line\">  Point3d::translate( <span class=\"keyword\">const</span> Point3d* <span class=\"keyword\">this</span>, <span class=\"keyword\">const</span> Point3d &amp;pt ) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">this</span>-&gt;x += pt.x;</span><br><span class=\"line\">     <span class=\"keyword\">this</span>-&gt;y += pt.y;</span><br><span class=\"line\">     <span class=\"keyword\">this</span>-&gt;z += pt.z;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>地址：&amp;origin._y;和&amp;origin + ( &amp;Point3d::_y - 1 );是一样的。指向 data member 的指针，其 offset 值总是被加上1。这样可以使编译系统区分出 “一个指针 data member 的指针，用以指向 class 的第一个 member”和“一个指向 data member 的指针，但是没有指向任何 member”两种情况(成员指针也需要有个表示 NULL 的方式，0 相当于用来表示 NULL 了，其它的就都要加上 1 了)。</p>\n<h2 id=\"Inheritance-and-the-Data-Member\"><a href=\"#Inheritance-and-the-Data-Member\" class=\"headerlink\" title=\"Inheritance and the Data Member\"></a>Inheritance and the Data Member</h2><p>C++ Standard 保证:“出现在派生类中的 base class subobject 有其完整原样性!” 子类会被放在父类的对齐空白字节之后，因为父类的完整性必须得以保证，父类的对齐空白字节 也是父类的一部分，也是不可分割的。</p>\n<p>请看下面例子：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">X</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> c;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">X2</span>:</span><span class=\"keyword\">public</span> X</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">char</span>  c2;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>X2的布局应当是x(4),c(1),c2(1),这么说来sizeof(X2)的值应该是8？错了，实际上是12。原因在于X后面的三个字节的填充空白不能为c2所用。也就是说X2的大小实际上为：X(8)+c2(1)+填补（3）=12。这样看来编译器似乎是那么的呆板，其实不然，看一下下面的语句会发生什么？</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">X2 x2;</span><br><span class=\"line\">X x;</span><br><span class=\"line\">x2=x;</span><br></pre></td></tr></table></figure>\n<p>如果X后面的填充空白可以被c2使用的话，那么X2和X都将是8字节。上面的语句执行后x2.c2的值会是多少？一个不确定的值！这样的结果肯定不是我们想要的。</p>\n<p>在多重继承的派生体系中，将派生类的地址转换为第 1 基类时成本与单继承是相同的，只需要改换地址的解释方式而已；而对于转换为非第 1 基类的情况，则需要对地址进行一定的 offset 操作 才行。<br>C++ Standard 并未明确 base classes 的特定排列次序，但是目前的编译器都是按照声明的次序来安放他们的。(有一个优化:如果第 1 基类没有 vtable 而后继基类有，则可能把它们调 个位置)。<br>多重继承中，可能会有多个 vptr 指针，视其继承体系而定:派生类中 vptr 的数目最多等于所有基<br>类的 vptr 数目的总和。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>C++对象模型的细节，讨论了 data members 的处理。</p>\n<h2 id=\"空类在内存中有空间吗\"><a href=\"#空类在内存中有空间吗\" class=\"headerlink\" title=\"空类在内存中有空间吗\"></a>空类在内存中有空间吗</h2><p>一个实例引出的思考：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">X</span>&#123;</span>&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Y</span>:</span><span class=\"keyword\">virtual</span> <span class=\"keyword\">public</span> X&#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Z</span>:</span><span class=\"keyword\">virtual</span> <span class=\"keyword\">public</span> X&#123;&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>:</span><span class=\"keyword\">public</span> Y, <span class=\"keyword\">public</span> Z&#123;&#125;;</span><br></pre></td></tr></table></figure>\n<p>猜猜sizeof上面各个类都为多少？</p>\n<p>Lippman的一个法国读者的结果是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sizeof X yielded 1</span><br><span class=\"line\">sizeof Y yielded 8</span><br><span class=\"line\">sizeof Z yielded 8</span><br><span class=\"line\">sizeof A yielded 12</span><br></pre></td></tr></table></figure>\n<p>Lippman自己的结果是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sizeof X yielded 1</span><br><span class=\"line\">sizeof Y yielded 4</span><br><span class=\"line\">sizeof Z yielded 4</span><br><span class=\"line\">sizeof A yielded 8</span><br></pre></td></tr></table></figure>\n<p>事实上，对于像X这样的一个空类，编译器会对其动点手脚——隐晦的插入一个字节。为什么要这样做呢？插入了这一个字节，那么X的每一个对象都将有一个独一无二的地址。<br>如果不插入这一个字节呢？哼哼，那对X的对象取地址的结果是什么？两个不同的X对象间地址的比较怎么办？</p>\n<p>我们再来看Y和Z。首先我们要明白的是实现虚继承，将要带来一些额外的负担——额外需要一个某种形式的指针。到目前为止，对于一个32位的机器来说Y、Z的大小应该为5，而不是8或者4。我们需要再考虑两点因素：内存对齐（alignment—）和编译器的优化。</p>\n<p>空类也有1Byte的大小，因为这样才能使得这个class的2个objects在内存中有独一无二的地址。</p>\n<h2 id=\"The-Binding-of-a-Data-Member\"><a href=\"#The-Binding-of-a-Data-Member\" class=\"headerlink\" title=\"The Binding of a Data Member\"></a>The Binding of a Data Member</h2><p>考虑下面这样的代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">float</span> x;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point3d</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">truePoint3d(<span class=\"keyword\">float</span>, <span class=\"keyword\">float</span>, <span class=\"keyword\">float</span>);</span><br><span class=\"line\">true<span class=\"comment\">//问题是 x 到底是哪个 x 呢</span></span><br><span class=\"line\">true<span class=\"function\"><span class=\"keyword\">float</span> <span class=\"title\">X</span><span class=\"params\">()</span> <span class=\"keyword\">const</span> </span>&#123;<span class=\"keyword\">return</span> x;&#125;</span><br><span class=\"line\">true<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">X</span><span class=\"params\">(<span class=\"keyword\">float</span> new_x)</span> <span class=\"keyword\">const</span></span>&#123;x = new_x;&#125;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">true<span class=\"keyword\">float</span> x;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对member functions本身的分析会直到整个class的声明都出现了才开始（直到看到代表 class 结束的}右大括号）。所以class的 member functions 可以引用声明在后面的成员，C 语言就做不到。</p>\n<p>和member functions对比，需要十分注意的一点是:<br>class中的typedef并不具备这个性质。<br>因此，类中的 typedef 的影响会受到函数与 typedef 的先后顺序的影响。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> length;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point3d</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">true<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f1</span><span class=\"params\">(length l)</span></span>&#123; <span class=\"built_in\">cout</span> &lt;&lt; l &lt;&lt; <span class=\"built_in\">endl</span>; &#125;</span><br><span class=\"line\">true<span class=\"keyword\">typedef</span> <span class=\"built_in\">string</span> length;</span><br><span class=\"line\">true<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">f2</span><span class=\"params\">(length l)</span></span>&#123; <span class=\"built_in\">cout</span> &lt;&lt; l &lt;&lt; <span class=\"built_in\">endl</span>; &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这样 f1 绑定的 length 类型是 int;<br>而 f2 绑定的 length 类型才是 string。</p>\n<p>所以，对于 typedef 需要防御性的程序风格:<br>始终把 nested type 声明(即 typedef)放在 class 起始处!</p>\n<h2 id=\"Data-Member-Layout\"><a href=\"#Data-Member-Layout\" class=\"headerlink\" title=\"Data Member Layout\"></a>Data Member Layout</h2><p>C++只保证处于同一个 access section（也就是private,public,protected片段）的数据，一定会以声明的次序出现在内存布局当中(要求较晚出现的数据成员处在较大的内存地址中)。<br>C++标准只提供了这一点点的保证。<br>允许编译器将多个Acess Section的顺序自由排列，而不必在乎它们的声明次序。但似乎没有编译器这样做。<br>对于继承类，C++标准并未指定是其基类成员在前还是自己的成员在前。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">X</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">   <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> j;</span><br><span class=\"line\"><span class=\"keyword\">private</span>:</span><br><span class=\"line\">   <span class=\"keyword\">int</span> k;</span><br><span class=\"line\">   <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>数据 i 一定在 j 之前，k 一定在 n 之前。具体什么顺序就看编译器了。</p>\n<p>传统上，vptr被安放在所有被明确声明的member的最后，不过也有些编译器把vptr放在最前面(MSVC++就是把 vptr 放在最前面，而 G++ 是把 vptr 放在最后面)。</p>\n<h2 id=\"Access-of-a-Data-Member\"><a href=\"#Access-of-a-Data-Member\" class=\"headerlink\" title=\"Access of a Data Member\"></a>Access of a Data Member</h2><p>在C++中，直观上来说，由一个对象存取一个member会比由一个指针存取一个member更快捷。<br>但是对于经由一个对象来存取和由一个指针来存取一个静态的 member 来说，是完全一样的，都会被编译器所扩展。</p>\n<p>经由 member selection operators（也就是 “.” 运算符）对一个 static data member 进行存取操作只是一种语法上的便宜行事而已。member 其实并不在 class object 中，因此存取并不需要通过 class object。</p>\n<p>经由一个函数调用的结果来存取静态成员，C++标准要求编译器必须对这个函数进行求值，虽然这个求值的结果并无用处。</p>\n<p>foo().static_member = 100;</p>\n<p>foo()返回一个类型为 X 的对象，含有一个 static_member，foo()其实可以不用求值而直接访 问这个静态成员，但是 C++标准保证了 foo()会被求值，可能的代码扩展为:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"keyword\">void</span>) foo();</span><br><span class=\"line\">X::static_member = <span class=\"number\">100</span>;</span><br></pre></td></tr></table></figure>\n<h2 id=\"static-data-members\"><a href=\"#static-data-members\" class=\"headerlink\" title=\"static data members\"></a>static data members</h2><p>如果有两个 class ，每个都声明了一个 static member freelist，那么当他们都被放在程序的 data segment时，就会导致名称冲突。编译器的解决方法是暗中对每一个 static data member 编码（这种手法有个很美的名称：name-mangling），以获得一个独一无二的程序识别代码。有多少种编译器就有多少种 name-mangling 做法！通常不外乎是表格啦，语法措辞啦等等。任何 name-mangling 都有两个要点：</p>\n<ol>\n<li>一种算法，推导出独一无二的名称。</li>\n<li>万一编译系统（或环境工具）必须和使用者交谈，那些独一无二的名称可以轻易被推导回原来的名称。</li>\n</ol>\n<h2 id=\"nonstatic-data-members\"><a href=\"#nonstatic-data-members\" class=\"headerlink\" title=\"nonstatic data members\"></a>nonstatic data members</h2><p>Nonstatic data members are stored directly within each class object and cannot be accessed except through an explicit or implicit class object. An implicit class object is present whenever the programmer directly accesses a nonstatic data member within a member function. For example, in the following code:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Point3d</span><br><span class=\"line\">Point3d::translate( <span class=\"keyword\">const</span> Point3d &amp;pt ) &#123;</span><br><span class=\"line\">   x += pt.x;</span><br><span class=\"line\">   y += pt.y;</span><br><span class=\"line\">   z += pt.z;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>the seemingly direct access of x, y, and z is actually carried out through an implicit class object represented<br>by the this pointer. Internally, the function is augmented as follows:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// internal augmentation of member function</span></span><br><span class=\"line\">  Point3d</span><br><span class=\"line\">  Point3d::translate( <span class=\"keyword\">const</span> Point3d* <span class=\"keyword\">this</span>, <span class=\"keyword\">const</span> Point3d &amp;pt ) &#123;</span><br><span class=\"line\">     <span class=\"keyword\">this</span>-&gt;x += pt.x;</span><br><span class=\"line\">     <span class=\"keyword\">this</span>-&gt;y += pt.y;</span><br><span class=\"line\">     <span class=\"keyword\">this</span>-&gt;z += pt.z;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>地址：&amp;origin._y;和&amp;origin + ( &amp;Point3d::_y - 1 );是一样的。指向 data member 的指针，其 offset 值总是被加上1。这样可以使编译系统区分出 “一个指针 data member 的指针，用以指向 class 的第一个 member”和“一个指向 data member 的指针，但是没有指向任何 member”两种情况(成员指针也需要有个表示 NULL 的方式，0 相当于用来表示 NULL 了，其它的就都要加上 1 了)。</p>\n<h2 id=\"Inheritance-and-the-Data-Member\"><a href=\"#Inheritance-and-the-Data-Member\" class=\"headerlink\" title=\"Inheritance and the Data Member\"></a>Inheritance and the Data Member</h2><p>C++ Standard 保证:“出现在派生类中的 base class subobject 有其完整原样性!” 子类会被放在父类的对齐空白字节之后，因为父类的完整性必须得以保证，父类的对齐空白字节 也是父类的一部分，也是不可分割的。</p>\n<p>请看下面例子：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">X</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">int</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> c;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">X2</span>:</span><span class=\"keyword\">public</span> X</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"keyword\">char</span>  c2;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>X2的布局应当是x(4),c(1),c2(1),这么说来sizeof(X2)的值应该是8？错了，实际上是12。原因在于X后面的三个字节的填充空白不能为c2所用。也就是说X2的大小实际上为：X(8)+c2(1)+填补（3）=12。这样看来编译器似乎是那么的呆板，其实不然，看一下下面的语句会发生什么？</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">X2 x2;</span><br><span class=\"line\">X x;</span><br><span class=\"line\">x2=x;</span><br></pre></td></tr></table></figure>\n<p>如果X后面的填充空白可以被c2使用的话，那么X2和X都将是8字节。上面的语句执行后x2.c2的值会是多少？一个不确定的值！这样的结果肯定不是我们想要的。</p>\n<p>在多重继承的派生体系中，将派生类的地址转换为第 1 基类时成本与单继承是相同的，只需要改换地址的解释方式而已；而对于转换为非第 1 基类的情况，则需要对地址进行一定的 offset 操作 才行。<br>C++ Standard 并未明确 base classes 的特定排列次序，但是目前的编译器都是按照声明的次序来安放他们的。(有一个优化:如果第 1 基类没有 vtable 而后继基类有，则可能把它们调 个位置)。<br>多重继承中，可能会有多个 vptr 指针，视其继承体系而定:派生类中 vptr 的数目最多等于所有基<br>类的 vptr 数目的总和。</p>\n"},{"layout":"post","title":"Inside the C++ Object Model 系列笔记 四 -- The Semantics of Function","date":"2017-10-22T16:00:00.000Z","comments":1,"_content":"\n>c++支持三种类型的成员函数，分别为static,nostatic,virtual。每一种调用方式都不尽相同。\n\n## nonstatic member function\n\nC++的设计准则之一就是:nonstatic member function至少必须和一般的nonmember function 有相同的效率。\n实际上，nonstatic member function 会被编译器进行如下的转换，变成一个普通函数:\n\nType1 X::foo(Type2 arg1) { ... }\n\n会被转换为如下的普通函数:\n\nvoid foo(X *const this, Type1 &__result, Type2 arg1) { ... }\n\n改写函数原型，在参数中增加this指针，对每一个”nonstatic data member的存取操作”改为由this指针来存取\n\n将member function重写为一个外部函数，经过”mangling”处理（不需要处理的加上 extern “C”）\n\n实际上，普通函数、普通成员函数、静态成员函数到最后都会变成与C语言函数类似的普通函数，只是编译器在这些不同类型的函数身上做了不同的扩展，并放在不同的 scope 里面而已。\n\n编译器内部会将成员函数等价转换为非成员函数，具体是这样做的:\n\n1.改写成员函数的签名，使得其可以接受一个额外参数，这个额外参数即是this指针：\n\n```C++\nfloat Point::X();\n//成员函数X被插入额外参数this\nfloat Point:: X(Point* this );\n```\n\n当然如果成员函数是const的，插入的参数类型将为 const Point* 类型。\n\n2.将每一个对非静态数据成员的操作都改写为经过this操作。\n\n3.将成员函数写成一个外部函数，对函数名进行“mangling”处理，使之成为独一无二的名称。\n\n可以看出，将一个成员函数改写成一个外部函数的关键在于两点，一是给函数提供一个可以直接读写成员数据的通道；\n二是解决好有可能带来的名字冲突。第一点通过给函数提供一个额外的指针参数来解决，第二点则是通过一定的规则将名字转换，使之独一无二。\n\n于是在VC中对于上面的例子中的成员函数的调用将发生如下的转换：\n\n```C++\n//p->X();被转化为\n?X@Point@@QAEMXZ(p);\n//obj.X();被转化为\n?X@Point@@QAEMXZ(&obj);\n```\n\n覆盖（override）、重载（overload）、隐藏（hide, overwrite）的区别：\n\n- 覆盖（也叫重写）是指在派生类中重新对基类中的虚函数（注意是虚函数）重新实现。即函数名和参数都一样（函数签名一样），只是函数的实现体不一样。\n- 重载是指 **在同一个类中** 不同的函数使用相同的函数名，但是函数的参数个数或类型不同。调用的时候根据函数的参数来区别不同的函数。\n- 隐藏是指派生类中的函数把基类中相同名字的函数屏蔽掉了。隐藏与另外两个概念表面上看来很像，很难区分，其实他们的关键区别就是在多态的实现上。\n\n>C++多态（polymorphism）表示”以一个public base class的指针（或者reference），寻址出一个derived class object”\n\n我专门写了一篇关于这些容易弄混的概念的文章：[Override Overload Overwrite](../2017/11/14/Override-Overload-Overwrite)\n\n## Virtual Member Function\n\n如果function()是一个虚拟函数，那么用指针或引用进行的调用将发生一点特别的转换——一个中间层被引入进来。例如：\n\n```C++\n// p->function()\n//将转化为\n(*p->vptr[1])(p);\n```\n\n- 其中vptr为指向虚函数表的指针，它由编译器产生。vptr也要进行名字处理，因为一个继承体系可能有多个vptr。\n- 1是虚函数在虚函数表中的索引，通过它关联到虚函数function().\n\n何时发生这种转换？答案是在必需的时候 -- 一个再熟悉不过的答案。当通过指针调用的时候，要调用的函数实体无法在编译期决定，必需待到执行期才能获得，所以上面引入一个间接层的转换必不可少。但是当我们通过对象（不是引用，也不是指针）来调用的时候，\n进行上面的转换就显得多余了，因为在编译器要调用的函数实体已经被决定。此时调用发生的转换，与一个非静态成员函数(Nonstatic Member Functions)调用发生的转换一致。p.function()的处理就跟非静态成员函数一样了。\n\n## Static Member Function\n\n- 不能够直接存取其类中的非静态成员（nostatic members），包括不能调用非静态成员函数(Nonstatic Member Functions)。\n- 不能声明为const、volatile或virtual\n- 参数没有this\n- 可以不用对象访问，直接 类名::静态成员函数 访问，当然，通过对象调用也被允许\n\n需要注意的是通过一个表达式或函数对静态成员函数进行调用，被C++ Standard要求对表达式进行求值。如：\n\n```C++\n(a+=b).static_fuc();\nfunc().static_fuc();\n```\n\n虽然省去对a+b求值对于static_fuc()的调用并没有影响，但是程序员肯定会认为表达式a+=b已经执行，一旦编译器为了效率省去了这一步，很难说会浪费多少程序员多少时间去查找这个bug。这无疑是一个明智的规定。func()返回一个对象。\n\nvtable的内容：\n\n- virtual class offset（有虚基类才有）\n- topoffset\n- typeinfo\n- 继承基类所声明的虚函数实例，或者是覆盖（override）基类的虚函数\n- 新的虚函数（或者是纯虚函数占位）\n\n虚函数表的构造挺简单的：\n\n![虚函数表的构造](https://i.loli.net/2018/04/25/5ae01bb4b32a9.gif)\n\n从内存布局的角度看，类对象继承基类的时候只把基类的 nonstatic data member和member function（函数入口，也可以说是函数指针） 放进自己内存里，static data member和static function都在global address里面。然后就是虚函数表是复制了一份基类的虚函数表，然后把virtual实现了的部分替换掉，没实现的就不改，依然用父类的。然后虚函数表指针自然也要不一样，毕竟指向的内存地址不一样，对吧。\n","source":"_posts/2017/2017-10-23-Inside-the-C++-Object-Model-系列笔记--The-Semantics-of-Function.md","raw":"---\nlayout: post\ntitle: Inside the C++ Object Model 系列笔记 四 -- The Semantics of Function\ndate: 2017-10-23\ncategories: [读书笔记, 《Inside the C++ Object Model》]\ntags: [C++]\ncomments: true\n---\n\n>c++支持三种类型的成员函数，分别为static,nostatic,virtual。每一种调用方式都不尽相同。\n\n## nonstatic member function\n\nC++的设计准则之一就是:nonstatic member function至少必须和一般的nonmember function 有相同的效率。\n实际上，nonstatic member function 会被编译器进行如下的转换，变成一个普通函数:\n\nType1 X::foo(Type2 arg1) { ... }\n\n会被转换为如下的普通函数:\n\nvoid foo(X *const this, Type1 &__result, Type2 arg1) { ... }\n\n改写函数原型，在参数中增加this指针，对每一个”nonstatic data member的存取操作”改为由this指针来存取\n\n将member function重写为一个外部函数，经过”mangling”处理（不需要处理的加上 extern “C”）\n\n实际上，普通函数、普通成员函数、静态成员函数到最后都会变成与C语言函数类似的普通函数，只是编译器在这些不同类型的函数身上做了不同的扩展，并放在不同的 scope 里面而已。\n\n编译器内部会将成员函数等价转换为非成员函数，具体是这样做的:\n\n1.改写成员函数的签名，使得其可以接受一个额外参数，这个额外参数即是this指针：\n\n```C++\nfloat Point::X();\n//成员函数X被插入额外参数this\nfloat Point:: X(Point* this );\n```\n\n当然如果成员函数是const的，插入的参数类型将为 const Point* 类型。\n\n2.将每一个对非静态数据成员的操作都改写为经过this操作。\n\n3.将成员函数写成一个外部函数，对函数名进行“mangling”处理，使之成为独一无二的名称。\n\n可以看出，将一个成员函数改写成一个外部函数的关键在于两点，一是给函数提供一个可以直接读写成员数据的通道；\n二是解决好有可能带来的名字冲突。第一点通过给函数提供一个额外的指针参数来解决，第二点则是通过一定的规则将名字转换，使之独一无二。\n\n于是在VC中对于上面的例子中的成员函数的调用将发生如下的转换：\n\n```C++\n//p->X();被转化为\n?X@Point@@QAEMXZ(p);\n//obj.X();被转化为\n?X@Point@@QAEMXZ(&obj);\n```\n\n覆盖（override）、重载（overload）、隐藏（hide, overwrite）的区别：\n\n- 覆盖（也叫重写）是指在派生类中重新对基类中的虚函数（注意是虚函数）重新实现。即函数名和参数都一样（函数签名一样），只是函数的实现体不一样。\n- 重载是指 **在同一个类中** 不同的函数使用相同的函数名，但是函数的参数个数或类型不同。调用的时候根据函数的参数来区别不同的函数。\n- 隐藏是指派生类中的函数把基类中相同名字的函数屏蔽掉了。隐藏与另外两个概念表面上看来很像，很难区分，其实他们的关键区别就是在多态的实现上。\n\n>C++多态（polymorphism）表示”以一个public base class的指针（或者reference），寻址出一个derived class object”\n\n我专门写了一篇关于这些容易弄混的概念的文章：[Override Overload Overwrite](../2017/11/14/Override-Overload-Overwrite)\n\n## Virtual Member Function\n\n如果function()是一个虚拟函数，那么用指针或引用进行的调用将发生一点特别的转换——一个中间层被引入进来。例如：\n\n```C++\n// p->function()\n//将转化为\n(*p->vptr[1])(p);\n```\n\n- 其中vptr为指向虚函数表的指针，它由编译器产生。vptr也要进行名字处理，因为一个继承体系可能有多个vptr。\n- 1是虚函数在虚函数表中的索引，通过它关联到虚函数function().\n\n何时发生这种转换？答案是在必需的时候 -- 一个再熟悉不过的答案。当通过指针调用的时候，要调用的函数实体无法在编译期决定，必需待到执行期才能获得，所以上面引入一个间接层的转换必不可少。但是当我们通过对象（不是引用，也不是指针）来调用的时候，\n进行上面的转换就显得多余了，因为在编译器要调用的函数实体已经被决定。此时调用发生的转换，与一个非静态成员函数(Nonstatic Member Functions)调用发生的转换一致。p.function()的处理就跟非静态成员函数一样了。\n\n## Static Member Function\n\n- 不能够直接存取其类中的非静态成员（nostatic members），包括不能调用非静态成员函数(Nonstatic Member Functions)。\n- 不能声明为const、volatile或virtual\n- 参数没有this\n- 可以不用对象访问，直接 类名::静态成员函数 访问，当然，通过对象调用也被允许\n\n需要注意的是通过一个表达式或函数对静态成员函数进行调用，被C++ Standard要求对表达式进行求值。如：\n\n```C++\n(a+=b).static_fuc();\nfunc().static_fuc();\n```\n\n虽然省去对a+b求值对于static_fuc()的调用并没有影响，但是程序员肯定会认为表达式a+=b已经执行，一旦编译器为了效率省去了这一步，很难说会浪费多少程序员多少时间去查找这个bug。这无疑是一个明智的规定。func()返回一个对象。\n\nvtable的内容：\n\n- virtual class offset（有虚基类才有）\n- topoffset\n- typeinfo\n- 继承基类所声明的虚函数实例，或者是覆盖（override）基类的虚函数\n- 新的虚函数（或者是纯虚函数占位）\n\n虚函数表的构造挺简单的：\n\n![虚函数表的构造](https://i.loli.net/2018/04/25/5ae01bb4b32a9.gif)\n\n从内存布局的角度看，类对象继承基类的时候只把基类的 nonstatic data member和member function（函数入口，也可以说是函数指针） 放进自己内存里，static data member和static function都在global address里面。然后就是虚函数表是复制了一份基类的虚函数表，然后把virtual实现了的部分替换掉，没实现的就不改，依然用父类的。然后虚函数表指针自然也要不一样，毕竟指向的内存地址不一样，对吧。\n","slug":"Inside-the-C++-Object-Model-系列笔记--The-Semantics-of-Function","published":1,"updated":"2018-06-10T12:03:29.530Z","photos":[],"link":"","_id":"cjm2w8dd1001ffgpxg58cmriq","content":"<blockquote>\n<p>c++支持三种类型的成员函数，分别为static,nostatic,virtual。每一种调用方式都不尽相同。</p>\n</blockquote>\n<h2 id=\"nonstatic-member-function\"><a href=\"#nonstatic-member-function\" class=\"headerlink\" title=\"nonstatic member function\"></a>nonstatic member function</h2><p>C++的设计准则之一就是:nonstatic member function至少必须和一般的nonmember function 有相同的效率。<br>实际上，nonstatic member function 会被编译器进行如下的转换，变成一个普通函数:</p>\n<p>Type1 X::foo(Type2 arg1) { … }</p>\n<p>会被转换为如下的普通函数:</p>\n<p>void foo(X *const this, Type1 &amp;__result, Type2 arg1) { … }</p>\n<p>改写函数原型，在参数中增加this指针，对每一个”nonstatic data member的存取操作”改为由this指针来存取</p>\n<p>将member function重写为一个外部函数，经过”mangling”处理（不需要处理的加上 extern “C”）</p>\n<p>实际上，普通函数、普通成员函数、静态成员函数到最后都会变成与C语言函数类似的普通函数，只是编译器在这些不同类型的函数身上做了不同的扩展，并放在不同的 scope 里面而已。</p>\n<p>编译器内部会将成员函数等价转换为非成员函数，具体是这样做的:</p>\n<p>1.改写成员函数的签名，使得其可以接受一个额外参数，这个额外参数即是this指针：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">float</span> Point::X();</span><br><span class=\"line\"><span class=\"comment\">//成员函数X被插入额外参数this</span></span><br><span class=\"line\"><span class=\"keyword\">float</span> Point:: X(Point* <span class=\"keyword\">this</span> );</span><br></pre></td></tr></table></figure>\n<p>当然如果成员函数是const的，插入的参数类型将为 const Point* 类型。</p>\n<p>2.将每一个对非静态数据成员的操作都改写为经过this操作。</p>\n<p>3.将成员函数写成一个外部函数，对函数名进行“mangling”处理，使之成为独一无二的名称。</p>\n<p>可以看出，将一个成员函数改写成一个外部函数的关键在于两点，一是给函数提供一个可以直接读写成员数据的通道；<br>二是解决好有可能带来的名字冲突。第一点通过给函数提供一个额外的指针参数来解决，第二点则是通过一定的规则将名字转换，使之独一无二。</p>\n<p>于是在VC中对于上面的例子中的成员函数的调用将发生如下的转换：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//p-&gt;X();被转化为</span></span><br><span class=\"line\">?X@Point@@QAEMXZ(p);</span><br><span class=\"line\"><span class=\"comment\">//obj.X();被转化为</span></span><br><span class=\"line\">?X@Point@@QAEMXZ(&amp;obj);</span><br></pre></td></tr></table></figure>\n<p>覆盖（override）、重载（overload）、隐藏（hide, overwrite）的区别：</p>\n<ul>\n<li>覆盖（也叫重写）是指在派生类中重新对基类中的虚函数（注意是虚函数）重新实现。即函数名和参数都一样（函数签名一样），只是函数的实现体不一样。</li>\n<li>重载是指 <strong>在同一个类中</strong> 不同的函数使用相同的函数名，但是函数的参数个数或类型不同。调用的时候根据函数的参数来区别不同的函数。</li>\n<li>隐藏是指派生类中的函数把基类中相同名字的函数屏蔽掉了。隐藏与另外两个概念表面上看来很像，很难区分，其实他们的关键区别就是在多态的实现上。</li>\n</ul>\n<blockquote>\n<p>C++多态（polymorphism）表示”以一个public base class的指针（或者reference），寻址出一个derived class object”</p>\n</blockquote>\n<p>我专门写了一篇关于这些容易弄混的概念的文章：<a href=\"../2017/11/14/Override-Overload-Overwrite\">Override Overload Overwrite</a></p>\n<h2 id=\"Virtual-Member-Function\"><a href=\"#Virtual-Member-Function\" class=\"headerlink\" title=\"Virtual Member Function\"></a>Virtual Member Function</h2><p>如果function()是一个虚拟函数，那么用指针或引用进行的调用将发生一点特别的转换——一个中间层被引入进来。例如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// p-&gt;function()</span></span><br><span class=\"line\"><span class=\"comment\">//将转化为</span></span><br><span class=\"line\">(*p-&gt;vptr[<span class=\"number\">1</span>])(p);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>其中vptr为指向虚函数表的指针，它由编译器产生。vptr也要进行名字处理，因为一个继承体系可能有多个vptr。</li>\n<li>1是虚函数在虚函数表中的索引，通过它关联到虚函数function().</li>\n</ul>\n<p>何时发生这种转换？答案是在必需的时候 – 一个再熟悉不过的答案。当通过指针调用的时候，要调用的函数实体无法在编译期决定，必需待到执行期才能获得，所以上面引入一个间接层的转换必不可少。但是当我们通过对象（不是引用，也不是指针）来调用的时候，<br>进行上面的转换就显得多余了，因为在编译器要调用的函数实体已经被决定。此时调用发生的转换，与一个非静态成员函数(Nonstatic Member Functions)调用发生的转换一致。p.function()的处理就跟非静态成员函数一样了。</p>\n<h2 id=\"Static-Member-Function\"><a href=\"#Static-Member-Function\" class=\"headerlink\" title=\"Static Member Function\"></a>Static Member Function</h2><ul>\n<li>不能够直接存取其类中的非静态成员（nostatic members），包括不能调用非静态成员函数(Nonstatic Member Functions)。</li>\n<li>不能声明为const、volatile或virtual</li>\n<li>参数没有this</li>\n<li>可以不用对象访问，直接 类名::静态成员函数 访问，当然，通过对象调用也被允许</li>\n</ul>\n<p>需要注意的是通过一个表达式或函数对静态成员函数进行调用，被C++ Standard要求对表达式进行求值。如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(a+=b).static_fuc();</span><br><span class=\"line\">func().static_fuc();</span><br></pre></td></tr></table></figure>\n<p>虽然省去对a+b求值对于static_fuc()的调用并没有影响，但是程序员肯定会认为表达式a+=b已经执行，一旦编译器为了效率省去了这一步，很难说会浪费多少程序员多少时间去查找这个bug。这无疑是一个明智的规定。func()返回一个对象。</p>\n<p>vtable的内容：</p>\n<ul>\n<li>virtual class offset（有虚基类才有）</li>\n<li>topoffset</li>\n<li>typeinfo</li>\n<li>继承基类所声明的虚函数实例，或者是覆盖（override）基类的虚函数</li>\n<li>新的虚函数（或者是纯虚函数占位）</li>\n</ul>\n<p>虚函数表的构造挺简单的：</p>\n<p><img src=\"https://i.loli.net/2018/04/25/5ae01bb4b32a9.gif\" alt=\"虚函数表的构造\"></p>\n<p>从内存布局的角度看，类对象继承基类的时候只把基类的 nonstatic data member和member function（函数入口，也可以说是函数指针） 放进自己内存里，static data member和static function都在global address里面。然后就是虚函数表是复制了一份基类的虚函数表，然后把virtual实现了的部分替换掉，没实现的就不改，依然用父类的。然后虚函数表指针自然也要不一样，毕竟指向的内存地址不一样，对吧。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>c++支持三种类型的成员函数，分别为static,nostatic,virtual。每一种调用方式都不尽相同。</p>\n</blockquote>\n<h2 id=\"nonstatic-member-function\"><a href=\"#nonstatic-member-function\" class=\"headerlink\" title=\"nonstatic member function\"></a>nonstatic member function</h2><p>C++的设计准则之一就是:nonstatic member function至少必须和一般的nonmember function 有相同的效率。<br>实际上，nonstatic member function 会被编译器进行如下的转换，变成一个普通函数:</p>\n<p>Type1 X::foo(Type2 arg1) { … }</p>\n<p>会被转换为如下的普通函数:</p>\n<p>void foo(X *const this, Type1 &amp;__result, Type2 arg1) { … }</p>\n<p>改写函数原型，在参数中增加this指针，对每一个”nonstatic data member的存取操作”改为由this指针来存取</p>\n<p>将member function重写为一个外部函数，经过”mangling”处理（不需要处理的加上 extern “C”）</p>\n<p>实际上，普通函数、普通成员函数、静态成员函数到最后都会变成与C语言函数类似的普通函数，只是编译器在这些不同类型的函数身上做了不同的扩展，并放在不同的 scope 里面而已。</p>\n<p>编译器内部会将成员函数等价转换为非成员函数，具体是这样做的:</p>\n<p>1.改写成员函数的签名，使得其可以接受一个额外参数，这个额外参数即是this指针：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">float</span> Point::X();</span><br><span class=\"line\"><span class=\"comment\">//成员函数X被插入额外参数this</span></span><br><span class=\"line\"><span class=\"keyword\">float</span> Point:: X(Point* <span class=\"keyword\">this</span> );</span><br></pre></td></tr></table></figure>\n<p>当然如果成员函数是const的，插入的参数类型将为 const Point* 类型。</p>\n<p>2.将每一个对非静态数据成员的操作都改写为经过this操作。</p>\n<p>3.将成员函数写成一个外部函数，对函数名进行“mangling”处理，使之成为独一无二的名称。</p>\n<p>可以看出，将一个成员函数改写成一个外部函数的关键在于两点，一是给函数提供一个可以直接读写成员数据的通道；<br>二是解决好有可能带来的名字冲突。第一点通过给函数提供一个额外的指针参数来解决，第二点则是通过一定的规则将名字转换，使之独一无二。</p>\n<p>于是在VC中对于上面的例子中的成员函数的调用将发生如下的转换：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//p-&gt;X();被转化为</span></span><br><span class=\"line\">?X@Point@@QAEMXZ(p);</span><br><span class=\"line\"><span class=\"comment\">//obj.X();被转化为</span></span><br><span class=\"line\">?X@Point@@QAEMXZ(&amp;obj);</span><br></pre></td></tr></table></figure>\n<p>覆盖（override）、重载（overload）、隐藏（hide, overwrite）的区别：</p>\n<ul>\n<li>覆盖（也叫重写）是指在派生类中重新对基类中的虚函数（注意是虚函数）重新实现。即函数名和参数都一样（函数签名一样），只是函数的实现体不一样。</li>\n<li>重载是指 <strong>在同一个类中</strong> 不同的函数使用相同的函数名，但是函数的参数个数或类型不同。调用的时候根据函数的参数来区别不同的函数。</li>\n<li>隐藏是指派生类中的函数把基类中相同名字的函数屏蔽掉了。隐藏与另外两个概念表面上看来很像，很难区分，其实他们的关键区别就是在多态的实现上。</li>\n</ul>\n<blockquote>\n<p>C++多态（polymorphism）表示”以一个public base class的指针（或者reference），寻址出一个derived class object”</p>\n</blockquote>\n<p>我专门写了一篇关于这些容易弄混的概念的文章：<a href=\"../2017/11/14/Override-Overload-Overwrite\">Override Overload Overwrite</a></p>\n<h2 id=\"Virtual-Member-Function\"><a href=\"#Virtual-Member-Function\" class=\"headerlink\" title=\"Virtual Member Function\"></a>Virtual Member Function</h2><p>如果function()是一个虚拟函数，那么用指针或引用进行的调用将发生一点特别的转换——一个中间层被引入进来。例如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// p-&gt;function()</span></span><br><span class=\"line\"><span class=\"comment\">//将转化为</span></span><br><span class=\"line\">(*p-&gt;vptr[<span class=\"number\">1</span>])(p);</span><br></pre></td></tr></table></figure>\n<ul>\n<li>其中vptr为指向虚函数表的指针，它由编译器产生。vptr也要进行名字处理，因为一个继承体系可能有多个vptr。</li>\n<li>1是虚函数在虚函数表中的索引，通过它关联到虚函数function().</li>\n</ul>\n<p>何时发生这种转换？答案是在必需的时候 – 一个再熟悉不过的答案。当通过指针调用的时候，要调用的函数实体无法在编译期决定，必需待到执行期才能获得，所以上面引入一个间接层的转换必不可少。但是当我们通过对象（不是引用，也不是指针）来调用的时候，<br>进行上面的转换就显得多余了，因为在编译器要调用的函数实体已经被决定。此时调用发生的转换，与一个非静态成员函数(Nonstatic Member Functions)调用发生的转换一致。p.function()的处理就跟非静态成员函数一样了。</p>\n<h2 id=\"Static-Member-Function\"><a href=\"#Static-Member-Function\" class=\"headerlink\" title=\"Static Member Function\"></a>Static Member Function</h2><ul>\n<li>不能够直接存取其类中的非静态成员（nostatic members），包括不能调用非静态成员函数(Nonstatic Member Functions)。</li>\n<li>不能声明为const、volatile或virtual</li>\n<li>参数没有this</li>\n<li>可以不用对象访问，直接 类名::静态成员函数 访问，当然，通过对象调用也被允许</li>\n</ul>\n<p>需要注意的是通过一个表达式或函数对静态成员函数进行调用，被C++ Standard要求对表达式进行求值。如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(a+=b).static_fuc();</span><br><span class=\"line\">func().static_fuc();</span><br></pre></td></tr></table></figure>\n<p>虽然省去对a+b求值对于static_fuc()的调用并没有影响，但是程序员肯定会认为表达式a+=b已经执行，一旦编译器为了效率省去了这一步，很难说会浪费多少程序员多少时间去查找这个bug。这无疑是一个明智的规定。func()返回一个对象。</p>\n<p>vtable的内容：</p>\n<ul>\n<li>virtual class offset（有虚基类才有）</li>\n<li>topoffset</li>\n<li>typeinfo</li>\n<li>继承基类所声明的虚函数实例，或者是覆盖（override）基类的虚函数</li>\n<li>新的虚函数（或者是纯虚函数占位）</li>\n</ul>\n<p>虚函数表的构造挺简单的：</p>\n<p><img src=\"https://i.loli.net/2018/04/25/5ae01bb4b32a9.gif\" alt=\"虚函数表的构造\"></p>\n<p>从内存布局的角度看，类对象继承基类的时候只把基类的 nonstatic data member和member function（函数入口，也可以说是函数指针） 放进自己内存里，static data member和static function都在global address里面。然后就是虚函数表是复制了一份基类的虚函数表，然后把virtual实现了的部分替换掉，没实现的就不改，依然用父类的。然后虚函数表指针自然也要不一样，毕竟指向的内存地址不一样，对吧。</p>\n"},{"title":"Override Overload Overwrite","date":"2017-11-13T16:00:00.000Z","comments":1,"_content":"\n我们都知道有些东西容易混淆，在加上中文翻译得乱七八糟，更加让人困惑。今天我要讲的这三位可就真是绝了。\n\n它们是：Override、Overload、Overwrite。\n\n这是我查有道词典时候看到的可怕一幕：\n\n![](https://wx4.sinaimg.cn/mw690/006zFO3ggy1flhl8a9e69j312w0tatf9.jpg)\n\nOverride 一个把三个名字都占了，你怕不怕？反正我是看的心里一紧。\n\n如果把概念都煮成了一锅粥，那还不如不要记这些概念，你应该向更深层次去探寻。就这三个的区别来说，我觉得主要理解两个概念就行了：\n\n1. 函数签名（signature）\n2. 多态（polymorphism、polymorphic）\n\n## 函数签名\n\n函数签名是什么，其实就是用来区别函数的，两个函数怎么样认定是不同的两个函数呢，只有两个方面：\n\n1. 函数名\n2. 参数\n\n有人说还有返回值啊，不行，返回值不能作为函数签名的一部分，因为你调用一个函数的时候，返回值根本不能帮助编译器来识别你用的是哪个函数，比如：\n\n```C++\nint func(int a, int b);\nfloat func(int a, int b);\n\nfunc();\n```\n\n请问我使用的是哪个函数？你看返回值确实不行吧。\n\n## 多态\n\n多态是面向对象编程的概念，你可以看看它的准确定义：\n\n[Polymorphism](https://en.wikipedia.org/wiki/Polymorphism_(computer_science))。\n\n定义很简短：polymorphism is the provision of a single interface to entities of different types.\n\n[The Java™ Tutorials](https://docs.oracle.com/javase/tutorial/java/IandI/polymorphism.html)\n\n如果父类有一个函数，子类也定义了一个完全相同的函数（函数签名相同），那么你可以用父类指针（或者说父类对象）作为统一的接口，来调用子类的方法。比如：\n\n```C++\nclass Vehicle{\n    public void move(){\n        System.out.println(“Vehicles can move!!”);\n    }\n}\n\nclass MotorBike extends Vehicle{\n    public void move(){\n        System.out.println(“MotorBike can move and accelerate too!!”);\n    }\n}\nclass Car extends Vehicle{\n    public void move(){\n        System.out.println(“Hi! I am a car!”);\n    }\n}\n\nclass Test{\n    public static void main(String[] args){\n        Vehicle vh = new MotorBike();\n        vh.move();    // prints MotorBike can move and accelerate too!!\n        vh = new Vehicle();\n        vh.move();    // prints Vehicles can move!!\n        vh = new Car();\n        vh.move();   // prints Hi! I am a car!\n    }\n}\n```\n\n多态的好处是可以扩展啊，比如我后来又多了个 truck 类，我不需要去动已经写好的代码，只要把 truck 模块写好，加进去就行了。\n\n## Override、Overload、Overwrite 的区别\n\n好了，知道了这两个概念，我们再来看看上面的那三个混在一起的东西：\n\n- Override（推翻，对英文意思就是这个）subclass method overrides base class method means:\n  - in different range (in derived class and base class)\n  - the same function signature\n  - the base class method is virtual（if in C++）\n- overload（超载）function overloading means:\n  - the same range (in the same class)\n  - the same function name\n  - but different function signature\n- overwrite（重写）subclass method hides base class method means:\n  - in different range (in derived class and base class)\n  - the same function name\n\n我们应该记住只有 Override 才跟多态有关。\n\nOverload 是本class 里面的不同函数（只不过函数名一样罢了，其实是两个不同的函数，看两个函数是否是同一个函数就看函数签名就行了），其实没啥稀奇的，不就是函数名一样嘛。函数签名一样，区分出是用父类还是子类的函数，这才是面向对象和多态要解决的问题。\n\n## Override 和 Overwrite 的区别\n\n>比较容易混淆的其实是 Override 和 Overwrite，但你只要死记住：Override 必须函数签名要一样，而 Overwrite 只需函数名一样即可。另外 C++ 中一定要用virtual才算 Override，而 Java 默认就是 Override，不需要修饰词。\n\n>这里关于 Java 和 C++ 面向对象的细节区别可以写一大堆，比如：C++ class 后面是要加分号的，而 Java 不需要；但 Java 的类名是和文件名要一致的，而且只能有一个 public 类，而 C++不需要；Java 直接就能用 Override，而 C++必须要使用 virtual 关键字才能使用 Override（虚函数）；Java 的抽象方法跟 C++的纯虚函数对应。Java 是单继承，由接口来实现“多继承”，C++是多继承，没有接口，只有抽象类。C++还有个虚基类的概念。具体的写法上还有很多的不同，多用这两种语言写面向对象的代码，就慢慢会知道了。\n\nC++ 有一个 virtual 关键字和 virtual table 这个概念，没有加 virtual 的父类函数是不可能形成多态的，如果这时候你碰到父类和子类两个里面有同名的函数，那么就属于 Overwrite 这个概念了，你其实也可以称这种覆盖掉父类函数的行为为：hide 隐藏。Java 这种语言里面没有 virtual 这一套，Java 也可以表现出 Overwrite，但要注意函数签名如果一样的话，那又不叫 Overwrite 了，应该叫 Override 了（Java 如果要在子类中使用父类的同函数签名方法，则必须使用 super 关键字）。而 C++ 不一样，即便是函数签名一样，如果前面不加 virtual 是不能叫 Override 的，仍然属于 Overwrite 的概念。请看下面的例子：\n\n用 C++ 写的话：\n\n```C++\n#include <iostream>\n\nusing std::cout;\nusing std::endl;\n\nclass A{\npublic:\n    void func(int a){\n        cout << \"A\" << endl;\n    }\n};\n\nclass B:public A{\npublic:\n    void func(int a){\n        cout << \"B\" << endl;\n    }\n};\n\nint main(){\n    A *a = new B();\n    a->func(1);\n    ((B*)a)->func(1);\n    return 0;\n}\n```\n\n结果输出：\n\n```\nA\nB\n```\n\n可以看到，C++必须要用子类类型的指针才能访问到子类的部分（建议看一本书，叫：Inside the C++ Object Model，中文叫：深入C++对象模型，里面讲对象的内存布局讲的很清楚），java 也一样，必须转成子类型的指针才能访问，否则 IDE 会报错提示你。\n\nJava 代码：\n\n```C++\npublic class test {\n\n    class A{\n        void func(int a){\n            System.out.println(\"A\");\n        }\n    }\n    class B extends A{\n        void func(int a, int b){\n            System.out.println(\"B\");\n        }\n    }\n\n    public static void main(String[] args){\n        test t = new test();\n        A a = t.new B();\n        a.fun(1);\n        ((B)a).func(1,2);\n    }\n}\n```\n\n结果输出：\n\n```\nA\nB\n```\n\n为什么 Java 代码里不像 C++ 代码里面那样，使用两个函数签名相同的函数？因为前面说过了，那样的话就变成 Override 了，只有在 C++ 里才能实现函数签名相同的 Overwrite（不使用virtual即可）。\n","source":"_posts/2017/2017-11-14-Override-Overload-Overwrite.md","raw":"---\ntitle: Override Overload Overwrite\ndate: 2017-11-14\ncategories: [编程范式, 面向对象编程]\ncomments: true\n---\n\n我们都知道有些东西容易混淆，在加上中文翻译得乱七八糟，更加让人困惑。今天我要讲的这三位可就真是绝了。\n\n它们是：Override、Overload、Overwrite。\n\n这是我查有道词典时候看到的可怕一幕：\n\n![](https://wx4.sinaimg.cn/mw690/006zFO3ggy1flhl8a9e69j312w0tatf9.jpg)\n\nOverride 一个把三个名字都占了，你怕不怕？反正我是看的心里一紧。\n\n如果把概念都煮成了一锅粥，那还不如不要记这些概念，你应该向更深层次去探寻。就这三个的区别来说，我觉得主要理解两个概念就行了：\n\n1. 函数签名（signature）\n2. 多态（polymorphism、polymorphic）\n\n## 函数签名\n\n函数签名是什么，其实就是用来区别函数的，两个函数怎么样认定是不同的两个函数呢，只有两个方面：\n\n1. 函数名\n2. 参数\n\n有人说还有返回值啊，不行，返回值不能作为函数签名的一部分，因为你调用一个函数的时候，返回值根本不能帮助编译器来识别你用的是哪个函数，比如：\n\n```C++\nint func(int a, int b);\nfloat func(int a, int b);\n\nfunc();\n```\n\n请问我使用的是哪个函数？你看返回值确实不行吧。\n\n## 多态\n\n多态是面向对象编程的概念，你可以看看它的准确定义：\n\n[Polymorphism](https://en.wikipedia.org/wiki/Polymorphism_(computer_science))。\n\n定义很简短：polymorphism is the provision of a single interface to entities of different types.\n\n[The Java™ Tutorials](https://docs.oracle.com/javase/tutorial/java/IandI/polymorphism.html)\n\n如果父类有一个函数，子类也定义了一个完全相同的函数（函数签名相同），那么你可以用父类指针（或者说父类对象）作为统一的接口，来调用子类的方法。比如：\n\n```C++\nclass Vehicle{\n    public void move(){\n        System.out.println(“Vehicles can move!!”);\n    }\n}\n\nclass MotorBike extends Vehicle{\n    public void move(){\n        System.out.println(“MotorBike can move and accelerate too!!”);\n    }\n}\nclass Car extends Vehicle{\n    public void move(){\n        System.out.println(“Hi! I am a car!”);\n    }\n}\n\nclass Test{\n    public static void main(String[] args){\n        Vehicle vh = new MotorBike();\n        vh.move();    // prints MotorBike can move and accelerate too!!\n        vh = new Vehicle();\n        vh.move();    // prints Vehicles can move!!\n        vh = new Car();\n        vh.move();   // prints Hi! I am a car!\n    }\n}\n```\n\n多态的好处是可以扩展啊，比如我后来又多了个 truck 类，我不需要去动已经写好的代码，只要把 truck 模块写好，加进去就行了。\n\n## Override、Overload、Overwrite 的区别\n\n好了，知道了这两个概念，我们再来看看上面的那三个混在一起的东西：\n\n- Override（推翻，对英文意思就是这个）subclass method overrides base class method means:\n  - in different range (in derived class and base class)\n  - the same function signature\n  - the base class method is virtual（if in C++）\n- overload（超载）function overloading means:\n  - the same range (in the same class)\n  - the same function name\n  - but different function signature\n- overwrite（重写）subclass method hides base class method means:\n  - in different range (in derived class and base class)\n  - the same function name\n\n我们应该记住只有 Override 才跟多态有关。\n\nOverload 是本class 里面的不同函数（只不过函数名一样罢了，其实是两个不同的函数，看两个函数是否是同一个函数就看函数签名就行了），其实没啥稀奇的，不就是函数名一样嘛。函数签名一样，区分出是用父类还是子类的函数，这才是面向对象和多态要解决的问题。\n\n## Override 和 Overwrite 的区别\n\n>比较容易混淆的其实是 Override 和 Overwrite，但你只要死记住：Override 必须函数签名要一样，而 Overwrite 只需函数名一样即可。另外 C++ 中一定要用virtual才算 Override，而 Java 默认就是 Override，不需要修饰词。\n\n>这里关于 Java 和 C++ 面向对象的细节区别可以写一大堆，比如：C++ class 后面是要加分号的，而 Java 不需要；但 Java 的类名是和文件名要一致的，而且只能有一个 public 类，而 C++不需要；Java 直接就能用 Override，而 C++必须要使用 virtual 关键字才能使用 Override（虚函数）；Java 的抽象方法跟 C++的纯虚函数对应。Java 是单继承，由接口来实现“多继承”，C++是多继承，没有接口，只有抽象类。C++还有个虚基类的概念。具体的写法上还有很多的不同，多用这两种语言写面向对象的代码，就慢慢会知道了。\n\nC++ 有一个 virtual 关键字和 virtual table 这个概念，没有加 virtual 的父类函数是不可能形成多态的，如果这时候你碰到父类和子类两个里面有同名的函数，那么就属于 Overwrite 这个概念了，你其实也可以称这种覆盖掉父类函数的行为为：hide 隐藏。Java 这种语言里面没有 virtual 这一套，Java 也可以表现出 Overwrite，但要注意函数签名如果一样的话，那又不叫 Overwrite 了，应该叫 Override 了（Java 如果要在子类中使用父类的同函数签名方法，则必须使用 super 关键字）。而 C++ 不一样，即便是函数签名一样，如果前面不加 virtual 是不能叫 Override 的，仍然属于 Overwrite 的概念。请看下面的例子：\n\n用 C++ 写的话：\n\n```C++\n#include <iostream>\n\nusing std::cout;\nusing std::endl;\n\nclass A{\npublic:\n    void func(int a){\n        cout << \"A\" << endl;\n    }\n};\n\nclass B:public A{\npublic:\n    void func(int a){\n        cout << \"B\" << endl;\n    }\n};\n\nint main(){\n    A *a = new B();\n    a->func(1);\n    ((B*)a)->func(1);\n    return 0;\n}\n```\n\n结果输出：\n\n```\nA\nB\n```\n\n可以看到，C++必须要用子类类型的指针才能访问到子类的部分（建议看一本书，叫：Inside the C++ Object Model，中文叫：深入C++对象模型，里面讲对象的内存布局讲的很清楚），java 也一样，必须转成子类型的指针才能访问，否则 IDE 会报错提示你。\n\nJava 代码：\n\n```C++\npublic class test {\n\n    class A{\n        void func(int a){\n            System.out.println(\"A\");\n        }\n    }\n    class B extends A{\n        void func(int a, int b){\n            System.out.println(\"B\");\n        }\n    }\n\n    public static void main(String[] args){\n        test t = new test();\n        A a = t.new B();\n        a.fun(1);\n        ((B)a).func(1,2);\n    }\n}\n```\n\n结果输出：\n\n```\nA\nB\n```\n\n为什么 Java 代码里不像 C++ 代码里面那样，使用两个函数签名相同的函数？因为前面说过了，那样的话就变成 Override 了，只有在 C++ 里才能实现函数签名相同的 Overwrite（不使用virtual即可）。\n","slug":"Override-Overload-Overwrite","published":1,"updated":"2018-06-10T12:03:47.230Z","layout":"post","photos":[],"link":"","_id":"cjm2w8dd3001jfgpxc07847if","content":"<p>我们都知道有些东西容易混淆，在加上中文翻译得乱七八糟，更加让人困惑。今天我要讲的这三位可就真是绝了。</p>\n<p>它们是：Override、Overload、Overwrite。</p>\n<p>这是我查有道词典时候看到的可怕一幕：</p>\n<p><img src=\"https://wx4.sinaimg.cn/mw690/006zFO3ggy1flhl8a9e69j312w0tatf9.jpg\" alt=\"\"></p>\n<p>Override 一个把三个名字都占了，你怕不怕？反正我是看的心里一紧。</p>\n<p>如果把概念都煮成了一锅粥，那还不如不要记这些概念，你应该向更深层次去探寻。就这三个的区别来说，我觉得主要理解两个概念就行了：</p>\n<ol>\n<li>函数签名（signature）</li>\n<li>多态（polymorphism、polymorphic）</li>\n</ol>\n<h2 id=\"函数签名\"><a href=\"#函数签名\" class=\"headerlink\" title=\"函数签名\"></a>函数签名</h2><p>函数签名是什么，其实就是用来区别函数的，两个函数怎么样认定是不同的两个函数呢，只有两个方面：</p>\n<ol>\n<li>函数名</li>\n<li>参数</li>\n</ol>\n<p>有人说还有返回值啊，不行，返回值不能作为函数签名的一部分，因为你调用一个函数的时候，返回值根本不能帮助编译器来识别你用的是哪个函数，比如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">float</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">func();</span><br></pre></td></tr></table></figure>\n<p>请问我使用的是哪个函数？你看返回值确实不行吧。</p>\n<h2 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h2><p>多态是面向对象编程的概念，你可以看看它的准确定义：</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Polymorphism_(computer_science\" target=\"_blank\" rel=\"noopener\">Polymorphism</a>)。</p>\n<p>定义很简短：polymorphism is the provision of a single interface to entities of different types.</p>\n<p><a href=\"https://docs.oracle.com/javase/tutorial/java/IandI/polymorphism.html\" target=\"_blank\" rel=\"noopener\">The Java™ Tutorials</a></p>\n<p>如果父类有一个函数，子类也定义了一个完全相同的函数（函数签名相同），那么你可以用父类指针（或者说父类对象）作为统一的接口，来调用子类的方法。比如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vehicle</span>&#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">move</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(“Vehicles can move!!”);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MotorBike</span> <span class=\"title\">extends</span> <span class=\"title\">Vehicle</span>&#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">move</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(“MotorBike can move <span class=\"keyword\">and</span> accelerate too!!”);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Car</span> <span class=\"title\">extends</span> <span class=\"title\">Vehicle</span>&#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">move</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(“Hi! I am a car!”);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span>&#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Vehicle vh = <span class=\"keyword\">new</span> MotorBike();</span><br><span class=\"line\">        vh.move();    <span class=\"comment\">// prints MotorBike can move and accelerate too!!</span></span><br><span class=\"line\">        vh = <span class=\"keyword\">new</span> Vehicle();</span><br><span class=\"line\">        vh.move();    <span class=\"comment\">// prints Vehicles can move!!</span></span><br><span class=\"line\">        vh = <span class=\"keyword\">new</span> Car();</span><br><span class=\"line\">        vh.move();   <span class=\"comment\">// prints Hi! I am a car!</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>多态的好处是可以扩展啊，比如我后来又多了个 truck 类，我不需要去动已经写好的代码，只要把 truck 模块写好，加进去就行了。</p>\n<h2 id=\"Override、Overload、Overwrite-的区别\"><a href=\"#Override、Overload、Overwrite-的区别\" class=\"headerlink\" title=\"Override、Overload、Overwrite 的区别\"></a>Override、Overload、Overwrite 的区别</h2><p>好了，知道了这两个概念，我们再来看看上面的那三个混在一起的东西：</p>\n<ul>\n<li>Override（推翻，对英文意思就是这个）subclass method overrides base class method means:<ul>\n<li>in different range (in derived class and base class)</li>\n<li>the same function signature</li>\n<li>the base class method is virtual（if in C++）</li>\n</ul>\n</li>\n<li>overload（超载）function overloading means:<ul>\n<li>the same range (in the same class)</li>\n<li>the same function name</li>\n<li>but different function signature</li>\n</ul>\n</li>\n<li>overwrite（重写）subclass method hides base class method means:<ul>\n<li>in different range (in derived class and base class)</li>\n<li>the same function name</li>\n</ul>\n</li>\n</ul>\n<p>我们应该记住只有 Override 才跟多态有关。</p>\n<p>Overload 是本class 里面的不同函数（只不过函数名一样罢了，其实是两个不同的函数，看两个函数是否是同一个函数就看函数签名就行了），其实没啥稀奇的，不就是函数名一样嘛。函数签名一样，区分出是用父类还是子类的函数，这才是面向对象和多态要解决的问题。</p>\n<h2 id=\"Override-和-Overwrite-的区别\"><a href=\"#Override-和-Overwrite-的区别\" class=\"headerlink\" title=\"Override 和 Overwrite 的区别\"></a>Override 和 Overwrite 的区别</h2><blockquote>\n<p>比较容易混淆的其实是 Override 和 Overwrite，但你只要死记住：Override 必须函数签名要一样，而 Overwrite 只需函数名一样即可。另外 C++ 中一定要用virtual才算 Override，而 Java 默认就是 Override，不需要修饰词。</p>\n</blockquote>\n<blockquote>\n<p>这里关于 Java 和 C++ 面向对象的细节区别可以写一大堆，比如：C++ class 后面是要加分号的，而 Java 不需要；但 Java 的类名是和文件名要一致的，而且只能有一个 public 类，而 C++不需要；Java 直接就能用 Override，而 C++必须要使用 virtual 关键字才能使用 Override（虚函数）；Java 的抽象方法跟 C++的纯虚函数对应。Java 是单继承，由接口来实现“多继承”，C++是多继承，没有接口，只有抽象类。C++还有个虚基类的概念。具体的写法上还有很多的不同，多用这两种语言写面向对象的代码，就慢慢会知道了。</p>\n</blockquote>\n<p>C++ 有一个 virtual 关键字和 virtual table 这个概念，没有加 virtual 的父类函数是不可能形成多态的，如果这时候你碰到父类和子类两个里面有同名的函数，那么就属于 Overwrite 这个概念了，你其实也可以称这种覆盖掉父类函数的行为为：hide 隐藏。Java 这种语言里面没有 virtual 这一套，Java 也可以表现出 Overwrite，但要注意函数签名如果一样的话，那又不叫 Overwrite 了，应该叫 Override 了（Java 如果要在子类中使用父类的同函数签名方法，则必须使用 super 关键字）。而 C++ 不一样，即便是函数签名一样，如果前面不加 virtual 是不能叫 Override 的，仍然属于 Overwrite 的概念。请看下面的例子：</p>\n<p>用 C++ 写的话：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> a)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"A\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span>:</span><span class=\"keyword\">public</span> A&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> a)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"B\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    A *a = <span class=\"keyword\">new</span> B();</span><br><span class=\"line\">    a-&gt;func(<span class=\"number\">1</span>);</span><br><span class=\"line\">    ((B*)a)-&gt;func(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A</span><br><span class=\"line\">B</span><br></pre></td></tr></table></figure>\n<p>可以看到，C++必须要用子类类型的指针才能访问到子类的部分（建议看一本书，叫：Inside the C++ Object Model，中文叫：深入C++对象模型，里面讲对象的内存布局讲的很清楚），java 也一样，必须转成子类型的指针才能访问，否则 IDE 会报错提示你。</p>\n<p>Java 代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">test</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>&#123;</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> a)</span></span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"A\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"title\">extends</span> <span class=\"title\">A</span>&#123;</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"B\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        test t = <span class=\"keyword\">new</span> test();</span><br><span class=\"line\">        A a = t.<span class=\"keyword\">new</span> B();</span><br><span class=\"line\">        a.fun(<span class=\"number\">1</span>);</span><br><span class=\"line\">        ((B)a).func(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A</span><br><span class=\"line\">B</span><br></pre></td></tr></table></figure>\n<p>为什么 Java 代码里不像 C++ 代码里面那样，使用两个函数签名相同的函数？因为前面说过了，那样的话就变成 Override 了，只有在 C++ 里才能实现函数签名相同的 Overwrite（不使用virtual即可）。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>我们都知道有些东西容易混淆，在加上中文翻译得乱七八糟，更加让人困惑。今天我要讲的这三位可就真是绝了。</p>\n<p>它们是：Override、Overload、Overwrite。</p>\n<p>这是我查有道词典时候看到的可怕一幕：</p>\n<p><img src=\"https://wx4.sinaimg.cn/mw690/006zFO3ggy1flhl8a9e69j312w0tatf9.jpg\" alt=\"\"></p>\n<p>Override 一个把三个名字都占了，你怕不怕？反正我是看的心里一紧。</p>\n<p>如果把概念都煮成了一锅粥，那还不如不要记这些概念，你应该向更深层次去探寻。就这三个的区别来说，我觉得主要理解两个概念就行了：</p>\n<ol>\n<li>函数签名（signature）</li>\n<li>多态（polymorphism、polymorphic）</li>\n</ol>\n<h2 id=\"函数签名\"><a href=\"#函数签名\" class=\"headerlink\" title=\"函数签名\"></a>函数签名</h2><p>函数签名是什么，其实就是用来区别函数的，两个函数怎么样认定是不同的两个函数呢，只有两个方面：</p>\n<ol>\n<li>函数名</li>\n<li>参数</li>\n</ol>\n<p>有人说还有返回值啊，不行，返回值不能作为函数签名的一部分，因为你调用一个函数的时候，返回值根本不能帮助编译器来识别你用的是哪个函数，比如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">float</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">func();</span><br></pre></td></tr></table></figure>\n<p>请问我使用的是哪个函数？你看返回值确实不行吧。</p>\n<h2 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h2><p>多态是面向对象编程的概念，你可以看看它的准确定义：</p>\n<p><a href=\"https://en.wikipedia.org/wiki/Polymorphism_(computer_science\" target=\"_blank\" rel=\"noopener\">Polymorphism</a>)。</p>\n<p>定义很简短：polymorphism is the provision of a single interface to entities of different types.</p>\n<p><a href=\"https://docs.oracle.com/javase/tutorial/java/IandI/polymorphism.html\" target=\"_blank\" rel=\"noopener\">The Java™ Tutorials</a></p>\n<p>如果父类有一个函数，子类也定义了一个完全相同的函数（函数签名相同），那么你可以用父类指针（或者说父类对象）作为统一的接口，来调用子类的方法。比如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Vehicle</span>&#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">move</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(“Vehicles can move!!”);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MotorBike</span> <span class=\"title\">extends</span> <span class=\"title\">Vehicle</span>&#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">move</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(“MotorBike can move <span class=\"keyword\">and</span> accelerate too!!”);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Car</span> <span class=\"title\">extends</span> <span class=\"title\">Vehicle</span>&#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">move</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        System.out.println(“Hi! I am a car!”);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span>&#123;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        Vehicle vh = <span class=\"keyword\">new</span> MotorBike();</span><br><span class=\"line\">        vh.move();    <span class=\"comment\">// prints MotorBike can move and accelerate too!!</span></span><br><span class=\"line\">        vh = <span class=\"keyword\">new</span> Vehicle();</span><br><span class=\"line\">        vh.move();    <span class=\"comment\">// prints Vehicles can move!!</span></span><br><span class=\"line\">        vh = <span class=\"keyword\">new</span> Car();</span><br><span class=\"line\">        vh.move();   <span class=\"comment\">// prints Hi! I am a car!</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>多态的好处是可以扩展啊，比如我后来又多了个 truck 类，我不需要去动已经写好的代码，只要把 truck 模块写好，加进去就行了。</p>\n<h2 id=\"Override、Overload、Overwrite-的区别\"><a href=\"#Override、Overload、Overwrite-的区别\" class=\"headerlink\" title=\"Override、Overload、Overwrite 的区别\"></a>Override、Overload、Overwrite 的区别</h2><p>好了，知道了这两个概念，我们再来看看上面的那三个混在一起的东西：</p>\n<ul>\n<li>Override（推翻，对英文意思就是这个）subclass method overrides base class method means:<ul>\n<li>in different range (in derived class and base class)</li>\n<li>the same function signature</li>\n<li>the base class method is virtual（if in C++）</li>\n</ul>\n</li>\n<li>overload（超载）function overloading means:<ul>\n<li>the same range (in the same class)</li>\n<li>the same function name</li>\n<li>but different function signature</li>\n</ul>\n</li>\n<li>overwrite（重写）subclass method hides base class method means:<ul>\n<li>in different range (in derived class and base class)</li>\n<li>the same function name</li>\n</ul>\n</li>\n</ul>\n<p>我们应该记住只有 Override 才跟多态有关。</p>\n<p>Overload 是本class 里面的不同函数（只不过函数名一样罢了，其实是两个不同的函数，看两个函数是否是同一个函数就看函数签名就行了），其实没啥稀奇的，不就是函数名一样嘛。函数签名一样，区分出是用父类还是子类的函数，这才是面向对象和多态要解决的问题。</p>\n<h2 id=\"Override-和-Overwrite-的区别\"><a href=\"#Override-和-Overwrite-的区别\" class=\"headerlink\" title=\"Override 和 Overwrite 的区别\"></a>Override 和 Overwrite 的区别</h2><blockquote>\n<p>比较容易混淆的其实是 Override 和 Overwrite，但你只要死记住：Override 必须函数签名要一样，而 Overwrite 只需函数名一样即可。另外 C++ 中一定要用virtual才算 Override，而 Java 默认就是 Override，不需要修饰词。</p>\n</blockquote>\n<blockquote>\n<p>这里关于 Java 和 C++ 面向对象的细节区别可以写一大堆，比如：C++ class 后面是要加分号的，而 Java 不需要；但 Java 的类名是和文件名要一致的，而且只能有一个 public 类，而 C++不需要；Java 直接就能用 Override，而 C++必须要使用 virtual 关键字才能使用 Override（虚函数）；Java 的抽象方法跟 C++的纯虚函数对应。Java 是单继承，由接口来实现“多继承”，C++是多继承，没有接口，只有抽象类。C++还有个虚基类的概念。具体的写法上还有很多的不同，多用这两种语言写面向对象的代码，就慢慢会知道了。</p>\n</blockquote>\n<p>C++ 有一个 virtual 关键字和 virtual table 这个概念，没有加 virtual 的父类函数是不可能形成多态的，如果这时候你碰到父类和子类两个里面有同名的函数，那么就属于 Overwrite 这个概念了，你其实也可以称这种覆盖掉父类函数的行为为：hide 隐藏。Java 这种语言里面没有 virtual 这一套，Java 也可以表现出 Overwrite，但要注意函数签名如果一样的话，那又不叫 Overwrite 了，应该叫 Override 了（Java 如果要在子类中使用父类的同函数签名方法，则必须使用 super 关键字）。而 C++ 不一样，即便是函数签名一样，如果前面不加 virtual 是不能叫 Override 的，仍然属于 Overwrite 的概念。请看下面的例子：</p>\n<p>用 C++ 写的话：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">cout</span>;</span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"built_in\">std</span>::<span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>&#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> a)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"A\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span>:</span><span class=\"keyword\">public</span> A&#123;</span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> a)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"B\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    A *a = <span class=\"keyword\">new</span> B();</span><br><span class=\"line\">    a-&gt;func(<span class=\"number\">1</span>);</span><br><span class=\"line\">    ((B*)a)-&gt;func(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A</span><br><span class=\"line\">B</span><br></pre></td></tr></table></figure>\n<p>可以看到，C++必须要用子类类型的指针才能访问到子类的部分（建议看一本书，叫：Inside the C++ Object Model，中文叫：深入C++对象模型，里面讲对象的内存布局讲的很清楚），java 也一样，必须转成子类型的指针才能访问，否则 IDE 会报错提示你。</p>\n<p>Java 代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">test</span> &#123;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>&#123;</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> a)</span></span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"A\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span> <span class=\"title\">extends</span> <span class=\"title\">A</span>&#123;</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>&#123;</span><br><span class=\"line\">            System.out.println(<span class=\"string\">\"B\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span></span>&#123;</span><br><span class=\"line\">        test t = <span class=\"keyword\">new</span> test();</span><br><span class=\"line\">        A a = t.<span class=\"keyword\">new</span> B();</span><br><span class=\"line\">        a.fun(<span class=\"number\">1</span>);</span><br><span class=\"line\">        ((B)a).func(<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>结果输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A</span><br><span class=\"line\">B</span><br></pre></td></tr></table></figure>\n<p>为什么 Java 代码里不像 C++ 代码里面那样，使用两个函数签名相同的函数？因为前面说过了，那样的话就变成 Override 了，只有在 C++ 里才能实现函数签名相同的 Overwrite（不使用virtual即可）。</p>\n"},{"title":"POJ 1001 Exponentiation","date":"2018-01-19T16:00:00.000Z","comments":1,"_content":"\n这是我第一次做 ACM，也是 POJ 上的第一题，本来以为这一题应该属于很简单的题，但没想到却花了不少时间。\n\n本来我是想着用C++标准库的 pow 函数，但这一题显然是个大实数乘法，double 可能就不够用了，所以只能自己手动实现乘法。Java 有个 BigInteger 和 BigDecimal 分别用来处理大整数和大实数。\n\n我的代码（已经 AC）：\n\nC++代码：\n\n```C++\n#include <iostream>  \n#include <string>  \n#include <vector>\nusing namespace std;\n\n // 两数相乘，使用vector保存每一位数字，从低位到高位\nvector<int> Multi(vector<int> v1,vector<int> v2)\n{\n    vector<int> result;\n    for (int i = 0; i < v1.size() + v2.size() + 1; i++)\n    {\n        result.push_back(0);\n    }\n    for (int i = 0; i < v1.size(); i++)\n    {\n        for (int j = 0; j < v2.size(); j++)\n        {\n            result[i + j] += v1[i] * v2[j];\n            result[i + j + 1] += result[i + j] / 10;\n            result[i + j] %= 10;\n        }\n    }\n    return result;\n}\n\nint main()  \n{\n    string str;\n    int n;\n    while(cin >> str >> n){\n        // cout << str << \" \" << n << \" \";\n        vector<int> numArray;\n        vector<int> resultArray;\n        int dotPos = 0, begin = 0, end = str.length() - 1;\n\n        //如果全是0和. 就直接输出0\n        bool isAllZero = true;\n        bool hasDot = false;\n        for(int i=0;i<str.length();i++){\n            if(str[i]!='0' && str[i]!='.'){\n                isAllZero = false;\n            }\n            if(str[i]=='.'){\n                hasDot = true;\n            }\n        }\n        if(isAllZero){\n            cout << 0;\n            cout << endl;\n            continue;\n        }\n\n        //如果没有小数点就不用删除后序零\n        if(hasDot){\n            //删除后序零（只删除小数点后的后序零，小数点之前的零保留，比如 10.0，变成10，而不是1）\n            for (int i = str.length() - 1; i >= 0; i--)\n            {\n                if(str[i] != '0')\n                {\n                    end = i;\n                    break;\n                }\n            }\n        }\n\n        // 测出小数位数\n        for (int i = end; i >= 0; i--)\n        {\n            if (str[i] == '.')\n            {\n                dotPos = end - i;\n                break;\n            }\n        }\n        //删除前序零（如果小数点被0包裹，那么也将小数点删除，比如：00.001，变成1）\n        for (int i = 0; i < str.length(); i++)\n        {\n            if(str[i] != '0' && str[i]!='.')\n            {\n                begin = i;\n                break;\n            }\n        }\n        // 将浮点数按位保存为整型\n        for (int i = end; i >= begin; i--)\n        {\n            if(str[i]!='.'){\n                numArray.push_back(str[i] - '0');\n            }\n        }\n        // 复制数组\n        for (int i = 0; i < numArray.size(); i++)\n        {\n            resultArray.push_back(numArray[i]);\n        }\n        // 计算数组的n次方\n        for (int j = 0; j < n-1; j++)\n        {\n            resultArray = Multi(resultArray, numArray);\n            int len = resultArray.size();\n            // 移除前导零\n            while (resultArray[len-1] == 0)\n            {\n                resultArray.pop_back();\n                len--;\n            }\n        }\n        // 输出结果，结果小于零时\n        if(n * dotPos >= resultArray.size())\n        {\n            cout << \".\";\n            for(int k = 0; k < n * dotPos - resultArray.size(); k++)\n            {\n                cout << \"0\";\n            }\n            for(int k=resultArray.size()-1;k>=0;k--){\n                cout << resultArray[k];\n            }\n        }else{\n            for (int k = resultArray.size() - 1; k >= 0; k--)\n            {\n                if (k == n * dotPos - 1)\n                {\n                    cout << \".\";\n                }\n                cout << resultArray[k];\n            }\n        }\n\n        cout << endl;\n    }\n    return 0;\n}\n```\n\n我自己写了一个测试用例的脚本：\n\ninput.cpp:\n\n```C++\n#include <iostream>\n#include <vector>\n#include <string>\n#include <fstream>\n\nusing namespace std;\n\nint main(){\n    string buffer;\n    ifstream in(\"hello.txt\");\n    if (! in.is_open())  \n       { cout << \"Error opening file\"; exit (1); }\n       while (!in.eof() )  \n       {  \n        getline(in,buffer);\n        cout << buffer << endl;\n\n       }\n    return 0;\n}\n```\n\nhello.txt 内容如下：\n\n```\n95.123 12\n0.4321 20\n5.1234 15\n6.7592  9\n98.999 10\n1.0100 12\n.00001  1\n.12345  1\n0001.1  1\n1.1000  1\n10.000  1\n000.10  1\n000000  1\n000.00  1\n.00000  0\n000010  1\n000.10  1\n0000.1  1\n00.111  1\n\n0.0001  1\n0.0001  3\n0.0010  1\n0.0010  3\n0.0100  1\n0.0100  3\n0.1000  1\n0.1000  3\n1.0000  1\n1.0000  3\n1.0001  1\n1.0001  3\n1.0010  1\n1.0010  3\n1.0100  1\n1.0100  3\n1.1000  1\n1.1000  3\n10.000  1\n10.000  3\n10.001  1\n10.001  3\n10.010  1\n10.010  3\n10.100  1\n10.100  3\n99.000  1\n99.000  3\n99.001  1\n99.001  3\n99.010  1\n99.010  3\n99.100  1\n99.100  3\n99.998  1\n99.998  3\n```\n\n这些测试用例都是前辈们留下来的资料。链接在这里：[测试用例](http://poj.org/showmessage?message_id=76017)\n\n顺带讲一下怎么自动测试：\n\n```\n//打开命令行，先编译两个 C++ 文件：\ng++ -std=c++11 -o input input.cpp\ng++ -std=c++11 -o main main.cpp\n//然后用管道把输入输出串起来，把最终解输入到文件 output.txt 里\n./input | ./main > output.txt\n```\n","source":"_posts/2018/2018-01-20-POJ-1001-Exponentiation.md","raw":"---\ntitle: POJ 1001 Exponentiation\ndate: 2018-01-20\ncategories: [ACM, POJ]\ncomments: true\n---\n\n这是我第一次做 ACM，也是 POJ 上的第一题，本来以为这一题应该属于很简单的题，但没想到却花了不少时间。\n\n本来我是想着用C++标准库的 pow 函数，但这一题显然是个大实数乘法，double 可能就不够用了，所以只能自己手动实现乘法。Java 有个 BigInteger 和 BigDecimal 分别用来处理大整数和大实数。\n\n我的代码（已经 AC）：\n\nC++代码：\n\n```C++\n#include <iostream>  \n#include <string>  \n#include <vector>\nusing namespace std;\n\n // 两数相乘，使用vector保存每一位数字，从低位到高位\nvector<int> Multi(vector<int> v1,vector<int> v2)\n{\n    vector<int> result;\n    for (int i = 0; i < v1.size() + v2.size() + 1; i++)\n    {\n        result.push_back(0);\n    }\n    for (int i = 0; i < v1.size(); i++)\n    {\n        for (int j = 0; j < v2.size(); j++)\n        {\n            result[i + j] += v1[i] * v2[j];\n            result[i + j + 1] += result[i + j] / 10;\n            result[i + j] %= 10;\n        }\n    }\n    return result;\n}\n\nint main()  \n{\n    string str;\n    int n;\n    while(cin >> str >> n){\n        // cout << str << \" \" << n << \" \";\n        vector<int> numArray;\n        vector<int> resultArray;\n        int dotPos = 0, begin = 0, end = str.length() - 1;\n\n        //如果全是0和. 就直接输出0\n        bool isAllZero = true;\n        bool hasDot = false;\n        for(int i=0;i<str.length();i++){\n            if(str[i]!='0' && str[i]!='.'){\n                isAllZero = false;\n            }\n            if(str[i]=='.'){\n                hasDot = true;\n            }\n        }\n        if(isAllZero){\n            cout << 0;\n            cout << endl;\n            continue;\n        }\n\n        //如果没有小数点就不用删除后序零\n        if(hasDot){\n            //删除后序零（只删除小数点后的后序零，小数点之前的零保留，比如 10.0，变成10，而不是1）\n            for (int i = str.length() - 1; i >= 0; i--)\n            {\n                if(str[i] != '0')\n                {\n                    end = i;\n                    break;\n                }\n            }\n        }\n\n        // 测出小数位数\n        for (int i = end; i >= 0; i--)\n        {\n            if (str[i] == '.')\n            {\n                dotPos = end - i;\n                break;\n            }\n        }\n        //删除前序零（如果小数点被0包裹，那么也将小数点删除，比如：00.001，变成1）\n        for (int i = 0; i < str.length(); i++)\n        {\n            if(str[i] != '0' && str[i]!='.')\n            {\n                begin = i;\n                break;\n            }\n        }\n        // 将浮点数按位保存为整型\n        for (int i = end; i >= begin; i--)\n        {\n            if(str[i]!='.'){\n                numArray.push_back(str[i] - '0');\n            }\n        }\n        // 复制数组\n        for (int i = 0; i < numArray.size(); i++)\n        {\n            resultArray.push_back(numArray[i]);\n        }\n        // 计算数组的n次方\n        for (int j = 0; j < n-1; j++)\n        {\n            resultArray = Multi(resultArray, numArray);\n            int len = resultArray.size();\n            // 移除前导零\n            while (resultArray[len-1] == 0)\n            {\n                resultArray.pop_back();\n                len--;\n            }\n        }\n        // 输出结果，结果小于零时\n        if(n * dotPos >= resultArray.size())\n        {\n            cout << \".\";\n            for(int k = 0; k < n * dotPos - resultArray.size(); k++)\n            {\n                cout << \"0\";\n            }\n            for(int k=resultArray.size()-1;k>=0;k--){\n                cout << resultArray[k];\n            }\n        }else{\n            for (int k = resultArray.size() - 1; k >= 0; k--)\n            {\n                if (k == n * dotPos - 1)\n                {\n                    cout << \".\";\n                }\n                cout << resultArray[k];\n            }\n        }\n\n        cout << endl;\n    }\n    return 0;\n}\n```\n\n我自己写了一个测试用例的脚本：\n\ninput.cpp:\n\n```C++\n#include <iostream>\n#include <vector>\n#include <string>\n#include <fstream>\n\nusing namespace std;\n\nint main(){\n    string buffer;\n    ifstream in(\"hello.txt\");\n    if (! in.is_open())  \n       { cout << \"Error opening file\"; exit (1); }\n       while (!in.eof() )  \n       {  \n        getline(in,buffer);\n        cout << buffer << endl;\n\n       }\n    return 0;\n}\n```\n\nhello.txt 内容如下：\n\n```\n95.123 12\n0.4321 20\n5.1234 15\n6.7592  9\n98.999 10\n1.0100 12\n.00001  1\n.12345  1\n0001.1  1\n1.1000  1\n10.000  1\n000.10  1\n000000  1\n000.00  1\n.00000  0\n000010  1\n000.10  1\n0000.1  1\n00.111  1\n\n0.0001  1\n0.0001  3\n0.0010  1\n0.0010  3\n0.0100  1\n0.0100  3\n0.1000  1\n0.1000  3\n1.0000  1\n1.0000  3\n1.0001  1\n1.0001  3\n1.0010  1\n1.0010  3\n1.0100  1\n1.0100  3\n1.1000  1\n1.1000  3\n10.000  1\n10.000  3\n10.001  1\n10.001  3\n10.010  1\n10.010  3\n10.100  1\n10.100  3\n99.000  1\n99.000  3\n99.001  1\n99.001  3\n99.010  1\n99.010  3\n99.100  1\n99.100  3\n99.998  1\n99.998  3\n```\n\n这些测试用例都是前辈们留下来的资料。链接在这里：[测试用例](http://poj.org/showmessage?message_id=76017)\n\n顺带讲一下怎么自动测试：\n\n```\n//打开命令行，先编译两个 C++ 文件：\ng++ -std=c++11 -o input input.cpp\ng++ -std=c++11 -o main main.cpp\n//然后用管道把输入输出串起来，把最终解输入到文件 output.txt 里\n./input | ./main > output.txt\n```\n","slug":"POJ-1001-Exponentiation","published":1,"updated":"2018-06-10T11:58:53.820Z","layout":"post","photos":[],"link":"","_id":"cjm2w8dd4001mfgpxw2qwvmk2","content":"<p>这是我第一次做 ACM，也是 POJ 上的第一题，本来以为这一题应该属于很简单的题，但没想到却花了不少时间。</p>\n<p>本来我是想着用C++标准库的 pow 函数，但这一题显然是个大实数乘法，double 可能就不够用了，所以只能自己手动实现乘法。Java 有个 BigInteger 和 BigDecimal 分别用来处理大整数和大实数。</p>\n<p>我的代码（已经 AC）：</p>\n<p>C++代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;  </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;  </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">// 两数相乘，使用vector保存每一位数字，从低位到高位</span></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; Multi(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; v1,<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; v2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; result;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; v1.size() + v2.size() + <span class=\"number\">1</span>; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        result.push_back(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; v1.size(); i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; v2.size(); j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            result[i + j] += v1[i] * v2[j];</span><br><span class=\"line\">            result[i + j + <span class=\"number\">1</span>] += result[i + j] / <span class=\"number\">10</span>;</span><br><span class=\"line\">            result[i + j] %= <span class=\"number\">10</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span>  </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> str;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span> &gt;&gt; str &gt;&gt; n)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// cout &lt;&lt; str &lt;&lt; \" \" &lt;&lt; n &lt;&lt; \" \";</span></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; numArray;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; resultArray;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> dotPos = <span class=\"number\">0</span>, begin = <span class=\"number\">0</span>, end = str.length() - <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//如果全是0和. 就直接输出0</span></span><br><span class=\"line\">        <span class=\"keyword\">bool</span> isAllZero = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> hasDot = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;str.length();i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(str[i]!=<span class=\"string\">'0'</span> &amp;&amp; str[i]!=<span class=\"string\">'.'</span>)&#123;</span><br><span class=\"line\">                isAllZero = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(str[i]==<span class=\"string\">'.'</span>)&#123;</span><br><span class=\"line\">                hasDot = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(isAllZero)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//如果没有小数点就不用删除后序零</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(hasDot)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//删除后序零（只删除小数点后的后序零，小数点之前的零保留，比如 10.0，变成10，而不是1）</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = str.length() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(str[i] != <span class=\"string\">'0'</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    end = i;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 测出小数位数</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = end; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (str[i] == <span class=\"string\">'.'</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                dotPos = end - i;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//删除前序零（如果小数点被0包裹，那么也将小数点删除，比如：00.001，变成1）</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; str.length(); i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(str[i] != <span class=\"string\">'0'</span> &amp;&amp; str[i]!=<span class=\"string\">'.'</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                begin = i;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 将浮点数按位保存为整型</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = end; i &gt;= begin; i--)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(str[i]!=<span class=\"string\">'.'</span>)&#123;</span><br><span class=\"line\">                numArray.push_back(str[i] - <span class=\"string\">'0'</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 复制数组</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numArray.size(); i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            resultArray.push_back(numArray[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 计算数组的n次方</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n<span class=\"number\">-1</span>; j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            resultArray = Multi(resultArray, numArray);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> len = resultArray.size();</span><br><span class=\"line\">            <span class=\"comment\">// 移除前导零</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (resultArray[len<span class=\"number\">-1</span>] == <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                resultArray.pop_back();</span><br><span class=\"line\">                len--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 输出结果，结果小于零时</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n * dotPos &gt;= resultArray.size())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\".\"</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; n * dotPos - resultArray.size(); k++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"0\"</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k=resultArray.size()<span class=\"number\">-1</span>;k&gt;=<span class=\"number\">0</span>;k--)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; resultArray[k];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = resultArray.size() - <span class=\"number\">1</span>; k &gt;= <span class=\"number\">0</span>; k--)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (k == n * dotPos - <span class=\"number\">1</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\".\"</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; resultArray[k];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我自己写了一个测试用例的脚本：</p>\n<p>input.cpp:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fstream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> buffer;</span><br><span class=\"line\">    <span class=\"function\">ifstream <span class=\"title\">in</span><span class=\"params\">(<span class=\"string\">\"hello.txt\"</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (! in.is_open())  </span><br><span class=\"line\">       &#123; <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Error opening file\"</span>; <span class=\"built_in\">exit</span> (<span class=\"number\">1</span>); &#125;</span><br><span class=\"line\">       <span class=\"keyword\">while</span> (!in.eof() )  </span><br><span class=\"line\">       &#123;  </span><br><span class=\"line\">        getline(in,buffer);</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; buffer &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>hello.txt 内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">95.123 12</span><br><span class=\"line\">0.4321 20</span><br><span class=\"line\">5.1234 15</span><br><span class=\"line\">6.7592  9</span><br><span class=\"line\">98.999 10</span><br><span class=\"line\">1.0100 12</span><br><span class=\"line\">.00001  1</span><br><span class=\"line\">.12345  1</span><br><span class=\"line\">0001.1  1</span><br><span class=\"line\">1.1000  1</span><br><span class=\"line\">10.000  1</span><br><span class=\"line\">000.10  1</span><br><span class=\"line\">000000  1</span><br><span class=\"line\">000.00  1</span><br><span class=\"line\">.00000  0</span><br><span class=\"line\">000010  1</span><br><span class=\"line\">000.10  1</span><br><span class=\"line\">0000.1  1</span><br><span class=\"line\">00.111  1</span><br><span class=\"line\"></span><br><span class=\"line\">0.0001  1</span><br><span class=\"line\">0.0001  3</span><br><span class=\"line\">0.0010  1</span><br><span class=\"line\">0.0010  3</span><br><span class=\"line\">0.0100  1</span><br><span class=\"line\">0.0100  3</span><br><span class=\"line\">0.1000  1</span><br><span class=\"line\">0.1000  3</span><br><span class=\"line\">1.0000  1</span><br><span class=\"line\">1.0000  3</span><br><span class=\"line\">1.0001  1</span><br><span class=\"line\">1.0001  3</span><br><span class=\"line\">1.0010  1</span><br><span class=\"line\">1.0010  3</span><br><span class=\"line\">1.0100  1</span><br><span class=\"line\">1.0100  3</span><br><span class=\"line\">1.1000  1</span><br><span class=\"line\">1.1000  3</span><br><span class=\"line\">10.000  1</span><br><span class=\"line\">10.000  3</span><br><span class=\"line\">10.001  1</span><br><span class=\"line\">10.001  3</span><br><span class=\"line\">10.010  1</span><br><span class=\"line\">10.010  3</span><br><span class=\"line\">10.100  1</span><br><span class=\"line\">10.100  3</span><br><span class=\"line\">99.000  1</span><br><span class=\"line\">99.000  3</span><br><span class=\"line\">99.001  1</span><br><span class=\"line\">99.001  3</span><br><span class=\"line\">99.010  1</span><br><span class=\"line\">99.010  3</span><br><span class=\"line\">99.100  1</span><br><span class=\"line\">99.100  3</span><br><span class=\"line\">99.998  1</span><br><span class=\"line\">99.998  3</span><br></pre></td></tr></table></figure>\n<p>这些测试用例都是前辈们留下来的资料。链接在这里：<a href=\"http://poj.org/showmessage?message_id=76017\" target=\"_blank\" rel=\"noopener\">测试用例</a></p>\n<p>顺带讲一下怎么自动测试：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//打开命令行，先编译两个 C++ 文件：</span><br><span class=\"line\">g++ -std=c++11 -o input input.cpp</span><br><span class=\"line\">g++ -std=c++11 -o main main.cpp</span><br><span class=\"line\">//然后用管道把输入输出串起来，把最终解输入到文件 output.txt 里</span><br><span class=\"line\">./input | ./main &gt; output.txt</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>这是我第一次做 ACM，也是 POJ 上的第一题，本来以为这一题应该属于很简单的题，但没想到却花了不少时间。</p>\n<p>本来我是想着用C++标准库的 pow 函数，但这一题显然是个大实数乘法，double 可能就不够用了，所以只能自己手动实现乘法。Java 有个 BigInteger 和 BigDecimal 分别用来处理大整数和大实数。</p>\n<p>我的代码（已经 AC）：</p>\n<p>C++代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;  </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;  </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">// 两数相乘，使用vector保存每一位数字，从低位到高位</span></span><br><span class=\"line\"><span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; Multi(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; v1,<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; v2)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; result;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; v1.size() + v2.size() + <span class=\"number\">1</span>; i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        result.push_back(<span class=\"number\">0</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; v1.size(); i++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; v2.size(); j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            result[i + j] += v1[i] * v2[j];</span><br><span class=\"line\">            result[i + j + <span class=\"number\">1</span>] += result[i + j] / <span class=\"number\">10</span>;</span><br><span class=\"line\">            result[i + j] %= <span class=\"number\">10</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span>  </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> str;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span> &gt;&gt; str &gt;&gt; n)&#123;</span><br><span class=\"line\">        <span class=\"comment\">// cout &lt;&lt; str &lt;&lt; \" \" &lt;&lt; n &lt;&lt; \" \";</span></span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; numArray;</span><br><span class=\"line\">        <span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt; resultArray;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> dotPos = <span class=\"number\">0</span>, begin = <span class=\"number\">0</span>, end = str.length() - <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//如果全是0和. 就直接输出0</span></span><br><span class=\"line\">        <span class=\"keyword\">bool</span> isAllZero = <span class=\"literal\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">bool</span> hasDot = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;str.length();i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(str[i]!=<span class=\"string\">'0'</span> &amp;&amp; str[i]!=<span class=\"string\">'.'</span>)&#123;</span><br><span class=\"line\">                isAllZero = <span class=\"literal\">false</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(str[i]==<span class=\"string\">'.'</span>)&#123;</span><br><span class=\"line\">                hasDot = <span class=\"literal\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(isAllZero)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//如果没有小数点就不用删除后序零</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(hasDot)&#123;</span><br><span class=\"line\">            <span class=\"comment\">//删除后序零（只删除小数点后的后序零，小数点之前的零保留，比如 10.0，变成10，而不是1）</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = str.length() - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span>(str[i] != <span class=\"string\">'0'</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    end = i;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 测出小数位数</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = end; i &gt;= <span class=\"number\">0</span>; i--)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (str[i] == <span class=\"string\">'.'</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                dotPos = end - i;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//删除前序零（如果小数点被0包裹，那么也将小数点删除，比如：00.001，变成1）</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; str.length(); i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(str[i] != <span class=\"string\">'0'</span> &amp;&amp; str[i]!=<span class=\"string\">'.'</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                begin = i;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 将浮点数按位保存为整型</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = end; i &gt;= begin; i--)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(str[i]!=<span class=\"string\">'.'</span>)&#123;</span><br><span class=\"line\">                numArray.push_back(str[i] - <span class=\"string\">'0'</span>);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 复制数组</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; numArray.size(); i++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            resultArray.push_back(numArray[i]);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 计算数组的n次方</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; n<span class=\"number\">-1</span>; j++)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            resultArray = Multi(resultArray, numArray);</span><br><span class=\"line\">            <span class=\"keyword\">int</span> len = resultArray.size();</span><br><span class=\"line\">            <span class=\"comment\">// 移除前导零</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (resultArray[len<span class=\"number\">-1</span>] == <span class=\"number\">0</span>)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                resultArray.pop_back();</span><br><span class=\"line\">                len--;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">// 输出结果，结果小于零时</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(n * dotPos &gt;= resultArray.size())</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\".\"</span>;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k = <span class=\"number\">0</span>; k &lt; n * dotPos - resultArray.size(); k++)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"0\"</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> k=resultArray.size()<span class=\"number\">-1</span>;k&gt;=<span class=\"number\">0</span>;k--)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; resultArray[k];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> k = resultArray.size() - <span class=\"number\">1</span>; k &gt;= <span class=\"number\">0</span>; k--)</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (k == n * dotPos - <span class=\"number\">1</span>)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\".\"</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"built_in\">cout</span> &lt;&lt; resultArray[k];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我自己写了一个测试用例的脚本：</p>\n<p>input.cpp:</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fstream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> buffer;</span><br><span class=\"line\">    <span class=\"function\">ifstream <span class=\"title\">in</span><span class=\"params\">(<span class=\"string\">\"hello.txt\"</span>)</span></span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (! in.is_open())  </span><br><span class=\"line\">       &#123; <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Error opening file\"</span>; <span class=\"built_in\">exit</span> (<span class=\"number\">1</span>); &#125;</span><br><span class=\"line\">       <span class=\"keyword\">while</span> (!in.eof() )  </span><br><span class=\"line\">       &#123;  </span><br><span class=\"line\">        getline(in,buffer);</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; buffer &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>hello.txt 内容如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">95.123 12</span><br><span class=\"line\">0.4321 20</span><br><span class=\"line\">5.1234 15</span><br><span class=\"line\">6.7592  9</span><br><span class=\"line\">98.999 10</span><br><span class=\"line\">1.0100 12</span><br><span class=\"line\">.00001  1</span><br><span class=\"line\">.12345  1</span><br><span class=\"line\">0001.1  1</span><br><span class=\"line\">1.1000  1</span><br><span class=\"line\">10.000  1</span><br><span class=\"line\">000.10  1</span><br><span class=\"line\">000000  1</span><br><span class=\"line\">000.00  1</span><br><span class=\"line\">.00000  0</span><br><span class=\"line\">000010  1</span><br><span class=\"line\">000.10  1</span><br><span class=\"line\">0000.1  1</span><br><span class=\"line\">00.111  1</span><br><span class=\"line\"></span><br><span class=\"line\">0.0001  1</span><br><span class=\"line\">0.0001  3</span><br><span class=\"line\">0.0010  1</span><br><span class=\"line\">0.0010  3</span><br><span class=\"line\">0.0100  1</span><br><span class=\"line\">0.0100  3</span><br><span class=\"line\">0.1000  1</span><br><span class=\"line\">0.1000  3</span><br><span class=\"line\">1.0000  1</span><br><span class=\"line\">1.0000  3</span><br><span class=\"line\">1.0001  1</span><br><span class=\"line\">1.0001  3</span><br><span class=\"line\">1.0010  1</span><br><span class=\"line\">1.0010  3</span><br><span class=\"line\">1.0100  1</span><br><span class=\"line\">1.0100  3</span><br><span class=\"line\">1.1000  1</span><br><span class=\"line\">1.1000  3</span><br><span class=\"line\">10.000  1</span><br><span class=\"line\">10.000  3</span><br><span class=\"line\">10.001  1</span><br><span class=\"line\">10.001  3</span><br><span class=\"line\">10.010  1</span><br><span class=\"line\">10.010  3</span><br><span class=\"line\">10.100  1</span><br><span class=\"line\">10.100  3</span><br><span class=\"line\">99.000  1</span><br><span class=\"line\">99.000  3</span><br><span class=\"line\">99.001  1</span><br><span class=\"line\">99.001  3</span><br><span class=\"line\">99.010  1</span><br><span class=\"line\">99.010  3</span><br><span class=\"line\">99.100  1</span><br><span class=\"line\">99.100  3</span><br><span class=\"line\">99.998  1</span><br><span class=\"line\">99.998  3</span><br></pre></td></tr></table></figure>\n<p>这些测试用例都是前辈们留下来的资料。链接在这里：<a href=\"http://poj.org/showmessage?message_id=76017\" target=\"_blank\" rel=\"noopener\">测试用例</a></p>\n<p>顺带讲一下怎么自动测试：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//打开命令行，先编译两个 C++ 文件：</span><br><span class=\"line\">g++ -std=c++11 -o input input.cpp</span><br><span class=\"line\">g++ -std=c++11 -o main main.cpp</span><br><span class=\"line\">//然后用管道把输入输出串起来，把最终解输入到文件 output.txt 里</span><br><span class=\"line\">./input | ./main &gt; output.txt</span><br></pre></td></tr></table></figure>\n"},{"title":"POJ 1002 487 3279","date":"2018-01-20T16:00:00.000Z","comments":1,"_content":"\n这一题看似很简单，却有着很多限制，我也是搞了很久。刚开始的时候我是用了很多 c++11 的东西，然后一直报 Compile Error，但我本地编译是不会有错的，查出几点：\n\nvector<vector<int>>会报错，但 c++11可以这样写，以前的老编译器只能这么写：vector<vector<int> >\nto_string()函数无法使用，这是 c++11 新出的。\nfor(int x:result)这种写法直到 c++11 才支持。\nPOJ 上的编译器是比较老的，所以无法使用 c++11 的新特性。\n\n这还不算，后来一直报 Time Limit Exceeded，上网查资料发现，要把 cin 输入改成 getchar 接收输入，终于 AC。还有就是在勾选 language 的时候，一定要用 G++，不要用 C++，如果你选 C++，会报如下错误：\n\n```\nCompile Error\n\nMain.cpp\nF:\\temp\\18069972.33777\\Main.cpp(16) : error C2057: expected constant expression\nF:\\temp\\18069972.33777\\Main.cpp(16) : error C2466: cannot allocate an array of constant size 0\nF:\\temp\\18069972.33777\\Main.cpp(16) : error C2133: 'data' : unknown size\n```\n\nC++代码：\n\n```C++\n#include <iostream>  \n#include <cstdio>\n#include <cstdlib>\n#include <string>  \n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <sstream>\nusing namespace std;\n\nint main(){\n    int n;\n    char ch;\n    scanf(\"%d\",&n);\n    int data[n];\n    int size = n;\n    while(n--){\n        ch = getchar();\n        //过滤空行\n        if(ch=='\\n'){\n            n++;\n            continue;\n        }\n        int num = 0;\n        while(ch!='\\n'){\n            if(ch>='0' && ch<='9'){\n                num = num*10 + ch - '0';\n            }else if(ch >= 'A' && ch <= 'P'){\n                num = num*10 + (ch - 'A')/3 + 2;\n            }else if(ch >= 'R' && ch <= 'Y'){\n                num = num*10 + (ch - 'Q')/3 + 7;\n            }\n            ch = getchar();\n        }\n        data[n]=num;\n    }\n    // qsort(data, size, sizeof(int), compare);\n    sort(data, data+size);\n    // for(int i=0;i<size;i++){\n    //     cout << data[i] << endl;\n    // }\n    int count=1;\n    int index=0;\n    for(int i=1;i<size;++i){\n        if(data[i]==data[i-1]){\n            count++;\n            index=i;\n        }else{\n            if(count!=1){\n                printf(\"%03d-%04d %d\\n\",data[i-1]/10000,data[i-1]%10000,count);\n                // cout << setfill('0') << setw(3) << data[i-1]/10000 << '-' << setfill('0') << setw(4) << data[i-1]%10000 << ' ' << count << endl;\n                count=1;\n            }\n        }\n        if(i==size-1 && count!=1){\n            printf(\"%03d-%04d %d\\n\",data[i-1]/10000,data[i-1]%10000,count);\n            count=1;\n        }\n    }\n    if(index==0){\n        cout << \"No duplicates.\" << endl;\n    }\n    return 0;\n}\n```\n","source":"_posts/2018/2018-01-21-POJ-1002-487-3279.md","raw":"---\ntitle: POJ 1002 487 3279\ndate: 2018-01-21\ncategories: [ACM, POJ]\ncomments: true\n---\n\n这一题看似很简单，却有着很多限制，我也是搞了很久。刚开始的时候我是用了很多 c++11 的东西，然后一直报 Compile Error，但我本地编译是不会有错的，查出几点：\n\nvector<vector<int>>会报错，但 c++11可以这样写，以前的老编译器只能这么写：vector<vector<int> >\nto_string()函数无法使用，这是 c++11 新出的。\nfor(int x:result)这种写法直到 c++11 才支持。\nPOJ 上的编译器是比较老的，所以无法使用 c++11 的新特性。\n\n这还不算，后来一直报 Time Limit Exceeded，上网查资料发现，要把 cin 输入改成 getchar 接收输入，终于 AC。还有就是在勾选 language 的时候，一定要用 G++，不要用 C++，如果你选 C++，会报如下错误：\n\n```\nCompile Error\n\nMain.cpp\nF:\\temp\\18069972.33777\\Main.cpp(16) : error C2057: expected constant expression\nF:\\temp\\18069972.33777\\Main.cpp(16) : error C2466: cannot allocate an array of constant size 0\nF:\\temp\\18069972.33777\\Main.cpp(16) : error C2133: 'data' : unknown size\n```\n\nC++代码：\n\n```C++\n#include <iostream>  \n#include <cstdio>\n#include <cstdlib>\n#include <string>  \n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <sstream>\nusing namespace std;\n\nint main(){\n    int n;\n    char ch;\n    scanf(\"%d\",&n);\n    int data[n];\n    int size = n;\n    while(n--){\n        ch = getchar();\n        //过滤空行\n        if(ch=='\\n'){\n            n++;\n            continue;\n        }\n        int num = 0;\n        while(ch!='\\n'){\n            if(ch>='0' && ch<='9'){\n                num = num*10 + ch - '0';\n            }else if(ch >= 'A' && ch <= 'P'){\n                num = num*10 + (ch - 'A')/3 + 2;\n            }else if(ch >= 'R' && ch <= 'Y'){\n                num = num*10 + (ch - 'Q')/3 + 7;\n            }\n            ch = getchar();\n        }\n        data[n]=num;\n    }\n    // qsort(data, size, sizeof(int), compare);\n    sort(data, data+size);\n    // for(int i=0;i<size;i++){\n    //     cout << data[i] << endl;\n    // }\n    int count=1;\n    int index=0;\n    for(int i=1;i<size;++i){\n        if(data[i]==data[i-1]){\n            count++;\n            index=i;\n        }else{\n            if(count!=1){\n                printf(\"%03d-%04d %d\\n\",data[i-1]/10000,data[i-1]%10000,count);\n                // cout << setfill('0') << setw(3) << data[i-1]/10000 << '-' << setfill('0') << setw(4) << data[i-1]%10000 << ' ' << count << endl;\n                count=1;\n            }\n        }\n        if(i==size-1 && count!=1){\n            printf(\"%03d-%04d %d\\n\",data[i-1]/10000,data[i-1]%10000,count);\n            count=1;\n        }\n    }\n    if(index==0){\n        cout << \"No duplicates.\" << endl;\n    }\n    return 0;\n}\n```\n","slug":"POJ-1002-487-3279","published":1,"updated":"2018-06-10T11:59:04.971Z","layout":"post","photos":[],"link":"","_id":"cjm2w8dd5001qfgpxnhck7ys3","content":"<p>这一题看似很简单，却有着很多限制，我也是搞了很久。刚开始的时候我是用了很多 c++11 的东西，然后一直报 Compile Error，但我本地编译是不会有错的，查出几点：</p>\n<p>vector&lt;vector<int>&gt;会报错，但 c++11可以这样写，以前的老编译器只能这么写：vector&lt;vector<int> &gt;<br>to_string()函数无法使用，这是 c++11 新出的。<br>for(int x:result)这种写法直到 c++11 才支持。<br>POJ 上的编译器是比较老的，所以无法使用 c++11 的新特性。</int></int></p>\n<p>这还不算，后来一直报 Time Limit Exceeded，上网查资料发现，要把 cin 输入改成 getchar 接收输入，终于 AC。还有就是在勾选 language 的时候，一定要用 G++，不要用 C++，如果你选 C++，会报如下错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Compile Error</span><br><span class=\"line\"></span><br><span class=\"line\">Main.cpp</span><br><span class=\"line\">F:\\temp\\18069972.33777\\Main.cpp(16) : error C2057: expected constant expression</span><br><span class=\"line\">F:\\temp\\18069972.33777\\Main.cpp(16) : error C2466: cannot allocate an array of constant size 0</span><br><span class=\"line\">F:\\temp\\18069972.33777\\Main.cpp(16) : error C2133: &apos;data&apos; : unknown size</span><br></pre></td></tr></table></figure>\n<p>C++代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;  </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdlib&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;  </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;utility&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sstream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> ch;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> data[n];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = n;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n--)&#123;</span><br><span class=\"line\">        ch = getchar();</span><br><span class=\"line\">        <span class=\"comment\">//过滤空行</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ch==<span class=\"string\">'\\n'</span>)&#123;</span><br><span class=\"line\">            n++;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> num = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(ch!=<span class=\"string\">'\\n'</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ch&gt;=<span class=\"string\">'0'</span> &amp;&amp; ch&lt;=<span class=\"string\">'9'</span>)&#123;</span><br><span class=\"line\">                num = num*<span class=\"number\">10</span> + ch - <span class=\"string\">'0'</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(ch &gt;= <span class=\"string\">'A'</span> &amp;&amp; ch &lt;= <span class=\"string\">'P'</span>)&#123;</span><br><span class=\"line\">                num = num*<span class=\"number\">10</span> + (ch - <span class=\"string\">'A'</span>)/<span class=\"number\">3</span> + <span class=\"number\">2</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(ch &gt;= <span class=\"string\">'R'</span> &amp;&amp; ch &lt;= <span class=\"string\">'Y'</span>)&#123;</span><br><span class=\"line\">                num = num*<span class=\"number\">10</span> + (ch - <span class=\"string\">'Q'</span>)/<span class=\"number\">3</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ch = getchar();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        data[n]=num;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// qsort(data, size, sizeof(int), compare);</span></span><br><span class=\"line\">    sort(data, data+size);</span><br><span class=\"line\">    <span class=\"comment\">// for(int i=0;i&lt;size;i++)&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//     cout &lt;&lt; data[i] &lt;&lt; endl;</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> count=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> index=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;size;++i)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(data[i]==data[i<span class=\"number\">-1</span>])&#123;</span><br><span class=\"line\">            count++;</span><br><span class=\"line\">            index=i;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(count!=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"%03d-%04d %d\\n\"</span>,data[i<span class=\"number\">-1</span>]/<span class=\"number\">10000</span>,data[i<span class=\"number\">-1</span>]%<span class=\"number\">10000</span>,count);</span><br><span class=\"line\">                <span class=\"comment\">// cout &lt;&lt; setfill('0') &lt;&lt; setw(3) &lt;&lt; data[i-1]/10000 &lt;&lt; '-' &lt;&lt; setfill('0') &lt;&lt; setw(4) &lt;&lt; data[i-1]%10000 &lt;&lt; ' ' &lt;&lt; count &lt;&lt; endl;</span></span><br><span class=\"line\">                count=<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i==size<span class=\"number\">-1</span> &amp;&amp; count!=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%03d-%04d %d\\n\"</span>,data[i<span class=\"number\">-1</span>]/<span class=\"number\">10000</span>,data[i<span class=\"number\">-1</span>]%<span class=\"number\">10000</span>,count);</span><br><span class=\"line\">            count=<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(index==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"No duplicates.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>这一题看似很简单，却有着很多限制，我也是搞了很久。刚开始的时候我是用了很多 c++11 的东西，然后一直报 Compile Error，但我本地编译是不会有错的，查出几点：</p>\n<p>vector&lt;vector<int>&gt;会报错，但 c++11可以这样写，以前的老编译器只能这么写：vector&lt;vector<int> &gt;<br>to_string()函数无法使用，这是 c++11 新出的。<br>for(int x:result)这种写法直到 c++11 才支持。<br>POJ 上的编译器是比较老的，所以无法使用 c++11 的新特性。</int></int></p>\n<p>这还不算，后来一直报 Time Limit Exceeded，上网查资料发现，要把 cin 输入改成 getchar 接收输入，终于 AC。还有就是在勾选 language 的时候，一定要用 G++，不要用 C++，如果你选 C++，会报如下错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Compile Error</span><br><span class=\"line\"></span><br><span class=\"line\">Main.cpp</span><br><span class=\"line\">F:\\temp\\18069972.33777\\Main.cpp(16) : error C2057: expected constant expression</span><br><span class=\"line\">F:\\temp\\18069972.33777\\Main.cpp(16) : error C2466: cannot allocate an array of constant size 0</span><br><span class=\"line\">F:\\temp\\18069972.33777\\Main.cpp(16) : error C2133: &apos;data&apos; : unknown size</span><br></pre></td></tr></table></figure>\n<p>C++代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;  </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdio&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cstdlib&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;  </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;vector&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;utility&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sstream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> ch;</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;n);</span><br><span class=\"line\">    <span class=\"keyword\">int</span> data[n];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> size = n;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n--)&#123;</span><br><span class=\"line\">        ch = getchar();</span><br><span class=\"line\">        <span class=\"comment\">//过滤空行</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(ch==<span class=\"string\">'\\n'</span>)&#123;</span><br><span class=\"line\">            n++;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> num = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(ch!=<span class=\"string\">'\\n'</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(ch&gt;=<span class=\"string\">'0'</span> &amp;&amp; ch&lt;=<span class=\"string\">'9'</span>)&#123;</span><br><span class=\"line\">                num = num*<span class=\"number\">10</span> + ch - <span class=\"string\">'0'</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(ch &gt;= <span class=\"string\">'A'</span> &amp;&amp; ch &lt;= <span class=\"string\">'P'</span>)&#123;</span><br><span class=\"line\">                num = num*<span class=\"number\">10</span> + (ch - <span class=\"string\">'A'</span>)/<span class=\"number\">3</span> + <span class=\"number\">2</span>;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(ch &gt;= <span class=\"string\">'R'</span> &amp;&amp; ch &lt;= <span class=\"string\">'Y'</span>)&#123;</span><br><span class=\"line\">                num = num*<span class=\"number\">10</span> + (ch - <span class=\"string\">'Q'</span>)/<span class=\"number\">3</span> + <span class=\"number\">7</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            ch = getchar();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        data[n]=num;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// qsort(data, size, sizeof(int), compare);</span></span><br><span class=\"line\">    sort(data, data+size);</span><br><span class=\"line\">    <span class=\"comment\">// for(int i=0;i&lt;size;i++)&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//     cout &lt;&lt; data[i] &lt;&lt; endl;</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> count=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> index=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;i&lt;size;++i)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(data[i]==data[i<span class=\"number\">-1</span>])&#123;</span><br><span class=\"line\">            count++;</span><br><span class=\"line\">            index=i;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(count!=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">                <span class=\"built_in\">printf</span>(<span class=\"string\">\"%03d-%04d %d\\n\"</span>,data[i<span class=\"number\">-1</span>]/<span class=\"number\">10000</span>,data[i<span class=\"number\">-1</span>]%<span class=\"number\">10000</span>,count);</span><br><span class=\"line\">                <span class=\"comment\">// cout &lt;&lt; setfill('0') &lt;&lt; setw(3) &lt;&lt; data[i-1]/10000 &lt;&lt; '-' &lt;&lt; setfill('0') &lt;&lt; setw(4) &lt;&lt; data[i-1]%10000 &lt;&lt; ' ' &lt;&lt; count &lt;&lt; endl;</span></span><br><span class=\"line\">                count=<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(i==size<span class=\"number\">-1</span> &amp;&amp; count!=<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"%03d-%04d %d\\n\"</span>,data[i<span class=\"number\">-1</span>]/<span class=\"number\">10000</span>,data[i<span class=\"number\">-1</span>]%<span class=\"number\">10000</span>,count);</span><br><span class=\"line\">            count=<span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(index==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"No duplicates.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"POJ-1003-Hangover","date":"2018-01-20T16:00:00.000Z","comments":1,"_content":"\n这一题 AC 的速度还是挺快的，题目本身也是很简单：\n\nC++ 代码：\n\n```C++\n#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nstring double2Str(const double &double_temp){\n    stringstream ss;\n    ss << double_temp;\n    string str;\n    ss >> str;\n    return str;\n}\n\nint main(){\n    double x;\n    cin >> x;\n    //对浮点数只能使用大于、小于号进行比较，不能使用等号和不等号，我这里直接把 double 转成字符串，就可以用不等号比较了\n    //根据输入条件的限制，可以这样写：x>0.01。\n    while(double2Str(x)!=\"0\"){\n        int i=2;\n        double sum=1.0/i;\n        while(sum < x){\n            i++;\n            sum += 1.0/i;\n        }\n        cout << i-1 << \" card(s)\" << endl;\n        cin >> x;\n    }\n    return 0;\n}\n```\n","source":"_posts/2018/2018-01-21-POJ-1003-Hangover.md","raw":"---\ntitle: POJ-1003-Hangover\ndate: 2018-01-21\ncategories: [ACM, POJ]\ncomments: true\n---\n\n这一题 AC 的速度还是挺快的，题目本身也是很简单：\n\nC++ 代码：\n\n```C++\n#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nstring double2Str(const double &double_temp){\n    stringstream ss;\n    ss << double_temp;\n    string str;\n    ss >> str;\n    return str;\n}\n\nint main(){\n    double x;\n    cin >> x;\n    //对浮点数只能使用大于、小于号进行比较，不能使用等号和不等号，我这里直接把 double 转成字符串，就可以用不等号比较了\n    //根据输入条件的限制，可以这样写：x>0.01。\n    while(double2Str(x)!=\"0\"){\n        int i=2;\n        double sum=1.0/i;\n        while(sum < x){\n            i++;\n            sum += 1.0/i;\n        }\n        cout << i-1 << \" card(s)\" << endl;\n        cin >> x;\n    }\n    return 0;\n}\n```\n","slug":"POJ-1003-Hangover","published":1,"updated":"2018-06-10T11:59:11.939Z","layout":"post","photos":[],"link":"","_id":"cjm2w8dd7001ufgpxfxrtr2qr","content":"<p>这一题 AC 的速度还是挺快的，题目本身也是很简单：</p>\n<p>C++ 代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sstream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">double2Str</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">double</span> &amp;double_temp)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">stringstream</span> ss;</span><br><span class=\"line\">    ss &lt;&lt; double_temp;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> str;</span><br><span class=\"line\">    ss &gt;&gt; str;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> str;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> x;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; x;</span><br><span class=\"line\">    <span class=\"comment\">//对浮点数只能使用大于、小于号进行比较，不能使用等号和不等号，我这里直接把 double 转成字符串，就可以用不等号比较了</span></span><br><span class=\"line\">    <span class=\"comment\">//根据输入条件的限制，可以这样写：x&gt;0.01。</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(double2Str(x)!=<span class=\"string\">\"0\"</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i=<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> sum=<span class=\"number\">1.0</span>/i;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(sum &lt; x)&#123;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">            sum += <span class=\"number\">1.0</span>/i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; i<span class=\"number\">-1</span> &lt;&lt; <span class=\"string\">\" card(s)\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>这一题 AC 的速度还是挺快的，题目本身也是很简单：</p>\n<p>C++ 代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sstream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"built_in\">string</span> <span class=\"title\">double2Str</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">double</span> &amp;double_temp)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">stringstream</span> ss;</span><br><span class=\"line\">    ss &lt;&lt; double_temp;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> str;</span><br><span class=\"line\">    ss &gt;&gt; str;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> str;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> x;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; x;</span><br><span class=\"line\">    <span class=\"comment\">//对浮点数只能使用大于、小于号进行比较，不能使用等号和不等号，我这里直接把 double 转成字符串，就可以用不等号比较了</span></span><br><span class=\"line\">    <span class=\"comment\">//根据输入条件的限制，可以这样写：x&gt;0.01。</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(double2Str(x)!=<span class=\"string\">\"0\"</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> i=<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"keyword\">double</span> sum=<span class=\"number\">1.0</span>/i;</span><br><span class=\"line\">        <span class=\"keyword\">while</span>(sum &lt; x)&#123;</span><br><span class=\"line\">            i++;</span><br><span class=\"line\">            sum += <span class=\"number\">1.0</span>/i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; i<span class=\"number\">-1</span> &lt;&lt; <span class=\"string\">\" card(s)\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"POJ 1003 Hangover","date":"2018-01-20T16:00:00.000Z","comments":1,"_content":"\n这一题简单的有点过分了，一度让我有点怀疑，但当我直接提交 AC 的那一刻，才发现还真是就这么简单。\n\nC++ 代码：\n\n```C++\n#include <iostream>  \nusing namespace std;\n\nint main(){\n    double x;\n    double sum;\n    while(cin >> x){\n        sum += x;\n    }\n    cout << \"$\" << sum/12 << endl;\n    return 0;\n}\n```\n","source":"_posts/2018/2018-01-21-POJ-1004-Financial-Management.md","raw":"---\ntitle: POJ 1003 Hangover\ndate: 2018-01-21\ncategories: [ACM, POJ]\ncomments: true\n---\n\n这一题简单的有点过分了，一度让我有点怀疑，但当我直接提交 AC 的那一刻，才发现还真是就这么简单。\n\nC++ 代码：\n\n```C++\n#include <iostream>  \nusing namespace std;\n\nint main(){\n    double x;\n    double sum;\n    while(cin >> x){\n        sum += x;\n    }\n    cout << \"$\" << sum/12 << endl;\n    return 0;\n}\n```\n","slug":"POJ-1004-Financial-Management","published":1,"updated":"2018-06-10T11:59:16.818Z","layout":"post","photos":[],"link":"","_id":"cjm2w8dd8001xfgpxm72tqj6u","content":"<p>这一题简单的有点过分了，一度让我有点怀疑，但当我直接提交 AC 的那一刻，才发现还真是就这么简单。</p>\n<p>C++ 代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;  </span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> sum;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span> &gt;&gt; x)&#123;</span><br><span class=\"line\">        sum += x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"$\"</span> &lt;&lt; sum/<span class=\"number\">12</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>这一题简单的有点过分了，一度让我有点怀疑，但当我直接提交 AC 的那一刻，才发现还真是就这么简单。</p>\n<p>C++ 代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;  </span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> sum;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span> &gt;&gt; x)&#123;</span><br><span class=\"line\">        sum += x;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"$\"</span> &lt;&lt; sum/<span class=\"number\">12</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"POJ 1005 I Think I Need a Houseboat","date":"2018-01-20T16:00:00.000Z","comments":1,"_content":"\n这一题也很简单，直接上代码：\n\nC++ 代码：\n\n```C++\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint main(){\n    const double PI = 3.141592653589793;\n    int n;\n    double x;\n    double y;\n    double area;\n    int year;\n    cin >> n;\n    int i=1;\n    while(n--){\n        cin >> x >> y;\n        area = PI*(x*x+y*y)/2;\n        year = area/50 + 1;\n        cout << \"Property \" << i << \": This property will begin eroding in year \" << year << \".\" << endl;\n        i++;\n    }\n    cout << \"END OF OUTPUT.\" << endl;\n    return 0;\n}\n```\n","source":"_posts/2018/2018-01-21-POJ-1005-I-Think-I-Need-a-Houseboat.md","raw":"---\ntitle: POJ 1005 I Think I Need a Houseboat\ndate: 2018-01-21\ncategories: [ACM, POJ]\ncomments: true\n---\n\n这一题也很简单，直接上代码：\n\nC++ 代码：\n\n```C++\n#include <iostream>\n#include <cmath>\nusing namespace std;\n\nint main(){\n    const double PI = 3.141592653589793;\n    int n;\n    double x;\n    double y;\n    double area;\n    int year;\n    cin >> n;\n    int i=1;\n    while(n--){\n        cin >> x >> y;\n        area = PI*(x*x+y*y)/2;\n        year = area/50 + 1;\n        cout << \"Property \" << i << \": This property will begin eroding in year \" << year << \".\" << endl;\n        i++;\n    }\n    cout << \"END OF OUTPUT.\" << endl;\n    return 0;\n}\n```\n","slug":"POJ-1005-I-Think-I-Need-a-Houseboat","published":1,"updated":"2018-06-10T11:59:21.778Z","layout":"post","photos":[],"link":"","_id":"cjm2w8dd9001zfgpx0elpn0jx","content":"<p>这一题也很简单，直接上代码：</p>\n<p>C++ 代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">double</span> PI = <span class=\"number\">3.141592653589793</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> y;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> area;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> year;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n--)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class=\"line\">        area = PI*(x*x+y*y)/<span class=\"number\">2</span>;</span><br><span class=\"line\">        year = area/<span class=\"number\">50</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Property \"</span> &lt;&lt; i &lt;&lt; <span class=\"string\">\": This property will begin eroding in year \"</span> &lt;&lt; year &lt;&lt; <span class=\"string\">\".\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"END OF OUTPUT.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>这一题也很简单，直接上代码：</p>\n<p>C++ 代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;cmath&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">double</span> PI = <span class=\"number\">3.141592653589793</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> y;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> area;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> year;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n--)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class=\"line\">        area = PI*(x*x+y*y)/<span class=\"number\">2</span>;</span><br><span class=\"line\">        year = area/<span class=\"number\">50</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Property \"</span> &lt;&lt; i &lt;&lt; <span class=\"string\">\": This property will begin eroding in year \"</span> &lt;&lt; year &lt;&lt; <span class=\"string\">\".\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"END OF OUTPUT.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"POJ 1007 DNA sorting","date":"2018-02-20T16:00:00.000Z","comments":1,"_content":"\n这道题有点尴尬，刚开始一直没看懂，主要是先入为主，以为是对每一串字符串做排序，最后发现居然是根据每一串 DNA 的逆序数，对串之间进行排序。\n\n题目本身是简单的，第一步统计逆序数，第二步排序，这里使用C++标准库的sort。\n\nC++代码：\n\n```C++\n#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstruct dna\n{\n    int unorder;\n    string s;\n}DNA[105];\n\nint inversionNumber(string s){\n    int result = 0;\n    int A, C, G;\n    A = C = G = 0;\n    for(int i = s.length()-1;i>=0;--i){\n        switch(s[i]){\n            case 'A':\n                A++;\n                break;\n            case 'C':\n                C++;\n                result += A;\n                break;\n            case 'G':\n                G++;\n                result += A;\n                result += C;\n                break;\n            case 'T':\n                result += A;\n                result += C;\n                result += G;\n                break;\n            default:\n                break;\n        }\n    }\n    return result;\n}\n\nbool compare(dna a, dna b){\n    return a.unorder < b.unorder;\n}\n\nint main() {\n    int n, m;\n    int i=0;\n    cin >> n >> m;\n    while(i<m){\n        cin >> DNA[i].s;\n        DNA[i].unorder = inversionNumber(DNA[i].s);\n        i++;\n    }\n    sort(DNA, DNA+m, compare);\n    for(int i=0;i<m;++i){\n        cout << DNA[i].s << endl;\n    }\n    return 0;\n}\n```\n","source":"_posts/2018/2018-02-21-POJ-1007-DNA-sorting.md","raw":"---\ntitle: POJ 1007 DNA sorting\ndate: 2018-02-21\ncategories: [ACM, POJ]\ncomments: true\n---\n\n这道题有点尴尬，刚开始一直没看懂，主要是先入为主，以为是对每一串字符串做排序，最后发现居然是根据每一串 DNA 的逆序数，对串之间进行排序。\n\n题目本身是简单的，第一步统计逆序数，第二步排序，这里使用C++标准库的sort。\n\nC++代码：\n\n```C++\n#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nstruct dna\n{\n    int unorder;\n    string s;\n}DNA[105];\n\nint inversionNumber(string s){\n    int result = 0;\n    int A, C, G;\n    A = C = G = 0;\n    for(int i = s.length()-1;i>=0;--i){\n        switch(s[i]){\n            case 'A':\n                A++;\n                break;\n            case 'C':\n                C++;\n                result += A;\n                break;\n            case 'G':\n                G++;\n                result += A;\n                result += C;\n                break;\n            case 'T':\n                result += A;\n                result += C;\n                result += G;\n                break;\n            default:\n                break;\n        }\n    }\n    return result;\n}\n\nbool compare(dna a, dna b){\n    return a.unorder < b.unorder;\n}\n\nint main() {\n    int n, m;\n    int i=0;\n    cin >> n >> m;\n    while(i<m){\n        cin >> DNA[i].s;\n        DNA[i].unorder = inversionNumber(DNA[i].s);\n        i++;\n    }\n    sort(DNA, DNA+m, compare);\n    for(int i=0;i<m;++i){\n        cout << DNA[i].s << endl;\n    }\n    return 0;\n}\n```\n","slug":"POJ-1007-DNA-sorting","published":1,"updated":"2018-06-10T11:59:35.570Z","layout":"post","photos":[],"link":"","_id":"cjm2w8dda0021fgpxl6kehe4x","content":"<p>这道题有点尴尬，刚开始一直没看懂，主要是先入为主，以为是对每一串字符串做排序，最后发现居然是根据每一串 DNA 的逆序数，对串之间进行排序。</p>\n<p>题目本身是简单的，第一步统计逆序数，第二步排序，这里使用C++标准库的sort。</p>\n<p>C++代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dna</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> unorder;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> s;</span><br><span class=\"line\">&#125;DNA[<span class=\"number\">105</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">inversionNumber</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> A, C, G;</span><br><span class=\"line\">    A = C = G = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = s.length()<span class=\"number\">-1</span>;i&gt;=<span class=\"number\">0</span>;--i)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(s[i])&#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">'A'</span>:</span><br><span class=\"line\">                A++;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">'C'</span>:</span><br><span class=\"line\">                C++;</span><br><span class=\"line\">                result += A;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">'G'</span>:</span><br><span class=\"line\">                G++;</span><br><span class=\"line\">                result += A;</span><br><span class=\"line\">                result += C;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">'T'</span>:</span><br><span class=\"line\">                result += A;</span><br><span class=\"line\">                result += C;</span><br><span class=\"line\">                result += G;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">compare</span><span class=\"params\">(dna a, dna b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.unorder &lt; b.unorder;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i&lt;m)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; DNA[i].s;</span><br><span class=\"line\">        DNA[i].unorder = inversionNumber(DNA[i].s);</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sort(DNA, DNA+m, compare);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;m;++i)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; DNA[i].s &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>这道题有点尴尬，刚开始一直没看懂，主要是先入为主，以为是对每一串字符串做排序，最后发现居然是根据每一串 DNA 的逆序数，对串之间进行排序。</p>\n<p>题目本身是简单的，第一步统计逆序数，第二步排序，这里使用C++标准库的sort。</p>\n<p>C++代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dna</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> unorder;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> s;</span><br><span class=\"line\">&#125;DNA[<span class=\"number\">105</span>];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">inversionNumber</span><span class=\"params\">(<span class=\"built_in\">string</span> s)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> result = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> A, C, G;</span><br><span class=\"line\">    A = C = G = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = s.length()<span class=\"number\">-1</span>;i&gt;=<span class=\"number\">0</span>;--i)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(s[i])&#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">'A'</span>:</span><br><span class=\"line\">                A++;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">'C'</span>:</span><br><span class=\"line\">                C++;</span><br><span class=\"line\">                result += A;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">'G'</span>:</span><br><span class=\"line\">                G++;</span><br><span class=\"line\">                result += A;</span><br><span class=\"line\">                result += C;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"string\">'T'</span>:</span><br><span class=\"line\">                result += A;</span><br><span class=\"line\">                result += C;</span><br><span class=\"line\">                result += G;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">compare</span><span class=\"params\">(dna a, dna b)</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.unorder &lt; b.unorder;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, m;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(i&lt;m)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; DNA[i].s;</span><br><span class=\"line\">        DNA[i].unorder = inversionNumber(DNA[i].s);</span><br><span class=\"line\">        i++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    sort(DNA, DNA+m, compare);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;m;++i)&#123;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; DNA[i].s &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"POJ 1006 Biorhythms","date":"2018-02-14T16:00:00.000Z","comments":1,"_content":"\n## 同余\n\n两个整数 a, b，若它们除以正整数 m所得的余数相等，则称 a,b对于模 m 同余，记作：$a \\equiv b (mod\\quad m)$。最先引用同余的概念与”$\\equiv$”符号的是德国数学家 高斯。\n\n## 中国剩余定理\n\n在《孙子算经》中有这样一个问题：“今有物不知其数，三三数之剩二（除以3余2），五五数之剩三（除以5余3），七七数之剩二（除以7余2），问物几何？”这个问题称为“孙子问题”，该问题的一般解法国际上称为“中国剩余定理”。具体解法分三步：\n\n找出三个数：从3和5的公倍数中找出被7除余1的最小数15，从3和7的公倍数中找出被5除余1 的最小数21，最后从5和7的公倍数中找出除3余1的最小数70。\n用15乘以2（2为最终结果除以7的余数），用21乘以3（3为最终结果除以5的余数），同理，用70乘以2（2为最终结果除以3的余数），然后把三个乘积相加（15*2+21*3+70*2）得到和233。\n用233除以3，5，7三个数的最小公倍数105，得到余数23，即233%105=23。这个余数23就是符合条件的最小数。\n\n为什么要这么做呢？\n\n这就牵涉到一个最基本数学定理，如果有a%b=c,则有(a+kb)%b=c(k为非零整数)，换句话说，如果一个除法运算的余数为c，那么被除数与k倍的除数相加（或相减）的和（差）再与除数相除，余数不变。这就是上面提到的同余。\n\n以此定理为依据，如果n2是3的倍数，n1+n2就依然满足除以3余2。同理，如果n3也是3的倍数，那么n1+n2+n3的和就满足除以3余2。这是从n1的角度考虑的，再从n2，n3的角度出发，我们可推导出以下三点：\n\n- 为使n1+n2+n3的和满足除以3余2，n2和n3必须是3的倍数。\n- 为使n1+n2+n3的和满足除以5余3，n1和n3必须是5的倍数。\n- 为使n1+n2+n3的和满足除以7余2，n1和n2必须是7的倍数。\n\n因此，为使n1+n2+n3的和作为“孙子问题”的一个最终解，需满足：\n\n- n1除以3余2，且是5和7的公倍数。\n- n2除以5余3，且是3和7的公倍数。\n- n3除以7余2，且是3和5的公倍数。\n\n所以，孙子问题解法的本质是从5和7的公倍数中找一个除以3余2的数n1，从3和7的公倍数中找一个除以5余3的数n2，从3和5的公倍数中找一个除以7余2的数n3，再将三个数相加得到解。在求n1，n2，n3时又用了一个小技巧，以n1为例，并非从5和7的公倍数中直接找一个除以3余2的数，而是先找一个除以3余1的数，再乘以2。\n\n最后，我们还要清楚一点，n1+n2+n3只是问题的一个解，并不是最小的解。如何得到最小解？我们只需要从中最大限度的减掉掉3，5，7的公倍数105即可。道理就是前面讲过的定理“如果a%b=c,则有(a-kb)%b=c”。所以（n1+n2+n3）%105就是最终的最小解。\n\n总结就两个公式：\n\n- 如果 a%b=c , 则有 (a+kb)%b=c (k为非零整数)。\n- 如果 a%b=c，那么 (a*k)%b=kc (k为大于零的整数)。\n\n## 解题代码\n\n最后我们再来看看我们这道题，如何使用中国剩余定理来得到时间复杂度 O(1) 的解。\n\n已知(n+d)%23=p; (n+d)%28=e; (n+d)%33=i\n\n使33×28×a被23除余1，用33×28×8=5544；\n\n使23×33×b被28除余1，用23×33×19=14421；\n\n使23×28×c被33除余1，用23×28×2=1288。\n\n因此有（5544×p+14421×e+1288×i）% lcm(23,28,33) =n+d\n\n又23、28、33互质，即lcm(23,28,33)= 21252;\n\n所以有n=（5544×p+14421×e+1288×i-d）%21252\n\n本题所求的是最小整数解，避免n为负，因此最后结果为n= [n+21252]% 21252\n\n那么最终求解n的表达式就是：\nn=(5544p+14421e+1288*i-d+21252)%21252\n\n```C++\n#include <iostream>\n\nusing namespace std;\n\n#define P 23\n#define E 28\n#define I 33\n#define C 21252\n\nint main() {\n    int p, e, i, d;\n    int count=1;\n    int J=E*I;\n    int K=P*I;\n    int H=P*E;\n    int j;\n    int k;\n    int h;\n    for(j=J;j%P!=1;j+=J);\n    for(k=K;k%E!=1;k+=K);\n    for(h=H;h%I!=1;h+=H);\n    // cout << j << endl;\n    // cout << k << endl;\n    // cout << h << endl;\n    while (cin >> p >> e >> i >> d) {\n        if(p==-1){\n            break;\n        }\n        int result = (j*p+k*e+h*i-d+C)%C;\n        if(result==0)\n            result = C;\n        cout << \"Case \"<< count << \": the next triple peak occurs in \" << result << \" days.\" << endl;\n        count++;\n    }\n    return 0;\n}\n```\n","source":"_posts/2018/2018-02-15-POJ-1006-Biorhythms.md","raw":"---\ntitle: POJ 1006 Biorhythms\ndate: 2018-02-15\ncategories: [ACM, POJ]\ncomments: true\n---\n\n## 同余\n\n两个整数 a, b，若它们除以正整数 m所得的余数相等，则称 a,b对于模 m 同余，记作：$a \\equiv b (mod\\quad m)$。最先引用同余的概念与”$\\equiv$”符号的是德国数学家 高斯。\n\n## 中国剩余定理\n\n在《孙子算经》中有这样一个问题：“今有物不知其数，三三数之剩二（除以3余2），五五数之剩三（除以5余3），七七数之剩二（除以7余2），问物几何？”这个问题称为“孙子问题”，该问题的一般解法国际上称为“中国剩余定理”。具体解法分三步：\n\n找出三个数：从3和5的公倍数中找出被7除余1的最小数15，从3和7的公倍数中找出被5除余1 的最小数21，最后从5和7的公倍数中找出除3余1的最小数70。\n用15乘以2（2为最终结果除以7的余数），用21乘以3（3为最终结果除以5的余数），同理，用70乘以2（2为最终结果除以3的余数），然后把三个乘积相加（15*2+21*3+70*2）得到和233。\n用233除以3，5，7三个数的最小公倍数105，得到余数23，即233%105=23。这个余数23就是符合条件的最小数。\n\n为什么要这么做呢？\n\n这就牵涉到一个最基本数学定理，如果有a%b=c,则有(a+kb)%b=c(k为非零整数)，换句话说，如果一个除法运算的余数为c，那么被除数与k倍的除数相加（或相减）的和（差）再与除数相除，余数不变。这就是上面提到的同余。\n\n以此定理为依据，如果n2是3的倍数，n1+n2就依然满足除以3余2。同理，如果n3也是3的倍数，那么n1+n2+n3的和就满足除以3余2。这是从n1的角度考虑的，再从n2，n3的角度出发，我们可推导出以下三点：\n\n- 为使n1+n2+n3的和满足除以3余2，n2和n3必须是3的倍数。\n- 为使n1+n2+n3的和满足除以5余3，n1和n3必须是5的倍数。\n- 为使n1+n2+n3的和满足除以7余2，n1和n2必须是7的倍数。\n\n因此，为使n1+n2+n3的和作为“孙子问题”的一个最终解，需满足：\n\n- n1除以3余2，且是5和7的公倍数。\n- n2除以5余3，且是3和7的公倍数。\n- n3除以7余2，且是3和5的公倍数。\n\n所以，孙子问题解法的本质是从5和7的公倍数中找一个除以3余2的数n1，从3和7的公倍数中找一个除以5余3的数n2，从3和5的公倍数中找一个除以7余2的数n3，再将三个数相加得到解。在求n1，n2，n3时又用了一个小技巧，以n1为例，并非从5和7的公倍数中直接找一个除以3余2的数，而是先找一个除以3余1的数，再乘以2。\n\n最后，我们还要清楚一点，n1+n2+n3只是问题的一个解，并不是最小的解。如何得到最小解？我们只需要从中最大限度的减掉掉3，5，7的公倍数105即可。道理就是前面讲过的定理“如果a%b=c,则有(a-kb)%b=c”。所以（n1+n2+n3）%105就是最终的最小解。\n\n总结就两个公式：\n\n- 如果 a%b=c , 则有 (a+kb)%b=c (k为非零整数)。\n- 如果 a%b=c，那么 (a*k)%b=kc (k为大于零的整数)。\n\n## 解题代码\n\n最后我们再来看看我们这道题，如何使用中国剩余定理来得到时间复杂度 O(1) 的解。\n\n已知(n+d)%23=p; (n+d)%28=e; (n+d)%33=i\n\n使33×28×a被23除余1，用33×28×8=5544；\n\n使23×33×b被28除余1，用23×33×19=14421；\n\n使23×28×c被33除余1，用23×28×2=1288。\n\n因此有（5544×p+14421×e+1288×i）% lcm(23,28,33) =n+d\n\n又23、28、33互质，即lcm(23,28,33)= 21252;\n\n所以有n=（5544×p+14421×e+1288×i-d）%21252\n\n本题所求的是最小整数解，避免n为负，因此最后结果为n= [n+21252]% 21252\n\n那么最终求解n的表达式就是：\nn=(5544p+14421e+1288*i-d+21252)%21252\n\n```C++\n#include <iostream>\n\nusing namespace std;\n\n#define P 23\n#define E 28\n#define I 33\n#define C 21252\n\nint main() {\n    int p, e, i, d;\n    int count=1;\n    int J=E*I;\n    int K=P*I;\n    int H=P*E;\n    int j;\n    int k;\n    int h;\n    for(j=J;j%P!=1;j+=J);\n    for(k=K;k%E!=1;k+=K);\n    for(h=H;h%I!=1;h+=H);\n    // cout << j << endl;\n    // cout << k << endl;\n    // cout << h << endl;\n    while (cin >> p >> e >> i >> d) {\n        if(p==-1){\n            break;\n        }\n        int result = (j*p+k*e+h*i-d+C)%C;\n        if(result==0)\n            result = C;\n        cout << \"Case \"<< count << \": the next triple peak occurs in \" << result << \" days.\" << endl;\n        count++;\n    }\n    return 0;\n}\n```\n","slug":"POJ-1006-Biorhythms","published":1,"updated":"2018-06-10T11:59:26.770Z","layout":"post","photos":[],"link":"","_id":"cjm2w8ddb0024fgpx141ubpmj","content":"<h2 id=\"同余\"><a href=\"#同余\" class=\"headerlink\" title=\"同余\"></a>同余</h2><p>两个整数 a, b，若它们除以正整数 m所得的余数相等，则称 a,b对于模 m 同余，记作：$a \\equiv b (mod\\quad m)$。最先引用同余的概念与”$\\equiv$”符号的是德国数学家 高斯。</p>\n<h2 id=\"中国剩余定理\"><a href=\"#中国剩余定理\" class=\"headerlink\" title=\"中国剩余定理\"></a>中国剩余定理</h2><p>在《孙子算经》中有这样一个问题：“今有物不知其数，三三数之剩二（除以3余2），五五数之剩三（除以5余3），七七数之剩二（除以7余2），问物几何？”这个问题称为“孙子问题”，该问题的一般解法国际上称为“中国剩余定理”。具体解法分三步：</p>\n<p>找出三个数：从3和5的公倍数中找出被7除余1的最小数15，从3和7的公倍数中找出被5除余1 的最小数21，最后从5和7的公倍数中找出除3余1的最小数70。<br>用15乘以2（2为最终结果除以7的余数），用21乘以3（3为最终结果除以5的余数），同理，用70乘以2（2为最终结果除以3的余数），然后把三个乘积相加（15<em>2+21</em>3+70*2）得到和233。<br>用233除以3，5，7三个数的最小公倍数105，得到余数23，即233%105=23。这个余数23就是符合条件的最小数。</p>\n<p>为什么要这么做呢？</p>\n<p>这就牵涉到一个最基本数学定理，如果有a%b=c,则有(a+kb)%b=c(k为非零整数)，换句话说，如果一个除法运算的余数为c，那么被除数与k倍的除数相加（或相减）的和（差）再与除数相除，余数不变。这就是上面提到的同余。</p>\n<p>以此定理为依据，如果n2是3的倍数，n1+n2就依然满足除以3余2。同理，如果n3也是3的倍数，那么n1+n2+n3的和就满足除以3余2。这是从n1的角度考虑的，再从n2，n3的角度出发，我们可推导出以下三点：</p>\n<ul>\n<li>为使n1+n2+n3的和满足除以3余2，n2和n3必须是3的倍数。</li>\n<li>为使n1+n2+n3的和满足除以5余3，n1和n3必须是5的倍数。</li>\n<li>为使n1+n2+n3的和满足除以7余2，n1和n2必须是7的倍数。</li>\n</ul>\n<p>因此，为使n1+n2+n3的和作为“孙子问题”的一个最终解，需满足：</p>\n<ul>\n<li>n1除以3余2，且是5和7的公倍数。</li>\n<li>n2除以5余3，且是3和7的公倍数。</li>\n<li>n3除以7余2，且是3和5的公倍数。</li>\n</ul>\n<p>所以，孙子问题解法的本质是从5和7的公倍数中找一个除以3余2的数n1，从3和7的公倍数中找一个除以5余3的数n2，从3和5的公倍数中找一个除以7余2的数n3，再将三个数相加得到解。在求n1，n2，n3时又用了一个小技巧，以n1为例，并非从5和7的公倍数中直接找一个除以3余2的数，而是先找一个除以3余1的数，再乘以2。</p>\n<p>最后，我们还要清楚一点，n1+n2+n3只是问题的一个解，并不是最小的解。如何得到最小解？我们只需要从中最大限度的减掉掉3，5，7的公倍数105即可。道理就是前面讲过的定理“如果a%b=c,则有(a-kb)%b=c”。所以（n1+n2+n3）%105就是最终的最小解。</p>\n<p>总结就两个公式：</p>\n<ul>\n<li>如果 a%b=c , 则有 (a+kb)%b=c (k为非零整数)。</li>\n<li>如果 a%b=c，那么 (a*k)%b=kc (k为大于零的整数)。</li>\n</ul>\n<h2 id=\"解题代码\"><a href=\"#解题代码\" class=\"headerlink\" title=\"解题代码\"></a>解题代码</h2><p>最后我们再来看看我们这道题，如何使用中国剩余定理来得到时间复杂度 O(1) 的解。</p>\n<p>已知(n+d)%23=p; (n+d)%28=e; (n+d)%33=i</p>\n<p>使33×28×a被23除余1，用33×28×8=5544；</p>\n<p>使23×33×b被28除余1，用23×33×19=14421；</p>\n<p>使23×28×c被33除余1，用23×28×2=1288。</p>\n<p>因此有（5544×p+14421×e+1288×i）% lcm(23,28,33) =n+d</p>\n<p>又23、28、33互质，即lcm(23,28,33)= 21252;</p>\n<p>所以有n=（5544×p+14421×e+1288×i-d）%21252</p>\n<p>本题所求的是最小整数解，避免n为负，因此最后结果为n= [n+21252]% 21252</p>\n<p>那么最终求解n的表达式就是：<br>n=(5544p+14421e+1288*i-d+21252)%21252</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> P 23</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> E 28</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> I 33</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> C 21252</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> p, e, i, d;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> J=E*I;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> K=P*I;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> H=P*E;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> k;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(j=J;j%P!=<span class=\"number\">1</span>;j+=J);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(k=K;k%E!=<span class=\"number\">1</span>;k+=K);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(h=H;h%I!=<span class=\"number\">1</span>;h+=H);</span><br><span class=\"line\">    <span class=\"comment\">// cout &lt;&lt; j &lt;&lt; endl;</span></span><br><span class=\"line\">    <span class=\"comment\">// cout &lt;&lt; k &lt;&lt; endl;</span></span><br><span class=\"line\">    <span class=\"comment\">// cout &lt;&lt; h &lt;&lt; endl;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"built_in\">cin</span> &gt;&gt; p &gt;&gt; e &gt;&gt; i &gt;&gt; d) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p==<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = (j*p+k*e+h*i-d+C)%C;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(result==<span class=\"number\">0</span>)</span><br><span class=\"line\">            result = C;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Case \"</span>&lt;&lt; count &lt;&lt; <span class=\"string\">\": the next triple peak occurs in \"</span> &lt;&lt; result &lt;&lt; <span class=\"string\">\" days.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"同余\"><a href=\"#同余\" class=\"headerlink\" title=\"同余\"></a>同余</h2><p>两个整数 a, b，若它们除以正整数 m所得的余数相等，则称 a,b对于模 m 同余，记作：$a \\equiv b (mod\\quad m)$。最先引用同余的概念与”$\\equiv$”符号的是德国数学家 高斯。</p>\n<h2 id=\"中国剩余定理\"><a href=\"#中国剩余定理\" class=\"headerlink\" title=\"中国剩余定理\"></a>中国剩余定理</h2><p>在《孙子算经》中有这样一个问题：“今有物不知其数，三三数之剩二（除以3余2），五五数之剩三（除以5余3），七七数之剩二（除以7余2），问物几何？”这个问题称为“孙子问题”，该问题的一般解法国际上称为“中国剩余定理”。具体解法分三步：</p>\n<p>找出三个数：从3和5的公倍数中找出被7除余1的最小数15，从3和7的公倍数中找出被5除余1 的最小数21，最后从5和7的公倍数中找出除3余1的最小数70。<br>用15乘以2（2为最终结果除以7的余数），用21乘以3（3为最终结果除以5的余数），同理，用70乘以2（2为最终结果除以3的余数），然后把三个乘积相加（15<em>2+21</em>3+70*2）得到和233。<br>用233除以3，5，7三个数的最小公倍数105，得到余数23，即233%105=23。这个余数23就是符合条件的最小数。</p>\n<p>为什么要这么做呢？</p>\n<p>这就牵涉到一个最基本数学定理，如果有a%b=c,则有(a+kb)%b=c(k为非零整数)，换句话说，如果一个除法运算的余数为c，那么被除数与k倍的除数相加（或相减）的和（差）再与除数相除，余数不变。这就是上面提到的同余。</p>\n<p>以此定理为依据，如果n2是3的倍数，n1+n2就依然满足除以3余2。同理，如果n3也是3的倍数，那么n1+n2+n3的和就满足除以3余2。这是从n1的角度考虑的，再从n2，n3的角度出发，我们可推导出以下三点：</p>\n<ul>\n<li>为使n1+n2+n3的和满足除以3余2，n2和n3必须是3的倍数。</li>\n<li>为使n1+n2+n3的和满足除以5余3，n1和n3必须是5的倍数。</li>\n<li>为使n1+n2+n3的和满足除以7余2，n1和n2必须是7的倍数。</li>\n</ul>\n<p>因此，为使n1+n2+n3的和作为“孙子问题”的一个最终解，需满足：</p>\n<ul>\n<li>n1除以3余2，且是5和7的公倍数。</li>\n<li>n2除以5余3，且是3和7的公倍数。</li>\n<li>n3除以7余2，且是3和5的公倍数。</li>\n</ul>\n<p>所以，孙子问题解法的本质是从5和7的公倍数中找一个除以3余2的数n1，从3和7的公倍数中找一个除以5余3的数n2，从3和5的公倍数中找一个除以7余2的数n3，再将三个数相加得到解。在求n1，n2，n3时又用了一个小技巧，以n1为例，并非从5和7的公倍数中直接找一个除以3余2的数，而是先找一个除以3余1的数，再乘以2。</p>\n<p>最后，我们还要清楚一点，n1+n2+n3只是问题的一个解，并不是最小的解。如何得到最小解？我们只需要从中最大限度的减掉掉3，5，7的公倍数105即可。道理就是前面讲过的定理“如果a%b=c,则有(a-kb)%b=c”。所以（n1+n2+n3）%105就是最终的最小解。</p>\n<p>总结就两个公式：</p>\n<ul>\n<li>如果 a%b=c , 则有 (a+kb)%b=c (k为非零整数)。</li>\n<li>如果 a%b=c，那么 (a*k)%b=kc (k为大于零的整数)。</li>\n</ul>\n<h2 id=\"解题代码\"><a href=\"#解题代码\" class=\"headerlink\" title=\"解题代码\"></a>解题代码</h2><p>最后我们再来看看我们这道题，如何使用中国剩余定理来得到时间复杂度 O(1) 的解。</p>\n<p>已知(n+d)%23=p; (n+d)%28=e; (n+d)%33=i</p>\n<p>使33×28×a被23除余1，用33×28×8=5544；</p>\n<p>使23×33×b被28除余1，用23×33×19=14421；</p>\n<p>使23×28×c被33除余1，用23×28×2=1288。</p>\n<p>因此有（5544×p+14421×e+1288×i）% lcm(23,28,33) =n+d</p>\n<p>又23、28、33互质，即lcm(23,28,33)= 21252;</p>\n<p>所以有n=（5544×p+14421×e+1288×i-d）%21252</p>\n<p>本题所求的是最小整数解，避免n为负，因此最后结果为n= [n+21252]% 21252</p>\n<p>那么最终求解n的表达式就是：<br>n=(5544p+14421e+1288*i-d+21252)%21252</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> P 23</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> E 28</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> I 33</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> C 21252</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> p, e, i, d;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> J=E*I;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> K=P*I;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> H=P*E;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> j;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> k;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(j=J;j%P!=<span class=\"number\">1</span>;j+=J);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(k=K;k%E!=<span class=\"number\">1</span>;k+=K);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(h=H;h%I!=<span class=\"number\">1</span>;h+=H);</span><br><span class=\"line\">    <span class=\"comment\">// cout &lt;&lt; j &lt;&lt; endl;</span></span><br><span class=\"line\">    <span class=\"comment\">// cout &lt;&lt; k &lt;&lt; endl;</span></span><br><span class=\"line\">    <span class=\"comment\">// cout &lt;&lt; h &lt;&lt; endl;</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (<span class=\"built_in\">cin</span> &gt;&gt; p &gt;&gt; e &gt;&gt; i &gt;&gt; d) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(p==<span class=\"number\">-1</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = (j*p+k*e+h*i-d+C)%C;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(result==<span class=\"number\">0</span>)</span><br><span class=\"line\">            result = C;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"Case \"</span>&lt;&lt; count &lt;&lt; <span class=\"string\">\": the next triple peak occurs in \"</span> &lt;&lt; result &lt;&lt; <span class=\"string\">\" days.\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"POJ 1008 Maya Calendar","date":"2018-02-21T16:00:00.000Z","comments":1,"_content":"\n这一题的话：\n\n1. 要注意 C++ 的 switch 不能使用 string，所以只好写成 if 来判断了。\n2. 另外一个值得注意的地方是，空格会中断标准输入，所以不能使用一个 string 来装下一行输入，而是分别用 string Day，string str，int Year，装下 day, month, year。\n3. 注意 Day[i]-'0'\n4. 可以使用分批输出，无需打包成一个 string。\n\nC++代码：\n\n```C++\n#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n#define Haab 365\n#define Tzolkin 260\n\nint main() {\n    int n;\n    cin>>n;\n    string Day;\n    int Year;\n    string str;\n    cout << n << endl;\n    while(n--){\n        int num=0;\n        cin >> Day;\n        for(int i=0;Day[i]!='.';++i){\n            num = num*10+Day[i]-'0';\n        }\n        cin >> str;\n        if(str==\"no\")num += 20;\n        if(str==\"zip\")num+=40;\n        if(str==\"zotz\")num+=60;\n        if(str==\"tzec\")num+=80;\n        if(str==\"xul\")num+=100;\n        if(str==\"yoxkin\")num+=120;\n        if(str==\"mol\")num+=140;\n        if(str==\"chen\")num+=160;\n        if(str==\"yax\")num+=180;\n        if(str==\"zac\")num+=200;\n        if(str==\"ceh\")num+=220;\n        if(str==\"mac\")num+=240;\n        if(str==\"kankin\")num+=260;\n        if(str==\"muan\")num+=280;\n        if(str==\"pax\")num+=300;\n        if(str==\"koyab\")num+=320;\n        if(str==\"cumhu\")num+=340;\n        if(str==\"uayet\")num+=360;\n        cin >> Year;\n        num += Year*365;\n        cout << num%13+1;\n        int month = num%260;\n        switch(month%20){\n            case 0:\n                str = \"imix\";\n                break;\n            case 1:\n                str = \"ik\";\n                break;\n            case 2:\n                str = \"akbal\";\n                break;\n            case 3:\n                str = \"kan\";\n                break;\n            case 4:\n                str = \"chicchan\";\n                break;\n            case 5:\n                str = \"cimi\";\n                break;\n            case 6:\n                str = \"manik\";\n                break;\n            case 7:\n                str = \"lamat\";\n                break;\n            case 8:\n                str = \"muluk\";\n                break;\n            case 9:\n                str = \"ok\";\n                break;\n            case 10:\n                str = \"chuen\";\n                break;\n            case 11:\n                str = \"eb\";\n                break;\n            case 12:\n                str = \"ben\";\n                break;\n            case 13:\n                str = \"ix\";\n                break;\n            case 14:\n                str = \"mem\";\n                break;\n            case 15:\n                str = \"cib\";\n                break;\n            case 16:\n                str = \"caban\";\n                break;\n            case 17:\n                str = \"eznab\";\n                break;\n            case 18:\n                str = \"canac\";\n                break;\n            case 19:\n                str = \"ahau\";\n                break;\n        }\n        cout << \" \" +str +\" \";\n        cout << num/260 << endl;\n    }\n    return 0;\n}\n```\n","source":"_posts/2018/2018-02-22-POJ-1008-Maya-Calendar.md","raw":"---\ntitle: POJ 1008 Maya Calendar\ndate: 2018-02-22\ncategories: [ACM, POJ]\ncomments: true\n---\n\n这一题的话：\n\n1. 要注意 C++ 的 switch 不能使用 string，所以只好写成 if 来判断了。\n2. 另外一个值得注意的地方是，空格会中断标准输入，所以不能使用一个 string 来装下一行输入，而是分别用 string Day，string str，int Year，装下 day, month, year。\n3. 注意 Day[i]-'0'\n4. 可以使用分批输出，无需打包成一个 string。\n\nC++代码：\n\n```C++\n#include <iostream>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\n#define Haab 365\n#define Tzolkin 260\n\nint main() {\n    int n;\n    cin>>n;\n    string Day;\n    int Year;\n    string str;\n    cout << n << endl;\n    while(n--){\n        int num=0;\n        cin >> Day;\n        for(int i=0;Day[i]!='.';++i){\n            num = num*10+Day[i]-'0';\n        }\n        cin >> str;\n        if(str==\"no\")num += 20;\n        if(str==\"zip\")num+=40;\n        if(str==\"zotz\")num+=60;\n        if(str==\"tzec\")num+=80;\n        if(str==\"xul\")num+=100;\n        if(str==\"yoxkin\")num+=120;\n        if(str==\"mol\")num+=140;\n        if(str==\"chen\")num+=160;\n        if(str==\"yax\")num+=180;\n        if(str==\"zac\")num+=200;\n        if(str==\"ceh\")num+=220;\n        if(str==\"mac\")num+=240;\n        if(str==\"kankin\")num+=260;\n        if(str==\"muan\")num+=280;\n        if(str==\"pax\")num+=300;\n        if(str==\"koyab\")num+=320;\n        if(str==\"cumhu\")num+=340;\n        if(str==\"uayet\")num+=360;\n        cin >> Year;\n        num += Year*365;\n        cout << num%13+1;\n        int month = num%260;\n        switch(month%20){\n            case 0:\n                str = \"imix\";\n                break;\n            case 1:\n                str = \"ik\";\n                break;\n            case 2:\n                str = \"akbal\";\n                break;\n            case 3:\n                str = \"kan\";\n                break;\n            case 4:\n                str = \"chicchan\";\n                break;\n            case 5:\n                str = \"cimi\";\n                break;\n            case 6:\n                str = \"manik\";\n                break;\n            case 7:\n                str = \"lamat\";\n                break;\n            case 8:\n                str = \"muluk\";\n                break;\n            case 9:\n                str = \"ok\";\n                break;\n            case 10:\n                str = \"chuen\";\n                break;\n            case 11:\n                str = \"eb\";\n                break;\n            case 12:\n                str = \"ben\";\n                break;\n            case 13:\n                str = \"ix\";\n                break;\n            case 14:\n                str = \"mem\";\n                break;\n            case 15:\n                str = \"cib\";\n                break;\n            case 16:\n                str = \"caban\";\n                break;\n            case 17:\n                str = \"eznab\";\n                break;\n            case 18:\n                str = \"canac\";\n                break;\n            case 19:\n                str = \"ahau\";\n                break;\n        }\n        cout << \" \" +str +\" \";\n        cout << num/260 << endl;\n    }\n    return 0;\n}\n```\n","slug":"POJ-1008-Maya-Calendar","published":1,"updated":"2018-06-10T11:59:41.465Z","layout":"post","photos":[],"link":"","_id":"cjm2w8ddc0025fgpx13mibade","content":"<p>这一题的话：</p>\n<ol>\n<li>要注意 C++ 的 switch 不能使用 string，所以只好写成 if 来判断了。</li>\n<li>另外一个值得注意的地方是，空格会中断标准输入，所以不能使用一个 string 来装下一行输入，而是分别用 string Day，string str，int Year，装下 day, month, year。</li>\n<li>注意 Day[i]-‘0’</li>\n<li>可以使用分批输出，无需打包成一个 string。</li>\n</ol>\n<p>C++代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Haab 365</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Tzolkin 260</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> Day;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> Year;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> str;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; n &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n--)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> num=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; Day;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;Day[i]!=<span class=\"string\">'.'</span>;++i)&#123;</span><br><span class=\"line\">            num = num*<span class=\"number\">10</span>+Day[i]-<span class=\"string\">'0'</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; str;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str==<span class=\"string\">\"no\"</span>)num += <span class=\"number\">20</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str==<span class=\"string\">\"zip\"</span>)num+=<span class=\"number\">40</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str==<span class=\"string\">\"zotz\"</span>)num+=<span class=\"number\">60</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str==<span class=\"string\">\"tzec\"</span>)num+=<span class=\"number\">80</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str==<span class=\"string\">\"xul\"</span>)num+=<span class=\"number\">100</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str==<span class=\"string\">\"yoxkin\"</span>)num+=<span class=\"number\">120</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str==<span class=\"string\">\"mol\"</span>)num+=<span class=\"number\">140</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str==<span class=\"string\">\"chen\"</span>)num+=<span class=\"number\">160</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str==<span class=\"string\">\"yax\"</span>)num+=<span class=\"number\">180</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str==<span class=\"string\">\"zac\"</span>)num+=<span class=\"number\">200</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str==<span class=\"string\">\"ceh\"</span>)num+=<span class=\"number\">220</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str==<span class=\"string\">\"mac\"</span>)num+=<span class=\"number\">240</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str==<span class=\"string\">\"kankin\"</span>)num+=<span class=\"number\">260</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str==<span class=\"string\">\"muan\"</span>)num+=<span class=\"number\">280</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str==<span class=\"string\">\"pax\"</span>)num+=<span class=\"number\">300</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str==<span class=\"string\">\"koyab\"</span>)num+=<span class=\"number\">320</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str==<span class=\"string\">\"cumhu\"</span>)num+=<span class=\"number\">340</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str==<span class=\"string\">\"uayet\"</span>)num+=<span class=\"number\">360</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; Year;</span><br><span class=\"line\">        num += Year*<span class=\"number\">365</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; num%<span class=\"number\">13</span>+<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> month = num%<span class=\"number\">260</span>;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(month%<span class=\"number\">20</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">                str = <span class=\"string\">\"imix\"</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">                str = <span class=\"string\">\"ik\"</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">                str = <span class=\"string\">\"akbal\"</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">3</span>:</span><br><span class=\"line\">                str = <span class=\"string\">\"kan\"</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">4</span>:</span><br><span class=\"line\">                str = <span class=\"string\">\"chicchan\"</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">5</span>:</span><br><span class=\"line\">                str = <span class=\"string\">\"cimi\"</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">6</span>:</span><br><span class=\"line\">                str = <span class=\"string\">\"manik\"</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">7</span>:</span><br><span class=\"line\">                str = <span class=\"string\">\"lamat\"</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">8</span>:</span><br><span class=\"line\">                str = <span class=\"string\">\"muluk\"</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">9</span>:</span><br><span class=\"line\">                str = <span class=\"string\">\"ok\"</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">10</span>:</span><br><span class=\"line\">                str = <span class=\"string\">\"chuen\"</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">11</span>:</span><br><span class=\"line\">                str = <span class=\"string\">\"eb\"</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">12</span>:</span><br><span class=\"line\">                str = <span class=\"string\">\"ben\"</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">13</span>:</span><br><span class=\"line\">                str = <span class=\"string\">\"ix\"</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">14</span>:</span><br><span class=\"line\">                str = <span class=\"string\">\"mem\"</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">15</span>:</span><br><span class=\"line\">                str = <span class=\"string\">\"cib\"</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">16</span>:</span><br><span class=\"line\">                str = <span class=\"string\">\"caban\"</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">17</span>:</span><br><span class=\"line\">                str = <span class=\"string\">\"eznab\"</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">18</span>:</span><br><span class=\"line\">                str = <span class=\"string\">\"canac\"</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">19</span>:</span><br><span class=\"line\">                str = <span class=\"string\">\"ahau\"</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\" \"</span> +str +<span class=\"string\">\" \"</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; num/<span class=\"number\">260</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>这一题的话：</p>\n<ol>\n<li>要注意 C++ 的 switch 不能使用 string，所以只好写成 if 来判断了。</li>\n<li>另外一个值得注意的地方是，空格会中断标准输入，所以不能使用一个 string 来装下一行输入，而是分别用 string Day，string str，int Year，装下 day, month, year。</li>\n<li>注意 Day[i]-‘0’</li>\n<li>可以使用分批输出，无需打包成一个 string。</li>\n</ol>\n<p>C++代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;algorithm&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Haab 365</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Tzolkin 260</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">    <span class=\"built_in\">cin</span>&gt;&gt;n;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> Day;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> Year;</span><br><span class=\"line\">    <span class=\"built_in\">string</span> str;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; n &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n--)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> num=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; Day;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;Day[i]!=<span class=\"string\">'.'</span>;++i)&#123;</span><br><span class=\"line\">            num = num*<span class=\"number\">10</span>+Day[i]-<span class=\"string\">'0'</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; str;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str==<span class=\"string\">\"no\"</span>)num += <span class=\"number\">20</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str==<span class=\"string\">\"zip\"</span>)num+=<span class=\"number\">40</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str==<span class=\"string\">\"zotz\"</span>)num+=<span class=\"number\">60</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str==<span class=\"string\">\"tzec\"</span>)num+=<span class=\"number\">80</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str==<span class=\"string\">\"xul\"</span>)num+=<span class=\"number\">100</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str==<span class=\"string\">\"yoxkin\"</span>)num+=<span class=\"number\">120</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str==<span class=\"string\">\"mol\"</span>)num+=<span class=\"number\">140</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str==<span class=\"string\">\"chen\"</span>)num+=<span class=\"number\">160</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str==<span class=\"string\">\"yax\"</span>)num+=<span class=\"number\">180</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str==<span class=\"string\">\"zac\"</span>)num+=<span class=\"number\">200</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str==<span class=\"string\">\"ceh\"</span>)num+=<span class=\"number\">220</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str==<span class=\"string\">\"mac\"</span>)num+=<span class=\"number\">240</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str==<span class=\"string\">\"kankin\"</span>)num+=<span class=\"number\">260</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str==<span class=\"string\">\"muan\"</span>)num+=<span class=\"number\">280</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str==<span class=\"string\">\"pax\"</span>)num+=<span class=\"number\">300</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str==<span class=\"string\">\"koyab\"</span>)num+=<span class=\"number\">320</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str==<span class=\"string\">\"cumhu\"</span>)num+=<span class=\"number\">340</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(str==<span class=\"string\">\"uayet\"</span>)num+=<span class=\"number\">360</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cin</span> &gt;&gt; Year;</span><br><span class=\"line\">        num += Year*<span class=\"number\">365</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; num%<span class=\"number\">13</span>+<span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> month = num%<span class=\"number\">260</span>;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(month%<span class=\"number\">20</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">0</span>:</span><br><span class=\"line\">                str = <span class=\"string\">\"imix\"</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">                str = <span class=\"string\">\"ik\"</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">2</span>:</span><br><span class=\"line\">                str = <span class=\"string\">\"akbal\"</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">3</span>:</span><br><span class=\"line\">                str = <span class=\"string\">\"kan\"</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">4</span>:</span><br><span class=\"line\">                str = <span class=\"string\">\"chicchan\"</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">5</span>:</span><br><span class=\"line\">                str = <span class=\"string\">\"cimi\"</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">6</span>:</span><br><span class=\"line\">                str = <span class=\"string\">\"manik\"</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">7</span>:</span><br><span class=\"line\">                str = <span class=\"string\">\"lamat\"</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">8</span>:</span><br><span class=\"line\">                str = <span class=\"string\">\"muluk\"</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">9</span>:</span><br><span class=\"line\">                str = <span class=\"string\">\"ok\"</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">10</span>:</span><br><span class=\"line\">                str = <span class=\"string\">\"chuen\"</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">11</span>:</span><br><span class=\"line\">                str = <span class=\"string\">\"eb\"</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">12</span>:</span><br><span class=\"line\">                str = <span class=\"string\">\"ben\"</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">13</span>:</span><br><span class=\"line\">                str = <span class=\"string\">\"ix\"</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">14</span>:</span><br><span class=\"line\">                str = <span class=\"string\">\"mem\"</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">15</span>:</span><br><span class=\"line\">                str = <span class=\"string\">\"cib\"</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">16</span>:</span><br><span class=\"line\">                str = <span class=\"string\">\"caban\"</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">17</span>:</span><br><span class=\"line\">                str = <span class=\"string\">\"eznab\"</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">18</span>:</span><br><span class=\"line\">                str = <span class=\"string\">\"canac\"</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> <span class=\"number\">19</span>:</span><br><span class=\"line\">                str = <span class=\"string\">\"ahau\"</span>;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\" \"</span> +str +<span class=\"string\">\" \"</span>;</span><br><span class=\"line\">        <span class=\"built_in\">cout</span> &lt;&lt; num/<span class=\"number\">260</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"POJ 1008 Maya Calendar","date":"2018-02-23T16:00:00.000Z","comments":1,"_content":"\n这一题花了不少时间，首先是题目没看懂，然后搜了很久的资料，才看懂了。\n\n边缘检测是图像处理里面的基础，这题用的边缘检测就是最简单的边缘检测，根据周边八个像素点和此像素点差值 来描绘图像中的物体的边缘。\n\n比如第一个点15，它周围的三个点是100，100，15，得到的结果是85，再比如第4行第2列是175，它周边的点是100，100，100，175，25，175，175，25，得到的结果是150.\n\n输入也是刚开始没看懂，其实也很简单，第一个数表示图的宽度，接下来是若干对数字，前面是像素的值，后面是个数。\n\n最后贴上有注释的代码（C++）：\n\n```C++\n//Memory Time   \n//332K   32MS   \n\n#include<iostream>  \n#include<cmath>  \n#include<algorithm>  \nusing namespace std;  \n\nconst int size=1000;  //每幅图片的pair上限  \nint width;  //Map的宽  \nint total=0;  //像素点总个数  \n\ntypedef class OutMapPix  \n{  \n    public:  \n        int pos;    //OutMap中每个像素点的顺序位置，pos从1开始  \n        int code;   //OutMap中每个像素点对应InMap的编码  \n}Pix;  \n\nint InMapPair[size][2];  //InMapPair[][0]为像素值，InMapPair[][1]为InMapPair[][0]连续出现的个数  \nPix OutMap[size*9];    //每个pix都依赖其周围的8个点编码  \n\nint cmp(const void* a,const void* b);  //快排比较规则  \nint GetValue(int pos);  //返回第pos个像素点的像素值  \nint GetCode(int pos);   //返回第pos个像素点的编码  \n\nint main(int k)  \n{  \n    while(cin>>width && width)  \n    {  \n        int pairv,pairt;  \n        k=total=0;  \n        while(cin>>pairv>>pairt && pairt)  \n        {  \n            InMapPair[k][0]=pairv;  \n            InMapPair[k++][1]=pairt;  \n            total+=pairt;  \n        }  \n        int PairNum=k;  //pair的个数  \n\n        cout<<width<<endl;  \n\n        int pos=1;  //当前处理的像素点的位置  \n        k=0; //OutMap[]指针  \n        for(int p=0;p<=PairNum;p++)  \n        {  \n            int row=(pos-1)/width;  //得到pos在二维图对应的坐标  \n            int col=(pos-1)%width;  \n\n            for(int i=row-1;i<=row+1;i++)        //枚举(row,col)周围及其自身共9个点(x,y)  \n                for(int j=col-1;j<=col+1;j++)  \n                {  \n                    int tpos=i*width+j;  //得到(x,y)的顺序位置  \n\n                    if(i<0 || j<0 || j>=width || tpos>=total)  \n                        continue;  \n\n                    OutMap[k].pos=tpos+1;  \n                    OutMap[k++].code=GetCode(tpos+1);  //对发生变化的像素点的附近8个点和这一点本身编码（总共是9个点）\n                }  \n\n            pos+=InMapPair[p][1];  //跳跃，确定下一个像素发生变化的点的位置  \n        }  \n\n        qsort(OutMap,k,sizeof(Pix),cmp);  //对OutMap根据顺序位置  \n\n        /*OutPut*/  \n\n        Pix temp=OutMap[0];  \n        for(int i=0;i<k;i++)  \n        {  \n            if(temp.code==OutMap[i].code)  \n                continue;  \n            cout<<temp.code<<' '<<OutMap[i].pos-temp.pos<<endl;  \n            temp=OutMap[i];  \n        }  \n        cout<<temp.code<<' '<<total-temp.pos+1<<endl;  \n        cout<<\"0 0\"<<endl;  \n\n    }  \n    cout<<0<<endl;  \n\n    return 0;  \n}  \n\n\n/*快排比较规则*/  \nint cmp(const void* a,const void* b)  \n{  \n    Pix* x=(Pix*)a;  \n    Pix* y=(Pix*)b;  \n    return x->pos - y->pos;  \n}  \n\n/*返回第pos个像素点的像素值*/  \nint GetValue(int pos)  \n{  \n    int i=0,p=0;  \n    while(p<pos)  \n        p+=InMapPair[i++][1];  \n\n    return InMapPair[i-1][0];  \n}  \n\n/*返回第pos个像素点的编码*/  \nint GetCode(int pos)  \n{  \n    int code=GetValue(pos);  \n    int MaxAbs=0;  \n\n    int row=(pos-1)/width;  \n    int col=(pos-1)%width;  \n\n    for(int i=row-1;i<=row+1;i++)  \n        for(int j=col-1;j<=col+1;j++)  \n        {  \n            int tpos=i*width+j;  \n\n            if(i<0 || j<0 || j>=width || tpos>=total || tpos==pos-1)  //tpos==pos-1为中心的像素点，即当前待编码的点  \n                continue;  \n\n            int tcode=GetValue(tpos+1);  \n\n            if(MaxAbs<abs(tcode-code))   //注意取绝对值  \n                MaxAbs=abs(tcode-code);  \n        }  \n\n    return MaxAbs;  \n}\n```\n\n要注意的点：\n\n1. 主要就是自加，这里面用了很多的右自加，右自加是先使用值，然后再自加。\n2. GetValue函数 是一个典型的寻区间代码。\n3. 算法：只计算 RLE 起始点和其周围的点。这里不做证明。\n","source":"_posts/2018/2018-02-24-POJ-1009-Edge-Detection.md","raw":"---\ntitle: POJ 1008 Maya Calendar\ndate: 2018-02-24\ncategories: [ACM, POJ]\ncomments: true\n---\n\n这一题花了不少时间，首先是题目没看懂，然后搜了很久的资料，才看懂了。\n\n边缘检测是图像处理里面的基础，这题用的边缘检测就是最简单的边缘检测，根据周边八个像素点和此像素点差值 来描绘图像中的物体的边缘。\n\n比如第一个点15，它周围的三个点是100，100，15，得到的结果是85，再比如第4行第2列是175，它周边的点是100，100，100，175，25，175，175，25，得到的结果是150.\n\n输入也是刚开始没看懂，其实也很简单，第一个数表示图的宽度，接下来是若干对数字，前面是像素的值，后面是个数。\n\n最后贴上有注释的代码（C++）：\n\n```C++\n//Memory Time   \n//332K   32MS   \n\n#include<iostream>  \n#include<cmath>  \n#include<algorithm>  \nusing namespace std;  \n\nconst int size=1000;  //每幅图片的pair上限  \nint width;  //Map的宽  \nint total=0;  //像素点总个数  \n\ntypedef class OutMapPix  \n{  \n    public:  \n        int pos;    //OutMap中每个像素点的顺序位置，pos从1开始  \n        int code;   //OutMap中每个像素点对应InMap的编码  \n}Pix;  \n\nint InMapPair[size][2];  //InMapPair[][0]为像素值，InMapPair[][1]为InMapPair[][0]连续出现的个数  \nPix OutMap[size*9];    //每个pix都依赖其周围的8个点编码  \n\nint cmp(const void* a,const void* b);  //快排比较规则  \nint GetValue(int pos);  //返回第pos个像素点的像素值  \nint GetCode(int pos);   //返回第pos个像素点的编码  \n\nint main(int k)  \n{  \n    while(cin>>width && width)  \n    {  \n        int pairv,pairt;  \n        k=total=0;  \n        while(cin>>pairv>>pairt && pairt)  \n        {  \n            InMapPair[k][0]=pairv;  \n            InMapPair[k++][1]=pairt;  \n            total+=pairt;  \n        }  \n        int PairNum=k;  //pair的个数  \n\n        cout<<width<<endl;  \n\n        int pos=1;  //当前处理的像素点的位置  \n        k=0; //OutMap[]指针  \n        for(int p=0;p<=PairNum;p++)  \n        {  \n            int row=(pos-1)/width;  //得到pos在二维图对应的坐标  \n            int col=(pos-1)%width;  \n\n            for(int i=row-1;i<=row+1;i++)        //枚举(row,col)周围及其自身共9个点(x,y)  \n                for(int j=col-1;j<=col+1;j++)  \n                {  \n                    int tpos=i*width+j;  //得到(x,y)的顺序位置  \n\n                    if(i<0 || j<0 || j>=width || tpos>=total)  \n                        continue;  \n\n                    OutMap[k].pos=tpos+1;  \n                    OutMap[k++].code=GetCode(tpos+1);  //对发生变化的像素点的附近8个点和这一点本身编码（总共是9个点）\n                }  \n\n            pos+=InMapPair[p][1];  //跳跃，确定下一个像素发生变化的点的位置  \n        }  \n\n        qsort(OutMap,k,sizeof(Pix),cmp);  //对OutMap根据顺序位置  \n\n        /*OutPut*/  \n\n        Pix temp=OutMap[0];  \n        for(int i=0;i<k;i++)  \n        {  \n            if(temp.code==OutMap[i].code)  \n                continue;  \n            cout<<temp.code<<' '<<OutMap[i].pos-temp.pos<<endl;  \n            temp=OutMap[i];  \n        }  \n        cout<<temp.code<<' '<<total-temp.pos+1<<endl;  \n        cout<<\"0 0\"<<endl;  \n\n    }  \n    cout<<0<<endl;  \n\n    return 0;  \n}  \n\n\n/*快排比较规则*/  \nint cmp(const void* a,const void* b)  \n{  \n    Pix* x=(Pix*)a;  \n    Pix* y=(Pix*)b;  \n    return x->pos - y->pos;  \n}  \n\n/*返回第pos个像素点的像素值*/  \nint GetValue(int pos)  \n{  \n    int i=0,p=0;  \n    while(p<pos)  \n        p+=InMapPair[i++][1];  \n\n    return InMapPair[i-1][0];  \n}  \n\n/*返回第pos个像素点的编码*/  \nint GetCode(int pos)  \n{  \n    int code=GetValue(pos);  \n    int MaxAbs=0;  \n\n    int row=(pos-1)/width;  \n    int col=(pos-1)%width;  \n\n    for(int i=row-1;i<=row+1;i++)  \n        for(int j=col-1;j<=col+1;j++)  \n        {  \n            int tpos=i*width+j;  \n\n            if(i<0 || j<0 || j>=width || tpos>=total || tpos==pos-1)  //tpos==pos-1为中心的像素点，即当前待编码的点  \n                continue;  \n\n            int tcode=GetValue(tpos+1);  \n\n            if(MaxAbs<abs(tcode-code))   //注意取绝对值  \n                MaxAbs=abs(tcode-code);  \n        }  \n\n    return MaxAbs;  \n}\n```\n\n要注意的点：\n\n1. 主要就是自加，这里面用了很多的右自加，右自加是先使用值，然后再自加。\n2. GetValue函数 是一个典型的寻区间代码。\n3. 算法：只计算 RLE 起始点和其周围的点。这里不做证明。\n","slug":"POJ-1009-Edge-Detection","published":1,"updated":"2018-06-10T11:59:50.207Z","layout":"post","photos":[],"link":"","_id":"cjm2w8dde0028fgpx7maz5vpr","content":"<p>这一题花了不少时间，首先是题目没看懂，然后搜了很久的资料，才看懂了。</p>\n<p>边缘检测是图像处理里面的基础，这题用的边缘检测就是最简单的边缘检测，根据周边八个像素点和此像素点差值 来描绘图像中的物体的边缘。</p>\n<p>比如第一个点15，它周围的三个点是100，100，15，得到的结果是85，再比如第4行第2列是175，它周边的点是100，100，100，175，25，175，175，25，得到的结果是150.</p>\n<p>输入也是刚开始没看懂，其实也很简单，第一个数表示图的宽度，接下来是若干对数字，前面是像素的值，后面是个数。</p>\n<p>最后贴上有注释的代码（C++）：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Memory Time   </span></span><br><span class=\"line\"><span class=\"comment\">//332K   32MS   </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;  </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cmath&gt;  </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;algorithm&gt;  </span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> size=<span class=\"number\">1000</span>;  <span class=\"comment\">//每幅图片的pair上限  </span></span><br><span class=\"line\"><span class=\"keyword\">int</span> width;  <span class=\"comment\">//Map的宽  </span></span><br><span class=\"line\"><span class=\"keyword\">int</span> total=<span class=\"number\">0</span>;  <span class=\"comment\">//像素点总个数  </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OutMapPix</span>  </span></span><br><span class=\"line\"><span class=\"class\">&#123;</span>  </span><br><span class=\"line\">    <span class=\"keyword\">public</span>:  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> pos;    <span class=\"comment\">//OutMap中每个像素点的顺序位置，pos从1开始  </span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> code;   <span class=\"comment\">//OutMap中每个像素点对应InMap的编码  </span></span><br><span class=\"line\">&#125;Pix;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> InMapPair[size][<span class=\"number\">2</span>];  <span class=\"comment\">//InMapPair[][0]为像素值，InMapPair[][1]为InMapPair[][0]连续出现的个数  </span></span><br><span class=\"line\">Pix OutMap[size*<span class=\"number\">9</span>];    <span class=\"comment\">//每个pix都依赖其周围的8个点编码  </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">cmp</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* a,<span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* b)</span></span>;  <span class=\"comment\">//快排比较规则  </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">GetValue</span><span class=\"params\">(<span class=\"keyword\">int</span> pos)</span></span>;  <span class=\"comment\">//返回第pos个像素点的像素值  </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">GetCode</span><span class=\"params\">(<span class=\"keyword\">int</span> pos)</span></span>;   <span class=\"comment\">//返回第pos个像素点的编码  </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> k)</span>  </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;width &amp;&amp; width)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> pairv,pairt;  </span><br><span class=\"line\">        k=total=<span class=\"number\">0</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;pairv&gt;&gt;pairt &amp;&amp; pairt)  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            InMapPair[k][<span class=\"number\">0</span>]=pairv;  </span><br><span class=\"line\">            InMapPair[k++][<span class=\"number\">1</span>]=pairt;  </span><br><span class=\"line\">            total+=pairt;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> PairNum=k;  <span class=\"comment\">//pair的个数  </span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;width&lt;&lt;<span class=\"built_in\">endl</span>;  </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> pos=<span class=\"number\">1</span>;  <span class=\"comment\">//当前处理的像素点的位置  </span></span><br><span class=\"line\">        k=<span class=\"number\">0</span>; <span class=\"comment\">//OutMap[]指针  </span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> p=<span class=\"number\">0</span>;p&lt;=PairNum;p++)  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">int</span> row=(pos<span class=\"number\">-1</span>)/width;  <span class=\"comment\">//得到pos在二维图对应的坐标  </span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> col=(pos<span class=\"number\">-1</span>)%width;  </span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=row<span class=\"number\">-1</span>;i&lt;=row+<span class=\"number\">1</span>;i++)        <span class=\"comment\">//枚举(row,col)周围及其自身共9个点(x,y)  </span></span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=col<span class=\"number\">-1</span>;j&lt;=col+<span class=\"number\">1</span>;j++)  </span><br><span class=\"line\">                &#123;  </span><br><span class=\"line\">                    <span class=\"keyword\">int</span> tpos=i*width+j;  <span class=\"comment\">//得到(x,y)的顺序位置  </span></span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(i&lt;<span class=\"number\">0</span> || j&lt;<span class=\"number\">0</span> || j&gt;=width || tpos&gt;=total)  </span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;  </span><br><span class=\"line\"></span><br><span class=\"line\">                    OutMap[k].pos=tpos+<span class=\"number\">1</span>;  </span><br><span class=\"line\">                    OutMap[k++].code=GetCode(tpos+<span class=\"number\">1</span>);  <span class=\"comment\">//对发生变化的像素点的附近8个点和这一点本身编码（总共是9个点）</span></span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">            pos+=InMapPair[p][<span class=\"number\">1</span>];  <span class=\"comment\">//跳跃，确定下一个像素发生变化的点的位置  </span></span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">        qsort(OutMap,k,<span class=\"keyword\">sizeof</span>(Pix),cmp);  <span class=\"comment\">//对OutMap根据顺序位置  </span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*OutPut*/</span>  </span><br><span class=\"line\"></span><br><span class=\"line\">        Pix temp=OutMap[<span class=\"number\">0</span>];  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;k;i++)  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(temp.code==OutMap[i].code)  </span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;  </span><br><span class=\"line\">            <span class=\"built_in\">cout</span>&lt;&lt;temp.code&lt;&lt;<span class=\"string\">' '</span>&lt;&lt;OutMap[i].pos-temp.pos&lt;&lt;<span class=\"built_in\">endl</span>;  </span><br><span class=\"line\">            temp=OutMap[i];  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;temp.code&lt;&lt;<span class=\"string\">' '</span>&lt;&lt;total-temp.pos+<span class=\"number\">1</span>&lt;&lt;<span class=\"built_in\">endl</span>;  </span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"0 0\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;  </span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"number\">0</span>&lt;&lt;<span class=\"built_in\">endl</span>;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*快排比较规则*/</span>  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">cmp</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* a,<span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* b)</span>  </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;  </span><br><span class=\"line\">    Pix* x=(Pix*)a;  </span><br><span class=\"line\">    Pix* y=(Pix*)b;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> x-&gt;pos - y-&gt;pos;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*返回第pos个像素点的像素值*/</span>  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">GetValue</span><span class=\"params\">(<span class=\"keyword\">int</span> pos)</span>  </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>,p=<span class=\"number\">0</span>;  </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p&lt;pos)  </span><br><span class=\"line\">        p+=InMapPair[i++][<span class=\"number\">1</span>];  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> InMapPair[i<span class=\"number\">-1</span>][<span class=\"number\">0</span>];  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*返回第pos个像素点的编码*/</span>  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">GetCode</span><span class=\"params\">(<span class=\"keyword\">int</span> pos)</span>  </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> code=GetValue(pos);  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> MaxAbs=<span class=\"number\">0</span>;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> row=(pos<span class=\"number\">-1</span>)/width;  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> col=(pos<span class=\"number\">-1</span>)%width;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=row<span class=\"number\">-1</span>;i&lt;=row+<span class=\"number\">1</span>;i++)  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=col<span class=\"number\">-1</span>;j&lt;=col+<span class=\"number\">1</span>;j++)  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">int</span> tpos=i*width+j;  </span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i&lt;<span class=\"number\">0</span> || j&lt;<span class=\"number\">0</span> || j&gt;=width || tpos&gt;=total || tpos==pos<span class=\"number\">-1</span>)  <span class=\"comment\">//tpos==pos-1为中心的像素点，即当前待编码的点  </span></span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;  </span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">int</span> tcode=GetValue(tpos+<span class=\"number\">1</span>);  </span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(MaxAbs&lt;<span class=\"built_in\">abs</span>(tcode-code))   <span class=\"comment\">//注意取绝对值  </span></span><br><span class=\"line\">                MaxAbs=<span class=\"built_in\">abs</span>(tcode-code);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> MaxAbs;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>要注意的点：</p>\n<ol>\n<li>主要就是自加，这里面用了很多的右自加，右自加是先使用值，然后再自加。</li>\n<li>GetValue函数 是一个典型的寻区间代码。</li>\n<li>算法：只计算 RLE 起始点和其周围的点。这里不做证明。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>这一题花了不少时间，首先是题目没看懂，然后搜了很久的资料，才看懂了。</p>\n<p>边缘检测是图像处理里面的基础，这题用的边缘检测就是最简单的边缘检测，根据周边八个像素点和此像素点差值 来描绘图像中的物体的边缘。</p>\n<p>比如第一个点15，它周围的三个点是100，100，15，得到的结果是85，再比如第4行第2列是175，它周边的点是100，100，100，175，25，175，175，25，得到的结果是150.</p>\n<p>输入也是刚开始没看懂，其实也很简单，第一个数表示图的宽度，接下来是若干对数字，前面是像素的值，后面是个数。</p>\n<p>最后贴上有注释的代码（C++）：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Memory Time   </span></span><br><span class=\"line\"><span class=\"comment\">//332K   32MS   </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;  </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;cmath&gt;  </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;algorithm&gt;  </span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> size=<span class=\"number\">1000</span>;  <span class=\"comment\">//每幅图片的pair上限  </span></span><br><span class=\"line\"><span class=\"keyword\">int</span> width;  <span class=\"comment\">//Map的宽  </span></span><br><span class=\"line\"><span class=\"keyword\">int</span> total=<span class=\"number\">0</span>;  <span class=\"comment\">//像素点总个数  </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OutMapPix</span>  </span></span><br><span class=\"line\"><span class=\"class\">&#123;</span>  </span><br><span class=\"line\">    <span class=\"keyword\">public</span>:  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> pos;    <span class=\"comment\">//OutMap中每个像素点的顺序位置，pos从1开始  </span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> code;   <span class=\"comment\">//OutMap中每个像素点对应InMap的编码  </span></span><br><span class=\"line\">&#125;Pix;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">int</span> InMapPair[size][<span class=\"number\">2</span>];  <span class=\"comment\">//InMapPair[][0]为像素值，InMapPair[][1]为InMapPair[][0]连续出现的个数  </span></span><br><span class=\"line\">Pix OutMap[size*<span class=\"number\">9</span>];    <span class=\"comment\">//每个pix都依赖其周围的8个点编码  </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">cmp</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* a,<span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* b)</span></span>;  <span class=\"comment\">//快排比较规则  </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">GetValue</span><span class=\"params\">(<span class=\"keyword\">int</span> pos)</span></span>;  <span class=\"comment\">//返回第pos个像素点的像素值  </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">GetCode</span><span class=\"params\">(<span class=\"keyword\">int</span> pos)</span></span>;   <span class=\"comment\">//返回第pos个像素点的编码  </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> k)</span>  </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;width &amp;&amp; width)  </span><br><span class=\"line\">    &#123;  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> pairv,pairt;  </span><br><span class=\"line\">        k=total=<span class=\"number\">0</span>;  </span><br><span class=\"line\">        <span class=\"keyword\">while</span>(<span class=\"built_in\">cin</span>&gt;&gt;pairv&gt;&gt;pairt &amp;&amp; pairt)  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            InMapPair[k][<span class=\"number\">0</span>]=pairv;  </span><br><span class=\"line\">            InMapPair[k++][<span class=\"number\">1</span>]=pairt;  </span><br><span class=\"line\">            total+=pairt;  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"keyword\">int</span> PairNum=k;  <span class=\"comment\">//pair的个数  </span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;width&lt;&lt;<span class=\"built_in\">endl</span>;  </span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> pos=<span class=\"number\">1</span>;  <span class=\"comment\">//当前处理的像素点的位置  </span></span><br><span class=\"line\">        k=<span class=\"number\">0</span>; <span class=\"comment\">//OutMap[]指针  </span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> p=<span class=\"number\">0</span>;p&lt;=PairNum;p++)  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">int</span> row=(pos<span class=\"number\">-1</span>)/width;  <span class=\"comment\">//得到pos在二维图对应的坐标  </span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> col=(pos<span class=\"number\">-1</span>)%width;  </span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=row<span class=\"number\">-1</span>;i&lt;=row+<span class=\"number\">1</span>;i++)        <span class=\"comment\">//枚举(row,col)周围及其自身共9个点(x,y)  </span></span><br><span class=\"line\">                <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=col<span class=\"number\">-1</span>;j&lt;=col+<span class=\"number\">1</span>;j++)  </span><br><span class=\"line\">                &#123;  </span><br><span class=\"line\">                    <span class=\"keyword\">int</span> tpos=i*width+j;  <span class=\"comment\">//得到(x,y)的顺序位置  </span></span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"keyword\">if</span>(i&lt;<span class=\"number\">0</span> || j&lt;<span class=\"number\">0</span> || j&gt;=width || tpos&gt;=total)  </span><br><span class=\"line\">                        <span class=\"keyword\">continue</span>;  </span><br><span class=\"line\"></span><br><span class=\"line\">                    OutMap[k].pos=tpos+<span class=\"number\">1</span>;  </span><br><span class=\"line\">                    OutMap[k++].code=GetCode(tpos+<span class=\"number\">1</span>);  <span class=\"comment\">//对发生变化的像素点的附近8个点和这一点本身编码（总共是9个点）</span></span><br><span class=\"line\">                &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">            pos+=InMapPair[p][<span class=\"number\">1</span>];  <span class=\"comment\">//跳跃，确定下一个像素发生变化的点的位置  </span></span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">        qsort(OutMap,k,<span class=\"keyword\">sizeof</span>(Pix),cmp);  <span class=\"comment\">//对OutMap根据顺序位置  </span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/*OutPut*/</span>  </span><br><span class=\"line\"></span><br><span class=\"line\">        Pix temp=OutMap[<span class=\"number\">0</span>];  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;k;i++)  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">if</span>(temp.code==OutMap[i].code)  </span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;  </span><br><span class=\"line\">            <span class=\"built_in\">cout</span>&lt;&lt;temp.code&lt;&lt;<span class=\"string\">' '</span>&lt;&lt;OutMap[i].pos-temp.pos&lt;&lt;<span class=\"built_in\">endl</span>;  </span><br><span class=\"line\">            temp=OutMap[i];  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;temp.code&lt;&lt;<span class=\"string\">' '</span>&lt;&lt;total-temp.pos+<span class=\"number\">1</span>&lt;&lt;<span class=\"built_in\">endl</span>;  </span><br><span class=\"line\">        <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"0 0\"</span>&lt;&lt;<span class=\"built_in\">endl</span>;  </span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">    <span class=\"built_in\">cout</span>&lt;&lt;<span class=\"number\">0</span>&lt;&lt;<span class=\"built_in\">endl</span>;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*快排比较规则*/</span>  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">cmp</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* a,<span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* b)</span>  </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;  </span><br><span class=\"line\">    Pix* x=(Pix*)a;  </span><br><span class=\"line\">    Pix* y=(Pix*)b;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> x-&gt;pos - y-&gt;pos;  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*返回第pos个像素点的像素值*/</span>  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">GetValue</span><span class=\"params\">(<span class=\"keyword\">int</span> pos)</span>  </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> i=<span class=\"number\">0</span>,p=<span class=\"number\">0</span>;  </span><br><span class=\"line\">    <span class=\"keyword\">while</span>(p&lt;pos)  </span><br><span class=\"line\">        p+=InMapPair[i++][<span class=\"number\">1</span>];  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> InMapPair[i<span class=\"number\">-1</span>][<span class=\"number\">0</span>];  </span><br><span class=\"line\">&#125;  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*返回第pos个像素点的编码*/</span>  </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">GetCode</span><span class=\"params\">(<span class=\"keyword\">int</span> pos)</span>  </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> code=GetValue(pos);  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> MaxAbs=<span class=\"number\">0</span>;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> row=(pos<span class=\"number\">-1</span>)/width;  </span><br><span class=\"line\">    <span class=\"keyword\">int</span> col=(pos<span class=\"number\">-1</span>)%width;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=row<span class=\"number\">-1</span>;i&lt;=row+<span class=\"number\">1</span>;i++)  </span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> j=col<span class=\"number\">-1</span>;j&lt;=col+<span class=\"number\">1</span>;j++)  </span><br><span class=\"line\">        &#123;  </span><br><span class=\"line\">            <span class=\"keyword\">int</span> tpos=i*width+j;  </span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i&lt;<span class=\"number\">0</span> || j&lt;<span class=\"number\">0</span> || j&gt;=width || tpos&gt;=total || tpos==pos<span class=\"number\">-1</span>)  <span class=\"comment\">//tpos==pos-1为中心的像素点，即当前待编码的点  </span></span><br><span class=\"line\">                <span class=\"keyword\">continue</span>;  </span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">int</span> tcode=GetValue(tpos+<span class=\"number\">1</span>);  </span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(MaxAbs&lt;<span class=\"built_in\">abs</span>(tcode-code))   <span class=\"comment\">//注意取绝对值  </span></span><br><span class=\"line\">                MaxAbs=<span class=\"built_in\">abs</span>(tcode-code);  </span><br><span class=\"line\">        &#125;  </span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> MaxAbs;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>要注意的点：</p>\n<ol>\n<li>主要就是自加，这里面用了很多的右自加，右自加是先使用值，然后再自加。</li>\n<li>GetValue函数 是一个典型的寻区间代码。</li>\n<li>算法：只计算 RLE 起始点和其周围的点。这里不做证明。</li>\n</ol>\n"},{"title":"新概念英语四 lesson 03 Matterhorn Man","date":"2018-02-24T16:00:00.000Z","comments":1,"_content":"\n生词：\n\n- climber （这个单词要注意发音，b 是不发音的）\n- alpinist 登山运动员\n- route 路\n- summit 最高，顶点\n- sought seek 的过去式, seek sought sought\n- perilous 危险的\n- manner 方式\n- court 招致\n- solitary 孤独的\n- rapidly 快速的\n- Alpine 阿尔卑斯山的\n- impoverished 贫困\n- settlements 定居点\n- flea-ridden 跳蚤猖獗\n- coarse 粗糙的\n- boast 吹嘘\n- priest 牧师\n- parishioner 教徒\n- shepherd 牧羊人\n- Invariably 不变的\n- linen 亚麻的\n\n语言点：\nalpinist 实际上是由 Alps 阿尔卑斯山演变来的。\n\nWhat was the main objective of early mountain climbers?\n\n语言用词的多样性：这里的目标用的是 objective，也可以用 aim，goal 等。\n\n这个问题的答案是：to get to the top by the easiest route\n\nModern alpinists try to climb mountains by a route which will give them good sport, and the more difficult it is, the more highly it is regarded.\n\n英语用词有时候非常简单，比如这里的 good sport 和 highly。\n\n而翻译成汉语则是：\n\n现代登山运动员总想找一条能够给他们带来运动乐趣的路线来攀登山峰。他们认为，道路愈艰险愈带劲儿。\n\n汉语用的是 运动乐趣 和 带劲儿。也是相当地道的。\n\nIn the pioneering days however, this was not the case at all.\n\n然而，在登山运动的初期，全然不是这种情况。\n\n这里的 pioneering days 用法很新鲜，如果是我的话只会想到 early，this was not the case at all 又一次反映了英语用词的简洁。the case 用的很爽。\n\nThe early climbers were looking for the easiest way to the top because the summit was the prize they sought, especially if it had never been attained before.\n\n早期登山者所寻找的是通往山顶的最方便的途径，这是他们追寻的目标，特别是前人未曾到达过的山顶。\n\n这里的 early 呼应了前面的 pioneering，the summit was the prize they sought，时刻注意时态，英语就是如此，有不少的细节，需要严谨对待。另外 summit 用来表示山顶，如果是我的话只能想到 top，以后可以用 summit 来代替了。especially if it had never been attained before，我突然想到是不是也可以用 achieved。\n\nIt is true that during their explorations they often faced difficulties and dangers of the most perilous nature, equipped in a manner which would make a modern climber shudder at the thought, but they did not go out of their way to court such excitement.\n\n确实，在探险中他们经常遇到惊心动魄的困难和危险，而他们的装备之简陋足以使现代登山者一想起来就胆战心惊。但是他们并非故意寻求这种刺激。\n\nperilous险恶的，perilous nature 用来形容恶劣的自然环境。equipped in a manner which would make a modern climber shudder at the thought，这一句十分经典。court such excitement，这里的 court 表示招致，我以前只知道：法院、球场。\n\nThey had a single aim, a solitary goal – the top!\n\n这个用了相同的词来描述同一个事，作为强调。而且语气上是递进的 single 和 solitary 比，solitary 语气更重，aim 和 goal 比，aim 表示一般的泛泛的目标，goal 则常用在体育竞赛方面。\n\nIt is hard for us to realize nowadays how difficult it was for the pioneers.\n\n我们今天很难想象昔日的登山先驱是多么艰苦。\n\nExcept for one or two places such as Zermatt and Chamonix, which had rapidly become popular.\n\nAlpine villages tended to be impoverished settlements cut off from civilization by the high mountains.\n\n阿尔卑斯山山区的小村几乎全是高山环抱、与世隔绝的穷乡僻壤。\n\ntended to be，几乎全是，用得好。cut off from civilization by the high mountains，简单词用的好，形象的描述了高山环抱、与世隔绝、穷乡僻壤。\n\nSuch inns as there were were generally dirty and flea-ridden;the food simply local cheese accompanied by bread often twelve months old, all washed down with coarse wine.\n\n那里的小客栈一般都很脏，而且跳蚤猖獗。食物是当地的干酪和通常存放了一年之久的面包，人们就着劣酒吞下这种食物。\n\naccompanied by 这里用的不错，bread often twelve months old，形容面包和形容人是一样的用法。washed down 用液体灌下。coarse 粗糙的，coarse wine 劣质的酒。\n\nOften a valley boasted no inn at all, and climbers found shelter wherever they could sometimes with the local priest(who was usually as poor as his parishioners), sometimes with shepherds or cheese-makers. Invariably the background was the same: dirt and poverty, and very uncomfortable.\n\n山谷里常常没有小客栈，登山者只好随遇而安。有时同当地牧师（他通常和他的教民一样穷）住在一起，有时同牧羊人或制乳酪的人住在一起。无论在哪儿，情况都一样：肮脏、贫穷，极其不舒适。\n\nboast: to be lucky enough to own。这里不用 have 而是用 boast，表明作者不是在做客观的描述，而是带有感情色彩的。例子：The university boasts the highest number of first-rate teachers in China.\n\ninvariably 不变的。\n\nFor men accustomed to eating seven-course dinners and sleeping between fine linen sheets at home, the change to the Alps must have been very hard indeed.\n\n对于过惯了一顿饭吃7道菜、睡亚麻细布床单的人来说，变换一下生活环境来到阿尔卑斯山山区，那一定是很艰难的。\n\nseven-course dinners，七道菜的晚饭。sheet 薄片，纸张，床单。\n","source":"_posts/2018/2018-02-25-新概念英语四-lesson-03-Matterhorn-Man.md","raw":"---\ntitle: 新概念英语四 lesson 03 Matterhorn Man\ndate: 2018-02-25\ncategories: [新概念英语四]\ncomments: true\n---\n\n生词：\n\n- climber （这个单词要注意发音，b 是不发音的）\n- alpinist 登山运动员\n- route 路\n- summit 最高，顶点\n- sought seek 的过去式, seek sought sought\n- perilous 危险的\n- manner 方式\n- court 招致\n- solitary 孤独的\n- rapidly 快速的\n- Alpine 阿尔卑斯山的\n- impoverished 贫困\n- settlements 定居点\n- flea-ridden 跳蚤猖獗\n- coarse 粗糙的\n- boast 吹嘘\n- priest 牧师\n- parishioner 教徒\n- shepherd 牧羊人\n- Invariably 不变的\n- linen 亚麻的\n\n语言点：\nalpinist 实际上是由 Alps 阿尔卑斯山演变来的。\n\nWhat was the main objective of early mountain climbers?\n\n语言用词的多样性：这里的目标用的是 objective，也可以用 aim，goal 等。\n\n这个问题的答案是：to get to the top by the easiest route\n\nModern alpinists try to climb mountains by a route which will give them good sport, and the more difficult it is, the more highly it is regarded.\n\n英语用词有时候非常简单，比如这里的 good sport 和 highly。\n\n而翻译成汉语则是：\n\n现代登山运动员总想找一条能够给他们带来运动乐趣的路线来攀登山峰。他们认为，道路愈艰险愈带劲儿。\n\n汉语用的是 运动乐趣 和 带劲儿。也是相当地道的。\n\nIn the pioneering days however, this was not the case at all.\n\n然而，在登山运动的初期，全然不是这种情况。\n\n这里的 pioneering days 用法很新鲜，如果是我的话只会想到 early，this was not the case at all 又一次反映了英语用词的简洁。the case 用的很爽。\n\nThe early climbers were looking for the easiest way to the top because the summit was the prize they sought, especially if it had never been attained before.\n\n早期登山者所寻找的是通往山顶的最方便的途径，这是他们追寻的目标，特别是前人未曾到达过的山顶。\n\n这里的 early 呼应了前面的 pioneering，the summit was the prize they sought，时刻注意时态，英语就是如此，有不少的细节，需要严谨对待。另外 summit 用来表示山顶，如果是我的话只能想到 top，以后可以用 summit 来代替了。especially if it had never been attained before，我突然想到是不是也可以用 achieved。\n\nIt is true that during their explorations they often faced difficulties and dangers of the most perilous nature, equipped in a manner which would make a modern climber shudder at the thought, but they did not go out of their way to court such excitement.\n\n确实，在探险中他们经常遇到惊心动魄的困难和危险，而他们的装备之简陋足以使现代登山者一想起来就胆战心惊。但是他们并非故意寻求这种刺激。\n\nperilous险恶的，perilous nature 用来形容恶劣的自然环境。equipped in a manner which would make a modern climber shudder at the thought，这一句十分经典。court such excitement，这里的 court 表示招致，我以前只知道：法院、球场。\n\nThey had a single aim, a solitary goal – the top!\n\n这个用了相同的词来描述同一个事，作为强调。而且语气上是递进的 single 和 solitary 比，solitary 语气更重，aim 和 goal 比，aim 表示一般的泛泛的目标，goal 则常用在体育竞赛方面。\n\nIt is hard for us to realize nowadays how difficult it was for the pioneers.\n\n我们今天很难想象昔日的登山先驱是多么艰苦。\n\nExcept for one or two places such as Zermatt and Chamonix, which had rapidly become popular.\n\nAlpine villages tended to be impoverished settlements cut off from civilization by the high mountains.\n\n阿尔卑斯山山区的小村几乎全是高山环抱、与世隔绝的穷乡僻壤。\n\ntended to be，几乎全是，用得好。cut off from civilization by the high mountains，简单词用的好，形象的描述了高山环抱、与世隔绝、穷乡僻壤。\n\nSuch inns as there were were generally dirty and flea-ridden;the food simply local cheese accompanied by bread often twelve months old, all washed down with coarse wine.\n\n那里的小客栈一般都很脏，而且跳蚤猖獗。食物是当地的干酪和通常存放了一年之久的面包，人们就着劣酒吞下这种食物。\n\naccompanied by 这里用的不错，bread often twelve months old，形容面包和形容人是一样的用法。washed down 用液体灌下。coarse 粗糙的，coarse wine 劣质的酒。\n\nOften a valley boasted no inn at all, and climbers found shelter wherever they could sometimes with the local priest(who was usually as poor as his parishioners), sometimes with shepherds or cheese-makers. Invariably the background was the same: dirt and poverty, and very uncomfortable.\n\n山谷里常常没有小客栈，登山者只好随遇而安。有时同当地牧师（他通常和他的教民一样穷）住在一起，有时同牧羊人或制乳酪的人住在一起。无论在哪儿，情况都一样：肮脏、贫穷，极其不舒适。\n\nboast: to be lucky enough to own。这里不用 have 而是用 boast，表明作者不是在做客观的描述，而是带有感情色彩的。例子：The university boasts the highest number of first-rate teachers in China.\n\ninvariably 不变的。\n\nFor men accustomed to eating seven-course dinners and sleeping between fine linen sheets at home, the change to the Alps must have been very hard indeed.\n\n对于过惯了一顿饭吃7道菜、睡亚麻细布床单的人来说，变换一下生活环境来到阿尔卑斯山山区，那一定是很艰难的。\n\nseven-course dinners，七道菜的晚饭。sheet 薄片，纸张，床单。\n","slug":"新概念英语四-lesson-03-Matterhorn-Man","published":1,"updated":"2018-04-23T14:10:45.534Z","layout":"post","photos":[],"link":"","_id":"cjm2w8dde002afgpxg10suxhr","content":"<p>生词：</p>\n<ul>\n<li>climber （这个单词要注意发音，b 是不发音的）</li>\n<li>alpinist 登山运动员</li>\n<li>route 路</li>\n<li>summit 最高，顶点</li>\n<li>sought seek 的过去式, seek sought sought</li>\n<li>perilous 危险的</li>\n<li>manner 方式</li>\n<li>court 招致</li>\n<li>solitary 孤独的</li>\n<li>rapidly 快速的</li>\n<li>Alpine 阿尔卑斯山的</li>\n<li>impoverished 贫困</li>\n<li>settlements 定居点</li>\n<li>flea-ridden 跳蚤猖獗</li>\n<li>coarse 粗糙的</li>\n<li>boast 吹嘘</li>\n<li>priest 牧师</li>\n<li>parishioner 教徒</li>\n<li>shepherd 牧羊人</li>\n<li>Invariably 不变的</li>\n<li>linen 亚麻的</li>\n</ul>\n<p>语言点：<br>alpinist 实际上是由 Alps 阿尔卑斯山演变来的。</p>\n<p>What was the main objective of early mountain climbers?</p>\n<p>语言用词的多样性：这里的目标用的是 objective，也可以用 aim，goal 等。</p>\n<p>这个问题的答案是：to get to the top by the easiest route</p>\n<p>Modern alpinists try to climb mountains by a route which will give them good sport, and the more difficult it is, the more highly it is regarded.</p>\n<p>英语用词有时候非常简单，比如这里的 good sport 和 highly。</p>\n<p>而翻译成汉语则是：</p>\n<p>现代登山运动员总想找一条能够给他们带来运动乐趣的路线来攀登山峰。他们认为，道路愈艰险愈带劲儿。</p>\n<p>汉语用的是 运动乐趣 和 带劲儿。也是相当地道的。</p>\n<p>In the pioneering days however, this was not the case at all.</p>\n<p>然而，在登山运动的初期，全然不是这种情况。</p>\n<p>这里的 pioneering days 用法很新鲜，如果是我的话只会想到 early，this was not the case at all 又一次反映了英语用词的简洁。the case 用的很爽。</p>\n<p>The early climbers were looking for the easiest way to the top because the summit was the prize they sought, especially if it had never been attained before.</p>\n<p>早期登山者所寻找的是通往山顶的最方便的途径，这是他们追寻的目标，特别是前人未曾到达过的山顶。</p>\n<p>这里的 early 呼应了前面的 pioneering，the summit was the prize they sought，时刻注意时态，英语就是如此，有不少的细节，需要严谨对待。另外 summit 用来表示山顶，如果是我的话只能想到 top，以后可以用 summit 来代替了。especially if it had never been attained before，我突然想到是不是也可以用 achieved。</p>\n<p>It is true that during their explorations they often faced difficulties and dangers of the most perilous nature, equipped in a manner which would make a modern climber shudder at the thought, but they did not go out of their way to court such excitement.</p>\n<p>确实，在探险中他们经常遇到惊心动魄的困难和危险，而他们的装备之简陋足以使现代登山者一想起来就胆战心惊。但是他们并非故意寻求这种刺激。</p>\n<p>perilous险恶的，perilous nature 用来形容恶劣的自然环境。equipped in a manner which would make a modern climber shudder at the thought，这一句十分经典。court such excitement，这里的 court 表示招致，我以前只知道：法院、球场。</p>\n<p>They had a single aim, a solitary goal – the top!</p>\n<p>这个用了相同的词来描述同一个事，作为强调。而且语气上是递进的 single 和 solitary 比，solitary 语气更重，aim 和 goal 比，aim 表示一般的泛泛的目标，goal 则常用在体育竞赛方面。</p>\n<p>It is hard for us to realize nowadays how difficult it was for the pioneers.</p>\n<p>我们今天很难想象昔日的登山先驱是多么艰苦。</p>\n<p>Except for one or two places such as Zermatt and Chamonix, which had rapidly become popular.</p>\n<p>Alpine villages tended to be impoverished settlements cut off from civilization by the high mountains.</p>\n<p>阿尔卑斯山山区的小村几乎全是高山环抱、与世隔绝的穷乡僻壤。</p>\n<p>tended to be，几乎全是，用得好。cut off from civilization by the high mountains，简单词用的好，形象的描述了高山环抱、与世隔绝、穷乡僻壤。</p>\n<p>Such inns as there were were generally dirty and flea-ridden;the food simply local cheese accompanied by bread often twelve months old, all washed down with coarse wine.</p>\n<p>那里的小客栈一般都很脏，而且跳蚤猖獗。食物是当地的干酪和通常存放了一年之久的面包，人们就着劣酒吞下这种食物。</p>\n<p>accompanied by 这里用的不错，bread often twelve months old，形容面包和形容人是一样的用法。washed down 用液体灌下。coarse 粗糙的，coarse wine 劣质的酒。</p>\n<p>Often a valley boasted no inn at all, and climbers found shelter wherever they could sometimes with the local priest(who was usually as poor as his parishioners), sometimes with shepherds or cheese-makers. Invariably the background was the same: dirt and poverty, and very uncomfortable.</p>\n<p>山谷里常常没有小客栈，登山者只好随遇而安。有时同当地牧师（他通常和他的教民一样穷）住在一起，有时同牧羊人或制乳酪的人住在一起。无论在哪儿，情况都一样：肮脏、贫穷，极其不舒适。</p>\n<p>boast: to be lucky enough to own。这里不用 have 而是用 boast，表明作者不是在做客观的描述，而是带有感情色彩的。例子：The university boasts the highest number of first-rate teachers in China.</p>\n<p>invariably 不变的。</p>\n<p>For men accustomed to eating seven-course dinners and sleeping between fine linen sheets at home, the change to the Alps must have been very hard indeed.</p>\n<p>对于过惯了一顿饭吃7道菜、睡亚麻细布床单的人来说，变换一下生活环境来到阿尔卑斯山山区，那一定是很艰难的。</p>\n<p>seven-course dinners，七道菜的晚饭。sheet 薄片，纸张，床单。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>生词：</p>\n<ul>\n<li>climber （这个单词要注意发音，b 是不发音的）</li>\n<li>alpinist 登山运动员</li>\n<li>route 路</li>\n<li>summit 最高，顶点</li>\n<li>sought seek 的过去式, seek sought sought</li>\n<li>perilous 危险的</li>\n<li>manner 方式</li>\n<li>court 招致</li>\n<li>solitary 孤独的</li>\n<li>rapidly 快速的</li>\n<li>Alpine 阿尔卑斯山的</li>\n<li>impoverished 贫困</li>\n<li>settlements 定居点</li>\n<li>flea-ridden 跳蚤猖獗</li>\n<li>coarse 粗糙的</li>\n<li>boast 吹嘘</li>\n<li>priest 牧师</li>\n<li>parishioner 教徒</li>\n<li>shepherd 牧羊人</li>\n<li>Invariably 不变的</li>\n<li>linen 亚麻的</li>\n</ul>\n<p>语言点：<br>alpinist 实际上是由 Alps 阿尔卑斯山演变来的。</p>\n<p>What was the main objective of early mountain climbers?</p>\n<p>语言用词的多样性：这里的目标用的是 objective，也可以用 aim，goal 等。</p>\n<p>这个问题的答案是：to get to the top by the easiest route</p>\n<p>Modern alpinists try to climb mountains by a route which will give them good sport, and the more difficult it is, the more highly it is regarded.</p>\n<p>英语用词有时候非常简单，比如这里的 good sport 和 highly。</p>\n<p>而翻译成汉语则是：</p>\n<p>现代登山运动员总想找一条能够给他们带来运动乐趣的路线来攀登山峰。他们认为，道路愈艰险愈带劲儿。</p>\n<p>汉语用的是 运动乐趣 和 带劲儿。也是相当地道的。</p>\n<p>In the pioneering days however, this was not the case at all.</p>\n<p>然而，在登山运动的初期，全然不是这种情况。</p>\n<p>这里的 pioneering days 用法很新鲜，如果是我的话只会想到 early，this was not the case at all 又一次反映了英语用词的简洁。the case 用的很爽。</p>\n<p>The early climbers were looking for the easiest way to the top because the summit was the prize they sought, especially if it had never been attained before.</p>\n<p>早期登山者所寻找的是通往山顶的最方便的途径，这是他们追寻的目标，特别是前人未曾到达过的山顶。</p>\n<p>这里的 early 呼应了前面的 pioneering，the summit was the prize they sought，时刻注意时态，英语就是如此，有不少的细节，需要严谨对待。另外 summit 用来表示山顶，如果是我的话只能想到 top，以后可以用 summit 来代替了。especially if it had never been attained before，我突然想到是不是也可以用 achieved。</p>\n<p>It is true that during their explorations they often faced difficulties and dangers of the most perilous nature, equipped in a manner which would make a modern climber shudder at the thought, but they did not go out of their way to court such excitement.</p>\n<p>确实，在探险中他们经常遇到惊心动魄的困难和危险，而他们的装备之简陋足以使现代登山者一想起来就胆战心惊。但是他们并非故意寻求这种刺激。</p>\n<p>perilous险恶的，perilous nature 用来形容恶劣的自然环境。equipped in a manner which would make a modern climber shudder at the thought，这一句十分经典。court such excitement，这里的 court 表示招致，我以前只知道：法院、球场。</p>\n<p>They had a single aim, a solitary goal – the top!</p>\n<p>这个用了相同的词来描述同一个事，作为强调。而且语气上是递进的 single 和 solitary 比，solitary 语气更重，aim 和 goal 比，aim 表示一般的泛泛的目标，goal 则常用在体育竞赛方面。</p>\n<p>It is hard for us to realize nowadays how difficult it was for the pioneers.</p>\n<p>我们今天很难想象昔日的登山先驱是多么艰苦。</p>\n<p>Except for one or two places such as Zermatt and Chamonix, which had rapidly become popular.</p>\n<p>Alpine villages tended to be impoverished settlements cut off from civilization by the high mountains.</p>\n<p>阿尔卑斯山山区的小村几乎全是高山环抱、与世隔绝的穷乡僻壤。</p>\n<p>tended to be，几乎全是，用得好。cut off from civilization by the high mountains，简单词用的好，形象的描述了高山环抱、与世隔绝、穷乡僻壤。</p>\n<p>Such inns as there were were generally dirty and flea-ridden;the food simply local cheese accompanied by bread often twelve months old, all washed down with coarse wine.</p>\n<p>那里的小客栈一般都很脏，而且跳蚤猖獗。食物是当地的干酪和通常存放了一年之久的面包，人们就着劣酒吞下这种食物。</p>\n<p>accompanied by 这里用的不错，bread often twelve months old，形容面包和形容人是一样的用法。washed down 用液体灌下。coarse 粗糙的，coarse wine 劣质的酒。</p>\n<p>Often a valley boasted no inn at all, and climbers found shelter wherever they could sometimes with the local priest(who was usually as poor as his parishioners), sometimes with shepherds or cheese-makers. Invariably the background was the same: dirt and poverty, and very uncomfortable.</p>\n<p>山谷里常常没有小客栈，登山者只好随遇而安。有时同当地牧师（他通常和他的教民一样穷）住在一起，有时同牧羊人或制乳酪的人住在一起。无论在哪儿，情况都一样：肮脏、贫穷，极其不舒适。</p>\n<p>boast: to be lucky enough to own。这里不用 have 而是用 boast，表明作者不是在做客观的描述，而是带有感情色彩的。例子：The university boasts the highest number of first-rate teachers in China.</p>\n<p>invariably 不变的。</p>\n<p>For men accustomed to eating seven-course dinners and sleeping between fine linen sheets at home, the change to the Alps must have been very hard indeed.</p>\n<p>对于过惯了一顿饭吃7道菜、睡亚麻细布床单的人来说，变换一下生活环境来到阿尔卑斯山山区，那一定是很艰难的。</p>\n<p>seven-course dinners，七道菜的晚饭。sheet 薄片，纸张，床单。</p>\n"},{"layout":"post","title":"Java OutputStream flush","date":"2018-02-26T16:00:00.000Z","comments":1,"_content":"\nFileOutPutStream继承OutputStream，并不提供flush()方法的重写，所以无论内容多少，write都会将二进制流直接传递给底层操作系统的I/O，flush无效果。而Buffered系列的输入输出流函数单从Buffered这个单词就可以看出他们是使用缓冲区的。\n\n应用程序每次IO都要和设备进行通信，效率很低，因此缓冲区为了提高效率，当写入设备时，先写入缓冲区，每次等到缓冲区满了时，就将数据一次性整体写入设备，避免了每一个数据都和IO进行一次交互，IO交互消耗太大。\n\n## 使用flush()和不使用flush()效果对比\n\n### 不使用flush()\n\n```Java\nString s = \"Hello World\";\ntry {\n    // create a new stream at specified file\n    PrintWriter pw = new PrintWriter(System.out);\n    // write the string in the file\n    pw.write(s);\n//            // flush the writer\n//            pw.flush();\n} catch (Exception ex) {\n    ex.printStackTrace();\n}\n```\n\nbuffer没有满，输出为空。\n\n### 使用flush()\n\n```Java\nString s = \"Hello World\";\ntry {\n    // create a new stream at specified file\n    PrintWriter pw = new PrintWriter(System.out);\n    // write the string in the file\n    pw.write(s);\n    // flush the writer\n    pw.flush();\n} catch (Exception ex) {\n    ex.printStackTrace();\n}\n```\n\n得到期望的输出结果。\n\n## close()和flush()作用有交集！\n\n```Java\npublic static void main(String[] args) {\n    BufferedWriter fw =null;\n    try {\n        fw =  new BufferedWriter(new FileWriter(\"e:\\\\test.txt\"));\n        fw.write(\"wo shi lucky girl.\");\n        //fw.flush();\n        fw.close();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n```\n\n因为close的时候，会把你没flush掉的一起flush掉。\n缓冲区中的数据保存直到缓冲区满后才写出，也可以使用flush方法将缓冲区中的数据强制写出或使用close()方法关闭流，关闭流之前，缓冲输出流将缓冲区数据一次性写出。在这个例子中，flush()和close()都使数据强制写出，所以两种结果是一样的，如果都不写的话，会发现不能成功写出。\n\n## Java默认缓冲区大小是多少？\n\n默认缓冲去大小8192字节，也就是8k。\n\n### 实验\n\n```Java\nchar[] array  = new char[8192];\nArrays.fill(array,'s');\nPrintWriter pw = new PrintWriter(System.out);\npw.write(array);\n```\n\n```Java\nchar[] array  = new char[8193];\nArrays.fill(array,'s');\nPrintWriter pw = new PrintWriter(System.out);\npw.write(array);\n```\n\n当设置数组长度为8192时没有输出，设置8193时有输出。\n","source":"_posts/2018/2018-02-27-Java-OutputStream-flush.md","raw":"---\nlayout: post\ntitle: Java OutputStream flush\ndate: 2018-02-27\ncategories: [Java]\ncomments: true\n---\n\nFileOutPutStream继承OutputStream，并不提供flush()方法的重写，所以无论内容多少，write都会将二进制流直接传递给底层操作系统的I/O，flush无效果。而Buffered系列的输入输出流函数单从Buffered这个单词就可以看出他们是使用缓冲区的。\n\n应用程序每次IO都要和设备进行通信，效率很低，因此缓冲区为了提高效率，当写入设备时，先写入缓冲区，每次等到缓冲区满了时，就将数据一次性整体写入设备，避免了每一个数据都和IO进行一次交互，IO交互消耗太大。\n\n## 使用flush()和不使用flush()效果对比\n\n### 不使用flush()\n\n```Java\nString s = \"Hello World\";\ntry {\n    // create a new stream at specified file\n    PrintWriter pw = new PrintWriter(System.out);\n    // write the string in the file\n    pw.write(s);\n//            // flush the writer\n//            pw.flush();\n} catch (Exception ex) {\n    ex.printStackTrace();\n}\n```\n\nbuffer没有满，输出为空。\n\n### 使用flush()\n\n```Java\nString s = \"Hello World\";\ntry {\n    // create a new stream at specified file\n    PrintWriter pw = new PrintWriter(System.out);\n    // write the string in the file\n    pw.write(s);\n    // flush the writer\n    pw.flush();\n} catch (Exception ex) {\n    ex.printStackTrace();\n}\n```\n\n得到期望的输出结果。\n\n## close()和flush()作用有交集！\n\n```Java\npublic static void main(String[] args) {\n    BufferedWriter fw =null;\n    try {\n        fw =  new BufferedWriter(new FileWriter(\"e:\\\\test.txt\"));\n        fw.write(\"wo shi lucky girl.\");\n        //fw.flush();\n        fw.close();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n```\n\n因为close的时候，会把你没flush掉的一起flush掉。\n缓冲区中的数据保存直到缓冲区满后才写出，也可以使用flush方法将缓冲区中的数据强制写出或使用close()方法关闭流，关闭流之前，缓冲输出流将缓冲区数据一次性写出。在这个例子中，flush()和close()都使数据强制写出，所以两种结果是一样的，如果都不写的话，会发现不能成功写出。\n\n## Java默认缓冲区大小是多少？\n\n默认缓冲去大小8192字节，也就是8k。\n\n### 实验\n\n```Java\nchar[] array  = new char[8192];\nArrays.fill(array,'s');\nPrintWriter pw = new PrintWriter(System.out);\npw.write(array);\n```\n\n```Java\nchar[] array  = new char[8193];\nArrays.fill(array,'s');\nPrintWriter pw = new PrintWriter(System.out);\npw.write(array);\n```\n\n当设置数组长度为8192时没有输出，设置8193时有输出。\n","slug":"Java-OutputStream-flush","published":1,"updated":"2018-04-24T01:10:11.280Z","photos":[],"link":"","_id":"cjm2w8ddg002dfgpxmry1l86b","content":"<p>FileOutPutStream继承OutputStream，并不提供flush()方法的重写，所以无论内容多少，write都会将二进制流直接传递给底层操作系统的I/O，flush无效果。而Buffered系列的输入输出流函数单从Buffered这个单词就可以看出他们是使用缓冲区的。</p>\n<p>应用程序每次IO都要和设备进行通信，效率很低，因此缓冲区为了提高效率，当写入设备时，先写入缓冲区，每次等到缓冲区满了时，就将数据一次性整体写入设备，避免了每一个数据都和IO进行一次交互，IO交互消耗太大。</p>\n<h2 id=\"使用flush-和不使用flush-效果对比\"><a href=\"#使用flush-和不使用flush-效果对比\" class=\"headerlink\" title=\"使用flush()和不使用flush()效果对比\"></a>使用flush()和不使用flush()效果对比</h2><h3 id=\"不使用flush\"><a href=\"#不使用flush\" class=\"headerlink\" title=\"不使用flush()\"></a>不使用flush()</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s = <span class=\"string\">\"Hello World\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// create a new stream at specified file</span></span><br><span class=\"line\">    PrintWriter pw = <span class=\"keyword\">new</span> PrintWriter(System.out);</span><br><span class=\"line\">    <span class=\"comment\">// write the string in the file</span></span><br><span class=\"line\">    pw.write(s);</span><br><span class=\"line\"><span class=\"comment\">//            // flush the writer</span></span><br><span class=\"line\"><span class=\"comment\">//            pw.flush();</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception ex) &#123;</span><br><span class=\"line\">    ex.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>buffer没有满，输出为空。</p>\n<h3 id=\"使用flush\"><a href=\"#使用flush\" class=\"headerlink\" title=\"使用flush()\"></a>使用flush()</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s = <span class=\"string\">\"Hello World\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// create a new stream at specified file</span></span><br><span class=\"line\">    PrintWriter pw = <span class=\"keyword\">new</span> PrintWriter(System.out);</span><br><span class=\"line\">    <span class=\"comment\">// write the string in the file</span></span><br><span class=\"line\">    pw.write(s);</span><br><span class=\"line\">    <span class=\"comment\">// flush the writer</span></span><br><span class=\"line\">    pw.flush();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception ex) &#123;</span><br><span class=\"line\">    ex.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>得到期望的输出结果。</p>\n<h2 id=\"close-和flush-作用有交集！\"><a href=\"#close-和flush-作用有交集！\" class=\"headerlink\" title=\"close()和flush()作用有交集！\"></a>close()和flush()作用有交集！</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    BufferedWriter fw =<span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        fw =  <span class=\"keyword\">new</span> BufferedWriter(<span class=\"keyword\">new</span> FileWriter(<span class=\"string\">\"e:\\\\test.txt\"</span>));</span><br><span class=\"line\">        fw.write(<span class=\"string\">\"wo shi lucky girl.\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//fw.flush();</span></span><br><span class=\"line\">        fw.close();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为close的时候，会把你没flush掉的一起flush掉。<br>缓冲区中的数据保存直到缓冲区满后才写出，也可以使用flush方法将缓冲区中的数据强制写出或使用close()方法关闭流，关闭流之前，缓冲输出流将缓冲区数据一次性写出。在这个例子中，flush()和close()都使数据强制写出，所以两种结果是一样的，如果都不写的话，会发现不能成功写出。</p>\n<h2 id=\"Java默认缓冲区大小是多少？\"><a href=\"#Java默认缓冲区大小是多少？\" class=\"headerlink\" title=\"Java默认缓冲区大小是多少？\"></a>Java默认缓冲区大小是多少？</h2><p>默认缓冲去大小8192字节，也就是8k。</p>\n<h3 id=\"实验\"><a href=\"#实验\" class=\"headerlink\" title=\"实验\"></a>实验</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span>[] array  = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"number\">8192</span>];</span><br><span class=\"line\">Arrays.fill(array,<span class=\"string\">'s'</span>);</span><br><span class=\"line\">PrintWriter pw = <span class=\"keyword\">new</span> PrintWriter(System.out);</span><br><span class=\"line\">pw.write(array);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span>[] array  = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"number\">8193</span>];</span><br><span class=\"line\">Arrays.fill(array,<span class=\"string\">'s'</span>);</span><br><span class=\"line\">PrintWriter pw = <span class=\"keyword\">new</span> PrintWriter(System.out);</span><br><span class=\"line\">pw.write(array);</span><br></pre></td></tr></table></figure>\n<p>当设置数组长度为8192时没有输出，设置8193时有输出。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>FileOutPutStream继承OutputStream，并不提供flush()方法的重写，所以无论内容多少，write都会将二进制流直接传递给底层操作系统的I/O，flush无效果。而Buffered系列的输入输出流函数单从Buffered这个单词就可以看出他们是使用缓冲区的。</p>\n<p>应用程序每次IO都要和设备进行通信，效率很低，因此缓冲区为了提高效率，当写入设备时，先写入缓冲区，每次等到缓冲区满了时，就将数据一次性整体写入设备，避免了每一个数据都和IO进行一次交互，IO交互消耗太大。</p>\n<h2 id=\"使用flush-和不使用flush-效果对比\"><a href=\"#使用flush-和不使用flush-效果对比\" class=\"headerlink\" title=\"使用flush()和不使用flush()效果对比\"></a>使用flush()和不使用flush()效果对比</h2><h3 id=\"不使用flush\"><a href=\"#不使用flush\" class=\"headerlink\" title=\"不使用flush()\"></a>不使用flush()</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s = <span class=\"string\">\"Hello World\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// create a new stream at specified file</span></span><br><span class=\"line\">    PrintWriter pw = <span class=\"keyword\">new</span> PrintWriter(System.out);</span><br><span class=\"line\">    <span class=\"comment\">// write the string in the file</span></span><br><span class=\"line\">    pw.write(s);</span><br><span class=\"line\"><span class=\"comment\">//            // flush the writer</span></span><br><span class=\"line\"><span class=\"comment\">//            pw.flush();</span></span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception ex) &#123;</span><br><span class=\"line\">    ex.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>buffer没有满，输出为空。</p>\n<h3 id=\"使用flush\"><a href=\"#使用flush\" class=\"headerlink\" title=\"使用flush()\"></a>使用flush()</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String s = <span class=\"string\">\"Hello World\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// create a new stream at specified file</span></span><br><span class=\"line\">    PrintWriter pw = <span class=\"keyword\">new</span> PrintWriter(System.out);</span><br><span class=\"line\">    <span class=\"comment\">// write the string in the file</span></span><br><span class=\"line\">    pw.write(s);</span><br><span class=\"line\">    <span class=\"comment\">// flush the writer</span></span><br><span class=\"line\">    pw.flush();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (Exception ex) &#123;</span><br><span class=\"line\">    ex.printStackTrace();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>得到期望的输出结果。</p>\n<h2 id=\"close-和flush-作用有交集！\"><a href=\"#close-和flush-作用有交集！\" class=\"headerlink\" title=\"close()和flush()作用有交集！\"></a>close()和flush()作用有交集！</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    BufferedWriter fw =<span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        fw =  <span class=\"keyword\">new</span> BufferedWriter(<span class=\"keyword\">new</span> FileWriter(<span class=\"string\">\"e:\\\\test.txt\"</span>));</span><br><span class=\"line\">        fw.write(<span class=\"string\">\"wo shi lucky girl.\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//fw.flush();</span></span><br><span class=\"line\">        fw.close();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">        e.printStackTrace();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>因为close的时候，会把你没flush掉的一起flush掉。<br>缓冲区中的数据保存直到缓冲区满后才写出，也可以使用flush方法将缓冲区中的数据强制写出或使用close()方法关闭流，关闭流之前，缓冲输出流将缓冲区数据一次性写出。在这个例子中，flush()和close()都使数据强制写出，所以两种结果是一样的，如果都不写的话，会发现不能成功写出。</p>\n<h2 id=\"Java默认缓冲区大小是多少？\"><a href=\"#Java默认缓冲区大小是多少？\" class=\"headerlink\" title=\"Java默认缓冲区大小是多少？\"></a>Java默认缓冲区大小是多少？</h2><p>默认缓冲去大小8192字节，也就是8k。</p>\n<h3 id=\"实验\"><a href=\"#实验\" class=\"headerlink\" title=\"实验\"></a>实验</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span>[] array  = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"number\">8192</span>];</span><br><span class=\"line\">Arrays.fill(array,<span class=\"string\">'s'</span>);</span><br><span class=\"line\">PrintWriter pw = <span class=\"keyword\">new</span> PrintWriter(System.out);</span><br><span class=\"line\">pw.write(array);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span>[] array  = <span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"number\">8193</span>];</span><br><span class=\"line\">Arrays.fill(array,<span class=\"string\">'s'</span>);</span><br><span class=\"line\">PrintWriter pw = <span class=\"keyword\">new</span> PrintWriter(System.out);</span><br><span class=\"line\">pw.write(array);</span><br></pre></td></tr></table></figure>\n<p>当设置数组长度为8192时没有输出，设置8193时有输出。</p>\n"},{"title":"Hexo+Markdown+MathJax搭建个人博客","date":"2018-04-24T16:00:00.000Z","comments":1,"_content":"\n## 为什么搭建个人博客\n\n其实有想过用简书写博客，但简书不支持 `mathjax`，而我写作的时候要用到不少数学公式。\n\n以前也用过 leanote，也就是现在的 蚂蚁笔记，但蚂蚁笔记的博客中，[TOC] 是有 mathjax 渲染的，但右上角的目录导航却是没有加 mathjax 渲染的，这样看着会相当别扭。另外还有几个原因：\n\n1. leanote收费\n2. 无法彻底的自定义\n3. 博客不像使用静态网站引擎那样直观的以文件的形式展示在我面前\n\n## 为什么选 hexo\n\n为什么选择 `hexo`，而不是 `jekyll`，或者 `hugo`。\n\n其实我以前的博客是用的 jekyll，弃用 jekyll 是因为这东西实在是太慢了，我更新文章之后无法立即看到结果，要刷新很多次，或者说要等很久，git pages 上才会显示新的东西。听说 hexo 和 hugo 的速度都比较快，所以就换了 hexo，hexo 的主题比 hugo 多，另外 hugo 的官网和主题网站访问实在太慢了，成功恶心到了我。所以我最后选了 hexo，用上了经典主题 next。现在来说，主要是next主题吸引我，而hugo的next主题太简陋了。\n\n>hexo 是用 nodejs 写的，jekyll 是用 ruby 写的，hugo 是用 go 语言写的，wordpress 是用 php 实现的。\n\n那为什么不用 wordpress 呢，因为我想用 git pages 这个平台，而这个平台只支持静态博客。\n\n## 搭建过程\n\n### 环境配置\n\n首先你要安装 `git` 和 `npm`，git 是一种版本控制工具，npm 则是 nodejs 的包管理工具。\n\nmac 上，使用 brew 和 brew cask 可以像许多 Linux 系统一样直接通过命令行安装软件。\n\n```\nbrew install git\nbrew install node\n```\n\n另外很不幸的是 git 和 npm 在国内都是无法愉快的使用的，虽然没有被墙，但是速度奇慢无比。于是我们需要做些工作：\n\n给 git 挂代理：\n\n```\ngit config --global http.proxy https://127.0.0.1:1087\ngit config --global https.proxy https://127.0.0.1:1087\n```\n\n但为了实现上面的功能，首先你得有个翻墙代理。关于翻墙都可以额外写篇文章了。\n\n想看详细的解决办法：\n\n- https://www.zhihu.com/question/27159393\n- https://www.zhihu.com/question/27159393/answer/141047266\n\n然后给 npm 换源：\n\n```\nnpm config set registry https://registry.npm.taobao.org\nnpm info underscore （这个只是为了检验上面的设置命令是否成功，若成功，会返回[指定包]的信息）\n```\n\n想看更详细的解决办法：\n\n- https://segmentfault.com/a/1190000007829080\n\n好了，之后就是\n\n- hexo 安装\n- 初始化 blog 目录\n- 然后 hexo server 开启本地服务器，一个 demo 就出现啦。\n\n命令如下：\n\n```\nnpm install hexo-cli -g\nhexo init blog\nhexo server\n```\n\n### 基本的建站过程\n\n#### 从 jekyll 迁移到 hexo\n\n我是从 jekyll 迁移过来的，所以先把文章全都拷贝进 `source/_posts` 目录下面，然后修改 `_config.yml`，把：\n\n```\nnew_post_name: :title.md\n```\n\n变成：\n\n```\nnew_post_name: :year-:month-:day-:title.md\n```\n\n官网迁移教程：https://hexo.io/zh-cn/docs/migration.html\n\n#### 下载 next 主题并添加 mathjax\n\n然后下载一个 `next` 主题：\n\n```\ngit clone https://github.com/iissnan/hexo-theme-next themes/next\n```\n\n然后修改 `_config.yml`，把：\n\n```\ntheme: landscape\n```\n\n变成：\n\n```\ntheme: next\n```\n\n然后修改 `next` 的 `_config.yml`，把：\n\n```\nmathjax:\n  enable: false\n  per_page: false\n  cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config#TeX-AMS-MML_HTMLorMML\n```\n\n变成：\n\n\n```\nmathjax:\n  enable: true\n  per_page: false\n  cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config#TeX-AMS-MML_HTMLorMML\n```\n\n>注意`per_page`不能是true，一定要是false。\n\n#### 解决 markdown 与 mathjax 的冲突\n\n为了解决 `markdown` 下划线转义成 `<em>` 标签（HTML标签），从而导致 `mathjax` 的下标无法使用，这个问题，我们修改 `marked.js` 文件，如果你使用的是 `sublime text` 或者 `Atom` 编辑器，`cmd+o`打开你的博客目录，然后 `cmd+p` 输入你要在此目录下找的文件名：`marked.js` 就可以找到这个文件。这个文件的是：`node_modules/marked/lib/marked.js`。把文件中的：\n\n总共发现 mathjax 中的三处冲突：\n\n1. `_`变成了`<em>`\n2. `\\\\`变成了单个`\\`\n3. `< xxx >`大于号小于号之间会新增一个 `#\"\"`\n\n将\n\n```\nescape: /^\\\\([\\\\`*{}\\[\\]()# +\\-.!_>])/,\n```\n\n改为\n\n```\nescape: /^\\\\([`*{}\\[\\]()# +\\-.!_>])/,\n```\n\n这样就去掉了，双斜杠转义。\n\n把\n\n```\nem: /^\\b_((?:[^_]|__)+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,\n```\n\n改为\n\n```\nem:/^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,\n```\n\n这样就禁掉了 `_` 变 `<em>`（斜体标记）。\n\n最后，为了解决第三个冲突，我把 `>` 写成了 HTML 实体形式：`&gt;`，这样就无法组成一对尖括号了，终于不会冲突了。\n\n我为什么不装个 `hexo-renderer-pandoc` + `pandoc` ，说出来都是泪啊，装了啊，一执行就报错，google 了一圈，没有有用的解答，遂作罢。\n\n#### 解决语言不正确的问题\n\n我发现有些地方居然默认的是德语还是什么其他语言，反正不是英语，所以我们需要改：\n\n- 根目录下的 `_config.yml`\n- next 主题的 `_config.yml`\n\n两个都改成：\n\n```\nlanguage: en\n```\n\n#### 生成 public 静态网站目录 和 部署到 github\n\n生成静态网站目录：\n\n```\nhexo g\n```\n\n下载 hexo-deployer-git 插件：\n\n```\nnpm install hexo-deployer-git --save\n```\n\n再修改 `_config.yml`，把：\n\n```\ndeploy:\n  type:\n```\n\n变成：\n\n```\ndeploy:\n  type: git\n  repo: https://github.com/liuqinh2s/liuqinh2s.github.io\n  branch: master\n```\n\n然后，用命令 `hexo d` 部署就行了，不过首先你得有个 github 账号，然后还得有个叫 `liuqinh2s.github.io` 的项目，然后你还得配置好 github 环境：\n\n```\ngit config --global user.name \"Your Name Here\"\ngit config --global user.email \"your_email@example.com\"\n```\n\n然后把公钥的内容传给 github 就行了。这里只说原理，具体的操作懒得贴了。\n\n>只有多懂原理（哪怕只是基本的原理），你才能顺利解决遇到的诸多问题。\n\n官网的部署教程：https://hexo.io/zh-cn/docs/deployment.html\n\n基本的建站就结束了，然后就是慢慢把博客进行个性化吧。\n\n### hexo 个性化配置\n\n- hexo-reference，用来支持 markdown 脚注的\n- hexo-generator-seo-friendly-sitemap，sitemap用来喂给搜索引擎的，更好的爬取网站\n- hexo-generator-search，博客内部搜索\n- hexo-wordcount，统计字数用的\n\n然后就是调 next 主题，把自己喜欢的特性用上。\n\n然后就是加上 `不蒜子`，百度统计这类统计工具，和 disqus 评论等等。\n","source":"_posts/2018/2018-04-25-Hexo+Markdown+MathJax搭建个人博客.md","raw":"---\ntitle: Hexo+Markdown+MathJax搭建个人博客\ndate: 2018-04-25\ncategories: [projects]\ncomments: true\n---\n\n## 为什么搭建个人博客\n\n其实有想过用简书写博客，但简书不支持 `mathjax`，而我写作的时候要用到不少数学公式。\n\n以前也用过 leanote，也就是现在的 蚂蚁笔记，但蚂蚁笔记的博客中，[TOC] 是有 mathjax 渲染的，但右上角的目录导航却是没有加 mathjax 渲染的，这样看着会相当别扭。另外还有几个原因：\n\n1. leanote收费\n2. 无法彻底的自定义\n3. 博客不像使用静态网站引擎那样直观的以文件的形式展示在我面前\n\n## 为什么选 hexo\n\n为什么选择 `hexo`，而不是 `jekyll`，或者 `hugo`。\n\n其实我以前的博客是用的 jekyll，弃用 jekyll 是因为这东西实在是太慢了，我更新文章之后无法立即看到结果，要刷新很多次，或者说要等很久，git pages 上才会显示新的东西。听说 hexo 和 hugo 的速度都比较快，所以就换了 hexo，hexo 的主题比 hugo 多，另外 hugo 的官网和主题网站访问实在太慢了，成功恶心到了我。所以我最后选了 hexo，用上了经典主题 next。现在来说，主要是next主题吸引我，而hugo的next主题太简陋了。\n\n>hexo 是用 nodejs 写的，jekyll 是用 ruby 写的，hugo 是用 go 语言写的，wordpress 是用 php 实现的。\n\n那为什么不用 wordpress 呢，因为我想用 git pages 这个平台，而这个平台只支持静态博客。\n\n## 搭建过程\n\n### 环境配置\n\n首先你要安装 `git` 和 `npm`，git 是一种版本控制工具，npm 则是 nodejs 的包管理工具。\n\nmac 上，使用 brew 和 brew cask 可以像许多 Linux 系统一样直接通过命令行安装软件。\n\n```\nbrew install git\nbrew install node\n```\n\n另外很不幸的是 git 和 npm 在国内都是无法愉快的使用的，虽然没有被墙，但是速度奇慢无比。于是我们需要做些工作：\n\n给 git 挂代理：\n\n```\ngit config --global http.proxy https://127.0.0.1:1087\ngit config --global https.proxy https://127.0.0.1:1087\n```\n\n但为了实现上面的功能，首先你得有个翻墙代理。关于翻墙都可以额外写篇文章了。\n\n想看详细的解决办法：\n\n- https://www.zhihu.com/question/27159393\n- https://www.zhihu.com/question/27159393/answer/141047266\n\n然后给 npm 换源：\n\n```\nnpm config set registry https://registry.npm.taobao.org\nnpm info underscore （这个只是为了检验上面的设置命令是否成功，若成功，会返回[指定包]的信息）\n```\n\n想看更详细的解决办法：\n\n- https://segmentfault.com/a/1190000007829080\n\n好了，之后就是\n\n- hexo 安装\n- 初始化 blog 目录\n- 然后 hexo server 开启本地服务器，一个 demo 就出现啦。\n\n命令如下：\n\n```\nnpm install hexo-cli -g\nhexo init blog\nhexo server\n```\n\n### 基本的建站过程\n\n#### 从 jekyll 迁移到 hexo\n\n我是从 jekyll 迁移过来的，所以先把文章全都拷贝进 `source/_posts` 目录下面，然后修改 `_config.yml`，把：\n\n```\nnew_post_name: :title.md\n```\n\n变成：\n\n```\nnew_post_name: :year-:month-:day-:title.md\n```\n\n官网迁移教程：https://hexo.io/zh-cn/docs/migration.html\n\n#### 下载 next 主题并添加 mathjax\n\n然后下载一个 `next` 主题：\n\n```\ngit clone https://github.com/iissnan/hexo-theme-next themes/next\n```\n\n然后修改 `_config.yml`，把：\n\n```\ntheme: landscape\n```\n\n变成：\n\n```\ntheme: next\n```\n\n然后修改 `next` 的 `_config.yml`，把：\n\n```\nmathjax:\n  enable: false\n  per_page: false\n  cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config#TeX-AMS-MML_HTMLorMML\n```\n\n变成：\n\n\n```\nmathjax:\n  enable: true\n  per_page: false\n  cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config#TeX-AMS-MML_HTMLorMML\n```\n\n>注意`per_page`不能是true，一定要是false。\n\n#### 解决 markdown 与 mathjax 的冲突\n\n为了解决 `markdown` 下划线转义成 `<em>` 标签（HTML标签），从而导致 `mathjax` 的下标无法使用，这个问题，我们修改 `marked.js` 文件，如果你使用的是 `sublime text` 或者 `Atom` 编辑器，`cmd+o`打开你的博客目录，然后 `cmd+p` 输入你要在此目录下找的文件名：`marked.js` 就可以找到这个文件。这个文件的是：`node_modules/marked/lib/marked.js`。把文件中的：\n\n总共发现 mathjax 中的三处冲突：\n\n1. `_`变成了`<em>`\n2. `\\\\`变成了单个`\\`\n3. `< xxx >`大于号小于号之间会新增一个 `#\"\"`\n\n将\n\n```\nescape: /^\\\\([\\\\`*{}\\[\\]()# +\\-.!_>])/,\n```\n\n改为\n\n```\nescape: /^\\\\([`*{}\\[\\]()# +\\-.!_>])/,\n```\n\n这样就去掉了，双斜杠转义。\n\n把\n\n```\nem: /^\\b_((?:[^_]|__)+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,\n```\n\n改为\n\n```\nem:/^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,\n```\n\n这样就禁掉了 `_` 变 `<em>`（斜体标记）。\n\n最后，为了解决第三个冲突，我把 `>` 写成了 HTML 实体形式：`&gt;`，这样就无法组成一对尖括号了，终于不会冲突了。\n\n我为什么不装个 `hexo-renderer-pandoc` + `pandoc` ，说出来都是泪啊，装了啊，一执行就报错，google 了一圈，没有有用的解答，遂作罢。\n\n#### 解决语言不正确的问题\n\n我发现有些地方居然默认的是德语还是什么其他语言，反正不是英语，所以我们需要改：\n\n- 根目录下的 `_config.yml`\n- next 主题的 `_config.yml`\n\n两个都改成：\n\n```\nlanguage: en\n```\n\n#### 生成 public 静态网站目录 和 部署到 github\n\n生成静态网站目录：\n\n```\nhexo g\n```\n\n下载 hexo-deployer-git 插件：\n\n```\nnpm install hexo-deployer-git --save\n```\n\n再修改 `_config.yml`，把：\n\n```\ndeploy:\n  type:\n```\n\n变成：\n\n```\ndeploy:\n  type: git\n  repo: https://github.com/liuqinh2s/liuqinh2s.github.io\n  branch: master\n```\n\n然后，用命令 `hexo d` 部署就行了，不过首先你得有个 github 账号，然后还得有个叫 `liuqinh2s.github.io` 的项目，然后你还得配置好 github 环境：\n\n```\ngit config --global user.name \"Your Name Here\"\ngit config --global user.email \"your_email@example.com\"\n```\n\n然后把公钥的内容传给 github 就行了。这里只说原理，具体的操作懒得贴了。\n\n>只有多懂原理（哪怕只是基本的原理），你才能顺利解决遇到的诸多问题。\n\n官网的部署教程：https://hexo.io/zh-cn/docs/deployment.html\n\n基本的建站就结束了，然后就是慢慢把博客进行个性化吧。\n\n### hexo 个性化配置\n\n- hexo-reference，用来支持 markdown 脚注的\n- hexo-generator-seo-friendly-sitemap，sitemap用来喂给搜索引擎的，更好的爬取网站\n- hexo-generator-search，博客内部搜索\n- hexo-wordcount，统计字数用的\n\n然后就是调 next 主题，把自己喜欢的特性用上。\n\n然后就是加上 `不蒜子`，百度统计这类统计工具，和 disqus 评论等等。\n","slug":"Hexo+Markdown+MathJax搭建个人博客","published":1,"updated":"2018-04-25T04:52:20.655Z","layout":"post","photos":[],"link":"","_id":"cjm2w8ddh002efgpx1fv54zee","content":"<h2 id=\"为什么搭建个人博客\"><a href=\"#为什么搭建个人博客\" class=\"headerlink\" title=\"为什么搭建个人博客\"></a>为什么搭建个人博客</h2><p>其实有想过用简书写博客，但简书不支持 <code>mathjax</code>，而我写作的时候要用到不少数学公式。</p>\n<p>以前也用过 leanote，也就是现在的 蚂蚁笔记，但蚂蚁笔记的博客中，[TOC] 是有 mathjax 渲染的，但右上角的目录导航却是没有加 mathjax 渲染的，这样看着会相当别扭。另外还有几个原因：</p>\n<ol>\n<li>leanote收费</li>\n<li>无法彻底的自定义</li>\n<li>博客不像使用静态网站引擎那样直观的以文件的形式展示在我面前</li>\n</ol>\n<h2 id=\"为什么选-hexo\"><a href=\"#为什么选-hexo\" class=\"headerlink\" title=\"为什么选 hexo\"></a>为什么选 hexo</h2><p>为什么选择 <code>hexo</code>，而不是 <code>jekyll</code>，或者 <code>hugo</code>。</p>\n<p>其实我以前的博客是用的 jekyll，弃用 jekyll 是因为这东西实在是太慢了，我更新文章之后无法立即看到结果，要刷新很多次，或者说要等很久，git pages 上才会显示新的东西。听说 hexo 和 hugo 的速度都比较快，所以就换了 hexo，hexo 的主题比 hugo 多，另外 hugo 的官网和主题网站访问实在太慢了，成功恶心到了我。所以我最后选了 hexo，用上了经典主题 next。现在来说，主要是next主题吸引我，而hugo的next主题太简陋了。</p>\n<blockquote>\n<p>hexo 是用 nodejs 写的，jekyll 是用 ruby 写的，hugo 是用 go 语言写的，wordpress 是用 php 实现的。</p>\n</blockquote>\n<p>那为什么不用 wordpress 呢，因为我想用 git pages 这个平台，而这个平台只支持静态博客。</p>\n<h2 id=\"搭建过程\"><a href=\"#搭建过程\" class=\"headerlink\" title=\"搭建过程\"></a>搭建过程</h2><h3 id=\"环境配置\"><a href=\"#环境配置\" class=\"headerlink\" title=\"环境配置\"></a>环境配置</h3><p>首先你要安装 <code>git</code> 和 <code>npm</code>，git 是一种版本控制工具，npm 则是 nodejs 的包管理工具。</p>\n<p>mac 上，使用 brew 和 brew cask 可以像许多 Linux 系统一样直接通过命令行安装软件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install git</span><br><span class=\"line\">brew install node</span><br></pre></td></tr></table></figure>\n<p>另外很不幸的是 git 和 npm 在国内都是无法愉快的使用的，虽然没有被墙，但是速度奇慢无比。于是我们需要做些工作：</p>\n<p>给 git 挂代理：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global http.proxy https://127.0.0.1:1087</span><br><span class=\"line\">git config --global https.proxy https://127.0.0.1:1087</span><br></pre></td></tr></table></figure>\n<p>但为了实现上面的功能，首先你得有个翻墙代理。关于翻墙都可以额外写篇文章了。</p>\n<p>想看详细的解决办法：</p>\n<ul>\n<li><a href=\"https://www.zhihu.com/question/27159393\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/27159393</a></li>\n<li><a href=\"https://www.zhihu.com/question/27159393/answer/141047266\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/27159393/answer/141047266</a></li>\n</ul>\n<p>然后给 npm 换源：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config set registry https://registry.npm.taobao.org</span><br><span class=\"line\">npm info underscore （这个只是为了检验上面的设置命令是否成功，若成功，会返回[指定包]的信息）</span><br></pre></td></tr></table></figure>\n<p>想看更详细的解决办法：</p>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000007829080\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000007829080</a></li>\n</ul>\n<p>好了，之后就是</p>\n<ul>\n<li>hexo 安装</li>\n<li>初始化 blog 目录</li>\n<li>然后 hexo server 开启本地服务器，一个 demo 就出现啦。</li>\n</ul>\n<p>命令如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-cli -g</span><br><span class=\"line\">hexo init blog</span><br><span class=\"line\">hexo server</span><br></pre></td></tr></table></figure>\n<h3 id=\"基本的建站过程\"><a href=\"#基本的建站过程\" class=\"headerlink\" title=\"基本的建站过程\"></a>基本的建站过程</h3><h4 id=\"从-jekyll-迁移到-hexo\"><a href=\"#从-jekyll-迁移到-hexo\" class=\"headerlink\" title=\"从 jekyll 迁移到 hexo\"></a>从 jekyll 迁移到 hexo</h4><p>我是从 jekyll 迁移过来的，所以先把文章全都拷贝进 <code>source/_posts</code> 目录下面，然后修改 <code>_config.yml</code>，把：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new_post_name: :title.md</span><br></pre></td></tr></table></figure>\n<p>变成：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new_post_name: :year-:month-:day-:title.md</span><br></pre></td></tr></table></figure>\n<p>官网迁移教程：<a href=\"https://hexo.io/zh-cn/docs/migration.html\" target=\"_blank\" rel=\"noopener\">https://hexo.io/zh-cn/docs/migration.html</a></p>\n<h4 id=\"下载-next-主题并添加-mathjax\"><a href=\"#下载-next-主题并添加-mathjax\" class=\"headerlink\" title=\"下载 next 主题并添加 mathjax\"></a>下载 next 主题并添加 mathjax</h4><p>然后下载一个 <code>next</code> 主题：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>\n<p>然后修改 <code>_config.yml</code>，把：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">theme: landscape</span><br></pre></td></tr></table></figure>\n<p>变成：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">theme: next</span><br></pre></td></tr></table></figure>\n<p>然后修改 <code>next</code> 的 <code>_config.yml</code>，把：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mathjax:</span><br><span class=\"line\">  enable: false</span><br><span class=\"line\">  per_page: false</span><br><span class=\"line\">  cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config#TeX-AMS-MML_HTMLorMML</span><br></pre></td></tr></table></figure>\n<p>变成：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mathjax:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  per_page: false</span><br><span class=\"line\">  cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config#TeX-AMS-MML_HTMLorMML</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意<code>per_page</code>不能是true，一定要是false。</p>\n</blockquote>\n<h4 id=\"解决-markdown-与-mathjax-的冲突\"><a href=\"#解决-markdown-与-mathjax-的冲突\" class=\"headerlink\" title=\"解决 markdown 与 mathjax 的冲突\"></a>解决 markdown 与 mathjax 的冲突</h4><p>为了解决 <code>markdown</code> 下划线转义成 <code>&lt;em&gt;</code> 标签（HTML标签），从而导致 <code>mathjax</code> 的下标无法使用，这个问题，我们修改 <code>marked.js</code> 文件，如果你使用的是 <code>sublime text</code> 或者 <code>Atom</code> 编辑器，<code>cmd+o</code>打开你的博客目录，然后 <code>cmd+p</code> 输入你要在此目录下找的文件名：<code>marked.js</code> 就可以找到这个文件。这个文件的是：<code>node_modules/marked/lib/marked.js</code>。把文件中的：</p>\n<p>总共发现 mathjax 中的三处冲突：</p>\n<ol>\n<li><code>_</code>变成了<code>&lt;em&gt;</code></li>\n<li><code>\\\\</code>变成了单个<code>\\</code></li>\n<li><code>&lt; xxx &gt;</code>大于号小于号之间会新增一个 <code>#&quot;&quot;</code></li>\n</ol>\n<p>将</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">escape: /^\\\\([\\\\`*&#123;&#125;\\[\\]()# +\\-.!_&gt;])/,</span><br></pre></td></tr></table></figure>\n<p>改为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">escape: /^\\\\([`*&#123;&#125;\\[\\]()# +\\-.!_&gt;])/,</span><br></pre></td></tr></table></figure>\n<p>这样就去掉了，双斜杠转义。</p>\n<p>把</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">em: /^\\b_((?:[^_]|__)+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,</span><br></pre></td></tr></table></figure>\n<p>改为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">em:/^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,</span><br></pre></td></tr></table></figure>\n<p>这样就禁掉了 <code>_</code> 变 <code>&lt;em&gt;</code>（斜体标记）。</p>\n<p>最后，为了解决第三个冲突，我把 <code>&gt;</code> 写成了 HTML 实体形式：<code>&amp;gt;</code>，这样就无法组成一对尖括号了，终于不会冲突了。</p>\n<p>我为什么不装个 <code>hexo-renderer-pandoc</code> + <code>pandoc</code> ，说出来都是泪啊，装了啊，一执行就报错，google 了一圈，没有有用的解答，遂作罢。</p>\n<h4 id=\"解决语言不正确的问题\"><a href=\"#解决语言不正确的问题\" class=\"headerlink\" title=\"解决语言不正确的问题\"></a>解决语言不正确的问题</h4><p>我发现有些地方居然默认的是德语还是什么其他语言，反正不是英语，所以我们需要改：</p>\n<ul>\n<li>根目录下的 <code>_config.yml</code></li>\n<li>next 主题的 <code>_config.yml</code></li>\n</ul>\n<p>两个都改成：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">language: en</span><br></pre></td></tr></table></figure>\n<h4 id=\"生成-public-静态网站目录-和-部署到-github\"><a href=\"#生成-public-静态网站目录-和-部署到-github\" class=\"headerlink\" title=\"生成 public 静态网站目录 和 部署到 github\"></a>生成 public 静态网站目录 和 部署到 github</h4><p>生成静态网站目录：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g</span><br></pre></td></tr></table></figure>\n<p>下载 hexo-deployer-git 插件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n<p>再修改 <code>_config.yml</code>，把：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type:</span><br></pre></td></tr></table></figure>\n<p>变成：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: https://github.com/liuqinh2s/liuqinh2s.github.io</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n<p>然后，用命令 <code>hexo d</code> 部署就行了，不过首先你得有个 github 账号，然后还得有个叫 <code>liuqinh2s.github.io</code> 的项目，然后你还得配置好 github 环境：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global user.name &quot;Your Name Here&quot;</span><br><span class=\"line\">git config --global user.email &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure>\n<p>然后把公钥的内容传给 github 就行了。这里只说原理，具体的操作懒得贴了。</p>\n<blockquote>\n<p>只有多懂原理（哪怕只是基本的原理），你才能顺利解决遇到的诸多问题。</p>\n</blockquote>\n<p>官网的部署教程：<a href=\"https://hexo.io/zh-cn/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">https://hexo.io/zh-cn/docs/deployment.html</a></p>\n<p>基本的建站就结束了，然后就是慢慢把博客进行个性化吧。</p>\n<h3 id=\"hexo-个性化配置\"><a href=\"#hexo-个性化配置\" class=\"headerlink\" title=\"hexo 个性化配置\"></a>hexo 个性化配置</h3><ul>\n<li>hexo-reference，用来支持 markdown 脚注的</li>\n<li>hexo-generator-seo-friendly-sitemap，sitemap用来喂给搜索引擎的，更好的爬取网站</li>\n<li>hexo-generator-search，博客内部搜索</li>\n<li>hexo-wordcount，统计字数用的</li>\n</ul>\n<p>然后就是调 next 主题，把自己喜欢的特性用上。</p>\n<p>然后就是加上 <code>不蒜子</code>，百度统计这类统计工具，和 disqus 评论等等。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"为什么搭建个人博客\"><a href=\"#为什么搭建个人博客\" class=\"headerlink\" title=\"为什么搭建个人博客\"></a>为什么搭建个人博客</h2><p>其实有想过用简书写博客，但简书不支持 <code>mathjax</code>，而我写作的时候要用到不少数学公式。</p>\n<p>以前也用过 leanote，也就是现在的 蚂蚁笔记，但蚂蚁笔记的博客中，[TOC] 是有 mathjax 渲染的，但右上角的目录导航却是没有加 mathjax 渲染的，这样看着会相当别扭。另外还有几个原因：</p>\n<ol>\n<li>leanote收费</li>\n<li>无法彻底的自定义</li>\n<li>博客不像使用静态网站引擎那样直观的以文件的形式展示在我面前</li>\n</ol>\n<h2 id=\"为什么选-hexo\"><a href=\"#为什么选-hexo\" class=\"headerlink\" title=\"为什么选 hexo\"></a>为什么选 hexo</h2><p>为什么选择 <code>hexo</code>，而不是 <code>jekyll</code>，或者 <code>hugo</code>。</p>\n<p>其实我以前的博客是用的 jekyll，弃用 jekyll 是因为这东西实在是太慢了，我更新文章之后无法立即看到结果，要刷新很多次，或者说要等很久，git pages 上才会显示新的东西。听说 hexo 和 hugo 的速度都比较快，所以就换了 hexo，hexo 的主题比 hugo 多，另外 hugo 的官网和主题网站访问实在太慢了，成功恶心到了我。所以我最后选了 hexo，用上了经典主题 next。现在来说，主要是next主题吸引我，而hugo的next主题太简陋了。</p>\n<blockquote>\n<p>hexo 是用 nodejs 写的，jekyll 是用 ruby 写的，hugo 是用 go 语言写的，wordpress 是用 php 实现的。</p>\n</blockquote>\n<p>那为什么不用 wordpress 呢，因为我想用 git pages 这个平台，而这个平台只支持静态博客。</p>\n<h2 id=\"搭建过程\"><a href=\"#搭建过程\" class=\"headerlink\" title=\"搭建过程\"></a>搭建过程</h2><h3 id=\"环境配置\"><a href=\"#环境配置\" class=\"headerlink\" title=\"环境配置\"></a>环境配置</h3><p>首先你要安装 <code>git</code> 和 <code>npm</code>，git 是一种版本控制工具，npm 则是 nodejs 的包管理工具。</p>\n<p>mac 上，使用 brew 和 brew cask 可以像许多 Linux 系统一样直接通过命令行安装软件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install git</span><br><span class=\"line\">brew install node</span><br></pre></td></tr></table></figure>\n<p>另外很不幸的是 git 和 npm 在国内都是无法愉快的使用的，虽然没有被墙，但是速度奇慢无比。于是我们需要做些工作：</p>\n<p>给 git 挂代理：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global http.proxy https://127.0.0.1:1087</span><br><span class=\"line\">git config --global https.proxy https://127.0.0.1:1087</span><br></pre></td></tr></table></figure>\n<p>但为了实现上面的功能，首先你得有个翻墙代理。关于翻墙都可以额外写篇文章了。</p>\n<p>想看详细的解决办法：</p>\n<ul>\n<li><a href=\"https://www.zhihu.com/question/27159393\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/27159393</a></li>\n<li><a href=\"https://www.zhihu.com/question/27159393/answer/141047266\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/27159393/answer/141047266</a></li>\n</ul>\n<p>然后给 npm 换源：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config set registry https://registry.npm.taobao.org</span><br><span class=\"line\">npm info underscore （这个只是为了检验上面的设置命令是否成功，若成功，会返回[指定包]的信息）</span><br></pre></td></tr></table></figure>\n<p>想看更详细的解决办法：</p>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000007829080\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000007829080</a></li>\n</ul>\n<p>好了，之后就是</p>\n<ul>\n<li>hexo 安装</li>\n<li>初始化 blog 目录</li>\n<li>然后 hexo server 开启本地服务器，一个 demo 就出现啦。</li>\n</ul>\n<p>命令如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-cli -g</span><br><span class=\"line\">hexo init blog</span><br><span class=\"line\">hexo server</span><br></pre></td></tr></table></figure>\n<h3 id=\"基本的建站过程\"><a href=\"#基本的建站过程\" class=\"headerlink\" title=\"基本的建站过程\"></a>基本的建站过程</h3><h4 id=\"从-jekyll-迁移到-hexo\"><a href=\"#从-jekyll-迁移到-hexo\" class=\"headerlink\" title=\"从 jekyll 迁移到 hexo\"></a>从 jekyll 迁移到 hexo</h4><p>我是从 jekyll 迁移过来的，所以先把文章全都拷贝进 <code>source/_posts</code> 目录下面，然后修改 <code>_config.yml</code>，把：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new_post_name: :title.md</span><br></pre></td></tr></table></figure>\n<p>变成：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new_post_name: :year-:month-:day-:title.md</span><br></pre></td></tr></table></figure>\n<p>官网迁移教程：<a href=\"https://hexo.io/zh-cn/docs/migration.html\" target=\"_blank\" rel=\"noopener\">https://hexo.io/zh-cn/docs/migration.html</a></p>\n<h4 id=\"下载-next-主题并添加-mathjax\"><a href=\"#下载-next-主题并添加-mathjax\" class=\"headerlink\" title=\"下载 next 主题并添加 mathjax\"></a>下载 next 主题并添加 mathjax</h4><p>然后下载一个 <code>next</code> 主题：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>\n<p>然后修改 <code>_config.yml</code>，把：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">theme: landscape</span><br></pre></td></tr></table></figure>\n<p>变成：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">theme: next</span><br></pre></td></tr></table></figure>\n<p>然后修改 <code>next</code> 的 <code>_config.yml</code>，把：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mathjax:</span><br><span class=\"line\">  enable: false</span><br><span class=\"line\">  per_page: false</span><br><span class=\"line\">  cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config#TeX-AMS-MML_HTMLorMML</span><br></pre></td></tr></table></figure>\n<p>变成：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mathjax:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  per_page: false</span><br><span class=\"line\">  cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config#TeX-AMS-MML_HTMLorMML</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注意<code>per_page</code>不能是true，一定要是false。</p>\n</blockquote>\n<h4 id=\"解决-markdown-与-mathjax-的冲突\"><a href=\"#解决-markdown-与-mathjax-的冲突\" class=\"headerlink\" title=\"解决 markdown 与 mathjax 的冲突\"></a>解决 markdown 与 mathjax 的冲突</h4><p>为了解决 <code>markdown</code> 下划线转义成 <code>&lt;em&gt;</code> 标签（HTML标签），从而导致 <code>mathjax</code> 的下标无法使用，这个问题，我们修改 <code>marked.js</code> 文件，如果你使用的是 <code>sublime text</code> 或者 <code>Atom</code> 编辑器，<code>cmd+o</code>打开你的博客目录，然后 <code>cmd+p</code> 输入你要在此目录下找的文件名：<code>marked.js</code> 就可以找到这个文件。这个文件的是：<code>node_modules/marked/lib/marked.js</code>。把文件中的：</p>\n<p>总共发现 mathjax 中的三处冲突：</p>\n<ol>\n<li><code>_</code>变成了<code>&lt;em&gt;</code></li>\n<li><code>\\\\</code>变成了单个<code>\\</code></li>\n<li><code>&lt; xxx &gt;</code>大于号小于号之间会新增一个 <code>#&quot;&quot;</code></li>\n</ol>\n<p>将</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">escape: /^\\\\([\\\\`*&#123;&#125;\\[\\]()# +\\-.!_&gt;])/,</span><br></pre></td></tr></table></figure>\n<p>改为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">escape: /^\\\\([`*&#123;&#125;\\[\\]()# +\\-.!_&gt;])/,</span><br></pre></td></tr></table></figure>\n<p>这样就去掉了，双斜杠转义。</p>\n<p>把</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">em: /^\\b_((?:[^_]|__)+?)_\\b|^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,</span><br></pre></td></tr></table></figure>\n<p>改为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">em:/^\\*((?:\\*\\*|[\\s\\S])+?)\\*(?!\\*)/,</span><br></pre></td></tr></table></figure>\n<p>这样就禁掉了 <code>_</code> 变 <code>&lt;em&gt;</code>（斜体标记）。</p>\n<p>最后，为了解决第三个冲突，我把 <code>&gt;</code> 写成了 HTML 实体形式：<code>&amp;gt;</code>，这样就无法组成一对尖括号了，终于不会冲突了。</p>\n<p>我为什么不装个 <code>hexo-renderer-pandoc</code> + <code>pandoc</code> ，说出来都是泪啊，装了啊，一执行就报错，google 了一圈，没有有用的解答，遂作罢。</p>\n<h4 id=\"解决语言不正确的问题\"><a href=\"#解决语言不正确的问题\" class=\"headerlink\" title=\"解决语言不正确的问题\"></a>解决语言不正确的问题</h4><p>我发现有些地方居然默认的是德语还是什么其他语言，反正不是英语，所以我们需要改：</p>\n<ul>\n<li>根目录下的 <code>_config.yml</code></li>\n<li>next 主题的 <code>_config.yml</code></li>\n</ul>\n<p>两个都改成：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">language: en</span><br></pre></td></tr></table></figure>\n<h4 id=\"生成-public-静态网站目录-和-部署到-github\"><a href=\"#生成-public-静态网站目录-和-部署到-github\" class=\"headerlink\" title=\"生成 public 静态网站目录 和 部署到 github\"></a>生成 public 静态网站目录 和 部署到 github</h4><p>生成静态网站目录：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g</span><br></pre></td></tr></table></figure>\n<p>下载 hexo-deployer-git 插件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n<p>再修改 <code>_config.yml</code>，把：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type:</span><br></pre></td></tr></table></figure>\n<p>变成：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: https://github.com/liuqinh2s/liuqinh2s.github.io</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n<p>然后，用命令 <code>hexo d</code> 部署就行了，不过首先你得有个 github 账号，然后还得有个叫 <code>liuqinh2s.github.io</code> 的项目，然后你还得配置好 github 环境：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global user.name &quot;Your Name Here&quot;</span><br><span class=\"line\">git config --global user.email &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure>\n<p>然后把公钥的内容传给 github 就行了。这里只说原理，具体的操作懒得贴了。</p>\n<blockquote>\n<p>只有多懂原理（哪怕只是基本的原理），你才能顺利解决遇到的诸多问题。</p>\n</blockquote>\n<p>官网的部署教程：<a href=\"https://hexo.io/zh-cn/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">https://hexo.io/zh-cn/docs/deployment.html</a></p>\n<p>基本的建站就结束了，然后就是慢慢把博客进行个性化吧。</p>\n<h3 id=\"hexo-个性化配置\"><a href=\"#hexo-个性化配置\" class=\"headerlink\" title=\"hexo 个性化配置\"></a>hexo 个性化配置</h3><ul>\n<li>hexo-reference，用来支持 markdown 脚注的</li>\n<li>hexo-generator-seo-friendly-sitemap，sitemap用来喂给搜索引擎的，更好的爬取网站</li>\n<li>hexo-generator-search，博客内部搜索</li>\n<li>hexo-wordcount，统计字数用的</li>\n</ul>\n<p>然后就是调 next 主题，把自己喜欢的特性用上。</p>\n<p>然后就是加上 <code>不蒜子</code>，百度统计这类统计工具，和 disqus 评论等等。</p>\n"},{"title":"数学基础公式推导","date":"2018-04-24T16:00:00.000Z","comments":1,"_content":"\n今天看到下面这个公式，突然想我好像不会推导啊：\n\n$\\sin(\\beta-\\alpha) = \\sin\\beta\\cos\\alpha - \\cos\\beta\\sin\\alpha$\n\n遂想如何推导，在youtube上找了一个视频：[三角函数正余弦和角公式推导](https://www.youtube.com/watch?v=uX6hxwW5BYM)\n\n思路是先推导出：$\\cos(\\beta-\\alpha) = \\cos\\alpha\\cos\\beta + \\sin\\alpha\\sin\\beta$\n\n>然后根据这个再结合正弦余弦之间的关系就很容易推 $\\sin(\\beta-\\alpha) = \\sin\\beta\\cos\\alpha - \\cos\\beta\\sin\\alpha$\n\n那么怎么推导上面这个公式呢？\n\n需要用到解析几何：\n\n![Screen Shot 2018-04-27 at 11.42.48 AM.png](https://i.loli.net/2018/04/27/5ae29c4bf121f.png)\n\n结合 `勾股定理` 和 `余弦定理` 可以推导出。\n\n根据勾股定理：\n\n$$\n\\begin{align}\n\\overline{PQ}^2\n& = (\\sin\\alpha - \\sin\\beta)^2 + (\\cos\\beta - \\cos\\alpha)^2 \\\\\n& = 2 - 2(\\cos\\alpha\\cos\\beta + \\sin\\alpha\\sin\\beta) \\\\\n\\end{align}\n$$\n\n根据余弦定理（$a^2 = b^2 + c^2 -2ab\\cos A$）：\n\n$$\n\\begin{align}\n\\overline{PQ}^2\n& = 1^2 + 1^2 - 2\\cdot1\\cdot1\\cdot\\cos(\\alpha-\\beta)\n\\end{align}\n$$\n\n由此推出：\n\n$$\n\\cos(\\alpha-\\beta) = \\sin\\alpha\\sin\\beta+\\cos\\alpha\\cos\\beta\n$$\n\n也即：\n\n$$\n\\cos(\\beta-\\alpha) = \\sin\\alpha\\sin\\beta+\\cos\\alpha\\cos\\beta\n$$\n\n然后：\n\n$$\n\\begin{align}\n\\sin(\\beta-\\alpha)\n&= \\cos(\\frac{\\pi}{2}-(\\beta-\\alpha)) \\\\\n&= \\cos((\\frac{\\pi}{2}+\\alpha) - \\beta) \\\\\n&= \\sin(\\frac{\\pi}{2}+\\alpha)\\sin\\beta + \\cos(\\frac{\\pi}{2}+\\alpha)\\cos\\beta \\\\\n&= \\cos\\alpha\\sin\\beta - \\sin\\alpha\\cos\\beta \\\\\n&= \\sin\\beta\\cos\\alpha - \\cos\\beta\\sin\\alpha\n\\end{align}\n$$\n\n>勾股定理和余弦定理的证明比较简单，读者可以试着自证。\n","source":"_posts/2018/2018-04-25-数学基础公式推导.md","raw":"---\ntitle: 数学基础公式推导\ndate: 2018-04-25\ncategories: [数学]\ncomments: true\n---\n\n今天看到下面这个公式，突然想我好像不会推导啊：\n\n$\\sin(\\beta-\\alpha) = \\sin\\beta\\cos\\alpha - \\cos\\beta\\sin\\alpha$\n\n遂想如何推导，在youtube上找了一个视频：[三角函数正余弦和角公式推导](https://www.youtube.com/watch?v=uX6hxwW5BYM)\n\n思路是先推导出：$\\cos(\\beta-\\alpha) = \\cos\\alpha\\cos\\beta + \\sin\\alpha\\sin\\beta$\n\n>然后根据这个再结合正弦余弦之间的关系就很容易推 $\\sin(\\beta-\\alpha) = \\sin\\beta\\cos\\alpha - \\cos\\beta\\sin\\alpha$\n\n那么怎么推导上面这个公式呢？\n\n需要用到解析几何：\n\n![Screen Shot 2018-04-27 at 11.42.48 AM.png](https://i.loli.net/2018/04/27/5ae29c4bf121f.png)\n\n结合 `勾股定理` 和 `余弦定理` 可以推导出。\n\n根据勾股定理：\n\n$$\n\\begin{align}\n\\overline{PQ}^2\n& = (\\sin\\alpha - \\sin\\beta)^2 + (\\cos\\beta - \\cos\\alpha)^2 \\\\\n& = 2 - 2(\\cos\\alpha\\cos\\beta + \\sin\\alpha\\sin\\beta) \\\\\n\\end{align}\n$$\n\n根据余弦定理（$a^2 = b^2 + c^2 -2ab\\cos A$）：\n\n$$\n\\begin{align}\n\\overline{PQ}^2\n& = 1^2 + 1^2 - 2\\cdot1\\cdot1\\cdot\\cos(\\alpha-\\beta)\n\\end{align}\n$$\n\n由此推出：\n\n$$\n\\cos(\\alpha-\\beta) = \\sin\\alpha\\sin\\beta+\\cos\\alpha\\cos\\beta\n$$\n\n也即：\n\n$$\n\\cos(\\beta-\\alpha) = \\sin\\alpha\\sin\\beta+\\cos\\alpha\\cos\\beta\n$$\n\n然后：\n\n$$\n\\begin{align}\n\\sin(\\beta-\\alpha)\n&= \\cos(\\frac{\\pi}{2}-(\\beta-\\alpha)) \\\\\n&= \\cos((\\frac{\\pi}{2}+\\alpha) - \\beta) \\\\\n&= \\sin(\\frac{\\pi}{2}+\\alpha)\\sin\\beta + \\cos(\\frac{\\pi}{2}+\\alpha)\\cos\\beta \\\\\n&= \\cos\\alpha\\sin\\beta - \\sin\\alpha\\cos\\beta \\\\\n&= \\sin\\beta\\cos\\alpha - \\cos\\beta\\sin\\alpha\n\\end{align}\n$$\n\n>勾股定理和余弦定理的证明比较简单，读者可以试着自证。\n","slug":"数学基础公式推导","published":1,"updated":"2018-04-27T04:00:26.760Z","layout":"post","photos":[],"link":"","_id":"cjm2w8ddi002hfgpxzbobsus1","content":"<p>今天看到下面这个公式，突然想我好像不会推导啊：</p>\n<p>$\\sin(\\beta-\\alpha) = \\sin\\beta\\cos\\alpha - \\cos\\beta\\sin\\alpha$</p>\n<p>遂想如何推导，在youtube上找了一个视频：<a href=\"https://www.youtube.com/watch?v=uX6hxwW5BYM\" target=\"_blank\" rel=\"noopener\">三角函数正余弦和角公式推导</a></p>\n<p>思路是先推导出：$\\cos(\\beta-\\alpha) = \\cos\\alpha\\cos\\beta + \\sin\\alpha\\sin\\beta$</p>\n<blockquote>\n<p>然后根据这个再结合正弦余弦之间的关系就很容易推 $\\sin(\\beta-\\alpha) = \\sin\\beta\\cos\\alpha - \\cos\\beta\\sin\\alpha$</p>\n</blockquote>\n<p>那么怎么推导上面这个公式呢？</p>\n<p>需要用到解析几何：</p>\n<p><img src=\"https://i.loli.net/2018/04/27/5ae29c4bf121f.png\" alt=\"Screen Shot 2018-04-27 at 11.42.48 AM.png\"></p>\n<p>结合 <code>勾股定理</code> 和 <code>余弦定理</code> 可以推导出。</p>\n<p>根据勾股定理：</p>\n<p>$$<br>\\begin{align}<br>\\overline{PQ}^2<br>&amp; = (\\sin\\alpha - \\sin\\beta)^2 + (\\cos\\beta - \\cos\\alpha)^2 \\\\<br>&amp; = 2 - 2(\\cos\\alpha\\cos\\beta + \\sin\\alpha\\sin\\beta) \\\\<br>\\end{align}<br>$$</p>\n<p>根据余弦定理（$a^2 = b^2 + c^2 -2ab\\cos A$）：</p>\n<p>$$<br>\\begin{align}<br>\\overline{PQ}^2<br>&amp; = 1^2 + 1^2 - 2\\cdot1\\cdot1\\cdot\\cos(\\alpha-\\beta)<br>\\end{align}<br>$$</p>\n<p>由此推出：</p>\n<p>$$<br>\\cos(\\alpha-\\beta) = \\sin\\alpha\\sin\\beta+\\cos\\alpha\\cos\\beta<br>$$</p>\n<p>也即：</p>\n<p>$$<br>\\cos(\\beta-\\alpha) = \\sin\\alpha\\sin\\beta+\\cos\\alpha\\cos\\beta<br>$$</p>\n<p>然后：</p>\n<p>$$<br>\\begin{align}<br>\\sin(\\beta-\\alpha)<br>&amp;= \\cos(\\frac{\\pi}{2}-(\\beta-\\alpha)) \\\\<br>&amp;= \\cos((\\frac{\\pi}{2}+\\alpha) - \\beta) \\\\<br>&amp;= \\sin(\\frac{\\pi}{2}+\\alpha)\\sin\\beta + \\cos(\\frac{\\pi}{2}+\\alpha)\\cos\\beta \\\\<br>&amp;= \\cos\\alpha\\sin\\beta - \\sin\\alpha\\cos\\beta \\\\<br>&amp;= \\sin\\beta\\cos\\alpha - \\cos\\beta\\sin\\alpha<br>\\end{align}<br>$$</p>\n<blockquote>\n<p>勾股定理和余弦定理的证明比较简单，读者可以试着自证。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>今天看到下面这个公式，突然想我好像不会推导啊：</p>\n<p>$\\sin(\\beta-\\alpha) = \\sin\\beta\\cos\\alpha - \\cos\\beta\\sin\\alpha$</p>\n<p>遂想如何推导，在youtube上找了一个视频：<a href=\"https://www.youtube.com/watch?v=uX6hxwW5BYM\" target=\"_blank\" rel=\"noopener\">三角函数正余弦和角公式推导</a></p>\n<p>思路是先推导出：$\\cos(\\beta-\\alpha) = \\cos\\alpha\\cos\\beta + \\sin\\alpha\\sin\\beta$</p>\n<blockquote>\n<p>然后根据这个再结合正弦余弦之间的关系就很容易推 $\\sin(\\beta-\\alpha) = \\sin\\beta\\cos\\alpha - \\cos\\beta\\sin\\alpha$</p>\n</blockquote>\n<p>那么怎么推导上面这个公式呢？</p>\n<p>需要用到解析几何：</p>\n<p><img src=\"https://i.loli.net/2018/04/27/5ae29c4bf121f.png\" alt=\"Screen Shot 2018-04-27 at 11.42.48 AM.png\"></p>\n<p>结合 <code>勾股定理</code> 和 <code>余弦定理</code> 可以推导出。</p>\n<p>根据勾股定理：</p>\n<p>$$<br>\\begin{align}<br>\\overline{PQ}^2<br>&amp; = (\\sin\\alpha - \\sin\\beta)^2 + (\\cos\\beta - \\cos\\alpha)^2 \\\\<br>&amp; = 2 - 2(\\cos\\alpha\\cos\\beta + \\sin\\alpha\\sin\\beta) \\\\<br>\\end{align}<br>$$</p>\n<p>根据余弦定理（$a^2 = b^2 + c^2 -2ab\\cos A$）：</p>\n<p>$$<br>\\begin{align}<br>\\overline{PQ}^2<br>&amp; = 1^2 + 1^2 - 2\\cdot1\\cdot1\\cdot\\cos(\\alpha-\\beta)<br>\\end{align}<br>$$</p>\n<p>由此推出：</p>\n<p>$$<br>\\cos(\\alpha-\\beta) = \\sin\\alpha\\sin\\beta+\\cos\\alpha\\cos\\beta<br>$$</p>\n<p>也即：</p>\n<p>$$<br>\\cos(\\beta-\\alpha) = \\sin\\alpha\\sin\\beta+\\cos\\alpha\\cos\\beta<br>$$</p>\n<p>然后：</p>\n<p>$$<br>\\begin{align}<br>\\sin(\\beta-\\alpha)<br>&amp;= \\cos(\\frac{\\pi}{2}-(\\beta-\\alpha)) \\\\<br>&amp;= \\cos((\\frac{\\pi}{2}+\\alpha) - \\beta) \\\\<br>&amp;= \\sin(\\frac{\\pi}{2}+\\alpha)\\sin\\beta + \\cos(\\frac{\\pi}{2}+\\alpha)\\cos\\beta \\\\<br>&amp;= \\cos\\alpha\\sin\\beta - \\sin\\alpha\\cos\\beta \\\\<br>&amp;= \\sin\\beta\\cos\\alpha - \\cos\\beta\\sin\\alpha<br>\\end{align}<br>$$</p>\n<blockquote>\n<p>勾股定理和余弦定理的证明比较简单，读者可以试着自证。</p>\n</blockquote>\n"},{"title":"UML图","date":"2018-04-27T16:00:00.000Z","comments":1,"_content":"\n## 从一个示例开始看懂UML图\n\n请看下面这个类图，类之间的关系是我们需要关注的：\n\n![](http://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_class_struct.jpg)\n\n- 车的类图结构为abstract，代表车是一个抽象类\n- 它有两个继承类：小汽车和自行车，它们之间的关系为实现关系，使用带空心箭头的虚线表示\n- 小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示\n- 小汽车与发动机之间是组合关系，使用带实心箭头的实线表示\n- 学生与班级之间是聚合关系，使用带空心箭头的实线表示\n- 学生与身份证之间为关联关系，使用一根实线表示\n- 学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示\n\n下面我们将介绍这六种关系：\n\n## 类之间的关系\n\n### 泛化关系（generalization）\n\n类的继承结构表现在UML中为：泛化（generalize）与实现（realize）：\n\n继承关系为 `is-a` 的关系，两个对象之间如果可以用 `is-a` 来表示，就是继承关系\n\neg: 自行车是车，猫是动物\n\n泛化关系用一条带空心箭头的直接表示，如下图表示（A继承自B）\n\n![](http://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_generalization.jpg)\n\neg：汽车在现实中有实现，可用汽车定义具体的对象；汽车与SUV之间为泛化关系；\n\n![](http://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_generalize.jpg)\n\n注：最终代码中，**泛化关系表现为继承非抽象类**；\n\n### 实现关系（realize）\n\n实现关系用一条带空心箭头的虚线表示；\n\neg: \"车\"为一个抽象的概念，在现实中并无法直接用来定义对象，只有指明具体的子类（汽车还是自行车），才可以用来定义对象（“车”这个类在C++中用抽象类表示，在Java中有接口这个概念，更容易理解）\n\n![](http://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_realize.jpg)\n\n注：最终代码中，**实现关系表现为继承抽象类**；\n\n### 聚合关系（aggregation）\n\n聚合关系用一条带空心菱形箭头的直线表示，如下图表示A聚合到B上，或者说B由A组成；\n\n![](http://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_aggregation.jpg)\n\n聚合关系用于表示实体对象之间的关系，表示整体由部分构成的语义；例如一个部门由多个员工组成；\n\n>与组合关系不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在；例如，部门撤销了，人员不会消失，他们依然存在；\n\n### 组合关系（composition）\n\n\n组合关系用一条带实心菱形箭头直线表示，如下图表示A组成B，或者B由A组成；\n\n![](http://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_composition.jpg)\n\n与聚合关系一样，组合关系同样表示整体由部分构成的语义；比如公司由多个部门组成；\n\n>但组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在了；例如， 公司不存在了，部门也将不存在了；\n\n### 关联关系（association）\n\n关联关系是用一条直线表示的。它描述不同类的对象之间的结构关系，它是一种静态关系，通常与运行状态无关，一般由常识等因素决定的，它一般用来定义对象之间静态的、天然的结构，所以，关联关系是一种“强关联的关系”。\n\n比如，乘车人和车票之间是一种关联关系；学生和学校是一种关联关系。\n\n关联关系默认不强调方向，表示对象间相互知道，如果特别强调方向，如下图，表示A知道B，但B不知道A。\n\n![](http://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_association.jpg)\n\n注：在最终代码中，**关联对象通常是以成员变量的形式实现的**；\n\n### 依赖关系（dependency）\n\n依赖关系是用一套带箭头的虚线表示的，如下图表示A依赖B，他描述一个对象在运行期间会用到另一个对象的关系：\n\n![](http://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_dependency.jpg)\n\n与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化，依赖关系也可能发生变化\n\n显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生。\n\n注：在最终代码中，**依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系，依赖关系除了临时知道对方外，还“使用”对方的方法和属性**。\n\n\n","source":"_posts/2018/2018-04-28-UML图.md","raw":"---\ntitle: UML图\ndate: 2018-04-28\ncategories: [编程范式, 面向对象编程]\ncomments: true\n---\n\n## 从一个示例开始看懂UML图\n\n请看下面这个类图，类之间的关系是我们需要关注的：\n\n![](http://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_class_struct.jpg)\n\n- 车的类图结构为abstract，代表车是一个抽象类\n- 它有两个继承类：小汽车和自行车，它们之间的关系为实现关系，使用带空心箭头的虚线表示\n- 小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示\n- 小汽车与发动机之间是组合关系，使用带实心箭头的实线表示\n- 学生与班级之间是聚合关系，使用带空心箭头的实线表示\n- 学生与身份证之间为关联关系，使用一根实线表示\n- 学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示\n\n下面我们将介绍这六种关系：\n\n## 类之间的关系\n\n### 泛化关系（generalization）\n\n类的继承结构表现在UML中为：泛化（generalize）与实现（realize）：\n\n继承关系为 `is-a` 的关系，两个对象之间如果可以用 `is-a` 来表示，就是继承关系\n\neg: 自行车是车，猫是动物\n\n泛化关系用一条带空心箭头的直接表示，如下图表示（A继承自B）\n\n![](http://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_generalization.jpg)\n\neg：汽车在现实中有实现，可用汽车定义具体的对象；汽车与SUV之间为泛化关系；\n\n![](http://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_generalize.jpg)\n\n注：最终代码中，**泛化关系表现为继承非抽象类**；\n\n### 实现关系（realize）\n\n实现关系用一条带空心箭头的虚线表示；\n\neg: \"车\"为一个抽象的概念，在现实中并无法直接用来定义对象，只有指明具体的子类（汽车还是自行车），才可以用来定义对象（“车”这个类在C++中用抽象类表示，在Java中有接口这个概念，更容易理解）\n\n![](http://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_realize.jpg)\n\n注：最终代码中，**实现关系表现为继承抽象类**；\n\n### 聚合关系（aggregation）\n\n聚合关系用一条带空心菱形箭头的直线表示，如下图表示A聚合到B上，或者说B由A组成；\n\n![](http://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_aggregation.jpg)\n\n聚合关系用于表示实体对象之间的关系，表示整体由部分构成的语义；例如一个部门由多个员工组成；\n\n>与组合关系不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在；例如，部门撤销了，人员不会消失，他们依然存在；\n\n### 组合关系（composition）\n\n\n组合关系用一条带实心菱形箭头直线表示，如下图表示A组成B，或者B由A组成；\n\n![](http://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_composition.jpg)\n\n与聚合关系一样，组合关系同样表示整体由部分构成的语义；比如公司由多个部门组成；\n\n>但组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在了；例如， 公司不存在了，部门也将不存在了；\n\n### 关联关系（association）\n\n关联关系是用一条直线表示的。它描述不同类的对象之间的结构关系，它是一种静态关系，通常与运行状态无关，一般由常识等因素决定的，它一般用来定义对象之间静态的、天然的结构，所以，关联关系是一种“强关联的关系”。\n\n比如，乘车人和车票之间是一种关联关系；学生和学校是一种关联关系。\n\n关联关系默认不强调方向，表示对象间相互知道，如果特别强调方向，如下图，表示A知道B，但B不知道A。\n\n![](http://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_association.jpg)\n\n注：在最终代码中，**关联对象通常是以成员变量的形式实现的**；\n\n### 依赖关系（dependency）\n\n依赖关系是用一套带箭头的虚线表示的，如下图表示A依赖B，他描述一个对象在运行期间会用到另一个对象的关系：\n\n![](http://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_dependency.jpg)\n\n与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化，依赖关系也可能发生变化\n\n显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生。\n\n注：在最终代码中，**依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系，依赖关系除了临时知道对方外，还“使用”对方的方法和属性**。\n\n\n","slug":"UML图","published":1,"updated":"2018-08-07T11:59:06.704Z","layout":"post","photos":[],"link":"","_id":"cjm2w8ddj002ifgpxqjv10lys","content":"<h2 id=\"从一个示例开始看懂UML图\"><a href=\"#从一个示例开始看懂UML图\" class=\"headerlink\" title=\"从一个示例开始看懂UML图\"></a>从一个示例开始看懂UML图</h2><p>请看下面这个类图，类之间的关系是我们需要关注的：</p>\n<p><img src=\"http://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_class_struct.jpg\" alt=\"\"></p>\n<ul>\n<li>车的类图结构为abstract，代表车是一个抽象类</li>\n<li>它有两个继承类：小汽车和自行车，它们之间的关系为实现关系，使用带空心箭头的虚线表示</li>\n<li>小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示</li>\n<li>小汽车与发动机之间是组合关系，使用带实心箭头的实线表示</li>\n<li>学生与班级之间是聚合关系，使用带空心箭头的实线表示</li>\n<li>学生与身份证之间为关联关系，使用一根实线表示</li>\n<li>学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示</li>\n</ul>\n<p>下面我们将介绍这六种关系：</p>\n<h2 id=\"类之间的关系\"><a href=\"#类之间的关系\" class=\"headerlink\" title=\"类之间的关系\"></a>类之间的关系</h2><h3 id=\"泛化关系（generalization）\"><a href=\"#泛化关系（generalization）\" class=\"headerlink\" title=\"泛化关系（generalization）\"></a>泛化关系（generalization）</h3><p>类的继承结构表现在UML中为：泛化（generalize）与实现（realize）：</p>\n<p>继承关系为 <code>is-a</code> 的关系，两个对象之间如果可以用 <code>is-a</code> 来表示，就是继承关系</p>\n<p>eg: 自行车是车，猫是动物</p>\n<p>泛化关系用一条带空心箭头的直接表示，如下图表示（A继承自B）</p>\n<p><img src=\"http://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_generalization.jpg\" alt=\"\"></p>\n<p>eg：汽车在现实中有实现，可用汽车定义具体的对象；汽车与SUV之间为泛化关系；</p>\n<p><img src=\"http://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_generalize.jpg\" alt=\"\"></p>\n<p>注：最终代码中，<strong>泛化关系表现为继承非抽象类</strong>；</p>\n<h3 id=\"实现关系（realize）\"><a href=\"#实现关系（realize）\" class=\"headerlink\" title=\"实现关系（realize）\"></a>实现关系（realize）</h3><p>实现关系用一条带空心箭头的虚线表示；</p>\n<p>eg: “车”为一个抽象的概念，在现实中并无法直接用来定义对象，只有指明具体的子类（汽车还是自行车），才可以用来定义对象（“车”这个类在C++中用抽象类表示，在Java中有接口这个概念，更容易理解）</p>\n<p><img src=\"http://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_realize.jpg\" alt=\"\"></p>\n<p>注：最终代码中，<strong>实现关系表现为继承抽象类</strong>；</p>\n<h3 id=\"聚合关系（aggregation）\"><a href=\"#聚合关系（aggregation）\" class=\"headerlink\" title=\"聚合关系（aggregation）\"></a>聚合关系（aggregation）</h3><p>聚合关系用一条带空心菱形箭头的直线表示，如下图表示A聚合到B上，或者说B由A组成；</p>\n<p><img src=\"http://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_aggregation.jpg\" alt=\"\"></p>\n<p>聚合关系用于表示实体对象之间的关系，表示整体由部分构成的语义；例如一个部门由多个员工组成；</p>\n<blockquote>\n<p>与组合关系不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在；例如，部门撤销了，人员不会消失，他们依然存在；</p>\n</blockquote>\n<h3 id=\"组合关系（composition）\"><a href=\"#组合关系（composition）\" class=\"headerlink\" title=\"组合关系（composition）\"></a>组合关系（composition）</h3><p>组合关系用一条带实心菱形箭头直线表示，如下图表示A组成B，或者B由A组成；</p>\n<p><img src=\"http://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_composition.jpg\" alt=\"\"></p>\n<p>与聚合关系一样，组合关系同样表示整体由部分构成的语义；比如公司由多个部门组成；</p>\n<blockquote>\n<p>但组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在了；例如， 公司不存在了，部门也将不存在了；</p>\n</blockquote>\n<h3 id=\"关联关系（association）\"><a href=\"#关联关系（association）\" class=\"headerlink\" title=\"关联关系（association）\"></a>关联关系（association）</h3><p>关联关系是用一条直线表示的。它描述不同类的对象之间的结构关系，它是一种静态关系，通常与运行状态无关，一般由常识等因素决定的，它一般用来定义对象之间静态的、天然的结构，所以，关联关系是一种“强关联的关系”。</p>\n<p>比如，乘车人和车票之间是一种关联关系；学生和学校是一种关联关系。</p>\n<p>关联关系默认不强调方向，表示对象间相互知道，如果特别强调方向，如下图，表示A知道B，但B不知道A。</p>\n<p><img src=\"http://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_association.jpg\" alt=\"\"></p>\n<p>注：在最终代码中，<strong>关联对象通常是以成员变量的形式实现的</strong>；</p>\n<h3 id=\"依赖关系（dependency）\"><a href=\"#依赖关系（dependency）\" class=\"headerlink\" title=\"依赖关系（dependency）\"></a>依赖关系（dependency）</h3><p>依赖关系是用一套带箭头的虚线表示的，如下图表示A依赖B，他描述一个对象在运行期间会用到另一个对象的关系：</p>\n<p><img src=\"http://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_dependency.jpg\" alt=\"\"></p>\n<p>与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化，依赖关系也可能发生变化</p>\n<p>显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生。</p>\n<p>注：在最终代码中，<strong>依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系，依赖关系除了临时知道对方外，还“使用”对方的方法和属性</strong>。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"从一个示例开始看懂UML图\"><a href=\"#从一个示例开始看懂UML图\" class=\"headerlink\" title=\"从一个示例开始看懂UML图\"></a>从一个示例开始看懂UML图</h2><p>请看下面这个类图，类之间的关系是我们需要关注的：</p>\n<p><img src=\"http://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_class_struct.jpg\" alt=\"\"></p>\n<ul>\n<li>车的类图结构为abstract，代表车是一个抽象类</li>\n<li>它有两个继承类：小汽车和自行车，它们之间的关系为实现关系，使用带空心箭头的虚线表示</li>\n<li>小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示</li>\n<li>小汽车与发动机之间是组合关系，使用带实心箭头的实线表示</li>\n<li>学生与班级之间是聚合关系，使用带空心箭头的实线表示</li>\n<li>学生与身份证之间为关联关系，使用一根实线表示</li>\n<li>学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示</li>\n</ul>\n<p>下面我们将介绍这六种关系：</p>\n<h2 id=\"类之间的关系\"><a href=\"#类之间的关系\" class=\"headerlink\" title=\"类之间的关系\"></a>类之间的关系</h2><h3 id=\"泛化关系（generalization）\"><a href=\"#泛化关系（generalization）\" class=\"headerlink\" title=\"泛化关系（generalization）\"></a>泛化关系（generalization）</h3><p>类的继承结构表现在UML中为：泛化（generalize）与实现（realize）：</p>\n<p>继承关系为 <code>is-a</code> 的关系，两个对象之间如果可以用 <code>is-a</code> 来表示，就是继承关系</p>\n<p>eg: 自行车是车，猫是动物</p>\n<p>泛化关系用一条带空心箭头的直接表示，如下图表示（A继承自B）</p>\n<p><img src=\"http://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_generalization.jpg\" alt=\"\"></p>\n<p>eg：汽车在现实中有实现，可用汽车定义具体的对象；汽车与SUV之间为泛化关系；</p>\n<p><img src=\"http://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_generalize.jpg\" alt=\"\"></p>\n<p>注：最终代码中，<strong>泛化关系表现为继承非抽象类</strong>；</p>\n<h3 id=\"实现关系（realize）\"><a href=\"#实现关系（realize）\" class=\"headerlink\" title=\"实现关系（realize）\"></a>实现关系（realize）</h3><p>实现关系用一条带空心箭头的虚线表示；</p>\n<p>eg: “车”为一个抽象的概念，在现实中并无法直接用来定义对象，只有指明具体的子类（汽车还是自行车），才可以用来定义对象（“车”这个类在C++中用抽象类表示，在Java中有接口这个概念，更容易理解）</p>\n<p><img src=\"http://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_realize.jpg\" alt=\"\"></p>\n<p>注：最终代码中，<strong>实现关系表现为继承抽象类</strong>；</p>\n<h3 id=\"聚合关系（aggregation）\"><a href=\"#聚合关系（aggregation）\" class=\"headerlink\" title=\"聚合关系（aggregation）\"></a>聚合关系（aggregation）</h3><p>聚合关系用一条带空心菱形箭头的直线表示，如下图表示A聚合到B上，或者说B由A组成；</p>\n<p><img src=\"http://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_aggregation.jpg\" alt=\"\"></p>\n<p>聚合关系用于表示实体对象之间的关系，表示整体由部分构成的语义；例如一个部门由多个员工组成；</p>\n<blockquote>\n<p>与组合关系不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在；例如，部门撤销了，人员不会消失，他们依然存在；</p>\n</blockquote>\n<h3 id=\"组合关系（composition）\"><a href=\"#组合关系（composition）\" class=\"headerlink\" title=\"组合关系（composition）\"></a>组合关系（composition）</h3><p>组合关系用一条带实心菱形箭头直线表示，如下图表示A组成B，或者B由A组成；</p>\n<p><img src=\"http://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_composition.jpg\" alt=\"\"></p>\n<p>与聚合关系一样，组合关系同样表示整体由部分构成的语义；比如公司由多个部门组成；</p>\n<blockquote>\n<p>但组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也不存在了；例如， 公司不存在了，部门也将不存在了；</p>\n</blockquote>\n<h3 id=\"关联关系（association）\"><a href=\"#关联关系（association）\" class=\"headerlink\" title=\"关联关系（association）\"></a>关联关系（association）</h3><p>关联关系是用一条直线表示的。它描述不同类的对象之间的结构关系，它是一种静态关系，通常与运行状态无关，一般由常识等因素决定的，它一般用来定义对象之间静态的、天然的结构，所以，关联关系是一种“强关联的关系”。</p>\n<p>比如，乘车人和车票之间是一种关联关系；学生和学校是一种关联关系。</p>\n<p>关联关系默认不强调方向，表示对象间相互知道，如果特别强调方向，如下图，表示A知道B，但B不知道A。</p>\n<p><img src=\"http://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_association.jpg\" alt=\"\"></p>\n<p>注：在最终代码中，<strong>关联对象通常是以成员变量的形式实现的</strong>；</p>\n<h3 id=\"依赖关系（dependency）\"><a href=\"#依赖关系（dependency）\" class=\"headerlink\" title=\"依赖关系（dependency）\"></a>依赖关系（dependency）</h3><p>依赖关系是用一套带箭头的虚线表示的，如下图表示A依赖B，他描述一个对象在运行期间会用到另一个对象的关系：</p>\n<p><img src=\"http://design-patterns.readthedocs.io/zh_CN/latest/_images/uml_dependency.jpg\" alt=\"\"></p>\n<p>与关联关系不同的是，它是一种临时性的关系，通常在运行期间产生，并且随着运行时的变化，依赖关系也可能发生变化</p>\n<p>显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生。</p>\n<p>注：在最终代码中，<strong>依赖关系体现为类构造方法及类方法的传入参数，箭头的指向为调用关系，依赖关系除了临时知道对方外，还“使用”对方的方法和属性</strong>。</p>\n"},{"title":"Leetcode Algorithm 274. H-Index","date":"2018-04-29T16:00:00.000Z","comments":1,"_content":"\nGiven an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index.\n\nAccording to the [definition of h-index on Wikipedia](https://en.wikipedia.org/wiki/H-index): \"A scientist has index h if h of his/her N papers have **at least** h citations each, and the other N − h papers have **no more than** h citations each.\"\n\nFor example, given `citations = [3, 0, 6, 1, 5]`, which means the researcher has `5` papers in total and each of them had received `3, 0, 6, 1, 5` citations respectively. Since the researcher has `3` papers with **at least** `3` citations each and the remaining two with **no more than** `3` citations each, his h-index is `3`.\n\n**Note:** If there are several possible values for `h`, the maximum one is taken as the h-index.\n\n**Credits:**\nSpecial thanks to @jianchao.li.fighter for adding this problem and creating all test cases.\n\n看了维基百科的解说之后，我发现这题还是挺简单的，思路就是排序，如果用C++解这题，我就直接用std::sort了。\n\nC++代码如下：\n\n```C++\nclass Solution {\npublic:\n    int hIndex(vector<int>& citations) {\n        if(citations.size()<=0){\n            return 0;\n        }\n        std::sort(citations.begin(), citations.end(), compare);\n        int result = citations[0];\n        for(int i=0;i<citations.size();i++){\n            if(i<citations[i]){\n                result = i+1;\n            }\n        }\n        return result;\n    }\n    \n    static bool compare(int i, int j){\n        return i>j;\n    }\n};\n```\n\n","source":"_posts/2018/2018-04-30-Leetcode-Algorithm-274.H-Index.md","raw":"---\ntitle: Leetcode Algorithm 274. H-Index\ndate: 2018-04-30\ncategories: [ACM, Leetcode]\ncomments: true\n---\n\nGiven an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index.\n\nAccording to the [definition of h-index on Wikipedia](https://en.wikipedia.org/wiki/H-index): \"A scientist has index h if h of his/her N papers have **at least** h citations each, and the other N − h papers have **no more than** h citations each.\"\n\nFor example, given `citations = [3, 0, 6, 1, 5]`, which means the researcher has `5` papers in total and each of them had received `3, 0, 6, 1, 5` citations respectively. Since the researcher has `3` papers with **at least** `3` citations each and the remaining two with **no more than** `3` citations each, his h-index is `3`.\n\n**Note:** If there are several possible values for `h`, the maximum one is taken as the h-index.\n\n**Credits:**\nSpecial thanks to @jianchao.li.fighter for adding this problem and creating all test cases.\n\n看了维基百科的解说之后，我发现这题还是挺简单的，思路就是排序，如果用C++解这题，我就直接用std::sort了。\n\nC++代码如下：\n\n```C++\nclass Solution {\npublic:\n    int hIndex(vector<int>& citations) {\n        if(citations.size()<=0){\n            return 0;\n        }\n        std::sort(citations.begin(), citations.end(), compare);\n        int result = citations[0];\n        for(int i=0;i<citations.size();i++){\n            if(i<citations[i]){\n                result = i+1;\n            }\n        }\n        return result;\n    }\n    \n    static bool compare(int i, int j){\n        return i>j;\n    }\n};\n```\n\n","slug":"Leetcode-Algorithm-274.H-Index","published":1,"updated":"2018-04-30T07:41:17.558Z","layout":"post","photos":[],"link":"","_id":"cjm2w8ddk002lfgpxhsekpx6t","content":"<p>Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher’s h-index.</p>\n<p>According to the <a href=\"https://en.wikipedia.org/wiki/H-index\" target=\"_blank\" rel=\"noopener\">definition of h-index on Wikipedia</a>: “A scientist has index h if h of his/her N papers have <strong>at least</strong> h citations each, and the other N − h papers have <strong>no more than</strong> h citations each.”</p>\n<p>For example, given <code>citations = [3, 0, 6, 1, 5]</code>, which means the researcher has <code>5</code> papers in total and each of them had received <code>3, 0, 6, 1, 5</code> citations respectively. Since the researcher has <code>3</code> papers with <strong>at least</strong> <code>3</code> citations each and the remaining two with <strong>no more than</strong> <code>3</code> citations each, his h-index is <code>3</code>.</p>\n<p><strong>Note:</strong> If there are several possible values for <code>h</code>, the maximum one is taken as the h-index.</p>\n<p><strong>Credits:</strong><br>Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.</p>\n<p>看了维基百科的解说之后，我发现这题还是挺简单的，思路就是排序，如果用C++解这题，我就直接用std::sort了。</p>\n<p>C++代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hIndex</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; citations)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(citations.size()&lt;=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::sort(citations.begin(), citations.end(), compare);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = citations[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;citations.size();i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i&lt;citations[i])&#123;</span><br><span class=\"line\">                result = i+<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">bool</span> <span class=\"title\">compare</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> i&gt;j;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher’s h-index.</p>\n<p>According to the <a href=\"https://en.wikipedia.org/wiki/H-index\" target=\"_blank\" rel=\"noopener\">definition of h-index on Wikipedia</a>: “A scientist has index h if h of his/her N papers have <strong>at least</strong> h citations each, and the other N − h papers have <strong>no more than</strong> h citations each.”</p>\n<p>For example, given <code>citations = [3, 0, 6, 1, 5]</code>, which means the researcher has <code>5</code> papers in total and each of them had received <code>3, 0, 6, 1, 5</code> citations respectively. Since the researcher has <code>3</code> papers with <strong>at least</strong> <code>3</code> citations each and the remaining two with <strong>no more than</strong> <code>3</code> citations each, his h-index is <code>3</code>.</p>\n<p><strong>Note:</strong> If there are several possible values for <code>h</code>, the maximum one is taken as the h-index.</p>\n<p><strong>Credits:</strong><br>Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.</p>\n<p>看了维基百科的解说之后，我发现这题还是挺简单的，思路就是排序，如果用C++解这题，我就直接用std::sort了。</p>\n<p>C++代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span> &#123;</span></span><br><span class=\"line\"><span class=\"keyword\">public</span>:</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hIndex</span><span class=\"params\">(<span class=\"built_in\">vector</span>&lt;<span class=\"keyword\">int</span>&gt;&amp; citations)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(citations.size()&lt;=<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">std</span>::sort(citations.begin(), citations.end(), compare);</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = citations[<span class=\"number\">0</span>];</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;citations.size();i++)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(i&lt;citations[i])&#123;</span><br><span class=\"line\">                result = i+<span class=\"number\">1</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">bool</span> <span class=\"title\">compare</span><span class=\"params\">(<span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> i&gt;j;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n"},{"title":"mathjax常用公式记录","date":"2018-04-29T16:00:00.000Z","comments":1,"_content":"\n## 角度记法\n\n- 度数：`$60^\\circ$`，$60^\\circ$\n- 度数分：`$60^\\prime$`，$60^\\prime$\n- 弧度：`$\\frac{\\pi}{2}$`，$\\frac{\\pi}{2}$\n- 角度记法：`$\\angle A$`，$\\angle A$\n","source":"_posts/2018/2018-04-30-mathjax常用公式记录.md","raw":"---\ntitle: mathjax常用公式记录\ndate: 2018-04-30\ncategories: [LaTex]\ncomments: true\n---\n\n## 角度记法\n\n- 度数：`$60^\\circ$`，$60^\\circ$\n- 度数分：`$60^\\prime$`，$60^\\prime$\n- 弧度：`$\\frac{\\pi}{2}$`，$\\frac{\\pi}{2}$\n- 角度记法：`$\\angle A$`，$\\angle A$\n","slug":"mathjax常用公式记录","published":1,"updated":"2018-04-30T06:57:18.698Z","layout":"post","photos":[],"link":"","_id":"cjm2w8ddl002nfgpx3y02tq61","content":"<h2 id=\"角度记法\"><a href=\"#角度记法\" class=\"headerlink\" title=\"角度记法\"></a>角度记法</h2><ul>\n<li>度数：<code>$60^\\circ$</code>，$60^\\circ$</li>\n<li>度数分：<code>$60^\\prime$</code>，$60^\\prime$</li>\n<li>弧度：<code>$\\frac{\\pi}{2}$</code>，$\\frac{\\pi}{2}$</li>\n<li>角度记法：<code>$\\angle A$</code>，$\\angle A$</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"角度记法\"><a href=\"#角度记法\" class=\"headerlink\" title=\"角度记法\"></a>角度记法</h2><ul>\n<li>度数：<code>$60^\\circ$</code>，$60^\\circ$</li>\n<li>度数分：<code>$60^\\prime$</code>，$60^\\prime$</li>\n<li>弧度：<code>$\\frac{\\pi}{2}$</code>，$\\frac{\\pi}{2}$</li>\n<li>角度记法：<code>$\\angle A$</code>，$\\angle A$</li>\n</ul>\n"},{"title":"椭圆规","date":"2018-04-29T16:00:00.000Z","comments":1,"_content":"\n## 利用简单定义的椭圆规\n\n椭圆大家高中的时候都学过，椭圆有两个中心，椭圆轨迹上的点到这两个中心的距离加起来就是长轴的长度。\n\n![利用简单定义的椭圆规](http://highscope.ch.ntu.edu.tw/wordpress/wp-content/uploads/2011/01/EasyCapture1105.bmp)\n\n## 利用参数式的椭圆规\n\n![利用参数式的椭圆规](http://highscope.ch.ntu.edu.tw/wordpress/wp-content/uploads/2011/01/EasyCapture1101.bmp)\n\n$\\overline{AP}=a$，$\\overline{BP}=b$，P点所绘制的就是椭圆了。画圆规时先固定十字底座，旋转时A点保持在纵轴滑动，B点保持在横轴滑动，当规臂完成$360^\\circ$时，P点的轨迹即为椭圆，且此椭圆的长半轴是 a，短半轴是 b。\n\n下面讲讲原理：\n\n![参数式椭圆规原理](http://highscope.ch.ntu.edu.tw/wordpress/wp-content/uploads/2011/01/EasyCapture1102.bmp)\n\n若以十字中心为原点，十字横向为x轴，纵向为y轴，设定一个直角坐标系，并设 $\\theta$ 为以x轴为始边，规臂$\\overline{AP}$为终边的广义角，不难看出来P点的坐标是 $(a\\cos\\theta, b\\sin\\theta)$，即方程式为：$\\frac{x^2}{a^2}+\\frac{y^2}{b^2}=1$ 的椭圆方程式。其中a为长半轴的长度，b为短半轴的长度。","source":"_posts/2018/2018-04-30-椭圆规.md","raw":"---\ntitle: 椭圆规\ndate: 2018-04-30\ncategories: [数学, 解析几何]\ncomments: true\n---\n\n## 利用简单定义的椭圆规\n\n椭圆大家高中的时候都学过，椭圆有两个中心，椭圆轨迹上的点到这两个中心的距离加起来就是长轴的长度。\n\n![利用简单定义的椭圆规](http://highscope.ch.ntu.edu.tw/wordpress/wp-content/uploads/2011/01/EasyCapture1105.bmp)\n\n## 利用参数式的椭圆规\n\n![利用参数式的椭圆规](http://highscope.ch.ntu.edu.tw/wordpress/wp-content/uploads/2011/01/EasyCapture1101.bmp)\n\n$\\overline{AP}=a$，$\\overline{BP}=b$，P点所绘制的就是椭圆了。画圆规时先固定十字底座，旋转时A点保持在纵轴滑动，B点保持在横轴滑动，当规臂完成$360^\\circ$时，P点的轨迹即为椭圆，且此椭圆的长半轴是 a，短半轴是 b。\n\n下面讲讲原理：\n\n![参数式椭圆规原理](http://highscope.ch.ntu.edu.tw/wordpress/wp-content/uploads/2011/01/EasyCapture1102.bmp)\n\n若以十字中心为原点，十字横向为x轴，纵向为y轴，设定一个直角坐标系，并设 $\\theta$ 为以x轴为始边，规臂$\\overline{AP}$为终边的广义角，不难看出来P点的坐标是 $(a\\cos\\theta, b\\sin\\theta)$，即方程式为：$\\frac{x^2}{a^2}+\\frac{y^2}{b^2}=1$ 的椭圆方程式。其中a为长半轴的长度，b为短半轴的长度。","slug":"椭圆规","published":1,"updated":"2018-04-30T06:51:08.635Z","layout":"post","photos":[],"link":"","_id":"cjm2w8ddm002qfgpx4mpelz8z","content":"<h2 id=\"利用简单定义的椭圆规\"><a href=\"#利用简单定义的椭圆规\" class=\"headerlink\" title=\"利用简单定义的椭圆规\"></a>利用简单定义的椭圆规</h2><p>椭圆大家高中的时候都学过，椭圆有两个中心，椭圆轨迹上的点到这两个中心的距离加起来就是长轴的长度。</p>\n<p><img src=\"http://highscope.ch.ntu.edu.tw/wordpress/wp-content/uploads/2011/01/EasyCapture1105.bmp\" alt=\"利用简单定义的椭圆规\"></p>\n<h2 id=\"利用参数式的椭圆规\"><a href=\"#利用参数式的椭圆规\" class=\"headerlink\" title=\"利用参数式的椭圆规\"></a>利用参数式的椭圆规</h2><p><img src=\"http://highscope.ch.ntu.edu.tw/wordpress/wp-content/uploads/2011/01/EasyCapture1101.bmp\" alt=\"利用参数式的椭圆规\"></p>\n<p>$\\overline{AP}=a$，$\\overline{BP}=b$，P点所绘制的就是椭圆了。画圆规时先固定十字底座，旋转时A点保持在纵轴滑动，B点保持在横轴滑动，当规臂完成$360^\\circ$时，P点的轨迹即为椭圆，且此椭圆的长半轴是 a，短半轴是 b。</p>\n<p>下面讲讲原理：</p>\n<p><img src=\"http://highscope.ch.ntu.edu.tw/wordpress/wp-content/uploads/2011/01/EasyCapture1102.bmp\" alt=\"参数式椭圆规原理\"></p>\n<p>若以十字中心为原点，十字横向为x轴，纵向为y轴，设定一个直角坐标系，并设 $\\theta$ 为以x轴为始边，规臂$\\overline{AP}$为终边的广义角，不难看出来P点的坐标是 $(a\\cos\\theta, b\\sin\\theta)$，即方程式为：$\\frac{x^2}{a^2}+\\frac{y^2}{b^2}=1$ 的椭圆方程式。其中a为长半轴的长度，b为短半轴的长度。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"利用简单定义的椭圆规\"><a href=\"#利用简单定义的椭圆规\" class=\"headerlink\" title=\"利用简单定义的椭圆规\"></a>利用简单定义的椭圆规</h2><p>椭圆大家高中的时候都学过，椭圆有两个中心，椭圆轨迹上的点到这两个中心的距离加起来就是长轴的长度。</p>\n<p><img src=\"http://highscope.ch.ntu.edu.tw/wordpress/wp-content/uploads/2011/01/EasyCapture1105.bmp\" alt=\"利用简单定义的椭圆规\"></p>\n<h2 id=\"利用参数式的椭圆规\"><a href=\"#利用参数式的椭圆规\" class=\"headerlink\" title=\"利用参数式的椭圆规\"></a>利用参数式的椭圆规</h2><p><img src=\"http://highscope.ch.ntu.edu.tw/wordpress/wp-content/uploads/2011/01/EasyCapture1101.bmp\" alt=\"利用参数式的椭圆规\"></p>\n<p>$\\overline{AP}=a$，$\\overline{BP}=b$，P点所绘制的就是椭圆了。画圆规时先固定十字底座，旋转时A点保持在纵轴滑动，B点保持在横轴滑动，当规臂完成$360^\\circ$时，P点的轨迹即为椭圆，且此椭圆的长半轴是 a，短半轴是 b。</p>\n<p>下面讲讲原理：</p>\n<p><img src=\"http://highscope.ch.ntu.edu.tw/wordpress/wp-content/uploads/2011/01/EasyCapture1102.bmp\" alt=\"参数式椭圆规原理\"></p>\n<p>若以十字中心为原点，十字横向为x轴，纵向为y轴，设定一个直角坐标系，并设 $\\theta$ 为以x轴为始边，规臂$\\overline{AP}$为终边的广义角，不难看出来P点的坐标是 $(a\\cos\\theta, b\\sin\\theta)$，即方程式为：$\\frac{x^2}{a^2}+\\frac{y^2}{b^2}=1$ 的椭圆方程式。其中a为长半轴的长度，b为短半轴的长度。</p>\n"},{"title":"Java Servlet 学习笔记","date":"2018-04-30T16:00:00.000Z","comments":1,"_content":"\n>The difference between servlets and JSP is that servlets typically embed HTML inside Java code, while JSPs embed Java code in HTML.\n\n不过现在都是用MVC框架了。\n\n## life cycle of a servlet\n\nThree methods are central to the life cycle of a servlet. These are `init()`, `service()`, and `destroy()`. They are implemented by every servlet and are invoked at specific times by the server.\n\n- the web container initializes the servlet instance by calling the init() method, passing an object implementing the `javax.servlet.ServletConfig` interface. This configuration object allows the servlet to access name-value initialization parameters from the web application.\n- Each request is serviced in its own separate thread. The web container calls the service() method of the servlet for every request. The developer of the servlet must provide an implementation for these methods.\n- Finally, the web container calls the destroy() method that takes the servlet out of service. The destroy() method, like init(), is called only once in the lifecycle of a servlet.\n\nThe following is a typical user scenario of these methods.\n\n1. Assume that a user requests to visit a URL.\n\t- The browser then generates an HTTP request for this URL.\n\t- This request is then sent to the appropriate server.\n2. The HTTP request is received by the web server and forwarded to the servlet container.\n\t- The container maps this request to a particular servlet.\n\t- The servlet is dynamically retrieved and loaded into the address space of the container.\n3. The container invokes the `init()` method of the servlet.\n\t- **This method is invoked only when the servlet is first loaded into memory.**\n\t- It is possible to pass initialization parameters to the servlet so that it may configure itself.\n4. The container invokes the `service()` method of the servlet.\n\t- This method is called to process the HTTP request.\n\t- The servlet may read data that has been provided in the HTTP request.\n\t- The servlet may also formulate an HTTP response for the client.\n5. The servlet remains in the container's address space and is available to process any other HTTP requests received from clients.\n\t- **The service() method is called for each HTTP request.**\n6. The container may, at some point, decide to unload the servlet from its memory.\n\t- The algorithms by which this decision is made are specific to each container.\n7. The container calls the servlet's destroy() method to relinquish any resources such as file handles that are allocated for the servlet; important data may be saved to a persistent store.\n8. The memory allocated for the servlet and its objects can then be garbage collected.\n\n## Example\n\nThe following example servlet prints how many times its `service()` method was called.\n\nNote that `HttpServlet` is a subclass of `GenericServlet`, an implementation of the `Servlet` interface.\n\nThe `service()` method of `HttpServlet` class dispatches requests to the methods `doGet()`, `doPost()`, `doPut()`, `doDelete()`, and so on; according to the HTTP request. In the example below `service()` is overridden and does not distinguish which HTTP request method it serves.\n\n```Java\nimport java.io.IOException;\n \nimport javax.servlet.ServletConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class ServletLifeCycleExample extends HttpServlet {\n \n    private int count;\n \n    @Override\n    public void init(final ServletConfig config) throws ServletException {\n        super.init(config);\n        getServletContext().log(\"init() called\");\n        count = 0;\n    }\n \n    @Override\n    protected void service(final HttpServletRequest request, final HttpServletResponse response) throws ServletException, IOException {\n        getServletContext().log(\"service() called\");\n        count++;\n        response.getWriter().write(\"Incrementing the count to \" + count);\n    }\n \n    @Override\n    public void destroy() {\n        getServletContext().log(\"destroy() called\");\n    }\n}\n```\n\n>javax是什么？\n\njava和javax都是Java的API(Application Programming Interface)包，java是核心包，**javax的x是extension的意思，也就是扩展包**。java类库是java发布之初就确定了的基础库，而javax类库则是在上面增加的一层东西，就是为了保持版本兼容要保存原来的，但有些东西有了更好的解决方案，所以，就加上些，典型的就是awt(Abstract Windowing ToolKit) 和swing。","source":"_posts/2018/2018-05-01-Java-Servlet-学习笔记.md","raw":"---\ntitle: Java Servlet 学习笔记\ndate: 2018-05-01\ncategories: [Java, Java web]\ncomments: true\n---\n\n>The difference between servlets and JSP is that servlets typically embed HTML inside Java code, while JSPs embed Java code in HTML.\n\n不过现在都是用MVC框架了。\n\n## life cycle of a servlet\n\nThree methods are central to the life cycle of a servlet. These are `init()`, `service()`, and `destroy()`. They are implemented by every servlet and are invoked at specific times by the server.\n\n- the web container initializes the servlet instance by calling the init() method, passing an object implementing the `javax.servlet.ServletConfig` interface. This configuration object allows the servlet to access name-value initialization parameters from the web application.\n- Each request is serviced in its own separate thread. The web container calls the service() method of the servlet for every request. The developer of the servlet must provide an implementation for these methods.\n- Finally, the web container calls the destroy() method that takes the servlet out of service. The destroy() method, like init(), is called only once in the lifecycle of a servlet.\n\nThe following is a typical user scenario of these methods.\n\n1. Assume that a user requests to visit a URL.\n\t- The browser then generates an HTTP request for this URL.\n\t- This request is then sent to the appropriate server.\n2. The HTTP request is received by the web server and forwarded to the servlet container.\n\t- The container maps this request to a particular servlet.\n\t- The servlet is dynamically retrieved and loaded into the address space of the container.\n3. The container invokes the `init()` method of the servlet.\n\t- **This method is invoked only when the servlet is first loaded into memory.**\n\t- It is possible to pass initialization parameters to the servlet so that it may configure itself.\n4. The container invokes the `service()` method of the servlet.\n\t- This method is called to process the HTTP request.\n\t- The servlet may read data that has been provided in the HTTP request.\n\t- The servlet may also formulate an HTTP response for the client.\n5. The servlet remains in the container's address space and is available to process any other HTTP requests received from clients.\n\t- **The service() method is called for each HTTP request.**\n6. The container may, at some point, decide to unload the servlet from its memory.\n\t- The algorithms by which this decision is made are specific to each container.\n7. The container calls the servlet's destroy() method to relinquish any resources such as file handles that are allocated for the servlet; important data may be saved to a persistent store.\n8. The memory allocated for the servlet and its objects can then be garbage collected.\n\n## Example\n\nThe following example servlet prints how many times its `service()` method was called.\n\nNote that `HttpServlet` is a subclass of `GenericServlet`, an implementation of the `Servlet` interface.\n\nThe `service()` method of `HttpServlet` class dispatches requests to the methods `doGet()`, `doPost()`, `doPut()`, `doDelete()`, and so on; according to the HTTP request. In the example below `service()` is overridden and does not distinguish which HTTP request method it serves.\n\n```Java\nimport java.io.IOException;\n \nimport javax.servlet.ServletConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class ServletLifeCycleExample extends HttpServlet {\n \n    private int count;\n \n    @Override\n    public void init(final ServletConfig config) throws ServletException {\n        super.init(config);\n        getServletContext().log(\"init() called\");\n        count = 0;\n    }\n \n    @Override\n    protected void service(final HttpServletRequest request, final HttpServletResponse response) throws ServletException, IOException {\n        getServletContext().log(\"service() called\");\n        count++;\n        response.getWriter().write(\"Incrementing the count to \" + count);\n    }\n \n    @Override\n    public void destroy() {\n        getServletContext().log(\"destroy() called\");\n    }\n}\n```\n\n>javax是什么？\n\njava和javax都是Java的API(Application Programming Interface)包，java是核心包，**javax的x是extension的意思，也就是扩展包**。java类库是java发布之初就确定了的基础库，而javax类库则是在上面增加的一层东西，就是为了保持版本兼容要保存原来的，但有些东西有了更好的解决方案，所以，就加上些，典型的就是awt(Abstract Windowing ToolKit) 和swing。","slug":"Java-Servlet-学习笔记","published":1,"updated":"2018-05-01T09:02:28.929Z","layout":"post","photos":[],"link":"","_id":"cjm2w8ddn002sfgpxiwbaaj6m","content":"<blockquote>\n<p>The difference between servlets and JSP is that servlets typically embed HTML inside Java code, while JSPs embed Java code in HTML.</p>\n</blockquote>\n<p>不过现在都是用MVC框架了。</p>\n<h2 id=\"life-cycle-of-a-servlet\"><a href=\"#life-cycle-of-a-servlet\" class=\"headerlink\" title=\"life cycle of a servlet\"></a>life cycle of a servlet</h2><p>Three methods are central to the life cycle of a servlet. These are <code>init()</code>, <code>service()</code>, and <code>destroy()</code>. They are implemented by every servlet and are invoked at specific times by the server.</p>\n<ul>\n<li>the web container initializes the servlet instance by calling the init() method, passing an object implementing the <code>javax.servlet.ServletConfig</code> interface. This configuration object allows the servlet to access name-value initialization parameters from the web application.</li>\n<li>Each request is serviced in its own separate thread. The web container calls the service() method of the servlet for every request. The developer of the servlet must provide an implementation for these methods.</li>\n<li>Finally, the web container calls the destroy() method that takes the servlet out of service. The destroy() method, like init(), is called only once in the lifecycle of a servlet.</li>\n</ul>\n<p>The following is a typical user scenario of these methods.</p>\n<ol>\n<li>Assume that a user requests to visit a URL.<ul>\n<li>The browser then generates an HTTP request for this URL.</li>\n<li>This request is then sent to the appropriate server.</li>\n</ul>\n</li>\n<li>The HTTP request is received by the web server and forwarded to the servlet container.<ul>\n<li>The container maps this request to a particular servlet.</li>\n<li>The servlet is dynamically retrieved and loaded into the address space of the container.</li>\n</ul>\n</li>\n<li>The container invokes the <code>init()</code> method of the servlet.<ul>\n<li><strong>This method is invoked only when the servlet is first loaded into memory.</strong></li>\n<li>It is possible to pass initialization parameters to the servlet so that it may configure itself.</li>\n</ul>\n</li>\n<li>The container invokes the <code>service()</code> method of the servlet.<ul>\n<li>This method is called to process the HTTP request.</li>\n<li>The servlet may read data that has been provided in the HTTP request.</li>\n<li>The servlet may also formulate an HTTP response for the client.</li>\n</ul>\n</li>\n<li>The servlet remains in the container’s address space and is available to process any other HTTP requests received from clients.<ul>\n<li><strong>The service() method is called for each HTTP request.</strong></li>\n</ul>\n</li>\n<li>The container may, at some point, decide to unload the servlet from its memory.<ul>\n<li>The algorithms by which this decision is made are specific to each container.</li>\n</ul>\n</li>\n<li>The container calls the servlet’s destroy() method to relinquish any resources such as file handles that are allocated for the servlet; important data may be saved to a persistent store.</li>\n<li>The memory allocated for the servlet and its objects can then be garbage collected.</li>\n</ol>\n<h2 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h2><p>The following example servlet prints how many times its <code>service()</code> method was called.</p>\n<p>Note that <code>HttpServlet</code> is a subclass of <code>GenericServlet</code>, an implementation of the <code>Servlet</code> interface.</p>\n<p>The <code>service()</code> method of <code>HttpServlet</code> class dispatches requests to the methods <code>doGet()</code>, <code>doPost()</code>, <code>doPut()</code>, <code>doDelete()</code>, and so on; according to the HTTP request. In the example below <code>service()</code> is overridden and does not distinguish which HTTP request method it serves.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.ServletConfig;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.ServletException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServlet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServletLifeCycleExample</span> <span class=\"keyword\">extends</span> <span class=\"title\">HttpServlet</span> </span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> count;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(<span class=\"keyword\">final</span> ServletConfig config)</span> <span class=\"keyword\">throws</span> ServletException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.init(config);</span><br><span class=\"line\">        getServletContext().log(<span class=\"string\">\"init() called\"</span>);</span><br><span class=\"line\">        count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">service</span><span class=\"params\">(<span class=\"keyword\">final</span> HttpServletRequest request, <span class=\"keyword\">final</span> HttpServletResponse response)</span> <span class=\"keyword\">throws</span> ServletException, IOException </span>&#123;</span><br><span class=\"line\">        getServletContext().log(<span class=\"string\">\"service() called\"</span>);</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">        response.getWriter().write(<span class=\"string\">\"Incrementing the count to \"</span> + count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        getServletContext().log(<span class=\"string\">\"destroy() called\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>javax是什么？</p>\n</blockquote>\n<p>java和javax都是Java的API(Application Programming Interface)包，java是核心包，<strong>javax的x是extension的意思，也就是扩展包</strong>。java类库是java发布之初就确定了的基础库，而javax类库则是在上面增加的一层东西，就是为了保持版本兼容要保存原来的，但有些东西有了更好的解决方案，所以，就加上些，典型的就是awt(Abstract Windowing ToolKit) 和swing。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>The difference between servlets and JSP is that servlets typically embed HTML inside Java code, while JSPs embed Java code in HTML.</p>\n</blockquote>\n<p>不过现在都是用MVC框架了。</p>\n<h2 id=\"life-cycle-of-a-servlet\"><a href=\"#life-cycle-of-a-servlet\" class=\"headerlink\" title=\"life cycle of a servlet\"></a>life cycle of a servlet</h2><p>Three methods are central to the life cycle of a servlet. These are <code>init()</code>, <code>service()</code>, and <code>destroy()</code>. They are implemented by every servlet and are invoked at specific times by the server.</p>\n<ul>\n<li>the web container initializes the servlet instance by calling the init() method, passing an object implementing the <code>javax.servlet.ServletConfig</code> interface. This configuration object allows the servlet to access name-value initialization parameters from the web application.</li>\n<li>Each request is serviced in its own separate thread. The web container calls the service() method of the servlet for every request. The developer of the servlet must provide an implementation for these methods.</li>\n<li>Finally, the web container calls the destroy() method that takes the servlet out of service. The destroy() method, like init(), is called only once in the lifecycle of a servlet.</li>\n</ul>\n<p>The following is a typical user scenario of these methods.</p>\n<ol>\n<li>Assume that a user requests to visit a URL.<ul>\n<li>The browser then generates an HTTP request for this URL.</li>\n<li>This request is then sent to the appropriate server.</li>\n</ul>\n</li>\n<li>The HTTP request is received by the web server and forwarded to the servlet container.<ul>\n<li>The container maps this request to a particular servlet.</li>\n<li>The servlet is dynamically retrieved and loaded into the address space of the container.</li>\n</ul>\n</li>\n<li>The container invokes the <code>init()</code> method of the servlet.<ul>\n<li><strong>This method is invoked only when the servlet is first loaded into memory.</strong></li>\n<li>It is possible to pass initialization parameters to the servlet so that it may configure itself.</li>\n</ul>\n</li>\n<li>The container invokes the <code>service()</code> method of the servlet.<ul>\n<li>This method is called to process the HTTP request.</li>\n<li>The servlet may read data that has been provided in the HTTP request.</li>\n<li>The servlet may also formulate an HTTP response for the client.</li>\n</ul>\n</li>\n<li>The servlet remains in the container’s address space and is available to process any other HTTP requests received from clients.<ul>\n<li><strong>The service() method is called for each HTTP request.</strong></li>\n</ul>\n</li>\n<li>The container may, at some point, decide to unload the servlet from its memory.<ul>\n<li>The algorithms by which this decision is made are specific to each container.</li>\n</ul>\n</li>\n<li>The container calls the servlet’s destroy() method to relinquish any resources such as file handles that are allocated for the servlet; important data may be saved to a persistent store.</li>\n<li>The memory allocated for the servlet and its objects can then be garbage collected.</li>\n</ol>\n<h2 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h2><p>The following example servlet prints how many times its <code>service()</code> method was called.</p>\n<p>Note that <code>HttpServlet</code> is a subclass of <code>GenericServlet</code>, an implementation of the <code>Servlet</code> interface.</p>\n<p>The <code>service()</code> method of <code>HttpServlet</code> class dispatches requests to the methods <code>doGet()</code>, <code>doPost()</code>, <code>doPut()</code>, <code>doDelete()</code>, and so on; according to the HTTP request. In the example below <code>service()</code> is overridden and does not distinguish which HTTP request method it serves.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.IOException;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.ServletConfig;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.ServletException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServlet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ServletLifeCycleExample</span> <span class=\"keyword\">extends</span> <span class=\"title\">HttpServlet</span> </span>&#123;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> count;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">init</span><span class=\"params\">(<span class=\"keyword\">final</span> ServletConfig config)</span> <span class=\"keyword\">throws</span> ServletException </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>.init(config);</span><br><span class=\"line\">        getServletContext().log(<span class=\"string\">\"init() called\"</span>);</span><br><span class=\"line\">        count = <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">service</span><span class=\"params\">(<span class=\"keyword\">final</span> HttpServletRequest request, <span class=\"keyword\">final</span> HttpServletResponse response)</span> <span class=\"keyword\">throws</span> ServletException, IOException </span>&#123;</span><br><span class=\"line\">        getServletContext().log(<span class=\"string\">\"service() called\"</span>);</span><br><span class=\"line\">        count++;</span><br><span class=\"line\">        response.getWriter().write(<span class=\"string\">\"Incrementing the count to \"</span> + count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">destroy</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        getServletContext().log(<span class=\"string\">\"destroy() called\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>javax是什么？</p>\n</blockquote>\n<p>java和javax都是Java的API(Application Programming Interface)包，java是核心包，<strong>javax的x是extension的意思，也就是扩展包</strong>。java类库是java发布之初就确定了的基础库，而javax类库则是在上面增加的一层东西，就是为了保持版本兼容要保存原来的，但有些东西有了更好的解决方案，所以，就加上些，典型的就是awt(Abstract Windowing ToolKit) 和swing。</p>\n"},{"title":"Android通讯录深入研究","date":"2018-05-02T16:00:00.000Z","comments":1,"_content":"\nThe `DISPLAY_NAME` can be fetched either from Contacts `database/ContactsContract.Data' OR 'database/ContactsContract.CommonDataKinds.StructuredName' OR 'database/RawContactsEntity`. In the later 2 cases you will be able to fetch the `DISPLAY_NAME` using `RAW_CONTACT_ID`\n\nCouple of Key pointers:\n\n- Contacts._ID = Data.CONTACT_ID\n- RawContacts._ID = Data.RAW_CONTACT_ID\n- RawContacts.CONTACT_ID = Contacts._ID\n- RawContactsEntity._ID = RawContacts._ID\n\nSounds confusing?? Let me try...\n\n1. The Contacts database is divided into 3 tables `contacts`, `raw contacts`, and `data`.\n2. Each table contains column (_ID) which is an auto incremented primary key.\n3. data table contains all the contact info like phone number, mail id, address etc.\n4. The raw contacts points to the actual contact created. Hence we use the raw contacts while adding a contact.\n5. The user cannot add any data in the contacts table. The data in this table is populated internally due to aggregation of contacts.\n6. The reason your logic worked for some of the contacts is: _ID for contacts, raw contacts remains same until there is any contact aggregation taking place. Lets say you add two contacts with same name abc. Here the _ID for raw contacts increments twice while _ID for contacts increments only once as these two contacts gets merged due to the aggregation of contacts\n\nThe best approach to fetch the info in your case is by using `ContactsContract.RawContactsEntity` ( an outer join of the raw_contacts table with the data table)\n\n这里还有一篇文章，写的比较详细：http://android-contact-id-vs-raw-contact-id.blogspot.jp/\n\n官方文档：\n\n- https://developer.android.com/reference/android/provider/ContactsContract\n- https://developer.android.com/reference/android/provider/ContactsContract.Data\n\n\n\n","source":"_posts/2018/2018-05-03-Android通讯录深入研究.md","raw":"---\ntitle: Android通讯录深入研究\ndate: 2018-05-03\ncategories: [Android, 通讯录]\ncomments: true\n---\n\nThe `DISPLAY_NAME` can be fetched either from Contacts `database/ContactsContract.Data' OR 'database/ContactsContract.CommonDataKinds.StructuredName' OR 'database/RawContactsEntity`. In the later 2 cases you will be able to fetch the `DISPLAY_NAME` using `RAW_CONTACT_ID`\n\nCouple of Key pointers:\n\n- Contacts._ID = Data.CONTACT_ID\n- RawContacts._ID = Data.RAW_CONTACT_ID\n- RawContacts.CONTACT_ID = Contacts._ID\n- RawContactsEntity._ID = RawContacts._ID\n\nSounds confusing?? Let me try...\n\n1. The Contacts database is divided into 3 tables `contacts`, `raw contacts`, and `data`.\n2. Each table contains column (_ID) which is an auto incremented primary key.\n3. data table contains all the contact info like phone number, mail id, address etc.\n4. The raw contacts points to the actual contact created. Hence we use the raw contacts while adding a contact.\n5. The user cannot add any data in the contacts table. The data in this table is populated internally due to aggregation of contacts.\n6. The reason your logic worked for some of the contacts is: _ID for contacts, raw contacts remains same until there is any contact aggregation taking place. Lets say you add two contacts with same name abc. Here the _ID for raw contacts increments twice while _ID for contacts increments only once as these two contacts gets merged due to the aggregation of contacts\n\nThe best approach to fetch the info in your case is by using `ContactsContract.RawContactsEntity` ( an outer join of the raw_contacts table with the data table)\n\n这里还有一篇文章，写的比较详细：http://android-contact-id-vs-raw-contact-id.blogspot.jp/\n\n官方文档：\n\n- https://developer.android.com/reference/android/provider/ContactsContract\n- https://developer.android.com/reference/android/provider/ContactsContract.Data\n\n\n\n","slug":"Android通讯录深入研究","published":1,"updated":"2018-06-10T01:05:53.024Z","layout":"post","photos":[],"link":"","_id":"cjm2w8ddo002vfgpxjo38gn28","content":"<p>The <code>DISPLAY_NAME</code> can be fetched either from Contacts <code>database/ContactsContract.Data&#39; OR &#39;database/ContactsContract.CommonDataKinds.StructuredName&#39; OR &#39;database/RawContactsEntity</code>. In the later 2 cases you will be able to fetch the <code>DISPLAY_NAME</code> using <code>RAW_CONTACT_ID</code></p>\n<p>Couple of Key pointers:</p>\n<ul>\n<li>Contacts._ID = Data.CONTACT_ID</li>\n<li>RawContacts._ID = Data.RAW_CONTACT_ID</li>\n<li>RawContacts.CONTACT_ID = Contacts._ID</li>\n<li>RawContactsEntity._ID = RawContacts._ID</li>\n</ul>\n<p>Sounds confusing?? Let me try…</p>\n<ol>\n<li>The Contacts database is divided into 3 tables <code>contacts</code>, <code>raw contacts</code>, and <code>data</code>.</li>\n<li>Each table contains column (_ID) which is an auto incremented primary key.</li>\n<li>data table contains all the contact info like phone number, mail id, address etc.</li>\n<li>The raw contacts points to the actual contact created. Hence we use the raw contacts while adding a contact.</li>\n<li>The user cannot add any data in the contacts table. The data in this table is populated internally due to aggregation of contacts.</li>\n<li>The reason your logic worked for some of the contacts is: _ID for contacts, raw contacts remains same until there is any contact aggregation taking place. Lets say you add two contacts with same name abc. Here the _ID for raw contacts increments twice while _ID for contacts increments only once as these two contacts gets merged due to the aggregation of contacts</li>\n</ol>\n<p>The best approach to fetch the info in your case is by using <code>ContactsContract.RawContactsEntity</code> ( an outer join of the raw_contacts table with the data table)</p>\n<p>这里还有一篇文章，写的比较详细：<a href=\"http://android-contact-id-vs-raw-contact-id.blogspot.jp/\" target=\"_blank\" rel=\"noopener\">http://android-contact-id-vs-raw-contact-id.blogspot.jp/</a></p>\n<p>官方文档：</p>\n<ul>\n<li><a href=\"https://developer.android.com/reference/android/provider/ContactsContract\" target=\"_blank\" rel=\"noopener\">https://developer.android.com/reference/android/provider/ContactsContract</a></li>\n<li><a href=\"https://developer.android.com/reference/android/provider/ContactsContract.Data\" target=\"_blank\" rel=\"noopener\">https://developer.android.com/reference/android/provider/ContactsContract.Data</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>The <code>DISPLAY_NAME</code> can be fetched either from Contacts <code>database/ContactsContract.Data&#39; OR &#39;database/ContactsContract.CommonDataKinds.StructuredName&#39; OR &#39;database/RawContactsEntity</code>. In the later 2 cases you will be able to fetch the <code>DISPLAY_NAME</code> using <code>RAW_CONTACT_ID</code></p>\n<p>Couple of Key pointers:</p>\n<ul>\n<li>Contacts._ID = Data.CONTACT_ID</li>\n<li>RawContacts._ID = Data.RAW_CONTACT_ID</li>\n<li>RawContacts.CONTACT_ID = Contacts._ID</li>\n<li>RawContactsEntity._ID = RawContacts._ID</li>\n</ul>\n<p>Sounds confusing?? Let me try…</p>\n<ol>\n<li>The Contacts database is divided into 3 tables <code>contacts</code>, <code>raw contacts</code>, and <code>data</code>.</li>\n<li>Each table contains column (_ID) which is an auto incremented primary key.</li>\n<li>data table contains all the contact info like phone number, mail id, address etc.</li>\n<li>The raw contacts points to the actual contact created. Hence we use the raw contacts while adding a contact.</li>\n<li>The user cannot add any data in the contacts table. The data in this table is populated internally due to aggregation of contacts.</li>\n<li>The reason your logic worked for some of the contacts is: _ID for contacts, raw contacts remains same until there is any contact aggregation taking place. Lets say you add two contacts with same name abc. Here the _ID for raw contacts increments twice while _ID for contacts increments only once as these two contacts gets merged due to the aggregation of contacts</li>\n</ol>\n<p>The best approach to fetch the info in your case is by using <code>ContactsContract.RawContactsEntity</code> ( an outer join of the raw_contacts table with the data table)</p>\n<p>这里还有一篇文章，写的比较详细：<a href=\"http://android-contact-id-vs-raw-contact-id.blogspot.jp/\" target=\"_blank\" rel=\"noopener\">http://android-contact-id-vs-raw-contact-id.blogspot.jp/</a></p>\n<p>官方文档：</p>\n<ul>\n<li><a href=\"https://developer.android.com/reference/android/provider/ContactsContract\" target=\"_blank\" rel=\"noopener\">https://developer.android.com/reference/android/provider/ContactsContract</a></li>\n<li><a href=\"https://developer.android.com/reference/android/provider/ContactsContract.Data\" target=\"_blank\" rel=\"noopener\">https://developer.android.com/reference/android/provider/ContactsContract.Data</a></li>\n</ul>\n"},{"title":"Volley库StringRequest编码问题","date":"2018-05-02T16:00:00.000Z","comments":1,"_content":"\n最近在做的一个工作是：从一个URL地址读取一系列手机联系人资料，保持到手机通讯录里面。\n\n项目使用了Volley库，FastJson库，遇到的一个bug是编码错误，FastJson在进行从String到bean的解析的时候，编码不正确导致的出错，这个时候，先检查了URL的编码是UTF-8的，然后Android Studio的程序源文件也是UTF-8的，那就只有一个可能了，网络传输过程中的编码错误。\n\ngoogle一下发现早就有人在stackoverflow上问过这个问题了：\n\n>How to get Android Volley StringRequest GET to return responses in UTF-8 encoding\n\nHow can I get Android Volley StringRequest GET to return responses in UTF-8 encoding? It only seems to return responses in ISO-8859-1.\n\nIs it possible to get it to accept a UTF-8 string?\n\nStringRequest call HttpHeaderParser.parseCharset(response.headers) to get charset from response headers, is 'Content-Type' in headers don`t contains 'charset' the default charset return as 'ISO-8859-1'.\n\nStringRequest.java\n\n```Java\nprotected Response<String> parseNetworkResponse(NetworkResponse response) {\n    String parsed;\n    try {\n        parsed = new String(response.data, HttpHeaderParser.parseCharset(response.headers));\n    } catch (UnsupportedEncodingException var4) {\n        parsed = new String(response.data);\n    }\n\n    return Response.success(parsed, HttpHeaderParser.parseCacheHeaders(response));\n}\n```\n\nHttpHeaderParser.java\n\n```Java\npublic static String parseCharset(Map<String, String> headers, String defaultCharset) {\n    String contentType = headers.get(HTTP.CONTENT_TYPE);\n    if (contentType != null) {\n        String[] params = contentType.split(\";\");\n        for (int i = 1; i < params.length; i++) {\n            String[] pair = params[i].trim().split(\"=\");\n            if (pair.length == 2) {\n                if (pair[0].equals(\"charset\")) {\n                    return pair[1];\n                }\n            }\n        }\n    }\n\n    return defaultCharset;\n}\n\n/**\n * Returns the charset specified in the Content-Type of this header,\n * or the HTTP default (ISO-8859-1) if none can be found.\n */\npublic static String parseCharset(Map<String, String> headers) {\n    return parseCharset(headers, HTTP.DEFAULT_CONTENT_CHARSET);\n}\n```\n\nso, you can parse to 'UTF-8' in 2 ways:\n\n1. tell your webServer to add 'Content-Type' with 'charset=UTF-8' in headers\n2. Create a subclass of StringRequest and override parseNetworkResponse method\n\n意思是定制一个`MyStringRequest`类，继承`StringRequest`类，重载`parseNetworkResponse`即可：\n\n```Java\nprotected Response<String> parseNetworkResponse(NetworkResponse response) {\n    String parsed;\n    try {\n        parsed = new String(response.data, \"utf-8\");\n    } catch (UnsupportedEncodingException var4) {\n        parsed = new String(response.data);\n    }\n\n    return Response.success(parsed, HttpHeaderParser.parseCacheHeaders(response));\n}\n```\n","source":"_posts/2018/2018-05-03-Volley库StringRequest编码问题.md","raw":"---\ntitle: Volley库StringRequest编码问题\ndate: 2018-05-03\ncategories: [Android, Volley库]\ncomments: true\n---\n\n最近在做的一个工作是：从一个URL地址读取一系列手机联系人资料，保持到手机通讯录里面。\n\n项目使用了Volley库，FastJson库，遇到的一个bug是编码错误，FastJson在进行从String到bean的解析的时候，编码不正确导致的出错，这个时候，先检查了URL的编码是UTF-8的，然后Android Studio的程序源文件也是UTF-8的，那就只有一个可能了，网络传输过程中的编码错误。\n\ngoogle一下发现早就有人在stackoverflow上问过这个问题了：\n\n>How to get Android Volley StringRequest GET to return responses in UTF-8 encoding\n\nHow can I get Android Volley StringRequest GET to return responses in UTF-8 encoding? It only seems to return responses in ISO-8859-1.\n\nIs it possible to get it to accept a UTF-8 string?\n\nStringRequest call HttpHeaderParser.parseCharset(response.headers) to get charset from response headers, is 'Content-Type' in headers don`t contains 'charset' the default charset return as 'ISO-8859-1'.\n\nStringRequest.java\n\n```Java\nprotected Response<String> parseNetworkResponse(NetworkResponse response) {\n    String parsed;\n    try {\n        parsed = new String(response.data, HttpHeaderParser.parseCharset(response.headers));\n    } catch (UnsupportedEncodingException var4) {\n        parsed = new String(response.data);\n    }\n\n    return Response.success(parsed, HttpHeaderParser.parseCacheHeaders(response));\n}\n```\n\nHttpHeaderParser.java\n\n```Java\npublic static String parseCharset(Map<String, String> headers, String defaultCharset) {\n    String contentType = headers.get(HTTP.CONTENT_TYPE);\n    if (contentType != null) {\n        String[] params = contentType.split(\";\");\n        for (int i = 1; i < params.length; i++) {\n            String[] pair = params[i].trim().split(\"=\");\n            if (pair.length == 2) {\n                if (pair[0].equals(\"charset\")) {\n                    return pair[1];\n                }\n            }\n        }\n    }\n\n    return defaultCharset;\n}\n\n/**\n * Returns the charset specified in the Content-Type of this header,\n * or the HTTP default (ISO-8859-1) if none can be found.\n */\npublic static String parseCharset(Map<String, String> headers) {\n    return parseCharset(headers, HTTP.DEFAULT_CONTENT_CHARSET);\n}\n```\n\nso, you can parse to 'UTF-8' in 2 ways:\n\n1. tell your webServer to add 'Content-Type' with 'charset=UTF-8' in headers\n2. Create a subclass of StringRequest and override parseNetworkResponse method\n\n意思是定制一个`MyStringRequest`类，继承`StringRequest`类，重载`parseNetworkResponse`即可：\n\n```Java\nprotected Response<String> parseNetworkResponse(NetworkResponse response) {\n    String parsed;\n    try {\n        parsed = new String(response.data, \"utf-8\");\n    } catch (UnsupportedEncodingException var4) {\n        parsed = new String(response.data);\n    }\n\n    return Response.success(parsed, HttpHeaderParser.parseCacheHeaders(response));\n}\n```\n","slug":"Volley库StringRequest编码问题","published":1,"updated":"2018-05-03T12:48:43.238Z","layout":"post","photos":[],"link":"","_id":"cjm2w8ddp002xfgpx8x97ehl4","content":"<p>最近在做的一个工作是：从一个URL地址读取一系列手机联系人资料，保持到手机通讯录里面。</p>\n<p>项目使用了Volley库，FastJson库，遇到的一个bug是编码错误，FastJson在进行从String到bean的解析的时候，编码不正确导致的出错，这个时候，先检查了URL的编码是UTF-8的，然后Android Studio的程序源文件也是UTF-8的，那就只有一个可能了，网络传输过程中的编码错误。</p>\n<p>google一下发现早就有人在stackoverflow上问过这个问题了：</p>\n<blockquote>\n<p>How to get Android Volley StringRequest GET to return responses in UTF-8 encoding</p>\n</blockquote>\n<p>How can I get Android Volley StringRequest GET to return responses in UTF-8 encoding? It only seems to return responses in ISO-8859-1.</p>\n<p>Is it possible to get it to accept a UTF-8 string?</p>\n<p>StringRequest call HttpHeaderParser.parseCharset(response.headers) to get charset from response headers, is ‘Content-Type’ in headers don`t contains ‘charset’ the default charset return as ‘ISO-8859-1’.</p>\n<p>StringRequest.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> Response&lt;String&gt; <span class=\"title\">parseNetworkResponse</span><span class=\"params\">(NetworkResponse response)</span> </span>&#123;</span><br><span class=\"line\">    String parsed;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        parsed = <span class=\"keyword\">new</span> String(response.data, HttpHeaderParser.parseCharset(response.headers));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (UnsupportedEncodingException var4) &#123;</span><br><span class=\"line\">        parsed = <span class=\"keyword\">new</span> String(response.data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> Response.success(parsed, HttpHeaderParser.parseCacheHeaders(response));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>HttpHeaderParser.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">parseCharset</span><span class=\"params\">(Map&lt;String, String&gt; headers, String defaultCharset)</span> </span>&#123;</span><br><span class=\"line\">    String contentType = headers.get(HTTP.CONTENT_TYPE);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (contentType != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        String[] params = contentType.split(<span class=\"string\">\";\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; params.length; i++) &#123;</span><br><span class=\"line\">            String[] pair = params[i].trim().split(<span class=\"string\">\"=\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pair.length == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (pair[<span class=\"number\">0</span>].equals(<span class=\"string\">\"charset\"</span>)) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> pair[<span class=\"number\">1</span>];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> defaultCharset;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns the charset specified in the Content-Type of this header,</span></span><br><span class=\"line\"><span class=\"comment\"> * or the HTTP default (ISO-8859-1) if none can be found.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">parseCharset</span><span class=\"params\">(Map&lt;String, String&gt; headers)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> parseCharset(headers, HTTP.DEFAULT_CONTENT_CHARSET);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>so, you can parse to ‘UTF-8’ in 2 ways:</p>\n<ol>\n<li>tell your webServer to add ‘Content-Type’ with ‘charset=UTF-8’ in headers</li>\n<li>Create a subclass of StringRequest and override parseNetworkResponse method</li>\n</ol>\n<p>意思是定制一个<code>MyStringRequest</code>类，继承<code>StringRequest</code>类，重载<code>parseNetworkResponse</code>即可：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> Response&lt;String&gt; <span class=\"title\">parseNetworkResponse</span><span class=\"params\">(NetworkResponse response)</span> </span>&#123;</span><br><span class=\"line\">    String parsed;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        parsed = <span class=\"keyword\">new</span> String(response.data, <span class=\"string\">\"utf-8\"</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (UnsupportedEncodingException var4) &#123;</span><br><span class=\"line\">        parsed = <span class=\"keyword\">new</span> String(response.data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> Response.success(parsed, HttpHeaderParser.parseCacheHeaders(response));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>最近在做的一个工作是：从一个URL地址读取一系列手机联系人资料，保持到手机通讯录里面。</p>\n<p>项目使用了Volley库，FastJson库，遇到的一个bug是编码错误，FastJson在进行从String到bean的解析的时候，编码不正确导致的出错，这个时候，先检查了URL的编码是UTF-8的，然后Android Studio的程序源文件也是UTF-8的，那就只有一个可能了，网络传输过程中的编码错误。</p>\n<p>google一下发现早就有人在stackoverflow上问过这个问题了：</p>\n<blockquote>\n<p>How to get Android Volley StringRequest GET to return responses in UTF-8 encoding</p>\n</blockquote>\n<p>How can I get Android Volley StringRequest GET to return responses in UTF-8 encoding? It only seems to return responses in ISO-8859-1.</p>\n<p>Is it possible to get it to accept a UTF-8 string?</p>\n<p>StringRequest call HttpHeaderParser.parseCharset(response.headers) to get charset from response headers, is ‘Content-Type’ in headers don`t contains ‘charset’ the default charset return as ‘ISO-8859-1’.</p>\n<p>StringRequest.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> Response&lt;String&gt; <span class=\"title\">parseNetworkResponse</span><span class=\"params\">(NetworkResponse response)</span> </span>&#123;</span><br><span class=\"line\">    String parsed;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        parsed = <span class=\"keyword\">new</span> String(response.data, HttpHeaderParser.parseCharset(response.headers));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (UnsupportedEncodingException var4) &#123;</span><br><span class=\"line\">        parsed = <span class=\"keyword\">new</span> String(response.data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> Response.success(parsed, HttpHeaderParser.parseCacheHeaders(response));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>HttpHeaderParser.java</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">parseCharset</span><span class=\"params\">(Map&lt;String, String&gt; headers, String defaultCharset)</span> </span>&#123;</span><br><span class=\"line\">    String contentType = headers.get(HTTP.CONTENT_TYPE);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (contentType != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        String[] params = contentType.split(<span class=\"string\">\";\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; params.length; i++) &#123;</span><br><span class=\"line\">            String[] pair = params[i].trim().split(<span class=\"string\">\"=\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (pair.length == <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (pair[<span class=\"number\">0</span>].equals(<span class=\"string\">\"charset\"</span>)) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> pair[<span class=\"number\">1</span>];</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> defaultCharset;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns the charset specified in the Content-Type of this header,</span></span><br><span class=\"line\"><span class=\"comment\"> * or the HTTP default (ISO-8859-1) if none can be found.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">parseCharset</span><span class=\"params\">(Map&lt;String, String&gt; headers)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> parseCharset(headers, HTTP.DEFAULT_CONTENT_CHARSET);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>so, you can parse to ‘UTF-8’ in 2 ways:</p>\n<ol>\n<li>tell your webServer to add ‘Content-Type’ with ‘charset=UTF-8’ in headers</li>\n<li>Create a subclass of StringRequest and override parseNetworkResponse method</li>\n</ol>\n<p>意思是定制一个<code>MyStringRequest</code>类，继承<code>StringRequest</code>类，重载<code>parseNetworkResponse</code>即可：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> Response&lt;String&gt; <span class=\"title\">parseNetworkResponse</span><span class=\"params\">(NetworkResponse response)</span> </span>&#123;</span><br><span class=\"line\">    String parsed;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        parsed = <span class=\"keyword\">new</span> String(response.data, <span class=\"string\">\"utf-8\"</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">catch</span> (UnsupportedEncodingException var4) &#123;</span><br><span class=\"line\">        parsed = <span class=\"keyword\">new</span> String(response.data);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> Response.success(parsed, HttpHeaderParser.parseCacheHeaders(response));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"用ipfs发布博客","date":"2018-05-03T16:00:00.000Z","comments":1,"_content":"\nipfs是一个p2p的网络\n\n## 常用ipfs命令\n\n```\nipfs add -r mysite\n// 通过上一步可以得到很多个哈希值（每个目录和文件都有一个），把根目录对应的哈希值拿出来用\nipfs name publish QmZyenFLZtm9rk2B98ZqRAFYRkzhqyUruKBSsdZUnKk9ek\n```\n\n第二步实际上是把这个站点的根目录映射到了你的 `ipfs id` 上面，你的这个id是固定的。之后你每次更新这个站点下的内容都要 `ipfs add -r mysite` 一次，然后把根目录对应的哈希值重新映射到你的 ipfs id 上。\n\n然后你访问ipfs站点的时候，可以这样访问：`https://ipfs.io/ipns/your_ipfs_id`，如果你的浏览器装了ipfs插件就可以自动解析这个网址，从而直接用ipfs协议来访问站点了。\n\n>注意your_ipfs_id是指你的ipfs id，你可以用命令`ipfs id`查看你的id是什么，相信我的读者不会蠢到直接复制粘贴your_ipfs_id。\n\n## hexo生成的博客，缺失css和js的问题\n\n在hexo的config里面，有个root，这个root就是用来给css和js等资源指定目录的，所以你要改成：`/ipns/your_ipfs_id/`\n\n如果你想同时在git pages上面，和ipfs上面发布你的博客，那么root这个属性必定就冲突了，因为在git pages上面发布的时候，直接填`/`就行了（他是直接发布在像：`liuqinh2s.github.io`，这个域名后面，也就是子域名的根目录，不像ipfs那样会加个`/ipns/your_ipfs_id`这种目录）。那么你就只能搞两个博客工程了，新发布博客的时候，就要同时修改两个地方。\n\n比如我是这样做的，我建了一个ipfs文件夹，里面存放我所有发布在ipfs上的资源，所以我会把我的博客复制一份到这个文件夹里面，更新博客的时候，复制一份博客文件到这边，git pages那边要发布一次，然后ipfs这边也要发布一次。\n\n访问我的ipfs站点：https://ipfs.io/ipns/QmT7mga4wwTLNFCrtt1FbvLgmxTWZyKGRsrnFZNMoHdEJa/\n\n## 使用脚本自动化push\n\n为了实现自动push，我自己写了个脚本，可以同时把博客push到git pages和ipfs上：https://gist.github.com/liuqinh2s/0864ed7799b161bb2f048b4fab867d5a\n\n在你的博客目录下新建一个`push.sh`，然后把代码复制粘贴，保存，以后每次push的时候执行：`bash push.sh`\n","source":"_posts/2018/2018-05-04-用ipfs发布博客.md","raw":"---\ntitle: 用ipfs发布博客\ndate: 2018-05-04\ncategories: [区块链, ipfs]\ncomments: true\n---\n\nipfs是一个p2p的网络\n\n## 常用ipfs命令\n\n```\nipfs add -r mysite\n// 通过上一步可以得到很多个哈希值（每个目录和文件都有一个），把根目录对应的哈希值拿出来用\nipfs name publish QmZyenFLZtm9rk2B98ZqRAFYRkzhqyUruKBSsdZUnKk9ek\n```\n\n第二步实际上是把这个站点的根目录映射到了你的 `ipfs id` 上面，你的这个id是固定的。之后你每次更新这个站点下的内容都要 `ipfs add -r mysite` 一次，然后把根目录对应的哈希值重新映射到你的 ipfs id 上。\n\n然后你访问ipfs站点的时候，可以这样访问：`https://ipfs.io/ipns/your_ipfs_id`，如果你的浏览器装了ipfs插件就可以自动解析这个网址，从而直接用ipfs协议来访问站点了。\n\n>注意your_ipfs_id是指你的ipfs id，你可以用命令`ipfs id`查看你的id是什么，相信我的读者不会蠢到直接复制粘贴your_ipfs_id。\n\n## hexo生成的博客，缺失css和js的问题\n\n在hexo的config里面，有个root，这个root就是用来给css和js等资源指定目录的，所以你要改成：`/ipns/your_ipfs_id/`\n\n如果你想同时在git pages上面，和ipfs上面发布你的博客，那么root这个属性必定就冲突了，因为在git pages上面发布的时候，直接填`/`就行了（他是直接发布在像：`liuqinh2s.github.io`，这个域名后面，也就是子域名的根目录，不像ipfs那样会加个`/ipns/your_ipfs_id`这种目录）。那么你就只能搞两个博客工程了，新发布博客的时候，就要同时修改两个地方。\n\n比如我是这样做的，我建了一个ipfs文件夹，里面存放我所有发布在ipfs上的资源，所以我会把我的博客复制一份到这个文件夹里面，更新博客的时候，复制一份博客文件到这边，git pages那边要发布一次，然后ipfs这边也要发布一次。\n\n访问我的ipfs站点：https://ipfs.io/ipns/QmT7mga4wwTLNFCrtt1FbvLgmxTWZyKGRsrnFZNMoHdEJa/\n\n## 使用脚本自动化push\n\n为了实现自动push，我自己写了个脚本，可以同时把博客push到git pages和ipfs上：https://gist.github.com/liuqinh2s/0864ed7799b161bb2f048b4fab867d5a\n\n在你的博客目录下新建一个`push.sh`，然后把代码复制粘贴，保存，以后每次push的时候执行：`bash push.sh`\n","slug":"用ipfs发布博客","published":1,"updated":"2018-05-07T04:28:13.734Z","layout":"post","photos":[],"link":"","_id":"cjm2w8ddq0030fgpxiit15aia","content":"<p>ipfs是一个p2p的网络</p>\n<h2 id=\"常用ipfs命令\"><a href=\"#常用ipfs命令\" class=\"headerlink\" title=\"常用ipfs命令\"></a>常用ipfs命令</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ipfs add -r mysite</span><br><span class=\"line\">// 通过上一步可以得到很多个哈希值（每个目录和文件都有一个），把根目录对应的哈希值拿出来用</span><br><span class=\"line\">ipfs name publish QmZyenFLZtm9rk2B98ZqRAFYRkzhqyUruKBSsdZUnKk9ek</span><br></pre></td></tr></table></figure>\n<p>第二步实际上是把这个站点的根目录映射到了你的 <code>ipfs id</code> 上面，你的这个id是固定的。之后你每次更新这个站点下的内容都要 <code>ipfs add -r mysite</code> 一次，然后把根目录对应的哈希值重新映射到你的 ipfs id 上。</p>\n<p>然后你访问ipfs站点的时候，可以这样访问：<code>https://ipfs.io/ipns/your_ipfs_id</code>，如果你的浏览器装了ipfs插件就可以自动解析这个网址，从而直接用ipfs协议来访问站点了。</p>\n<blockquote>\n<p>注意your_ipfs_id是指你的ipfs id，你可以用命令<code>ipfs id</code>查看你的id是什么，相信我的读者不会蠢到直接复制粘贴your_ipfs_id。</p>\n</blockquote>\n<h2 id=\"hexo生成的博客，缺失css和js的问题\"><a href=\"#hexo生成的博客，缺失css和js的问题\" class=\"headerlink\" title=\"hexo生成的博客，缺失css和js的问题\"></a>hexo生成的博客，缺失css和js的问题</h2><p>在hexo的config里面，有个root，这个root就是用来给css和js等资源指定目录的，所以你要改成：<code>/ipns/your_ipfs_id/</code></p>\n<p>如果你想同时在git pages上面，和ipfs上面发布你的博客，那么root这个属性必定就冲突了，因为在git pages上面发布的时候，直接填<code>/</code>就行了（他是直接发布在像：<code>liuqinh2s.github.io</code>，这个域名后面，也就是子域名的根目录，不像ipfs那样会加个<code>/ipns/your_ipfs_id</code>这种目录）。那么你就只能搞两个博客工程了，新发布博客的时候，就要同时修改两个地方。</p>\n<p>比如我是这样做的，我建了一个ipfs文件夹，里面存放我所有发布在ipfs上的资源，所以我会把我的博客复制一份到这个文件夹里面，更新博客的时候，复制一份博客文件到这边，git pages那边要发布一次，然后ipfs这边也要发布一次。</p>\n<p>访问我的ipfs站点：<a href=\"https://ipfs.io/ipns/QmT7mga4wwTLNFCrtt1FbvLgmxTWZyKGRsrnFZNMoHdEJa/\" target=\"_blank\" rel=\"noopener\">https://ipfs.io/ipns/QmT7mga4wwTLNFCrtt1FbvLgmxTWZyKGRsrnFZNMoHdEJa/</a></p>\n<h2 id=\"使用脚本自动化push\"><a href=\"#使用脚本自动化push\" class=\"headerlink\" title=\"使用脚本自动化push\"></a>使用脚本自动化push</h2><p>为了实现自动push，我自己写了个脚本，可以同时把博客push到git pages和ipfs上：<a href=\"https://gist.github.com/liuqinh2s/0864ed7799b161bb2f048b4fab867d5a\" target=\"_blank\" rel=\"noopener\">https://gist.github.com/liuqinh2s/0864ed7799b161bb2f048b4fab867d5a</a></p>\n<p>在你的博客目录下新建一个<code>push.sh</code>，然后把代码复制粘贴，保存，以后每次push的时候执行：<code>bash push.sh</code></p>\n","site":{"data":{}},"excerpt":"","more":"<p>ipfs是一个p2p的网络</p>\n<h2 id=\"常用ipfs命令\"><a href=\"#常用ipfs命令\" class=\"headerlink\" title=\"常用ipfs命令\"></a>常用ipfs命令</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ipfs add -r mysite</span><br><span class=\"line\">// 通过上一步可以得到很多个哈希值（每个目录和文件都有一个），把根目录对应的哈希值拿出来用</span><br><span class=\"line\">ipfs name publish QmZyenFLZtm9rk2B98ZqRAFYRkzhqyUruKBSsdZUnKk9ek</span><br></pre></td></tr></table></figure>\n<p>第二步实际上是把这个站点的根目录映射到了你的 <code>ipfs id</code> 上面，你的这个id是固定的。之后你每次更新这个站点下的内容都要 <code>ipfs add -r mysite</code> 一次，然后把根目录对应的哈希值重新映射到你的 ipfs id 上。</p>\n<p>然后你访问ipfs站点的时候，可以这样访问：<code>https://ipfs.io/ipns/your_ipfs_id</code>，如果你的浏览器装了ipfs插件就可以自动解析这个网址，从而直接用ipfs协议来访问站点了。</p>\n<blockquote>\n<p>注意your_ipfs_id是指你的ipfs id，你可以用命令<code>ipfs id</code>查看你的id是什么，相信我的读者不会蠢到直接复制粘贴your_ipfs_id。</p>\n</blockquote>\n<h2 id=\"hexo生成的博客，缺失css和js的问题\"><a href=\"#hexo生成的博客，缺失css和js的问题\" class=\"headerlink\" title=\"hexo生成的博客，缺失css和js的问题\"></a>hexo生成的博客，缺失css和js的问题</h2><p>在hexo的config里面，有个root，这个root就是用来给css和js等资源指定目录的，所以你要改成：<code>/ipns/your_ipfs_id/</code></p>\n<p>如果你想同时在git pages上面，和ipfs上面发布你的博客，那么root这个属性必定就冲突了，因为在git pages上面发布的时候，直接填<code>/</code>就行了（他是直接发布在像：<code>liuqinh2s.github.io</code>，这个域名后面，也就是子域名的根目录，不像ipfs那样会加个<code>/ipns/your_ipfs_id</code>这种目录）。那么你就只能搞两个博客工程了，新发布博客的时候，就要同时修改两个地方。</p>\n<p>比如我是这样做的，我建了一个ipfs文件夹，里面存放我所有发布在ipfs上的资源，所以我会把我的博客复制一份到这个文件夹里面，更新博客的时候，复制一份博客文件到这边，git pages那边要发布一次，然后ipfs这边也要发布一次。</p>\n<p>访问我的ipfs站点：<a href=\"https://ipfs.io/ipns/QmT7mga4wwTLNFCrtt1FbvLgmxTWZyKGRsrnFZNMoHdEJa/\" target=\"_blank\" rel=\"noopener\">https://ipfs.io/ipns/QmT7mga4wwTLNFCrtt1FbvLgmxTWZyKGRsrnFZNMoHdEJa/</a></p>\n<h2 id=\"使用脚本自动化push\"><a href=\"#使用脚本自动化push\" class=\"headerlink\" title=\"使用脚本自动化push\"></a>使用脚本自动化push</h2><p>为了实现自动push，我自己写了个脚本，可以同时把博客push到git pages和ipfs上：<a href=\"https://gist.github.com/liuqinh2s/0864ed7799b161bb2f048b4fab867d5a\" target=\"_blank\" rel=\"noopener\">https://gist.github.com/liuqinh2s/0864ed7799b161bb2f048b4fab867d5a</a></p>\n<p>在你的博客目录下新建一个<code>push.sh</code>，然后把代码复制粘贴，保存，以后每次push的时候执行：<code>bash push.sh</code></p>\n"},{"title":"对区块链以及未来的一些思考","date":"2018-05-06T16:00:00.000Z","comments":1,"_content":"\n有个用户痛点，我来描述一下：当你更改了手机号，it's a disaster! 你需要改无数绑定的东西，比如：银行预留手机号，各类APP的绑定手机号，还要通知所有人你改了手机号，当然我现在换手机号也懒得通知别人了，除了还给我打电话的那几个人，现在大家都是用QQ和微信沟通了。\n\n我说个笑话，不，其实这是个真实的故事，我曾今在深圳用过摩拜共享单车，当时绑定了我的手机号，后来我在杭州，并且手机号也换了，另外摩拜也加了个身份证验证。我就再也使用不了摩拜了，好像是因为手机号和身份证绑定了，我无法通过其他手机号使用摩拜了。摩拜让我交了200块钱押金，让我充了10块钱车费，最后却告诉我，我不能骑车。我只好申诉，申诉没起效果，最后我直接申请退款了，退款理由我写上了：无法实名认证。我希望以此能够催促摩拜尽早改好这个BUG，从而帮助到其他人吧。\n\n还有就是各种证，从身份证开始，学位证，毕业证，结婚证，团员证，党员证，房产证。。。\n\n还有一些事是大家都知道的，三鹿奶粉，三聚氰胺，地沟油，等等。\n\n那么这些事之间有什么联系呢？\n\n有，当然有，那就是：信任。\n\n如何让别人信任你，如何让我们信任那些企业，如何做到一个账号上网，或者说不用麻烦的认证，你上网，网就认识你，从这个网站到那个网站，不需要繁琐的注册登陆。\n\n区块链貌似能解决这个问题，如果我们的信息都放在一起，需要的时候就去查看，而且有严格的权限限制，那么我们就建立了一个统一的信息源。\n","source":"_posts/2018/2018-05-07-对区块链以及未来的一些思考.md","raw":"---\ntitle: 对区块链以及未来的一些思考\ndate: 2018-05-07\ncategories: [区块链]\ncomments: true\n---\n\n有个用户痛点，我来描述一下：当你更改了手机号，it's a disaster! 你需要改无数绑定的东西，比如：银行预留手机号，各类APP的绑定手机号，还要通知所有人你改了手机号，当然我现在换手机号也懒得通知别人了，除了还给我打电话的那几个人，现在大家都是用QQ和微信沟通了。\n\n我说个笑话，不，其实这是个真实的故事，我曾今在深圳用过摩拜共享单车，当时绑定了我的手机号，后来我在杭州，并且手机号也换了，另外摩拜也加了个身份证验证。我就再也使用不了摩拜了，好像是因为手机号和身份证绑定了，我无法通过其他手机号使用摩拜了。摩拜让我交了200块钱押金，让我充了10块钱车费，最后却告诉我，我不能骑车。我只好申诉，申诉没起效果，最后我直接申请退款了，退款理由我写上了：无法实名认证。我希望以此能够催促摩拜尽早改好这个BUG，从而帮助到其他人吧。\n\n还有就是各种证，从身份证开始，学位证，毕业证，结婚证，团员证，党员证，房产证。。。\n\n还有一些事是大家都知道的，三鹿奶粉，三聚氰胺，地沟油，等等。\n\n那么这些事之间有什么联系呢？\n\n有，当然有，那就是：信任。\n\n如何让别人信任你，如何让我们信任那些企业，如何做到一个账号上网，或者说不用麻烦的认证，你上网，网就认识你，从这个网站到那个网站，不需要繁琐的注册登陆。\n\n区块链貌似能解决这个问题，如果我们的信息都放在一起，需要的时候就去查看，而且有严格的权限限制，那么我们就建立了一个统一的信息源。\n","slug":"对区块链以及未来的一些思考","published":1,"updated":"2018-05-07T09:42:58.093Z","layout":"post","photos":[],"link":"","_id":"cjm2w8ddr0032fgpx5ldxwm2b","content":"<p>有个用户痛点，我来描述一下：当你更改了手机号，it’s a disaster! 你需要改无数绑定的东西，比如：银行预留手机号，各类APP的绑定手机号，还要通知所有人你改了手机号，当然我现在换手机号也懒得通知别人了，除了还给我打电话的那几个人，现在大家都是用QQ和微信沟通了。</p>\n<p>我说个笑话，不，其实这是个真实的故事，我曾今在深圳用过摩拜共享单车，当时绑定了我的手机号，后来我在杭州，并且手机号也换了，另外摩拜也加了个身份证验证。我就再也使用不了摩拜了，好像是因为手机号和身份证绑定了，我无法通过其他手机号使用摩拜了。摩拜让我交了200块钱押金，让我充了10块钱车费，最后却告诉我，我不能骑车。我只好申诉，申诉没起效果，最后我直接申请退款了，退款理由我写上了：无法实名认证。我希望以此能够催促摩拜尽早改好这个BUG，从而帮助到其他人吧。</p>\n<p>还有就是各种证，从身份证开始，学位证，毕业证，结婚证，团员证，党员证，房产证。。。</p>\n<p>还有一些事是大家都知道的，三鹿奶粉，三聚氰胺，地沟油，等等。</p>\n<p>那么这些事之间有什么联系呢？</p>\n<p>有，当然有，那就是：信任。</p>\n<p>如何让别人信任你，如何让我们信任那些企业，如何做到一个账号上网，或者说不用麻烦的认证，你上网，网就认识你，从这个网站到那个网站，不需要繁琐的注册登陆。</p>\n<p>区块链貌似能解决这个问题，如果我们的信息都放在一起，需要的时候就去查看，而且有严格的权限限制，那么我们就建立了一个统一的信息源。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>有个用户痛点，我来描述一下：当你更改了手机号，it’s a disaster! 你需要改无数绑定的东西，比如：银行预留手机号，各类APP的绑定手机号，还要通知所有人你改了手机号，当然我现在换手机号也懒得通知别人了，除了还给我打电话的那几个人，现在大家都是用QQ和微信沟通了。</p>\n<p>我说个笑话，不，其实这是个真实的故事，我曾今在深圳用过摩拜共享单车，当时绑定了我的手机号，后来我在杭州，并且手机号也换了，另外摩拜也加了个身份证验证。我就再也使用不了摩拜了，好像是因为手机号和身份证绑定了，我无法通过其他手机号使用摩拜了。摩拜让我交了200块钱押金，让我充了10块钱车费，最后却告诉我，我不能骑车。我只好申诉，申诉没起效果，最后我直接申请退款了，退款理由我写上了：无法实名认证。我希望以此能够催促摩拜尽早改好这个BUG，从而帮助到其他人吧。</p>\n<p>还有就是各种证，从身份证开始，学位证，毕业证，结婚证，团员证，党员证，房产证。。。</p>\n<p>还有一些事是大家都知道的，三鹿奶粉，三聚氰胺，地沟油，等等。</p>\n<p>那么这些事之间有什么联系呢？</p>\n<p>有，当然有，那就是：信任。</p>\n<p>如何让别人信任你，如何让我们信任那些企业，如何做到一个账号上网，或者说不用麻烦的认证，你上网，网就认识你，从这个网站到那个网站，不需要繁琐的注册登陆。</p>\n<p>区块链貌似能解决这个问题，如果我们的信息都放在一起，需要的时候就去查看，而且有严格的权限限制，那么我们就建立了一个统一的信息源。</p>\n"},{"title":"Linux Shell 配色","date":"2018-05-07T16:00:00.000Z","comments":1,"_content":"\n早就想自己给bash配个色，但是一直没空学习这方面的知识，今天抽个空，搞了一点点。\n\n## 切换shell\n\n切换shell，分临时和永久。\n\n临时：输入命令：`bash`或者`zsh`都行，shell调用shell，一层套一层，按`ctrl+d`或者输入`exit`可以退出。\n永久：输入命令：`chsh -s /bin/bash`\n\n>chsh意思就是change shell，使用`man chsh`进行查看\n\n## 修改prompt\n\nprompt也就是提示符，首先就是要修改这个，什么样的提示符才是一个好的提示符呢？我觉得首要的是要短，太长的提示符占了命令的空间。其次提示符还必须显示用户名和机器名，因为只有这样才能在你远程登录的时候与远程shell区分开。机器名最好是缩写。然后我就得出了我自己的提示符的前缀：`liuqinh2s@mbp`，然后我觉得得加个短路径，不要求绝对路径，这样太占空间，只需要加个当前文件夹即可。这样进一步修改之后，我的提示符变成了：`liuqinh2s@mbp:~`，最后需要添加一个普通用户和超级用户的区分，普通用户用：`$`，超级用户用`#`，所以我的提示符最终的样子是：`liuqinh2s@mbp:~$ `，注意`$`后面我加了一个空格，这样看起来比较舒服，提示符和命令的界限一目了然。\n\n但其实还是不清晰，我就给prompt上了个颜色。\n\n最后就变成这样啦：\n\n<img src=\"https://i.loli.net/2018/05/08/5af13dcea3fa6.png\" alt=\"屏幕快照 2018-05-08 下午2.03.34.png\" title=\"屏幕快照 2018-05-08 下午2.03.34.png\" width=\"30%\" height=\"30%\"/>\n\n配置代码：`PS1=\"\\[\\e[0;32m\\]\\u@\\h:\\[\\e[0;34m\\]\\W\\$\\[\\e[0m\\] \"`\n\n>使用`export PS1=\"\\[\\e[0;32m\\]\\u@\\h:\\[\\e[0;34m\\]\\W\\$\\[\\e[0m\\] \"`，这样的话，你输入`bash`的时候，也能用到你的配置\n\n>export in sh and related shells (such as bash), marks an environment variable to be exported to child-processes, so that the child inherits them.\n\nexport的作用就是让子进程也继承环境变量\n\n如果你用的是mac的话，在home目录的`.bash_profile`中修改就可以了\n\n下面是配置代码的讲解：\n\n### Bash转义序列\n\n```\n\\a     an ASCII bell character (07)\n\\d     the date in \"Weekday Month Date\" format (e.g., \"Tue May 26\")\n\\D{format}\n       the format is passed to strftime(3) and the result is inserted into the prompt string; an empty format results in a locale-\n       specific time representation.  The braces are required\n\\e     an ASCII escape character (033)\n\\h     the hostname up to the first `.'\n\\H     the hostname\n\\j     the number of jobs currently managed by the shell\n\\l     the basename of the shell's terminal device name\n\\n     newline\n\\r     carriage return\n\\s     the name of the shell, the basename of $0 (the portion following the final slash)\n\\t     the current time in 24-hour HH:MM:SS format\n\\T     the current time in 12-hour HH:MM:SS format\n\\@     the current time in 12-hour am/pm format\n\\A     the current time in 24-hour HH:MM format\n\\u     the username of the current user\n\\v     the version of bash (e.g., 2.00)\n\\V     the release of bash, version + patch level (e.g., 2.00.0)\n\\w     the current working directory, with $HOME abbreviated with a tilde (uses the value of the PROMPT_DIRTRIM variable)\n\\W     the basename of the current working directory, with $HOME abbreviated with a tilde\n\\!     the history number of this command\n\\#     the command number of this command\n\\$     if the effective UID is 0, a #, otherwise a $\n\\nnn   the character corresponding to the octal number nnn\n\\\\     a backslash\n\\[     begin a sequence of non-printing characters, which could be used to embed a terminal control sequence into the prompt\n\\]     end a sequence of non-printing characters\n```\n\n### 变更prompt颜色\n\n首先，大家必须以[与]作为色彩代码的描述范围。对于Bash，这代表两个括号间的字符为非输出字符。\n\nBash需要在此基础上估算字符数量，以备后续输出。如果不将色彩代码纳入[与]之间，那么Bash会将全部字符都计为文本字符并在下一行中进行打包。\n\n另外，在括号内的非输出序列中，我们需要输入\\e[或者\\033[指定彩色prompt的起点。二者的作用相同，都负责指定该反义序列的起始位置。\n\n在]之前，我们还需要使用“m”来表示即将提供一条色彩序列。\n\n基本上，每次进行色彩修改时，我们都需要输入下面这种命令格式：\n\n```\n\\[\\e[color_informationm\\]\n```\n\n下面来看用于变更前景文本颜色的基本代码：\n\n- 30: Black\n- 31: Red\n- 32: Green\n- 33: Yellow\n- 34: Blue\n- 35: Purple\n- 36: Cyan\n- 37: White\n\n大家也可以通过在以上设定前设置“属性”修改这些基础值，各值之间以分号分隔。\n\n根据实际终端的不同，操作效果也有所区别。部分常见属性包括：\n\n- 0: 普通文本\n- 1: 在不同终端中可能代表粗体或者浅色显示\n- 4: 下划线文本\n\n因此如果大家希望使用下划线绿色文本，则：`\\[\\e[4;32m\\]`\n\n接下来继续正常使用即可。另外，我们也可以随时将色彩重置为初始值。\n\n重置命令如下：\n\n```\n\\[\\e[0m\\]\n```\n\n我们也可以指定背景颜色。背景颜色无法获取属性，具体包括：\n\n- 40: Black background\n- 41: Red background\n- 42: Green background\n- 43: Yellow background\n- 44: Blue background\n- 45: Purple background\n- 46: Cyan background\n- 47: White background\n\n不过大家可以一次性指定背景颜色、属性与文本颜色：\n\n```\n\\[\\e[42;1;36m\\]\n```\n\n当然，这里建议各位将背景信息与其它信息分隔开来：\n\n```\n\\[\\e[42m\\]\\[\\e[1;36m\\]\n```\n\n在使用普通文本属性（0）时，终端中可能出现一些乱码。如果遇到这种问题，大家最好避免使用0值指定普通属性——由于属于默认值，我们无需额外指定。\n\n## 配置ls和grep的颜色\n\n```\n# Tell ls to be colourful\n export CLICOLOR=1\n export LSCOLORS=Exfxcxdxbxegedabagacad\n\n # Tell grep to highlight matches\n export GREP_OPTIONS='--color=auto’\n```\n\n- CLICOLOR是用来设置是否进行颜色的显示。CLI是Command Line Interface的缩写。\n\n- LSCOLORS是用来设置当CLICOLOR被启用后，各种文件类型的颜色。LSCOLORS的值中每两个字母为一组，分别设置某个文件类型的文字颜色和背景颜色。LSCOLORS中一共11组颜色设置，按照先后顺序，分别对以下的文件类型进行设置：\n\n![文件类型 - 文件颜色](https://upload-images.jianshu.io/upload_images/1233651-e586f58eae66c4ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)\n\n所以，如果我们想把目录显示成红色，就可以把LSCOLORS设置为fxfxaxdxcxegedabagacad就可以了\n","source":"_posts/2018/2018-05-08-Linux-Shell-配色.md","raw":"---\ntitle: Linux Shell 配色\ndate: 2018-05-08\ncategories: [Linux]\ncomments: true\n---\n\n早就想自己给bash配个色，但是一直没空学习这方面的知识，今天抽个空，搞了一点点。\n\n## 切换shell\n\n切换shell，分临时和永久。\n\n临时：输入命令：`bash`或者`zsh`都行，shell调用shell，一层套一层，按`ctrl+d`或者输入`exit`可以退出。\n永久：输入命令：`chsh -s /bin/bash`\n\n>chsh意思就是change shell，使用`man chsh`进行查看\n\n## 修改prompt\n\nprompt也就是提示符，首先就是要修改这个，什么样的提示符才是一个好的提示符呢？我觉得首要的是要短，太长的提示符占了命令的空间。其次提示符还必须显示用户名和机器名，因为只有这样才能在你远程登录的时候与远程shell区分开。机器名最好是缩写。然后我就得出了我自己的提示符的前缀：`liuqinh2s@mbp`，然后我觉得得加个短路径，不要求绝对路径，这样太占空间，只需要加个当前文件夹即可。这样进一步修改之后，我的提示符变成了：`liuqinh2s@mbp:~`，最后需要添加一个普通用户和超级用户的区分，普通用户用：`$`，超级用户用`#`，所以我的提示符最终的样子是：`liuqinh2s@mbp:~$ `，注意`$`后面我加了一个空格，这样看起来比较舒服，提示符和命令的界限一目了然。\n\n但其实还是不清晰，我就给prompt上了个颜色。\n\n最后就变成这样啦：\n\n<img src=\"https://i.loli.net/2018/05/08/5af13dcea3fa6.png\" alt=\"屏幕快照 2018-05-08 下午2.03.34.png\" title=\"屏幕快照 2018-05-08 下午2.03.34.png\" width=\"30%\" height=\"30%\"/>\n\n配置代码：`PS1=\"\\[\\e[0;32m\\]\\u@\\h:\\[\\e[0;34m\\]\\W\\$\\[\\e[0m\\] \"`\n\n>使用`export PS1=\"\\[\\e[0;32m\\]\\u@\\h:\\[\\e[0;34m\\]\\W\\$\\[\\e[0m\\] \"`，这样的话，你输入`bash`的时候，也能用到你的配置\n\n>export in sh and related shells (such as bash), marks an environment variable to be exported to child-processes, so that the child inherits them.\n\nexport的作用就是让子进程也继承环境变量\n\n如果你用的是mac的话，在home目录的`.bash_profile`中修改就可以了\n\n下面是配置代码的讲解：\n\n### Bash转义序列\n\n```\n\\a     an ASCII bell character (07)\n\\d     the date in \"Weekday Month Date\" format (e.g., \"Tue May 26\")\n\\D{format}\n       the format is passed to strftime(3) and the result is inserted into the prompt string; an empty format results in a locale-\n       specific time representation.  The braces are required\n\\e     an ASCII escape character (033)\n\\h     the hostname up to the first `.'\n\\H     the hostname\n\\j     the number of jobs currently managed by the shell\n\\l     the basename of the shell's terminal device name\n\\n     newline\n\\r     carriage return\n\\s     the name of the shell, the basename of $0 (the portion following the final slash)\n\\t     the current time in 24-hour HH:MM:SS format\n\\T     the current time in 12-hour HH:MM:SS format\n\\@     the current time in 12-hour am/pm format\n\\A     the current time in 24-hour HH:MM format\n\\u     the username of the current user\n\\v     the version of bash (e.g., 2.00)\n\\V     the release of bash, version + patch level (e.g., 2.00.0)\n\\w     the current working directory, with $HOME abbreviated with a tilde (uses the value of the PROMPT_DIRTRIM variable)\n\\W     the basename of the current working directory, with $HOME abbreviated with a tilde\n\\!     the history number of this command\n\\#     the command number of this command\n\\$     if the effective UID is 0, a #, otherwise a $\n\\nnn   the character corresponding to the octal number nnn\n\\\\     a backslash\n\\[     begin a sequence of non-printing characters, which could be used to embed a terminal control sequence into the prompt\n\\]     end a sequence of non-printing characters\n```\n\n### 变更prompt颜色\n\n首先，大家必须以[与]作为色彩代码的描述范围。对于Bash，这代表两个括号间的字符为非输出字符。\n\nBash需要在此基础上估算字符数量，以备后续输出。如果不将色彩代码纳入[与]之间，那么Bash会将全部字符都计为文本字符并在下一行中进行打包。\n\n另外，在括号内的非输出序列中，我们需要输入\\e[或者\\033[指定彩色prompt的起点。二者的作用相同，都负责指定该反义序列的起始位置。\n\n在]之前，我们还需要使用“m”来表示即将提供一条色彩序列。\n\n基本上，每次进行色彩修改时，我们都需要输入下面这种命令格式：\n\n```\n\\[\\e[color_informationm\\]\n```\n\n下面来看用于变更前景文本颜色的基本代码：\n\n- 30: Black\n- 31: Red\n- 32: Green\n- 33: Yellow\n- 34: Blue\n- 35: Purple\n- 36: Cyan\n- 37: White\n\n大家也可以通过在以上设定前设置“属性”修改这些基础值，各值之间以分号分隔。\n\n根据实际终端的不同，操作效果也有所区别。部分常见属性包括：\n\n- 0: 普通文本\n- 1: 在不同终端中可能代表粗体或者浅色显示\n- 4: 下划线文本\n\n因此如果大家希望使用下划线绿色文本，则：`\\[\\e[4;32m\\]`\n\n接下来继续正常使用即可。另外，我们也可以随时将色彩重置为初始值。\n\n重置命令如下：\n\n```\n\\[\\e[0m\\]\n```\n\n我们也可以指定背景颜色。背景颜色无法获取属性，具体包括：\n\n- 40: Black background\n- 41: Red background\n- 42: Green background\n- 43: Yellow background\n- 44: Blue background\n- 45: Purple background\n- 46: Cyan background\n- 47: White background\n\n不过大家可以一次性指定背景颜色、属性与文本颜色：\n\n```\n\\[\\e[42;1;36m\\]\n```\n\n当然，这里建议各位将背景信息与其它信息分隔开来：\n\n```\n\\[\\e[42m\\]\\[\\e[1;36m\\]\n```\n\n在使用普通文本属性（0）时，终端中可能出现一些乱码。如果遇到这种问题，大家最好避免使用0值指定普通属性——由于属于默认值，我们无需额外指定。\n\n## 配置ls和grep的颜色\n\n```\n# Tell ls to be colourful\n export CLICOLOR=1\n export LSCOLORS=Exfxcxdxbxegedabagacad\n\n # Tell grep to highlight matches\n export GREP_OPTIONS='--color=auto’\n```\n\n- CLICOLOR是用来设置是否进行颜色的显示。CLI是Command Line Interface的缩写。\n\n- LSCOLORS是用来设置当CLICOLOR被启用后，各种文件类型的颜色。LSCOLORS的值中每两个字母为一组，分别设置某个文件类型的文字颜色和背景颜色。LSCOLORS中一共11组颜色设置，按照先后顺序，分别对以下的文件类型进行设置：\n\n![文件类型 - 文件颜色](https://upload-images.jianshu.io/upload_images/1233651-e586f58eae66c4ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)\n\n所以，如果我们想把目录显示成红色，就可以把LSCOLORS设置为fxfxaxdxcxegedabagacad就可以了\n","slug":"Linux-Shell-配色","published":1,"updated":"2018-05-08T08:33:55.427Z","layout":"post","photos":[],"link":"","_id":"cjm2w8dds0035fgpxnfsgt1o2","content":"<p>早就想自己给bash配个色，但是一直没空学习这方面的知识，今天抽个空，搞了一点点。</p>\n<h2 id=\"切换shell\"><a href=\"#切换shell\" class=\"headerlink\" title=\"切换shell\"></a>切换shell</h2><p>切换shell，分临时和永久。</p>\n<p>临时：输入命令：<code>bash</code>或者<code>zsh</code>都行，shell调用shell，一层套一层，按<code>ctrl+d</code>或者输入<code>exit</code>可以退出。<br>永久：输入命令：<code>chsh -s /bin/bash</code></p>\n<blockquote>\n<p>chsh意思就是change shell，使用<code>man chsh</code>进行查看</p>\n</blockquote>\n<h2 id=\"修改prompt\"><a href=\"#修改prompt\" class=\"headerlink\" title=\"修改prompt\"></a>修改prompt</h2><p>prompt也就是提示符，首先就是要修改这个，什么样的提示符才是一个好的提示符呢？我觉得首要的是要短，太长的提示符占了命令的空间。其次提示符还必须显示用户名和机器名，因为只有这样才能在你远程登录的时候与远程shell区分开。机器名最好是缩写。然后我就得出了我自己的提示符的前缀：<code>liuqinh2s@mbp</code>，然后我觉得得加个短路径，不要求绝对路径，这样太占空间，只需要加个当前文件夹即可。这样进一步修改之后，我的提示符变成了：<code>liuqinh2s@mbp:~</code>，最后需要添加一个普通用户和超级用户的区分，普通用户用：<code>$</code>，超级用户用<code>#</code>，所以我的提示符最终的样子是：<code>liuqinh2s@mbp:~$</code>，注意<code>$</code>后面我加了一个空格，这样看起来比较舒服，提示符和命令的界限一目了然。</p>\n<p>但其实还是不清晰，我就给prompt上了个颜色。</p>\n<p>最后就变成这样啦：</p>\n<p><img src=\"https://i.loli.net/2018/05/08/5af13dcea3fa6.png\" alt=\"屏幕快照 2018-05-08 下午2.03.34.png\" title=\"屏幕快照 2018-05-08 下午2.03.34.png\" width=\"30%\" height=\"30%\"></p>\n<p>配置代码：<code>PS1=&quot;\\[\\e[0;32m\\]\\u@\\h:\\[\\e[0;34m\\]\\W\\$\\[\\e[0m\\] &quot;</code></p>\n<blockquote>\n<p>使用<code>export PS1=&quot;\\[\\e[0;32m\\]\\u@\\h:\\[\\e[0;34m\\]\\W\\$\\[\\e[0m\\] &quot;</code>，这样的话，你输入<code>bash</code>的时候，也能用到你的配置</p>\n</blockquote>\n<blockquote>\n<p>export in sh and related shells (such as bash), marks an environment variable to be exported to child-processes, so that the child inherits them.</p>\n</blockquote>\n<p>export的作用就是让子进程也继承环境变量</p>\n<p>如果你用的是mac的话，在home目录的<code>.bash_profile</code>中修改就可以了</p>\n<p>下面是配置代码的讲解：</p>\n<h3 id=\"Bash转义序列\"><a href=\"#Bash转义序列\" class=\"headerlink\" title=\"Bash转义序列\"></a>Bash转义序列</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\a     an ASCII bell character (07)</span><br><span class=\"line\">\\d     the date in &quot;Weekday Month Date&quot; format (e.g., &quot;Tue May 26&quot;)</span><br><span class=\"line\">\\D&#123;format&#125;</span><br><span class=\"line\">       the format is passed to strftime(3) and the result is inserted into the prompt string; an empty format results in a locale-</span><br><span class=\"line\">       specific time representation.  The braces are required</span><br><span class=\"line\">\\e     an ASCII escape character (033)</span><br><span class=\"line\">\\h     the hostname up to the first `.&apos;</span><br><span class=\"line\">\\H     the hostname</span><br><span class=\"line\">\\j     the number of jobs currently managed by the shell</span><br><span class=\"line\">\\l     the basename of the shell&apos;s terminal device name</span><br><span class=\"line\">\\n     newline</span><br><span class=\"line\">\\r     carriage return</span><br><span class=\"line\">\\s     the name of the shell, the basename of $0 (the portion following the final slash)</span><br><span class=\"line\">\\t     the current time in 24-hour HH:MM:SS format</span><br><span class=\"line\">\\T     the current time in 12-hour HH:MM:SS format</span><br><span class=\"line\">\\@     the current time in 12-hour am/pm format</span><br><span class=\"line\">\\A     the current time in 24-hour HH:MM format</span><br><span class=\"line\">\\u     the username of the current user</span><br><span class=\"line\">\\v     the version of bash (e.g., 2.00)</span><br><span class=\"line\">\\V     the release of bash, version + patch level (e.g., 2.00.0)</span><br><span class=\"line\">\\w     the current working directory, with $HOME abbreviated with a tilde (uses the value of the PROMPT_DIRTRIM variable)</span><br><span class=\"line\">\\W     the basename of the current working directory, with $HOME abbreviated with a tilde</span><br><span class=\"line\">\\!     the history number of this command</span><br><span class=\"line\">\\#     the command number of this command</span><br><span class=\"line\">\\$     if the effective UID is 0, a #, otherwise a $</span><br><span class=\"line\">\\nnn   the character corresponding to the octal number nnn</span><br><span class=\"line\">\\\\     a backslash</span><br><span class=\"line\">\\[     begin a sequence of non-printing characters, which could be used to embed a terminal control sequence into the prompt</span><br><span class=\"line\">\\]     end a sequence of non-printing characters</span><br></pre></td></tr></table></figure>\n<h3 id=\"变更prompt颜色\"><a href=\"#变更prompt颜色\" class=\"headerlink\" title=\"变更prompt颜色\"></a>变更prompt颜色</h3><p>首先，大家必须以[与]作为色彩代码的描述范围。对于Bash，这代表两个括号间的字符为非输出字符。</p>\n<p>Bash需要在此基础上估算字符数量，以备后续输出。如果不将色彩代码纳入[与]之间，那么Bash会将全部字符都计为文本字符并在下一行中进行打包。</p>\n<p>另外，在括号内的非输出序列中，我们需要输入\\e[或者\\033[指定彩色prompt的起点。二者的作用相同，都负责指定该反义序列的起始位置。</p>\n<p>在]之前，我们还需要使用“m”来表示即将提供一条色彩序列。</p>\n<p>基本上，每次进行色彩修改时，我们都需要输入下面这种命令格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\[\\e[color_informationm\\]</span><br></pre></td></tr></table></figure>\n<p>下面来看用于变更前景文本颜色的基本代码：</p>\n<ul>\n<li>30: Black</li>\n<li>31: Red</li>\n<li>32: Green</li>\n<li>33: Yellow</li>\n<li>34: Blue</li>\n<li>35: Purple</li>\n<li>36: Cyan</li>\n<li>37: White</li>\n</ul>\n<p>大家也可以通过在以上设定前设置“属性”修改这些基础值，各值之间以分号分隔。</p>\n<p>根据实际终端的不同，操作效果也有所区别。部分常见属性包括：</p>\n<ul>\n<li>0: 普通文本</li>\n<li>1: 在不同终端中可能代表粗体或者浅色显示</li>\n<li>4: 下划线文本</li>\n</ul>\n<p>因此如果大家希望使用下划线绿色文本，则：<code>\\[\\e[4;32m\\]</code></p>\n<p>接下来继续正常使用即可。另外，我们也可以随时将色彩重置为初始值。</p>\n<p>重置命令如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\[\\e[0m\\]</span><br></pre></td></tr></table></figure>\n<p>我们也可以指定背景颜色。背景颜色无法获取属性，具体包括：</p>\n<ul>\n<li>40: Black background</li>\n<li>41: Red background</li>\n<li>42: Green background</li>\n<li>43: Yellow background</li>\n<li>44: Blue background</li>\n<li>45: Purple background</li>\n<li>46: Cyan background</li>\n<li>47: White background</li>\n</ul>\n<p>不过大家可以一次性指定背景颜色、属性与文本颜色：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\[\\e[42;1;36m\\]</span><br></pre></td></tr></table></figure>\n<p>当然，这里建议各位将背景信息与其它信息分隔开来：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\[\\e[42m\\]\\[\\e[1;36m\\]</span><br></pre></td></tr></table></figure>\n<p>在使用普通文本属性（0）时，终端中可能出现一些乱码。如果遇到这种问题，大家最好避免使用0值指定普通属性——由于属于默认值，我们无需额外指定。</p>\n<h2 id=\"配置ls和grep的颜色\"><a href=\"#配置ls和grep的颜色\" class=\"headerlink\" title=\"配置ls和grep的颜色\"></a>配置ls和grep的颜色</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Tell ls to be colourful</span><br><span class=\"line\"> export CLICOLOR=1</span><br><span class=\"line\"> export LSCOLORS=Exfxcxdxbxegedabagacad</span><br><span class=\"line\"></span><br><span class=\"line\"> # Tell grep to highlight matches</span><br><span class=\"line\"> export GREP_OPTIONS=&apos;--color=auto’</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>CLICOLOR是用来设置是否进行颜色的显示。CLI是Command Line Interface的缩写。</p>\n</li>\n<li><p>LSCOLORS是用来设置当CLICOLOR被启用后，各种文件类型的颜色。LSCOLORS的值中每两个字母为一组，分别设置某个文件类型的文字颜色和背景颜色。LSCOLORS中一共11组颜色设置，按照先后顺序，分别对以下的文件类型进行设置：</p>\n</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1233651-e586f58eae66c4ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700\" alt=\"文件类型 - 文件颜色\"></p>\n<p>所以，如果我们想把目录显示成红色，就可以把LSCOLORS设置为fxfxaxdxcxegedabagacad就可以了</p>\n","site":{"data":{}},"excerpt":"","more":"<p>早就想自己给bash配个色，但是一直没空学习这方面的知识，今天抽个空，搞了一点点。</p>\n<h2 id=\"切换shell\"><a href=\"#切换shell\" class=\"headerlink\" title=\"切换shell\"></a>切换shell</h2><p>切换shell，分临时和永久。</p>\n<p>临时：输入命令：<code>bash</code>或者<code>zsh</code>都行，shell调用shell，一层套一层，按<code>ctrl+d</code>或者输入<code>exit</code>可以退出。<br>永久：输入命令：<code>chsh -s /bin/bash</code></p>\n<blockquote>\n<p>chsh意思就是change shell，使用<code>man chsh</code>进行查看</p>\n</blockquote>\n<h2 id=\"修改prompt\"><a href=\"#修改prompt\" class=\"headerlink\" title=\"修改prompt\"></a>修改prompt</h2><p>prompt也就是提示符，首先就是要修改这个，什么样的提示符才是一个好的提示符呢？我觉得首要的是要短，太长的提示符占了命令的空间。其次提示符还必须显示用户名和机器名，因为只有这样才能在你远程登录的时候与远程shell区分开。机器名最好是缩写。然后我就得出了我自己的提示符的前缀：<code>liuqinh2s@mbp</code>，然后我觉得得加个短路径，不要求绝对路径，这样太占空间，只需要加个当前文件夹即可。这样进一步修改之后，我的提示符变成了：<code>liuqinh2s@mbp:~</code>，最后需要添加一个普通用户和超级用户的区分，普通用户用：<code>$</code>，超级用户用<code>#</code>，所以我的提示符最终的样子是：<code>liuqinh2s@mbp:~$</code>，注意<code>$</code>后面我加了一个空格，这样看起来比较舒服，提示符和命令的界限一目了然。</p>\n<p>但其实还是不清晰，我就给prompt上了个颜色。</p>\n<p>最后就变成这样啦：</p>\n<p><img src=\"https://i.loli.net/2018/05/08/5af13dcea3fa6.png\" alt=\"屏幕快照 2018-05-08 下午2.03.34.png\" title=\"屏幕快照 2018-05-08 下午2.03.34.png\" width=\"30%\" height=\"30%\"></p>\n<p>配置代码：<code>PS1=&quot;\\[\\e[0;32m\\]\\u@\\h:\\[\\e[0;34m\\]\\W\\$\\[\\e[0m\\] &quot;</code></p>\n<blockquote>\n<p>使用<code>export PS1=&quot;\\[\\e[0;32m\\]\\u@\\h:\\[\\e[0;34m\\]\\W\\$\\[\\e[0m\\] &quot;</code>，这样的话，你输入<code>bash</code>的时候，也能用到你的配置</p>\n</blockquote>\n<blockquote>\n<p>export in sh and related shells (such as bash), marks an environment variable to be exported to child-processes, so that the child inherits them.</p>\n</blockquote>\n<p>export的作用就是让子进程也继承环境变量</p>\n<p>如果你用的是mac的话，在home目录的<code>.bash_profile</code>中修改就可以了</p>\n<p>下面是配置代码的讲解：</p>\n<h3 id=\"Bash转义序列\"><a href=\"#Bash转义序列\" class=\"headerlink\" title=\"Bash转义序列\"></a>Bash转义序列</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\a     an ASCII bell character (07)</span><br><span class=\"line\">\\d     the date in &quot;Weekday Month Date&quot; format (e.g., &quot;Tue May 26&quot;)</span><br><span class=\"line\">\\D&#123;format&#125;</span><br><span class=\"line\">       the format is passed to strftime(3) and the result is inserted into the prompt string; an empty format results in a locale-</span><br><span class=\"line\">       specific time representation.  The braces are required</span><br><span class=\"line\">\\e     an ASCII escape character (033)</span><br><span class=\"line\">\\h     the hostname up to the first `.&apos;</span><br><span class=\"line\">\\H     the hostname</span><br><span class=\"line\">\\j     the number of jobs currently managed by the shell</span><br><span class=\"line\">\\l     the basename of the shell&apos;s terminal device name</span><br><span class=\"line\">\\n     newline</span><br><span class=\"line\">\\r     carriage return</span><br><span class=\"line\">\\s     the name of the shell, the basename of $0 (the portion following the final slash)</span><br><span class=\"line\">\\t     the current time in 24-hour HH:MM:SS format</span><br><span class=\"line\">\\T     the current time in 12-hour HH:MM:SS format</span><br><span class=\"line\">\\@     the current time in 12-hour am/pm format</span><br><span class=\"line\">\\A     the current time in 24-hour HH:MM format</span><br><span class=\"line\">\\u     the username of the current user</span><br><span class=\"line\">\\v     the version of bash (e.g., 2.00)</span><br><span class=\"line\">\\V     the release of bash, version + patch level (e.g., 2.00.0)</span><br><span class=\"line\">\\w     the current working directory, with $HOME abbreviated with a tilde (uses the value of the PROMPT_DIRTRIM variable)</span><br><span class=\"line\">\\W     the basename of the current working directory, with $HOME abbreviated with a tilde</span><br><span class=\"line\">\\!     the history number of this command</span><br><span class=\"line\">\\#     the command number of this command</span><br><span class=\"line\">\\$     if the effective UID is 0, a #, otherwise a $</span><br><span class=\"line\">\\nnn   the character corresponding to the octal number nnn</span><br><span class=\"line\">\\\\     a backslash</span><br><span class=\"line\">\\[     begin a sequence of non-printing characters, which could be used to embed a terminal control sequence into the prompt</span><br><span class=\"line\">\\]     end a sequence of non-printing characters</span><br></pre></td></tr></table></figure>\n<h3 id=\"变更prompt颜色\"><a href=\"#变更prompt颜色\" class=\"headerlink\" title=\"变更prompt颜色\"></a>变更prompt颜色</h3><p>首先，大家必须以[与]作为色彩代码的描述范围。对于Bash，这代表两个括号间的字符为非输出字符。</p>\n<p>Bash需要在此基础上估算字符数量，以备后续输出。如果不将色彩代码纳入[与]之间，那么Bash会将全部字符都计为文本字符并在下一行中进行打包。</p>\n<p>另外，在括号内的非输出序列中，我们需要输入\\e[或者\\033[指定彩色prompt的起点。二者的作用相同，都负责指定该反义序列的起始位置。</p>\n<p>在]之前，我们还需要使用“m”来表示即将提供一条色彩序列。</p>\n<p>基本上，每次进行色彩修改时，我们都需要输入下面这种命令格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\[\\e[color_informationm\\]</span><br></pre></td></tr></table></figure>\n<p>下面来看用于变更前景文本颜色的基本代码：</p>\n<ul>\n<li>30: Black</li>\n<li>31: Red</li>\n<li>32: Green</li>\n<li>33: Yellow</li>\n<li>34: Blue</li>\n<li>35: Purple</li>\n<li>36: Cyan</li>\n<li>37: White</li>\n</ul>\n<p>大家也可以通过在以上设定前设置“属性”修改这些基础值，各值之间以分号分隔。</p>\n<p>根据实际终端的不同，操作效果也有所区别。部分常见属性包括：</p>\n<ul>\n<li>0: 普通文本</li>\n<li>1: 在不同终端中可能代表粗体或者浅色显示</li>\n<li>4: 下划线文本</li>\n</ul>\n<p>因此如果大家希望使用下划线绿色文本，则：<code>\\[\\e[4;32m\\]</code></p>\n<p>接下来继续正常使用即可。另外，我们也可以随时将色彩重置为初始值。</p>\n<p>重置命令如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\[\\e[0m\\]</span><br></pre></td></tr></table></figure>\n<p>我们也可以指定背景颜色。背景颜色无法获取属性，具体包括：</p>\n<ul>\n<li>40: Black background</li>\n<li>41: Red background</li>\n<li>42: Green background</li>\n<li>43: Yellow background</li>\n<li>44: Blue background</li>\n<li>45: Purple background</li>\n<li>46: Cyan background</li>\n<li>47: White background</li>\n</ul>\n<p>不过大家可以一次性指定背景颜色、属性与文本颜色：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\[\\e[42;1;36m\\]</span><br></pre></td></tr></table></figure>\n<p>当然，这里建议各位将背景信息与其它信息分隔开来：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\\[\\e[42m\\]\\[\\e[1;36m\\]</span><br></pre></td></tr></table></figure>\n<p>在使用普通文本属性（0）时，终端中可能出现一些乱码。如果遇到这种问题，大家最好避免使用0值指定普通属性——由于属于默认值，我们无需额外指定。</p>\n<h2 id=\"配置ls和grep的颜色\"><a href=\"#配置ls和grep的颜色\" class=\"headerlink\" title=\"配置ls和grep的颜色\"></a>配置ls和grep的颜色</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Tell ls to be colourful</span><br><span class=\"line\"> export CLICOLOR=1</span><br><span class=\"line\"> export LSCOLORS=Exfxcxdxbxegedabagacad</span><br><span class=\"line\"></span><br><span class=\"line\"> # Tell grep to highlight matches</span><br><span class=\"line\"> export GREP_OPTIONS=&apos;--color=auto’</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>CLICOLOR是用来设置是否进行颜色的显示。CLI是Command Line Interface的缩写。</p>\n</li>\n<li><p>LSCOLORS是用来设置当CLICOLOR被启用后，各种文件类型的颜色。LSCOLORS的值中每两个字母为一组，分别设置某个文件类型的文字颜色和背景颜色。LSCOLORS中一共11组颜色设置，按照先后顺序，分别对以下的文件类型进行设置：</p>\n</li>\n</ul>\n<p><img src=\"https://upload-images.jianshu.io/upload_images/1233651-e586f58eae66c4ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700\" alt=\"文件类型 - 文件颜色\"></p>\n<p>所以，如果我们想把目录显示成红色，就可以把LSCOLORS设置为fxfxaxdxcxegedabagacad就可以了</p>\n"},{"title":"投奔vim系列之--NerdTree插件的使用","date":"2018-05-13T16:00:00.000Z","comments":1,"_content":"\n## NERDTree的使用\n\n### 切换工作台和目录\n\n```\nctrl+w+h    光标focus左侧树形目录\nctrl+w+l    光标focus右侧文件显示窗口\nctrl+w+w    光标自动在左右侧窗口切换\nctrl+w+r    移动当前窗口的布局位置\n```\n\n```\no   在已有窗口中打开文件、目录或书签，并跳到该窗口\ngo  在已有窗口中打开文件、目录或书签，但不跳到该窗口\nt   在新Tab中打开选中文件/书签，并跳到新Tab\nT   在新Tab中打开选中文件/书签，但不跳到新Tab\ni   split一个新窗口打开选中文件，并跳到该窗口\ngi  split一个新窗口打开选中文件，但不跳到该窗口\ns   vsplit一个新窗口打开选中文件，并跳到该窗口\ngs  vsplit一个新窗口打开选中文件，但不跳到该窗口\n!   执行当前文件\nO   递归打开选中结点下的所有目录\nx   合拢选中结点的父目录\nX   递归合拢选中结点下的所有目录\ne   Edit the current dif\n\nD   删除当前书签\n\nP   跳到根节点\np   跳到父节点\nK   跳到当前目录下同级的第一个结点\nJ   跳到当前目录下同级的最后一个结点\nk   跳到当前目录下同级的前一个结点\nj   跳到当前目录下同级的后一个结点\n\nC   将选中目录或选中文件的父目录设为根节点\nu   将当前根节点的父目录设为根目录，并变成合拢原根节点\nU   将当前根节点的父目录设为根目录，但保持展开原根节点\nr   递归刷新选中目录\nR   递归刷新根节点\nm   显示文件系统菜单\ncd  将CWD设为选中目录\n\nI   切换是否显示隐藏文件\nf   切换是否使用文件过滤器\nF   切换是否显示文件\nB   切换是否显示书签\n\nq   关闭NerdTree窗口\n?  切换是否显示Quick help\n```\n\n### 切换标签页\n\n```\n:tabnew [++opt选项] [+cmd]  文件    建立对指定文件新的tab\n:tabc   关闭当前的tab\n:tabo   关闭所有其他的tab\n:tabs   查看所有打开的tab\n:tabp   前一个tab\n:tabn   后一个tab\n\n标准模式下：\ngT  前一个tab\ngt  后一个tab\n\nMacVim还可以借助快捷键来完成tab的关闭、切换\ncmd+w   关闭当前的tab\ncmd+{   前一个tab\ncmd+}   后一个tab\n```\n\n### NerdTree在.vimrc中的常用配置\n\n```\n\" 在 vim 启动的时候默认开启 NERDTree（autocmd 可以缩写为 au）\nautocmd VimEnter * NERDTree\n\n\" 按下 F2 调出/隐藏 NERDTree\nmap  :silent! NERDTreeToggle\n\n\" 将 NERDTree 的窗口设置在 vim 窗口的右侧（默认为左侧）\nlet NERDTreeWinPos=\"right\"\n\n\" 当打开 NERDTree 窗口时，自动显示 Bookmarks\nlet NERDTreeShowBookmarks=1\n```\n\n### 一些简单问题的解决方案\n\n- 以上提到了怎么关闭tab，但没有提到怎么关闭窗口。关于怎么关闭一个窗口，其实很简单，只要使用vim的命令：`:wq`即可:\n- 怎么在vim中创建一个文件：`:e %:h/filename`，这是在当前目录下新建一个文件\n- 在mac osx中遇到一个问题，insert模式下delete键无法删除文字，发出恼人的duang duang duang声音，出现这个问题，基本是因为你的VIM使用了compatible模式，或者把`backspace`变量设置为空了。好奇的读者一定会问，这两个配置又代表了什么意思？其实compatible模式是VIM为了兼容vi而出现的配置，它的作用是使VIM的操作行为和规范和vi一致，而这种模式下backspace配置是空的。即意味着backspace无法删除`indent`，`end of line`，`start`这三种字符。如果你出现了和博主一样的情况，不妨在解决问题前先在VIM中用set backspace?命令查看下自己当前的删除模式。如果`backspace`为空，效果就相当于delete只能删除本次insert模式中输入的字符。那么为什么backspace=2又能解决问题呢？其实这个命令是set backspace=indent,eol,start的简化写法，也就相当于把delete键配置成增强模式。具体数值和对应增强模式的对应关系见 vim官方文档，简单摘录如下：\n\n- 1 same as “:set backspace=” (Vi compatible)\n- 2 same as “:set backspace=indent,eol”\n- 3 same as “:set backspace=indent,eol,start”\n\n还有个问题就是，在进入visual block模式，进行列编辑的时候，按I或者A发现没反应，最后发现要先输入你要输入的东西，然后再按I或者A，而不是先按I或者A再进行输入。\n","source":"_posts/2018/2018-05-14-投奔vim系列之--NerdTree插件的使用.md","raw":"---\ntitle: 投奔vim系列之--NerdTree插件的使用\ndate: 2018-05-14\ncategories: [vim]\ncomments: true\n---\n\n## NERDTree的使用\n\n### 切换工作台和目录\n\n```\nctrl+w+h    光标focus左侧树形目录\nctrl+w+l    光标focus右侧文件显示窗口\nctrl+w+w    光标自动在左右侧窗口切换\nctrl+w+r    移动当前窗口的布局位置\n```\n\n```\no   在已有窗口中打开文件、目录或书签，并跳到该窗口\ngo  在已有窗口中打开文件、目录或书签，但不跳到该窗口\nt   在新Tab中打开选中文件/书签，并跳到新Tab\nT   在新Tab中打开选中文件/书签，但不跳到新Tab\ni   split一个新窗口打开选中文件，并跳到该窗口\ngi  split一个新窗口打开选中文件，但不跳到该窗口\ns   vsplit一个新窗口打开选中文件，并跳到该窗口\ngs  vsplit一个新窗口打开选中文件，但不跳到该窗口\n!   执行当前文件\nO   递归打开选中结点下的所有目录\nx   合拢选中结点的父目录\nX   递归合拢选中结点下的所有目录\ne   Edit the current dif\n\nD   删除当前书签\n\nP   跳到根节点\np   跳到父节点\nK   跳到当前目录下同级的第一个结点\nJ   跳到当前目录下同级的最后一个结点\nk   跳到当前目录下同级的前一个结点\nj   跳到当前目录下同级的后一个结点\n\nC   将选中目录或选中文件的父目录设为根节点\nu   将当前根节点的父目录设为根目录，并变成合拢原根节点\nU   将当前根节点的父目录设为根目录，但保持展开原根节点\nr   递归刷新选中目录\nR   递归刷新根节点\nm   显示文件系统菜单\ncd  将CWD设为选中目录\n\nI   切换是否显示隐藏文件\nf   切换是否使用文件过滤器\nF   切换是否显示文件\nB   切换是否显示书签\n\nq   关闭NerdTree窗口\n?  切换是否显示Quick help\n```\n\n### 切换标签页\n\n```\n:tabnew [++opt选项] [+cmd]  文件    建立对指定文件新的tab\n:tabc   关闭当前的tab\n:tabo   关闭所有其他的tab\n:tabs   查看所有打开的tab\n:tabp   前一个tab\n:tabn   后一个tab\n\n标准模式下：\ngT  前一个tab\ngt  后一个tab\n\nMacVim还可以借助快捷键来完成tab的关闭、切换\ncmd+w   关闭当前的tab\ncmd+{   前一个tab\ncmd+}   后一个tab\n```\n\n### NerdTree在.vimrc中的常用配置\n\n```\n\" 在 vim 启动的时候默认开启 NERDTree（autocmd 可以缩写为 au）\nautocmd VimEnter * NERDTree\n\n\" 按下 F2 调出/隐藏 NERDTree\nmap  :silent! NERDTreeToggle\n\n\" 将 NERDTree 的窗口设置在 vim 窗口的右侧（默认为左侧）\nlet NERDTreeWinPos=\"right\"\n\n\" 当打开 NERDTree 窗口时，自动显示 Bookmarks\nlet NERDTreeShowBookmarks=1\n```\n\n### 一些简单问题的解决方案\n\n- 以上提到了怎么关闭tab，但没有提到怎么关闭窗口。关于怎么关闭一个窗口，其实很简单，只要使用vim的命令：`:wq`即可:\n- 怎么在vim中创建一个文件：`:e %:h/filename`，这是在当前目录下新建一个文件\n- 在mac osx中遇到一个问题，insert模式下delete键无法删除文字，发出恼人的duang duang duang声音，出现这个问题，基本是因为你的VIM使用了compatible模式，或者把`backspace`变量设置为空了。好奇的读者一定会问，这两个配置又代表了什么意思？其实compatible模式是VIM为了兼容vi而出现的配置，它的作用是使VIM的操作行为和规范和vi一致，而这种模式下backspace配置是空的。即意味着backspace无法删除`indent`，`end of line`，`start`这三种字符。如果你出现了和博主一样的情况，不妨在解决问题前先在VIM中用set backspace?命令查看下自己当前的删除模式。如果`backspace`为空，效果就相当于delete只能删除本次insert模式中输入的字符。那么为什么backspace=2又能解决问题呢？其实这个命令是set backspace=indent,eol,start的简化写法，也就相当于把delete键配置成增强模式。具体数值和对应增强模式的对应关系见 vim官方文档，简单摘录如下：\n\n- 1 same as “:set backspace=” (Vi compatible)\n- 2 same as “:set backspace=indent,eol”\n- 3 same as “:set backspace=indent,eol,start”\n\n还有个问题就是，在进入visual block模式，进行列编辑的时候，按I或者A发现没反应，最后发现要先输入你要输入的东西，然后再按I或者A，而不是先按I或者A再进行输入。\n","slug":"投奔vim系列之--NerdTree插件的使用","published":1,"updated":"2018-05-17T08:23:07.278Z","layout":"post","photos":[],"link":"","_id":"cjm2w8ddt0037fgpx9mg6m22w","content":"<h2 id=\"NERDTree的使用\"><a href=\"#NERDTree的使用\" class=\"headerlink\" title=\"NERDTree的使用\"></a>NERDTree的使用</h2><h3 id=\"切换工作台和目录\"><a href=\"#切换工作台和目录\" class=\"headerlink\" title=\"切换工作台和目录\"></a>切换工作台和目录</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ctrl+w+h    光标focus左侧树形目录</span><br><span class=\"line\">ctrl+w+l    光标focus右侧文件显示窗口</span><br><span class=\"line\">ctrl+w+w    光标自动在左右侧窗口切换</span><br><span class=\"line\">ctrl+w+r    移动当前窗口的布局位置</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">o   在已有窗口中打开文件、目录或书签，并跳到该窗口</span><br><span class=\"line\">go  在已有窗口中打开文件、目录或书签，但不跳到该窗口</span><br><span class=\"line\">t   在新Tab中打开选中文件/书签，并跳到新Tab</span><br><span class=\"line\">T   在新Tab中打开选中文件/书签，但不跳到新Tab</span><br><span class=\"line\">i   split一个新窗口打开选中文件，并跳到该窗口</span><br><span class=\"line\">gi  split一个新窗口打开选中文件，但不跳到该窗口</span><br><span class=\"line\">s   vsplit一个新窗口打开选中文件，并跳到该窗口</span><br><span class=\"line\">gs  vsplit一个新窗口打开选中文件，但不跳到该窗口</span><br><span class=\"line\">!   执行当前文件</span><br><span class=\"line\">O   递归打开选中结点下的所有目录</span><br><span class=\"line\">x   合拢选中结点的父目录</span><br><span class=\"line\">X   递归合拢选中结点下的所有目录</span><br><span class=\"line\">e   Edit the current dif</span><br><span class=\"line\"></span><br><span class=\"line\">D   删除当前书签</span><br><span class=\"line\"></span><br><span class=\"line\">P   跳到根节点</span><br><span class=\"line\">p   跳到父节点</span><br><span class=\"line\">K   跳到当前目录下同级的第一个结点</span><br><span class=\"line\">J   跳到当前目录下同级的最后一个结点</span><br><span class=\"line\">k   跳到当前目录下同级的前一个结点</span><br><span class=\"line\">j   跳到当前目录下同级的后一个结点</span><br><span class=\"line\"></span><br><span class=\"line\">C   将选中目录或选中文件的父目录设为根节点</span><br><span class=\"line\">u   将当前根节点的父目录设为根目录，并变成合拢原根节点</span><br><span class=\"line\">U   将当前根节点的父目录设为根目录，但保持展开原根节点</span><br><span class=\"line\">r   递归刷新选中目录</span><br><span class=\"line\">R   递归刷新根节点</span><br><span class=\"line\">m   显示文件系统菜单</span><br><span class=\"line\">cd  将CWD设为选中目录</span><br><span class=\"line\"></span><br><span class=\"line\">I   切换是否显示隐藏文件</span><br><span class=\"line\">f   切换是否使用文件过滤器</span><br><span class=\"line\">F   切换是否显示文件</span><br><span class=\"line\">B   切换是否显示书签</span><br><span class=\"line\"></span><br><span class=\"line\">q   关闭NerdTree窗口</span><br><span class=\"line\">?  切换是否显示Quick help</span><br></pre></td></tr></table></figure>\n<h3 id=\"切换标签页\"><a href=\"#切换标签页\" class=\"headerlink\" title=\"切换标签页\"></a>切换标签页</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:tabnew [++opt选项] [+cmd]  文件    建立对指定文件新的tab</span><br><span class=\"line\">:tabc   关闭当前的tab</span><br><span class=\"line\">:tabo   关闭所有其他的tab</span><br><span class=\"line\">:tabs   查看所有打开的tab</span><br><span class=\"line\">:tabp   前一个tab</span><br><span class=\"line\">:tabn   后一个tab</span><br><span class=\"line\"></span><br><span class=\"line\">标准模式下：</span><br><span class=\"line\">gT  前一个tab</span><br><span class=\"line\">gt  后一个tab</span><br><span class=\"line\"></span><br><span class=\"line\">MacVim还可以借助快捷键来完成tab的关闭、切换</span><br><span class=\"line\">cmd+w   关闭当前的tab</span><br><span class=\"line\">cmd+&#123;   前一个tab</span><br><span class=\"line\">cmd+&#125;   后一个tab</span><br></pre></td></tr></table></figure>\n<h3 id=\"NerdTree在-vimrc中的常用配置\"><a href=\"#NerdTree在-vimrc中的常用配置\" class=\"headerlink\" title=\"NerdTree在.vimrc中的常用配置\"></a>NerdTree在.vimrc中的常用配置</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot; 在 vim 启动的时候默认开启 NERDTree（autocmd 可以缩写为 au）</span><br><span class=\"line\">autocmd VimEnter * NERDTree</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; 按下 F2 调出/隐藏 NERDTree</span><br><span class=\"line\">map  :silent! NERDTreeToggle</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; 将 NERDTree 的窗口设置在 vim 窗口的右侧（默认为左侧）</span><br><span class=\"line\">let NERDTreeWinPos=&quot;right&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; 当打开 NERDTree 窗口时，自动显示 Bookmarks</span><br><span class=\"line\">let NERDTreeShowBookmarks=1</span><br></pre></td></tr></table></figure>\n<h3 id=\"一些简单问题的解决方案\"><a href=\"#一些简单问题的解决方案\" class=\"headerlink\" title=\"一些简单问题的解决方案\"></a>一些简单问题的解决方案</h3><ul>\n<li>以上提到了怎么关闭tab，但没有提到怎么关闭窗口。关于怎么关闭一个窗口，其实很简单，只要使用vim的命令：<code>:wq</code>即可:</li>\n<li>怎么在vim中创建一个文件：<code>:e %:h/filename</code>，这是在当前目录下新建一个文件</li>\n<li><p>在mac osx中遇到一个问题，insert模式下delete键无法删除文字，发出恼人的duang duang duang声音，出现这个问题，基本是因为你的VIM使用了compatible模式，或者把<code>backspace</code>变量设置为空了。好奇的读者一定会问，这两个配置又代表了什么意思？其实compatible模式是VIM为了兼容vi而出现的配置，它的作用是使VIM的操作行为和规范和vi一致，而这种模式下backspace配置是空的。即意味着backspace无法删除<code>indent</code>，<code>end of line</code>，<code>start</code>这三种字符。如果你出现了和博主一样的情况，不妨在解决问题前先在VIM中用set backspace?命令查看下自己当前的删除模式。如果<code>backspace</code>为空，效果就相当于delete只能删除本次insert模式中输入的字符。那么为什么backspace=2又能解决问题呢？其实这个命令是set backspace=indent,eol,start的简化写法，也就相当于把delete键配置成增强模式。具体数值和对应增强模式的对应关系见 vim官方文档，简单摘录如下：</p>\n</li>\n<li><p>1 same as “:set backspace=” (Vi compatible)</p>\n</li>\n<li>2 same as “:set backspace=indent,eol”</li>\n<li>3 same as “:set backspace=indent,eol,start”</li>\n</ul>\n<p>还有个问题就是，在进入visual block模式，进行列编辑的时候，按I或者A发现没反应，最后发现要先输入你要输入的东西，然后再按I或者A，而不是先按I或者A再进行输入。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"NERDTree的使用\"><a href=\"#NERDTree的使用\" class=\"headerlink\" title=\"NERDTree的使用\"></a>NERDTree的使用</h2><h3 id=\"切换工作台和目录\"><a href=\"#切换工作台和目录\" class=\"headerlink\" title=\"切换工作台和目录\"></a>切换工作台和目录</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ctrl+w+h    光标focus左侧树形目录</span><br><span class=\"line\">ctrl+w+l    光标focus右侧文件显示窗口</span><br><span class=\"line\">ctrl+w+w    光标自动在左右侧窗口切换</span><br><span class=\"line\">ctrl+w+r    移动当前窗口的布局位置</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">o   在已有窗口中打开文件、目录或书签，并跳到该窗口</span><br><span class=\"line\">go  在已有窗口中打开文件、目录或书签，但不跳到该窗口</span><br><span class=\"line\">t   在新Tab中打开选中文件/书签，并跳到新Tab</span><br><span class=\"line\">T   在新Tab中打开选中文件/书签，但不跳到新Tab</span><br><span class=\"line\">i   split一个新窗口打开选中文件，并跳到该窗口</span><br><span class=\"line\">gi  split一个新窗口打开选中文件，但不跳到该窗口</span><br><span class=\"line\">s   vsplit一个新窗口打开选中文件，并跳到该窗口</span><br><span class=\"line\">gs  vsplit一个新窗口打开选中文件，但不跳到该窗口</span><br><span class=\"line\">!   执行当前文件</span><br><span class=\"line\">O   递归打开选中结点下的所有目录</span><br><span class=\"line\">x   合拢选中结点的父目录</span><br><span class=\"line\">X   递归合拢选中结点下的所有目录</span><br><span class=\"line\">e   Edit the current dif</span><br><span class=\"line\"></span><br><span class=\"line\">D   删除当前书签</span><br><span class=\"line\"></span><br><span class=\"line\">P   跳到根节点</span><br><span class=\"line\">p   跳到父节点</span><br><span class=\"line\">K   跳到当前目录下同级的第一个结点</span><br><span class=\"line\">J   跳到当前目录下同级的最后一个结点</span><br><span class=\"line\">k   跳到当前目录下同级的前一个结点</span><br><span class=\"line\">j   跳到当前目录下同级的后一个结点</span><br><span class=\"line\"></span><br><span class=\"line\">C   将选中目录或选中文件的父目录设为根节点</span><br><span class=\"line\">u   将当前根节点的父目录设为根目录，并变成合拢原根节点</span><br><span class=\"line\">U   将当前根节点的父目录设为根目录，但保持展开原根节点</span><br><span class=\"line\">r   递归刷新选中目录</span><br><span class=\"line\">R   递归刷新根节点</span><br><span class=\"line\">m   显示文件系统菜单</span><br><span class=\"line\">cd  将CWD设为选中目录</span><br><span class=\"line\"></span><br><span class=\"line\">I   切换是否显示隐藏文件</span><br><span class=\"line\">f   切换是否使用文件过滤器</span><br><span class=\"line\">F   切换是否显示文件</span><br><span class=\"line\">B   切换是否显示书签</span><br><span class=\"line\"></span><br><span class=\"line\">q   关闭NerdTree窗口</span><br><span class=\"line\">?  切换是否显示Quick help</span><br></pre></td></tr></table></figure>\n<h3 id=\"切换标签页\"><a href=\"#切换标签页\" class=\"headerlink\" title=\"切换标签页\"></a>切换标签页</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">:tabnew [++opt选项] [+cmd]  文件    建立对指定文件新的tab</span><br><span class=\"line\">:tabc   关闭当前的tab</span><br><span class=\"line\">:tabo   关闭所有其他的tab</span><br><span class=\"line\">:tabs   查看所有打开的tab</span><br><span class=\"line\">:tabp   前一个tab</span><br><span class=\"line\">:tabn   后一个tab</span><br><span class=\"line\"></span><br><span class=\"line\">标准模式下：</span><br><span class=\"line\">gT  前一个tab</span><br><span class=\"line\">gt  后一个tab</span><br><span class=\"line\"></span><br><span class=\"line\">MacVim还可以借助快捷键来完成tab的关闭、切换</span><br><span class=\"line\">cmd+w   关闭当前的tab</span><br><span class=\"line\">cmd+&#123;   前一个tab</span><br><span class=\"line\">cmd+&#125;   后一个tab</span><br></pre></td></tr></table></figure>\n<h3 id=\"NerdTree在-vimrc中的常用配置\"><a href=\"#NerdTree在-vimrc中的常用配置\" class=\"headerlink\" title=\"NerdTree在.vimrc中的常用配置\"></a>NerdTree在.vimrc中的常用配置</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot; 在 vim 启动的时候默认开启 NERDTree（autocmd 可以缩写为 au）</span><br><span class=\"line\">autocmd VimEnter * NERDTree</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; 按下 F2 调出/隐藏 NERDTree</span><br><span class=\"line\">map  :silent! NERDTreeToggle</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; 将 NERDTree 的窗口设置在 vim 窗口的右侧（默认为左侧）</span><br><span class=\"line\">let NERDTreeWinPos=&quot;right&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&quot; 当打开 NERDTree 窗口时，自动显示 Bookmarks</span><br><span class=\"line\">let NERDTreeShowBookmarks=1</span><br></pre></td></tr></table></figure>\n<h3 id=\"一些简单问题的解决方案\"><a href=\"#一些简单问题的解决方案\" class=\"headerlink\" title=\"一些简单问题的解决方案\"></a>一些简单问题的解决方案</h3><ul>\n<li>以上提到了怎么关闭tab，但没有提到怎么关闭窗口。关于怎么关闭一个窗口，其实很简单，只要使用vim的命令：<code>:wq</code>即可:</li>\n<li>怎么在vim中创建一个文件：<code>:e %:h/filename</code>，这是在当前目录下新建一个文件</li>\n<li><p>在mac osx中遇到一个问题，insert模式下delete键无法删除文字，发出恼人的duang duang duang声音，出现这个问题，基本是因为你的VIM使用了compatible模式，或者把<code>backspace</code>变量设置为空了。好奇的读者一定会问，这两个配置又代表了什么意思？其实compatible模式是VIM为了兼容vi而出现的配置，它的作用是使VIM的操作行为和规范和vi一致，而这种模式下backspace配置是空的。即意味着backspace无法删除<code>indent</code>，<code>end of line</code>，<code>start</code>这三种字符。如果你出现了和博主一样的情况，不妨在解决问题前先在VIM中用set backspace?命令查看下自己当前的删除模式。如果<code>backspace</code>为空，效果就相当于delete只能删除本次insert模式中输入的字符。那么为什么backspace=2又能解决问题呢？其实这个命令是set backspace=indent,eol,start的简化写法，也就相当于把delete键配置成增强模式。具体数值和对应增强模式的对应关系见 vim官方文档，简单摘录如下：</p>\n</li>\n<li><p>1 same as “:set backspace=” (Vi compatible)</p>\n</li>\n<li>2 same as “:set backspace=indent,eol”</li>\n<li>3 same as “:set backspace=indent,eol,start”</li>\n</ul>\n<p>还有个问题就是，在进入visual block模式，进行列编辑的时候，按I或者A发现没反应，最后发现要先输入你要输入的东西，然后再按I或者A，而不是先按I或者A再进行输入。</p>\n"},{"title":"APUE读书笔记--Unix System Overview","date":"2018-05-21T16:00:00.000Z","comments":1,"_content":"\n## 1.1    Introduction\n\nAll operating systems provide services for programs they run. Typical services include executing a new program, opening a file, reading a file, allocating a region of memory, getting the current time of day, and so on. The focus of this text is to describe the services provided by various versions of the UNIX operating system. 所有的操作系统都提供一些服务让程序能够在其上运行，典型的服务包括：执行一个新程序，打开一个文件，读取一个文件，分配一块内存，获取当前时间，等等。 这本书所关注的重点就是众多种类的unix操作系统能提供服务。\n\nDescribing the UNIX System in a strictly linear fashion, without any forward references to terms that haven’t been described yet, is nearly impossible (and would probably be boring). 这里道出了一个众所周知的难题，想要线性的给读者讲授一个新课程，在讲授一个知识点时却又不引进任何其他的未知概念，这几乎是不可能的。\n\n>但我认为能不能做到，不用去管，做教育的就是要尽可能的降低学习者的难度，将新知识点尽可能的用学习者已有的知识结构描述清楚。所以我们可以看到我们的课程都是有选修课的。\n\n## 1.2    Unix Architecture\n\n<img src=\"https://i.loli.net/2018/05/22/5b03742b0a818.png\" width=\"50%\">\n\n- 内核（kernel）：In a strict sense, an operating system can be defined as the software that **controls the hardware resources of the computer** and **provides an environment under which programs can run**. Generally, we call this software the kernel, since it is **relatively small and resides at the core of the environment**. 内核控制硬件资源，并给其上的程序提供运行环境，内核相对（相对是指相对于上面这张图，整个软件环境：包括内核、系统调用、公用函数库、shell(命令解释器)、应用程序）来说比较小，并处于整个环境的中心。\n- 系统调用（system calls）：**The interface to the kernel** is a layer of software called the system calls . 系统调用是内核对外的接口。\n- Libraries of common functions are built on top of the system call interface, but applications are free to use both. The shell is a special application that provides an interface for running other applications. 公共库是建立在系统调用之上的，但应用程序既可以使用公共库也可以使用系统调用。shell是一种特殊的应用程序，给执行命令(运行其他程序)提供接口。\n\n## 1.3    Logging In\n\n### Login Name\n\n**口令文件（password file）** ：当我们使用用户名和密码登陆unix的时候，系统会在`/etc/passwd`文件(password file，又叫：口令文件)中查找我们的用户名，口令文件中每个条目占一行，格式是：\n\n```\n登录名:加密过的密码:user ID:group ID:注解:home目录:shell\n```\n\n>不过加密过的密码现在也不显示在这个文件里了，而是用一个`*`号或者`x`号之类的取代，home目录又称为起始目录，新开一个shell，`pwd`一下，就是home目录。\n\n例子：\n\n```\nsar:x:205:105:Stephen Rago:/home/sar:/bin/ksh\n```\n\n登录名是sar，加密过的密码是`x`（不显示在这里），user ID是205，group ID是105，注解是Stephen Rago，home目录是`/home/sar`，使用的shell是`/bin/ksh`\n\n### Shells\n\nA shell is a command-line interpreter that reads user input and executes commands. The user input to a shell is normally from the terminal (an interactive shell) or sometimes from a file (called a shell script). shell是一种命令解释器，可以读取用户的输入，并执行命令，用户可以交互式的输入命令，也可以把命令预先全部写在一个文本文件（shell脚本）中让shell执行。\n\n常见的shell有：\n\n<img src=\"https://i.loli.net/2018/05/23/5b04b995bf5e1.png\" width=\"70%\">\n\nThe system knows which shell to execute for us based on the final field in our entry in the password file. 系统是通过口令文件的最后一个字段知道我们登陆时使用哪个shell。\n\n`bash`的全称是`Bourne-again shell`\n\nThe Bourne-again shell is the GNU shell provided with all Linux systems. It was designed to be POSIX conformant, while still remaining compatible with the Bourne shell. It supports features from both the C shell and the Korn shell.\n\n## 1.4     Files and Directories\n\n### File System\n\n- **根目录（root）**：The UNIX file system is a hierarchical arrangement of directories and files. Everything starts in the directory called root, whose name is the single character /. unix文件系统是目录和文件的层级安排，所有东西都从一个叫root的目录开始，root的名字是一个单字符：`/`。\n- **目录（directory）**：A directory is a file that contains directory entries. Logically, we can think of each directory entry as containing a filename along with a structure of information describing the attributes of the file. The attributes of a file are such things as the type of file (regular file, directory), the size of the file, the owner of the file, permissions for the file (whether other users may access this file), and when the file was last modified. 目录是一个包含目录条目的文件。逻辑上，我们可以认为每一个目录条目包含一个文件名和一个描述文件属性的结构信息。文件属性包括：文件类型（普通文件还是目录），文件大小，文件所属者，文件权限（其他用户是否能访问），文件最后被修改的时间。\n\n>The stat and fstat functions return a structure of information containing all the attributes of a file. `stat`和`fstat`函数可以返回一个结构信息，包含文件的所有属性。\n\n>We make a distinction between the logical view of a directory entry and the way it is actually stored on disk. Most implementations of UNIX file systems don’t store attributes in the directory entries themselves, because of the difficulty of keeping them in synch when a file has multiple hard links. 也就是说上面目录条目只是逻辑上的，实际上在硬盘存储上并不是直接将目录条目中的那些属性存储在目录文件中的，因为如果文件有硬链接的话，很难让这些属性信息保持同步。\n\n### Filename\n\n**文件名**：The names in a directory are called filenames. The only two characters that cannot appear in a filename are the slash character (/) and the null character. The slash separates the filenames that form a pathname (described next) and the null character terminates a pathname. Nevertheless, it’s good practice to restrict the characters in a filename to a subset of the normal printing characters. (If we use some of the shell’s special characters in the filename, we have to use the shell’s quoting mechanism to reference the filename, and this can get complicated.) Indeed, for portability, POSIX.1 recommends restricting filenames to consist of the following characters: letters (a-z, A-Z), numbers (0-9), period (.), dash (-), and underscore (_).\n一个目录中的诸多名字（包括文件和目录）称为文件名，只有两个字符不能出现在文件名中：`斜杠/(slash)`和`空字符(null character)`，斜杠用来分割`路径名(pathname)`中的文件名，空字符用来结束一个路径名（实际上编程语言中字符串就是由空字符来结束的）。然而，我们命名文件的时候最好不要使用一些乱七八糟的字符，如果我们使用了shell的特殊字符，我们就必须使用shell的引用机制去引用文件名。实际上，为了可移植性，POSIX.1标准推荐严格使用以下字符来命名文件：字母(a-z, A-Z)，数字(0-9)，点(.)，中杠(-)，下划线(_)。\n\nTwo filenames are automatically created whenever a new directory is created: . (called dot) and .. (called dot-dot). Dot refers to the current directory, and dot-dot refers to the parent directory. In the root directory, dot-dot is the same as dot. 有两个文件名在目录被创建的时候自动创建：`.`和`..`，`.`指向当前目录，`..`指向父目录，在根目录中，`..`和`.`一样（都指向当前目录）。\n\n>The Research UNIX System and some older UNIX System V file systems restricted a filename to 14 characters. BSD versions extended this limit to 255 characters. Today, almost all commercial UNIX file systems support at least 255-character filenames. 现如今的unix文件系统都支持至少255字符的文件名。\n\n### Pathname\n\nA sequence of one or more filenames, separated by slashes and optionally starting with a slash, forms a pathname. A pathname that begins with a slash is called an absolute pathname; otherwise, it’s called a relative pathname. Relative pathnames refer to files relative to the current directory. 一系列的由斜杠分割而开的文件名组成一个路径名，一个路径名可以由一个斜杠开始，这叫做：`绝对路径`，反之就是相对路径，相对路径是相对于当前路径的。\n\n### Example\n\nListing the names of all the files in a directory is not difficult. There is a bare-bones implementation of the ls(1) command:\n\n> Figure 1.3 List all the files in a directory \n\n```C\n#include \"apue.h\"\n#include <dirent.h>\n\nint main(int argc, char *argv[])\n{\n   DIR *dp;\n   struct dirent *dirp;\n   if (argc != 2)\n       err_quit(\"usage: ls directory_name\");\n   if ((dp = opendir(argv[1])) == NULL)\n       err_sys(\"can’t open %s\", argv[1]);\n   while ((dirp = readdir(dp)) != NULL)\n       printf(\"%s\\n\", dirp->d_name);\n    closedir(dp);\n    exit(0);\n}\n```\n\nThe notation ls(1) is the normal way to reference a particular entry in the UNIX system manuals. It refers to the entry for ls in Section 1. The sections are normally numbered 1 through 8, and all the entries within each section are arranged alphabetically. Throughout this text, we assume that you have a copy of the manuals for your UNIX system.  熟悉unix的人应该都知道，unix有个man命令，可以查看其它命令的说明书，当然也可以`man man`查看自己的说明书。 man命令有8个section，每个section里的条目按照字幕顺序排列。\n\n> Historically, UNIX systems lumped all eight sections together into what was called the UNIX Programmer’s Manual. As the page count increased, the trend changed to distributing the sections among separate manuals: **one for users, one for programmers, and one for system administrators**, for example. Some UNIX systems further divide the manual pages within a given section, using an uppercase letter. For example, all the standard input/output (I/O) functions in AT&T [1990e] are indicated as being in Section 3S, as in fopen(3S). Other systems have replaced the numeric sections with alphabetic ones, such as C for commands. \n\nToday, most manuals are distributed in electronic form. If your manuals are online, the way to see the manual pages for the ls command would be something like \n\n```shell\nman 1 ls\n```\n\nor\n\n```shell\nman -s1 ls\n```\n\nFigure 1.3 is a program that just prints the name of every file in a directory, and nothing else. If the source file is named myls.c, we compile it into the default a.out executable file by running \n\n```shell\ncc myls.c\n```\n\n> Historically, cc(1) is the C compiler. On systems with the GNU C compilation system, the C \n>\n> compiler is gcc(1). Here, cc is usually linked to gcc. \n\n但在实际的操作过程中，遇到了如下错误：\n\n```\nUndefined symbols for architecture x86_64:\n  \"_err_quit\", referenced from:\n      _main in fig1-457251.o\n  \"_err_sys\", referenced from:\n      _main in fig1-457251.o\nld: symbol(s) not found for architecture x86_64\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n```\n\n这是个链接错误，具体的解决办法请看这篇博客：[OS X下UNIX环境高级编程（第三版）学习日志－第一章ChapterI，编译apue包与第一个例程](https://my.oschina.net/alextuan/blog/530425)\n\n- When the program is done, it calls the function exit with an argument of 0. The function exit terminates a program. By convention, an argument of 0 means OK, and an argument between 1 and 255 means that an error occurred.  **0代表OK，1到255代表各种类型的错误**。\n\n### Working Directory\n\n**工作目录（working directory）**：Every process has a working directory, sometimes called the **current working directory**. This is the directory from which all relative pathnames are interpreted. A process can change its working directory with the `chdir` function.  每个进程都有一个工作目录，又叫做：当前工作目录，相对路径就是相对于当前工作目录的来解释的，可以调用`chdir`函数来改变工作目录。\n\nFor example, the relative pathname doc/memo/joe refers to the file or directory joe, in the directory memo, in the directory doc, which must be a directory within the working directory. From looking just at this pathname, we know that both doc and memo have to be directories, but we can’t tell whether joe is a file or a directory. The pathname /usr/lib/lint is an absolute pathname that refers to the file or directory lint in the directory lib, in the directory usr, which is in the root directory.  这里有趣的一点是，我们无法判断joe是文件还是目录。\n\n### Home Directory\n\nWhen we log in, the working directory is set to our **home directory**. Our home directory is obtained from our entry in the **password file** (Section 1.3).  当我们登陆的时候，工作目录会设定为home目录，而我们的home目录设置在口令文件中。\n\n## 1.5    Input and Output\n\n### File Descriptors\n\n**文件描述符（file descriptor）**：File descriptors are normally small non-negative integers that the kernel uses to identify the files accessed by a process. Whenever it opens an existing file or creates a new file, the kernel returns a file descriptor that we use when we want to read or write the file.  文件描述符是一个小的非负整数，内核用它来标识正在被进程访问的文件。打开或者创建文件的时候内核会返回一个文件描述符，我们可以使用这个文件描述符来对文件进行读写。\n\n### Standard Input, Standard Output, and Standard Error\n\n**标准输入，标准输出，标准错误**：By convention, all shells open three descriptors whenever a new program is run: standard input, standard output, and standard error. If nothing special is done, as in the simple command \n\n```\nls\n```\n\nthen **all three are connected to the terminal**. Most shells provide a way to redirect any or all of these three descriptors to any file. For example, \n\n```\nls > file.list\n```\n\nexecutes the ls command with its standard output redirected to the file named \n\nfile.list. \n\n**按照惯例，当新程序运行的时候，shell会打开三个文件描述符：标准输入，标准输出，标准错误。如果没有进行指明，那么三个文件描述符都会连接到终端。**\n\n### Unbuffered I/O\n\nUnbuffered I/O is provided by the functions `open`, `read`,` write`, `lseek`, and `close`. These functions all work with file descriptors. **unbuffered I/O**意思是系统不提供buffer管理，要你自己申请buffer，并传递给系统函数。\n\n### Example\n\nIf we’re willing to read from the standard input and write to the standard output, then the program in Figure 1.4 copies any regular file on a UNIX system. \n\n> Figure 1.4 Copy standard input to standard output \n\n```C\n#include \"apue.h\"\n#define BUFFSIZE 4096\nint main(void)\n{\n    int n;\n    char buf[BUFFSIZE];\n    while ((n = read(STDIN_FILENO, buf, BUFFSIZE)) > 0)\n        if (write(STDOUT_FILENO, buf, n) != n)\n            err_sys(\"write error\");\n    if (n < 0)\n        err_sys(\"read error\");\n\texit(0); \n}\n```\n\n下面是对程序的解释：\n\nThe `<unistd.h>` header, included by `apue.h`, and the two constants `STDIN_FILENO` and `STDOUT_FILENO` are part of the POSIX standard (about which we’ll have a lot more to say in the next chapter). This header contains function prototypes for many of the UNIX system services, such as the `read` and `write` functions that we call. \n\nThe constants STDIN_FILENO and STDOUT_FILENO are defined in <unistd.h> and specify the file descriptors for standard input and standard output. **These values are 0 and 1, respectively, as required by POSIX.1**, but we’ll use the names for readability. POSIX.1标准：**标准输入是0，标准输出是1，标准错误是2**。\n\nThe `read` function returns the number of bytes that are read, and this value is used as the number of bytes to `write`. When the end of the input file is encountered, read returns 0 and the program stops. If a read error occurs, read returns −1. Most of the system functions return −1 when an error occurs.  `read`函数返回的是读入字节的个数，把这个返回值传给`write`函数，就可以读多少写多少了，当遇到输入文件结束时，read函数返回0，当遇到错误时，read函数返回-1。**许多系统函数返回-1，当它们遇到错误时**。\n\nIf we compile the program into the standard name (a.out) and execute it as \n\n```shell\n./a.out > data\n```\n\nstandard input is the terminal, standard output is redirected to the file data, and standard error is also the terminal. **If this output file doesn’t exist, the shell creates it by default**. The program copies lines that we type to the standard output **until we type the end-of-file character (usually Control-D)**. \n\nIf we run \n\n```shell\n./a.out < infile > outfile\n```\n\nthen the file named infile will be copied to the file named outfile. \n\n如果文件不存在，shell默认给我们创建一个。标准输入和标准错误都是终端，我们可以一直输入，直到输入一个文件结束符，也就是`ctrl+d`。\n\n### Standard I/O\n\nThe standard I/O functions provide a buffered interface to the unbuffered I/O functions. **Using standard I/O relieves us from having to choose optimal buffer sizes**, such as the BUFFSIZE constant in Figure 1.4. The standard I/O functions also simplify dealing with lines of input (a common occurrence in UNIX applications). **The `fgets` function, for example, reads an entire line. The read function, in contrast, reads a specified number of bytes**. As we shall see in Section 5.4, the standard I/O library provides functions that let us control the style of buffering used by the library. 标准I/O函数给unbuffered I/O 函数提供了缓冲接口，使用标准I/O函数可以让我们从优化buffer大小中解脱出来，举个例子，`fgets`函数直接读取一整行，而`read`函数读取固定个数的字节。\n\nThe most common standard I/O function is `printf`. In programs that call printf, we’ll always include <stdio.h>—normally by including apue.h—as this header contains the function prototypes for all the standard I/O functions. \n\n### Example\n\nThe program in Figure 1.5, which we’ll examine in more detail in Section 5.8, is like the previous program that called read and write. This program copies standard input to standard output and can copy any regular file. \n\n> Figure 1.5 Copy standard input to standard output, using standard I/O \n\n```C\n#include \"apue.h\"\nint main(void)\n{\n\tint c;\n    while ((c = getc(stdin)) != EOF)\n    \tif (putc(c, stdout) == EOF)\n    \t\terr_sys(\"output error\");\n    if (ferror(stdin))\n    \terr_sys(\"input error\");\n\texit(0);\n}\n```\n\n**The function getc reads one character at a time, and this character is written by putc**. After the last byte of input has been read, getc returns the constant EOF (defined in <stdio.h>). The standard I/O constants stdin and stdout are also defined in the <stdio.h> header and refer to the standard input and standard output. \n\n## 1.6    Programs and Processes\n\n### Program\n\nA program is an executable file residing on disk in a directory. A program is read into memory and is executed by the kernel as a result of one of the **seven exec functions**. \n\n### Processes and Process ID \n\nAn executing instance of a program is called a **process**, a term used on almost every page of this text. Some operating systems use the term **task** to refer to a program that is being executed.  程序运行的一个实例叫做：进程，也有些操作系统使用：task这个术语来描述被执行的程序。\n\nThe UNIX System guarantees that every process has a unique numeric identifier called the process ID. The process ID is always a non-negative integer. unix系统保证每个进程都有独一无二的进程ID，这个进程ID是一个非负整数。\n\n### Example\n\nThe program in Figure 1.6 prints its process ID. \n\n> Figure 1.6 Print the process ID  \n\n```C\n#include \"apue.h\"\nint main(void)\n{\n    printf(\"hello world from process ID %ld\\n\", (long)getpid());\n    exit(0); \n}\n```\n\n输出结果：\n\n```\n➜  apue.3e ./fig1.6\nhello world from process ID 8080\n➜  apue.3e ./fig1.6\nhello world from process ID 8086\n```\n\n### Process Control\n\nThere are three primary functions for process control: `fork`, `exec`, and `waitpid`. (The exec function has seven variants, but we often refer to them collectively as simply the exec function.)  有三个进程控制的基本函数：`fork`，`exec`和`waitpid`，虽然exec函数有7种变体，但我们往往简单的用一个exec来表示它们。\n\n### Example\n\nThe process control features of the UNIX System are demonstrated using a simple program (Figure 1.7) that reads commands from standard input and executes the commands. This is a bare-bones implementation of a shell-like program. \n\n> Figure 1.7 Read commands from standard input and execute them \n\n```C\n#include \"include/apue.h\"\n#include <sys/wait.h>\n\nint main(void)\n{\n    char    buf[MAXLINE];   /* from apue.h */\n    pid_t   pid;\n    int     status;\n\n    printf(\"%% \");  /* print prompt (printf requires %% to print %) */\n    while (fgets(buf, MAXLINE, stdin) != NULL) {\n        if (buf[strlen(buf) - 1] == '\\n')\n            buf[strlen(buf) - 1] = 0; /* replace newline with null */\n        if ((pid = fork()) < 0) {\n            err_sys(\"fork error\");\n        } else if (pid == 0) {      /* child */\n            execlp(buf, buf, (char *)0);\n            // or\n            // execlp(buf, buf, (char *)NULL);\n            err_ret(\"couldn’t execute: %s\", buf);\n            exit(127);\n\t\t}\n        /* parent */\n        if ((pid = waitpid(pid, &status, 0)) < 0)\n            err_sys(\"waitpid error\");\n        printf(\"%% \");\n\t}\n\texit(0); \n}\n```\n\nThere are several features to consider in this 30-line program. \n\n- We use the standard I/O function fgets to read one line at a time from the standard input. When we type the end-of-file character (which is often Control-D) as the first character of a line, fgets returns a null pointer, the loop stops, and the process terminates. In Chapter 18, we describe all the special terminal characters—end of file, backspace one character, erase entire line, and so on—and how to change them.  我们使用了标准I/O函数`fgets`来一次读取标准输入的一行。当我们直接输入一个EOF时，fgets返回一个空指针，循环停止，进程终止。在第18章，我们将讲述特殊终止符，比如：end of file，backspace one character, erase entire line, 等等，以及如何改变它们。\n- Because each line returned by fgets is terminated with a newline character, followed by a null byte, we use the standard C function strlen to calculate the length of the string, and then replace the newline with a null byte. We do this because the execlp function wants a null-terminated argument, not a newline-terminated argument.  因为fgets返回的每一行都被一个换行符终止，换行符之后是一个空字符，我们使用标准C函数`strlen`来计算string的长度，然后将换行符替换成空字符（这样末尾就两个空字符了）。我们这样做是因为`execlp`函数希望有一个空字符来作为结尾参数，而不是一个换行符。\n- We call fork to create a new process, which is a copy of the caller. We say that the caller is the parent and that the newly created process is the child. Then fork returns the non-negative process ID of the new child process to the parent, and returns 0 to the child. Because fork creates a new process, we say that it is called once—by the parent—but returns twice—in the parent and in the child.  我们调用`fork`创建一个新进程，这个新进程是调用进程的一个复制。我们说，调用者是父进程，新创建出来的进程是子进程。**然后fork返回子进程的非负进程ID给父进程，并返回0给子进程**。因为fork创建了一个新进程，**我们说它调用了一次（被父进程），但是返回了两次**，在父进程和子进程里面。\n- In the child, we call execlp to execute the command that was read from the standard input. This replaces the child process with the new program file. The combination of fork followed by exec is called spawning a new process on some operating systems. In the UNIX System, the two parts are separated into individual functions. We’ll say a lot more about these functions in Chapter 8.  在子进程中，我们调用`execlp`来执行从标注输入中读取来的命令。这就把子进程替换成了新执行的程序。fork后面跟个exec这种结合方式被叫做 **spawning a new process** 在某些操作系统中。在unix系统中，这两部分被分别放到了两个单独的函数中。我们将在第8章中讨论更多的这类函数。\n- Because the child calls execlp to execute the new program file, the parent wants to wait for the child to terminate. This is done by calling waitpid, specifying which process to wait for: the pid argument, which is the process ID of the child. The waitpid function also returns the termination status of the child—the status variable—but in this simple program, we don’t do anything with this value. We could examine it to determine how the child terminated.  因为子进程调用了`execlp`来执行新程序文件，父进程想要等子进程结束。通过调用`waitpid`可以完成这个任务，用`pid`（子进程的进程ID）参数来明确需要等待哪个进程。`waitpid`函数同样也返回子进程的终止状态（记录在status这个参数），但在这个简单的程序里，我们没有用到这个值。我们通过这个值得知子进程是如何结束的。\n- The most fundamental limitation of this program is that we can’t pass arguments to the command we execute. We can’t, for example, specify the name of a directory to list. We can execute ls only on the working directory. To allow arguments would require that we parse the input line, separating the arguments by some convention, probably spaces or tabs, and then pass each argument as a separate parameter to the execlp function. Nevertheless, this program is still a useful demonstration of the UNIX System’s process control functions.  这个程序最大的限制就是，我们不能传递参数给我们要执行的命令。比如，我们不能给定一个目录给list程序（展示目录下的所有目录和文件的程序）。我们只能在当前目录下执行ls。如果要允许传递参数，就需要我们分析输入行，按照惯例，比如空格或者制表符，把参数分割开来，然后把参数传给execlp函数。不管怎么说，这个程序已经很好的展示了unix系统是如何控制函数的。\n\nIf we run this program, we get the following result. Note that our program has a different prompt—the percent sign—to distinguish it from the shell’s prompt. \n\n```\n➜  apue.3e ./fig1.7\n% pwd\n/Users/liuqinh2s/Downloads/apue.3e\n% who\nliuqinh2s console  May 21 12:09\nliuqinh2s ttys000  May 21 12:10\n% date\n2018年 5月24日 星期四 15时26分59秒 CST\n% %                                                                                                                                                                                                         ➜  apue.3e\n```\n\n> The notation ˆD is used to indicate a control character. Control characters are special characters formed by holding down the control key—often labeled Control or Ctrl—on your keyboard and then pressing another key at the same time. **Control-D, or ˆD, is the default end-of-file character**. We’ll see many more control characters when we discuss terminal I/O in Chapter 18.  `^D`这种记法用于表示控制字符，控制字符是一类特殊的字符，由`ctrl`键加一个其他键组成，`Control-D`或者说`^D`是默认的文件终止符。我们将在第18章讨论输入输出终止符的时候看到更多的控制字符。\n\n### Threads and Thread IDs\n\nUsually, a process has only one thread of control—one set of machine instructions executing at a time. Some problems are easier to solve when more than one thread of control can operate on different parts of the problem. Additionally, multiple threads of control can exploit the parallelism possible on multiprocessor systems. \n\nAll threads within a process share the same address space, file descriptors, stacks, and process-related attributes. Each thread executes on its own stack, although any thread can access the stacks of other threads in the same process. Because they can access the same memory, the threads need to synchronize access to shared data among themselves to avoid inconsistencies.  属于同一个进程的多个线程共享同一块内存空间，文件描述符，栈，以及和进程相关的属性。每个线程都在自己的栈里面执行，但每个线程又能访问其他线程的栈（同属于一个进程的多个线程）。因为它们能访问同一块内存，所以为了避免不一致性，需要保护好临界资源。\n\nLike processes, threads are identified by IDs. **Thread IDs, however, are local to a process**. A thread ID from one process has no meaning in another process. We use thread IDs to refer to specific threads as we manipulate the threads within a process.  就像进程一样，线程也用ID标识。**然而线程ID是局部的，只在某个进程内有效，出了这个进程，对其他进程来说这个线程ID就没有任何意义了。**\n\n> threads were added to the UNIX System long after the process model was established \n\n## 1.7    Error Handling\n\nWhen an error occurs in one of the UNIX System functions, a negative value is often returned, and the integer **errno** is usually set to a value that tells why. For example, the open function returns either a non-negative file descriptor if all is OK or −1 if an error occurs. An error from open has about 15 possible errno values, such as file doesn’t exist, permission problem, and so on. Some functions use a convention other than returning a negative value. For example, most functions that return a pointer to an object return a null pointer to indicate an error.  当unix系统函数出错时，会返回一个负数，整形变量**errno**会设置为一个值，这个值告诉我们为什么出错。例如，open函数返回一个非负的文件描述符，如果成功的话，如果出现错误则返回一个-1。open函数返回的错误有15个可能的errno值，比如：文件不存在，权限问题，等等。有些函数使用另一个传统而非返回一个负数。例如，很多函数返回一个对象指针，或者一个空指针如果出现错误。\n\nThe file <errno.h> defines the symbol errno and constants for each value that errno can assume. Each of these constants begins with the character E. Also, the first page of Section 2 of the UNIX system manuals, named intro(2), usually lists all these error constants. For example, if errno is equal to the constant EACCES, this indicates a permission problem, such as insufficient permission to open the requested file.  `<errno.h>`文件定义了变量errno和一系列常量（errno可能的值）。每个常量都以字符`E`开头。unix系统手册`intro(2)`展示了这些常量。例如，如果errno等于常量EACCES，就表示是权限问题，没有足够的权限去打开这个文件。\n\n> On Linux, the error constants are listed in the errno(3) manual page. \n\nPOSIX and ISO C define errno as a symbol expanding into a modifiable lvalue of type integer. This can be either an integer that contains the error number or a function that returns a pointer to the error number. The historical definition is \n\n```C\nextern int errno;\n```\n\nBut in an environment that supports threads, the process address space is shared among multiple threads, and each thread needs its own local copy of errno to prevent one thread from interfering with another. Linux, for example, supports multithreaded access to errno by defining it as \n\n```C\nextern int *__errno_location(void); \n#define errno (*__errno_location())\n```\n\nPOSIX和ISO C把errno定义为一个可以修改的左值。可以定义为一个整形值，也可以定义为一个指针，指针指向错误码（String类型）。如果是多线程环境下，每个线程都有自己的一个errno拷贝。通过宏定义把errno给替换成函数：`int *__errno_location(void); `了。\n\nThere are two rules to be aware of with respect to errno. First, its value is never cleared by a routine if an error does not occur. Therefore, we should examine its value only when the return value from a function indicates that an error occurred. Second, the value of errno is never set to 0 by any of the functions, and none of the constants defined in <errno.h> has a value of 0.  第一，如果没有出错，errno的值不会被重置，因此，我们只有在函数返回出错的时候才检查errno；第二，errno不会等于0。\n\nTwo functions are defined by the C standard to help with printing error messages. \n\n```C\n#include <string.h>\n\nchar *strerror(int errnum);\t//Returns: pointer to message string\n```\n\nThis function maps errnum, which is typically the errno value, into an error message string and returns a pointer to the string. \n\nThe perror function produces an error message on the standard error, based on the current value of errno, and returns. \n\n```C\n#include <stdio.h>\n\nvoid perror(const char* msg);\n```\n\nIt outputs the string pointed to by msg, followed by a colon and a space, followed by the error message corresponding to the value of errno, followed by a newline. \n\n### Example\n\nFigure 1.8 shows the use of these two error functions. \n\n> Figure 1.8 Demonstrate strerror and perror \n\n```C\n#include \"apue.h\"\n#include <errno.h>\nint main(int argc, char *argv[])\n{\n    fprintf(stderr, \"EACCES: %s\\n\", strerror(EACCES));\n    errno = ENOENT;\n    perror(argv[0]);\n    exit(0);\n}\n```\n\n输出结果：\n\n```\n➜  apue.3e ./fig1.8\nEACCES: Permission denied\n./fig1.8: No such file or directory\n➜  apue.3e\n```\n\n> argv[0] 表示输入的第一个参数，也就是命令名\n\n### Error Recovery\n\nThe errors defined in <errno.h> can be divided into two categories: fatal and nonfatal. A fatal error has no recovery action. The best we can do is print an error message on the user’s screen or to a log file, and then exit. Nonfatal errors, on the other hand, can sometimes be dealt with more robustly. Most nonfatal errors are temporary, such as a resource shortage, and might not occur when there is less activity on the system.  定义在`<errno.h>`中的错误可以分为两类：fatal和nonfatal，致命和非致命。致命错误没有恢复动作，我们最多能做的就是把错误信息在用户显示屏上打印出来，或者写到log文件里，然后退出。非致命错误，可以更妥善的处理，许多非致命错误都是暂时的，比如：资源短缺，当系统活动较少时这类错误可能不会发生。\n\nResource-related nonfatal errors include **EAGAIN, ENFILE, ENOBUFS, ENOLCK, ENOSPC, EWOULDBLOCK**, and sometimes **ENOMEM**. **EBUSY** can be treated as nonfatal when it indicates that a shared resource is in use. Sometimes, **EINTR** can be treated as a nonfatal error when it interrupts a slow system call (more on this in Section 10.5).  \n\nThe typical recovery action for a resource-related nonfatal error is to delay and retry later. This technique can be applied in other circumstances. For example, if an error indicates that a network connection is no longer functioning, it might be possible for the application to delay a short time and then reestablish the connection. Some applications use an exponential backoff algorithm, waiting a longer period of time in each subsequent iteration.  **典型的资源相关性非致命错误的处理办法是先等一下，之后再重试。**\n\n**Ultimately, it is up to the application developer to determine the cases where an application can recover from an error. If a reasonable recovery strategy can be used, we can improve the robustness of our application by avoiding an abnormal exit. **\n\n## 1.8    User Identification\n\n### User ID\n\nThe user ID from our entry in the password file is a numeric value that identifies us to the system. This user ID is assigned by the system administrator when our login name is assigned, and we cannot change it. The user ID is normally assigned to be unique for every user. We’ll see how the kernel uses the user ID to check whether we have the appropriate permissions to perform certain operations.  用户ID来自口令文件中对应的条目，它是以数字的形式帮助系统对我们进行标识。用户ID是系统管理员给我们分配的（当分配登录名时，同时也必须分配用户ID），我们自己无法改。每个人的用户ID应该是唯一的，内核使用用户ID来检查我们是否有合适的权限来进行一个操作。\n\nWe call the user whose user ID is 0 either root or the superuser. The entry in the password file normally has a login name of root, and we refer to the special privileges of this user as superuser privileges. As we’ll see in Chapter 4, if a process has superuser privileges, most file permission checks are bypassed. Some operating system functions are restricted to the superuser. The superuser has free rein over the system.  我们把用户ID为0的用户称为：**root**或者**superuser**。口令文件中有一个条目的登录名是root，root用户拥有特殊权限。拥有superuser特权的进程可以自由的使用任意文件，而且有些操作系统函数是只对superuser开放的。superuser拥有对系统的绝对的权限（可以把系统弄残）。\n\n> Client versions of Mac OS X ship with the superuser account disabled; server versions ship with the account already enabled. Instructions are available on Apple’s Web site describing how to enable it. See http://support.apple.com/kb/HT1528. \n\n### Group ID\n\nOur entry in the password file also specifies our numeric group ID. This, too, is assigned by the system administrator when our login name is assigned. Typically, the password file contains multiple entries that specify the same group ID. Groups are normally used to collect users together into projects or departments. This allows the sharing of resources, such as files, among members of the same group. We’ll see in Section 4.5 that we can set the permissions on a file so that all members of a group can access the file, whereas others outside the group cannot.  Group ID的作用就是让相同组的人共享资源。\n\nThere is also a group file that maps group names into numeric group IDs. The group file is usually `/etc/group`. \n\nThe use of numeric user IDs and numeric group IDs for permissions is historical. With every file on disk, the file system stores both the user ID and the group ID of a file’s owner. Storing both of these values requires only four bytes, assuming that each is stored as a two-byte integer. If the full ASCII login name and group name were used instead, additional disk space would be required. In addition, comparing strings during permission checks is more expensive than comparing integers.  使用数字的用户ID和组ID是有历史原因的。对于每个存放在磁盘上的文件，文件系统都存储了该文件的拥有者的用户ID和组ID。存储这两个数字需要4字节（每个2字节），如果使用ASCII编码的登录名和组名，需要多用掉很多额外的磁盘空间。另外在检查权限是否合格时，整形数字比较要比字符串比较更快。\n\nUsers, however, work better with names than with numbers, so the password file maintains the mapping between login names and user IDs, and the group file provides the mapping between group names and group IDs. The ls -l command, for example, prints the login name of the owner of a file, using the password file to map the numeric user ID into the corresponding login name.  然而对于用户来说名字比数字更好记，所以password file和group file分别记录了登录名和用户ID的映射，组名和组ID的映射。使用`ls -l`命令，可以看到打印出了文件所属者和所属的组，其原理就是查找了password file和group file，把相应的数字ID换成名字。\n\n> Early UNIX systems used 16-bit integers to represent user and group IDs. Contemporary UNIX systems use 32-bit integers. \n\n### Example\n\nThe program in Figure 1.9 prints the user ID and the group ID. \n\n> Figure 1.9 Print user ID and group ID  \n\n```C\n#include \"apue.h\"\n\nint main(void)\n{\n\tprintf(\"uid = %d, gid = %d\\n\", getuid(), getgid());\n\texit(0); \n}\n```\n\n### Supplementary Group IDs \n\n**附加组（supplementary group）**：In addition to the group ID specified in the password file for a login name, most versions of the UNIX System allow a user to belong to other groups. This practice started with 4.2BSD, which allowed a user to belong to up to 16 additional groups. These supplementary group IDs are obtained at login time by reading the file /etc/group and finding the first 16 entries that list the user as a member. As we shall see in the next chapter, POSIX requires that a system support at least 8 supplementary groups per process, but most systems support at least 16.  许多unix系统允许用户属于多个组，最多16个。主组，也就是登陆时的默认组记录在`/etc/passwd`中。\n\n`/etc/group`格式如下：\n\n```shell\n_analyticsusers:*:250:_analyticsd,_networkd,_timed\n_analyticsd:*:263:_analyticsd\n```\n\n解释：\n\n```\n组名:口令:组ID:组内用户列表\n```\n\n## 1.9    Signal\n\nSignals are a technique used to notify a process that some condition has occurred. For example, if a process divides by zero, the signal whose name is SIGFPE (floating-point exception) is sent to the process. The process has three choices for dealing with the signal.  信号是一种用来通知进程发生了某些事的技术。举个例子：当进程除以0时，就会有一个SIGFPE (floating-point exception)发送到这个进程。进程处理信号有三种选择：\n\n1. Ignore the signal. This option isn’t recommended for signals that denote a hardware exception, such as dividing by zero or referencing memory outside the address space of the process, as the results are undefined.  忽视信号。如果是硬件异常不推荐这个选择，例如：被0除，引用进程外的内存，因为这些结果都是不确定的。\n2. Let the default action occur. For a divide-by-zero condition, the default is to terminate the process.  让默认动作出现，比如被0除的情况下，默认是终止该进程。\n3. Provide a function that is called when the signal occurs (this is called ‘‘catching’’ the signal). By providing a function of our own, we’ll know when the signal occurs and we can handle it as we wish.  我们自己提供一个函数捕获信号，这样我们就能让程序以我们的意愿处理异常。\n\nMany conditions generate signals. Two terminal keys, called the **interrupt key**— often the **DELETE** key or **Control-C**—and the **quit key**—often **Control-backslash**—are used to interrupt the currently running process. Another way to generate a signal is by calling the `kill` function. **We can call this function from a process to send a signal to another process. Naturally, there are limitations: we have to be the owner of the other process (or the superuser) to be able to send it a signal**.    很多条件下可以生成信号，终端键有两种，interrupt key（delete键或者ctrl+c）和 quit key（ctrl+\\）。另一个生成信号的方法是调用`kill`函数，我们可以在一个进程里调用kill函数来结束另一个线程，但我们需要有权限（如果我们是另一个进程的拥有者，或者是超级用户，就可以）。\n\n### Example\n\nRecall the bare-bones shell example (Figure 1.7). If we invoke this program and press the interrupt key, the process terminates because the default action for this signal, named SIGINT, is to terminate the process. The process hasn’t told the kernel to do anything other than the default with this signal, so the process terminates.  如果直接执行Figure 1.7的代码，我们按下中断键，程序就会终止，因为这个SIGINT信号的默认动作就是终止进程。\n\nTo catch this signal, the program needs to call the signal function, specifying the name of the function to call when the SIGINT signal is generated. The function is named sig_int; when it’s called, it just prints a message and a new prompt. Adding 11 lines to the program in Figure 1.7 gives us the version in Figure 1.10. (The 11 new lines are indicated with a plus sign at the beginning of the line.)  为了捕获这个信号，程序需要调用一个信号函数。我们给它命名为：`sig_int`函数，在捕获到**SIGINT**信号之后，打印信息并打印一个新的提示符。下面的程序相比Figure 1.7多了11行，用`+`号标识了。\n\n> Figure 1.10 Read commands from standard input and execute them \n\n```C\n  #include \"include/apue.h\"\n  #include <sys/wait.h>\n  \n+ static void sig_int(int);\t/* our signal-catching function */\n+\n  int main(void)\n  {\n      char    buf[MAXLINE];   /* from apue.h */\n      pid_t   pid;\n      int     status;\n  \n  +\t  if(signal(SIGINT, sig_int) == SIG_ERR)\n          err_sys(\"signal error\");\n    \n      printf(\"%% \");  /* print prompt (printf requires %% to print %) */\n      while (fgets(buf, MAXLINE, stdin) != NULL) {\n          if (buf[strlen(buf) - 1] == '\\n')\n              buf[strlen(buf) - 1] = 0; /* replace newline with null */\n          if ((pid = fork()) < 0) {\n              err_sys(\"fork error\");\n          } else if (pid == 0) {      /* child */\n              execlp(buf, buf, (char *)0);\n              err_ret(\"couldn’t execute: %s\", buf);\n              exit(127);\n\t\t  }\n          /* parent */\n          if ((pid = waitpid(pid, &status, 0)) < 0)\n              err_sys(\"waitpid error\");\n          printf(\"%% \");\n\t  }\n\t  exit(0); \n  }\n+\n+ void sig_int(int signo){\n+     printf(\"interrupt\\n%% \");\n+ }\n```\n\n## 1.10    Time Values\n\nHistorically, UNIX systems have maintained two different time values: \n\n1. **Calendar time**. This value counts the number of seconds since the **Epoch: 00:00:00 January 1, 1970,Coordinated Universal Time (UTC)**. (Older manuals refer to UTC as Greenwich Mean Time.) These time values are used to record the time when a file was last modified, for example. \n\n   The primitive system data type `time_t` holds these time values. \n\n2. **Process time**. This is also called CPU time and measures the central processor resources used by a process. Process time is measured in clock ticks, which have historically been 50, 60, or 100 ticks per second. \n\n   The primitive system data type `clock_t` holds these time values. (We’ll show how to obtain the number of clock ticks per second with the `sysconf` function in Section 2.5.4.) \n\n有两种类型的时间：**日历时间**和**进程时间**，日历时间也就是UTC。\n\nWhen we measure the execution time of a process, as in Section 3.9, we’ll see that the UNIX System maintains three values for a process: \n\n- Clock time \n- User CPU time \n- System CPU time \n\nThe clock time, sometimes called **wall clock time**, is the amount of time the process takes to run, and its value depends on the number of other processes being run on the system. Whenever we report the clock time, the measurements are made with no other activities on the system. \n\nThe user CPU time is the CPU time attributed to user instructions. The system CPU time is the CPU time attributed to the kernel when it executes on behalf of the process. For example, whenever a process executes a system service, such as read or write, the time spent within the kernel performing that system service is charged to the process. The sum of user CPU time and system CPU time is often called the CPU time. \n\n度量进程执行时间，有三种：\n\n1. 墙上时钟，也就是进程执行花费的总时间。\n2. 用户CPU时间，是用户模式（非内核）下的CPU使用时间\n3. 系统CPU时间，是进程进入内核执行的CPU使用时间\n\nIt is easy to measure the clock time, user time, and system time of any process: simply execute the time(1) command, with the argument to the time command being the command we want to measure. For example: \n\n```shell\n$ cd /usr/include\n$ time -p grep _POSIX_SOURCE */*.h > /dev/null\n```\n\n结果：\n\n```\nreal    0m0.81s\nuser    0m0.11s\nsys     0m0.07s\n```\n\nThe output format from the time command depends on the shell being used, because some shells don’t run /usr/bin/time, but instead have a separate built-in function to measure the time it takes commands to run.  time命令的输出格式取决于使用什么shell，因为有些shell并不运行：`/usr/bin/time`，而是运行自己内置的一个time函数。\n\n## 1.11    System Calls and Library Functions\n\nAll operating systems provide service points through which programs request services from the kernel. All implementations of the UNIX System provide a well-defined, limited number of entry points directly into the kernel called system calls (recall Figure 1.1). Version 7 of the Research UNIX System provided about 50 system calls, 4.4BSD provided about 110, and SVR4 had around 120. The exact number of system calls varies depending on the operating system version. More recent systems have seen incredible growth in the number of supported system calls. Linux 3.2.0 has 380 system calls and FreeBSD 8.0 has over 450.  随着时间的推移，系统调用越来越多，可见系统是越来越完善的。\n\nThe system call interface has always been documented in Section 2 of the UNIX Programmer’s Manual. Its definition is in the C language, no matter which implementation technique is actually used on any given system to invoke a system call. This differs from many older operating systems, which traditionally defined the kernel entry points in the assembly language of the machine.  **系统调用的文档总是在unix编程手册的第二个章节里。它是用C语言定义的**，不管系统具体是如何实现系统调用的。这一点与很多老操作系统不同（老操作系统使用汇编语言定义内核接口）\n\nThe technique used on UNIX systems is for each system call to have a function of the same name in the standard C library. The user process calls this function, using the standard C calling sequence. This function then invokes the appropriate kernel service, using whatever technique is required on the system. For example, the function may put one or more of the C arguments into general registers and then execute some machine instruction that generates a software interrupt in the kernel. For our purposes, we can consider the system calls to be C functions.  每个系统调用都对应一个相同名字的函数在标准C库里。用户进程调用这个函数，然后这个函数调用相应的内核服务。举个例子，这个函数可能会把一个或多个C参数放到通用寄存器，并执行机器指令在内核中产生一个软件中断。从我们的角度看，我们可以直接认为系统调用就是C函数。\n\nSection 3 of the UNIX Programmer’s Manual defines the general-purpose library functions available to programmers. These functions aren’t entry points into the kernel, although they may invoke one or more of the kernel’s system calls. For example, the printf function may use the write system call to output a string, but the strcpy (copy a string) and atoi (convert ASCII to integer) functions don’t involve the kernel at all.  在**unix编程手册第三章定义了通用库函数给程序员。这些函数不是内核入口，虽然它们可能会调用一个或几个内核的系统调用**。举个例子，`printf`函数可能会使用`write`系统调用来输出一个字符串，但是`strcpy`（拷贝一个字符串）和`atoi`（吧ASCII字符转成整形）函数根本没有调用内核。\n\nFrom an implementor’s point of view, the distinction between a system call and a library function is fundamental. From a user’s perspective, however, the difference is not as critical. From our perspective in this text, both system calls and library functions appear as normal C functions. Both exist to provide services for application programs. We should realize, however, that we can replace the library functions, if desired, whereas the system calls usually cannot be replaced.  从实现者的角度来看，系统调用和库函数的区别是很大的。然而从使用者的角度来看，这个区别并不重要。在这本书中，在我们看来，系统调用和库函数都以C函数的形式出现。两者的存在都是为了给应用开发者提供服务。然而我们应该意识到，**虽然我们能替换库函数（如果我们想这样做），但系统调用不能被替换**。\n\nConsider the memory allocation function malloc as an example. There are many ways to do memory allocation and its associated garbage collection (best fit, first fit, and so on). No single technique is optimal for all programs. The UNIX system call that handles memory allocation, sbrk(2), is not a general-purpose memory manager. It increases or decreases the address space of the process by a specified number of bytes. How that space is managed is up to the process. The memory allocation function, malloc(3), implements one particular type of allocation. If we don’t like its operation, we can define our own malloc function, which will probably use the sbrk system call. In fact, numerous software packages implement their own memory allocation algorithms with the sbrk system call. Figure 1.11 shows the relationship between the application, the malloc function, and the sbrk system call.  让我们来看看内存分配函数`malloc`这个例子。有很多内存分配和相关的垃圾回收方法（最好适应算法，最先适应算法，等等）。没有哪个技术是对所有程序优化的。**unix系统调用`sbrk(2)`不是一个通用的存储管理器。它给进程增加和减少内存空间都是固定的字节数。怎么管理空间其实还要取决于进程自己。内存分配函数`malloc(3)`，实现了特定类型的分配。如果我们不喜欢它的做法，我们可以定义自己的malloc函数，但也是要用到sbrk系统调用的。实际上大量的软件包都通过直接使用sbrk系统调用实现了自己的内存管理算法**。图1.11展示了应用，malloc函数，和sbrk系统调用之间的关系。\n\n<img src=\"https://i.loli.net/2018/05/25/5b07647fc7597.png\", width=\"70%\">\n\nHere we have a clean separation of duties: the system call in the kernel allocates an additional chunk of space on behalf of the process. The malloc library function manages this space from user level.  这里职责是分明的：系统调用代表进程在内核里分配了额外的一块空间。malloc库函数在用户层级上管理这块空间。\n\nAnother example to illustrate the difference between a system call and a library function is the interface the UNIX System provides to determine the current time and date. Some operating systems provide one system call to return the time and another to return the date. Any special handling, such as the switch to or from daylight saving time, is handled by the kernel or requires human intervention. The UNIX System, in contrast, provides a single system call that returns the number of seconds since the Epoch: midnight, January 1, 1970, Coordinated Universal Time. Any interpretation of this value, such as converting it to a human-readable time and date using the local time zone, is left to the user process. The standard C library provides routines to handle most cases. These library routines handle such details as the various algorithms for daylight saving time.  另一个描述系统调用和库函数不同的例子是当前时间和日期。某些操作系统提供一个系统调用返回时间，另一个系统调用返回日期。任何特殊的处理，比如正常时制与夏令时的切换，需要内核的处理或者认为干预。Unix系统则相反，只提供一个系统调用，返回UTC（UTC是指从1970年的第一秒开始算起到现在经过的总时间）。任何对UTC这个值的解释，例如把它转成人类可读的时间日期使用当地时间，就留给了用户进程。标准C库提供了诸多例程来处理大多数情况。这些库例程处理这些细节，就像大多数算法处理夏令时切换一样。\n\nAn application can either make a system call or call a library routine. Also realize that many library routines invoke a system call. This is shown in Figure 1.12.  一个应用可以使用系统调用或者调用库例程，同样要意识到许多库例程调用了系统调用。\n\nAnother difference between system calls and library functions is that system calls usually **provide a minimal interface**, whereas library functions often **provide more elaborate functionality**. We’ve seen this already in the difference between the sbrk system call and the malloc library function. We’ll see this difference again later, when we compare the unbuffered I/O functions (Chapter 3) and the standard I/O functions (Chapter 5).  另一个系统调用和库函数的区别就是，系统调用往往只提供一个很小的接口，然而库函数经常提供更多精细的功能。\n\n<img src=\"https://i.loli.net/2018/05/25/5b07d2d3861c0.png\" width=\"70%\">\n\nThe process control system calls (**fork, exec, and waitpid**) are usually invoked by the user’s application code directly. (Recall the bare-bones shell in Figure 1.7.) But some library routines exist to simplify certain common cases: the **system** and **popen** library routines, for example. In Section 8.13, we’ll show an implementation of the system function that invokes the basic process control system calls. We’ll enhance this example in Section 10.18 to handle signals correctly. \n\nTo define the interface to the UNIX System that most programmers use, we have to describe both the system calls and some of the library functions. If we described only the sbrk system call, for example, we would skip the more programmer-friendly malloc library function that many applications use. **In this text, we’ll use the term function to refer to both system calls and library functions, except when the distinction is necessary.** \n\n","source":"_posts/2018/2018-05-22-APUE读书笔记--Unix-System-Overview.md","raw":"---\ntitle: APUE读书笔记--Unix System Overview\ndate: 2018-05-22\ncategories: [Unix]\ncomments: true\n---\n\n## 1.1    Introduction\n\nAll operating systems provide services for programs they run. Typical services include executing a new program, opening a file, reading a file, allocating a region of memory, getting the current time of day, and so on. The focus of this text is to describe the services provided by various versions of the UNIX operating system. 所有的操作系统都提供一些服务让程序能够在其上运行，典型的服务包括：执行一个新程序，打开一个文件，读取一个文件，分配一块内存，获取当前时间，等等。 这本书所关注的重点就是众多种类的unix操作系统能提供服务。\n\nDescribing the UNIX System in a strictly linear fashion, without any forward references to terms that haven’t been described yet, is nearly impossible (and would probably be boring). 这里道出了一个众所周知的难题，想要线性的给读者讲授一个新课程，在讲授一个知识点时却又不引进任何其他的未知概念，这几乎是不可能的。\n\n>但我认为能不能做到，不用去管，做教育的就是要尽可能的降低学习者的难度，将新知识点尽可能的用学习者已有的知识结构描述清楚。所以我们可以看到我们的课程都是有选修课的。\n\n## 1.2    Unix Architecture\n\n<img src=\"https://i.loli.net/2018/05/22/5b03742b0a818.png\" width=\"50%\">\n\n- 内核（kernel）：In a strict sense, an operating system can be defined as the software that **controls the hardware resources of the computer** and **provides an environment under which programs can run**. Generally, we call this software the kernel, since it is **relatively small and resides at the core of the environment**. 内核控制硬件资源，并给其上的程序提供运行环境，内核相对（相对是指相对于上面这张图，整个软件环境：包括内核、系统调用、公用函数库、shell(命令解释器)、应用程序）来说比较小，并处于整个环境的中心。\n- 系统调用（system calls）：**The interface to the kernel** is a layer of software called the system calls . 系统调用是内核对外的接口。\n- Libraries of common functions are built on top of the system call interface, but applications are free to use both. The shell is a special application that provides an interface for running other applications. 公共库是建立在系统调用之上的，但应用程序既可以使用公共库也可以使用系统调用。shell是一种特殊的应用程序，给执行命令(运行其他程序)提供接口。\n\n## 1.3    Logging In\n\n### Login Name\n\n**口令文件（password file）** ：当我们使用用户名和密码登陆unix的时候，系统会在`/etc/passwd`文件(password file，又叫：口令文件)中查找我们的用户名，口令文件中每个条目占一行，格式是：\n\n```\n登录名:加密过的密码:user ID:group ID:注解:home目录:shell\n```\n\n>不过加密过的密码现在也不显示在这个文件里了，而是用一个`*`号或者`x`号之类的取代，home目录又称为起始目录，新开一个shell，`pwd`一下，就是home目录。\n\n例子：\n\n```\nsar:x:205:105:Stephen Rago:/home/sar:/bin/ksh\n```\n\n登录名是sar，加密过的密码是`x`（不显示在这里），user ID是205，group ID是105，注解是Stephen Rago，home目录是`/home/sar`，使用的shell是`/bin/ksh`\n\n### Shells\n\nA shell is a command-line interpreter that reads user input and executes commands. The user input to a shell is normally from the terminal (an interactive shell) or sometimes from a file (called a shell script). shell是一种命令解释器，可以读取用户的输入，并执行命令，用户可以交互式的输入命令，也可以把命令预先全部写在一个文本文件（shell脚本）中让shell执行。\n\n常见的shell有：\n\n<img src=\"https://i.loli.net/2018/05/23/5b04b995bf5e1.png\" width=\"70%\">\n\nThe system knows which shell to execute for us based on the final field in our entry in the password file. 系统是通过口令文件的最后一个字段知道我们登陆时使用哪个shell。\n\n`bash`的全称是`Bourne-again shell`\n\nThe Bourne-again shell is the GNU shell provided with all Linux systems. It was designed to be POSIX conformant, while still remaining compatible with the Bourne shell. It supports features from both the C shell and the Korn shell.\n\n## 1.4     Files and Directories\n\n### File System\n\n- **根目录（root）**：The UNIX file system is a hierarchical arrangement of directories and files. Everything starts in the directory called root, whose name is the single character /. unix文件系统是目录和文件的层级安排，所有东西都从一个叫root的目录开始，root的名字是一个单字符：`/`。\n- **目录（directory）**：A directory is a file that contains directory entries. Logically, we can think of each directory entry as containing a filename along with a structure of information describing the attributes of the file. The attributes of a file are such things as the type of file (regular file, directory), the size of the file, the owner of the file, permissions for the file (whether other users may access this file), and when the file was last modified. 目录是一个包含目录条目的文件。逻辑上，我们可以认为每一个目录条目包含一个文件名和一个描述文件属性的结构信息。文件属性包括：文件类型（普通文件还是目录），文件大小，文件所属者，文件权限（其他用户是否能访问），文件最后被修改的时间。\n\n>The stat and fstat functions return a structure of information containing all the attributes of a file. `stat`和`fstat`函数可以返回一个结构信息，包含文件的所有属性。\n\n>We make a distinction between the logical view of a directory entry and the way it is actually stored on disk. Most implementations of UNIX file systems don’t store attributes in the directory entries themselves, because of the difficulty of keeping them in synch when a file has multiple hard links. 也就是说上面目录条目只是逻辑上的，实际上在硬盘存储上并不是直接将目录条目中的那些属性存储在目录文件中的，因为如果文件有硬链接的话，很难让这些属性信息保持同步。\n\n### Filename\n\n**文件名**：The names in a directory are called filenames. The only two characters that cannot appear in a filename are the slash character (/) and the null character. The slash separates the filenames that form a pathname (described next) and the null character terminates a pathname. Nevertheless, it’s good practice to restrict the characters in a filename to a subset of the normal printing characters. (If we use some of the shell’s special characters in the filename, we have to use the shell’s quoting mechanism to reference the filename, and this can get complicated.) Indeed, for portability, POSIX.1 recommends restricting filenames to consist of the following characters: letters (a-z, A-Z), numbers (0-9), period (.), dash (-), and underscore (_).\n一个目录中的诸多名字（包括文件和目录）称为文件名，只有两个字符不能出现在文件名中：`斜杠/(slash)`和`空字符(null character)`，斜杠用来分割`路径名(pathname)`中的文件名，空字符用来结束一个路径名（实际上编程语言中字符串就是由空字符来结束的）。然而，我们命名文件的时候最好不要使用一些乱七八糟的字符，如果我们使用了shell的特殊字符，我们就必须使用shell的引用机制去引用文件名。实际上，为了可移植性，POSIX.1标准推荐严格使用以下字符来命名文件：字母(a-z, A-Z)，数字(0-9)，点(.)，中杠(-)，下划线(_)。\n\nTwo filenames are automatically created whenever a new directory is created: . (called dot) and .. (called dot-dot). Dot refers to the current directory, and dot-dot refers to the parent directory. In the root directory, dot-dot is the same as dot. 有两个文件名在目录被创建的时候自动创建：`.`和`..`，`.`指向当前目录，`..`指向父目录，在根目录中，`..`和`.`一样（都指向当前目录）。\n\n>The Research UNIX System and some older UNIX System V file systems restricted a filename to 14 characters. BSD versions extended this limit to 255 characters. Today, almost all commercial UNIX file systems support at least 255-character filenames. 现如今的unix文件系统都支持至少255字符的文件名。\n\n### Pathname\n\nA sequence of one or more filenames, separated by slashes and optionally starting with a slash, forms a pathname. A pathname that begins with a slash is called an absolute pathname; otherwise, it’s called a relative pathname. Relative pathnames refer to files relative to the current directory. 一系列的由斜杠分割而开的文件名组成一个路径名，一个路径名可以由一个斜杠开始，这叫做：`绝对路径`，反之就是相对路径，相对路径是相对于当前路径的。\n\n### Example\n\nListing the names of all the files in a directory is not difficult. There is a bare-bones implementation of the ls(1) command:\n\n> Figure 1.3 List all the files in a directory \n\n```C\n#include \"apue.h\"\n#include <dirent.h>\n\nint main(int argc, char *argv[])\n{\n   DIR *dp;\n   struct dirent *dirp;\n   if (argc != 2)\n       err_quit(\"usage: ls directory_name\");\n   if ((dp = opendir(argv[1])) == NULL)\n       err_sys(\"can’t open %s\", argv[1]);\n   while ((dirp = readdir(dp)) != NULL)\n       printf(\"%s\\n\", dirp->d_name);\n    closedir(dp);\n    exit(0);\n}\n```\n\nThe notation ls(1) is the normal way to reference a particular entry in the UNIX system manuals. It refers to the entry for ls in Section 1. The sections are normally numbered 1 through 8, and all the entries within each section are arranged alphabetically. Throughout this text, we assume that you have a copy of the manuals for your UNIX system.  熟悉unix的人应该都知道，unix有个man命令，可以查看其它命令的说明书，当然也可以`man man`查看自己的说明书。 man命令有8个section，每个section里的条目按照字幕顺序排列。\n\n> Historically, UNIX systems lumped all eight sections together into what was called the UNIX Programmer’s Manual. As the page count increased, the trend changed to distributing the sections among separate manuals: **one for users, one for programmers, and one for system administrators**, for example. Some UNIX systems further divide the manual pages within a given section, using an uppercase letter. For example, all the standard input/output (I/O) functions in AT&T [1990e] are indicated as being in Section 3S, as in fopen(3S). Other systems have replaced the numeric sections with alphabetic ones, such as C for commands. \n\nToday, most manuals are distributed in electronic form. If your manuals are online, the way to see the manual pages for the ls command would be something like \n\n```shell\nman 1 ls\n```\n\nor\n\n```shell\nman -s1 ls\n```\n\nFigure 1.3 is a program that just prints the name of every file in a directory, and nothing else. If the source file is named myls.c, we compile it into the default a.out executable file by running \n\n```shell\ncc myls.c\n```\n\n> Historically, cc(1) is the C compiler. On systems with the GNU C compilation system, the C \n>\n> compiler is gcc(1). Here, cc is usually linked to gcc. \n\n但在实际的操作过程中，遇到了如下错误：\n\n```\nUndefined symbols for architecture x86_64:\n  \"_err_quit\", referenced from:\n      _main in fig1-457251.o\n  \"_err_sys\", referenced from:\n      _main in fig1-457251.o\nld: symbol(s) not found for architecture x86_64\nclang: error: linker command failed with exit code 1 (use -v to see invocation)\n```\n\n这是个链接错误，具体的解决办法请看这篇博客：[OS X下UNIX环境高级编程（第三版）学习日志－第一章ChapterI，编译apue包与第一个例程](https://my.oschina.net/alextuan/blog/530425)\n\n- When the program is done, it calls the function exit with an argument of 0. The function exit terminates a program. By convention, an argument of 0 means OK, and an argument between 1 and 255 means that an error occurred.  **0代表OK，1到255代表各种类型的错误**。\n\n### Working Directory\n\n**工作目录（working directory）**：Every process has a working directory, sometimes called the **current working directory**. This is the directory from which all relative pathnames are interpreted. A process can change its working directory with the `chdir` function.  每个进程都有一个工作目录，又叫做：当前工作目录，相对路径就是相对于当前工作目录的来解释的，可以调用`chdir`函数来改变工作目录。\n\nFor example, the relative pathname doc/memo/joe refers to the file or directory joe, in the directory memo, in the directory doc, which must be a directory within the working directory. From looking just at this pathname, we know that both doc and memo have to be directories, but we can’t tell whether joe is a file or a directory. The pathname /usr/lib/lint is an absolute pathname that refers to the file or directory lint in the directory lib, in the directory usr, which is in the root directory.  这里有趣的一点是，我们无法判断joe是文件还是目录。\n\n### Home Directory\n\nWhen we log in, the working directory is set to our **home directory**. Our home directory is obtained from our entry in the **password file** (Section 1.3).  当我们登陆的时候，工作目录会设定为home目录，而我们的home目录设置在口令文件中。\n\n## 1.5    Input and Output\n\n### File Descriptors\n\n**文件描述符（file descriptor）**：File descriptors are normally small non-negative integers that the kernel uses to identify the files accessed by a process. Whenever it opens an existing file or creates a new file, the kernel returns a file descriptor that we use when we want to read or write the file.  文件描述符是一个小的非负整数，内核用它来标识正在被进程访问的文件。打开或者创建文件的时候内核会返回一个文件描述符，我们可以使用这个文件描述符来对文件进行读写。\n\n### Standard Input, Standard Output, and Standard Error\n\n**标准输入，标准输出，标准错误**：By convention, all shells open three descriptors whenever a new program is run: standard input, standard output, and standard error. If nothing special is done, as in the simple command \n\n```\nls\n```\n\nthen **all three are connected to the terminal**. Most shells provide a way to redirect any or all of these three descriptors to any file. For example, \n\n```\nls > file.list\n```\n\nexecutes the ls command with its standard output redirected to the file named \n\nfile.list. \n\n**按照惯例，当新程序运行的时候，shell会打开三个文件描述符：标准输入，标准输出，标准错误。如果没有进行指明，那么三个文件描述符都会连接到终端。**\n\n### Unbuffered I/O\n\nUnbuffered I/O is provided by the functions `open`, `read`,` write`, `lseek`, and `close`. These functions all work with file descriptors. **unbuffered I/O**意思是系统不提供buffer管理，要你自己申请buffer，并传递给系统函数。\n\n### Example\n\nIf we’re willing to read from the standard input and write to the standard output, then the program in Figure 1.4 copies any regular file on a UNIX system. \n\n> Figure 1.4 Copy standard input to standard output \n\n```C\n#include \"apue.h\"\n#define BUFFSIZE 4096\nint main(void)\n{\n    int n;\n    char buf[BUFFSIZE];\n    while ((n = read(STDIN_FILENO, buf, BUFFSIZE)) > 0)\n        if (write(STDOUT_FILENO, buf, n) != n)\n            err_sys(\"write error\");\n    if (n < 0)\n        err_sys(\"read error\");\n\texit(0); \n}\n```\n\n下面是对程序的解释：\n\nThe `<unistd.h>` header, included by `apue.h`, and the two constants `STDIN_FILENO` and `STDOUT_FILENO` are part of the POSIX standard (about which we’ll have a lot more to say in the next chapter). This header contains function prototypes for many of the UNIX system services, such as the `read` and `write` functions that we call. \n\nThe constants STDIN_FILENO and STDOUT_FILENO are defined in <unistd.h> and specify the file descriptors for standard input and standard output. **These values are 0 and 1, respectively, as required by POSIX.1**, but we’ll use the names for readability. POSIX.1标准：**标准输入是0，标准输出是1，标准错误是2**。\n\nThe `read` function returns the number of bytes that are read, and this value is used as the number of bytes to `write`. When the end of the input file is encountered, read returns 0 and the program stops. If a read error occurs, read returns −1. Most of the system functions return −1 when an error occurs.  `read`函数返回的是读入字节的个数，把这个返回值传给`write`函数，就可以读多少写多少了，当遇到输入文件结束时，read函数返回0，当遇到错误时，read函数返回-1。**许多系统函数返回-1，当它们遇到错误时**。\n\nIf we compile the program into the standard name (a.out) and execute it as \n\n```shell\n./a.out > data\n```\n\nstandard input is the terminal, standard output is redirected to the file data, and standard error is also the terminal. **If this output file doesn’t exist, the shell creates it by default**. The program copies lines that we type to the standard output **until we type the end-of-file character (usually Control-D)**. \n\nIf we run \n\n```shell\n./a.out < infile > outfile\n```\n\nthen the file named infile will be copied to the file named outfile. \n\n如果文件不存在，shell默认给我们创建一个。标准输入和标准错误都是终端，我们可以一直输入，直到输入一个文件结束符，也就是`ctrl+d`。\n\n### Standard I/O\n\nThe standard I/O functions provide a buffered interface to the unbuffered I/O functions. **Using standard I/O relieves us from having to choose optimal buffer sizes**, such as the BUFFSIZE constant in Figure 1.4. The standard I/O functions also simplify dealing with lines of input (a common occurrence in UNIX applications). **The `fgets` function, for example, reads an entire line. The read function, in contrast, reads a specified number of bytes**. As we shall see in Section 5.4, the standard I/O library provides functions that let us control the style of buffering used by the library. 标准I/O函数给unbuffered I/O 函数提供了缓冲接口，使用标准I/O函数可以让我们从优化buffer大小中解脱出来，举个例子，`fgets`函数直接读取一整行，而`read`函数读取固定个数的字节。\n\nThe most common standard I/O function is `printf`. In programs that call printf, we’ll always include <stdio.h>—normally by including apue.h—as this header contains the function prototypes for all the standard I/O functions. \n\n### Example\n\nThe program in Figure 1.5, which we’ll examine in more detail in Section 5.8, is like the previous program that called read and write. This program copies standard input to standard output and can copy any regular file. \n\n> Figure 1.5 Copy standard input to standard output, using standard I/O \n\n```C\n#include \"apue.h\"\nint main(void)\n{\n\tint c;\n    while ((c = getc(stdin)) != EOF)\n    \tif (putc(c, stdout) == EOF)\n    \t\terr_sys(\"output error\");\n    if (ferror(stdin))\n    \terr_sys(\"input error\");\n\texit(0);\n}\n```\n\n**The function getc reads one character at a time, and this character is written by putc**. After the last byte of input has been read, getc returns the constant EOF (defined in <stdio.h>). The standard I/O constants stdin and stdout are also defined in the <stdio.h> header and refer to the standard input and standard output. \n\n## 1.6    Programs and Processes\n\n### Program\n\nA program is an executable file residing on disk in a directory. A program is read into memory and is executed by the kernel as a result of one of the **seven exec functions**. \n\n### Processes and Process ID \n\nAn executing instance of a program is called a **process**, a term used on almost every page of this text. Some operating systems use the term **task** to refer to a program that is being executed.  程序运行的一个实例叫做：进程，也有些操作系统使用：task这个术语来描述被执行的程序。\n\nThe UNIX System guarantees that every process has a unique numeric identifier called the process ID. The process ID is always a non-negative integer. unix系统保证每个进程都有独一无二的进程ID，这个进程ID是一个非负整数。\n\n### Example\n\nThe program in Figure 1.6 prints its process ID. \n\n> Figure 1.6 Print the process ID  \n\n```C\n#include \"apue.h\"\nint main(void)\n{\n    printf(\"hello world from process ID %ld\\n\", (long)getpid());\n    exit(0); \n}\n```\n\n输出结果：\n\n```\n➜  apue.3e ./fig1.6\nhello world from process ID 8080\n➜  apue.3e ./fig1.6\nhello world from process ID 8086\n```\n\n### Process Control\n\nThere are three primary functions for process control: `fork`, `exec`, and `waitpid`. (The exec function has seven variants, but we often refer to them collectively as simply the exec function.)  有三个进程控制的基本函数：`fork`，`exec`和`waitpid`，虽然exec函数有7种变体，但我们往往简单的用一个exec来表示它们。\n\n### Example\n\nThe process control features of the UNIX System are demonstrated using a simple program (Figure 1.7) that reads commands from standard input and executes the commands. This is a bare-bones implementation of a shell-like program. \n\n> Figure 1.7 Read commands from standard input and execute them \n\n```C\n#include \"include/apue.h\"\n#include <sys/wait.h>\n\nint main(void)\n{\n    char    buf[MAXLINE];   /* from apue.h */\n    pid_t   pid;\n    int     status;\n\n    printf(\"%% \");  /* print prompt (printf requires %% to print %) */\n    while (fgets(buf, MAXLINE, stdin) != NULL) {\n        if (buf[strlen(buf) - 1] == '\\n')\n            buf[strlen(buf) - 1] = 0; /* replace newline with null */\n        if ((pid = fork()) < 0) {\n            err_sys(\"fork error\");\n        } else if (pid == 0) {      /* child */\n            execlp(buf, buf, (char *)0);\n            // or\n            // execlp(buf, buf, (char *)NULL);\n            err_ret(\"couldn’t execute: %s\", buf);\n            exit(127);\n\t\t}\n        /* parent */\n        if ((pid = waitpid(pid, &status, 0)) < 0)\n            err_sys(\"waitpid error\");\n        printf(\"%% \");\n\t}\n\texit(0); \n}\n```\n\nThere are several features to consider in this 30-line program. \n\n- We use the standard I/O function fgets to read one line at a time from the standard input. When we type the end-of-file character (which is often Control-D) as the first character of a line, fgets returns a null pointer, the loop stops, and the process terminates. In Chapter 18, we describe all the special terminal characters—end of file, backspace one character, erase entire line, and so on—and how to change them.  我们使用了标准I/O函数`fgets`来一次读取标准输入的一行。当我们直接输入一个EOF时，fgets返回一个空指针，循环停止，进程终止。在第18章，我们将讲述特殊终止符，比如：end of file，backspace one character, erase entire line, 等等，以及如何改变它们。\n- Because each line returned by fgets is terminated with a newline character, followed by a null byte, we use the standard C function strlen to calculate the length of the string, and then replace the newline with a null byte. We do this because the execlp function wants a null-terminated argument, not a newline-terminated argument.  因为fgets返回的每一行都被一个换行符终止，换行符之后是一个空字符，我们使用标准C函数`strlen`来计算string的长度，然后将换行符替换成空字符（这样末尾就两个空字符了）。我们这样做是因为`execlp`函数希望有一个空字符来作为结尾参数，而不是一个换行符。\n- We call fork to create a new process, which is a copy of the caller. We say that the caller is the parent and that the newly created process is the child. Then fork returns the non-negative process ID of the new child process to the parent, and returns 0 to the child. Because fork creates a new process, we say that it is called once—by the parent—but returns twice—in the parent and in the child.  我们调用`fork`创建一个新进程，这个新进程是调用进程的一个复制。我们说，调用者是父进程，新创建出来的进程是子进程。**然后fork返回子进程的非负进程ID给父进程，并返回0给子进程**。因为fork创建了一个新进程，**我们说它调用了一次（被父进程），但是返回了两次**，在父进程和子进程里面。\n- In the child, we call execlp to execute the command that was read from the standard input. This replaces the child process with the new program file. The combination of fork followed by exec is called spawning a new process on some operating systems. In the UNIX System, the two parts are separated into individual functions. We’ll say a lot more about these functions in Chapter 8.  在子进程中，我们调用`execlp`来执行从标注输入中读取来的命令。这就把子进程替换成了新执行的程序。fork后面跟个exec这种结合方式被叫做 **spawning a new process** 在某些操作系统中。在unix系统中，这两部分被分别放到了两个单独的函数中。我们将在第8章中讨论更多的这类函数。\n- Because the child calls execlp to execute the new program file, the parent wants to wait for the child to terminate. This is done by calling waitpid, specifying which process to wait for: the pid argument, which is the process ID of the child. The waitpid function also returns the termination status of the child—the status variable—but in this simple program, we don’t do anything with this value. We could examine it to determine how the child terminated.  因为子进程调用了`execlp`来执行新程序文件，父进程想要等子进程结束。通过调用`waitpid`可以完成这个任务，用`pid`（子进程的进程ID）参数来明确需要等待哪个进程。`waitpid`函数同样也返回子进程的终止状态（记录在status这个参数），但在这个简单的程序里，我们没有用到这个值。我们通过这个值得知子进程是如何结束的。\n- The most fundamental limitation of this program is that we can’t pass arguments to the command we execute. We can’t, for example, specify the name of a directory to list. We can execute ls only on the working directory. To allow arguments would require that we parse the input line, separating the arguments by some convention, probably spaces or tabs, and then pass each argument as a separate parameter to the execlp function. Nevertheless, this program is still a useful demonstration of the UNIX System’s process control functions.  这个程序最大的限制就是，我们不能传递参数给我们要执行的命令。比如，我们不能给定一个目录给list程序（展示目录下的所有目录和文件的程序）。我们只能在当前目录下执行ls。如果要允许传递参数，就需要我们分析输入行，按照惯例，比如空格或者制表符，把参数分割开来，然后把参数传给execlp函数。不管怎么说，这个程序已经很好的展示了unix系统是如何控制函数的。\n\nIf we run this program, we get the following result. Note that our program has a different prompt—the percent sign—to distinguish it from the shell’s prompt. \n\n```\n➜  apue.3e ./fig1.7\n% pwd\n/Users/liuqinh2s/Downloads/apue.3e\n% who\nliuqinh2s console  May 21 12:09\nliuqinh2s ttys000  May 21 12:10\n% date\n2018年 5月24日 星期四 15时26分59秒 CST\n% %                                                                                                                                                                                                         ➜  apue.3e\n```\n\n> The notation ˆD is used to indicate a control character. Control characters are special characters formed by holding down the control key—often labeled Control or Ctrl—on your keyboard and then pressing another key at the same time. **Control-D, or ˆD, is the default end-of-file character**. We’ll see many more control characters when we discuss terminal I/O in Chapter 18.  `^D`这种记法用于表示控制字符，控制字符是一类特殊的字符，由`ctrl`键加一个其他键组成，`Control-D`或者说`^D`是默认的文件终止符。我们将在第18章讨论输入输出终止符的时候看到更多的控制字符。\n\n### Threads and Thread IDs\n\nUsually, a process has only one thread of control—one set of machine instructions executing at a time. Some problems are easier to solve when more than one thread of control can operate on different parts of the problem. Additionally, multiple threads of control can exploit the parallelism possible on multiprocessor systems. \n\nAll threads within a process share the same address space, file descriptors, stacks, and process-related attributes. Each thread executes on its own stack, although any thread can access the stacks of other threads in the same process. Because they can access the same memory, the threads need to synchronize access to shared data among themselves to avoid inconsistencies.  属于同一个进程的多个线程共享同一块内存空间，文件描述符，栈，以及和进程相关的属性。每个线程都在自己的栈里面执行，但每个线程又能访问其他线程的栈（同属于一个进程的多个线程）。因为它们能访问同一块内存，所以为了避免不一致性，需要保护好临界资源。\n\nLike processes, threads are identified by IDs. **Thread IDs, however, are local to a process**. A thread ID from one process has no meaning in another process. We use thread IDs to refer to specific threads as we manipulate the threads within a process.  就像进程一样，线程也用ID标识。**然而线程ID是局部的，只在某个进程内有效，出了这个进程，对其他进程来说这个线程ID就没有任何意义了。**\n\n> threads were added to the UNIX System long after the process model was established \n\n## 1.7    Error Handling\n\nWhen an error occurs in one of the UNIX System functions, a negative value is often returned, and the integer **errno** is usually set to a value that tells why. For example, the open function returns either a non-negative file descriptor if all is OK or −1 if an error occurs. An error from open has about 15 possible errno values, such as file doesn’t exist, permission problem, and so on. Some functions use a convention other than returning a negative value. For example, most functions that return a pointer to an object return a null pointer to indicate an error.  当unix系统函数出错时，会返回一个负数，整形变量**errno**会设置为一个值，这个值告诉我们为什么出错。例如，open函数返回一个非负的文件描述符，如果成功的话，如果出现错误则返回一个-1。open函数返回的错误有15个可能的errno值，比如：文件不存在，权限问题，等等。有些函数使用另一个传统而非返回一个负数。例如，很多函数返回一个对象指针，或者一个空指针如果出现错误。\n\nThe file <errno.h> defines the symbol errno and constants for each value that errno can assume. Each of these constants begins with the character E. Also, the first page of Section 2 of the UNIX system manuals, named intro(2), usually lists all these error constants. For example, if errno is equal to the constant EACCES, this indicates a permission problem, such as insufficient permission to open the requested file.  `<errno.h>`文件定义了变量errno和一系列常量（errno可能的值）。每个常量都以字符`E`开头。unix系统手册`intro(2)`展示了这些常量。例如，如果errno等于常量EACCES，就表示是权限问题，没有足够的权限去打开这个文件。\n\n> On Linux, the error constants are listed in the errno(3) manual page. \n\nPOSIX and ISO C define errno as a symbol expanding into a modifiable lvalue of type integer. This can be either an integer that contains the error number or a function that returns a pointer to the error number. The historical definition is \n\n```C\nextern int errno;\n```\n\nBut in an environment that supports threads, the process address space is shared among multiple threads, and each thread needs its own local copy of errno to prevent one thread from interfering with another. Linux, for example, supports multithreaded access to errno by defining it as \n\n```C\nextern int *__errno_location(void); \n#define errno (*__errno_location())\n```\n\nPOSIX和ISO C把errno定义为一个可以修改的左值。可以定义为一个整形值，也可以定义为一个指针，指针指向错误码（String类型）。如果是多线程环境下，每个线程都有自己的一个errno拷贝。通过宏定义把errno给替换成函数：`int *__errno_location(void); `了。\n\nThere are two rules to be aware of with respect to errno. First, its value is never cleared by a routine if an error does not occur. Therefore, we should examine its value only when the return value from a function indicates that an error occurred. Second, the value of errno is never set to 0 by any of the functions, and none of the constants defined in <errno.h> has a value of 0.  第一，如果没有出错，errno的值不会被重置，因此，我们只有在函数返回出错的时候才检查errno；第二，errno不会等于0。\n\nTwo functions are defined by the C standard to help with printing error messages. \n\n```C\n#include <string.h>\n\nchar *strerror(int errnum);\t//Returns: pointer to message string\n```\n\nThis function maps errnum, which is typically the errno value, into an error message string and returns a pointer to the string. \n\nThe perror function produces an error message on the standard error, based on the current value of errno, and returns. \n\n```C\n#include <stdio.h>\n\nvoid perror(const char* msg);\n```\n\nIt outputs the string pointed to by msg, followed by a colon and a space, followed by the error message corresponding to the value of errno, followed by a newline. \n\n### Example\n\nFigure 1.8 shows the use of these two error functions. \n\n> Figure 1.8 Demonstrate strerror and perror \n\n```C\n#include \"apue.h\"\n#include <errno.h>\nint main(int argc, char *argv[])\n{\n    fprintf(stderr, \"EACCES: %s\\n\", strerror(EACCES));\n    errno = ENOENT;\n    perror(argv[0]);\n    exit(0);\n}\n```\n\n输出结果：\n\n```\n➜  apue.3e ./fig1.8\nEACCES: Permission denied\n./fig1.8: No such file or directory\n➜  apue.3e\n```\n\n> argv[0] 表示输入的第一个参数，也就是命令名\n\n### Error Recovery\n\nThe errors defined in <errno.h> can be divided into two categories: fatal and nonfatal. A fatal error has no recovery action. The best we can do is print an error message on the user’s screen or to a log file, and then exit. Nonfatal errors, on the other hand, can sometimes be dealt with more robustly. Most nonfatal errors are temporary, such as a resource shortage, and might not occur when there is less activity on the system.  定义在`<errno.h>`中的错误可以分为两类：fatal和nonfatal，致命和非致命。致命错误没有恢复动作，我们最多能做的就是把错误信息在用户显示屏上打印出来，或者写到log文件里，然后退出。非致命错误，可以更妥善的处理，许多非致命错误都是暂时的，比如：资源短缺，当系统活动较少时这类错误可能不会发生。\n\nResource-related nonfatal errors include **EAGAIN, ENFILE, ENOBUFS, ENOLCK, ENOSPC, EWOULDBLOCK**, and sometimes **ENOMEM**. **EBUSY** can be treated as nonfatal when it indicates that a shared resource is in use. Sometimes, **EINTR** can be treated as a nonfatal error when it interrupts a slow system call (more on this in Section 10.5).  \n\nThe typical recovery action for a resource-related nonfatal error is to delay and retry later. This technique can be applied in other circumstances. For example, if an error indicates that a network connection is no longer functioning, it might be possible for the application to delay a short time and then reestablish the connection. Some applications use an exponential backoff algorithm, waiting a longer period of time in each subsequent iteration.  **典型的资源相关性非致命错误的处理办法是先等一下，之后再重试。**\n\n**Ultimately, it is up to the application developer to determine the cases where an application can recover from an error. If a reasonable recovery strategy can be used, we can improve the robustness of our application by avoiding an abnormal exit. **\n\n## 1.8    User Identification\n\n### User ID\n\nThe user ID from our entry in the password file is a numeric value that identifies us to the system. This user ID is assigned by the system administrator when our login name is assigned, and we cannot change it. The user ID is normally assigned to be unique for every user. We’ll see how the kernel uses the user ID to check whether we have the appropriate permissions to perform certain operations.  用户ID来自口令文件中对应的条目，它是以数字的形式帮助系统对我们进行标识。用户ID是系统管理员给我们分配的（当分配登录名时，同时也必须分配用户ID），我们自己无法改。每个人的用户ID应该是唯一的，内核使用用户ID来检查我们是否有合适的权限来进行一个操作。\n\nWe call the user whose user ID is 0 either root or the superuser. The entry in the password file normally has a login name of root, and we refer to the special privileges of this user as superuser privileges. As we’ll see in Chapter 4, if a process has superuser privileges, most file permission checks are bypassed. Some operating system functions are restricted to the superuser. The superuser has free rein over the system.  我们把用户ID为0的用户称为：**root**或者**superuser**。口令文件中有一个条目的登录名是root，root用户拥有特殊权限。拥有superuser特权的进程可以自由的使用任意文件，而且有些操作系统函数是只对superuser开放的。superuser拥有对系统的绝对的权限（可以把系统弄残）。\n\n> Client versions of Mac OS X ship with the superuser account disabled; server versions ship with the account already enabled. Instructions are available on Apple’s Web site describing how to enable it. See http://support.apple.com/kb/HT1528. \n\n### Group ID\n\nOur entry in the password file also specifies our numeric group ID. This, too, is assigned by the system administrator when our login name is assigned. Typically, the password file contains multiple entries that specify the same group ID. Groups are normally used to collect users together into projects or departments. This allows the sharing of resources, such as files, among members of the same group. We’ll see in Section 4.5 that we can set the permissions on a file so that all members of a group can access the file, whereas others outside the group cannot.  Group ID的作用就是让相同组的人共享资源。\n\nThere is also a group file that maps group names into numeric group IDs. The group file is usually `/etc/group`. \n\nThe use of numeric user IDs and numeric group IDs for permissions is historical. With every file on disk, the file system stores both the user ID and the group ID of a file’s owner. Storing both of these values requires only four bytes, assuming that each is stored as a two-byte integer. If the full ASCII login name and group name were used instead, additional disk space would be required. In addition, comparing strings during permission checks is more expensive than comparing integers.  使用数字的用户ID和组ID是有历史原因的。对于每个存放在磁盘上的文件，文件系统都存储了该文件的拥有者的用户ID和组ID。存储这两个数字需要4字节（每个2字节），如果使用ASCII编码的登录名和组名，需要多用掉很多额外的磁盘空间。另外在检查权限是否合格时，整形数字比较要比字符串比较更快。\n\nUsers, however, work better with names than with numbers, so the password file maintains the mapping between login names and user IDs, and the group file provides the mapping between group names and group IDs. The ls -l command, for example, prints the login name of the owner of a file, using the password file to map the numeric user ID into the corresponding login name.  然而对于用户来说名字比数字更好记，所以password file和group file分别记录了登录名和用户ID的映射，组名和组ID的映射。使用`ls -l`命令，可以看到打印出了文件所属者和所属的组，其原理就是查找了password file和group file，把相应的数字ID换成名字。\n\n> Early UNIX systems used 16-bit integers to represent user and group IDs. Contemporary UNIX systems use 32-bit integers. \n\n### Example\n\nThe program in Figure 1.9 prints the user ID and the group ID. \n\n> Figure 1.9 Print user ID and group ID  \n\n```C\n#include \"apue.h\"\n\nint main(void)\n{\n\tprintf(\"uid = %d, gid = %d\\n\", getuid(), getgid());\n\texit(0); \n}\n```\n\n### Supplementary Group IDs \n\n**附加组（supplementary group）**：In addition to the group ID specified in the password file for a login name, most versions of the UNIX System allow a user to belong to other groups. This practice started with 4.2BSD, which allowed a user to belong to up to 16 additional groups. These supplementary group IDs are obtained at login time by reading the file /etc/group and finding the first 16 entries that list the user as a member. As we shall see in the next chapter, POSIX requires that a system support at least 8 supplementary groups per process, but most systems support at least 16.  许多unix系统允许用户属于多个组，最多16个。主组，也就是登陆时的默认组记录在`/etc/passwd`中。\n\n`/etc/group`格式如下：\n\n```shell\n_analyticsusers:*:250:_analyticsd,_networkd,_timed\n_analyticsd:*:263:_analyticsd\n```\n\n解释：\n\n```\n组名:口令:组ID:组内用户列表\n```\n\n## 1.9    Signal\n\nSignals are a technique used to notify a process that some condition has occurred. For example, if a process divides by zero, the signal whose name is SIGFPE (floating-point exception) is sent to the process. The process has three choices for dealing with the signal.  信号是一种用来通知进程发生了某些事的技术。举个例子：当进程除以0时，就会有一个SIGFPE (floating-point exception)发送到这个进程。进程处理信号有三种选择：\n\n1. Ignore the signal. This option isn’t recommended for signals that denote a hardware exception, such as dividing by zero or referencing memory outside the address space of the process, as the results are undefined.  忽视信号。如果是硬件异常不推荐这个选择，例如：被0除，引用进程外的内存，因为这些结果都是不确定的。\n2. Let the default action occur. For a divide-by-zero condition, the default is to terminate the process.  让默认动作出现，比如被0除的情况下，默认是终止该进程。\n3. Provide a function that is called when the signal occurs (this is called ‘‘catching’’ the signal). By providing a function of our own, we’ll know when the signal occurs and we can handle it as we wish.  我们自己提供一个函数捕获信号，这样我们就能让程序以我们的意愿处理异常。\n\nMany conditions generate signals. Two terminal keys, called the **interrupt key**— often the **DELETE** key or **Control-C**—and the **quit key**—often **Control-backslash**—are used to interrupt the currently running process. Another way to generate a signal is by calling the `kill` function. **We can call this function from a process to send a signal to another process. Naturally, there are limitations: we have to be the owner of the other process (or the superuser) to be able to send it a signal**.    很多条件下可以生成信号，终端键有两种，interrupt key（delete键或者ctrl+c）和 quit key（ctrl+\\）。另一个生成信号的方法是调用`kill`函数，我们可以在一个进程里调用kill函数来结束另一个线程，但我们需要有权限（如果我们是另一个进程的拥有者，或者是超级用户，就可以）。\n\n### Example\n\nRecall the bare-bones shell example (Figure 1.7). If we invoke this program and press the interrupt key, the process terminates because the default action for this signal, named SIGINT, is to terminate the process. The process hasn’t told the kernel to do anything other than the default with this signal, so the process terminates.  如果直接执行Figure 1.7的代码，我们按下中断键，程序就会终止，因为这个SIGINT信号的默认动作就是终止进程。\n\nTo catch this signal, the program needs to call the signal function, specifying the name of the function to call when the SIGINT signal is generated. The function is named sig_int; when it’s called, it just prints a message and a new prompt. Adding 11 lines to the program in Figure 1.7 gives us the version in Figure 1.10. (The 11 new lines are indicated with a plus sign at the beginning of the line.)  为了捕获这个信号，程序需要调用一个信号函数。我们给它命名为：`sig_int`函数，在捕获到**SIGINT**信号之后，打印信息并打印一个新的提示符。下面的程序相比Figure 1.7多了11行，用`+`号标识了。\n\n> Figure 1.10 Read commands from standard input and execute them \n\n```C\n  #include \"include/apue.h\"\n  #include <sys/wait.h>\n  \n+ static void sig_int(int);\t/* our signal-catching function */\n+\n  int main(void)\n  {\n      char    buf[MAXLINE];   /* from apue.h */\n      pid_t   pid;\n      int     status;\n  \n  +\t  if(signal(SIGINT, sig_int) == SIG_ERR)\n          err_sys(\"signal error\");\n    \n      printf(\"%% \");  /* print prompt (printf requires %% to print %) */\n      while (fgets(buf, MAXLINE, stdin) != NULL) {\n          if (buf[strlen(buf) - 1] == '\\n')\n              buf[strlen(buf) - 1] = 0; /* replace newline with null */\n          if ((pid = fork()) < 0) {\n              err_sys(\"fork error\");\n          } else if (pid == 0) {      /* child */\n              execlp(buf, buf, (char *)0);\n              err_ret(\"couldn’t execute: %s\", buf);\n              exit(127);\n\t\t  }\n          /* parent */\n          if ((pid = waitpid(pid, &status, 0)) < 0)\n              err_sys(\"waitpid error\");\n          printf(\"%% \");\n\t  }\n\t  exit(0); \n  }\n+\n+ void sig_int(int signo){\n+     printf(\"interrupt\\n%% \");\n+ }\n```\n\n## 1.10    Time Values\n\nHistorically, UNIX systems have maintained two different time values: \n\n1. **Calendar time**. This value counts the number of seconds since the **Epoch: 00:00:00 January 1, 1970,Coordinated Universal Time (UTC)**. (Older manuals refer to UTC as Greenwich Mean Time.) These time values are used to record the time when a file was last modified, for example. \n\n   The primitive system data type `time_t` holds these time values. \n\n2. **Process time**. This is also called CPU time and measures the central processor resources used by a process. Process time is measured in clock ticks, which have historically been 50, 60, or 100 ticks per second. \n\n   The primitive system data type `clock_t` holds these time values. (We’ll show how to obtain the number of clock ticks per second with the `sysconf` function in Section 2.5.4.) \n\n有两种类型的时间：**日历时间**和**进程时间**，日历时间也就是UTC。\n\nWhen we measure the execution time of a process, as in Section 3.9, we’ll see that the UNIX System maintains three values for a process: \n\n- Clock time \n- User CPU time \n- System CPU time \n\nThe clock time, sometimes called **wall clock time**, is the amount of time the process takes to run, and its value depends on the number of other processes being run on the system. Whenever we report the clock time, the measurements are made with no other activities on the system. \n\nThe user CPU time is the CPU time attributed to user instructions. The system CPU time is the CPU time attributed to the kernel when it executes on behalf of the process. For example, whenever a process executes a system service, such as read or write, the time spent within the kernel performing that system service is charged to the process. The sum of user CPU time and system CPU time is often called the CPU time. \n\n度量进程执行时间，有三种：\n\n1. 墙上时钟，也就是进程执行花费的总时间。\n2. 用户CPU时间，是用户模式（非内核）下的CPU使用时间\n3. 系统CPU时间，是进程进入内核执行的CPU使用时间\n\nIt is easy to measure the clock time, user time, and system time of any process: simply execute the time(1) command, with the argument to the time command being the command we want to measure. For example: \n\n```shell\n$ cd /usr/include\n$ time -p grep _POSIX_SOURCE */*.h > /dev/null\n```\n\n结果：\n\n```\nreal    0m0.81s\nuser    0m0.11s\nsys     0m0.07s\n```\n\nThe output format from the time command depends on the shell being used, because some shells don’t run /usr/bin/time, but instead have a separate built-in function to measure the time it takes commands to run.  time命令的输出格式取决于使用什么shell，因为有些shell并不运行：`/usr/bin/time`，而是运行自己内置的一个time函数。\n\n## 1.11    System Calls and Library Functions\n\nAll operating systems provide service points through which programs request services from the kernel. All implementations of the UNIX System provide a well-defined, limited number of entry points directly into the kernel called system calls (recall Figure 1.1). Version 7 of the Research UNIX System provided about 50 system calls, 4.4BSD provided about 110, and SVR4 had around 120. The exact number of system calls varies depending on the operating system version. More recent systems have seen incredible growth in the number of supported system calls. Linux 3.2.0 has 380 system calls and FreeBSD 8.0 has over 450.  随着时间的推移，系统调用越来越多，可见系统是越来越完善的。\n\nThe system call interface has always been documented in Section 2 of the UNIX Programmer’s Manual. Its definition is in the C language, no matter which implementation technique is actually used on any given system to invoke a system call. This differs from many older operating systems, which traditionally defined the kernel entry points in the assembly language of the machine.  **系统调用的文档总是在unix编程手册的第二个章节里。它是用C语言定义的**，不管系统具体是如何实现系统调用的。这一点与很多老操作系统不同（老操作系统使用汇编语言定义内核接口）\n\nThe technique used on UNIX systems is for each system call to have a function of the same name in the standard C library. The user process calls this function, using the standard C calling sequence. This function then invokes the appropriate kernel service, using whatever technique is required on the system. For example, the function may put one or more of the C arguments into general registers and then execute some machine instruction that generates a software interrupt in the kernel. For our purposes, we can consider the system calls to be C functions.  每个系统调用都对应一个相同名字的函数在标准C库里。用户进程调用这个函数，然后这个函数调用相应的内核服务。举个例子，这个函数可能会把一个或多个C参数放到通用寄存器，并执行机器指令在内核中产生一个软件中断。从我们的角度看，我们可以直接认为系统调用就是C函数。\n\nSection 3 of the UNIX Programmer’s Manual defines the general-purpose library functions available to programmers. These functions aren’t entry points into the kernel, although they may invoke one or more of the kernel’s system calls. For example, the printf function may use the write system call to output a string, but the strcpy (copy a string) and atoi (convert ASCII to integer) functions don’t involve the kernel at all.  在**unix编程手册第三章定义了通用库函数给程序员。这些函数不是内核入口，虽然它们可能会调用一个或几个内核的系统调用**。举个例子，`printf`函数可能会使用`write`系统调用来输出一个字符串，但是`strcpy`（拷贝一个字符串）和`atoi`（吧ASCII字符转成整形）函数根本没有调用内核。\n\nFrom an implementor’s point of view, the distinction between a system call and a library function is fundamental. From a user’s perspective, however, the difference is not as critical. From our perspective in this text, both system calls and library functions appear as normal C functions. Both exist to provide services for application programs. We should realize, however, that we can replace the library functions, if desired, whereas the system calls usually cannot be replaced.  从实现者的角度来看，系统调用和库函数的区别是很大的。然而从使用者的角度来看，这个区别并不重要。在这本书中，在我们看来，系统调用和库函数都以C函数的形式出现。两者的存在都是为了给应用开发者提供服务。然而我们应该意识到，**虽然我们能替换库函数（如果我们想这样做），但系统调用不能被替换**。\n\nConsider the memory allocation function malloc as an example. There are many ways to do memory allocation and its associated garbage collection (best fit, first fit, and so on). No single technique is optimal for all programs. The UNIX system call that handles memory allocation, sbrk(2), is not a general-purpose memory manager. It increases or decreases the address space of the process by a specified number of bytes. How that space is managed is up to the process. The memory allocation function, malloc(3), implements one particular type of allocation. If we don’t like its operation, we can define our own malloc function, which will probably use the sbrk system call. In fact, numerous software packages implement their own memory allocation algorithms with the sbrk system call. Figure 1.11 shows the relationship between the application, the malloc function, and the sbrk system call.  让我们来看看内存分配函数`malloc`这个例子。有很多内存分配和相关的垃圾回收方法（最好适应算法，最先适应算法，等等）。没有哪个技术是对所有程序优化的。**unix系统调用`sbrk(2)`不是一个通用的存储管理器。它给进程增加和减少内存空间都是固定的字节数。怎么管理空间其实还要取决于进程自己。内存分配函数`malloc(3)`，实现了特定类型的分配。如果我们不喜欢它的做法，我们可以定义自己的malloc函数，但也是要用到sbrk系统调用的。实际上大量的软件包都通过直接使用sbrk系统调用实现了自己的内存管理算法**。图1.11展示了应用，malloc函数，和sbrk系统调用之间的关系。\n\n<img src=\"https://i.loli.net/2018/05/25/5b07647fc7597.png\", width=\"70%\">\n\nHere we have a clean separation of duties: the system call in the kernel allocates an additional chunk of space on behalf of the process. The malloc library function manages this space from user level.  这里职责是分明的：系统调用代表进程在内核里分配了额外的一块空间。malloc库函数在用户层级上管理这块空间。\n\nAnother example to illustrate the difference between a system call and a library function is the interface the UNIX System provides to determine the current time and date. Some operating systems provide one system call to return the time and another to return the date. Any special handling, such as the switch to or from daylight saving time, is handled by the kernel or requires human intervention. The UNIX System, in contrast, provides a single system call that returns the number of seconds since the Epoch: midnight, January 1, 1970, Coordinated Universal Time. Any interpretation of this value, such as converting it to a human-readable time and date using the local time zone, is left to the user process. The standard C library provides routines to handle most cases. These library routines handle such details as the various algorithms for daylight saving time.  另一个描述系统调用和库函数不同的例子是当前时间和日期。某些操作系统提供一个系统调用返回时间，另一个系统调用返回日期。任何特殊的处理，比如正常时制与夏令时的切换，需要内核的处理或者认为干预。Unix系统则相反，只提供一个系统调用，返回UTC（UTC是指从1970年的第一秒开始算起到现在经过的总时间）。任何对UTC这个值的解释，例如把它转成人类可读的时间日期使用当地时间，就留给了用户进程。标准C库提供了诸多例程来处理大多数情况。这些库例程处理这些细节，就像大多数算法处理夏令时切换一样。\n\nAn application can either make a system call or call a library routine. Also realize that many library routines invoke a system call. This is shown in Figure 1.12.  一个应用可以使用系统调用或者调用库例程，同样要意识到许多库例程调用了系统调用。\n\nAnother difference between system calls and library functions is that system calls usually **provide a minimal interface**, whereas library functions often **provide more elaborate functionality**. We’ve seen this already in the difference between the sbrk system call and the malloc library function. We’ll see this difference again later, when we compare the unbuffered I/O functions (Chapter 3) and the standard I/O functions (Chapter 5).  另一个系统调用和库函数的区别就是，系统调用往往只提供一个很小的接口，然而库函数经常提供更多精细的功能。\n\n<img src=\"https://i.loli.net/2018/05/25/5b07d2d3861c0.png\" width=\"70%\">\n\nThe process control system calls (**fork, exec, and waitpid**) are usually invoked by the user’s application code directly. (Recall the bare-bones shell in Figure 1.7.) But some library routines exist to simplify certain common cases: the **system** and **popen** library routines, for example. In Section 8.13, we’ll show an implementation of the system function that invokes the basic process control system calls. We’ll enhance this example in Section 10.18 to handle signals correctly. \n\nTo define the interface to the UNIX System that most programmers use, we have to describe both the system calls and some of the library functions. If we described only the sbrk system call, for example, we would skip the more programmer-friendly malloc library function that many applications use. **In this text, we’ll use the term function to refer to both system calls and library functions, except when the distinction is necessary.** \n\n","slug":"APUE读书笔记--Unix-System-Overview","published":1,"updated":"2018-05-25T09:15:47.231Z","layout":"post","photos":[],"link":"","_id":"cjm2w8ddu003afgpx0omhimvr","content":"<h2 id=\"1-1-Introduction\"><a href=\"#1-1-Introduction\" class=\"headerlink\" title=\"1.1    Introduction\"></a>1.1    Introduction</h2><p>All operating systems provide services for programs they run. Typical services include executing a new program, opening a file, reading a file, allocating a region of memory, getting the current time of day, and so on. The focus of this text is to describe the services provided by various versions of the UNIX operating system. 所有的操作系统都提供一些服务让程序能够在其上运行，典型的服务包括：执行一个新程序，打开一个文件，读取一个文件，分配一块内存，获取当前时间，等等。 这本书所关注的重点就是众多种类的unix操作系统能提供服务。</p>\n<p>Describing the UNIX System in a strictly linear fashion, without any forward references to terms that haven’t been described yet, is nearly impossible (and would probably be boring). 这里道出了一个众所周知的难题，想要线性的给读者讲授一个新课程，在讲授一个知识点时却又不引进任何其他的未知概念，这几乎是不可能的。</p>\n<blockquote>\n<p>但我认为能不能做到，不用去管，做教育的就是要尽可能的降低学习者的难度，将新知识点尽可能的用学习者已有的知识结构描述清楚。所以我们可以看到我们的课程都是有选修课的。</p>\n</blockquote>\n<h2 id=\"1-2-Unix-Architecture\"><a href=\"#1-2-Unix-Architecture\" class=\"headerlink\" title=\"1.2    Unix Architecture\"></a>1.2    Unix Architecture</h2><p><img src=\"https://i.loli.net/2018/05/22/5b03742b0a818.png\" width=\"50%\"></p>\n<ul>\n<li>内核（kernel）：In a strict sense, an operating system can be defined as the software that <strong>controls the hardware resources of the computer</strong> and <strong>provides an environment under which programs can run</strong>. Generally, we call this software the kernel, since it is <strong>relatively small and resides at the core of the environment</strong>. 内核控制硬件资源，并给其上的程序提供运行环境，内核相对（相对是指相对于上面这张图，整个软件环境：包括内核、系统调用、公用函数库、shell(命令解释器)、应用程序）来说比较小，并处于整个环境的中心。</li>\n<li>系统调用（system calls）：<strong>The interface to the kernel</strong> is a layer of software called the system calls . 系统调用是内核对外的接口。</li>\n<li>Libraries of common functions are built on top of the system call interface, but applications are free to use both. The shell is a special application that provides an interface for running other applications. 公共库是建立在系统调用之上的，但应用程序既可以使用公共库也可以使用系统调用。shell是一种特殊的应用程序，给执行命令(运行其他程序)提供接口。</li>\n</ul>\n<h2 id=\"1-3-Logging-In\"><a href=\"#1-3-Logging-In\" class=\"headerlink\" title=\"1.3    Logging In\"></a>1.3    Logging In</h2><h3 id=\"Login-Name\"><a href=\"#Login-Name\" class=\"headerlink\" title=\"Login Name\"></a>Login Name</h3><p><strong>口令文件（password file）</strong> ：当我们使用用户名和密码登陆unix的时候，系统会在<code>/etc/passwd</code>文件(password file，又叫：口令文件)中查找我们的用户名，口令文件中每个条目占一行，格式是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">登录名:加密过的密码:user ID:group ID:注解:home目录:shell</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>不过加密过的密码现在也不显示在这个文件里了，而是用一个<code>*</code>号或者<code>x</code>号之类的取代，home目录又称为起始目录，新开一个shell，<code>pwd</code>一下，就是home目录。</p>\n</blockquote>\n<p>例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sar:x:205:105:Stephen Rago:/home/sar:/bin/ksh</span><br></pre></td></tr></table></figure>\n<p>登录名是sar，加密过的密码是<code>x</code>（不显示在这里），user ID是205，group ID是105，注解是Stephen Rago，home目录是<code>/home/sar</code>，使用的shell是<code>/bin/ksh</code></p>\n<h3 id=\"Shells\"><a href=\"#Shells\" class=\"headerlink\" title=\"Shells\"></a>Shells</h3><p>A shell is a command-line interpreter that reads user input and executes commands. The user input to a shell is normally from the terminal (an interactive shell) or sometimes from a file (called a shell script). shell是一种命令解释器，可以读取用户的输入，并执行命令，用户可以交互式的输入命令，也可以把命令预先全部写在一个文本文件（shell脚本）中让shell执行。</p>\n<p>常见的shell有：</p>\n<p><img src=\"https://i.loli.net/2018/05/23/5b04b995bf5e1.png\" width=\"70%\"></p>\n<p>The system knows which shell to execute for us based on the final field in our entry in the password file. 系统是通过口令文件的最后一个字段知道我们登陆时使用哪个shell。</p>\n<p><code>bash</code>的全称是<code>Bourne-again shell</code></p>\n<p>The Bourne-again shell is the GNU shell provided with all Linux systems. It was designed to be POSIX conformant, while still remaining compatible with the Bourne shell. It supports features from both the C shell and the Korn shell.</p>\n<h2 id=\"1-4-Files-and-Directories\"><a href=\"#1-4-Files-and-Directories\" class=\"headerlink\" title=\"1.4     Files and Directories\"></a>1.4     Files and Directories</h2><h3 id=\"File-System\"><a href=\"#File-System\" class=\"headerlink\" title=\"File System\"></a>File System</h3><ul>\n<li><strong>根目录（root）</strong>：The UNIX file system is a hierarchical arrangement of directories and files. Everything starts in the directory called root, whose name is the single character /. unix文件系统是目录和文件的层级安排，所有东西都从一个叫root的目录开始，root的名字是一个单字符：<code>/</code>。</li>\n<li><strong>目录（directory）</strong>：A directory is a file that contains directory entries. Logically, we can think of each directory entry as containing a filename along with a structure of information describing the attributes of the file. The attributes of a file are such things as the type of file (regular file, directory), the size of the file, the owner of the file, permissions for the file (whether other users may access this file), and when the file was last modified. 目录是一个包含目录条目的文件。逻辑上，我们可以认为每一个目录条目包含一个文件名和一个描述文件属性的结构信息。文件属性包括：文件类型（普通文件还是目录），文件大小，文件所属者，文件权限（其他用户是否能访问），文件最后被修改的时间。</li>\n</ul>\n<blockquote>\n<p>The stat and fstat functions return a structure of information containing all the attributes of a file. <code>stat</code>和<code>fstat</code>函数可以返回一个结构信息，包含文件的所有属性。</p>\n</blockquote>\n<blockquote>\n<p>We make a distinction between the logical view of a directory entry and the way it is actually stored on disk. Most implementations of UNIX file systems don’t store attributes in the directory entries themselves, because of the difficulty of keeping them in synch when a file has multiple hard links. 也就是说上面目录条目只是逻辑上的，实际上在硬盘存储上并不是直接将目录条目中的那些属性存储在目录文件中的，因为如果文件有硬链接的话，很难让这些属性信息保持同步。</p>\n</blockquote>\n<h3 id=\"Filename\"><a href=\"#Filename\" class=\"headerlink\" title=\"Filename\"></a>Filename</h3><p><strong>文件名</strong>：The names in a directory are called filenames. The only two characters that cannot appear in a filename are the slash character (/) and the null character. The slash separates the filenames that form a pathname (described next) and the null character terminates a pathname. Nevertheless, it’s good practice to restrict the characters in a filename to a subset of the normal printing characters. (If we use some of the shell’s special characters in the filename, we have to use the shell’s quoting mechanism to reference the filename, and this can get complicated.) Indeed, for portability, POSIX.1 recommends restricting filenames to consist of the following characters: letters (a-z, A-Z), numbers (0-9), period (.), dash (-), and underscore (<em>).<br>一个目录中的诸多名字（包括文件和目录）称为文件名，只有两个字符不能出现在文件名中：<code>斜杠/(slash)</code>和<code>空字符(null character)</code>，斜杠用来分割<code>路径名(pathname)</code>中的文件名，空字符用来结束一个路径名（实际上编程语言中字符串就是由空字符来结束的）。然而，我们命名文件的时候最好不要使用一些乱七八糟的字符，如果我们使用了shell的特殊字符，我们就必须使用shell的引用机制去引用文件名。实际上，为了可移植性，POSIX.1标准推荐严格使用以下字符来命名文件：字母(a-z, A-Z)，数字(0-9)，点(.)，中杠(-)，下划线(</em>)。</p>\n<p>Two filenames are automatically created whenever a new directory is created: . (called dot) and .. (called dot-dot). Dot refers to the current directory, and dot-dot refers to the parent directory. In the root directory, dot-dot is the same as dot. 有两个文件名在目录被创建的时候自动创建：<code>.</code>和<code>..</code>，<code>.</code>指向当前目录，<code>..</code>指向父目录，在根目录中，<code>..</code>和<code>.</code>一样（都指向当前目录）。</p>\n<blockquote>\n<p>The Research UNIX System and some older UNIX System V file systems restricted a filename to 14 characters. BSD versions extended this limit to 255 characters. Today, almost all commercial UNIX file systems support at least 255-character filenames. 现如今的unix文件系统都支持至少255字符的文件名。</p>\n</blockquote>\n<h3 id=\"Pathname\"><a href=\"#Pathname\" class=\"headerlink\" title=\"Pathname\"></a>Pathname</h3><p>A sequence of one or more filenames, separated by slashes and optionally starting with a slash, forms a pathname. A pathname that begins with a slash is called an absolute pathname; otherwise, it’s called a relative pathname. Relative pathnames refer to files relative to the current directory. 一系列的由斜杠分割而开的文件名组成一个路径名，一个路径名可以由一个斜杠开始，这叫做：<code>绝对路径</code>，反之就是相对路径，相对路径是相对于当前路径的。</p>\n<h3 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h3><p>Listing the names of all the files in a directory is not difficult. There is a bare-bones implementation of the ls(1) command:</p>\n<blockquote>\n<p>Figure 1.3 List all the files in a directory </p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"apue.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;dirent.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   DIR *dp;</span><br><span class=\"line\">   <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dirent</span> *<span class=\"title\">dirp</span>;</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (argc != <span class=\"number\">2</span>)</span><br><span class=\"line\">       err_quit(<span class=\"string\">\"usage: ls directory_name\"</span>);</span><br><span class=\"line\">   <span class=\"keyword\">if</span> ((dp = opendir(argv[<span class=\"number\">1</span>])) == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">       err_sys(<span class=\"string\">\"can’t open %s\"</span>, argv[<span class=\"number\">1</span>]);</span><br><span class=\"line\">   <span class=\"keyword\">while</span> ((dirp = readdir(dp)) != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">       <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\\n\"</span>, dirp-&gt;d_name);</span><br><span class=\"line\">    closedir(dp);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>The notation ls(1) is the normal way to reference a particular entry in the UNIX system manuals. It refers to the entry for ls in Section 1. The sections are normally numbered 1 through 8, and all the entries within each section are arranged alphabetically. Throughout this text, we assume that you have a copy of the manuals for your UNIX system.  熟悉unix的人应该都知道，unix有个man命令，可以查看其它命令的说明书，当然也可以<code>man man</code>查看自己的说明书。 man命令有8个section，每个section里的条目按照字幕顺序排列。</p>\n<blockquote>\n<p>Historically, UNIX systems lumped all eight sections together into what was called the UNIX Programmer’s Manual. As the page count increased, the trend changed to distributing the sections among separate manuals: <strong>one for users, one for programmers, and one for system administrators</strong>, for example. Some UNIX systems further divide the manual pages within a given section, using an uppercase letter. For example, all the standard input/output (I/O) functions in AT&amp;T [1990e] are indicated as being in Section 3S, as in fopen(3S). Other systems have replaced the numeric sections with alphabetic ones, such as C for commands. </p>\n</blockquote>\n<p>Today, most manuals are distributed in electronic form. If your manuals are online, the way to see the manual pages for the ls command would be something like </p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">man 1 ls</span><br></pre></td></tr></table></figure>\n<p>or</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">man -s1 ls</span><br></pre></td></tr></table></figure>\n<p>Figure 1.3 is a program that just prints the name of every file in a directory, and nothing else. If the source file is named myls.c, we compile it into the default a.out executable file by running </p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cc myls.c</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Historically, cc(1) is the C compiler. On systems with the GNU C compilation system, the C </p>\n<p>compiler is gcc(1). Here, cc is usually linked to gcc. </p>\n</blockquote>\n<p>但在实际的操作过程中，遇到了如下错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Undefined symbols for architecture x86_64:</span><br><span class=\"line\">  &quot;_err_quit&quot;, referenced from:</span><br><span class=\"line\">      _main in fig1-457251.o</span><br><span class=\"line\">  &quot;_err_sys&quot;, referenced from:</span><br><span class=\"line\">      _main in fig1-457251.o</span><br><span class=\"line\">ld: symbol(s) not found for architecture x86_64</span><br><span class=\"line\">clang: error: linker command failed with exit code 1 (use -v to see invocation)</span><br></pre></td></tr></table></figure>\n<p>这是个链接错误，具体的解决办法请看这篇博客：<a href=\"https://my.oschina.net/alextuan/blog/530425\" target=\"_blank\" rel=\"noopener\">OS X下UNIX环境高级编程（第三版）学习日志－第一章ChapterI，编译apue包与第一个例程</a></p>\n<ul>\n<li>When the program is done, it calls the function exit with an argument of 0. The function exit terminates a program. By convention, an argument of 0 means OK, and an argument between 1 and 255 means that an error occurred.  <strong>0代表OK，1到255代表各种类型的错误</strong>。</li>\n</ul>\n<h3 id=\"Working-Directory\"><a href=\"#Working-Directory\" class=\"headerlink\" title=\"Working Directory\"></a>Working Directory</h3><p><strong>工作目录（working directory）</strong>：Every process has a working directory, sometimes called the <strong>current working directory</strong>. This is the directory from which all relative pathnames are interpreted. A process can change its working directory with the <code>chdir</code> function.  每个进程都有一个工作目录，又叫做：当前工作目录，相对路径就是相对于当前工作目录的来解释的，可以调用<code>chdir</code>函数来改变工作目录。</p>\n<p>For example, the relative pathname doc/memo/joe refers to the file or directory joe, in the directory memo, in the directory doc, which must be a directory within the working directory. From looking just at this pathname, we know that both doc and memo have to be directories, but we can’t tell whether joe is a file or a directory. The pathname /usr/lib/lint is an absolute pathname that refers to the file or directory lint in the directory lib, in the directory usr, which is in the root directory.  这里有趣的一点是，我们无法判断joe是文件还是目录。</p>\n<h3 id=\"Home-Directory\"><a href=\"#Home-Directory\" class=\"headerlink\" title=\"Home Directory\"></a>Home Directory</h3><p>When we log in, the working directory is set to our <strong>home directory</strong>. Our home directory is obtained from our entry in the <strong>password file</strong> (Section 1.3).  当我们登陆的时候，工作目录会设定为home目录，而我们的home目录设置在口令文件中。</p>\n<h2 id=\"1-5-Input-and-Output\"><a href=\"#1-5-Input-and-Output\" class=\"headerlink\" title=\"1.5    Input and Output\"></a>1.5    Input and Output</h2><h3 id=\"File-Descriptors\"><a href=\"#File-Descriptors\" class=\"headerlink\" title=\"File Descriptors\"></a>File Descriptors</h3><p><strong>文件描述符（file descriptor）</strong>：File descriptors are normally small non-negative integers that the kernel uses to identify the files accessed by a process. Whenever it opens an existing file or creates a new file, the kernel returns a file descriptor that we use when we want to read or write the file.  文件描述符是一个小的非负整数，内核用它来标识正在被进程访问的文件。打开或者创建文件的时候内核会返回一个文件描述符，我们可以使用这个文件描述符来对文件进行读写。</p>\n<h3 id=\"Standard-Input-Standard-Output-and-Standard-Error\"><a href=\"#Standard-Input-Standard-Output-and-Standard-Error\" class=\"headerlink\" title=\"Standard Input, Standard Output, and Standard Error\"></a>Standard Input, Standard Output, and Standard Error</h3><p><strong>标准输入，标准输出，标准错误</strong>：By convention, all shells open three descriptors whenever a new program is run: standard input, standard output, and standard error. If nothing special is done, as in the simple command </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls</span><br></pre></td></tr></table></figure>\n<p>then <strong>all three are connected to the terminal</strong>. Most shells provide a way to redirect any or all of these three descriptors to any file. For example, </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls &gt; file.list</span><br></pre></td></tr></table></figure>\n<p>executes the ls command with its standard output redirected to the file named </p>\n<p>file.list. </p>\n<p><strong>按照惯例，当新程序运行的时候，shell会打开三个文件描述符：标准输入，标准输出，标准错误。如果没有进行指明，那么三个文件描述符都会连接到终端。</strong></p>\n<h3 id=\"Unbuffered-I-O\"><a href=\"#Unbuffered-I-O\" class=\"headerlink\" title=\"Unbuffered I/O\"></a>Unbuffered I/O</h3><p>Unbuffered I/O is provided by the functions <code>open</code>, <code>read</code>,<code>write</code>, <code>lseek</code>, and <code>close</code>. These functions all work with file descriptors. <strong>unbuffered I/O</strong>意思是系统不提供buffer管理，要你自己申请buffer，并传递给系统函数。</p>\n<h3 id=\"Example-1\"><a href=\"#Example-1\" class=\"headerlink\" title=\"Example\"></a>Example</h3><p>If we’re willing to read from the standard input and write to the standard output, then the program in Figure 1.4 copies any regular file on a UNIX system. </p>\n<blockquote>\n<p>Figure 1.4 Copy standard input to standard output </p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"apue.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BUFFSIZE 4096</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[BUFFSIZE];</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((n = read(STDIN_FILENO, buf, BUFFSIZE)) &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (write(STDOUT_FILENO, buf, n) != n)</span><br><span class=\"line\">            err_sys(<span class=\"string\">\"write error\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        err_sys(<span class=\"string\">\"read error\"</span>);</span><br><span class=\"line\">true<span class=\"built_in\">exit</span>(<span class=\"number\">0</span>); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面是对程序的解释：</p>\n<p>The <code>&lt;unistd.h&gt;</code> header, included by <code>apue.h</code>, and the two constants <code>STDIN_FILENO</code> and <code>STDOUT_FILENO</code> are part of the POSIX standard (about which we’ll have a lot more to say in the next chapter). This header contains function prototypes for many of the UNIX system services, such as the <code>read</code> and <code>write</code> functions that we call. </p>\n<p>The constants STDIN_FILENO and STDOUT_FILENO are defined in &lt;unistd.h&gt; and specify the file descriptors for standard input and standard output. <strong>These values are 0 and 1, respectively, as required by POSIX.1</strong>, but we’ll use the names for readability. POSIX.1标准：<strong>标准输入是0，标准输出是1，标准错误是2</strong>。</p>\n<p>The <code>read</code> function returns the number of bytes that are read, and this value is used as the number of bytes to <code>write</code>. When the end of the input file is encountered, read returns 0 and the program stops. If a read error occurs, read returns −1. Most of the system functions return −1 when an error occurs.  <code>read</code>函数返回的是读入字节的个数，把这个返回值传给<code>write</code>函数，就可以读多少写多少了，当遇到输入文件结束时，read函数返回0，当遇到错误时，read函数返回-1。<strong>许多系统函数返回-1，当它们遇到错误时</strong>。</p>\n<p>If we compile the program into the standard name (a.out) and execute it as </p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./a.out &gt; data</span><br></pre></td></tr></table></figure>\n<p>standard input is the terminal, standard output is redirected to the file data, and standard error is also the terminal. <strong>If this output file doesn’t exist, the shell creates it by default</strong>. The program copies lines that we type to the standard output <strong>until we type the end-of-file character (usually Control-D)</strong>. </p>\n<p>If we run </p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./a.out &lt; infile &gt; outfile</span><br></pre></td></tr></table></figure>\n<p>then the file named infile will be copied to the file named outfile. </p>\n<p>如果文件不存在，shell默认给我们创建一个。标准输入和标准错误都是终端，我们可以一直输入，直到输入一个文件结束符，也就是<code>ctrl+d</code>。</p>\n<h3 id=\"Standard-I-O\"><a href=\"#Standard-I-O\" class=\"headerlink\" title=\"Standard I/O\"></a>Standard I/O</h3><p>The standard I/O functions provide a buffered interface to the unbuffered I/O functions. <strong>Using standard I/O relieves us from having to choose optimal buffer sizes</strong>, such as the BUFFSIZE constant in Figure 1.4. The standard I/O functions also simplify dealing with lines of input (a common occurrence in UNIX applications). <strong>The <code>fgets</code> function, for example, reads an entire line. The read function, in contrast, reads a specified number of bytes</strong>. As we shall see in Section 5.4, the standard I/O library provides functions that let us control the style of buffering used by the library. 标准I/O函数给unbuffered I/O 函数提供了缓冲接口，使用标准I/O函数可以让我们从优化buffer大小中解脱出来，举个例子，<code>fgets</code>函数直接读取一整行，而<code>read</code>函数读取固定个数的字节。</p>\n<p>The most common standard I/O function is <code>printf</code>. In programs that call printf, we’ll always include &lt;stdio.h&gt;—normally by including apue.h—as this header contains the function prototypes for all the standard I/O functions. </p>\n<h3 id=\"Example-2\"><a href=\"#Example-2\" class=\"headerlink\" title=\"Example\"></a>Example</h3><p>The program in Figure 1.5, which we’ll examine in more detail in Section 5.8, is like the previous program that called read and write. This program copies standard input to standard output and can copy any regular file. </p>\n<blockquote>\n<p>Figure 1.5 Copy standard input to standard output, using standard I/O </p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"apue.h\"</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">true<span class=\"keyword\">int</span> c;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((c = getc(<span class=\"built_in\">stdin</span>)) != EOF)</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span> (putc(c, <span class=\"built_in\">stdout</span>) == EOF)</span><br><span class=\"line\">    \t\terr_sys(<span class=\"string\">\"output error\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ferror(<span class=\"built_in\">stdin</span>))</span><br><span class=\"line\">    \terr_sys(<span class=\"string\">\"input error\"</span>);</span><br><span class=\"line\">true<span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>The function getc reads one character at a time, and this character is written by putc</strong>. After the last byte of input has been read, getc returns the constant EOF (defined in &lt;stdio.h&gt;). The standard I/O constants stdin and stdout are also defined in the &lt;stdio.h&gt; header and refer to the standard input and standard output. </p>\n<h2 id=\"1-6-Programs-and-Processes\"><a href=\"#1-6-Programs-and-Processes\" class=\"headerlink\" title=\"1.6    Programs and Processes\"></a>1.6    Programs and Processes</h2><h3 id=\"Program\"><a href=\"#Program\" class=\"headerlink\" title=\"Program\"></a>Program</h3><p>A program is an executable file residing on disk in a directory. A program is read into memory and is executed by the kernel as a result of one of the <strong>seven exec functions</strong>. </p>\n<h3 id=\"Processes-and-Process-ID\"><a href=\"#Processes-and-Process-ID\" class=\"headerlink\" title=\"Processes and Process ID\"></a>Processes and Process ID</h3><p>An executing instance of a program is called a <strong>process</strong>, a term used on almost every page of this text. Some operating systems use the term <strong>task</strong> to refer to a program that is being executed.  程序运行的一个实例叫做：进程，也有些操作系统使用：task这个术语来描述被执行的程序。</p>\n<p>The UNIX System guarantees that every process has a unique numeric identifier called the process ID. The process ID is always a non-negative integer. unix系统保证每个进程都有独一无二的进程ID，这个进程ID是一个非负整数。</p>\n<h3 id=\"Example-3\"><a href=\"#Example-3\" class=\"headerlink\" title=\"Example\"></a>Example</h3><p>The program in Figure 1.6 prints its process ID. </p>\n<blockquote>\n<p>Figure 1.6 Print the process ID  </p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"apue.h\"</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"hello world from process ID %ld\\n\"</span>, (<span class=\"keyword\">long</span>)getpid());</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  apue.3e ./fig1.6</span><br><span class=\"line\">hello world from process ID 8080</span><br><span class=\"line\">➜  apue.3e ./fig1.6</span><br><span class=\"line\">hello world from process ID 8086</span><br></pre></td></tr></table></figure>\n<h3 id=\"Process-Control\"><a href=\"#Process-Control\" class=\"headerlink\" title=\"Process Control\"></a>Process Control</h3><p>There are three primary functions for process control: <code>fork</code>, <code>exec</code>, and <code>waitpid</code>. (The exec function has seven variants, but we often refer to them collectively as simply the exec function.)  有三个进程控制的基本函数：<code>fork</code>，<code>exec</code>和<code>waitpid</code>，虽然exec函数有7种变体，但我们往往简单的用一个exec来表示它们。</p>\n<h3 id=\"Example-4\"><a href=\"#Example-4\" class=\"headerlink\" title=\"Example\"></a>Example</h3><p>The process control features of the UNIX System are demonstrated using a simple program (Figure 1.7) that reads commands from standard input and executes the commands. This is a bare-bones implementation of a shell-like program. </p>\n<blockquote>\n<p>Figure 1.7 Read commands from standard input and execute them </p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"include/apue.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/wait.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span>    buf[MAXLINE];   <span class=\"comment\">/* from apue.h */</span></span><br><span class=\"line\">    <span class=\"keyword\">pid_t</span>   pid;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>     status;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%% \"</span>);  <span class=\"comment\">/* print prompt (printf requires %% to print %) */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (fgets(buf, MAXLINE, <span class=\"built_in\">stdin</span>) != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (buf[<span class=\"built_in\">strlen</span>(buf) - <span class=\"number\">1</span>] == <span class=\"string\">'\\n'</span>)</span><br><span class=\"line\">            buf[<span class=\"built_in\">strlen</span>(buf) - <span class=\"number\">1</span>] = <span class=\"number\">0</span>; <span class=\"comment\">/* replace newline with null */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((pid = fork()) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            err_sys(<span class=\"string\">\"fork error\"</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pid == <span class=\"number\">0</span>) &#123;      <span class=\"comment\">/* child */</span></span><br><span class=\"line\">            execlp(buf, buf, (<span class=\"keyword\">char</span> *)<span class=\"number\">0</span>);</span><br><span class=\"line\">            <span class=\"comment\">// or</span></span><br><span class=\"line\">            <span class=\"comment\">// execlp(buf, buf, (char *)NULL);</span></span><br><span class=\"line\">            err_ret(<span class=\"string\">\"couldn’t execute: %s\"</span>, buf);</span><br><span class=\"line\">            <span class=\"built_in\">exit</span>(<span class=\"number\">127</span>);</span><br><span class=\"line\">truetrue&#125;</span><br><span class=\"line\">        <span class=\"comment\">/* parent */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((pid = waitpid(pid, &amp;status, <span class=\"number\">0</span>)) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            err_sys(<span class=\"string\">\"waitpid error\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%% \"</span>);</span><br><span class=\"line\">true&#125;</span><br><span class=\"line\">true<span class=\"built_in\">exit</span>(<span class=\"number\">0</span>); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>There are several features to consider in this 30-line program. </p>\n<ul>\n<li>We use the standard I/O function fgets to read one line at a time from the standard input. When we type the end-of-file character (which is often Control-D) as the first character of a line, fgets returns a null pointer, the loop stops, and the process terminates. In Chapter 18, we describe all the special terminal characters—end of file, backspace one character, erase entire line, and so on—and how to change them.  我们使用了标准I/O函数<code>fgets</code>来一次读取标准输入的一行。当我们直接输入一个EOF时，fgets返回一个空指针，循环停止，进程终止。在第18章，我们将讲述特殊终止符，比如：end of file，backspace one character, erase entire line, 等等，以及如何改变它们。</li>\n<li>Because each line returned by fgets is terminated with a newline character, followed by a null byte, we use the standard C function strlen to calculate the length of the string, and then replace the newline with a null byte. We do this because the execlp function wants a null-terminated argument, not a newline-terminated argument.  因为fgets返回的每一行都被一个换行符终止，换行符之后是一个空字符，我们使用标准C函数<code>strlen</code>来计算string的长度，然后将换行符替换成空字符（这样末尾就两个空字符了）。我们这样做是因为<code>execlp</code>函数希望有一个空字符来作为结尾参数，而不是一个换行符。</li>\n<li>We call fork to create a new process, which is a copy of the caller. We say that the caller is the parent and that the newly created process is the child. Then fork returns the non-negative process ID of the new child process to the parent, and returns 0 to the child. Because fork creates a new process, we say that it is called once—by the parent—but returns twice—in the parent and in the child.  我们调用<code>fork</code>创建一个新进程，这个新进程是调用进程的一个复制。我们说，调用者是父进程，新创建出来的进程是子进程。<strong>然后fork返回子进程的非负进程ID给父进程，并返回0给子进程</strong>。因为fork创建了一个新进程，<strong>我们说它调用了一次（被父进程），但是返回了两次</strong>，在父进程和子进程里面。</li>\n<li>In the child, we call execlp to execute the command that was read from the standard input. This replaces the child process with the new program file. The combination of fork followed by exec is called spawning a new process on some operating systems. In the UNIX System, the two parts are separated into individual functions. We’ll say a lot more about these functions in Chapter 8.  在子进程中，我们调用<code>execlp</code>来执行从标注输入中读取来的命令。这就把子进程替换成了新执行的程序。fork后面跟个exec这种结合方式被叫做 <strong>spawning a new process</strong> 在某些操作系统中。在unix系统中，这两部分被分别放到了两个单独的函数中。我们将在第8章中讨论更多的这类函数。</li>\n<li>Because the child calls execlp to execute the new program file, the parent wants to wait for the child to terminate. This is done by calling waitpid, specifying which process to wait for: the pid argument, which is the process ID of the child. The waitpid function also returns the termination status of the child—the status variable—but in this simple program, we don’t do anything with this value. We could examine it to determine how the child terminated.  因为子进程调用了<code>execlp</code>来执行新程序文件，父进程想要等子进程结束。通过调用<code>waitpid</code>可以完成这个任务，用<code>pid</code>（子进程的进程ID）参数来明确需要等待哪个进程。<code>waitpid</code>函数同样也返回子进程的终止状态（记录在status这个参数），但在这个简单的程序里，我们没有用到这个值。我们通过这个值得知子进程是如何结束的。</li>\n<li>The most fundamental limitation of this program is that we can’t pass arguments to the command we execute. We can’t, for example, specify the name of a directory to list. We can execute ls only on the working directory. To allow arguments would require that we parse the input line, separating the arguments by some convention, probably spaces or tabs, and then pass each argument as a separate parameter to the execlp function. Nevertheless, this program is still a useful demonstration of the UNIX System’s process control functions.  这个程序最大的限制就是，我们不能传递参数给我们要执行的命令。比如，我们不能给定一个目录给list程序（展示目录下的所有目录和文件的程序）。我们只能在当前目录下执行ls。如果要允许传递参数，就需要我们分析输入行，按照惯例，比如空格或者制表符，把参数分割开来，然后把参数传给execlp函数。不管怎么说，这个程序已经很好的展示了unix系统是如何控制函数的。</li>\n</ul>\n<p>If we run this program, we get the following result. Note that our program has a different prompt—the percent sign—to distinguish it from the shell’s prompt. </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  apue.3e ./fig1.7</span><br><span class=\"line\">% pwd</span><br><span class=\"line\">/Users/liuqinh2s/Downloads/apue.3e</span><br><span class=\"line\">% who</span><br><span class=\"line\">liuqinh2s console  May 21 12:09</span><br><span class=\"line\">liuqinh2s ttys000  May 21 12:10</span><br><span class=\"line\">% date</span><br><span class=\"line\">2018年 5月24日 星期四 15时26分59秒 CST</span><br><span class=\"line\">% %                                                                                                                                                                                                         ➜  apue.3e</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>The notation ˆD is used to indicate a control character. Control characters are special characters formed by holding down the control key—often labeled Control or Ctrl—on your keyboard and then pressing another key at the same time. <strong>Control-D, or ˆD, is the default end-of-file character</strong>. We’ll see many more control characters when we discuss terminal I/O in Chapter 18.  <code>^D</code>这种记法用于表示控制字符，控制字符是一类特殊的字符，由<code>ctrl</code>键加一个其他键组成，<code>Control-D</code>或者说<code>^D</code>是默认的文件终止符。我们将在第18章讨论输入输出终止符的时候看到更多的控制字符。</p>\n</blockquote>\n<h3 id=\"Threads-and-Thread-IDs\"><a href=\"#Threads-and-Thread-IDs\" class=\"headerlink\" title=\"Threads and Thread IDs\"></a>Threads and Thread IDs</h3><p>Usually, a process has only one thread of control—one set of machine instructions executing at a time. Some problems are easier to solve when more than one thread of control can operate on different parts of the problem. Additionally, multiple threads of control can exploit the parallelism possible on multiprocessor systems. </p>\n<p>All threads within a process share the same address space, file descriptors, stacks, and process-related attributes. Each thread executes on its own stack, although any thread can access the stacks of other threads in the same process. Because they can access the same memory, the threads need to synchronize access to shared data among themselves to avoid inconsistencies.  属于同一个进程的多个线程共享同一块内存空间，文件描述符，栈，以及和进程相关的属性。每个线程都在自己的栈里面执行，但每个线程又能访问其他线程的栈（同属于一个进程的多个线程）。因为它们能访问同一块内存，所以为了避免不一致性，需要保护好临界资源。</p>\n<p>Like processes, threads are identified by IDs. <strong>Thread IDs, however, are local to a process</strong>. A thread ID from one process has no meaning in another process. We use thread IDs to refer to specific threads as we manipulate the threads within a process.  就像进程一样，线程也用ID标识。<strong>然而线程ID是局部的，只在某个进程内有效，出了这个进程，对其他进程来说这个线程ID就没有任何意义了。</strong></p>\n<blockquote>\n<p>threads were added to the UNIX System long after the process model was established </p>\n</blockquote>\n<h2 id=\"1-7-Error-Handling\"><a href=\"#1-7-Error-Handling\" class=\"headerlink\" title=\"1.7    Error Handling\"></a>1.7    Error Handling</h2><p>When an error occurs in one of the UNIX System functions, a negative value is often returned, and the integer <strong>errno</strong> is usually set to a value that tells why. For example, the open function returns either a non-negative file descriptor if all is OK or −1 if an error occurs. An error from open has about 15 possible errno values, such as file doesn’t exist, permission problem, and so on. Some functions use a convention other than returning a negative value. For example, most functions that return a pointer to an object return a null pointer to indicate an error.  当unix系统函数出错时，会返回一个负数，整形变量<strong>errno</strong>会设置为一个值，这个值告诉我们为什么出错。例如，open函数返回一个非负的文件描述符，如果成功的话，如果出现错误则返回一个-1。open函数返回的错误有15个可能的errno值，比如：文件不存在，权限问题，等等。有些函数使用另一个传统而非返回一个负数。例如，很多函数返回一个对象指针，或者一个空指针如果出现错误。</p>\n<p>The file &lt;errno.h&gt; defines the symbol errno and constants for each value that errno can assume. Each of these constants begins with the character E. Also, the first page of Section 2 of the UNIX system manuals, named intro(2), usually lists all these error constants. For example, if errno is equal to the constant EACCES, this indicates a permission problem, such as insufficient permission to open the requested file.  <code>&lt;errno.h&gt;</code>文件定义了变量errno和一系列常量（errno可能的值）。每个常量都以字符<code>E</code>开头。unix系统手册<code>intro(2)</code>展示了这些常量。例如，如果errno等于常量EACCES，就表示是权限问题，没有足够的权限去打开这个文件。</p>\n<blockquote>\n<p>On Linux, the error constants are listed in the errno(3) manual page. </p>\n</blockquote>\n<p>POSIX and ISO C define errno as a symbol expanding into a modifiable lvalue of type integer. This can be either an integer that contains the error number or a function that returns a pointer to the error number. The historical definition is </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> errno;</span><br></pre></td></tr></table></figure>\n<p>But in an environment that supports threads, the process address space is shared among multiple threads, and each thread needs its own local copy of errno to prevent one thread from interfering with another. Linux, for example, supports multithreaded access to errno by defining it as </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> *__errno_location(<span class=\"keyword\">void</span>); </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> errno (*__errno_location())</span></span><br></pre></td></tr></table></figure>\n<p>POSIX和ISO C把errno定义为一个可以修改的左值。可以定义为一个整形值，也可以定义为一个指针，指针指向错误码（String类型）。如果是多线程环境下，每个线程都有自己的一个errno拷贝。通过宏定义把errno给替换成函数：<code>int *__errno_location(void);</code>了。</p>\n<p>There are two rules to be aware of with respect to errno. First, its value is never cleared by a routine if an error does not occur. Therefore, we should examine its value only when the return value from a function indicates that an error occurred. Second, the value of errno is never set to 0 by any of the functions, and none of the constants defined in &lt;errno.h&gt; has a value of 0.  第一，如果没有出错，errno的值不会被重置，因此，我们只有在函数返回出错的时候才检查errno；第二，errno不会等于0。</p>\n<p>Two functions are defined by the C standard to help with printing error messages. </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> *<span class=\"title\">strerror</span><span class=\"params\">(<span class=\"keyword\">int</span> errnum)</span></span>;\t<span class=\"comment\">//Returns: pointer to message string</span></span><br></pre></td></tr></table></figure>\n<p>This function maps errnum, which is typically the errno value, into an error message string and returns a pointer to the string. </p>\n<p>The perror function produces an error message on the standard error, based on the current value of errno, and returns. </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">perror</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* msg)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>It outputs the string pointed to by msg, followed by a colon and a space, followed by the error message corresponding to the value of errno, followed by a newline. </p>\n<h3 id=\"Example-5\"><a href=\"#Example-5\" class=\"headerlink\" title=\"Example\"></a>Example</h3><p>Figure 1.8 shows the use of these two error functions. </p>\n<blockquote>\n<p>Figure 1.8 Demonstrate strerror and perror </p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"apue.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;errno.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">\"EACCES: %s\\n\"</span>, strerror(EACCES));</span><br><span class=\"line\">    errno = ENOENT;</span><br><span class=\"line\">    perror(argv[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  apue.3e ./fig1.8</span><br><span class=\"line\">EACCES: Permission denied</span><br><span class=\"line\">./fig1.8: No such file or directory</span><br><span class=\"line\">➜  apue.3e</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>argv[0] 表示输入的第一个参数，也就是命令名</p>\n</blockquote>\n<h3 id=\"Error-Recovery\"><a href=\"#Error-Recovery\" class=\"headerlink\" title=\"Error Recovery\"></a>Error Recovery</h3><p>The errors defined in &lt;errno.h&gt; can be divided into two categories: fatal and nonfatal. A fatal error has no recovery action. The best we can do is print an error message on the user’s screen or to a log file, and then exit. Nonfatal errors, on the other hand, can sometimes be dealt with more robustly. Most nonfatal errors are temporary, such as a resource shortage, and might not occur when there is less activity on the system.  定义在<code>&lt;errno.h&gt;</code>中的错误可以分为两类：fatal和nonfatal，致命和非致命。致命错误没有恢复动作，我们最多能做的就是把错误信息在用户显示屏上打印出来，或者写到log文件里，然后退出。非致命错误，可以更妥善的处理，许多非致命错误都是暂时的，比如：资源短缺，当系统活动较少时这类错误可能不会发生。</p>\n<p>Resource-related nonfatal errors include <strong>EAGAIN, ENFILE, ENOBUFS, ENOLCK, ENOSPC, EWOULDBLOCK</strong>, and sometimes <strong>ENOMEM</strong>. <strong>EBUSY</strong> can be treated as nonfatal when it indicates that a shared resource is in use. Sometimes, <strong>EINTR</strong> can be treated as a nonfatal error when it interrupts a slow system call (more on this in Section 10.5).  </p>\n<p>The typical recovery action for a resource-related nonfatal error is to delay and retry later. This technique can be applied in other circumstances. For example, if an error indicates that a network connection is no longer functioning, it might be possible for the application to delay a short time and then reestablish the connection. Some applications use an exponential backoff algorithm, waiting a longer period of time in each subsequent iteration.  <strong>典型的资源相关性非致命错误的处理办法是先等一下，之后再重试。</strong></p>\n<p><strong>Ultimately, it is up to the application developer to determine the cases where an application can recover from an error. If a reasonable recovery strategy can be used, we can improve the robustness of our application by avoiding an abnormal exit. </strong></p>\n<h2 id=\"1-8-User-Identification\"><a href=\"#1-8-User-Identification\" class=\"headerlink\" title=\"1.8    User Identification\"></a>1.8    User Identification</h2><h3 id=\"User-ID\"><a href=\"#User-ID\" class=\"headerlink\" title=\"User ID\"></a>User ID</h3><p>The user ID from our entry in the password file is a numeric value that identifies us to the system. This user ID is assigned by the system administrator when our login name is assigned, and we cannot change it. The user ID is normally assigned to be unique for every user. We’ll see how the kernel uses the user ID to check whether we have the appropriate permissions to perform certain operations.  用户ID来自口令文件中对应的条目，它是以数字的形式帮助系统对我们进行标识。用户ID是系统管理员给我们分配的（当分配登录名时，同时也必须分配用户ID），我们自己无法改。每个人的用户ID应该是唯一的，内核使用用户ID来检查我们是否有合适的权限来进行一个操作。</p>\n<p>We call the user whose user ID is 0 either root or the superuser. The entry in the password file normally has a login name of root, and we refer to the special privileges of this user as superuser privileges. As we’ll see in Chapter 4, if a process has superuser privileges, most file permission checks are bypassed. Some operating system functions are restricted to the superuser. The superuser has free rein over the system.  我们把用户ID为0的用户称为：<strong>root</strong>或者<strong>superuser</strong>。口令文件中有一个条目的登录名是root，root用户拥有特殊权限。拥有superuser特权的进程可以自由的使用任意文件，而且有些操作系统函数是只对superuser开放的。superuser拥有对系统的绝对的权限（可以把系统弄残）。</p>\n<blockquote>\n<p>Client versions of Mac OS X ship with the superuser account disabled; server versions ship with the account already enabled. Instructions are available on Apple’s Web site describing how to enable it. See <a href=\"http://support.apple.com/kb/HT1528\" target=\"_blank\" rel=\"noopener\">http://support.apple.com/kb/HT1528</a>. </p>\n</blockquote>\n<h3 id=\"Group-ID\"><a href=\"#Group-ID\" class=\"headerlink\" title=\"Group ID\"></a>Group ID</h3><p>Our entry in the password file also specifies our numeric group ID. This, too, is assigned by the system administrator when our login name is assigned. Typically, the password file contains multiple entries that specify the same group ID. Groups are normally used to collect users together into projects or departments. This allows the sharing of resources, such as files, among members of the same group. We’ll see in Section 4.5 that we can set the permissions on a file so that all members of a group can access the file, whereas others outside the group cannot.  Group ID的作用就是让相同组的人共享资源。</p>\n<p>There is also a group file that maps group names into numeric group IDs. The group file is usually <code>/etc/group</code>. </p>\n<p>The use of numeric user IDs and numeric group IDs for permissions is historical. With every file on disk, the file system stores both the user ID and the group ID of a file’s owner. Storing both of these values requires only four bytes, assuming that each is stored as a two-byte integer. If the full ASCII login name and group name were used instead, additional disk space would be required. In addition, comparing strings during permission checks is more expensive than comparing integers.  使用数字的用户ID和组ID是有历史原因的。对于每个存放在磁盘上的文件，文件系统都存储了该文件的拥有者的用户ID和组ID。存储这两个数字需要4字节（每个2字节），如果使用ASCII编码的登录名和组名，需要多用掉很多额外的磁盘空间。另外在检查权限是否合格时，整形数字比较要比字符串比较更快。</p>\n<p>Users, however, work better with names than with numbers, so the password file maintains the mapping between login names and user IDs, and the group file provides the mapping between group names and group IDs. The ls -l command, for example, prints the login name of the owner of a file, using the password file to map the numeric user ID into the corresponding login name.  然而对于用户来说名字比数字更好记，所以password file和group file分别记录了登录名和用户ID的映射，组名和组ID的映射。使用<code>ls -l</code>命令，可以看到打印出了文件所属者和所属的组，其原理就是查找了password file和group file，把相应的数字ID换成名字。</p>\n<blockquote>\n<p>Early UNIX systems used 16-bit integers to represent user and group IDs. Contemporary UNIX systems use 32-bit integers. </p>\n</blockquote>\n<h3 id=\"Example-6\"><a href=\"#Example-6\" class=\"headerlink\" title=\"Example\"></a>Example</h3><p>The program in Figure 1.9 prints the user ID and the group ID. </p>\n<blockquote>\n<p>Figure 1.9 Print user ID and group ID  </p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"apue.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">true<span class=\"built_in\">printf</span>(<span class=\"string\">\"uid = %d, gid = %d\\n\"</span>, getuid(), getgid());</span><br><span class=\"line\">true<span class=\"built_in\">exit</span>(<span class=\"number\">0</span>); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Supplementary-Group-IDs\"><a href=\"#Supplementary-Group-IDs\" class=\"headerlink\" title=\"Supplementary Group IDs\"></a>Supplementary Group IDs</h3><p><strong>附加组（supplementary group）</strong>：In addition to the group ID specified in the password file for a login name, most versions of the UNIX System allow a user to belong to other groups. This practice started with 4.2BSD, which allowed a user to belong to up to 16 additional groups. These supplementary group IDs are obtained at login time by reading the file /etc/group and finding the first 16 entries that list the user as a member. As we shall see in the next chapter, POSIX requires that a system support at least 8 supplementary groups per process, but most systems support at least 16.  许多unix系统允许用户属于多个组，最多16个。主组，也就是登陆时的默认组记录在<code>/etc/passwd</code>中。</p>\n<p><code>/etc/group</code>格式如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_analyticsusers:*:250:_analyticsd,_networkd,_timed</span><br><span class=\"line\">_analyticsd:*:263:_analyticsd</span><br></pre></td></tr></table></figure>\n<p>解释：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">组名:口令:组ID:组内用户列表</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-9-Signal\"><a href=\"#1-9-Signal\" class=\"headerlink\" title=\"1.9    Signal\"></a>1.9    Signal</h2><p>Signals are a technique used to notify a process that some condition has occurred. For example, if a process divides by zero, the signal whose name is SIGFPE (floating-point exception) is sent to the process. The process has three choices for dealing with the signal.  信号是一种用来通知进程发生了某些事的技术。举个例子：当进程除以0时，就会有一个SIGFPE (floating-point exception)发送到这个进程。进程处理信号有三种选择：</p>\n<ol>\n<li>Ignore the signal. This option isn’t recommended for signals that denote a hardware exception, such as dividing by zero or referencing memory outside the address space of the process, as the results are undefined.  忽视信号。如果是硬件异常不推荐这个选择，例如：被0除，引用进程外的内存，因为这些结果都是不确定的。</li>\n<li>Let the default action occur. For a divide-by-zero condition, the default is to terminate the process.  让默认动作出现，比如被0除的情况下，默认是终止该进程。</li>\n<li>Provide a function that is called when the signal occurs (this is called ‘‘catching’’ the signal). By providing a function of our own, we’ll know when the signal occurs and we can handle it as we wish.  我们自己提供一个函数捕获信号，这样我们就能让程序以我们的意愿处理异常。</li>\n</ol>\n<p>Many conditions generate signals. Two terminal keys, called the <strong>interrupt key</strong>— often the <strong>DELETE</strong> key or <strong>Control-C</strong>—and the <strong>quit key</strong>—often <strong>Control-backslash</strong>—are used to interrupt the currently running process. Another way to generate a signal is by calling the <code>kill</code> function. <strong>We can call this function from a process to send a signal to another process. Naturally, there are limitations: we have to be the owner of the other process (or the superuser) to be able to send it a signal</strong>.    很多条件下可以生成信号，终端键有两种，interrupt key（delete键或者ctrl+c）和 quit key（ctrl+\\）。另一个生成信号的方法是调用<code>kill</code>函数，我们可以在一个进程里调用kill函数来结束另一个线程，但我们需要有权限（如果我们是另一个进程的拥有者，或者是超级用户，就可以）。</p>\n<h3 id=\"Example-7\"><a href=\"#Example-7\" class=\"headerlink\" title=\"Example\"></a>Example</h3><p>Recall the bare-bones shell example (Figure 1.7). If we invoke this program and press the interrupt key, the process terminates because the default action for this signal, named SIGINT, is to terminate the process. The process hasn’t told the kernel to do anything other than the default with this signal, so the process terminates.  如果直接执行Figure 1.7的代码，我们按下中断键，程序就会终止，因为这个SIGINT信号的默认动作就是终止进程。</p>\n<p>To catch this signal, the program needs to call the signal function, specifying the name of the function to call when the SIGINT signal is generated. The function is named sig_int; when it’s called, it just prints a message and a new prompt. Adding 11 lines to the program in Figure 1.7 gives us the version in Figure 1.10. (The 11 new lines are indicated with a plus sign at the beginning of the line.)  为了捕获这个信号，程序需要调用一个信号函数。我们给它命名为：<code>sig_int</code>函数，在捕获到<strong>SIGINT</strong>信号之后，打印信息并打印一个新的提示符。下面的程序相比Figure 1.7多了11行，用<code>+</code>号标识了。</p>\n<blockquote>\n<p>Figure 1.10 Read commands from standard input and execute them </p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"include/apue.h\"</span></span></span><br><span class=\"line\">  <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/wait.h&gt;</span></span></span><br><span class=\"line\">  </span><br><span class=\"line\">+ <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sig_int</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span></span>;\t<span class=\"comment\">/* our signal-catching function */</span></span><br><span class=\"line\">+</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">char</span>    buf[MAXLINE];   <span class=\"comment\">/* from apue.h */</span></span><br><span class=\"line\">      <span class=\"keyword\">pid_t</span>   pid;</span><br><span class=\"line\">      <span class=\"keyword\">int</span>     status;</span><br><span class=\"line\">  </span><br><span class=\"line\">  +\t  <span class=\"keyword\">if</span>(signal(SIGINT, sig_int) == SIG_ERR)</span><br><span class=\"line\">          err_sys(<span class=\"string\">\"signal error\"</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">      <span class=\"built_in\">printf</span>(<span class=\"string\">\"%% \"</span>);  <span class=\"comment\">/* print prompt (printf requires %% to print %) */</span></span><br><span class=\"line\">      <span class=\"keyword\">while</span> (fgets(buf, MAXLINE, <span class=\"built_in\">stdin</span>) != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (buf[<span class=\"built_in\">strlen</span>(buf) - <span class=\"number\">1</span>] == <span class=\"string\">'\\n'</span>)</span><br><span class=\"line\">              buf[<span class=\"built_in\">strlen</span>(buf) - <span class=\"number\">1</span>] = <span class=\"number\">0</span>; <span class=\"comment\">/* replace newline with null */</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> ((pid = fork()) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">              err_sys(<span class=\"string\">\"fork error\"</span>);</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pid == <span class=\"number\">0</span>) &#123;      <span class=\"comment\">/* child */</span></span><br><span class=\"line\">              execlp(buf, buf, (<span class=\"keyword\">char</span> *)<span class=\"number\">0</span>);</span><br><span class=\"line\">              err_ret(<span class=\"string\">\"couldn’t execute: %s\"</span>, buf);</span><br><span class=\"line\">              <span class=\"built_in\">exit</span>(<span class=\"number\">127</span>);</span><br><span class=\"line\">truetrue  &#125;</span><br><span class=\"line\">          <span class=\"comment\">/* parent */</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> ((pid = waitpid(pid, &amp;status, <span class=\"number\">0</span>)) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">              err_sys(<span class=\"string\">\"waitpid error\"</span>);</span><br><span class=\"line\">          <span class=\"built_in\">printf</span>(<span class=\"string\">\"%% \"</span>);</span><br><span class=\"line\">true  &#125;</span><br><span class=\"line\">true  <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>); </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">+</span><br><span class=\"line\">+ <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sig_int</span><span class=\"params\">(<span class=\"keyword\">int</span> signo)</span></span>&#123;</span><br><span class=\"line\">+     <span class=\"built_in\">printf</span>(<span class=\"string\">\"interrupt\\n%% \"</span>);</span><br><span class=\"line\">+ &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-10-Time-Values\"><a href=\"#1-10-Time-Values\" class=\"headerlink\" title=\"1.10    Time Values\"></a>1.10    Time Values</h2><p>Historically, UNIX systems have maintained two different time values: </p>\n<ol>\n<li><p><strong>Calendar time</strong>. This value counts the number of seconds since the <strong>Epoch: 00:00:00 January 1, 1970,Coordinated Universal Time (UTC)</strong>. (Older manuals refer to UTC as Greenwich Mean Time.) These time values are used to record the time when a file was last modified, for example. </p>\n<p>The primitive system data type <code>time_t</code> holds these time values. </p>\n</li>\n<li><p><strong>Process time</strong>. This is also called CPU time and measures the central processor resources used by a process. Process time is measured in clock ticks, which have historically been 50, 60, or 100 ticks per second. </p>\n<p>The primitive system data type <code>clock_t</code> holds these time values. (We’ll show how to obtain the number of clock ticks per second with the <code>sysconf</code> function in Section 2.5.4.) </p>\n</li>\n</ol>\n<p>有两种类型的时间：<strong>日历时间</strong>和<strong>进程时间</strong>，日历时间也就是UTC。</p>\n<p>When we measure the execution time of a process, as in Section 3.9, we’ll see that the UNIX System maintains three values for a process: </p>\n<ul>\n<li>Clock time </li>\n<li>User CPU time </li>\n<li>System CPU time </li>\n</ul>\n<p>The clock time, sometimes called <strong>wall clock time</strong>, is the amount of time the process takes to run, and its value depends on the number of other processes being run on the system. Whenever we report the clock time, the measurements are made with no other activities on the system. </p>\n<p>The user CPU time is the CPU time attributed to user instructions. The system CPU time is the CPU time attributed to the kernel when it executes on behalf of the process. For example, whenever a process executes a system service, such as read or write, the time spent within the kernel performing that system service is charged to the process. The sum of user CPU time and system CPU time is often called the CPU time. </p>\n<p>度量进程执行时间，有三种：</p>\n<ol>\n<li>墙上时钟，也就是进程执行花费的总时间。</li>\n<li>用户CPU时间，是用户模式（非内核）下的CPU使用时间</li>\n<li>系统CPU时间，是进程进入内核执行的CPU使用时间</li>\n</ol>\n<p>It is easy to measure the clock time, user time, and system time of any process: simply execute the time(1) command, with the argument to the time command being the command we want to measure. For example: </p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> cd /usr/include</span><br><span class=\"line\"><span class=\"meta\">$</span> time -p grep _POSIX_SOURCE */*.h &gt; /dev/null</span><br></pre></td></tr></table></figure>\n<p>结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">real    0m0.81s</span><br><span class=\"line\">user    0m0.11s</span><br><span class=\"line\">sys     0m0.07s</span><br></pre></td></tr></table></figure>\n<p>The output format from the time command depends on the shell being used, because some shells don’t run /usr/bin/time, but instead have a separate built-in function to measure the time it takes commands to run.  time命令的输出格式取决于使用什么shell，因为有些shell并不运行：<code>/usr/bin/time</code>，而是运行自己内置的一个time函数。</p>\n<h2 id=\"1-11-System-Calls-and-Library-Functions\"><a href=\"#1-11-System-Calls-and-Library-Functions\" class=\"headerlink\" title=\"1.11    System Calls and Library Functions\"></a>1.11    System Calls and Library Functions</h2><p>All operating systems provide service points through which programs request services from the kernel. All implementations of the UNIX System provide a well-defined, limited number of entry points directly into the kernel called system calls (recall Figure 1.1). Version 7 of the Research UNIX System provided about 50 system calls, 4.4BSD provided about 110, and SVR4 had around 120. The exact number of system calls varies depending on the operating system version. More recent systems have seen incredible growth in the number of supported system calls. Linux 3.2.0 has 380 system calls and FreeBSD 8.0 has over 450.  随着时间的推移，系统调用越来越多，可见系统是越来越完善的。</p>\n<p>The system call interface has always been documented in Section 2 of the UNIX Programmer’s Manual. Its definition is in the C language, no matter which implementation technique is actually used on any given system to invoke a system call. This differs from many older operating systems, which traditionally defined the kernel entry points in the assembly language of the machine.  <strong>系统调用的文档总是在unix编程手册的第二个章节里。它是用C语言定义的</strong>，不管系统具体是如何实现系统调用的。这一点与很多老操作系统不同（老操作系统使用汇编语言定义内核接口）</p>\n<p>The technique used on UNIX systems is for each system call to have a function of the same name in the standard C library. The user process calls this function, using the standard C calling sequence. This function then invokes the appropriate kernel service, using whatever technique is required on the system. For example, the function may put one or more of the C arguments into general registers and then execute some machine instruction that generates a software interrupt in the kernel. For our purposes, we can consider the system calls to be C functions.  每个系统调用都对应一个相同名字的函数在标准C库里。用户进程调用这个函数，然后这个函数调用相应的内核服务。举个例子，这个函数可能会把一个或多个C参数放到通用寄存器，并执行机器指令在内核中产生一个软件中断。从我们的角度看，我们可以直接认为系统调用就是C函数。</p>\n<p>Section 3 of the UNIX Programmer’s Manual defines the general-purpose library functions available to programmers. These functions aren’t entry points into the kernel, although they may invoke one or more of the kernel’s system calls. For example, the printf function may use the write system call to output a string, but the strcpy (copy a string) and atoi (convert ASCII to integer) functions don’t involve the kernel at all.  在<strong>unix编程手册第三章定义了通用库函数给程序员。这些函数不是内核入口，虽然它们可能会调用一个或几个内核的系统调用</strong>。举个例子，<code>printf</code>函数可能会使用<code>write</code>系统调用来输出一个字符串，但是<code>strcpy</code>（拷贝一个字符串）和<code>atoi</code>（吧ASCII字符转成整形）函数根本没有调用内核。</p>\n<p>From an implementor’s point of view, the distinction between a system call and a library function is fundamental. From a user’s perspective, however, the difference is not as critical. From our perspective in this text, both system calls and library functions appear as normal C functions. Both exist to provide services for application programs. We should realize, however, that we can replace the library functions, if desired, whereas the system calls usually cannot be replaced.  从实现者的角度来看，系统调用和库函数的区别是很大的。然而从使用者的角度来看，这个区别并不重要。在这本书中，在我们看来，系统调用和库函数都以C函数的形式出现。两者的存在都是为了给应用开发者提供服务。然而我们应该意识到，<strong>虽然我们能替换库函数（如果我们想这样做），但系统调用不能被替换</strong>。</p>\n<p>Consider the memory allocation function malloc as an example. There are many ways to do memory allocation and its associated garbage collection (best fit, first fit, and so on). No single technique is optimal for all programs. The UNIX system call that handles memory allocation, sbrk(2), is not a general-purpose memory manager. It increases or decreases the address space of the process by a specified number of bytes. How that space is managed is up to the process. The memory allocation function, malloc(3), implements one particular type of allocation. If we don’t like its operation, we can define our own malloc function, which will probably use the sbrk system call. In fact, numerous software packages implement their own memory allocation algorithms with the sbrk system call. Figure 1.11 shows the relationship between the application, the malloc function, and the sbrk system call.  让我们来看看内存分配函数<code>malloc</code>这个例子。有很多内存分配和相关的垃圾回收方法（最好适应算法，最先适应算法，等等）。没有哪个技术是对所有程序优化的。<strong>unix系统调用<code>sbrk(2)</code>不是一个通用的存储管理器。它给进程增加和减少内存空间都是固定的字节数。怎么管理空间其实还要取决于进程自己。内存分配函数<code>malloc(3)</code>，实现了特定类型的分配。如果我们不喜欢它的做法，我们可以定义自己的malloc函数，但也是要用到sbrk系统调用的。实际上大量的软件包都通过直接使用sbrk系统调用实现了自己的内存管理算法</strong>。图1.11展示了应用，malloc函数，和sbrk系统调用之间的关系。</p>\n<p>&lt;img src=”<a href=\"https://i.loli.net/2018/05/25/5b07647fc7597.png&quot;\" target=\"_blank\" rel=\"noopener\">https://i.loli.net/2018/05/25/5b07647fc7597.png&quot;</a>, width=”70%”&gt;</p>\n<p>Here we have a clean separation of duties: the system call in the kernel allocates an additional chunk of space on behalf of the process. The malloc library function manages this space from user level.  这里职责是分明的：系统调用代表进程在内核里分配了额外的一块空间。malloc库函数在用户层级上管理这块空间。</p>\n<p>Another example to illustrate the difference between a system call and a library function is the interface the UNIX System provides to determine the current time and date. Some operating systems provide one system call to return the time and another to return the date. Any special handling, such as the switch to or from daylight saving time, is handled by the kernel or requires human intervention. The UNIX System, in contrast, provides a single system call that returns the number of seconds since the Epoch: midnight, January 1, 1970, Coordinated Universal Time. Any interpretation of this value, such as converting it to a human-readable time and date using the local time zone, is left to the user process. The standard C library provides routines to handle most cases. These library routines handle such details as the various algorithms for daylight saving time.  另一个描述系统调用和库函数不同的例子是当前时间和日期。某些操作系统提供一个系统调用返回时间，另一个系统调用返回日期。任何特殊的处理，比如正常时制与夏令时的切换，需要内核的处理或者认为干预。Unix系统则相反，只提供一个系统调用，返回UTC（UTC是指从1970年的第一秒开始算起到现在经过的总时间）。任何对UTC这个值的解释，例如把它转成人类可读的时间日期使用当地时间，就留给了用户进程。标准C库提供了诸多例程来处理大多数情况。这些库例程处理这些细节，就像大多数算法处理夏令时切换一样。</p>\n<p>An application can either make a system call or call a library routine. Also realize that many library routines invoke a system call. This is shown in Figure 1.12.  一个应用可以使用系统调用或者调用库例程，同样要意识到许多库例程调用了系统调用。</p>\n<p>Another difference between system calls and library functions is that system calls usually <strong>provide a minimal interface</strong>, whereas library functions often <strong>provide more elaborate functionality</strong>. We’ve seen this already in the difference between the sbrk system call and the malloc library function. We’ll see this difference again later, when we compare the unbuffered I/O functions (Chapter 3) and the standard I/O functions (Chapter 5).  另一个系统调用和库函数的区别就是，系统调用往往只提供一个很小的接口，然而库函数经常提供更多精细的功能。</p>\n<p><img src=\"https://i.loli.net/2018/05/25/5b07d2d3861c0.png\" width=\"70%\"></p>\n<p>The process control system calls (<strong>fork, exec, and waitpid</strong>) are usually invoked by the user’s application code directly. (Recall the bare-bones shell in Figure 1.7.) But some library routines exist to simplify certain common cases: the <strong>system</strong> and <strong>popen</strong> library routines, for example. In Section 8.13, we’ll show an implementation of the system function that invokes the basic process control system calls. We’ll enhance this example in Section 10.18 to handle signals correctly. </p>\n<p>To define the interface to the UNIX System that most programmers use, we have to describe both the system calls and some of the library functions. If we described only the sbrk system call, for example, we would skip the more programmer-friendly malloc library function that many applications use. <strong>In this text, we’ll use the term function to refer to both system calls and library functions, except when the distinction is necessary.</strong> </p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-1-Introduction\"><a href=\"#1-1-Introduction\" class=\"headerlink\" title=\"1.1    Introduction\"></a>1.1    Introduction</h2><p>All operating systems provide services for programs they run. Typical services include executing a new program, opening a file, reading a file, allocating a region of memory, getting the current time of day, and so on. The focus of this text is to describe the services provided by various versions of the UNIX operating system. 所有的操作系统都提供一些服务让程序能够在其上运行，典型的服务包括：执行一个新程序，打开一个文件，读取一个文件，分配一块内存，获取当前时间，等等。 这本书所关注的重点就是众多种类的unix操作系统能提供服务。</p>\n<p>Describing the UNIX System in a strictly linear fashion, without any forward references to terms that haven’t been described yet, is nearly impossible (and would probably be boring). 这里道出了一个众所周知的难题，想要线性的给读者讲授一个新课程，在讲授一个知识点时却又不引进任何其他的未知概念，这几乎是不可能的。</p>\n<blockquote>\n<p>但我认为能不能做到，不用去管，做教育的就是要尽可能的降低学习者的难度，将新知识点尽可能的用学习者已有的知识结构描述清楚。所以我们可以看到我们的课程都是有选修课的。</p>\n</blockquote>\n<h2 id=\"1-2-Unix-Architecture\"><a href=\"#1-2-Unix-Architecture\" class=\"headerlink\" title=\"1.2    Unix Architecture\"></a>1.2    Unix Architecture</h2><p><img src=\"https://i.loli.net/2018/05/22/5b03742b0a818.png\" width=\"50%\"></p>\n<ul>\n<li>内核（kernel）：In a strict sense, an operating system can be defined as the software that <strong>controls the hardware resources of the computer</strong> and <strong>provides an environment under which programs can run</strong>. Generally, we call this software the kernel, since it is <strong>relatively small and resides at the core of the environment</strong>. 内核控制硬件资源，并给其上的程序提供运行环境，内核相对（相对是指相对于上面这张图，整个软件环境：包括内核、系统调用、公用函数库、shell(命令解释器)、应用程序）来说比较小，并处于整个环境的中心。</li>\n<li>系统调用（system calls）：<strong>The interface to the kernel</strong> is a layer of software called the system calls . 系统调用是内核对外的接口。</li>\n<li>Libraries of common functions are built on top of the system call interface, but applications are free to use both. The shell is a special application that provides an interface for running other applications. 公共库是建立在系统调用之上的，但应用程序既可以使用公共库也可以使用系统调用。shell是一种特殊的应用程序，给执行命令(运行其他程序)提供接口。</li>\n</ul>\n<h2 id=\"1-3-Logging-In\"><a href=\"#1-3-Logging-In\" class=\"headerlink\" title=\"1.3    Logging In\"></a>1.3    Logging In</h2><h3 id=\"Login-Name\"><a href=\"#Login-Name\" class=\"headerlink\" title=\"Login Name\"></a>Login Name</h3><p><strong>口令文件（password file）</strong> ：当我们使用用户名和密码登陆unix的时候，系统会在<code>/etc/passwd</code>文件(password file，又叫：口令文件)中查找我们的用户名，口令文件中每个条目占一行，格式是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">登录名:加密过的密码:user ID:group ID:注解:home目录:shell</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>不过加密过的密码现在也不显示在这个文件里了，而是用一个<code>*</code>号或者<code>x</code>号之类的取代，home目录又称为起始目录，新开一个shell，<code>pwd</code>一下，就是home目录。</p>\n</blockquote>\n<p>例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sar:x:205:105:Stephen Rago:/home/sar:/bin/ksh</span><br></pre></td></tr></table></figure>\n<p>登录名是sar，加密过的密码是<code>x</code>（不显示在这里），user ID是205，group ID是105，注解是Stephen Rago，home目录是<code>/home/sar</code>，使用的shell是<code>/bin/ksh</code></p>\n<h3 id=\"Shells\"><a href=\"#Shells\" class=\"headerlink\" title=\"Shells\"></a>Shells</h3><p>A shell is a command-line interpreter that reads user input and executes commands. The user input to a shell is normally from the terminal (an interactive shell) or sometimes from a file (called a shell script). shell是一种命令解释器，可以读取用户的输入，并执行命令，用户可以交互式的输入命令，也可以把命令预先全部写在一个文本文件（shell脚本）中让shell执行。</p>\n<p>常见的shell有：</p>\n<p><img src=\"https://i.loli.net/2018/05/23/5b04b995bf5e1.png\" width=\"70%\"></p>\n<p>The system knows which shell to execute for us based on the final field in our entry in the password file. 系统是通过口令文件的最后一个字段知道我们登陆时使用哪个shell。</p>\n<p><code>bash</code>的全称是<code>Bourne-again shell</code></p>\n<p>The Bourne-again shell is the GNU shell provided with all Linux systems. It was designed to be POSIX conformant, while still remaining compatible with the Bourne shell. It supports features from both the C shell and the Korn shell.</p>\n<h2 id=\"1-4-Files-and-Directories\"><a href=\"#1-4-Files-and-Directories\" class=\"headerlink\" title=\"1.4     Files and Directories\"></a>1.4     Files and Directories</h2><h3 id=\"File-System\"><a href=\"#File-System\" class=\"headerlink\" title=\"File System\"></a>File System</h3><ul>\n<li><strong>根目录（root）</strong>：The UNIX file system is a hierarchical arrangement of directories and files. Everything starts in the directory called root, whose name is the single character /. unix文件系统是目录和文件的层级安排，所有东西都从一个叫root的目录开始，root的名字是一个单字符：<code>/</code>。</li>\n<li><strong>目录（directory）</strong>：A directory is a file that contains directory entries. Logically, we can think of each directory entry as containing a filename along with a structure of information describing the attributes of the file. The attributes of a file are such things as the type of file (regular file, directory), the size of the file, the owner of the file, permissions for the file (whether other users may access this file), and when the file was last modified. 目录是一个包含目录条目的文件。逻辑上，我们可以认为每一个目录条目包含一个文件名和一个描述文件属性的结构信息。文件属性包括：文件类型（普通文件还是目录），文件大小，文件所属者，文件权限（其他用户是否能访问），文件最后被修改的时间。</li>\n</ul>\n<blockquote>\n<p>The stat and fstat functions return a structure of information containing all the attributes of a file. <code>stat</code>和<code>fstat</code>函数可以返回一个结构信息，包含文件的所有属性。</p>\n</blockquote>\n<blockquote>\n<p>We make a distinction between the logical view of a directory entry and the way it is actually stored on disk. Most implementations of UNIX file systems don’t store attributes in the directory entries themselves, because of the difficulty of keeping them in synch when a file has multiple hard links. 也就是说上面目录条目只是逻辑上的，实际上在硬盘存储上并不是直接将目录条目中的那些属性存储在目录文件中的，因为如果文件有硬链接的话，很难让这些属性信息保持同步。</p>\n</blockquote>\n<h3 id=\"Filename\"><a href=\"#Filename\" class=\"headerlink\" title=\"Filename\"></a>Filename</h3><p><strong>文件名</strong>：The names in a directory are called filenames. The only two characters that cannot appear in a filename are the slash character (/) and the null character. The slash separates the filenames that form a pathname (described next) and the null character terminates a pathname. Nevertheless, it’s good practice to restrict the characters in a filename to a subset of the normal printing characters. (If we use some of the shell’s special characters in the filename, we have to use the shell’s quoting mechanism to reference the filename, and this can get complicated.) Indeed, for portability, POSIX.1 recommends restricting filenames to consist of the following characters: letters (a-z, A-Z), numbers (0-9), period (.), dash (-), and underscore (<em>).<br>一个目录中的诸多名字（包括文件和目录）称为文件名，只有两个字符不能出现在文件名中：<code>斜杠/(slash)</code>和<code>空字符(null character)</code>，斜杠用来分割<code>路径名(pathname)</code>中的文件名，空字符用来结束一个路径名（实际上编程语言中字符串就是由空字符来结束的）。然而，我们命名文件的时候最好不要使用一些乱七八糟的字符，如果我们使用了shell的特殊字符，我们就必须使用shell的引用机制去引用文件名。实际上，为了可移植性，POSIX.1标准推荐严格使用以下字符来命名文件：字母(a-z, A-Z)，数字(0-9)，点(.)，中杠(-)，下划线(</em>)。</p>\n<p>Two filenames are automatically created whenever a new directory is created: . (called dot) and .. (called dot-dot). Dot refers to the current directory, and dot-dot refers to the parent directory. In the root directory, dot-dot is the same as dot. 有两个文件名在目录被创建的时候自动创建：<code>.</code>和<code>..</code>，<code>.</code>指向当前目录，<code>..</code>指向父目录，在根目录中，<code>..</code>和<code>.</code>一样（都指向当前目录）。</p>\n<blockquote>\n<p>The Research UNIX System and some older UNIX System V file systems restricted a filename to 14 characters. BSD versions extended this limit to 255 characters. Today, almost all commercial UNIX file systems support at least 255-character filenames. 现如今的unix文件系统都支持至少255字符的文件名。</p>\n</blockquote>\n<h3 id=\"Pathname\"><a href=\"#Pathname\" class=\"headerlink\" title=\"Pathname\"></a>Pathname</h3><p>A sequence of one or more filenames, separated by slashes and optionally starting with a slash, forms a pathname. A pathname that begins with a slash is called an absolute pathname; otherwise, it’s called a relative pathname. Relative pathnames refer to files relative to the current directory. 一系列的由斜杠分割而开的文件名组成一个路径名，一个路径名可以由一个斜杠开始，这叫做：<code>绝对路径</code>，反之就是相对路径，相对路径是相对于当前路径的。</p>\n<h3 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h3><p>Listing the names of all the files in a directory is not difficult. There is a bare-bones implementation of the ls(1) command:</p>\n<blockquote>\n<p>Figure 1.3 List all the files in a directory </p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"apue.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;dirent.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">   DIR *dp;</span><br><span class=\"line\">   <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">dirent</span> *<span class=\"title\">dirp</span>;</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> (argc != <span class=\"number\">2</span>)</span><br><span class=\"line\">       err_quit(<span class=\"string\">\"usage: ls directory_name\"</span>);</span><br><span class=\"line\">   <span class=\"keyword\">if</span> ((dp = opendir(argv[<span class=\"number\">1</span>])) == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">       err_sys(<span class=\"string\">\"can’t open %s\"</span>, argv[<span class=\"number\">1</span>]);</span><br><span class=\"line\">   <span class=\"keyword\">while</span> ((dirp = readdir(dp)) != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">       <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\\n\"</span>, dirp-&gt;d_name);</span><br><span class=\"line\">    closedir(dp);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>The notation ls(1) is the normal way to reference a particular entry in the UNIX system manuals. It refers to the entry for ls in Section 1. The sections are normally numbered 1 through 8, and all the entries within each section are arranged alphabetically. Throughout this text, we assume that you have a copy of the manuals for your UNIX system.  熟悉unix的人应该都知道，unix有个man命令，可以查看其它命令的说明书，当然也可以<code>man man</code>查看自己的说明书。 man命令有8个section，每个section里的条目按照字幕顺序排列。</p>\n<blockquote>\n<p>Historically, UNIX systems lumped all eight sections together into what was called the UNIX Programmer’s Manual. As the page count increased, the trend changed to distributing the sections among separate manuals: <strong>one for users, one for programmers, and one for system administrators</strong>, for example. Some UNIX systems further divide the manual pages within a given section, using an uppercase letter. For example, all the standard input/output (I/O) functions in AT&amp;T [1990e] are indicated as being in Section 3S, as in fopen(3S). Other systems have replaced the numeric sections with alphabetic ones, such as C for commands. </p>\n</blockquote>\n<p>Today, most manuals are distributed in electronic form. If your manuals are online, the way to see the manual pages for the ls command would be something like </p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">man 1 ls</span><br></pre></td></tr></table></figure>\n<p>or</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">man -s1 ls</span><br></pre></td></tr></table></figure>\n<p>Figure 1.3 is a program that just prints the name of every file in a directory, and nothing else. If the source file is named myls.c, we compile it into the default a.out executable file by running </p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cc myls.c</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Historically, cc(1) is the C compiler. On systems with the GNU C compilation system, the C </p>\n<p>compiler is gcc(1). Here, cc is usually linked to gcc. </p>\n</blockquote>\n<p>但在实际的操作过程中，遇到了如下错误：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Undefined symbols for architecture x86_64:</span><br><span class=\"line\">  &quot;_err_quit&quot;, referenced from:</span><br><span class=\"line\">      _main in fig1-457251.o</span><br><span class=\"line\">  &quot;_err_sys&quot;, referenced from:</span><br><span class=\"line\">      _main in fig1-457251.o</span><br><span class=\"line\">ld: symbol(s) not found for architecture x86_64</span><br><span class=\"line\">clang: error: linker command failed with exit code 1 (use -v to see invocation)</span><br></pre></td></tr></table></figure>\n<p>这是个链接错误，具体的解决办法请看这篇博客：<a href=\"https://my.oschina.net/alextuan/blog/530425\" target=\"_blank\" rel=\"noopener\">OS X下UNIX环境高级编程（第三版）学习日志－第一章ChapterI，编译apue包与第一个例程</a></p>\n<ul>\n<li>When the program is done, it calls the function exit with an argument of 0. The function exit terminates a program. By convention, an argument of 0 means OK, and an argument between 1 and 255 means that an error occurred.  <strong>0代表OK，1到255代表各种类型的错误</strong>。</li>\n</ul>\n<h3 id=\"Working-Directory\"><a href=\"#Working-Directory\" class=\"headerlink\" title=\"Working Directory\"></a>Working Directory</h3><p><strong>工作目录（working directory）</strong>：Every process has a working directory, sometimes called the <strong>current working directory</strong>. This is the directory from which all relative pathnames are interpreted. A process can change its working directory with the <code>chdir</code> function.  每个进程都有一个工作目录，又叫做：当前工作目录，相对路径就是相对于当前工作目录的来解释的，可以调用<code>chdir</code>函数来改变工作目录。</p>\n<p>For example, the relative pathname doc/memo/joe refers to the file or directory joe, in the directory memo, in the directory doc, which must be a directory within the working directory. From looking just at this pathname, we know that both doc and memo have to be directories, but we can’t tell whether joe is a file or a directory. The pathname /usr/lib/lint is an absolute pathname that refers to the file or directory lint in the directory lib, in the directory usr, which is in the root directory.  这里有趣的一点是，我们无法判断joe是文件还是目录。</p>\n<h3 id=\"Home-Directory\"><a href=\"#Home-Directory\" class=\"headerlink\" title=\"Home Directory\"></a>Home Directory</h3><p>When we log in, the working directory is set to our <strong>home directory</strong>. Our home directory is obtained from our entry in the <strong>password file</strong> (Section 1.3).  当我们登陆的时候，工作目录会设定为home目录，而我们的home目录设置在口令文件中。</p>\n<h2 id=\"1-5-Input-and-Output\"><a href=\"#1-5-Input-and-Output\" class=\"headerlink\" title=\"1.5    Input and Output\"></a>1.5    Input and Output</h2><h3 id=\"File-Descriptors\"><a href=\"#File-Descriptors\" class=\"headerlink\" title=\"File Descriptors\"></a>File Descriptors</h3><p><strong>文件描述符（file descriptor）</strong>：File descriptors are normally small non-negative integers that the kernel uses to identify the files accessed by a process. Whenever it opens an existing file or creates a new file, the kernel returns a file descriptor that we use when we want to read or write the file.  文件描述符是一个小的非负整数，内核用它来标识正在被进程访问的文件。打开或者创建文件的时候内核会返回一个文件描述符，我们可以使用这个文件描述符来对文件进行读写。</p>\n<h3 id=\"Standard-Input-Standard-Output-and-Standard-Error\"><a href=\"#Standard-Input-Standard-Output-and-Standard-Error\" class=\"headerlink\" title=\"Standard Input, Standard Output, and Standard Error\"></a>Standard Input, Standard Output, and Standard Error</h3><p><strong>标准输入，标准输出，标准错误</strong>：By convention, all shells open three descriptors whenever a new program is run: standard input, standard output, and standard error. If nothing special is done, as in the simple command </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls</span><br></pre></td></tr></table></figure>\n<p>then <strong>all three are connected to the terminal</strong>. Most shells provide a way to redirect any or all of these three descriptors to any file. For example, </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls &gt; file.list</span><br></pre></td></tr></table></figure>\n<p>executes the ls command with its standard output redirected to the file named </p>\n<p>file.list. </p>\n<p><strong>按照惯例，当新程序运行的时候，shell会打开三个文件描述符：标准输入，标准输出，标准错误。如果没有进行指明，那么三个文件描述符都会连接到终端。</strong></p>\n<h3 id=\"Unbuffered-I-O\"><a href=\"#Unbuffered-I-O\" class=\"headerlink\" title=\"Unbuffered I/O\"></a>Unbuffered I/O</h3><p>Unbuffered I/O is provided by the functions <code>open</code>, <code>read</code>,<code>write</code>, <code>lseek</code>, and <code>close</code>. These functions all work with file descriptors. <strong>unbuffered I/O</strong>意思是系统不提供buffer管理，要你自己申请buffer，并传递给系统函数。</p>\n<h3 id=\"Example-1\"><a href=\"#Example-1\" class=\"headerlink\" title=\"Example\"></a>Example</h3><p>If we’re willing to read from the standard input and write to the standard output, then the program in Figure 1.4 copies any regular file on a UNIX system. </p>\n<blockquote>\n<p>Figure 1.4 Copy standard input to standard output </p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"apue.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> BUFFSIZE 4096</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> buf[BUFFSIZE];</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((n = read(STDIN_FILENO, buf, BUFFSIZE)) &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (write(STDOUT_FILENO, buf, n) != n)</span><br><span class=\"line\">            err_sys(<span class=\"string\">\"write error\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (n &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        err_sys(<span class=\"string\">\"read error\"</span>);</span><br><span class=\"line\">true<span class=\"built_in\">exit</span>(<span class=\"number\">0</span>); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面是对程序的解释：</p>\n<p>The <code>&lt;unistd.h&gt;</code> header, included by <code>apue.h</code>, and the two constants <code>STDIN_FILENO</code> and <code>STDOUT_FILENO</code> are part of the POSIX standard (about which we’ll have a lot more to say in the next chapter). This header contains function prototypes for many of the UNIX system services, such as the <code>read</code> and <code>write</code> functions that we call. </p>\n<p>The constants STDIN_FILENO and STDOUT_FILENO are defined in &lt;unistd.h&gt; and specify the file descriptors for standard input and standard output. <strong>These values are 0 and 1, respectively, as required by POSIX.1</strong>, but we’ll use the names for readability. POSIX.1标准：<strong>标准输入是0，标准输出是1，标准错误是2</strong>。</p>\n<p>The <code>read</code> function returns the number of bytes that are read, and this value is used as the number of bytes to <code>write</code>. When the end of the input file is encountered, read returns 0 and the program stops. If a read error occurs, read returns −1. Most of the system functions return −1 when an error occurs.  <code>read</code>函数返回的是读入字节的个数，把这个返回值传给<code>write</code>函数，就可以读多少写多少了，当遇到输入文件结束时，read函数返回0，当遇到错误时，read函数返回-1。<strong>许多系统函数返回-1，当它们遇到错误时</strong>。</p>\n<p>If we compile the program into the standard name (a.out) and execute it as </p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./a.out &gt; data</span><br></pre></td></tr></table></figure>\n<p>standard input is the terminal, standard output is redirected to the file data, and standard error is also the terminal. <strong>If this output file doesn’t exist, the shell creates it by default</strong>. The program copies lines that we type to the standard output <strong>until we type the end-of-file character (usually Control-D)</strong>. </p>\n<p>If we run </p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./a.out &lt; infile &gt; outfile</span><br></pre></td></tr></table></figure>\n<p>then the file named infile will be copied to the file named outfile. </p>\n<p>如果文件不存在，shell默认给我们创建一个。标准输入和标准错误都是终端，我们可以一直输入，直到输入一个文件结束符，也就是<code>ctrl+d</code>。</p>\n<h3 id=\"Standard-I-O\"><a href=\"#Standard-I-O\" class=\"headerlink\" title=\"Standard I/O\"></a>Standard I/O</h3><p>The standard I/O functions provide a buffered interface to the unbuffered I/O functions. <strong>Using standard I/O relieves us from having to choose optimal buffer sizes</strong>, such as the BUFFSIZE constant in Figure 1.4. The standard I/O functions also simplify dealing with lines of input (a common occurrence in UNIX applications). <strong>The <code>fgets</code> function, for example, reads an entire line. The read function, in contrast, reads a specified number of bytes</strong>. As we shall see in Section 5.4, the standard I/O library provides functions that let us control the style of buffering used by the library. 标准I/O函数给unbuffered I/O 函数提供了缓冲接口，使用标准I/O函数可以让我们从优化buffer大小中解脱出来，举个例子，<code>fgets</code>函数直接读取一整行，而<code>read</code>函数读取固定个数的字节。</p>\n<p>The most common standard I/O function is <code>printf</code>. In programs that call printf, we’ll always include &lt;stdio.h&gt;—normally by including apue.h—as this header contains the function prototypes for all the standard I/O functions. </p>\n<h3 id=\"Example-2\"><a href=\"#Example-2\" class=\"headerlink\" title=\"Example\"></a>Example</h3><p>The program in Figure 1.5, which we’ll examine in more detail in Section 5.8, is like the previous program that called read and write. This program copies standard input to standard output and can copy any regular file. </p>\n<blockquote>\n<p>Figure 1.5 Copy standard input to standard output, using standard I/O </p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"apue.h\"</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">true<span class=\"keyword\">int</span> c;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> ((c = getc(<span class=\"built_in\">stdin</span>)) != EOF)</span><br><span class=\"line\">    \t<span class=\"keyword\">if</span> (putc(c, <span class=\"built_in\">stdout</span>) == EOF)</span><br><span class=\"line\">    \t\terr_sys(<span class=\"string\">\"output error\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ferror(<span class=\"built_in\">stdin</span>))</span><br><span class=\"line\">    \terr_sys(<span class=\"string\">\"input error\"</span>);</span><br><span class=\"line\">true<span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>The function getc reads one character at a time, and this character is written by putc</strong>. After the last byte of input has been read, getc returns the constant EOF (defined in &lt;stdio.h&gt;). The standard I/O constants stdin and stdout are also defined in the &lt;stdio.h&gt; header and refer to the standard input and standard output. </p>\n<h2 id=\"1-6-Programs-and-Processes\"><a href=\"#1-6-Programs-and-Processes\" class=\"headerlink\" title=\"1.6    Programs and Processes\"></a>1.6    Programs and Processes</h2><h3 id=\"Program\"><a href=\"#Program\" class=\"headerlink\" title=\"Program\"></a>Program</h3><p>A program is an executable file residing on disk in a directory. A program is read into memory and is executed by the kernel as a result of one of the <strong>seven exec functions</strong>. </p>\n<h3 id=\"Processes-and-Process-ID\"><a href=\"#Processes-and-Process-ID\" class=\"headerlink\" title=\"Processes and Process ID\"></a>Processes and Process ID</h3><p>An executing instance of a program is called a <strong>process</strong>, a term used on almost every page of this text. Some operating systems use the term <strong>task</strong> to refer to a program that is being executed.  程序运行的一个实例叫做：进程，也有些操作系统使用：task这个术语来描述被执行的程序。</p>\n<p>The UNIX System guarantees that every process has a unique numeric identifier called the process ID. The process ID is always a non-negative integer. unix系统保证每个进程都有独一无二的进程ID，这个进程ID是一个非负整数。</p>\n<h3 id=\"Example-3\"><a href=\"#Example-3\" class=\"headerlink\" title=\"Example\"></a>Example</h3><p>The program in Figure 1.6 prints its process ID. </p>\n<blockquote>\n<p>Figure 1.6 Print the process ID  </p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"apue.h\"</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"hello world from process ID %ld\\n\"</span>, (<span class=\"keyword\">long</span>)getpid());</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  apue.3e ./fig1.6</span><br><span class=\"line\">hello world from process ID 8080</span><br><span class=\"line\">➜  apue.3e ./fig1.6</span><br><span class=\"line\">hello world from process ID 8086</span><br></pre></td></tr></table></figure>\n<h3 id=\"Process-Control\"><a href=\"#Process-Control\" class=\"headerlink\" title=\"Process Control\"></a>Process Control</h3><p>There are three primary functions for process control: <code>fork</code>, <code>exec</code>, and <code>waitpid</code>. (The exec function has seven variants, but we often refer to them collectively as simply the exec function.)  有三个进程控制的基本函数：<code>fork</code>，<code>exec</code>和<code>waitpid</code>，虽然exec函数有7种变体，但我们往往简单的用一个exec来表示它们。</p>\n<h3 id=\"Example-4\"><a href=\"#Example-4\" class=\"headerlink\" title=\"Example\"></a>Example</h3><p>The process control features of the UNIX System are demonstrated using a simple program (Figure 1.7) that reads commands from standard input and executes the commands. This is a bare-bones implementation of a shell-like program. </p>\n<blockquote>\n<p>Figure 1.7 Read commands from standard input and execute them </p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"include/apue.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/wait.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span>    buf[MAXLINE];   <span class=\"comment\">/* from apue.h */</span></span><br><span class=\"line\">    <span class=\"keyword\">pid_t</span>   pid;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>     status;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%% \"</span>);  <span class=\"comment\">/* print prompt (printf requires %% to print %) */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (fgets(buf, MAXLINE, <span class=\"built_in\">stdin</span>) != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (buf[<span class=\"built_in\">strlen</span>(buf) - <span class=\"number\">1</span>] == <span class=\"string\">'\\n'</span>)</span><br><span class=\"line\">            buf[<span class=\"built_in\">strlen</span>(buf) - <span class=\"number\">1</span>] = <span class=\"number\">0</span>; <span class=\"comment\">/* replace newline with null */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((pid = fork()) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            err_sys(<span class=\"string\">\"fork error\"</span>);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pid == <span class=\"number\">0</span>) &#123;      <span class=\"comment\">/* child */</span></span><br><span class=\"line\">            execlp(buf, buf, (<span class=\"keyword\">char</span> *)<span class=\"number\">0</span>);</span><br><span class=\"line\">            <span class=\"comment\">// or</span></span><br><span class=\"line\">            <span class=\"comment\">// execlp(buf, buf, (char *)NULL);</span></span><br><span class=\"line\">            err_ret(<span class=\"string\">\"couldn’t execute: %s\"</span>, buf);</span><br><span class=\"line\">            <span class=\"built_in\">exit</span>(<span class=\"number\">127</span>);</span><br><span class=\"line\">truetrue&#125;</span><br><span class=\"line\">        <span class=\"comment\">/* parent */</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((pid = waitpid(pid, &amp;status, <span class=\"number\">0</span>)) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            err_sys(<span class=\"string\">\"waitpid error\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%% \"</span>);</span><br><span class=\"line\">true&#125;</span><br><span class=\"line\">true<span class=\"built_in\">exit</span>(<span class=\"number\">0</span>); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>There are several features to consider in this 30-line program. </p>\n<ul>\n<li>We use the standard I/O function fgets to read one line at a time from the standard input. When we type the end-of-file character (which is often Control-D) as the first character of a line, fgets returns a null pointer, the loop stops, and the process terminates. In Chapter 18, we describe all the special terminal characters—end of file, backspace one character, erase entire line, and so on—and how to change them.  我们使用了标准I/O函数<code>fgets</code>来一次读取标准输入的一行。当我们直接输入一个EOF时，fgets返回一个空指针，循环停止，进程终止。在第18章，我们将讲述特殊终止符，比如：end of file，backspace one character, erase entire line, 等等，以及如何改变它们。</li>\n<li>Because each line returned by fgets is terminated with a newline character, followed by a null byte, we use the standard C function strlen to calculate the length of the string, and then replace the newline with a null byte. We do this because the execlp function wants a null-terminated argument, not a newline-terminated argument.  因为fgets返回的每一行都被一个换行符终止，换行符之后是一个空字符，我们使用标准C函数<code>strlen</code>来计算string的长度，然后将换行符替换成空字符（这样末尾就两个空字符了）。我们这样做是因为<code>execlp</code>函数希望有一个空字符来作为结尾参数，而不是一个换行符。</li>\n<li>We call fork to create a new process, which is a copy of the caller. We say that the caller is the parent and that the newly created process is the child. Then fork returns the non-negative process ID of the new child process to the parent, and returns 0 to the child. Because fork creates a new process, we say that it is called once—by the parent—but returns twice—in the parent and in the child.  我们调用<code>fork</code>创建一个新进程，这个新进程是调用进程的一个复制。我们说，调用者是父进程，新创建出来的进程是子进程。<strong>然后fork返回子进程的非负进程ID给父进程，并返回0给子进程</strong>。因为fork创建了一个新进程，<strong>我们说它调用了一次（被父进程），但是返回了两次</strong>，在父进程和子进程里面。</li>\n<li>In the child, we call execlp to execute the command that was read from the standard input. This replaces the child process with the new program file. The combination of fork followed by exec is called spawning a new process on some operating systems. In the UNIX System, the two parts are separated into individual functions. We’ll say a lot more about these functions in Chapter 8.  在子进程中，我们调用<code>execlp</code>来执行从标注输入中读取来的命令。这就把子进程替换成了新执行的程序。fork后面跟个exec这种结合方式被叫做 <strong>spawning a new process</strong> 在某些操作系统中。在unix系统中，这两部分被分别放到了两个单独的函数中。我们将在第8章中讨论更多的这类函数。</li>\n<li>Because the child calls execlp to execute the new program file, the parent wants to wait for the child to terminate. This is done by calling waitpid, specifying which process to wait for: the pid argument, which is the process ID of the child. The waitpid function also returns the termination status of the child—the status variable—but in this simple program, we don’t do anything with this value. We could examine it to determine how the child terminated.  因为子进程调用了<code>execlp</code>来执行新程序文件，父进程想要等子进程结束。通过调用<code>waitpid</code>可以完成这个任务，用<code>pid</code>（子进程的进程ID）参数来明确需要等待哪个进程。<code>waitpid</code>函数同样也返回子进程的终止状态（记录在status这个参数），但在这个简单的程序里，我们没有用到这个值。我们通过这个值得知子进程是如何结束的。</li>\n<li>The most fundamental limitation of this program is that we can’t pass arguments to the command we execute. We can’t, for example, specify the name of a directory to list. We can execute ls only on the working directory. To allow arguments would require that we parse the input line, separating the arguments by some convention, probably spaces or tabs, and then pass each argument as a separate parameter to the execlp function. Nevertheless, this program is still a useful demonstration of the UNIX System’s process control functions.  这个程序最大的限制就是，我们不能传递参数给我们要执行的命令。比如，我们不能给定一个目录给list程序（展示目录下的所有目录和文件的程序）。我们只能在当前目录下执行ls。如果要允许传递参数，就需要我们分析输入行，按照惯例，比如空格或者制表符，把参数分割开来，然后把参数传给execlp函数。不管怎么说，这个程序已经很好的展示了unix系统是如何控制函数的。</li>\n</ul>\n<p>If we run this program, we get the following result. Note that our program has a different prompt—the percent sign—to distinguish it from the shell’s prompt. </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  apue.3e ./fig1.7</span><br><span class=\"line\">% pwd</span><br><span class=\"line\">/Users/liuqinh2s/Downloads/apue.3e</span><br><span class=\"line\">% who</span><br><span class=\"line\">liuqinh2s console  May 21 12:09</span><br><span class=\"line\">liuqinh2s ttys000  May 21 12:10</span><br><span class=\"line\">% date</span><br><span class=\"line\">2018年 5月24日 星期四 15时26分59秒 CST</span><br><span class=\"line\">% %                                                                                                                                                                                                         ➜  apue.3e</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>The notation ˆD is used to indicate a control character. Control characters are special characters formed by holding down the control key—often labeled Control or Ctrl—on your keyboard and then pressing another key at the same time. <strong>Control-D, or ˆD, is the default end-of-file character</strong>. We’ll see many more control characters when we discuss terminal I/O in Chapter 18.  <code>^D</code>这种记法用于表示控制字符，控制字符是一类特殊的字符，由<code>ctrl</code>键加一个其他键组成，<code>Control-D</code>或者说<code>^D</code>是默认的文件终止符。我们将在第18章讨论输入输出终止符的时候看到更多的控制字符。</p>\n</blockquote>\n<h3 id=\"Threads-and-Thread-IDs\"><a href=\"#Threads-and-Thread-IDs\" class=\"headerlink\" title=\"Threads and Thread IDs\"></a>Threads and Thread IDs</h3><p>Usually, a process has only one thread of control—one set of machine instructions executing at a time. Some problems are easier to solve when more than one thread of control can operate on different parts of the problem. Additionally, multiple threads of control can exploit the parallelism possible on multiprocessor systems. </p>\n<p>All threads within a process share the same address space, file descriptors, stacks, and process-related attributes. Each thread executes on its own stack, although any thread can access the stacks of other threads in the same process. Because they can access the same memory, the threads need to synchronize access to shared data among themselves to avoid inconsistencies.  属于同一个进程的多个线程共享同一块内存空间，文件描述符，栈，以及和进程相关的属性。每个线程都在自己的栈里面执行，但每个线程又能访问其他线程的栈（同属于一个进程的多个线程）。因为它们能访问同一块内存，所以为了避免不一致性，需要保护好临界资源。</p>\n<p>Like processes, threads are identified by IDs. <strong>Thread IDs, however, are local to a process</strong>. A thread ID from one process has no meaning in another process. We use thread IDs to refer to specific threads as we manipulate the threads within a process.  就像进程一样，线程也用ID标识。<strong>然而线程ID是局部的，只在某个进程内有效，出了这个进程，对其他进程来说这个线程ID就没有任何意义了。</strong></p>\n<blockquote>\n<p>threads were added to the UNIX System long after the process model was established </p>\n</blockquote>\n<h2 id=\"1-7-Error-Handling\"><a href=\"#1-7-Error-Handling\" class=\"headerlink\" title=\"1.7    Error Handling\"></a>1.7    Error Handling</h2><p>When an error occurs in one of the UNIX System functions, a negative value is often returned, and the integer <strong>errno</strong> is usually set to a value that tells why. For example, the open function returns either a non-negative file descriptor if all is OK or −1 if an error occurs. An error from open has about 15 possible errno values, such as file doesn’t exist, permission problem, and so on. Some functions use a convention other than returning a negative value. For example, most functions that return a pointer to an object return a null pointer to indicate an error.  当unix系统函数出错时，会返回一个负数，整形变量<strong>errno</strong>会设置为一个值，这个值告诉我们为什么出错。例如，open函数返回一个非负的文件描述符，如果成功的话，如果出现错误则返回一个-1。open函数返回的错误有15个可能的errno值，比如：文件不存在，权限问题，等等。有些函数使用另一个传统而非返回一个负数。例如，很多函数返回一个对象指针，或者一个空指针如果出现错误。</p>\n<p>The file &lt;errno.h&gt; defines the symbol errno and constants for each value that errno can assume. Each of these constants begins with the character E. Also, the first page of Section 2 of the UNIX system manuals, named intro(2), usually lists all these error constants. For example, if errno is equal to the constant EACCES, this indicates a permission problem, such as insufficient permission to open the requested file.  <code>&lt;errno.h&gt;</code>文件定义了变量errno和一系列常量（errno可能的值）。每个常量都以字符<code>E</code>开头。unix系统手册<code>intro(2)</code>展示了这些常量。例如，如果errno等于常量EACCES，就表示是权限问题，没有足够的权限去打开这个文件。</p>\n<blockquote>\n<p>On Linux, the error constants are listed in the errno(3) manual page. </p>\n</blockquote>\n<p>POSIX and ISO C define errno as a symbol expanding into a modifiable lvalue of type integer. This can be either an integer that contains the error number or a function that returns a pointer to the error number. The historical definition is </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> errno;</span><br></pre></td></tr></table></figure>\n<p>But in an environment that supports threads, the process address space is shared among multiple threads, and each thread needs its own local copy of errno to prevent one thread from interfering with another. Linux, for example, supports multithreaded access to errno by defining it as </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> *__errno_location(<span class=\"keyword\">void</span>); </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> errno (*__errno_location())</span></span><br></pre></td></tr></table></figure>\n<p>POSIX和ISO C把errno定义为一个可以修改的左值。可以定义为一个整形值，也可以定义为一个指针，指针指向错误码（String类型）。如果是多线程环境下，每个线程都有自己的一个errno拷贝。通过宏定义把errno给替换成函数：<code>int *__errno_location(void);</code>了。</p>\n<p>There are two rules to be aware of with respect to errno. First, its value is never cleared by a routine if an error does not occur. Therefore, we should examine its value only when the return value from a function indicates that an error occurred. Second, the value of errno is never set to 0 by any of the functions, and none of the constants defined in &lt;errno.h&gt; has a value of 0.  第一，如果没有出错，errno的值不会被重置，因此，我们只有在函数返回出错的时候才检查errno；第二，errno不会等于0。</p>\n<p>Two functions are defined by the C standard to help with printing error messages. </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> *<span class=\"title\">strerror</span><span class=\"params\">(<span class=\"keyword\">int</span> errnum)</span></span>;\t<span class=\"comment\">//Returns: pointer to message string</span></span><br></pre></td></tr></table></figure>\n<p>This function maps errnum, which is typically the errno value, into an error message string and returns a pointer to the string. </p>\n<p>The perror function produces an error message on the standard error, based on the current value of errno, and returns. </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">perror</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* msg)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>It outputs the string pointed to by msg, followed by a colon and a space, followed by the error message corresponding to the value of errno, followed by a newline. </p>\n<h3 id=\"Example-5\"><a href=\"#Example-5\" class=\"headerlink\" title=\"Example\"></a>Example</h3><p>Figure 1.8 shows the use of these two error functions. </p>\n<blockquote>\n<p>Figure 1.8 Demonstrate strerror and perror </p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"apue.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;errno.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">\"EACCES: %s\\n\"</span>, strerror(EACCES));</span><br><span class=\"line\">    errno = ENOENT;</span><br><span class=\"line\">    perror(argv[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>输出结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  apue.3e ./fig1.8</span><br><span class=\"line\">EACCES: Permission denied</span><br><span class=\"line\">./fig1.8: No such file or directory</span><br><span class=\"line\">➜  apue.3e</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>argv[0] 表示输入的第一个参数，也就是命令名</p>\n</blockquote>\n<h3 id=\"Error-Recovery\"><a href=\"#Error-Recovery\" class=\"headerlink\" title=\"Error Recovery\"></a>Error Recovery</h3><p>The errors defined in &lt;errno.h&gt; can be divided into two categories: fatal and nonfatal. A fatal error has no recovery action. The best we can do is print an error message on the user’s screen or to a log file, and then exit. Nonfatal errors, on the other hand, can sometimes be dealt with more robustly. Most nonfatal errors are temporary, such as a resource shortage, and might not occur when there is less activity on the system.  定义在<code>&lt;errno.h&gt;</code>中的错误可以分为两类：fatal和nonfatal，致命和非致命。致命错误没有恢复动作，我们最多能做的就是把错误信息在用户显示屏上打印出来，或者写到log文件里，然后退出。非致命错误，可以更妥善的处理，许多非致命错误都是暂时的，比如：资源短缺，当系统活动较少时这类错误可能不会发生。</p>\n<p>Resource-related nonfatal errors include <strong>EAGAIN, ENFILE, ENOBUFS, ENOLCK, ENOSPC, EWOULDBLOCK</strong>, and sometimes <strong>ENOMEM</strong>. <strong>EBUSY</strong> can be treated as nonfatal when it indicates that a shared resource is in use. Sometimes, <strong>EINTR</strong> can be treated as a nonfatal error when it interrupts a slow system call (more on this in Section 10.5).  </p>\n<p>The typical recovery action for a resource-related nonfatal error is to delay and retry later. This technique can be applied in other circumstances. For example, if an error indicates that a network connection is no longer functioning, it might be possible for the application to delay a short time and then reestablish the connection. Some applications use an exponential backoff algorithm, waiting a longer period of time in each subsequent iteration.  <strong>典型的资源相关性非致命错误的处理办法是先等一下，之后再重试。</strong></p>\n<p><strong>Ultimately, it is up to the application developer to determine the cases where an application can recover from an error. If a reasonable recovery strategy can be used, we can improve the robustness of our application by avoiding an abnormal exit. </strong></p>\n<h2 id=\"1-8-User-Identification\"><a href=\"#1-8-User-Identification\" class=\"headerlink\" title=\"1.8    User Identification\"></a>1.8    User Identification</h2><h3 id=\"User-ID\"><a href=\"#User-ID\" class=\"headerlink\" title=\"User ID\"></a>User ID</h3><p>The user ID from our entry in the password file is a numeric value that identifies us to the system. This user ID is assigned by the system administrator when our login name is assigned, and we cannot change it. The user ID is normally assigned to be unique for every user. We’ll see how the kernel uses the user ID to check whether we have the appropriate permissions to perform certain operations.  用户ID来自口令文件中对应的条目，它是以数字的形式帮助系统对我们进行标识。用户ID是系统管理员给我们分配的（当分配登录名时，同时也必须分配用户ID），我们自己无法改。每个人的用户ID应该是唯一的，内核使用用户ID来检查我们是否有合适的权限来进行一个操作。</p>\n<p>We call the user whose user ID is 0 either root or the superuser. The entry in the password file normally has a login name of root, and we refer to the special privileges of this user as superuser privileges. As we’ll see in Chapter 4, if a process has superuser privileges, most file permission checks are bypassed. Some operating system functions are restricted to the superuser. The superuser has free rein over the system.  我们把用户ID为0的用户称为：<strong>root</strong>或者<strong>superuser</strong>。口令文件中有一个条目的登录名是root，root用户拥有特殊权限。拥有superuser特权的进程可以自由的使用任意文件，而且有些操作系统函数是只对superuser开放的。superuser拥有对系统的绝对的权限（可以把系统弄残）。</p>\n<blockquote>\n<p>Client versions of Mac OS X ship with the superuser account disabled; server versions ship with the account already enabled. Instructions are available on Apple’s Web site describing how to enable it. See <a href=\"http://support.apple.com/kb/HT1528\" target=\"_blank\" rel=\"noopener\">http://support.apple.com/kb/HT1528</a>. </p>\n</blockquote>\n<h3 id=\"Group-ID\"><a href=\"#Group-ID\" class=\"headerlink\" title=\"Group ID\"></a>Group ID</h3><p>Our entry in the password file also specifies our numeric group ID. This, too, is assigned by the system administrator when our login name is assigned. Typically, the password file contains multiple entries that specify the same group ID. Groups are normally used to collect users together into projects or departments. This allows the sharing of resources, such as files, among members of the same group. We’ll see in Section 4.5 that we can set the permissions on a file so that all members of a group can access the file, whereas others outside the group cannot.  Group ID的作用就是让相同组的人共享资源。</p>\n<p>There is also a group file that maps group names into numeric group IDs. The group file is usually <code>/etc/group</code>. </p>\n<p>The use of numeric user IDs and numeric group IDs for permissions is historical. With every file on disk, the file system stores both the user ID and the group ID of a file’s owner. Storing both of these values requires only four bytes, assuming that each is stored as a two-byte integer. If the full ASCII login name and group name were used instead, additional disk space would be required. In addition, comparing strings during permission checks is more expensive than comparing integers.  使用数字的用户ID和组ID是有历史原因的。对于每个存放在磁盘上的文件，文件系统都存储了该文件的拥有者的用户ID和组ID。存储这两个数字需要4字节（每个2字节），如果使用ASCII编码的登录名和组名，需要多用掉很多额外的磁盘空间。另外在检查权限是否合格时，整形数字比较要比字符串比较更快。</p>\n<p>Users, however, work better with names than with numbers, so the password file maintains the mapping between login names and user IDs, and the group file provides the mapping between group names and group IDs. The ls -l command, for example, prints the login name of the owner of a file, using the password file to map the numeric user ID into the corresponding login name.  然而对于用户来说名字比数字更好记，所以password file和group file分别记录了登录名和用户ID的映射，组名和组ID的映射。使用<code>ls -l</code>命令，可以看到打印出了文件所属者和所属的组，其原理就是查找了password file和group file，把相应的数字ID换成名字。</p>\n<blockquote>\n<p>Early UNIX systems used 16-bit integers to represent user and group IDs. Contemporary UNIX systems use 32-bit integers. </p>\n</blockquote>\n<h3 id=\"Example-6\"><a href=\"#Example-6\" class=\"headerlink\" title=\"Example\"></a>Example</h3><p>The program in Figure 1.9 prints the user ID and the group ID. </p>\n<blockquote>\n<p>Figure 1.9 Print user ID and group ID  </p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"apue.h\"</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">true<span class=\"built_in\">printf</span>(<span class=\"string\">\"uid = %d, gid = %d\\n\"</span>, getuid(), getgid());</span><br><span class=\"line\">true<span class=\"built_in\">exit</span>(<span class=\"number\">0</span>); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Supplementary-Group-IDs\"><a href=\"#Supplementary-Group-IDs\" class=\"headerlink\" title=\"Supplementary Group IDs\"></a>Supplementary Group IDs</h3><p><strong>附加组（supplementary group）</strong>：In addition to the group ID specified in the password file for a login name, most versions of the UNIX System allow a user to belong to other groups. This practice started with 4.2BSD, which allowed a user to belong to up to 16 additional groups. These supplementary group IDs are obtained at login time by reading the file /etc/group and finding the first 16 entries that list the user as a member. As we shall see in the next chapter, POSIX requires that a system support at least 8 supplementary groups per process, but most systems support at least 16.  许多unix系统允许用户属于多个组，最多16个。主组，也就是登陆时的默认组记录在<code>/etc/passwd</code>中。</p>\n<p><code>/etc/group</code>格式如下：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_analyticsusers:*:250:_analyticsd,_networkd,_timed</span><br><span class=\"line\">_analyticsd:*:263:_analyticsd</span><br></pre></td></tr></table></figure>\n<p>解释：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">组名:口令:组ID:组内用户列表</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-9-Signal\"><a href=\"#1-9-Signal\" class=\"headerlink\" title=\"1.9    Signal\"></a>1.9    Signal</h2><p>Signals are a technique used to notify a process that some condition has occurred. For example, if a process divides by zero, the signal whose name is SIGFPE (floating-point exception) is sent to the process. The process has three choices for dealing with the signal.  信号是一种用来通知进程发生了某些事的技术。举个例子：当进程除以0时，就会有一个SIGFPE (floating-point exception)发送到这个进程。进程处理信号有三种选择：</p>\n<ol>\n<li>Ignore the signal. This option isn’t recommended for signals that denote a hardware exception, such as dividing by zero or referencing memory outside the address space of the process, as the results are undefined.  忽视信号。如果是硬件异常不推荐这个选择，例如：被0除，引用进程外的内存，因为这些结果都是不确定的。</li>\n<li>Let the default action occur. For a divide-by-zero condition, the default is to terminate the process.  让默认动作出现，比如被0除的情况下，默认是终止该进程。</li>\n<li>Provide a function that is called when the signal occurs (this is called ‘‘catching’’ the signal). By providing a function of our own, we’ll know when the signal occurs and we can handle it as we wish.  我们自己提供一个函数捕获信号，这样我们就能让程序以我们的意愿处理异常。</li>\n</ol>\n<p>Many conditions generate signals. Two terminal keys, called the <strong>interrupt key</strong>— often the <strong>DELETE</strong> key or <strong>Control-C</strong>—and the <strong>quit key</strong>—often <strong>Control-backslash</strong>—are used to interrupt the currently running process. Another way to generate a signal is by calling the <code>kill</code> function. <strong>We can call this function from a process to send a signal to another process. Naturally, there are limitations: we have to be the owner of the other process (or the superuser) to be able to send it a signal</strong>.    很多条件下可以生成信号，终端键有两种，interrupt key（delete键或者ctrl+c）和 quit key（ctrl+\\）。另一个生成信号的方法是调用<code>kill</code>函数，我们可以在一个进程里调用kill函数来结束另一个线程，但我们需要有权限（如果我们是另一个进程的拥有者，或者是超级用户，就可以）。</p>\n<h3 id=\"Example-7\"><a href=\"#Example-7\" class=\"headerlink\" title=\"Example\"></a>Example</h3><p>Recall the bare-bones shell example (Figure 1.7). If we invoke this program and press the interrupt key, the process terminates because the default action for this signal, named SIGINT, is to terminate the process. The process hasn’t told the kernel to do anything other than the default with this signal, so the process terminates.  如果直接执行Figure 1.7的代码，我们按下中断键，程序就会终止，因为这个SIGINT信号的默认动作就是终止进程。</p>\n<p>To catch this signal, the program needs to call the signal function, specifying the name of the function to call when the SIGINT signal is generated. The function is named sig_int; when it’s called, it just prints a message and a new prompt. Adding 11 lines to the program in Figure 1.7 gives us the version in Figure 1.10. (The 11 new lines are indicated with a plus sign at the beginning of the line.)  为了捕获这个信号，程序需要调用一个信号函数。我们给它命名为：<code>sig_int</code>函数，在捕获到<strong>SIGINT</strong>信号之后，打印信息并打印一个新的提示符。下面的程序相比Figure 1.7多了11行，用<code>+</code>号标识了。</p>\n<blockquote>\n<p>Figure 1.10 Read commands from standard input and execute them </p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"include/apue.h\"</span></span></span><br><span class=\"line\">  <span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/wait.h&gt;</span></span></span><br><span class=\"line\">  </span><br><span class=\"line\">+ <span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sig_int</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span></span>;\t<span class=\"comment\">/* our signal-catching function */</span></span><br><span class=\"line\">+</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\">  </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">char</span>    buf[MAXLINE];   <span class=\"comment\">/* from apue.h */</span></span><br><span class=\"line\">      <span class=\"keyword\">pid_t</span>   pid;</span><br><span class=\"line\">      <span class=\"keyword\">int</span>     status;</span><br><span class=\"line\">  </span><br><span class=\"line\">  +\t  <span class=\"keyword\">if</span>(signal(SIGINT, sig_int) == SIG_ERR)</span><br><span class=\"line\">          err_sys(<span class=\"string\">\"signal error\"</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">      <span class=\"built_in\">printf</span>(<span class=\"string\">\"%% \"</span>);  <span class=\"comment\">/* print prompt (printf requires %% to print %) */</span></span><br><span class=\"line\">      <span class=\"keyword\">while</span> (fgets(buf, MAXLINE, <span class=\"built_in\">stdin</span>) != <span class=\"literal\">NULL</span>) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (buf[<span class=\"built_in\">strlen</span>(buf) - <span class=\"number\">1</span>] == <span class=\"string\">'\\n'</span>)</span><br><span class=\"line\">              buf[<span class=\"built_in\">strlen</span>(buf) - <span class=\"number\">1</span>] = <span class=\"number\">0</span>; <span class=\"comment\">/* replace newline with null */</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> ((pid = fork()) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">              err_sys(<span class=\"string\">\"fork error\"</span>);</span><br><span class=\"line\">          &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (pid == <span class=\"number\">0</span>) &#123;      <span class=\"comment\">/* child */</span></span><br><span class=\"line\">              execlp(buf, buf, (<span class=\"keyword\">char</span> *)<span class=\"number\">0</span>);</span><br><span class=\"line\">              err_ret(<span class=\"string\">\"couldn’t execute: %s\"</span>, buf);</span><br><span class=\"line\">              <span class=\"built_in\">exit</span>(<span class=\"number\">127</span>);</span><br><span class=\"line\">truetrue  &#125;</span><br><span class=\"line\">          <span class=\"comment\">/* parent */</span></span><br><span class=\"line\">          <span class=\"keyword\">if</span> ((pid = waitpid(pid, &amp;status, <span class=\"number\">0</span>)) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">              err_sys(<span class=\"string\">\"waitpid error\"</span>);</span><br><span class=\"line\">          <span class=\"built_in\">printf</span>(<span class=\"string\">\"%% \"</span>);</span><br><span class=\"line\">true  &#125;</span><br><span class=\"line\">true  <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>); </span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">+</span><br><span class=\"line\">+ <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sig_int</span><span class=\"params\">(<span class=\"keyword\">int</span> signo)</span></span>&#123;</span><br><span class=\"line\">+     <span class=\"built_in\">printf</span>(<span class=\"string\">\"interrupt\\n%% \"</span>);</span><br><span class=\"line\">+ &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"1-10-Time-Values\"><a href=\"#1-10-Time-Values\" class=\"headerlink\" title=\"1.10    Time Values\"></a>1.10    Time Values</h2><p>Historically, UNIX systems have maintained two different time values: </p>\n<ol>\n<li><p><strong>Calendar time</strong>. This value counts the number of seconds since the <strong>Epoch: 00:00:00 January 1, 1970,Coordinated Universal Time (UTC)</strong>. (Older manuals refer to UTC as Greenwich Mean Time.) These time values are used to record the time when a file was last modified, for example. </p>\n<p>The primitive system data type <code>time_t</code> holds these time values. </p>\n</li>\n<li><p><strong>Process time</strong>. This is also called CPU time and measures the central processor resources used by a process. Process time is measured in clock ticks, which have historically been 50, 60, or 100 ticks per second. </p>\n<p>The primitive system data type <code>clock_t</code> holds these time values. (We’ll show how to obtain the number of clock ticks per second with the <code>sysconf</code> function in Section 2.5.4.) </p>\n</li>\n</ol>\n<p>有两种类型的时间：<strong>日历时间</strong>和<strong>进程时间</strong>，日历时间也就是UTC。</p>\n<p>When we measure the execution time of a process, as in Section 3.9, we’ll see that the UNIX System maintains three values for a process: </p>\n<ul>\n<li>Clock time </li>\n<li>User CPU time </li>\n<li>System CPU time </li>\n</ul>\n<p>The clock time, sometimes called <strong>wall clock time</strong>, is the amount of time the process takes to run, and its value depends on the number of other processes being run on the system. Whenever we report the clock time, the measurements are made with no other activities on the system. </p>\n<p>The user CPU time is the CPU time attributed to user instructions. The system CPU time is the CPU time attributed to the kernel when it executes on behalf of the process. For example, whenever a process executes a system service, such as read or write, the time spent within the kernel performing that system service is charged to the process. The sum of user CPU time and system CPU time is often called the CPU time. </p>\n<p>度量进程执行时间，有三种：</p>\n<ol>\n<li>墙上时钟，也就是进程执行花费的总时间。</li>\n<li>用户CPU时间，是用户模式（非内核）下的CPU使用时间</li>\n<li>系统CPU时间，是进程进入内核执行的CPU使用时间</li>\n</ol>\n<p>It is easy to measure the clock time, user time, and system time of any process: simply execute the time(1) command, with the argument to the time command being the command we want to measure. For example: </p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> cd /usr/include</span><br><span class=\"line\"><span class=\"meta\">$</span> time -p grep _POSIX_SOURCE */*.h &gt; /dev/null</span><br></pre></td></tr></table></figure>\n<p>结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">real    0m0.81s</span><br><span class=\"line\">user    0m0.11s</span><br><span class=\"line\">sys     0m0.07s</span><br></pre></td></tr></table></figure>\n<p>The output format from the time command depends on the shell being used, because some shells don’t run /usr/bin/time, but instead have a separate built-in function to measure the time it takes commands to run.  time命令的输出格式取决于使用什么shell，因为有些shell并不运行：<code>/usr/bin/time</code>，而是运行自己内置的一个time函数。</p>\n<h2 id=\"1-11-System-Calls-and-Library-Functions\"><a href=\"#1-11-System-Calls-and-Library-Functions\" class=\"headerlink\" title=\"1.11    System Calls and Library Functions\"></a>1.11    System Calls and Library Functions</h2><p>All operating systems provide service points through which programs request services from the kernel. All implementations of the UNIX System provide a well-defined, limited number of entry points directly into the kernel called system calls (recall Figure 1.1). Version 7 of the Research UNIX System provided about 50 system calls, 4.4BSD provided about 110, and SVR4 had around 120. The exact number of system calls varies depending on the operating system version. More recent systems have seen incredible growth in the number of supported system calls. Linux 3.2.0 has 380 system calls and FreeBSD 8.0 has over 450.  随着时间的推移，系统调用越来越多，可见系统是越来越完善的。</p>\n<p>The system call interface has always been documented in Section 2 of the UNIX Programmer’s Manual. Its definition is in the C language, no matter which implementation technique is actually used on any given system to invoke a system call. This differs from many older operating systems, which traditionally defined the kernel entry points in the assembly language of the machine.  <strong>系统调用的文档总是在unix编程手册的第二个章节里。它是用C语言定义的</strong>，不管系统具体是如何实现系统调用的。这一点与很多老操作系统不同（老操作系统使用汇编语言定义内核接口）</p>\n<p>The technique used on UNIX systems is for each system call to have a function of the same name in the standard C library. The user process calls this function, using the standard C calling sequence. This function then invokes the appropriate kernel service, using whatever technique is required on the system. For example, the function may put one or more of the C arguments into general registers and then execute some machine instruction that generates a software interrupt in the kernel. For our purposes, we can consider the system calls to be C functions.  每个系统调用都对应一个相同名字的函数在标准C库里。用户进程调用这个函数，然后这个函数调用相应的内核服务。举个例子，这个函数可能会把一个或多个C参数放到通用寄存器，并执行机器指令在内核中产生一个软件中断。从我们的角度看，我们可以直接认为系统调用就是C函数。</p>\n<p>Section 3 of the UNIX Programmer’s Manual defines the general-purpose library functions available to programmers. These functions aren’t entry points into the kernel, although they may invoke one or more of the kernel’s system calls. For example, the printf function may use the write system call to output a string, but the strcpy (copy a string) and atoi (convert ASCII to integer) functions don’t involve the kernel at all.  在<strong>unix编程手册第三章定义了通用库函数给程序员。这些函数不是内核入口，虽然它们可能会调用一个或几个内核的系统调用</strong>。举个例子，<code>printf</code>函数可能会使用<code>write</code>系统调用来输出一个字符串，但是<code>strcpy</code>（拷贝一个字符串）和<code>atoi</code>（吧ASCII字符转成整形）函数根本没有调用内核。</p>\n<p>From an implementor’s point of view, the distinction between a system call and a library function is fundamental. From a user’s perspective, however, the difference is not as critical. From our perspective in this text, both system calls and library functions appear as normal C functions. Both exist to provide services for application programs. We should realize, however, that we can replace the library functions, if desired, whereas the system calls usually cannot be replaced.  从实现者的角度来看，系统调用和库函数的区别是很大的。然而从使用者的角度来看，这个区别并不重要。在这本书中，在我们看来，系统调用和库函数都以C函数的形式出现。两者的存在都是为了给应用开发者提供服务。然而我们应该意识到，<strong>虽然我们能替换库函数（如果我们想这样做），但系统调用不能被替换</strong>。</p>\n<p>Consider the memory allocation function malloc as an example. There are many ways to do memory allocation and its associated garbage collection (best fit, first fit, and so on). No single technique is optimal for all programs. The UNIX system call that handles memory allocation, sbrk(2), is not a general-purpose memory manager. It increases or decreases the address space of the process by a specified number of bytes. How that space is managed is up to the process. The memory allocation function, malloc(3), implements one particular type of allocation. If we don’t like its operation, we can define our own malloc function, which will probably use the sbrk system call. In fact, numerous software packages implement their own memory allocation algorithms with the sbrk system call. Figure 1.11 shows the relationship between the application, the malloc function, and the sbrk system call.  让我们来看看内存分配函数<code>malloc</code>这个例子。有很多内存分配和相关的垃圾回收方法（最好适应算法，最先适应算法，等等）。没有哪个技术是对所有程序优化的。<strong>unix系统调用<code>sbrk(2)</code>不是一个通用的存储管理器。它给进程增加和减少内存空间都是固定的字节数。怎么管理空间其实还要取决于进程自己。内存分配函数<code>malloc(3)</code>，实现了特定类型的分配。如果我们不喜欢它的做法，我们可以定义自己的malloc函数，但也是要用到sbrk系统调用的。实际上大量的软件包都通过直接使用sbrk系统调用实现了自己的内存管理算法</strong>。图1.11展示了应用，malloc函数，和sbrk系统调用之间的关系。</p>\n<p>&lt;img src=”<a href=\"https://i.loli.net/2018/05/25/5b07647fc7597.png&quot;\" target=\"_blank\" rel=\"noopener\">https://i.loli.net/2018/05/25/5b07647fc7597.png&quot;</a>, width=”70%”&gt;</p>\n<p>Here we have a clean separation of duties: the system call in the kernel allocates an additional chunk of space on behalf of the process. The malloc library function manages this space from user level.  这里职责是分明的：系统调用代表进程在内核里分配了额外的一块空间。malloc库函数在用户层级上管理这块空间。</p>\n<p>Another example to illustrate the difference between a system call and a library function is the interface the UNIX System provides to determine the current time and date. Some operating systems provide one system call to return the time and another to return the date. Any special handling, such as the switch to or from daylight saving time, is handled by the kernel or requires human intervention. The UNIX System, in contrast, provides a single system call that returns the number of seconds since the Epoch: midnight, January 1, 1970, Coordinated Universal Time. Any interpretation of this value, such as converting it to a human-readable time and date using the local time zone, is left to the user process. The standard C library provides routines to handle most cases. These library routines handle such details as the various algorithms for daylight saving time.  另一个描述系统调用和库函数不同的例子是当前时间和日期。某些操作系统提供一个系统调用返回时间，另一个系统调用返回日期。任何特殊的处理，比如正常时制与夏令时的切换，需要内核的处理或者认为干预。Unix系统则相反，只提供一个系统调用，返回UTC（UTC是指从1970年的第一秒开始算起到现在经过的总时间）。任何对UTC这个值的解释，例如把它转成人类可读的时间日期使用当地时间，就留给了用户进程。标准C库提供了诸多例程来处理大多数情况。这些库例程处理这些细节，就像大多数算法处理夏令时切换一样。</p>\n<p>An application can either make a system call or call a library routine. Also realize that many library routines invoke a system call. This is shown in Figure 1.12.  一个应用可以使用系统调用或者调用库例程，同样要意识到许多库例程调用了系统调用。</p>\n<p>Another difference between system calls and library functions is that system calls usually <strong>provide a minimal interface</strong>, whereas library functions often <strong>provide more elaborate functionality</strong>. We’ve seen this already in the difference between the sbrk system call and the malloc library function. We’ll see this difference again later, when we compare the unbuffered I/O functions (Chapter 3) and the standard I/O functions (Chapter 5).  另一个系统调用和库函数的区别就是，系统调用往往只提供一个很小的接口，然而库函数经常提供更多精细的功能。</p>\n<p><img src=\"https://i.loli.net/2018/05/25/5b07d2d3861c0.png\" width=\"70%\"></p>\n<p>The process control system calls (<strong>fork, exec, and waitpid</strong>) are usually invoked by the user’s application code directly. (Recall the bare-bones shell in Figure 1.7.) But some library routines exist to simplify certain common cases: the <strong>system</strong> and <strong>popen</strong> library routines, for example. In Section 8.13, we’ll show an implementation of the system function that invokes the basic process control system calls. We’ll enhance this example in Section 10.18 to handle signals correctly. </p>\n<p>To define the interface to the UNIX System that most programmers use, we have to describe both the system calls and some of the library functions. If we described only the sbrk system call, for example, we would skip the more programmer-friendly malloc library function that many applications use. <strong>In this text, we’ll use the term function to refer to both system calls and library functions, except when the distinction is necessary.</strong> </p>\n"},{"title":"SQL必知必会","date":"2018-06-02T16:00:00.000Z","comments":1,"_content":"\n## 学数据库预备条件\n\n首先你得 **有个数据库来作为实践操作的对象**，最好是学数据库之前能熟练使用爬虫爬取大量数据，然后将这些数据作为学习数据库的材料。\n\n当然没有数据库也不是大问题，那你还是得随时手动准备一些数据。总之：**学数据库是需要靠动手实践的**。\n\n## 学习途径\n\n### 基本的SQL语法\n\n[w3school](http://www.w3school.com.cn/sql/sql_syntax.asp)\n\n外加随手google\n\n## 概念大纲\n\n- SQL，Structured Query Language，结构化查询语言，语法上大小写不敏感，语句以分号结尾，单条语句可不加分号。\n- ANSI，American National Standard Instruction，美国国家标准化组织，SQL已经被ANSI标准化，虽然不同的数据库有一些自己的特性，但差异较小，我们先学好ANSI SQL即可。\n- RDBMS，Relational Database Management System，关系型数据库管理系统，RDBMS是SQL的基础，RDBMS中的数据存储在表中，表由列和行组成。\n- SQL可以分为两部分：DML，Data Manipulation Language，数据操作语言；DDL，Data Definition Language，数据定义语言。查询和更新构成了SQL的DML部分：`SELECT`, `UPDATE`, `DELETE`, `INSERT INTO`。SQL的DDL部分使我们有能力创建或删除表格，我们也可以定义 **索引（键）**，规定表之间的链接，以及施加表之间的约束：`CREATE DATABASE`, `ALTER DATABASE`, `CREATE TABLE`, `ALTER TABLE`, `DROP TABLE`, `CREATE INDEX`, `DROP INDEX`。\n\n## 语法\n\n### SELECT（查询）\n\nSELECT 选出的结果存储在结果表中，可对结果表继续进行查询，大多数数据库系统允许使用编程函数在结果集进行导航，比如：Move-To-First-Record、Get-Record-Content、Move-To-Next-Record 等等。\n\n#### DISTINCT（唯一）\n\n`SELECT DISTINCT`去除重复结果\n\n### WHERE（条件）\n\n```sql\nSELECT 列名称 FROM 表名称 WHERE 列 运算符 值\n```\n\n| 操作符  | 描述         |\n| ------- | ------------ |\n| =       | 等于         |\n| <>      | 不等于       |\n| <       | 小于         |\n| >       | 大于         |\n| <=      | 小于等于     |\n| >=      | 大于等于     |\n| BETWEEN | 在某个范围内 |\n| LIKE    | 搜索某种模式 |\n\nSQL 使用单引号来环绕 **文本值**（大部分数据库系统也接受双引号）。如果是 **数值**，请不要使用引号。\n\n#### AND & OR\n\n```sql\nSELECT * FROM Persons WHERE (FirstName='Thomas' OR FirstName='William')\nAND LastName='Carter'\n```\n\n### ORDER BY\n\nORDER BY 语句默认按照升序对记录进行排序。\n\n如果您希望按照降序对记录进行排序，可以使用 DESC 关键字。\n\n```sql\nSELECT Company, OrderNumber FROM Orders ORDER BY Company DESC\n```\n\n可以按多个列来排序，也就是在第一列的基础上，在依照第二列继续排序。\n\n```sql\nSELECT Company, OrderNumber FROM Orders ORDER BY Company, OrderNumber\n```\n\n```sql\nSELECT Company, OrderNumber FROM Orders ORDER BY Company DESC, OrderNumber ASC\n```\n\n### INSERT INTO\n\n```sql\nINSERT INTO table_name (列1, 列2,...) VALUES (值1, 值2,....)\n```\n\n### UPDATE\n\n```sql\nUPDATE Person SET Address = 'Zhongshan 23', City = 'Nanjing'\nWHERE LastName = 'Wilson'\n```\n\n### DELETE\n\n**DELETE 语句用于删除表中的行**。\n\n```sql\nDELETE FROM Person WHERE LastName = 'Wilson' \n```\n\n可以删除所有行：\n\n```sql\nDELETE FROM table_name\n```\n\n或者：\n\n```\nDELETE * FROM table_name\n```\n\n这样可以清空数据，与此同时保留了表的结构。\n\n### TOP\n\n对于拥有数千条记录的大型表来说，TOP子句是非常有用的，它用于规定返回记录的数目（不超过限定的数）。\n\n> 但并非所有数据库管理系统都支持TOP子句\n\n```sql\nSELECT TOP number|percent column_name(s)\nFROM table_name\n```\n\n```sql\nSELECT TOP 2 * FROM Persons\n```\n\n```sql\nSELECT TOP 50 PERCENT * FROM Persons\n```\n\n#### MYSQL\n\n```sql\nSELECT column_name(s)\nFROM table_name\nLIMIT number\n```\n\n#### ORACLE\n\n```sql\nSELECT column_name(s)\nFROM table_name\nWHERE ROWNUM <= number\n```\n\n### LIKE\n\nLIKE 操作符用于在 WHERE 子句中搜索列中的指定模式。\"%\" 可用于定义通配符（模式中缺少的字母）。\n\n> 不区分大小写\n\n```sql\nSELECT * FROM Persons\nWHERE City LIKE '%lon%'\n```\n\n| Id   | LastName | FirstName | Address       | City   |\n| ---- | -------- | --------- | ------------- | ------ |\n| 1    | Adams    | John      | Oxford Street | London |\n\n### 通配符\n\n| 通配符                     | 描述                       |\n| -------------------------- | -------------------------- |\n| %                          | 替代一个或多个字符         |\n| _                          | 仅替代一个字符             |\n| [charlist]                 | 字符列中的任意一个字符     |\n| [^charlist] 或 [!charlist] | 不在字符列中的任何单一字符 |\n\n```sql\nSELECT * FROM Persons\nWHERE LastName LIKE 'C_r_er'\n```\n\n```sql\nSELECT * FROM Persons\nWHERE City LIKE '[!ALN]%'\n```\n\n### IN\n\n```sql\nSELECT column_name(s)\nFROM table_name\nWHERE column_name IN (value1,value2,...)\n```\n\n","source":"_posts/2018/2018-06-03-SQL必知必会.md","raw":"---\ntitle: SQL必知必会\ndate: 2018-06-03\ncategories: [SQL]\ncomments: true\n---\n\n## 学数据库预备条件\n\n首先你得 **有个数据库来作为实践操作的对象**，最好是学数据库之前能熟练使用爬虫爬取大量数据，然后将这些数据作为学习数据库的材料。\n\n当然没有数据库也不是大问题，那你还是得随时手动准备一些数据。总之：**学数据库是需要靠动手实践的**。\n\n## 学习途径\n\n### 基本的SQL语法\n\n[w3school](http://www.w3school.com.cn/sql/sql_syntax.asp)\n\n外加随手google\n\n## 概念大纲\n\n- SQL，Structured Query Language，结构化查询语言，语法上大小写不敏感，语句以分号结尾，单条语句可不加分号。\n- ANSI，American National Standard Instruction，美国国家标准化组织，SQL已经被ANSI标准化，虽然不同的数据库有一些自己的特性，但差异较小，我们先学好ANSI SQL即可。\n- RDBMS，Relational Database Management System，关系型数据库管理系统，RDBMS是SQL的基础，RDBMS中的数据存储在表中，表由列和行组成。\n- SQL可以分为两部分：DML，Data Manipulation Language，数据操作语言；DDL，Data Definition Language，数据定义语言。查询和更新构成了SQL的DML部分：`SELECT`, `UPDATE`, `DELETE`, `INSERT INTO`。SQL的DDL部分使我们有能力创建或删除表格，我们也可以定义 **索引（键）**，规定表之间的链接，以及施加表之间的约束：`CREATE DATABASE`, `ALTER DATABASE`, `CREATE TABLE`, `ALTER TABLE`, `DROP TABLE`, `CREATE INDEX`, `DROP INDEX`。\n\n## 语法\n\n### SELECT（查询）\n\nSELECT 选出的结果存储在结果表中，可对结果表继续进行查询，大多数数据库系统允许使用编程函数在结果集进行导航，比如：Move-To-First-Record、Get-Record-Content、Move-To-Next-Record 等等。\n\n#### DISTINCT（唯一）\n\n`SELECT DISTINCT`去除重复结果\n\n### WHERE（条件）\n\n```sql\nSELECT 列名称 FROM 表名称 WHERE 列 运算符 值\n```\n\n| 操作符  | 描述         |\n| ------- | ------------ |\n| =       | 等于         |\n| <>      | 不等于       |\n| <       | 小于         |\n| >       | 大于         |\n| <=      | 小于等于     |\n| >=      | 大于等于     |\n| BETWEEN | 在某个范围内 |\n| LIKE    | 搜索某种模式 |\n\nSQL 使用单引号来环绕 **文本值**（大部分数据库系统也接受双引号）。如果是 **数值**，请不要使用引号。\n\n#### AND & OR\n\n```sql\nSELECT * FROM Persons WHERE (FirstName='Thomas' OR FirstName='William')\nAND LastName='Carter'\n```\n\n### ORDER BY\n\nORDER BY 语句默认按照升序对记录进行排序。\n\n如果您希望按照降序对记录进行排序，可以使用 DESC 关键字。\n\n```sql\nSELECT Company, OrderNumber FROM Orders ORDER BY Company DESC\n```\n\n可以按多个列来排序，也就是在第一列的基础上，在依照第二列继续排序。\n\n```sql\nSELECT Company, OrderNumber FROM Orders ORDER BY Company, OrderNumber\n```\n\n```sql\nSELECT Company, OrderNumber FROM Orders ORDER BY Company DESC, OrderNumber ASC\n```\n\n### INSERT INTO\n\n```sql\nINSERT INTO table_name (列1, 列2,...) VALUES (值1, 值2,....)\n```\n\n### UPDATE\n\n```sql\nUPDATE Person SET Address = 'Zhongshan 23', City = 'Nanjing'\nWHERE LastName = 'Wilson'\n```\n\n### DELETE\n\n**DELETE 语句用于删除表中的行**。\n\n```sql\nDELETE FROM Person WHERE LastName = 'Wilson' \n```\n\n可以删除所有行：\n\n```sql\nDELETE FROM table_name\n```\n\n或者：\n\n```\nDELETE * FROM table_name\n```\n\n这样可以清空数据，与此同时保留了表的结构。\n\n### TOP\n\n对于拥有数千条记录的大型表来说，TOP子句是非常有用的，它用于规定返回记录的数目（不超过限定的数）。\n\n> 但并非所有数据库管理系统都支持TOP子句\n\n```sql\nSELECT TOP number|percent column_name(s)\nFROM table_name\n```\n\n```sql\nSELECT TOP 2 * FROM Persons\n```\n\n```sql\nSELECT TOP 50 PERCENT * FROM Persons\n```\n\n#### MYSQL\n\n```sql\nSELECT column_name(s)\nFROM table_name\nLIMIT number\n```\n\n#### ORACLE\n\n```sql\nSELECT column_name(s)\nFROM table_name\nWHERE ROWNUM <= number\n```\n\n### LIKE\n\nLIKE 操作符用于在 WHERE 子句中搜索列中的指定模式。\"%\" 可用于定义通配符（模式中缺少的字母）。\n\n> 不区分大小写\n\n```sql\nSELECT * FROM Persons\nWHERE City LIKE '%lon%'\n```\n\n| Id   | LastName | FirstName | Address       | City   |\n| ---- | -------- | --------- | ------------- | ------ |\n| 1    | Adams    | John      | Oxford Street | London |\n\n### 通配符\n\n| 通配符                     | 描述                       |\n| -------------------------- | -------------------------- |\n| %                          | 替代一个或多个字符         |\n| _                          | 仅替代一个字符             |\n| [charlist]                 | 字符列中的任意一个字符     |\n| [^charlist] 或 [!charlist] | 不在字符列中的任何单一字符 |\n\n```sql\nSELECT * FROM Persons\nWHERE LastName LIKE 'C_r_er'\n```\n\n```sql\nSELECT * FROM Persons\nWHERE City LIKE '[!ALN]%'\n```\n\n### IN\n\n```sql\nSELECT column_name(s)\nFROM table_name\nWHERE column_name IN (value1,value2,...)\n```\n\n","slug":"SQL必知必会","published":1,"updated":"2018-06-18T08:12:29.007Z","layout":"post","photos":[],"link":"","_id":"cjm2w8ddv003cfgpxrdda174h","content":"<h2 id=\"学数据库预备条件\"><a href=\"#学数据库预备条件\" class=\"headerlink\" title=\"学数据库预备条件\"></a>学数据库预备条件</h2><p>首先你得 <strong>有个数据库来作为实践操作的对象</strong>，最好是学数据库之前能熟练使用爬虫爬取大量数据，然后将这些数据作为学习数据库的材料。</p>\n<p>当然没有数据库也不是大问题，那你还是得随时手动准备一些数据。总之：<strong>学数据库是需要靠动手实践的</strong>。</p>\n<h2 id=\"学习途径\"><a href=\"#学习途径\" class=\"headerlink\" title=\"学习途径\"></a>学习途径</h2><h3 id=\"基本的SQL语法\"><a href=\"#基本的SQL语法\" class=\"headerlink\" title=\"基本的SQL语法\"></a>基本的SQL语法</h3><p><a href=\"http://www.w3school.com.cn/sql/sql_syntax.asp\" target=\"_blank\" rel=\"noopener\">w3school</a></p>\n<p>外加随手google</p>\n<h2 id=\"概念大纲\"><a href=\"#概念大纲\" class=\"headerlink\" title=\"概念大纲\"></a>概念大纲</h2><ul>\n<li>SQL，Structured Query Language，结构化查询语言，语法上大小写不敏感，语句以分号结尾，单条语句可不加分号。</li>\n<li>ANSI，American National Standard Instruction，美国国家标准化组织，SQL已经被ANSI标准化，虽然不同的数据库有一些自己的特性，但差异较小，我们先学好ANSI SQL即可。</li>\n<li>RDBMS，Relational Database Management System，关系型数据库管理系统，RDBMS是SQL的基础，RDBMS中的数据存储在表中，表由列和行组成。</li>\n<li>SQL可以分为两部分：DML，Data Manipulation Language，数据操作语言；DDL，Data Definition Language，数据定义语言。查询和更新构成了SQL的DML部分：<code>SELECT</code>, <code>UPDATE</code>, <code>DELETE</code>, <code>INSERT INTO</code>。SQL的DDL部分使我们有能力创建或删除表格，我们也可以定义 <strong>索引（键）</strong>，规定表之间的链接，以及施加表之间的约束：<code>CREATE DATABASE</code>, <code>ALTER DATABASE</code>, <code>CREATE TABLE</code>, <code>ALTER TABLE</code>, <code>DROP TABLE</code>, <code>CREATE INDEX</code>, <code>DROP INDEX</code>。</li>\n</ul>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><h3 id=\"SELECT（查询）\"><a href=\"#SELECT（查询）\" class=\"headerlink\" title=\"SELECT（查询）\"></a>SELECT（查询）</h3><p>SELECT 选出的结果存储在结果表中，可对结果表继续进行查询，大多数数据库系统允许使用编程函数在结果集进行导航，比如：Move-To-First-Record、Get-Record-Content、Move-To-Next-Record 等等。</p>\n<h4 id=\"DISTINCT（唯一）\"><a href=\"#DISTINCT（唯一）\" class=\"headerlink\" title=\"DISTINCT（唯一）\"></a>DISTINCT（唯一）</h4><p><code>SELECT DISTINCT</code>去除重复结果</p>\n<h3 id=\"WHERE（条件）\"><a href=\"#WHERE（条件）\" class=\"headerlink\" title=\"WHERE（条件）\"></a>WHERE（条件）</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> 列名称 <span class=\"keyword\">FROM</span> 表名称 <span class=\"keyword\">WHERE</span> 列 运算符 值</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>操作符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>=</td>\n<td>等于</td>\n</tr>\n<tr>\n<td>&lt;&gt;</td>\n<td>不等于</td>\n</tr>\n<tr>\n<td>&lt;</td>\n<td>小于</td>\n</tr>\n<tr>\n<td>&gt;</td>\n<td>大于</td>\n</tr>\n<tr>\n<td>&lt;=</td>\n<td>小于等于</td>\n</tr>\n<tr>\n<td>&gt;=</td>\n<td>大于等于</td>\n</tr>\n<tr>\n<td>BETWEEN</td>\n<td>在某个范围内</td>\n</tr>\n<tr>\n<td>LIKE</td>\n<td>搜索某种模式</td>\n</tr>\n</tbody>\n</table>\n<p>SQL 使用单引号来环绕 <strong>文本值</strong>（大部分数据库系统也接受双引号）。如果是 <strong>数值</strong>，请不要使用引号。</p>\n<h4 id=\"AND-amp-OR\"><a href=\"#AND-amp-OR\" class=\"headerlink\" title=\"AND &amp; OR\"></a>AND &amp; OR</h4><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> Persons <span class=\"keyword\">WHERE</span> (FirstName=<span class=\"string\">'Thomas'</span> <span class=\"keyword\">OR</span> FirstName=<span class=\"string\">'William'</span>)</span><br><span class=\"line\"><span class=\"keyword\">AND</span> LastName=<span class=\"string\">'Carter'</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"ORDER-BY\"><a href=\"#ORDER-BY\" class=\"headerlink\" title=\"ORDER BY\"></a>ORDER BY</h3><p>ORDER BY 语句默认按照升序对记录进行排序。</p>\n<p>如果您希望按照降序对记录进行排序，可以使用 DESC 关键字。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> Company, OrderNumber <span class=\"keyword\">FROM</span> Orders <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> Company <span class=\"keyword\">DESC</span></span><br></pre></td></tr></table></figure>\n<p>可以按多个列来排序，也就是在第一列的基础上，在依照第二列继续排序。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> Company, OrderNumber <span class=\"keyword\">FROM</span> Orders <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> Company, OrderNumber</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> Company, OrderNumber <span class=\"keyword\">FROM</span> Orders <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> Company <span class=\"keyword\">DESC</span>, OrderNumber <span class=\"keyword\">ASC</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"INSERT-INTO\"><a href=\"#INSERT-INTO\" class=\"headerlink\" title=\"INSERT INTO\"></a>INSERT INTO</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> table_name (列<span class=\"number\">1</span>, 列<span class=\"number\">2</span>,...) <span class=\"keyword\">VALUES</span> (值<span class=\"number\">1</span>, 值<span class=\"number\">2</span>,....)</span><br></pre></td></tr></table></figure>\n<h3 id=\"UPDATE\"><a href=\"#UPDATE\" class=\"headerlink\" title=\"UPDATE\"></a>UPDATE</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">UPDATE</span> Person <span class=\"keyword\">SET</span> Address = <span class=\"string\">'Zhongshan 23'</span>, City = <span class=\"string\">'Nanjing'</span></span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> LastName = <span class=\"string\">'Wilson'</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"DELETE\"><a href=\"#DELETE\" class=\"headerlink\" title=\"DELETE\"></a>DELETE</h3><p><strong>DELETE 语句用于删除表中的行</strong>。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DELETE</span> <span class=\"keyword\">FROM</span> Person <span class=\"keyword\">WHERE</span> LastName = <span class=\"string\">'Wilson'</span></span><br></pre></td></tr></table></figure>\n<p>可以删除所有行：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DELETE</span> <span class=\"keyword\">FROM</span> table_name</span><br></pre></td></tr></table></figure>\n<p>或者：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DELETE * FROM table_name</span><br></pre></td></tr></table></figure>\n<p>这样可以清空数据，与此同时保留了表的结构。</p>\n<h3 id=\"TOP\"><a href=\"#TOP\" class=\"headerlink\" title=\"TOP\"></a>TOP</h3><p>对于拥有数千条记录的大型表来说，TOP子句是非常有用的，它用于规定返回记录的数目（不超过限定的数）。</p>\n<blockquote>\n<p>但并非所有数据库管理系统都支持TOP子句</p>\n</blockquote>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> TOP <span class=\"built_in\">number</span>|<span class=\"keyword\">percent</span> column_name(s)</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> table_name</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> TOP <span class=\"number\">2</span> * <span class=\"keyword\">FROM</span> Persons</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> TOP <span class=\"number\">50</span> <span class=\"keyword\">PERCENT</span> * <span class=\"keyword\">FROM</span> Persons</span><br></pre></td></tr></table></figure>\n<h4 id=\"MYSQL\"><a href=\"#MYSQL\" class=\"headerlink\" title=\"MYSQL\"></a>MYSQL</h4><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> column_name(s)</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> table_name</span><br><span class=\"line\"><span class=\"keyword\">LIMIT</span> <span class=\"built_in\">number</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"ORACLE\"><a href=\"#ORACLE\" class=\"headerlink\" title=\"ORACLE\"></a>ORACLE</h4><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> column_name(s)</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> table_name</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> <span class=\"keyword\">ROWNUM</span> &lt;= <span class=\"built_in\">number</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"LIKE\"><a href=\"#LIKE\" class=\"headerlink\" title=\"LIKE\"></a>LIKE</h3><p>LIKE 操作符用于在 WHERE 子句中搜索列中的指定模式。”%” 可用于定义通配符（模式中缺少的字母）。</p>\n<blockquote>\n<p>不区分大小写</p>\n</blockquote>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> Persons</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> City <span class=\"keyword\">LIKE</span> <span class=\"string\">'%lon%'</span></span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>Id</th>\n<th>LastName</th>\n<th>FirstName</th>\n<th>Address</th>\n<th>City</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>Adams</td>\n<td>John</td>\n<td>Oxford Street</td>\n<td>London</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"通配符\"><a href=\"#通配符\" class=\"headerlink\" title=\"通配符\"></a>通配符</h3><table>\n<thead>\n<tr>\n<th>通配符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>%</td>\n<td>替代一个或多个字符</td>\n</tr>\n<tr>\n<td>_</td>\n<td>仅替代一个字符</td>\n</tr>\n<tr>\n<td>[charlist]</td>\n<td>字符列中的任意一个字符</td>\n</tr>\n<tr>\n<td>[^charlist] 或 [!charlist]</td>\n<td>不在字符列中的任何单一字符</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> Persons</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> LastName <span class=\"keyword\">LIKE</span> <span class=\"string\">'C_r_er'</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> Persons</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> City <span class=\"keyword\">LIKE</span> <span class=\"string\">'[!ALN]%'</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"IN\"><a href=\"#IN\" class=\"headerlink\" title=\"IN\"></a>IN</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> column_name(s)</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> table_name</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> column_name <span class=\"keyword\">IN</span> (value1,value2,...)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"学数据库预备条件\"><a href=\"#学数据库预备条件\" class=\"headerlink\" title=\"学数据库预备条件\"></a>学数据库预备条件</h2><p>首先你得 <strong>有个数据库来作为实践操作的对象</strong>，最好是学数据库之前能熟练使用爬虫爬取大量数据，然后将这些数据作为学习数据库的材料。</p>\n<p>当然没有数据库也不是大问题，那你还是得随时手动准备一些数据。总之：<strong>学数据库是需要靠动手实践的</strong>。</p>\n<h2 id=\"学习途径\"><a href=\"#学习途径\" class=\"headerlink\" title=\"学习途径\"></a>学习途径</h2><h3 id=\"基本的SQL语法\"><a href=\"#基本的SQL语法\" class=\"headerlink\" title=\"基本的SQL语法\"></a>基本的SQL语法</h3><p><a href=\"http://www.w3school.com.cn/sql/sql_syntax.asp\" target=\"_blank\" rel=\"noopener\">w3school</a></p>\n<p>外加随手google</p>\n<h2 id=\"概念大纲\"><a href=\"#概念大纲\" class=\"headerlink\" title=\"概念大纲\"></a>概念大纲</h2><ul>\n<li>SQL，Structured Query Language，结构化查询语言，语法上大小写不敏感，语句以分号结尾，单条语句可不加分号。</li>\n<li>ANSI，American National Standard Instruction，美国国家标准化组织，SQL已经被ANSI标准化，虽然不同的数据库有一些自己的特性，但差异较小，我们先学好ANSI SQL即可。</li>\n<li>RDBMS，Relational Database Management System，关系型数据库管理系统，RDBMS是SQL的基础，RDBMS中的数据存储在表中，表由列和行组成。</li>\n<li>SQL可以分为两部分：DML，Data Manipulation Language，数据操作语言；DDL，Data Definition Language，数据定义语言。查询和更新构成了SQL的DML部分：<code>SELECT</code>, <code>UPDATE</code>, <code>DELETE</code>, <code>INSERT INTO</code>。SQL的DDL部分使我们有能力创建或删除表格，我们也可以定义 <strong>索引（键）</strong>，规定表之间的链接，以及施加表之间的约束：<code>CREATE DATABASE</code>, <code>ALTER DATABASE</code>, <code>CREATE TABLE</code>, <code>ALTER TABLE</code>, <code>DROP TABLE</code>, <code>CREATE INDEX</code>, <code>DROP INDEX</code>。</li>\n</ul>\n<h2 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h2><h3 id=\"SELECT（查询）\"><a href=\"#SELECT（查询）\" class=\"headerlink\" title=\"SELECT（查询）\"></a>SELECT（查询）</h3><p>SELECT 选出的结果存储在结果表中，可对结果表继续进行查询，大多数数据库系统允许使用编程函数在结果集进行导航，比如：Move-To-First-Record、Get-Record-Content、Move-To-Next-Record 等等。</p>\n<h4 id=\"DISTINCT（唯一）\"><a href=\"#DISTINCT（唯一）\" class=\"headerlink\" title=\"DISTINCT（唯一）\"></a>DISTINCT（唯一）</h4><p><code>SELECT DISTINCT</code>去除重复结果</p>\n<h3 id=\"WHERE（条件）\"><a href=\"#WHERE（条件）\" class=\"headerlink\" title=\"WHERE（条件）\"></a>WHERE（条件）</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> 列名称 <span class=\"keyword\">FROM</span> 表名称 <span class=\"keyword\">WHERE</span> 列 运算符 值</span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>操作符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>=</td>\n<td>等于</td>\n</tr>\n<tr>\n<td>&lt;&gt;</td>\n<td>不等于</td>\n</tr>\n<tr>\n<td>&lt;</td>\n<td>小于</td>\n</tr>\n<tr>\n<td>&gt;</td>\n<td>大于</td>\n</tr>\n<tr>\n<td>&lt;=</td>\n<td>小于等于</td>\n</tr>\n<tr>\n<td>&gt;=</td>\n<td>大于等于</td>\n</tr>\n<tr>\n<td>BETWEEN</td>\n<td>在某个范围内</td>\n</tr>\n<tr>\n<td>LIKE</td>\n<td>搜索某种模式</td>\n</tr>\n</tbody>\n</table>\n<p>SQL 使用单引号来环绕 <strong>文本值</strong>（大部分数据库系统也接受双引号）。如果是 <strong>数值</strong>，请不要使用引号。</p>\n<h4 id=\"AND-amp-OR\"><a href=\"#AND-amp-OR\" class=\"headerlink\" title=\"AND &amp; OR\"></a>AND &amp; OR</h4><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> Persons <span class=\"keyword\">WHERE</span> (FirstName=<span class=\"string\">'Thomas'</span> <span class=\"keyword\">OR</span> FirstName=<span class=\"string\">'William'</span>)</span><br><span class=\"line\"><span class=\"keyword\">AND</span> LastName=<span class=\"string\">'Carter'</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"ORDER-BY\"><a href=\"#ORDER-BY\" class=\"headerlink\" title=\"ORDER BY\"></a>ORDER BY</h3><p>ORDER BY 语句默认按照升序对记录进行排序。</p>\n<p>如果您希望按照降序对记录进行排序，可以使用 DESC 关键字。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> Company, OrderNumber <span class=\"keyword\">FROM</span> Orders <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> Company <span class=\"keyword\">DESC</span></span><br></pre></td></tr></table></figure>\n<p>可以按多个列来排序，也就是在第一列的基础上，在依照第二列继续排序。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> Company, OrderNumber <span class=\"keyword\">FROM</span> Orders <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> Company, OrderNumber</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> Company, OrderNumber <span class=\"keyword\">FROM</span> Orders <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> Company <span class=\"keyword\">DESC</span>, OrderNumber <span class=\"keyword\">ASC</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"INSERT-INTO\"><a href=\"#INSERT-INTO\" class=\"headerlink\" title=\"INSERT INTO\"></a>INSERT INTO</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> table_name (列<span class=\"number\">1</span>, 列<span class=\"number\">2</span>,...) <span class=\"keyword\">VALUES</span> (值<span class=\"number\">1</span>, 值<span class=\"number\">2</span>,....)</span><br></pre></td></tr></table></figure>\n<h3 id=\"UPDATE\"><a href=\"#UPDATE\" class=\"headerlink\" title=\"UPDATE\"></a>UPDATE</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">UPDATE</span> Person <span class=\"keyword\">SET</span> Address = <span class=\"string\">'Zhongshan 23'</span>, City = <span class=\"string\">'Nanjing'</span></span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> LastName = <span class=\"string\">'Wilson'</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"DELETE\"><a href=\"#DELETE\" class=\"headerlink\" title=\"DELETE\"></a>DELETE</h3><p><strong>DELETE 语句用于删除表中的行</strong>。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DELETE</span> <span class=\"keyword\">FROM</span> Person <span class=\"keyword\">WHERE</span> LastName = <span class=\"string\">'Wilson'</span></span><br></pre></td></tr></table></figure>\n<p>可以删除所有行：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DELETE</span> <span class=\"keyword\">FROM</span> table_name</span><br></pre></td></tr></table></figure>\n<p>或者：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DELETE * FROM table_name</span><br></pre></td></tr></table></figure>\n<p>这样可以清空数据，与此同时保留了表的结构。</p>\n<h3 id=\"TOP\"><a href=\"#TOP\" class=\"headerlink\" title=\"TOP\"></a>TOP</h3><p>对于拥有数千条记录的大型表来说，TOP子句是非常有用的，它用于规定返回记录的数目（不超过限定的数）。</p>\n<blockquote>\n<p>但并非所有数据库管理系统都支持TOP子句</p>\n</blockquote>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> TOP <span class=\"built_in\">number</span>|<span class=\"keyword\">percent</span> column_name(s)</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> table_name</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> TOP <span class=\"number\">2</span> * <span class=\"keyword\">FROM</span> Persons</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> TOP <span class=\"number\">50</span> <span class=\"keyword\">PERCENT</span> * <span class=\"keyword\">FROM</span> Persons</span><br></pre></td></tr></table></figure>\n<h4 id=\"MYSQL\"><a href=\"#MYSQL\" class=\"headerlink\" title=\"MYSQL\"></a>MYSQL</h4><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> column_name(s)</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> table_name</span><br><span class=\"line\"><span class=\"keyword\">LIMIT</span> <span class=\"built_in\">number</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"ORACLE\"><a href=\"#ORACLE\" class=\"headerlink\" title=\"ORACLE\"></a>ORACLE</h4><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> column_name(s)</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> table_name</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> <span class=\"keyword\">ROWNUM</span> &lt;= <span class=\"built_in\">number</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"LIKE\"><a href=\"#LIKE\" class=\"headerlink\" title=\"LIKE\"></a>LIKE</h3><p>LIKE 操作符用于在 WHERE 子句中搜索列中的指定模式。”%” 可用于定义通配符（模式中缺少的字母）。</p>\n<blockquote>\n<p>不区分大小写</p>\n</blockquote>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> Persons</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> City <span class=\"keyword\">LIKE</span> <span class=\"string\">'%lon%'</span></span><br></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>Id</th>\n<th>LastName</th>\n<th>FirstName</th>\n<th>Address</th>\n<th>City</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>Adams</td>\n<td>John</td>\n<td>Oxford Street</td>\n<td>London</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"通配符\"><a href=\"#通配符\" class=\"headerlink\" title=\"通配符\"></a>通配符</h3><table>\n<thead>\n<tr>\n<th>通配符</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>%</td>\n<td>替代一个或多个字符</td>\n</tr>\n<tr>\n<td>_</td>\n<td>仅替代一个字符</td>\n</tr>\n<tr>\n<td>[charlist]</td>\n<td>字符列中的任意一个字符</td>\n</tr>\n<tr>\n<td>[^charlist] 或 [!charlist]</td>\n<td>不在字符列中的任何单一字符</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> Persons</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> LastName <span class=\"keyword\">LIKE</span> <span class=\"string\">'C_r_er'</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> * <span class=\"keyword\">FROM</span> Persons</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> City <span class=\"keyword\">LIKE</span> <span class=\"string\">'[!ALN]%'</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"IN\"><a href=\"#IN\" class=\"headerlink\" title=\"IN\"></a>IN</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> column_name(s)</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> table_name</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> column_name <span class=\"keyword\">IN</span> (value1,value2,...)</span><br></pre></td></tr></table></figure>\n"},{"title":"APUE读书笔记 — File I/O","date":"2018-05-27T16:00:00.000Z","comments":1,"_content":"\n## 前言\n\n这章将的是文件IO，其中有几个非常重要的概念：\n\n1. File Desriptors，文件描述符\n2. current file offset，当前文件偏移量\n3. File Sharing Data Structure，文件共享数据模型\n4. file descriptor flags ，文件描述位\n5. file status flags ，文件状态位\n\n\n\n## File Descriptors\n\n- 对内核来说，所有 **打开的文件** 都使用file descriptor引用。\n\n- 文件描述符是一个非负整数。当我们打开一个存在的文件或者创建一个新文件，内核返回一个文件描述符给进程。\n\n- 当我们想要读或者写一个文件，我们通过文件描述符来确定这个文件，文件描述符是被open或者creat返回的，然后作为read或者write的一个参数。\n\n> 文件描述符都使用尽可能小的非负整数，File descriptors range from 0 through OPEN_MAX−1. \n\n有三个magic number，0代表STDIN_FILENO，1代表STDOUT_FILENO，2代表STDERR_FILENO。虽然这已经是POSIX.1所定义的标准，但为了程序的可读性，还是不建议直接写数字。这三个常量定义在`<unistd.h>`中。\n\n## open and openat Functions\n\nA file is opened or created by calling either the open function or the openat function. \n\n```C\n#include <fcntl.h>\nint open(const char *path, int oflag, ... /* mode_t mode */ );\nint openat(int fd, const char *path, int oflag, ... /* mode_t mode */ );\n// Both return: file descriptor if OK, −1 on error\n```\n\n最后一个参数是`…`，这是ISO C定义剩下的多个参数的方式。对这些函数来说，只有当新文件被创建时，最后一个参数才被使用，后面我们会讲。在这个原型中我们把这个参数写作一个注释。\n\npath这个参数是要打开或者要创建的文件的名字。这个函数有多种操作，定在在oflag参数里。这个参数由下列一个或者多个定义在`<fcntl.h>`头文件中的常量通过或操作构成：\n\nO_RDONLY\tOpen for reading only\n\nO_WRONLY\tOpen for writing only\n\nO_RDWR\tOpen for reading and writing\n\n> Most implementations define O_RDONLY as 0, O_WRONLY as 1, and O_RDWR as 2, for compatibility with older programs.  **为了兼容老程序，许多实现定义O_RDONLY as 0, O_WRONLY as 1, and O_RDWR as 2**。\n\nO_EXEC\t\tOpen for execute only\n\nO_SEARCH\tOpen for search only(applies to directories)\n\n> The purpose of the O_SEARCH constant is to evaluate search permissions at the time a directory is opened. Further operations using the directory’s file descriptor will not reevaluate permission to search the directory. None of the versions of the operating systems covered in this book support O_SEARCH yet. \n\nOne and only one of the previous five constants must be specified. The following constants are optional: \n\n上面的五个常量有且只有一个必须被明确。接下来的是可选常量：\n\nO_APPEND\tAppend to the end of file on each write. We describe this option in detail in Section 3.11. \n\nO_CLOEXEC\tSet the FD_CLOEXEC file descriptor flag. We discuss file descriptor flags in Section 3.14. \n\nO_CREAT\tCreate the file if it doesn’t exist. This option requires a third argument to the open function (a fourth argument to the openat function) — the mode, which specifies the access permission bits of the new file. (When we describe a file’s access permission bits in Section 4.5, we’ll see how to specify the mode and how it can be modified by the umask value of a process.)  创建一个文件，如果不存在。这个操作需要open函数的第三个参数（openat函数的第四个参数）— mode，**它明确了这个新文件的访问权限位**。（当我们在第4.5章节讨论文件的访问权限位，我们将看到如何明确mode，以及它如何修改进程的umask值。）\n\nO_DIRECTORY\tGenerate an error if path doesn’t refer to a directory. \n\nO_EXCL\t\tGenerate an error if O_CREAT is also specified and the file already exists. This test for whether the file already exists and the creation of the file if it doesn’t exist is an atomic operation. We describe atomic operations in more detail in Section 3.11.  如果O_CREAT被使用了且文件已经存在就会生成一个错误。这个常量的作用是检测文件是否存在如果文件不存在就创建，这是一个原子操作。我们将在第3.11章节讨论更多原子操作的细节。\n\nO_NOCTTY\tIf path refers to a terminal device, do not allocate the device as the controlling terminal for this process. We talk about controlling terminals in Section 9.6.  如果这个路径指向的是终端设备，则不将这个设备分配为此进程的控制终端。\n\nO_NONBLOCK\tIf path refers to a FIFO, a block special file, or a character special file, this option sets the nonblocking mode for both the opening of the file and subsequent I/O. We describe this mode in Section 14.2.  如果path指向FIFO（先进先出），一个块特殊文件，一个字符特殊文件，这个选项设置了非阻塞模式为本次的打开操作和后续的I/O操作。\n\n> In earlier releases of System V, the O_NDELAY (no delay) flag was introduced. This option is similar to the O_NONBLOCK (nonblocking) option, but an ambiguity was introduced in the return value from a read operation. The no-delay option causes a read operation to return 0 if there is no data to be read from a pipe, FIFO, or device, but this conflicts with a return value of 0, indicating an end of file. SVR4-based systems still support the no-delay option, with the old semantics, but new applications should use the nonblocking option instead.  在早期的System V，有一个O_NDELAY(no delay)符号。这个符号和O_NONBLOCK(nonblocking)选项相似，但他的读操作返回值具有二义性。如果管道，先进先出，或者设备没有数据可读，no-delay选项就会造成read操作返回0，这与end of file造成的返回值0冲突了。虽然基于SVR4的系统还支持这个no-delay选项，但新的应用应该使用nonblocking选项。\n\nO_SYNC\t\tHave each write wait for physical I/O to complete, including I/O necessary to update file attributes modified as a result of the write. We use this option in Section 3.14.  使每次write都等物理I/O完成，包括更新文件属性所需要的I/O。\n\nO_TTY_INIT\tWhen opening a terminal device that is not already open, set the nonstandard termios parameters to values that result in behavior that conforms to the Single UNIX Specification. We discuss the termios structure when we discuss terminal I/O in Chapter 18.  当打开一个新的终端设备的时候，设置非标准参数 termios。\n\nThe following two flags are also optional. They are part of the synchronized input and output option of the Single UNIX Specification (and thus POSIX.1). \n\nO_DSYNC\tHave each write wait for physical I/O to complete, but don’t wait for file attributes to be updated if they don’t affect the ability to read the data just written.  让所有write都等待物理I/O完成，但是不用等文件属性更新，如果不影响刚刚写完的数据的读操作的话。\n\nO_RSYNC\tHave each read operation on the file descriptor wait until any pending writes for the same portion of the file are complete.  使每个使用文件描述符的的读操作等待，直到对文件的同一部分的所有写操作完成。\n\n> Solaris 10 supports all three synchronization flags. Historically, FreeBSD (and thus Mac OS X) have used the O_FSYNC flag, which has the same behavior as O_SYNC. Because the two flags are equivalent, they define the flags to have the same value. FreeBSD 8.0 doesn’t support the O_DSYNC or O_RSYNC flags. Mac OS X doesn’t support the O_RSYNC flag, but defines the O_DSYNC flag, treating it the same as the O_SYNC flag. Linux 3.2.0 supports the O_DSYNC flag, but treats the O_RSYNC flag the same as O_SYNC. \n\n**The file descriptor returned by open and openat is guaranteed to be the lowest- numbered unused descriptor**. This fact is used by some applications to open a new file on standard input, standard output, or standard error. **For example, an application might close standard output—normally, file descriptor 1—and then open another file, knowing that it will be opened on file descriptor 1**. We’ll see a better way to guarantee that a file is open on a given descriptor in Section 3.12, when we explore the dup2 function. \n\n**The fd parameter** distinguishes the openat function from the open function. There are three possibilities:\n\n1. The path parameter specifies an absolute pathname. In this case, the fd parameter is ignored and the openat function behaves like the open function. \n\n2. The path parameter specifies a relative pathname and the fd parameter is a file descriptor that specifies the starting location in the file system where the relative pathname is to be evaluated. The fd parameter is obtained by opening the directory where the relative pathname is to be evaluated. \n\n3. The path parameter specifies a relative pathname and the fd parameter has the special value AT_FDCWD. In this case, the pathname is evaluated starting in the current working directory and the openat function behaves like the open function. \n\nThe openat function is one of a class of functions added to the latest version of POSIX.1 to address two problems. First, it gives threads a way to use relative pathnames to open files in directories other than the current working directory. As we’ll see in Chapter 11, all threads in the same process share the same current working directory, so this makes it difficult for multiple threads in the same process to work in different directories at the same time. Second, it provides a way to avoid time-of-check- to-time-of-use (TOCTTOU) errors.  openat函数是在最后一个版本的POSIX.1加入的，为了解决两个问题。首先，它给线程以相对路径而非当前路径。我们将在第11章看到，在同一进程中的所有线程共享同一个当前目录，所以要让同一进程中的多线程同时在不同的目录工作是非常困难的。第二，它提供了避免 time-of-check-to-time-of-use（TOCTTOU） 错误。\n\nThe basic idea behind TOCTTOU errors is that a program is vulnerable if it makes two file-based function calls where the second call depends on the results of the first call. Because the two calls are not atomic, the file can change between the two calls, thereby invalidating the results of the first call, leading to a program error. TOCTTOU errors in the file system namespace generally deal with attempts to subvert file system permissions by tricking a privileged program into either reducing permissions on a privileged file or modifying a privileged file to open up a security hole. Wei and Pu [2005] discuss TOCTTOU weaknesses in the UNIX file system interface.  TOCTTOU错误的意思是，一个调用横叉一脚影响了另一个调用，本来另一个调用应该是一个原子操作。\n\n### Filename and Pathname Truncation \n\nWhat happens if NAME_MAX is 14 and we try to create a new file in the current directory with a filename containing 15 characters? Traditionally, early releases of System V, such as SVR2, allowed this to happen, silently truncating the filename beyond the 14th character. BSD-derived systems, in contrast, returned an error status, with errno set to ENAMETOOLONG. Silently truncating the filename presents a problem that affects more than simply the creation of new files. If NAME_MAX is 14 and a file exists whose name is exactly 14 characters, any function that accepts a pathname argument, such as open or stat, has no way to determine what the original name of the file was, as the original name might have been truncated.  如果NAME_MAX是14怎么办？传统上，早期的System V系统，允许这发生，静默的将文件名截断成14字符。相反的，BSD派生的系统，返回一个错误状态，并把errno设置成ENAMETOOLONG。静默的截断文件名呈现的问题不仅仅是创建了一个新文件。如果NAME_MAX是14且文件存在，且它的名字就是14字符，任何接收一个路径名作为参数的函数，比如open或者stat，没办法判断文件原来的名字是什么，因为原始文件名可能已经被截断。\n\nWith POSIX.1, the constant `_POSIX_NO_TRUNC` determines whether long filenames and long components of pathnames are truncated or an error is returned. As we saw in Chapter 2, this value can vary based on the type of the file system, and we can use fpathconf or pathconf to query a directory to see which behavior is supported.  在POSIX.1标准里，常量 `_POSIX_NO_TRUNC` 决定长文件名和路径名中长的组件是否被截断或者是否返回一个错误。正如我们在第二章中看到的，这个值在文件系统中是非常基本的，我们可以使用 `fpathconf` 或 `pathconf`查询一个目录看看它支持哪种行为。\n\n> Whether an error is returned is largely historical. For example, SVR4-based systems do not generate an error for the traditional System V file system, S5. For the BSD-style file system (known as UFS), however, SVR4-based systems do generate an error. Figure 2.20 illustrates another example: Solaris will return an error for UFS, but not for PCFS, the DOS-compatible file system, as DOS silently truncates filenames that don’t fit in an 8.3 format. BSD-derived systems and Linux always return an error. \n\nIf _POSIX_NO_TRUNC is in effect, errno is set to ENAMETOOLONG, and an error status is returned if any filename component of the pathname exceeds NAME_MAX. \n\n> Most modern file systems support a maximum of 255 characters for filenames. Because filenames are usually shorter than this limit, this constraint tends to not present problems for most applications. \n\n### creat Function\n\nA new file can also be created by calling the creat function. \n\n```C\n#include <fcntl.h>\nint creat(const char *path, mode_t mode);\n// Returns: file descriptor opened for write-only if OK, −1 on error\n```\n\nNote that this function is equivalent to \n\n```C\nopen(path, O_WRONLY | O_CREAT | O_TRUNC, mode);\n```\n\n> Historically, in early versions of the UNIX System, the second argument to open could be only 0, 1, or 2. There was no way to open a file that didn’t already exist. Therefore, a separate system call, creat, was needed to create new files. With the O_CREAT and O_TRUNC options now provided by open, a separate creat function is no longer needed.  这个函数诞生的原因是：历史上open函数的第二个参数只支持0，1，2这三个值，也就是读，写，读写。没办法打开一个不存在的文件。而现在有了O_CREAT and O_TRUNC options，creat函数也就没有存在的必要了。\n\nWe’ll show how to specify mode in Section 4.5 when we describe a file’s access permissions in detail. \n\nOne deficiency with creat is that the file is opened only for writing. Before the new version of open was provided, if we were creating a temporary file that we wanted to write and then read back, we had to call creat, close, and then open. A better way is to use the open function, as in \n\n```C\nopen(path, O_RDWR | O_CREAT | O_TRUNC, mode);\n```\n\n### close Function\n\nAn open file is closed by calling the close function. \n\n```C\n#include <unistd.h> \n\n// Returns: 0 if OK, −1 on error\nint close(int fd);\n```\n\nClosing a file also releases any record locks that the process may have on the file. We’ll discuss this point further in Section 14.3.  关闭一个文件同样会释放进程对该文件的所有锁。\n\nWhen a process terminates, all of its open files are closed automatically by the kernel. Many programs take advantage of this fact and don’t explicitly close open files. See the program in Figure 1.4, for example.  当一个进程终止，所有它打开的文件都会被内核自动关闭。许多程序利用了这一点，不明确关闭文件。\n\n### lseek Function\n\nEvery open file has an associated ‘‘current file offset,’’ normally a non-negative integer that measures the number of bytes from the beginning of the file. (We describe some exceptions to the ‘‘non-negative’’ qualifier later in this section.) Read and write operations normally start at the current file offset and cause the offset to be incremented by the number of bytes read or written. By default, this offset is initialized to 0 when a file is opened, unless the O_APPEND option is specified.  每个打开的文件都与 \"current file offset\"关联，正常情况下它是一个非负整形数，表示从文件开始到目前位置的字节数。读和写操作都是从 current file offset开始的，并且会让offset增加，随着读和写的进行。默认的，当文件被打开时，这个位移初始化时0，除非指明了O_APPEND选项。\n\nAn open file’s offset can be set explicitly by calling lseek.  通过调用 lseek函数，一个打开的文件的offset可以被设定。\n\n```C\n#include <unistd.h>\noff_t lseek(int fd, off_t offset, int whence);\n// Returns: new file offset if OK, −1 on error\n```\n\nThe interpretation of the offset depends on the value of the whence argument. \n\n- If whence is SEEK_SET, the file’s offset is set to offset bytes from the beginning of \n\n  the file. \n\n- If whence is SEEK_CUR, the file’s offset is set to its current value plus the offset. \n\n  The offset can be positive or negative. \n\n- If whence is SEEK_END, the file’s offset is set to the size of the file plus the offset. \n\n  The offset can be positive or negative.\n\nBecause a successful call to lseek returns the new file offset, we can seek zero bytes \n\nfrom the current position to determine the current offset: \n\n```C\noff_t    currpos;\ncurrpos = lseek(fd, 0, SEEK_CUR);\n```\n\nThis technique can also be used to determine if a file is capable of seeking. If the file descriptor refers to a pipe, FIFO, or socket, lseek sets errno to **ESPIPE** and returns −1.  \n\n> The three symbolic constants—SEEK_SET, SEEK_CUR, and SEEK_END—were introduced with System V. Prior to this, **whence was specified as 0 (absolute), 1 (relative to the current offset), or 2 (relative to the end of file). Much software still exists with these numbers hard coded**. \n>\n> **The character l in the name lseek means ‘‘long integer.’’ Before the introduction of the off_t data type, the offset argument and the return value were long integers**. lseek was introduced with Version 7 when long integers were added to C. (Similar functionality was provided in Version 6 by the functions seek and tell.) \n\n### Example\n\nThe program in Figure 3.1 tests its standard input to see whether it is capable of seeking. \n\n> Figure 3.1 Test whether standard input is capable of seeking \n\n```C\n#include \"apue.h\"\nint main(void)\n{\n    if (lseek(STDIN_FILENO, 0, SEEK_CUR) == -1)\n        printf(\"cannot seek\\n\");\n    else\n        printf(\"seek OK\\n\");\n \texit(0); \n}\n```\n\n**Normally, a file’s current offset must be a non-negative integer. It is possible, however, that certain devices could allow negative offsets. But for regular files, the offset must be non-negative. Because negative offsets are possible, we should be careful to compare the return value from lseek as being equal to or not equal to −1, rather than testing whether it is less than 0**. \n\n> The /dev/kmem device on FreeBSD for the Intel x86 processor supports negative offsets. Because the offset (off_t) is a signed data type (Figure 2.21), we lose a factor of 2 in the maximum file size. If off_t is a 32-bit integer, the maximum file size is $2^{31}$−1 bytes. \n>\n\nlseek only records the current file offset within the kernel — it does not cause any I/O to take place. This offset is then used by the next read or write operation. \n\nThe file’s offset can be greater than the file’s current size, in which case the next write to the file will extend the file. This is referred to as creating a hole in a file and is allowed. Any bytes in a file that have not been written are read back as 0.  文件偏移量可以大于文件的目前大小，在这种情况下下一次写文件将扩展文件。也就是说在文件中创建一个空洞是被允许的。在文件中任何没被写入的部分都将被读作0。\n\nA hole in a file isn’t required to have storage backing it on disk. Depending on the file system implementation, when you write after seeking past the end of a file, new disk blocks might be allocated to store the data, but there is no need to allocate disk blocks for the data between the old end of file and the location where you start writing.  文件中的空洞并不需要存储到磁盘上。根据文件系统的实现，当你在end of file之后写，为了存储数据新的磁盘空间可能会分配，但没有必要分配磁盘块给end of file和你开始写的地方之间的这些数据。\n\n### Example\n\nThe program shown in Figure 3.2 creates a file with a hole in it. \n\n> Figure 3.2  Create a file with a hole in it \n\n```C\n#include \"apue.h\"\n#include <fcntl.h>\nchar    buf1[] = \"abcdefghij\";\nchar    buf2[] = \"ABCDEFGHIJ\";\nint main(void)\n{\n\tint fd;\n    if ((fd = creat(\"file.hole\", FILE_MODE)) < 0)\n    \terr_sys(\"creat error\");\n    if (write(fd, buf1, 10) != 10)\n    \terr_sys(\"buf1 write error\");\n    /* offset now = 10 */\n    if (lseek(fd, 16384, SEEK_SET) == -1)\n    \terr_sys(\"lseek error\");\n    /* offset now = 16384 */\n    if (write(fd, buf2, 10) != 10)\n        err_sys(\"buf2 write error\");\n    /* offset now = 16394 */\n\texit(0); \n}\n```\n\n## File Sharing\n\nThe UNIX System supports the sharing of open files among different processes. Before describing the dup function, we need to describe this sharing. To do this, we’ll examine the data structures used by the kernel for all I/O. \n\n> The following description is conceptual; it may or may not match a particular implementation. Refer to Bach [1986] for a discussion of these structures in System V. McKusick et al. [1996] describe these structures in 4.4BSD. McKusick and Neville-Neil [2005] cover FreeBSD 5.2. For a similar discussion of Solaris, see McDougall and Mauro [2007]. The Linux 2.6 kernel architecture is discussed in Bovet and Cesati [2006]. \n\nThe kernel uses three data structures to represent an open file, and the relationships among them determine the effect one process has on another with regard to file sharing. \n\n1. Every process has an entry in the process table. Within each process table entry is a table of open file descriptors, which we can think of as a vector, with one entry per descriptor. Associated with each file descriptor are \n   1. The file descriptor flags (close-on-exec; refer to Figure 3.7 and Section 3.14) \n   2. A pointer to a file table entry \n\n2. The kernel maintains a file table for all open files. Each file table entry contains \n   1. The file status flags for the file, such as read, write, append, sync, and nonblocking; more on these in Section 3.14 \n   2. The current file offset \n   3. A pointer to the v-node table entry for the file \n\n3. Each open file (or device) has a v-node structure that **contains information about the type of file** and **pointers to functions that operate on the file**. For most files, the v-node also contains the i-node for the file. **This information is read from disk when the file is opened**, so that all the pertinent information about the file is readily available. For example, **the i-node contains the owner of the file, the size of the file, pointers to where the actual data blocks for the file are located on disk**, and so on. (We talk more about i-nodes in Section 4.14 when we describe the typical UNIX file system in more detail.) \n\n> Linux has no v-node. Instead, a generic i-node structure is used. Although the implementations differ, the v-node is conceptually the same as a generic i-node. Both point to an i-node structure specific to the file system.\n\nWe’re ignoring some implementation details that don’t affect our discussion. For example, the table of open file descriptors can be stored in the user area (a separate per- process structure that can be paged out) instead of the process table. Also, these tables can be implemented in numerous ways—they need not be arrays; one alternate implementation is a linked lists of structures. Regardless of the implementation details, the general concepts remain the same. \n\nFigure 3.7 shows a pictorial arrangement of these three tables for a single process that has two different files open: one file is open on standard input (file descriptor 0), and the other is open on standard output (file descriptor 1). \n\n<img src=\"https://i.loli.net/2018/05/30/5b0e51e54c6d1.png\">\n\nThe arrangement of these three tables has existed since the early versions of the UNIX System [Thompson 1978]. **This arrangement is critical to the way files are shared among processes**. We’ll return to this figure in later chapters, when we describe additional ways that files are shared. \n\n> **The v-node was invented to provide support for multiple file system types on a single computer system**. This work was done independently by Peter Weinberger (Bell Laboratories) and Bill Joy (Sun Microsystems). **Sun called this the Virtual File System and called the file system–independent portion of the i-node the v-node** [Kleiman 1986]. The v-node propagated through various vendor implementations as support for Sun’s Network File System (NFS) was added. The first release from Berkeley to provide v-nodes was the 4.3BSD Reno release, when NFS was added. \n\n> In SVR4, the v-node replaced the file system–independent i-node of SVR3. Solaris is derived from SVR4 and, therefore, uses v-nodes. \n\n> Instead of splitting the data structures into a v-node and an i-node, Linux uses a file system–independent i-node and a file system–dependent i-node. \n\nIf two independent processes have the same file open, we could have the arrangement shown in Figure 3.8. \n\n<img src=\"https://i.loli.net/2018/05/30/5b0e5b6638838.png\">\n\nWe assume here that the first process has the file open on descriptor 3 and that the second process has that same file open on descriptor 4. Each process that opens the file gets its own file table entry, but only a single v-node table entry is required for a given file. One reason each process gets its own file table entry is so that each process has its own current offset for the file. \n\nGiven these data structures, we now need to be more specific about what happens with certain operations that we’ve already described. \n\n- After each write is complete, the current file offset in the file table entry is incremented by the number of bytes written. If this causes the current file offset to exceed the current file size, the current file size in the i-node table entry is set to the current file offset (for example, the file is extended). \n- If a file is opened with the O_APPEND flag, a corresponding flag is set in the file status flags of the file table entry. Each time a write is performed for a file with this append flag set, the current file offset in the file table entry is first set to the current file size from the i-node table entry. This forces every write to be appended to the current end of file. \n- If a file is positioned to its current end of file using lseek, all that happens is the current file offset in the file table entry is set to the current file size from the i-node table entry. (Note that this is not the same as if the file was opened with the O_APPEND flag, as we will see in Section 3.11.) \n- The lseek function modifies only the current file offset in the file table entry. No I/O takes place. \n\nIt is possible for more than one file descriptor entry to point to the same file table entry, as we’ll see when we discuss the dup function in Section 3.12. This also happens after a fork when the parent and the child share the same file table entry for each open descriptor (Section 8.3). \n\n**Note the difference in scope between the file descriptor flags and the file status flags. The former apply only to a single descriptor in a single process, whereas the latter apply to all descriptors in any process that point to the given file table entry**. When we describe the fcntl function in Section 3.14, we’ll see how to fetch and modify both the file descriptor flags and the file status flags. \n\nEverything that we’ve described so far in this section works fine for multiple processes that are reading the same file. Each process has its own file table entry with its own current file offset. Unexpected results can arise, however, when multiple processes write to the same file. To see how to avoid some surprises, we need to understand the concept of atomic operations. \n\n## Atomic Operations\n\n### Appending to a File\n\nConsider a single process that wants to append to the end of a file. Older versions of the UNIX System didn’t support the O_APPEND option to open, so the program was coded as follows: \n\n```C\nif (lseek(fd, 0L, 2) < 0)         /* position to EOF */\n\terr_sys(\"lseek error\");\nif (write(fd, buf, 100) != 100)   /* and write */\n\terr_sys(\"write error\");\n```\n\nThis works fine for a single process, but problems arise if multiple processes use this technique to append to the same file. (This scenario can arise if multiple instances of the same program are appending messages to a log file, for example.) \n\nAssume that two independent processes, A and B, are appending to the same file. Each has opened the file but without the O_APPEND flag. This gives us the same picture as Figure 3.8. Each process has its own file table entry, but they share a single v-node table entry. Assume that process A does the lseek and that this sets the current offset for the file for process A to byte offset 1,500 (the current end of file). Then the kernel switches processes, and B continues running. Process B then does the lseek, which sets the current offset for the file for process B to byte offset 1,500 also (the current end of file). Then B calls write, which increments B’s current file offset for the file to 1,600. Because the file’s size has been extended, the kernel also updates the current file size in the v-node to 1,600. Then the kernel switches processes and A resumes. When A calls write, the data is written starting at the current file offset for A, which is byte offset 1,500. This overwrites the data that B wrote to the file. \n\nThe problem here is that our logical operation of ‘‘position to the end of file and write’’ requires two separate function calls (as we’ve shown it). The solution is to have the positioning to the current end of file and the write be an atomic operation with regard to other processes. Any operation that requires more than one function call cannot be atomic, as there is always the possibility that the kernel might temporarily suspend the process between the two function calls (as we assumed previously). \n\nThe UNIX System provides an atomic way to do this operation if we set the O_APPEND flag when a file is opened. As we described in the previous section, this causes the kernel to position the file to its current end of file before each write. We no longer have to call lseek before each write. \n\n### pread and pwrite Functions\n\nThe Single UNIX Specification includes two functions that allow applications to seek and perform I/O atomically: pread and pwrite. \n\n```C\n#include <unistd.h>\n\n// Returns: number of bytes read, 0 if end of file, −1 on error\nssize_t pread(int fd, void *buf, size_t nbytes, off_t offset);\n\n// Returns: number of bytes written if OK, −1 on error\nssize_t pwrite(int fd, const void *buf, size_t nbytes, off_t offset); \n```\n\nCalling pread is equivalent to calling lseek followed by a call to read, with the following exceptions. \n\n- There is no way to interrupt the two operations that occur when we call pread. \n\n- The current file offset is not updated. \n\nCalling pwrite is equivalent to calling lseek followed by a call to write, with similar exceptions. \n\n### Creating a File\n\nWe saw another example of an atomic operation when we described the O_CREAT and O_EXCL options for the open function. When both of these options are specified, the open will fail if the file already exists. We also said that the check for the existence of the file and the creation of the file was performed as an atomic operation. If we didn’t have this atomic operation, we might try \n\n```C\nif ((fd = open(path, O_WRONLY)) < 0) {\n    if (errno == ENOENT) {\n        if ((fd = creat(path, mode)) < 0)\n            err_sys(\"creat error\");\n    } else {\n        err_sys(\"open error\");\n} }\n```\n\nThe problem occurs if the file is created by another process between the open and the creat. If the file is created by another process between these two function calls, and if that other process writes something to the file, that data is erased when this creat is executed. Combining the test for existence and the creation into a single atomic operation avoids this problem. \n\nIn general, the term atomic operation refers to an operation that might be composed of multiple steps. If the operation is performed atomically, either all the steps are performed (on success) or none are performed (on failure). It must not be possible for only a subset of the steps to be performed. We’ll return to the topic of atomic operations when we describe the link function (Section 4.15) and record locking (Section 14.3). \n\n## dup and dup2 Functions\n\nAn existing file descriptor is duplicated by either of the following functions: \n\n```C\n#include <unistd.h>\n\n// Both return: new file descriptor if OK, −1 on error\nint dup(int fd);\nint dup2(int fd, int fd2);\n```\n\nThe new file descriptor returned by dup is guaranteed to be the lowest-numbered available file descriptor. **With dup2, we specify the value of the new descriptor with the fd2 argument. If fd2 is already open, it is first closed. If fd equals fd2, then dup2 returns fd2 without closing it. Otherwise, the FD_CLOEXEC file descriptor flag is cleared for fd2, so that fd2 is left open if the process calls exec**.\n\nThe new file descriptor that is returned as the value of the functions shares the same file table entry as the fd argument. We show this in Figure 3.9. \n\n<img src=\"https://i.loli.net/2018/05/30/5b0e6c0a52034.png\">\n\nIn this figure, we assume that when it’s started, the process executes \n\n```C\nnewfd = dup(1);\n```\n\nWe assume that the next available descriptor is 3 (which it probably is, since 0, 1, and 2 are opened by the shell). Because both descriptors point to the same file table entry, they share the same file status flags—read, write, append, and so on—and the same current file offset. \n\nEach descriptor has its own set of file descriptor flags. As we describe in Section 3.14, the close-on-exec file descriptor flag for the new descriptor is always cleared by the dup functions. \n\nAnother way to duplicate a descriptor is with the fcntl function, which we describe in Section 3.14. Indeed, the call \n\n```C\ndup(fd);\n```\n\nis equivalent to \n\n```C\nfcntl(fd, F_DUPFD, 0);\n```\n\nSimilarly, the call \n\n```C\ndup2(fd, fd2);\n```\n\nis equivalent to \n\n```C\nclose(fd2);\nfcntl(fd, F_DUPFD, fd2);\n```\n\nIn this last case, the dup2 is not exactly the same as a close followed by an fcntl. The differences are as follows: \n\n1. dup2 is an atomic operation, whereas the alternate form involves two function calls. It is possible in the latter case to have a signal catcher called between the close and the fcntl that could modify the file descriptors. (We describe signals in Chapter 10.) The same problem could occur if a different thread changes the file descriptors. (We describe threads in Chapter 11.) \n2. There are some errno differences between dup2 and fcntl. \n\n> The dup2 system call originated with Version 7 and propagated through the BSD releases. The fcntl method for duplicating file descriptors appeared with System III and continued with SystemV. SVR3.2 picked up the dup2 function, and 4.2BSD picked up the fcntl function and the F_DUPFD functionality. POSIX.1 requires both dup2 and the F_DUPFD feature of fcntl. \n\n## sync, fsync, and fdatasync Functions\n\nTraditional implementations of the UNIX System have a buffer cache or page cache in the kernel through which most disk I/O passes. When we write data to a file, the data is normally copied by the kernel into one of its buffers and queued for writing to disk at some later time. This is called delayed write. (Chapter 3 of Bach [1986] discusses this buffer cache in detail.) \n\nThe kernel eventually writes all the delayed-write blocks to disk, normally when it needs to reuse the buffer for some other disk block. To ensure consistency of the file system on disk with the contents of the buffer cache, the sync, fsync, and fdatasync functions are provided. \n\n```C\n#include <unistd.h> \n\n// Both Returns: 0 if OK, −1 on error\nint fsync(int fd); \nint fdatasync(int fd);\n\nvoid sync(void);\n```\n\n**The sync function simply queues all the modified block buffers for writing and returns; it does not wait for the disk writes to take place**. \n\n**The function sync is normally called periodically (usually every 30 seconds) from a system daemon, often called update**. This guarantees regular flushing of the kernel’s block buffers. The command sync(1) also calls the sync function. \n\nThe function fsync refers only to a single file, specified by the file descriptor fd, and **waits for the disk writes to complete before returning**. This function is used when an application, **such as a database**, needs to be sure that the modified blocks have been written to the disk. \n\n**The fdatasync function is similar to fsync, but it affects only the data portions of a file. With fsync, the file’s attributes are also updated synchronously**. \n\n> All four of the platforms described in this book support sync and fsync. However, FreeBSD 8.0 does not support fdatasync. \n\n## fcntl Function\n\nThe fcntl function can change the properties of a file that is already open. \n\n```C\n#include <fcntl.h>\n\n// Returns: depends on cmd if OK (see following), −1 on error\nint fcntl(int fd, int cmd, ... /* int arg */ );\n```\n\nIn the examples in this section, the third argument is always an integer, corresponding to the comment in the function prototype just shown. When we describe record locking in Section 14.3, however, the third argument becomes a pointer to a structure. \n\nThe fcntl function is used for five different purposes. \n\n1. Duplicate an existing descriptor (cmd = F_DUPFD or F_DUPFD_CLOEXEC) \n\n2. Get/set file descriptor flags (cmd = F_GETFD or F_SETFD) \n\n3. Get/set file status flags (cmd = F_GETFL or F_SETFL) \n\n4. Get/set asynchronous I/O ownership (cmd = F_GETOWN or F_SETOWN) \n\n5. Get/set record locks (cmd = F_GETLK, F_SETLK, or F_SETLKW) \n\nWe’ll now describe the first 8 of these 11 cmd values. (We’ll wait until Section 14.3 to describe the last 3, which deal with record locking.) Refer to Figure 3.7, as we’ll discuss both the file descriptor flags associated with each file descriptor in the process table entry and the file status flags associated with each file table entry. \n\nF_DUPFD \tDuplicate the file descriptor fd. The new file descriptor is returned as the value of the function. It is the lowest-numbered descriptor that is not already open, and that is greater than or equal to the third argument (taken as an integer). The new descriptor shares the same file table entry as fd. (Refer to Figure 3.9.) But the new descriptor has its own set of file descriptor flags, and its FD_CLOEXEC file descriptor flag is cleared. (This means that the descriptor is left open across an exec, which we discuss in Chapter 8.) \n\nF_DUPFD_CLOEXEC\tDuplicate the file descriptor and set the FD_CLOEXEC file descriptor flag associated with the new descriptor. Returns the new file descriptor. \n\nF_GETFD \tReturn the file descriptor flags for fd as the value of the function. Currently, only one file descriptor flag is defined: the FD_CLOEXEC flag. \n\nF_SETFD \tSet the file descriptor flags for fd. The new flag value is set from the third argument (taken as an integer). \n\n> Be aware that some existing programs that deal with the file descriptor flags don’t use the constant FD_CLOEXEC. Instead, these programs set the flag to either 0 (don’t close-on-exec, the default) or 1 (do close-on-exec). \n\nF_GETFL \tReturn the file status flags for fd as the value of the function. We described the file status flags when we described the open function. They are listed in Figure 3.10. \n\n<img src=\"https://i.loli.net/2018/05/31/5b0f49576d719.png\" width=\"70%\">\n\nUnfortunately, the five access-mode flags—O_RDONLY, O_WRONLY, O_RDWR, O_EXEC, and O_SEARCH—are not separate bits that can be tested. (As we mentioned earlier, the first three often have the values 0, 1, and 2, respectively, for historical reasons. Also, these five values are mutually exclusive; a file can have only one of them enabled.) Therefore, we must first use the O_ACCMODE mask to obtain the access-mode bits and then compare the result against any of the five values. \n\nF_SETFL \t\tSet the file status flags to the value of the third argument (taken as an integer). The only flags that can be changed are O_APPEND, O_NONBLOCK, O_SYNC, O_DSYNC, O_RSYNC, O_FSYNC, and O_ASYNC. \n\nF_GETOWN \tGet the process ID or process group ID currently receiving the SIGIO and SIGURG signals. We describe these asynchronous I/O signals in Section 14.5.2. \n\nF_SETOWN \tSet the process ID or process group ID to receive the SIGIO and SIGURG signals. A positive arg specifies a process ID. A negative arg implies a process group ID equal to the absolute value of arg. \n\nThe return value from fcntl depends on the command. All commands return −1 on an error or some other value if OK. The following four commands have special return values: F_DUPFD, F_GETFD, F_GETFL, and F_GETOWN. The first command returns the new file descriptor, the next two return the corresponding flags, and the final command returns a positive process ID or a negative process group ID. \n\n### Example\n\nThe program in Figure 3.11 takes a single command-line argument that specifies a file descriptor and prints a description of selected file flags for that descriptor. \n\n> Figure 3.11 Print file flags for specified descriptor \n\n```C\n#include \"include/apue.h\"\n#include <fcntl.h>\nint main(int argc, char *argv[])\n{\n  int val;\n  if (argc != 2)\n     err_quit(\"usage: a.out <descriptor#>\");\n  if ((val = fcntl(atoi(argv[1]), F_GETFL, 0)) < 0)\n     err_sys(\"fcntl error for fd %d\", atoi(argv[1]));\n  switch (val & O_ACCMODE) {\n    case O_RDONLY:\n       printf(\"read only\");\n       break;\n    case O_WRONLY:\n       printf(\"write only\");\n       break;\n    case O_RDWR:\n       printf(\"read write\");\n       break;\n    default:\n       err_dump(\"unknown access mode\");\n  }\n  if (val & O_APPEND)\n     printf(\", append\");\n  if (val & O_NONBLOCK)\n     printf(\", nonblocking\");\n  if (val & O_SYNC)\n    printf(\", synchronous writes\");\n    #if !defined(_POSIX_C_SOURCE) && defined(O_FSYNC) && (O_FSYNC != O_SYNC)\n         if (val & O_FSYNC)\n            printf(\", synchronous writes\");\n    #endif\n  putchar('\\n');\n  exit(0); \n}\n```\n\nNote that we use the feature test macro _POSIX_C_SOURCE and conditionally compile the file access flags that are not part of POSIX.1. The following script shows the operation of the program, when invoked from bash (the Bourne-again shell). Results will vary, depending on which shell you use. \n\n```shell\n➜  apue.3e ./fig3.11 0 < /dev/tty\nread only\n➜  apue.3e ./fig3.11 1 > temp.foo\n➜  apue.3e cat temp.foo\nwrite only\n➜  apue.3e ./fig3.11 2 2>>temp.foo\nwrite only, append\n➜  apue.3e ./fig3.11 5 5<>temp.foo\nread write\n```\n\nThe clause 5<>temp.foo opens the file temp.foo for reading and writing on file descriptor 5. \n\n### Example\n\nWhen we modify either the file descriptor flags or the file status flags, we must be careful to fetch the existing flag value, modify it as desired, and then set the new flag value. We can’t simply issue an F_SETFD or an F_SETFL command, as this could turn off flag bits that were previously set. \n\nFigure 3.12 shows a function that sets one or more of the file status flags for a descriptor. \n\n> Figure 3.12 Turn on one or more of the file status flags for a descriptor \n\n```C\n#include \"apue.h\"\n#include <fcntl.h>\nvoid set_fl(int fd, int flags) /* flags are file status flags to turn on */\n{\n\tint val;\n\tif ((val = fcntl(fd, F_GETFL, 0)) < 0)\n\t   err_sys(\"fcntl F_GETFL error\");\n\tval |= flags;       /* turn on flags */\n\tif (fcntl(fd, F_SETFL, val) < 0)\n\t   err_sys(\"fcntl F_SETFL error\");\n}\n```\n\nIf we change the middle statement to \n\n```C\nval &=  ̃flags;      /* turn flags off */\n```\n\nwe have a function named clr_fl, which we’ll use in some later examples. This statement logically ANDs the one’s complement of flags with the current val. \n\nIf we add the line \n\n```C\nset_fl(STDOUT_FILENO, O_SYNC);\n```\n\nto the beginning of the program shown in Figure 3.5, we’ll turn on the synchronous- write flag. This causes each write to wait for the data to be written to disk before returning. Normally in the UNIX System, a write only queues the data for writing; the actual disk write operation can take place sometime later. A database system is a likely candidate for using O_SYNC, so that it knows on return from a write that the data is actually on the disk, in case of an abnormal system failure. \n\nWe expect the O_SYNC flag to increase the system and clock times when the program runs. To test this, we can run the program in Figure 3.5, copying 492.6 MB of data from one file on disk to another and compare this with a version that does the same thing with the O_SYNC flag set. The results from a Linux system using the ext4 file system are shown in Figure 3.13. \n\n<img src=\"https://i.loli.net/2018/05/31/5b0f4c0dc6161.png\" width=\"80%\">\n\nThe six rows in Figure 3.13 were all measured with a BUFFSIZE of 4,096 bytes. The results in Figure 3.6 were measured while reading a disk file and writing to /dev/null, so there was no disk output. The second row in Figure 3.13 corresponds to reading a disk file and writing to another disk file. This is why the first and second rows in Figure 3.13 are different. The system time increases when we write to a disk file, because the kernel now copies the data from our process and queues the data for writing by the disk driver. We expect the clock time to increase as well when we write to a disk file. \n\nWhen we enable synchronous writes, the system and clock times should increase significantly. As the third row shows, the system time for writing synchronously is not much more expensive than when we used delayed writes. This implies that the Linux operating system is doing the same amount of work for delayed and synchronous writes (which is unlikely), or else the O_SYNC flag isn’t having the desired effect. In this case, the Linux operating system isn’t allowing us to set the O_SYNC flag using fcntl, instead failing without returning an error (but it would have honored the flag if we were able to specify it when the file was opened). \n\nThe clock time in the last three rows reflects the extra time needed to wait for all of the writes to be committed to disk. After writing a file synchronously, we expect that a call to fsync will have no effect. This case is supposed to be represented by the last row in Figure 3.13, but since the O_SYNC flag isn’t having the intended effect, the last row behaves the same way as the fifth row. \n\nFigure 3.14 shows timing results for the same tests run on Mac OS X 10.6.8, which uses the HFS file system. Note that the times match our expectations: synchronous writes are far more expensive than delayed writes, and using fsync with synchronous writes makes very little difference. Note also that adding a call to fsync at the end of the delayed writes makes little measurable difference. It is likely that the operating system flushed previously written data to disk as we were writing new data to the file, so by the time that we called fsync, very little work was left to be done. \n\n<img src=\"https://i.loli.net/2018/05/31/5b0f4c6873af3.png\" width=\"80%\">\n\nCompare fsync and fdatasync, both of which update a file’s contents when we say so, with the O_SYNC flag, which updates a file’s contents every time we write to the file. The performance of each alternative will depend on many factors, including the underlying operating system implementation, the speed of the disk drive, and the type of the file system. \n\nWith this example, we see the need for fcntl. Our program operates on a descriptor (standard output), never knowing the name of the file that was opened on that descriptor. We can’t set the O_SYNC flag when the file is opened, since the shell opened the file. With fcntl, we can modify the properties of a descriptor, knowing only the descriptor for the open file. We’ll see another need for fcntl when we describe nonblocking pipes (Section 15.2), since all we have with a pipe is a descriptor. \n\n## ioctl Function\n\nThe ioctl function has always been the catchall for I/O operations. Anything that couldn’t be expressed using one of the other functions in this chapter usually ended up being specified with an ioctl. Terminal I/O was the biggest user of this function. (When we get to Chapter 18, we’ll see that POSIX.1 has replaced the terminal I/O operations with separate functions.) \n\n```C\n#include <unistd.h>     /* System V */\n#include <sys/ioctl.h>  /* BSD and Linux */\n\n// Returns: −1 on error, something else if OK\nint ioctl(int fd, int request, ...);\n```\n\n> The ioctl function was included in the Single UNIX Specification only as an extension for dealing with STREAMS devices [Rago 1993], but it was moved to obsolescent status in SUSv4. UNIX System implementations use ioctl for many miscellaneous device operations. Some implementations have even extended it for use with regular files. \n\nThe prototype that we show corresponds to POSIX.1. FreeBSD 8.0 and Mac OS X 10.6.8 declare the second argument as an unsigned long. This detail doesn’t matter, since the second argument is always a #defined name from a header. \n\nFor the ISO C prototype, an ellipsis is used for the remaining arguments. Normally, however, there is only one more argument, and it’s usually a pointer to a variable or a structure. \n\nIn this prototype, we show only the headers required for the function itself. Normally, additional device-specific headers are required. For example, the ioctl commands for terminal I/O, beyond the basic operations specified by POSIX.1, all require the <termios.h> header. \n\nEach device driver can define its own set of ioctl commands. The system, however, provides generic ioctl commands for different classes of devices. Examples of some of the categories for these generic ioctl commands supported in FreeBSD are summarized in Figure 3.15. \n\n<img src=\"https://i.loli.net/2018/05/31/5b0f4cf6d20f6.png\" width=\"60%\">\n\nThe mag tape operations allow us to write end-of-file marks on a tape, rewind a tape, space forward over a specified number of files or records, and the like. None of these operations is easily expressed in terms of the other functions in the chapter (read, write, lseek, and so on), so the easiest way to handle these devices has always been to access their operations using ioctl. \n\nWe use the ioctl function in Section 18.12 to fetch and set the size of a terminal’s window, and in Section 19.7 when we access the advanced features of pseudo terminals. \n\n## /dev/fd\n\nNewer systems provide a directory named /dev/fd whose entries are files named 0, 1, 2, and so on. Opening the file /dev/fd/n is equivalent to duplicating descriptor n, assuming that descriptor n is open. \n\n> The /dev/fd feature was developed by Tom Duff and appeared in the 8th Edition of the Research UNIX System. It is supported by all of the systems described in this book: FreeBSD 8.0, Linux 3.2.0, Mac OS X 10.6.8, and Solaris 10. It is not part of POSIX.1. \n\nIn the function call \n\n```C\nfd = open(\"/dev/fd/0\", mode);\n```\n\nmost systems ignore the specified mode, whereas others require that it be a subset of the mode used when the referenced file (standard input, in this case) was originally opened. Because the previous open is equivalent to \n\n```C\nfd = dup(0);\n```\n\nthe descriptors 0 and fd share the same file table entry (Figure 3.9). For example, if descriptor 0 was opened read-only, we can only read on fd. Even if the system ignores the open mode and the call \n\n```C\nfd = open(\"/dev/fd/0\", O_RDWR);\n```\n\nsucceeds, we still can’t write to fd. \n\n> The Linux implementation of /dev/fd is an exception. It maps file descriptors into symbolic links pointing to the underlying physical files. When you open /dev/fd/0, for example, you are really opening the file associated with your standard input. Thus the mode of the new file descriptor returned is unrelated to the mode of the /dev/fd file descriptor. \n\nWe can also call creat with a /dev/fd pathname argument as well as specify O_CREAT in a call to open. This allows a program that calls creat to still work if the pathname argument is /dev/fd/1, for example. \n\n> Beware of doing this on Linux. Because the Linux implementation uses symbolic links to the real files, using creat on a /dev/fd file will result in the underlying file being truncated. \n\nSome systems provide the pathnames /dev/stdin, /dev/stdout, and /dev/stderr. These pathnames are equivalent to /dev/fd/0, /dev/fd/1, and /dev/fd/2, respectively. \n\nThe main use of the /dev/fd files is from the shell. It allows programs that use pathname arguments to handle standard input and standard output in the same manner as other pathnames. For example, the cat(1) program specifically looks for an input filename of - and uses it to mean standard input. The command \n\n```\nfilter file2 | cat file1 - file3 | lpr\n```\n\nis an example. First, cat reads file1, then its standard input (the output of the filter program on file2), and then file3. If /dev/fd is supported, the special handling of - can be removed from cat, and we can enter \n\n```\nfilter file2 | cat file1 /dev/fd/0 file3 | lpr\n```\n\nThe special meaning of - as a command-line argument to refer to the standard input or the standard output is a kludge that has crept into many programs. There are also problems if we specify - as the first file, as it looks like the start of another command-line option. Using /dev/fd is a step toward uniformity and cleanliness. \n\n## Summary\n\nThis chapter has described the basic I/O functions provided by the UNIX System. These are often called the unbuffered I/O functions because each read or write invokes a system call into the kernel. Using only read and write, we looked at the effect of various I/O sizes on the amount of time required to read a file. We also looked at several ways to flush written data to disk and their effect on application performance. \n\nAtomic operations were introduced when multiple processes append to the same file and when multiple processes create the same file. We also looked at the data structures used by the kernel to share information about open files. We’ll return to these data structures later in the text. \n\nWe also described the ioctl and fcntl functions. We return to both of these functions later in the book. In Chapter 14, we’ll use fcntl for record locking. In Chapter 18 and Chapter 19, we’ll use ioctl when we deal with terminal devices. \n\n## Exercises\n\n1. When reading or writing a disk file, are the functions described in this chapter really unbuffered? Explain. \n\n2. Write your own dup2 function that behaves the same way as the dup2 function described in Section 3.12, without calling the fcntl function. Be sure to handle errors correctly. \n\n3. Assume that a process executes the following three function calls: \n\n   ```C\n   fd1 = open(path, oflags);\n   fd2 = dup(fd1);\n   fd3 = open(path, oflags);\n   ```\n\n   Draw the resulting picture, similar to Figure 3.9. Which descriptors are affected by an fcntl on fd1 with a command of F_SETFD? Which descriptors are affected by an fcntl on fd1 with a command of F_SETFL? \n\n4. The following sequence of code has been observed in various programs: \n\n    ```C\n    dup2(fd, 0);\n    dup2(fd, 1);\n    dup2(fd, 2);\n    if (fd > 2)\n    ```\n\nclose(fd); \n\nTo see why the if test is needed, assume that fd is 1 and draw a picture of what happens to the three descriptor entries and the corresponding file table entry with each call to dup2. Then assume that fd is 3 and draw the same picture. ","source":"_posts/2018/2018-05-28-APUE读书笔记—File-IO.md","raw":"---\ntitle: APUE读书笔记 — File I/O\ndate: 2018-05-28\ncategories: [Unix]\ncomments: true\n---\n\n## 前言\n\n这章将的是文件IO，其中有几个非常重要的概念：\n\n1. File Desriptors，文件描述符\n2. current file offset，当前文件偏移量\n3. File Sharing Data Structure，文件共享数据模型\n4. file descriptor flags ，文件描述位\n5. file status flags ，文件状态位\n\n\n\n## File Descriptors\n\n- 对内核来说，所有 **打开的文件** 都使用file descriptor引用。\n\n- 文件描述符是一个非负整数。当我们打开一个存在的文件或者创建一个新文件，内核返回一个文件描述符给进程。\n\n- 当我们想要读或者写一个文件，我们通过文件描述符来确定这个文件，文件描述符是被open或者creat返回的，然后作为read或者write的一个参数。\n\n> 文件描述符都使用尽可能小的非负整数，File descriptors range from 0 through OPEN_MAX−1. \n\n有三个magic number，0代表STDIN_FILENO，1代表STDOUT_FILENO，2代表STDERR_FILENO。虽然这已经是POSIX.1所定义的标准，但为了程序的可读性，还是不建议直接写数字。这三个常量定义在`<unistd.h>`中。\n\n## open and openat Functions\n\nA file is opened or created by calling either the open function or the openat function. \n\n```C\n#include <fcntl.h>\nint open(const char *path, int oflag, ... /* mode_t mode */ );\nint openat(int fd, const char *path, int oflag, ... /* mode_t mode */ );\n// Both return: file descriptor if OK, −1 on error\n```\n\n最后一个参数是`…`，这是ISO C定义剩下的多个参数的方式。对这些函数来说，只有当新文件被创建时，最后一个参数才被使用，后面我们会讲。在这个原型中我们把这个参数写作一个注释。\n\npath这个参数是要打开或者要创建的文件的名字。这个函数有多种操作，定在在oflag参数里。这个参数由下列一个或者多个定义在`<fcntl.h>`头文件中的常量通过或操作构成：\n\nO_RDONLY\tOpen for reading only\n\nO_WRONLY\tOpen for writing only\n\nO_RDWR\tOpen for reading and writing\n\n> Most implementations define O_RDONLY as 0, O_WRONLY as 1, and O_RDWR as 2, for compatibility with older programs.  **为了兼容老程序，许多实现定义O_RDONLY as 0, O_WRONLY as 1, and O_RDWR as 2**。\n\nO_EXEC\t\tOpen for execute only\n\nO_SEARCH\tOpen for search only(applies to directories)\n\n> The purpose of the O_SEARCH constant is to evaluate search permissions at the time a directory is opened. Further operations using the directory’s file descriptor will not reevaluate permission to search the directory. None of the versions of the operating systems covered in this book support O_SEARCH yet. \n\nOne and only one of the previous five constants must be specified. The following constants are optional: \n\n上面的五个常量有且只有一个必须被明确。接下来的是可选常量：\n\nO_APPEND\tAppend to the end of file on each write. We describe this option in detail in Section 3.11. \n\nO_CLOEXEC\tSet the FD_CLOEXEC file descriptor flag. We discuss file descriptor flags in Section 3.14. \n\nO_CREAT\tCreate the file if it doesn’t exist. This option requires a third argument to the open function (a fourth argument to the openat function) — the mode, which specifies the access permission bits of the new file. (When we describe a file’s access permission bits in Section 4.5, we’ll see how to specify the mode and how it can be modified by the umask value of a process.)  创建一个文件，如果不存在。这个操作需要open函数的第三个参数（openat函数的第四个参数）— mode，**它明确了这个新文件的访问权限位**。（当我们在第4.5章节讨论文件的访问权限位，我们将看到如何明确mode，以及它如何修改进程的umask值。）\n\nO_DIRECTORY\tGenerate an error if path doesn’t refer to a directory. \n\nO_EXCL\t\tGenerate an error if O_CREAT is also specified and the file already exists. This test for whether the file already exists and the creation of the file if it doesn’t exist is an atomic operation. We describe atomic operations in more detail in Section 3.11.  如果O_CREAT被使用了且文件已经存在就会生成一个错误。这个常量的作用是检测文件是否存在如果文件不存在就创建，这是一个原子操作。我们将在第3.11章节讨论更多原子操作的细节。\n\nO_NOCTTY\tIf path refers to a terminal device, do not allocate the device as the controlling terminal for this process. We talk about controlling terminals in Section 9.6.  如果这个路径指向的是终端设备，则不将这个设备分配为此进程的控制终端。\n\nO_NONBLOCK\tIf path refers to a FIFO, a block special file, or a character special file, this option sets the nonblocking mode for both the opening of the file and subsequent I/O. We describe this mode in Section 14.2.  如果path指向FIFO（先进先出），一个块特殊文件，一个字符特殊文件，这个选项设置了非阻塞模式为本次的打开操作和后续的I/O操作。\n\n> In earlier releases of System V, the O_NDELAY (no delay) flag was introduced. This option is similar to the O_NONBLOCK (nonblocking) option, but an ambiguity was introduced in the return value from a read operation. The no-delay option causes a read operation to return 0 if there is no data to be read from a pipe, FIFO, or device, but this conflicts with a return value of 0, indicating an end of file. SVR4-based systems still support the no-delay option, with the old semantics, but new applications should use the nonblocking option instead.  在早期的System V，有一个O_NDELAY(no delay)符号。这个符号和O_NONBLOCK(nonblocking)选项相似，但他的读操作返回值具有二义性。如果管道，先进先出，或者设备没有数据可读，no-delay选项就会造成read操作返回0，这与end of file造成的返回值0冲突了。虽然基于SVR4的系统还支持这个no-delay选项，但新的应用应该使用nonblocking选项。\n\nO_SYNC\t\tHave each write wait for physical I/O to complete, including I/O necessary to update file attributes modified as a result of the write. We use this option in Section 3.14.  使每次write都等物理I/O完成，包括更新文件属性所需要的I/O。\n\nO_TTY_INIT\tWhen opening a terminal device that is not already open, set the nonstandard termios parameters to values that result in behavior that conforms to the Single UNIX Specification. We discuss the termios structure when we discuss terminal I/O in Chapter 18.  当打开一个新的终端设备的时候，设置非标准参数 termios。\n\nThe following two flags are also optional. They are part of the synchronized input and output option of the Single UNIX Specification (and thus POSIX.1). \n\nO_DSYNC\tHave each write wait for physical I/O to complete, but don’t wait for file attributes to be updated if they don’t affect the ability to read the data just written.  让所有write都等待物理I/O完成，但是不用等文件属性更新，如果不影响刚刚写完的数据的读操作的话。\n\nO_RSYNC\tHave each read operation on the file descriptor wait until any pending writes for the same portion of the file are complete.  使每个使用文件描述符的的读操作等待，直到对文件的同一部分的所有写操作完成。\n\n> Solaris 10 supports all three synchronization flags. Historically, FreeBSD (and thus Mac OS X) have used the O_FSYNC flag, which has the same behavior as O_SYNC. Because the two flags are equivalent, they define the flags to have the same value. FreeBSD 8.0 doesn’t support the O_DSYNC or O_RSYNC flags. Mac OS X doesn’t support the O_RSYNC flag, but defines the O_DSYNC flag, treating it the same as the O_SYNC flag. Linux 3.2.0 supports the O_DSYNC flag, but treats the O_RSYNC flag the same as O_SYNC. \n\n**The file descriptor returned by open and openat is guaranteed to be the lowest- numbered unused descriptor**. This fact is used by some applications to open a new file on standard input, standard output, or standard error. **For example, an application might close standard output—normally, file descriptor 1—and then open another file, knowing that it will be opened on file descriptor 1**. We’ll see a better way to guarantee that a file is open on a given descriptor in Section 3.12, when we explore the dup2 function. \n\n**The fd parameter** distinguishes the openat function from the open function. There are three possibilities:\n\n1. The path parameter specifies an absolute pathname. In this case, the fd parameter is ignored and the openat function behaves like the open function. \n\n2. The path parameter specifies a relative pathname and the fd parameter is a file descriptor that specifies the starting location in the file system where the relative pathname is to be evaluated. The fd parameter is obtained by opening the directory where the relative pathname is to be evaluated. \n\n3. The path parameter specifies a relative pathname and the fd parameter has the special value AT_FDCWD. In this case, the pathname is evaluated starting in the current working directory and the openat function behaves like the open function. \n\nThe openat function is one of a class of functions added to the latest version of POSIX.1 to address two problems. First, it gives threads a way to use relative pathnames to open files in directories other than the current working directory. As we’ll see in Chapter 11, all threads in the same process share the same current working directory, so this makes it difficult for multiple threads in the same process to work in different directories at the same time. Second, it provides a way to avoid time-of-check- to-time-of-use (TOCTTOU) errors.  openat函数是在最后一个版本的POSIX.1加入的，为了解决两个问题。首先，它给线程以相对路径而非当前路径。我们将在第11章看到，在同一进程中的所有线程共享同一个当前目录，所以要让同一进程中的多线程同时在不同的目录工作是非常困难的。第二，它提供了避免 time-of-check-to-time-of-use（TOCTTOU） 错误。\n\nThe basic idea behind TOCTTOU errors is that a program is vulnerable if it makes two file-based function calls where the second call depends on the results of the first call. Because the two calls are not atomic, the file can change between the two calls, thereby invalidating the results of the first call, leading to a program error. TOCTTOU errors in the file system namespace generally deal with attempts to subvert file system permissions by tricking a privileged program into either reducing permissions on a privileged file or modifying a privileged file to open up a security hole. Wei and Pu [2005] discuss TOCTTOU weaknesses in the UNIX file system interface.  TOCTTOU错误的意思是，一个调用横叉一脚影响了另一个调用，本来另一个调用应该是一个原子操作。\n\n### Filename and Pathname Truncation \n\nWhat happens if NAME_MAX is 14 and we try to create a new file in the current directory with a filename containing 15 characters? Traditionally, early releases of System V, such as SVR2, allowed this to happen, silently truncating the filename beyond the 14th character. BSD-derived systems, in contrast, returned an error status, with errno set to ENAMETOOLONG. Silently truncating the filename presents a problem that affects more than simply the creation of new files. If NAME_MAX is 14 and a file exists whose name is exactly 14 characters, any function that accepts a pathname argument, such as open or stat, has no way to determine what the original name of the file was, as the original name might have been truncated.  如果NAME_MAX是14怎么办？传统上，早期的System V系统，允许这发生，静默的将文件名截断成14字符。相反的，BSD派生的系统，返回一个错误状态，并把errno设置成ENAMETOOLONG。静默的截断文件名呈现的问题不仅仅是创建了一个新文件。如果NAME_MAX是14且文件存在，且它的名字就是14字符，任何接收一个路径名作为参数的函数，比如open或者stat，没办法判断文件原来的名字是什么，因为原始文件名可能已经被截断。\n\nWith POSIX.1, the constant `_POSIX_NO_TRUNC` determines whether long filenames and long components of pathnames are truncated or an error is returned. As we saw in Chapter 2, this value can vary based on the type of the file system, and we can use fpathconf or pathconf to query a directory to see which behavior is supported.  在POSIX.1标准里，常量 `_POSIX_NO_TRUNC` 决定长文件名和路径名中长的组件是否被截断或者是否返回一个错误。正如我们在第二章中看到的，这个值在文件系统中是非常基本的，我们可以使用 `fpathconf` 或 `pathconf`查询一个目录看看它支持哪种行为。\n\n> Whether an error is returned is largely historical. For example, SVR4-based systems do not generate an error for the traditional System V file system, S5. For the BSD-style file system (known as UFS), however, SVR4-based systems do generate an error. Figure 2.20 illustrates another example: Solaris will return an error for UFS, but not for PCFS, the DOS-compatible file system, as DOS silently truncates filenames that don’t fit in an 8.3 format. BSD-derived systems and Linux always return an error. \n\nIf _POSIX_NO_TRUNC is in effect, errno is set to ENAMETOOLONG, and an error status is returned if any filename component of the pathname exceeds NAME_MAX. \n\n> Most modern file systems support a maximum of 255 characters for filenames. Because filenames are usually shorter than this limit, this constraint tends to not present problems for most applications. \n\n### creat Function\n\nA new file can also be created by calling the creat function. \n\n```C\n#include <fcntl.h>\nint creat(const char *path, mode_t mode);\n// Returns: file descriptor opened for write-only if OK, −1 on error\n```\n\nNote that this function is equivalent to \n\n```C\nopen(path, O_WRONLY | O_CREAT | O_TRUNC, mode);\n```\n\n> Historically, in early versions of the UNIX System, the second argument to open could be only 0, 1, or 2. There was no way to open a file that didn’t already exist. Therefore, a separate system call, creat, was needed to create new files. With the O_CREAT and O_TRUNC options now provided by open, a separate creat function is no longer needed.  这个函数诞生的原因是：历史上open函数的第二个参数只支持0，1，2这三个值，也就是读，写，读写。没办法打开一个不存在的文件。而现在有了O_CREAT and O_TRUNC options，creat函数也就没有存在的必要了。\n\nWe’ll show how to specify mode in Section 4.5 when we describe a file’s access permissions in detail. \n\nOne deficiency with creat is that the file is opened only for writing. Before the new version of open was provided, if we were creating a temporary file that we wanted to write and then read back, we had to call creat, close, and then open. A better way is to use the open function, as in \n\n```C\nopen(path, O_RDWR | O_CREAT | O_TRUNC, mode);\n```\n\n### close Function\n\nAn open file is closed by calling the close function. \n\n```C\n#include <unistd.h> \n\n// Returns: 0 if OK, −1 on error\nint close(int fd);\n```\n\nClosing a file also releases any record locks that the process may have on the file. We’ll discuss this point further in Section 14.3.  关闭一个文件同样会释放进程对该文件的所有锁。\n\nWhen a process terminates, all of its open files are closed automatically by the kernel. Many programs take advantage of this fact and don’t explicitly close open files. See the program in Figure 1.4, for example.  当一个进程终止，所有它打开的文件都会被内核自动关闭。许多程序利用了这一点，不明确关闭文件。\n\n### lseek Function\n\nEvery open file has an associated ‘‘current file offset,’’ normally a non-negative integer that measures the number of bytes from the beginning of the file. (We describe some exceptions to the ‘‘non-negative’’ qualifier later in this section.) Read and write operations normally start at the current file offset and cause the offset to be incremented by the number of bytes read or written. By default, this offset is initialized to 0 when a file is opened, unless the O_APPEND option is specified.  每个打开的文件都与 \"current file offset\"关联，正常情况下它是一个非负整形数，表示从文件开始到目前位置的字节数。读和写操作都是从 current file offset开始的，并且会让offset增加，随着读和写的进行。默认的，当文件被打开时，这个位移初始化时0，除非指明了O_APPEND选项。\n\nAn open file’s offset can be set explicitly by calling lseek.  通过调用 lseek函数，一个打开的文件的offset可以被设定。\n\n```C\n#include <unistd.h>\noff_t lseek(int fd, off_t offset, int whence);\n// Returns: new file offset if OK, −1 on error\n```\n\nThe interpretation of the offset depends on the value of the whence argument. \n\n- If whence is SEEK_SET, the file’s offset is set to offset bytes from the beginning of \n\n  the file. \n\n- If whence is SEEK_CUR, the file’s offset is set to its current value plus the offset. \n\n  The offset can be positive or negative. \n\n- If whence is SEEK_END, the file’s offset is set to the size of the file plus the offset. \n\n  The offset can be positive or negative.\n\nBecause a successful call to lseek returns the new file offset, we can seek zero bytes \n\nfrom the current position to determine the current offset: \n\n```C\noff_t    currpos;\ncurrpos = lseek(fd, 0, SEEK_CUR);\n```\n\nThis technique can also be used to determine if a file is capable of seeking. If the file descriptor refers to a pipe, FIFO, or socket, lseek sets errno to **ESPIPE** and returns −1.  \n\n> The three symbolic constants—SEEK_SET, SEEK_CUR, and SEEK_END—were introduced with System V. Prior to this, **whence was specified as 0 (absolute), 1 (relative to the current offset), or 2 (relative to the end of file). Much software still exists with these numbers hard coded**. \n>\n> **The character l in the name lseek means ‘‘long integer.’’ Before the introduction of the off_t data type, the offset argument and the return value were long integers**. lseek was introduced with Version 7 when long integers were added to C. (Similar functionality was provided in Version 6 by the functions seek and tell.) \n\n### Example\n\nThe program in Figure 3.1 tests its standard input to see whether it is capable of seeking. \n\n> Figure 3.1 Test whether standard input is capable of seeking \n\n```C\n#include \"apue.h\"\nint main(void)\n{\n    if (lseek(STDIN_FILENO, 0, SEEK_CUR) == -1)\n        printf(\"cannot seek\\n\");\n    else\n        printf(\"seek OK\\n\");\n \texit(0); \n}\n```\n\n**Normally, a file’s current offset must be a non-negative integer. It is possible, however, that certain devices could allow negative offsets. But for regular files, the offset must be non-negative. Because negative offsets are possible, we should be careful to compare the return value from lseek as being equal to or not equal to −1, rather than testing whether it is less than 0**. \n\n> The /dev/kmem device on FreeBSD for the Intel x86 processor supports negative offsets. Because the offset (off_t) is a signed data type (Figure 2.21), we lose a factor of 2 in the maximum file size. If off_t is a 32-bit integer, the maximum file size is $2^{31}$−1 bytes. \n>\n\nlseek only records the current file offset within the kernel — it does not cause any I/O to take place. This offset is then used by the next read or write operation. \n\nThe file’s offset can be greater than the file’s current size, in which case the next write to the file will extend the file. This is referred to as creating a hole in a file and is allowed. Any bytes in a file that have not been written are read back as 0.  文件偏移量可以大于文件的目前大小，在这种情况下下一次写文件将扩展文件。也就是说在文件中创建一个空洞是被允许的。在文件中任何没被写入的部分都将被读作0。\n\nA hole in a file isn’t required to have storage backing it on disk. Depending on the file system implementation, when you write after seeking past the end of a file, new disk blocks might be allocated to store the data, but there is no need to allocate disk blocks for the data between the old end of file and the location where you start writing.  文件中的空洞并不需要存储到磁盘上。根据文件系统的实现，当你在end of file之后写，为了存储数据新的磁盘空间可能会分配，但没有必要分配磁盘块给end of file和你开始写的地方之间的这些数据。\n\n### Example\n\nThe program shown in Figure 3.2 creates a file with a hole in it. \n\n> Figure 3.2  Create a file with a hole in it \n\n```C\n#include \"apue.h\"\n#include <fcntl.h>\nchar    buf1[] = \"abcdefghij\";\nchar    buf2[] = \"ABCDEFGHIJ\";\nint main(void)\n{\n\tint fd;\n    if ((fd = creat(\"file.hole\", FILE_MODE)) < 0)\n    \terr_sys(\"creat error\");\n    if (write(fd, buf1, 10) != 10)\n    \terr_sys(\"buf1 write error\");\n    /* offset now = 10 */\n    if (lseek(fd, 16384, SEEK_SET) == -1)\n    \terr_sys(\"lseek error\");\n    /* offset now = 16384 */\n    if (write(fd, buf2, 10) != 10)\n        err_sys(\"buf2 write error\");\n    /* offset now = 16394 */\n\texit(0); \n}\n```\n\n## File Sharing\n\nThe UNIX System supports the sharing of open files among different processes. Before describing the dup function, we need to describe this sharing. To do this, we’ll examine the data structures used by the kernel for all I/O. \n\n> The following description is conceptual; it may or may not match a particular implementation. Refer to Bach [1986] for a discussion of these structures in System V. McKusick et al. [1996] describe these structures in 4.4BSD. McKusick and Neville-Neil [2005] cover FreeBSD 5.2. For a similar discussion of Solaris, see McDougall and Mauro [2007]. The Linux 2.6 kernel architecture is discussed in Bovet and Cesati [2006]. \n\nThe kernel uses three data structures to represent an open file, and the relationships among them determine the effect one process has on another with regard to file sharing. \n\n1. Every process has an entry in the process table. Within each process table entry is a table of open file descriptors, which we can think of as a vector, with one entry per descriptor. Associated with each file descriptor are \n   1. The file descriptor flags (close-on-exec; refer to Figure 3.7 and Section 3.14) \n   2. A pointer to a file table entry \n\n2. The kernel maintains a file table for all open files. Each file table entry contains \n   1. The file status flags for the file, such as read, write, append, sync, and nonblocking; more on these in Section 3.14 \n   2. The current file offset \n   3. A pointer to the v-node table entry for the file \n\n3. Each open file (or device) has a v-node structure that **contains information about the type of file** and **pointers to functions that operate on the file**. For most files, the v-node also contains the i-node for the file. **This information is read from disk when the file is opened**, so that all the pertinent information about the file is readily available. For example, **the i-node contains the owner of the file, the size of the file, pointers to where the actual data blocks for the file are located on disk**, and so on. (We talk more about i-nodes in Section 4.14 when we describe the typical UNIX file system in more detail.) \n\n> Linux has no v-node. Instead, a generic i-node structure is used. Although the implementations differ, the v-node is conceptually the same as a generic i-node. Both point to an i-node structure specific to the file system.\n\nWe’re ignoring some implementation details that don’t affect our discussion. For example, the table of open file descriptors can be stored in the user area (a separate per- process structure that can be paged out) instead of the process table. Also, these tables can be implemented in numerous ways—they need not be arrays; one alternate implementation is a linked lists of structures. Regardless of the implementation details, the general concepts remain the same. \n\nFigure 3.7 shows a pictorial arrangement of these three tables for a single process that has two different files open: one file is open on standard input (file descriptor 0), and the other is open on standard output (file descriptor 1). \n\n<img src=\"https://i.loli.net/2018/05/30/5b0e51e54c6d1.png\">\n\nThe arrangement of these three tables has existed since the early versions of the UNIX System [Thompson 1978]. **This arrangement is critical to the way files are shared among processes**. We’ll return to this figure in later chapters, when we describe additional ways that files are shared. \n\n> **The v-node was invented to provide support for multiple file system types on a single computer system**. This work was done independently by Peter Weinberger (Bell Laboratories) and Bill Joy (Sun Microsystems). **Sun called this the Virtual File System and called the file system–independent portion of the i-node the v-node** [Kleiman 1986]. The v-node propagated through various vendor implementations as support for Sun’s Network File System (NFS) was added. The first release from Berkeley to provide v-nodes was the 4.3BSD Reno release, when NFS was added. \n\n> In SVR4, the v-node replaced the file system–independent i-node of SVR3. Solaris is derived from SVR4 and, therefore, uses v-nodes. \n\n> Instead of splitting the data structures into a v-node and an i-node, Linux uses a file system–independent i-node and a file system–dependent i-node. \n\nIf two independent processes have the same file open, we could have the arrangement shown in Figure 3.8. \n\n<img src=\"https://i.loli.net/2018/05/30/5b0e5b6638838.png\">\n\nWe assume here that the first process has the file open on descriptor 3 and that the second process has that same file open on descriptor 4. Each process that opens the file gets its own file table entry, but only a single v-node table entry is required for a given file. One reason each process gets its own file table entry is so that each process has its own current offset for the file. \n\nGiven these data structures, we now need to be more specific about what happens with certain operations that we’ve already described. \n\n- After each write is complete, the current file offset in the file table entry is incremented by the number of bytes written. If this causes the current file offset to exceed the current file size, the current file size in the i-node table entry is set to the current file offset (for example, the file is extended). \n- If a file is opened with the O_APPEND flag, a corresponding flag is set in the file status flags of the file table entry. Each time a write is performed for a file with this append flag set, the current file offset in the file table entry is first set to the current file size from the i-node table entry. This forces every write to be appended to the current end of file. \n- If a file is positioned to its current end of file using lseek, all that happens is the current file offset in the file table entry is set to the current file size from the i-node table entry. (Note that this is not the same as if the file was opened with the O_APPEND flag, as we will see in Section 3.11.) \n- The lseek function modifies only the current file offset in the file table entry. No I/O takes place. \n\nIt is possible for more than one file descriptor entry to point to the same file table entry, as we’ll see when we discuss the dup function in Section 3.12. This also happens after a fork when the parent and the child share the same file table entry for each open descriptor (Section 8.3). \n\n**Note the difference in scope between the file descriptor flags and the file status flags. The former apply only to a single descriptor in a single process, whereas the latter apply to all descriptors in any process that point to the given file table entry**. When we describe the fcntl function in Section 3.14, we’ll see how to fetch and modify both the file descriptor flags and the file status flags. \n\nEverything that we’ve described so far in this section works fine for multiple processes that are reading the same file. Each process has its own file table entry with its own current file offset. Unexpected results can arise, however, when multiple processes write to the same file. To see how to avoid some surprises, we need to understand the concept of atomic operations. \n\n## Atomic Operations\n\n### Appending to a File\n\nConsider a single process that wants to append to the end of a file. Older versions of the UNIX System didn’t support the O_APPEND option to open, so the program was coded as follows: \n\n```C\nif (lseek(fd, 0L, 2) < 0)         /* position to EOF */\n\terr_sys(\"lseek error\");\nif (write(fd, buf, 100) != 100)   /* and write */\n\terr_sys(\"write error\");\n```\n\nThis works fine for a single process, but problems arise if multiple processes use this technique to append to the same file. (This scenario can arise if multiple instances of the same program are appending messages to a log file, for example.) \n\nAssume that two independent processes, A and B, are appending to the same file. Each has opened the file but without the O_APPEND flag. This gives us the same picture as Figure 3.8. Each process has its own file table entry, but they share a single v-node table entry. Assume that process A does the lseek and that this sets the current offset for the file for process A to byte offset 1,500 (the current end of file). Then the kernel switches processes, and B continues running. Process B then does the lseek, which sets the current offset for the file for process B to byte offset 1,500 also (the current end of file). Then B calls write, which increments B’s current file offset for the file to 1,600. Because the file’s size has been extended, the kernel also updates the current file size in the v-node to 1,600. Then the kernel switches processes and A resumes. When A calls write, the data is written starting at the current file offset for A, which is byte offset 1,500. This overwrites the data that B wrote to the file. \n\nThe problem here is that our logical operation of ‘‘position to the end of file and write’’ requires two separate function calls (as we’ve shown it). The solution is to have the positioning to the current end of file and the write be an atomic operation with regard to other processes. Any operation that requires more than one function call cannot be atomic, as there is always the possibility that the kernel might temporarily suspend the process between the two function calls (as we assumed previously). \n\nThe UNIX System provides an atomic way to do this operation if we set the O_APPEND flag when a file is opened. As we described in the previous section, this causes the kernel to position the file to its current end of file before each write. We no longer have to call lseek before each write. \n\n### pread and pwrite Functions\n\nThe Single UNIX Specification includes two functions that allow applications to seek and perform I/O atomically: pread and pwrite. \n\n```C\n#include <unistd.h>\n\n// Returns: number of bytes read, 0 if end of file, −1 on error\nssize_t pread(int fd, void *buf, size_t nbytes, off_t offset);\n\n// Returns: number of bytes written if OK, −1 on error\nssize_t pwrite(int fd, const void *buf, size_t nbytes, off_t offset); \n```\n\nCalling pread is equivalent to calling lseek followed by a call to read, with the following exceptions. \n\n- There is no way to interrupt the two operations that occur when we call pread. \n\n- The current file offset is not updated. \n\nCalling pwrite is equivalent to calling lseek followed by a call to write, with similar exceptions. \n\n### Creating a File\n\nWe saw another example of an atomic operation when we described the O_CREAT and O_EXCL options for the open function. When both of these options are specified, the open will fail if the file already exists. We also said that the check for the existence of the file and the creation of the file was performed as an atomic operation. If we didn’t have this atomic operation, we might try \n\n```C\nif ((fd = open(path, O_WRONLY)) < 0) {\n    if (errno == ENOENT) {\n        if ((fd = creat(path, mode)) < 0)\n            err_sys(\"creat error\");\n    } else {\n        err_sys(\"open error\");\n} }\n```\n\nThe problem occurs if the file is created by another process between the open and the creat. If the file is created by another process between these two function calls, and if that other process writes something to the file, that data is erased when this creat is executed. Combining the test for existence and the creation into a single atomic operation avoids this problem. \n\nIn general, the term atomic operation refers to an operation that might be composed of multiple steps. If the operation is performed atomically, either all the steps are performed (on success) or none are performed (on failure). It must not be possible for only a subset of the steps to be performed. We’ll return to the topic of atomic operations when we describe the link function (Section 4.15) and record locking (Section 14.3). \n\n## dup and dup2 Functions\n\nAn existing file descriptor is duplicated by either of the following functions: \n\n```C\n#include <unistd.h>\n\n// Both return: new file descriptor if OK, −1 on error\nint dup(int fd);\nint dup2(int fd, int fd2);\n```\n\nThe new file descriptor returned by dup is guaranteed to be the lowest-numbered available file descriptor. **With dup2, we specify the value of the new descriptor with the fd2 argument. If fd2 is already open, it is first closed. If fd equals fd2, then dup2 returns fd2 without closing it. Otherwise, the FD_CLOEXEC file descriptor flag is cleared for fd2, so that fd2 is left open if the process calls exec**.\n\nThe new file descriptor that is returned as the value of the functions shares the same file table entry as the fd argument. We show this in Figure 3.9. \n\n<img src=\"https://i.loli.net/2018/05/30/5b0e6c0a52034.png\">\n\nIn this figure, we assume that when it’s started, the process executes \n\n```C\nnewfd = dup(1);\n```\n\nWe assume that the next available descriptor is 3 (which it probably is, since 0, 1, and 2 are opened by the shell). Because both descriptors point to the same file table entry, they share the same file status flags—read, write, append, and so on—and the same current file offset. \n\nEach descriptor has its own set of file descriptor flags. As we describe in Section 3.14, the close-on-exec file descriptor flag for the new descriptor is always cleared by the dup functions. \n\nAnother way to duplicate a descriptor is with the fcntl function, which we describe in Section 3.14. Indeed, the call \n\n```C\ndup(fd);\n```\n\nis equivalent to \n\n```C\nfcntl(fd, F_DUPFD, 0);\n```\n\nSimilarly, the call \n\n```C\ndup2(fd, fd2);\n```\n\nis equivalent to \n\n```C\nclose(fd2);\nfcntl(fd, F_DUPFD, fd2);\n```\n\nIn this last case, the dup2 is not exactly the same as a close followed by an fcntl. The differences are as follows: \n\n1. dup2 is an atomic operation, whereas the alternate form involves two function calls. It is possible in the latter case to have a signal catcher called between the close and the fcntl that could modify the file descriptors. (We describe signals in Chapter 10.) The same problem could occur if a different thread changes the file descriptors. (We describe threads in Chapter 11.) \n2. There are some errno differences between dup2 and fcntl. \n\n> The dup2 system call originated with Version 7 and propagated through the BSD releases. The fcntl method for duplicating file descriptors appeared with System III and continued with SystemV. SVR3.2 picked up the dup2 function, and 4.2BSD picked up the fcntl function and the F_DUPFD functionality. POSIX.1 requires both dup2 and the F_DUPFD feature of fcntl. \n\n## sync, fsync, and fdatasync Functions\n\nTraditional implementations of the UNIX System have a buffer cache or page cache in the kernel through which most disk I/O passes. When we write data to a file, the data is normally copied by the kernel into one of its buffers and queued for writing to disk at some later time. This is called delayed write. (Chapter 3 of Bach [1986] discusses this buffer cache in detail.) \n\nThe kernel eventually writes all the delayed-write blocks to disk, normally when it needs to reuse the buffer for some other disk block. To ensure consistency of the file system on disk with the contents of the buffer cache, the sync, fsync, and fdatasync functions are provided. \n\n```C\n#include <unistd.h> \n\n// Both Returns: 0 if OK, −1 on error\nint fsync(int fd); \nint fdatasync(int fd);\n\nvoid sync(void);\n```\n\n**The sync function simply queues all the modified block buffers for writing and returns; it does not wait for the disk writes to take place**. \n\n**The function sync is normally called periodically (usually every 30 seconds) from a system daemon, often called update**. This guarantees regular flushing of the kernel’s block buffers. The command sync(1) also calls the sync function. \n\nThe function fsync refers only to a single file, specified by the file descriptor fd, and **waits for the disk writes to complete before returning**. This function is used when an application, **such as a database**, needs to be sure that the modified blocks have been written to the disk. \n\n**The fdatasync function is similar to fsync, but it affects only the data portions of a file. With fsync, the file’s attributes are also updated synchronously**. \n\n> All four of the platforms described in this book support sync and fsync. However, FreeBSD 8.0 does not support fdatasync. \n\n## fcntl Function\n\nThe fcntl function can change the properties of a file that is already open. \n\n```C\n#include <fcntl.h>\n\n// Returns: depends on cmd if OK (see following), −1 on error\nint fcntl(int fd, int cmd, ... /* int arg */ );\n```\n\nIn the examples in this section, the third argument is always an integer, corresponding to the comment in the function prototype just shown. When we describe record locking in Section 14.3, however, the third argument becomes a pointer to a structure. \n\nThe fcntl function is used for five different purposes. \n\n1. Duplicate an existing descriptor (cmd = F_DUPFD or F_DUPFD_CLOEXEC) \n\n2. Get/set file descriptor flags (cmd = F_GETFD or F_SETFD) \n\n3. Get/set file status flags (cmd = F_GETFL or F_SETFL) \n\n4. Get/set asynchronous I/O ownership (cmd = F_GETOWN or F_SETOWN) \n\n5. Get/set record locks (cmd = F_GETLK, F_SETLK, or F_SETLKW) \n\nWe’ll now describe the first 8 of these 11 cmd values. (We’ll wait until Section 14.3 to describe the last 3, which deal with record locking.) Refer to Figure 3.7, as we’ll discuss both the file descriptor flags associated with each file descriptor in the process table entry and the file status flags associated with each file table entry. \n\nF_DUPFD \tDuplicate the file descriptor fd. The new file descriptor is returned as the value of the function. It is the lowest-numbered descriptor that is not already open, and that is greater than or equal to the third argument (taken as an integer). The new descriptor shares the same file table entry as fd. (Refer to Figure 3.9.) But the new descriptor has its own set of file descriptor flags, and its FD_CLOEXEC file descriptor flag is cleared. (This means that the descriptor is left open across an exec, which we discuss in Chapter 8.) \n\nF_DUPFD_CLOEXEC\tDuplicate the file descriptor and set the FD_CLOEXEC file descriptor flag associated with the new descriptor. Returns the new file descriptor. \n\nF_GETFD \tReturn the file descriptor flags for fd as the value of the function. Currently, only one file descriptor flag is defined: the FD_CLOEXEC flag. \n\nF_SETFD \tSet the file descriptor flags for fd. The new flag value is set from the third argument (taken as an integer). \n\n> Be aware that some existing programs that deal with the file descriptor flags don’t use the constant FD_CLOEXEC. Instead, these programs set the flag to either 0 (don’t close-on-exec, the default) or 1 (do close-on-exec). \n\nF_GETFL \tReturn the file status flags for fd as the value of the function. We described the file status flags when we described the open function. They are listed in Figure 3.10. \n\n<img src=\"https://i.loli.net/2018/05/31/5b0f49576d719.png\" width=\"70%\">\n\nUnfortunately, the five access-mode flags—O_RDONLY, O_WRONLY, O_RDWR, O_EXEC, and O_SEARCH—are not separate bits that can be tested. (As we mentioned earlier, the first three often have the values 0, 1, and 2, respectively, for historical reasons. Also, these five values are mutually exclusive; a file can have only one of them enabled.) Therefore, we must first use the O_ACCMODE mask to obtain the access-mode bits and then compare the result against any of the five values. \n\nF_SETFL \t\tSet the file status flags to the value of the third argument (taken as an integer). The only flags that can be changed are O_APPEND, O_NONBLOCK, O_SYNC, O_DSYNC, O_RSYNC, O_FSYNC, and O_ASYNC. \n\nF_GETOWN \tGet the process ID or process group ID currently receiving the SIGIO and SIGURG signals. We describe these asynchronous I/O signals in Section 14.5.2. \n\nF_SETOWN \tSet the process ID or process group ID to receive the SIGIO and SIGURG signals. A positive arg specifies a process ID. A negative arg implies a process group ID equal to the absolute value of arg. \n\nThe return value from fcntl depends on the command. All commands return −1 on an error or some other value if OK. The following four commands have special return values: F_DUPFD, F_GETFD, F_GETFL, and F_GETOWN. The first command returns the new file descriptor, the next two return the corresponding flags, and the final command returns a positive process ID or a negative process group ID. \n\n### Example\n\nThe program in Figure 3.11 takes a single command-line argument that specifies a file descriptor and prints a description of selected file flags for that descriptor. \n\n> Figure 3.11 Print file flags for specified descriptor \n\n```C\n#include \"include/apue.h\"\n#include <fcntl.h>\nint main(int argc, char *argv[])\n{\n  int val;\n  if (argc != 2)\n     err_quit(\"usage: a.out <descriptor#>\");\n  if ((val = fcntl(atoi(argv[1]), F_GETFL, 0)) < 0)\n     err_sys(\"fcntl error for fd %d\", atoi(argv[1]));\n  switch (val & O_ACCMODE) {\n    case O_RDONLY:\n       printf(\"read only\");\n       break;\n    case O_WRONLY:\n       printf(\"write only\");\n       break;\n    case O_RDWR:\n       printf(\"read write\");\n       break;\n    default:\n       err_dump(\"unknown access mode\");\n  }\n  if (val & O_APPEND)\n     printf(\", append\");\n  if (val & O_NONBLOCK)\n     printf(\", nonblocking\");\n  if (val & O_SYNC)\n    printf(\", synchronous writes\");\n    #if !defined(_POSIX_C_SOURCE) && defined(O_FSYNC) && (O_FSYNC != O_SYNC)\n         if (val & O_FSYNC)\n            printf(\", synchronous writes\");\n    #endif\n  putchar('\\n');\n  exit(0); \n}\n```\n\nNote that we use the feature test macro _POSIX_C_SOURCE and conditionally compile the file access flags that are not part of POSIX.1. The following script shows the operation of the program, when invoked from bash (the Bourne-again shell). Results will vary, depending on which shell you use. \n\n```shell\n➜  apue.3e ./fig3.11 0 < /dev/tty\nread only\n➜  apue.3e ./fig3.11 1 > temp.foo\n➜  apue.3e cat temp.foo\nwrite only\n➜  apue.3e ./fig3.11 2 2>>temp.foo\nwrite only, append\n➜  apue.3e ./fig3.11 5 5<>temp.foo\nread write\n```\n\nThe clause 5<>temp.foo opens the file temp.foo for reading and writing on file descriptor 5. \n\n### Example\n\nWhen we modify either the file descriptor flags or the file status flags, we must be careful to fetch the existing flag value, modify it as desired, and then set the new flag value. We can’t simply issue an F_SETFD or an F_SETFL command, as this could turn off flag bits that were previously set. \n\nFigure 3.12 shows a function that sets one or more of the file status flags for a descriptor. \n\n> Figure 3.12 Turn on one or more of the file status flags for a descriptor \n\n```C\n#include \"apue.h\"\n#include <fcntl.h>\nvoid set_fl(int fd, int flags) /* flags are file status flags to turn on */\n{\n\tint val;\n\tif ((val = fcntl(fd, F_GETFL, 0)) < 0)\n\t   err_sys(\"fcntl F_GETFL error\");\n\tval |= flags;       /* turn on flags */\n\tif (fcntl(fd, F_SETFL, val) < 0)\n\t   err_sys(\"fcntl F_SETFL error\");\n}\n```\n\nIf we change the middle statement to \n\n```C\nval &=  ̃flags;      /* turn flags off */\n```\n\nwe have a function named clr_fl, which we’ll use in some later examples. This statement logically ANDs the one’s complement of flags with the current val. \n\nIf we add the line \n\n```C\nset_fl(STDOUT_FILENO, O_SYNC);\n```\n\nto the beginning of the program shown in Figure 3.5, we’ll turn on the synchronous- write flag. This causes each write to wait for the data to be written to disk before returning. Normally in the UNIX System, a write only queues the data for writing; the actual disk write operation can take place sometime later. A database system is a likely candidate for using O_SYNC, so that it knows on return from a write that the data is actually on the disk, in case of an abnormal system failure. \n\nWe expect the O_SYNC flag to increase the system and clock times when the program runs. To test this, we can run the program in Figure 3.5, copying 492.6 MB of data from one file on disk to another and compare this with a version that does the same thing with the O_SYNC flag set. The results from a Linux system using the ext4 file system are shown in Figure 3.13. \n\n<img src=\"https://i.loli.net/2018/05/31/5b0f4c0dc6161.png\" width=\"80%\">\n\nThe six rows in Figure 3.13 were all measured with a BUFFSIZE of 4,096 bytes. The results in Figure 3.6 were measured while reading a disk file and writing to /dev/null, so there was no disk output. The second row in Figure 3.13 corresponds to reading a disk file and writing to another disk file. This is why the first and second rows in Figure 3.13 are different. The system time increases when we write to a disk file, because the kernel now copies the data from our process and queues the data for writing by the disk driver. We expect the clock time to increase as well when we write to a disk file. \n\nWhen we enable synchronous writes, the system and clock times should increase significantly. As the third row shows, the system time for writing synchronously is not much more expensive than when we used delayed writes. This implies that the Linux operating system is doing the same amount of work for delayed and synchronous writes (which is unlikely), or else the O_SYNC flag isn’t having the desired effect. In this case, the Linux operating system isn’t allowing us to set the O_SYNC flag using fcntl, instead failing without returning an error (but it would have honored the flag if we were able to specify it when the file was opened). \n\nThe clock time in the last three rows reflects the extra time needed to wait for all of the writes to be committed to disk. After writing a file synchronously, we expect that a call to fsync will have no effect. This case is supposed to be represented by the last row in Figure 3.13, but since the O_SYNC flag isn’t having the intended effect, the last row behaves the same way as the fifth row. \n\nFigure 3.14 shows timing results for the same tests run on Mac OS X 10.6.8, which uses the HFS file system. Note that the times match our expectations: synchronous writes are far more expensive than delayed writes, and using fsync with synchronous writes makes very little difference. Note also that adding a call to fsync at the end of the delayed writes makes little measurable difference. It is likely that the operating system flushed previously written data to disk as we were writing new data to the file, so by the time that we called fsync, very little work was left to be done. \n\n<img src=\"https://i.loli.net/2018/05/31/5b0f4c6873af3.png\" width=\"80%\">\n\nCompare fsync and fdatasync, both of which update a file’s contents when we say so, with the O_SYNC flag, which updates a file’s contents every time we write to the file. The performance of each alternative will depend on many factors, including the underlying operating system implementation, the speed of the disk drive, and the type of the file system. \n\nWith this example, we see the need for fcntl. Our program operates on a descriptor (standard output), never knowing the name of the file that was opened on that descriptor. We can’t set the O_SYNC flag when the file is opened, since the shell opened the file. With fcntl, we can modify the properties of a descriptor, knowing only the descriptor for the open file. We’ll see another need for fcntl when we describe nonblocking pipes (Section 15.2), since all we have with a pipe is a descriptor. \n\n## ioctl Function\n\nThe ioctl function has always been the catchall for I/O operations. Anything that couldn’t be expressed using one of the other functions in this chapter usually ended up being specified with an ioctl. Terminal I/O was the biggest user of this function. (When we get to Chapter 18, we’ll see that POSIX.1 has replaced the terminal I/O operations with separate functions.) \n\n```C\n#include <unistd.h>     /* System V */\n#include <sys/ioctl.h>  /* BSD and Linux */\n\n// Returns: −1 on error, something else if OK\nint ioctl(int fd, int request, ...);\n```\n\n> The ioctl function was included in the Single UNIX Specification only as an extension for dealing with STREAMS devices [Rago 1993], but it was moved to obsolescent status in SUSv4. UNIX System implementations use ioctl for many miscellaneous device operations. Some implementations have even extended it for use with regular files. \n\nThe prototype that we show corresponds to POSIX.1. FreeBSD 8.0 and Mac OS X 10.6.8 declare the second argument as an unsigned long. This detail doesn’t matter, since the second argument is always a #defined name from a header. \n\nFor the ISO C prototype, an ellipsis is used for the remaining arguments. Normally, however, there is only one more argument, and it’s usually a pointer to a variable or a structure. \n\nIn this prototype, we show only the headers required for the function itself. Normally, additional device-specific headers are required. For example, the ioctl commands for terminal I/O, beyond the basic operations specified by POSIX.1, all require the <termios.h> header. \n\nEach device driver can define its own set of ioctl commands. The system, however, provides generic ioctl commands for different classes of devices. Examples of some of the categories for these generic ioctl commands supported in FreeBSD are summarized in Figure 3.15. \n\n<img src=\"https://i.loli.net/2018/05/31/5b0f4cf6d20f6.png\" width=\"60%\">\n\nThe mag tape operations allow us to write end-of-file marks on a tape, rewind a tape, space forward over a specified number of files or records, and the like. None of these operations is easily expressed in terms of the other functions in the chapter (read, write, lseek, and so on), so the easiest way to handle these devices has always been to access their operations using ioctl. \n\nWe use the ioctl function in Section 18.12 to fetch and set the size of a terminal’s window, and in Section 19.7 when we access the advanced features of pseudo terminals. \n\n## /dev/fd\n\nNewer systems provide a directory named /dev/fd whose entries are files named 0, 1, 2, and so on. Opening the file /dev/fd/n is equivalent to duplicating descriptor n, assuming that descriptor n is open. \n\n> The /dev/fd feature was developed by Tom Duff and appeared in the 8th Edition of the Research UNIX System. It is supported by all of the systems described in this book: FreeBSD 8.0, Linux 3.2.0, Mac OS X 10.6.8, and Solaris 10. It is not part of POSIX.1. \n\nIn the function call \n\n```C\nfd = open(\"/dev/fd/0\", mode);\n```\n\nmost systems ignore the specified mode, whereas others require that it be a subset of the mode used when the referenced file (standard input, in this case) was originally opened. Because the previous open is equivalent to \n\n```C\nfd = dup(0);\n```\n\nthe descriptors 0 and fd share the same file table entry (Figure 3.9). For example, if descriptor 0 was opened read-only, we can only read on fd. Even if the system ignores the open mode and the call \n\n```C\nfd = open(\"/dev/fd/0\", O_RDWR);\n```\n\nsucceeds, we still can’t write to fd. \n\n> The Linux implementation of /dev/fd is an exception. It maps file descriptors into symbolic links pointing to the underlying physical files. When you open /dev/fd/0, for example, you are really opening the file associated with your standard input. Thus the mode of the new file descriptor returned is unrelated to the mode of the /dev/fd file descriptor. \n\nWe can also call creat with a /dev/fd pathname argument as well as specify O_CREAT in a call to open. This allows a program that calls creat to still work if the pathname argument is /dev/fd/1, for example. \n\n> Beware of doing this on Linux. Because the Linux implementation uses symbolic links to the real files, using creat on a /dev/fd file will result in the underlying file being truncated. \n\nSome systems provide the pathnames /dev/stdin, /dev/stdout, and /dev/stderr. These pathnames are equivalent to /dev/fd/0, /dev/fd/1, and /dev/fd/2, respectively. \n\nThe main use of the /dev/fd files is from the shell. It allows programs that use pathname arguments to handle standard input and standard output in the same manner as other pathnames. For example, the cat(1) program specifically looks for an input filename of - and uses it to mean standard input. The command \n\n```\nfilter file2 | cat file1 - file3 | lpr\n```\n\nis an example. First, cat reads file1, then its standard input (the output of the filter program on file2), and then file3. If /dev/fd is supported, the special handling of - can be removed from cat, and we can enter \n\n```\nfilter file2 | cat file1 /dev/fd/0 file3 | lpr\n```\n\nThe special meaning of - as a command-line argument to refer to the standard input or the standard output is a kludge that has crept into many programs. There are also problems if we specify - as the first file, as it looks like the start of another command-line option. Using /dev/fd is a step toward uniformity and cleanliness. \n\n## Summary\n\nThis chapter has described the basic I/O functions provided by the UNIX System. These are often called the unbuffered I/O functions because each read or write invokes a system call into the kernel. Using only read and write, we looked at the effect of various I/O sizes on the amount of time required to read a file. We also looked at several ways to flush written data to disk and their effect on application performance. \n\nAtomic operations were introduced when multiple processes append to the same file and when multiple processes create the same file. We also looked at the data structures used by the kernel to share information about open files. We’ll return to these data structures later in the text. \n\nWe also described the ioctl and fcntl functions. We return to both of these functions later in the book. In Chapter 14, we’ll use fcntl for record locking. In Chapter 18 and Chapter 19, we’ll use ioctl when we deal with terminal devices. \n\n## Exercises\n\n1. When reading or writing a disk file, are the functions described in this chapter really unbuffered? Explain. \n\n2. Write your own dup2 function that behaves the same way as the dup2 function described in Section 3.12, without calling the fcntl function. Be sure to handle errors correctly. \n\n3. Assume that a process executes the following three function calls: \n\n   ```C\n   fd1 = open(path, oflags);\n   fd2 = dup(fd1);\n   fd3 = open(path, oflags);\n   ```\n\n   Draw the resulting picture, similar to Figure 3.9. Which descriptors are affected by an fcntl on fd1 with a command of F_SETFD? Which descriptors are affected by an fcntl on fd1 with a command of F_SETFL? \n\n4. The following sequence of code has been observed in various programs: \n\n    ```C\n    dup2(fd, 0);\n    dup2(fd, 1);\n    dup2(fd, 2);\n    if (fd > 2)\n    ```\n\nclose(fd); \n\nTo see why the if test is needed, assume that fd is 1 and draw a picture of what happens to the three descriptor entries and the corresponding file table entry with each call to dup2. Then assume that fd is 3 and draw the same picture. ","slug":"APUE读书笔记—File-IO","published":1,"updated":"2018-06-03T03:19:44.410Z","layout":"post","photos":[],"link":"","_id":"cjm2w8ddw003ffgpxe5f5k33r","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>这章将的是文件IO，其中有几个非常重要的概念：</p>\n<ol>\n<li>File Desriptors，文件描述符</li>\n<li>current file offset，当前文件偏移量</li>\n<li>File Sharing Data Structure，文件共享数据模型</li>\n<li>file descriptor flags ，文件描述位</li>\n<li>file status flags ，文件状态位</li>\n</ol>\n<h2 id=\"File-Descriptors\"><a href=\"#File-Descriptors\" class=\"headerlink\" title=\"File Descriptors\"></a>File Descriptors</h2><ul>\n<li><p>对内核来说，所有 <strong>打开的文件</strong> 都使用file descriptor引用。</p>\n</li>\n<li><p>文件描述符是一个非负整数。当我们打开一个存在的文件或者创建一个新文件，内核返回一个文件描述符给进程。</p>\n</li>\n<li><p>当我们想要读或者写一个文件，我们通过文件描述符来确定这个文件，文件描述符是被open或者creat返回的，然后作为read或者write的一个参数。</p>\n</li>\n</ul>\n<blockquote>\n<p>文件描述符都使用尽可能小的非负整数，File descriptors range from 0 through OPEN_MAX−1. </p>\n</blockquote>\n<p>有三个magic number，0代表STDIN_FILENO，1代表STDOUT_FILENO，2代表STDERR_FILENO。虽然这已经是POSIX.1所定义的标准，但为了程序的可读性，还是不建议直接写数字。这三个常量定义在<code>&lt;unistd.h&gt;</code>中。</p>\n<h2 id=\"open-and-openat-Functions\"><a href=\"#open-and-openat-Functions\" class=\"headerlink\" title=\"open and openat Functions\"></a>open and openat Functions</h2><p>A file is opened or created by calling either the open function or the openat function. </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">open</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *path, <span class=\"keyword\">int</span> oflag, ... <span class=\"comment\">/* mode_t mode */</span> )</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">openat</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *path, <span class=\"keyword\">int</span> oflag, ... <span class=\"comment\">/* mode_t mode */</span> )</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// Both return: file descriptor if OK, −1 on error</span></span><br></pre></td></tr></table></figure>\n<p>最后一个参数是<code>…</code>，这是ISO C定义剩下的多个参数的方式。对这些函数来说，只有当新文件被创建时，最后一个参数才被使用，后面我们会讲。在这个原型中我们把这个参数写作一个注释。</p>\n<p>path这个参数是要打开或者要创建的文件的名字。这个函数有多种操作，定在在oflag参数里。这个参数由下列一个或者多个定义在<code>&lt;fcntl.h&gt;</code>头文件中的常量通过或操作构成：</p>\n<p>O_RDONLY    Open for reading only</p>\n<p>O_WRONLY    Open for writing only</p>\n<p>O_RDWR    Open for reading and writing</p>\n<blockquote>\n<p>Most implementations define O_RDONLY as 0, O_WRONLY as 1, and O_RDWR as 2, for compatibility with older programs.  <strong>为了兼容老程序，许多实现定义O_RDONLY as 0, O_WRONLY as 1, and O_RDWR as 2</strong>。</p>\n</blockquote>\n<p>O_EXEC        Open for execute only</p>\n<p>O_SEARCH    Open for search only(applies to directories)</p>\n<blockquote>\n<p>The purpose of the O_SEARCH constant is to evaluate search permissions at the time a directory is opened. Further operations using the directory’s file descriptor will not reevaluate permission to search the directory. None of the versions of the operating systems covered in this book support O_SEARCH yet. </p>\n</blockquote>\n<p>One and only one of the previous five constants must be specified. The following constants are optional: </p>\n<p>上面的五个常量有且只有一个必须被明确。接下来的是可选常量：</p>\n<p>O_APPEND    Append to the end of file on each write. We describe this option in detail in Section 3.11. </p>\n<p>O_CLOEXEC    Set the FD_CLOEXEC file descriptor flag. We discuss file descriptor flags in Section 3.14. </p>\n<p>O_CREAT    Create the file if it doesn’t exist. This option requires a third argument to the open function (a fourth argument to the openat function) — the mode, which specifies the access permission bits of the new file. (When we describe a file’s access permission bits in Section 4.5, we’ll see how to specify the mode and how it can be modified by the umask value of a process.)  创建一个文件，如果不存在。这个操作需要open函数的第三个参数（openat函数的第四个参数）— mode，<strong>它明确了这个新文件的访问权限位</strong>。（当我们在第4.5章节讨论文件的访问权限位，我们将看到如何明确mode，以及它如何修改进程的umask值。）</p>\n<p>O_DIRECTORY    Generate an error if path doesn’t refer to a directory. </p>\n<p>O_EXCL        Generate an error if O_CREAT is also specified and the file already exists. This test for whether the file already exists and the creation of the file if it doesn’t exist is an atomic operation. We describe atomic operations in more detail in Section 3.11.  如果O_CREAT被使用了且文件已经存在就会生成一个错误。这个常量的作用是检测文件是否存在如果文件不存在就创建，这是一个原子操作。我们将在第3.11章节讨论更多原子操作的细节。</p>\n<p>O_NOCTTY    If path refers to a terminal device, do not allocate the device as the controlling terminal for this process. We talk about controlling terminals in Section 9.6.  如果这个路径指向的是终端设备，则不将这个设备分配为此进程的控制终端。</p>\n<p>O_NONBLOCK    If path refers to a FIFO, a block special file, or a character special file, this option sets the nonblocking mode for both the opening of the file and subsequent I/O. We describe this mode in Section 14.2.  如果path指向FIFO（先进先出），一个块特殊文件，一个字符特殊文件，这个选项设置了非阻塞模式为本次的打开操作和后续的I/O操作。</p>\n<blockquote>\n<p>In earlier releases of System V, the O_NDELAY (no delay) flag was introduced. This option is similar to the O_NONBLOCK (nonblocking) option, but an ambiguity was introduced in the return value from a read operation. The no-delay option causes a read operation to return 0 if there is no data to be read from a pipe, FIFO, or device, but this conflicts with a return value of 0, indicating an end of file. SVR4-based systems still support the no-delay option, with the old semantics, but new applications should use the nonblocking option instead.  在早期的System V，有一个O_NDELAY(no delay)符号。这个符号和O_NONBLOCK(nonblocking)选项相似，但他的读操作返回值具有二义性。如果管道，先进先出，或者设备没有数据可读，no-delay选项就会造成read操作返回0，这与end of file造成的返回值0冲突了。虽然基于SVR4的系统还支持这个no-delay选项，但新的应用应该使用nonblocking选项。</p>\n</blockquote>\n<p>O_SYNC        Have each write wait for physical I/O to complete, including I/O necessary to update file attributes modified as a result of the write. We use this option in Section 3.14.  使每次write都等物理I/O完成，包括更新文件属性所需要的I/O。</p>\n<p>O_TTY_INIT    When opening a terminal device that is not already open, set the nonstandard termios parameters to values that result in behavior that conforms to the Single UNIX Specification. We discuss the termios structure when we discuss terminal I/O in Chapter 18.  当打开一个新的终端设备的时候，设置非标准参数 termios。</p>\n<p>The following two flags are also optional. They are part of the synchronized input and output option of the Single UNIX Specification (and thus POSIX.1). </p>\n<p>O_DSYNC    Have each write wait for physical I/O to complete, but don’t wait for file attributes to be updated if they don’t affect the ability to read the data just written.  让所有write都等待物理I/O完成，但是不用等文件属性更新，如果不影响刚刚写完的数据的读操作的话。</p>\n<p>O_RSYNC    Have each read operation on the file descriptor wait until any pending writes for the same portion of the file are complete.  使每个使用文件描述符的的读操作等待，直到对文件的同一部分的所有写操作完成。</p>\n<blockquote>\n<p>Solaris 10 supports all three synchronization flags. Historically, FreeBSD (and thus Mac OS X) have used the O_FSYNC flag, which has the same behavior as O_SYNC. Because the two flags are equivalent, they define the flags to have the same value. FreeBSD 8.0 doesn’t support the O_DSYNC or O_RSYNC flags. Mac OS X doesn’t support the O_RSYNC flag, but defines the O_DSYNC flag, treating it the same as the O_SYNC flag. Linux 3.2.0 supports the O_DSYNC flag, but treats the O_RSYNC flag the same as O_SYNC. </p>\n</blockquote>\n<p><strong>The file descriptor returned by open and openat is guaranteed to be the lowest- numbered unused descriptor</strong>. This fact is used by some applications to open a new file on standard input, standard output, or standard error. <strong>For example, an application might close standard output—normally, file descriptor 1—and then open another file, knowing that it will be opened on file descriptor 1</strong>. We’ll see a better way to guarantee that a file is open on a given descriptor in Section 3.12, when we explore the dup2 function. </p>\n<p><strong>The fd parameter</strong> distinguishes the openat function from the open function. There are three possibilities:</p>\n<ol>\n<li><p>The path parameter specifies an absolute pathname. In this case, the fd parameter is ignored and the openat function behaves like the open function. </p>\n</li>\n<li><p>The path parameter specifies a relative pathname and the fd parameter is a file descriptor that specifies the starting location in the file system where the relative pathname is to be evaluated. The fd parameter is obtained by opening the directory where the relative pathname is to be evaluated. </p>\n</li>\n<li><p>The path parameter specifies a relative pathname and the fd parameter has the special value AT_FDCWD. In this case, the pathname is evaluated starting in the current working directory and the openat function behaves like the open function. </p>\n</li>\n</ol>\n<p>The openat function is one of a class of functions added to the latest version of POSIX.1 to address two problems. First, it gives threads a way to use relative pathnames to open files in directories other than the current working directory. As we’ll see in Chapter 11, all threads in the same process share the same current working directory, so this makes it difficult for multiple threads in the same process to work in different directories at the same time. Second, it provides a way to avoid time-of-check- to-time-of-use (TOCTTOU) errors.  openat函数是在最后一个版本的POSIX.1加入的，为了解决两个问题。首先，它给线程以相对路径而非当前路径。我们将在第11章看到，在同一进程中的所有线程共享同一个当前目录，所以要让同一进程中的多线程同时在不同的目录工作是非常困难的。第二，它提供了避免 time-of-check-to-time-of-use（TOCTTOU） 错误。</p>\n<p>The basic idea behind TOCTTOU errors is that a program is vulnerable if it makes two file-based function calls where the second call depends on the results of the first call. Because the two calls are not atomic, the file can change between the two calls, thereby invalidating the results of the first call, leading to a program error. TOCTTOU errors in the file system namespace generally deal with attempts to subvert file system permissions by tricking a privileged program into either reducing permissions on a privileged file or modifying a privileged file to open up a security hole. Wei and Pu [2005] discuss TOCTTOU weaknesses in the UNIX file system interface.  TOCTTOU错误的意思是，一个调用横叉一脚影响了另一个调用，本来另一个调用应该是一个原子操作。</p>\n<h3 id=\"Filename-and-Pathname-Truncation\"><a href=\"#Filename-and-Pathname-Truncation\" class=\"headerlink\" title=\"Filename and Pathname Truncation\"></a>Filename and Pathname Truncation</h3><p>What happens if NAME_MAX is 14 and we try to create a new file in the current directory with a filename containing 15 characters? Traditionally, early releases of System V, such as SVR2, allowed this to happen, silently truncating the filename beyond the 14th character. BSD-derived systems, in contrast, returned an error status, with errno set to ENAMETOOLONG. Silently truncating the filename presents a problem that affects more than simply the creation of new files. If NAME_MAX is 14 and a file exists whose name is exactly 14 characters, any function that accepts a pathname argument, such as open or stat, has no way to determine what the original name of the file was, as the original name might have been truncated.  如果NAME_MAX是14怎么办？传统上，早期的System V系统，允许这发生，静默的将文件名截断成14字符。相反的，BSD派生的系统，返回一个错误状态，并把errno设置成ENAMETOOLONG。静默的截断文件名呈现的问题不仅仅是创建了一个新文件。如果NAME_MAX是14且文件存在，且它的名字就是14字符，任何接收一个路径名作为参数的函数，比如open或者stat，没办法判断文件原来的名字是什么，因为原始文件名可能已经被截断。</p>\n<p>With POSIX.1, the constant <code>_POSIX_NO_TRUNC</code> determines whether long filenames and long components of pathnames are truncated or an error is returned. As we saw in Chapter 2, this value can vary based on the type of the file system, and we can use fpathconf or pathconf to query a directory to see which behavior is supported.  在POSIX.1标准里，常量 <code>_POSIX_NO_TRUNC</code> 决定长文件名和路径名中长的组件是否被截断或者是否返回一个错误。正如我们在第二章中看到的，这个值在文件系统中是非常基本的，我们可以使用 <code>fpathconf</code> 或 <code>pathconf</code>查询一个目录看看它支持哪种行为。</p>\n<blockquote>\n<p>Whether an error is returned is largely historical. For example, SVR4-based systems do not generate an error for the traditional System V file system, S5. For the BSD-style file system (known as UFS), however, SVR4-based systems do generate an error. Figure 2.20 illustrates another example: Solaris will return an error for UFS, but not for PCFS, the DOS-compatible file system, as DOS silently truncates filenames that don’t fit in an 8.3 format. BSD-derived systems and Linux always return an error. </p>\n</blockquote>\n<p>If _POSIX_NO_TRUNC is in effect, errno is set to ENAMETOOLONG, and an error status is returned if any filename component of the pathname exceeds NAME_MAX. </p>\n<blockquote>\n<p>Most modern file systems support a maximum of 255 characters for filenames. Because filenames are usually shorter than this limit, this constraint tends to not present problems for most applications. </p>\n</blockquote>\n<h3 id=\"creat-Function\"><a href=\"#creat-Function\" class=\"headerlink\" title=\"creat Function\"></a>creat Function</h3><p>A new file can also be created by calling the creat function. </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">creat</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *path, <span class=\"keyword\">mode_t</span> mode)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// Returns: file descriptor opened for write-only if OK, −1 on error</span></span><br></pre></td></tr></table></figure>\n<p>Note that this function is equivalent to </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open(path, O_WRONLY | O_CREAT | O_TRUNC, mode);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Historically, in early versions of the UNIX System, the second argument to open could be only 0, 1, or 2. There was no way to open a file that didn’t already exist. Therefore, a separate system call, creat, was needed to create new files. With the O_CREAT and O_TRUNC options now provided by open, a separate creat function is no longer needed.  这个函数诞生的原因是：历史上open函数的第二个参数只支持0，1，2这三个值，也就是读，写，读写。没办法打开一个不存在的文件。而现在有了O_CREAT and O_TRUNC options，creat函数也就没有存在的必要了。</p>\n</blockquote>\n<p>We’ll show how to specify mode in Section 4.5 when we describe a file’s access permissions in detail. </p>\n<p>One deficiency with creat is that the file is opened only for writing. Before the new version of open was provided, if we were creating a temporary file that we wanted to write and then read back, we had to call creat, close, and then open. A better way is to use the open function, as in </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open(path, O_RDWR | O_CREAT | O_TRUNC, mode);</span><br></pre></td></tr></table></figure>\n<h3 id=\"close-Function\"><a href=\"#close-Function\" class=\"headerlink\" title=\"close Function\"></a>close Function</h3><p>An open file is closed by calling the close function. </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt; </span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Returns: 0 if OK, −1 on error</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">close</span><span class=\"params\">(<span class=\"keyword\">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>Closing a file also releases any record locks that the process may have on the file. We’ll discuss this point further in Section 14.3.  关闭一个文件同样会释放进程对该文件的所有锁。</p>\n<p>When a process terminates, all of its open files are closed automatically by the kernel. Many programs take advantage of this fact and don’t explicitly close open files. See the program in Figure 1.4, for example.  当一个进程终止，所有它打开的文件都会被内核自动关闭。许多程序利用了这一点，不明确关闭文件。</p>\n<h3 id=\"lseek-Function\"><a href=\"#lseek-Function\" class=\"headerlink\" title=\"lseek Function\"></a>lseek Function</h3><p>Every open file has an associated ‘‘current file offset,’’ normally a non-negative integer that measures the number of bytes from the beginning of the file. (We describe some exceptions to the ‘‘non-negative’’ qualifier later in this section.) Read and write operations normally start at the current file offset and cause the offset to be incremented by the number of bytes read or written. By default, this offset is initialized to 0 when a file is opened, unless the O_APPEND option is specified.  每个打开的文件都与 “current file offset”关联，正常情况下它是一个非负整形数，表示从文件开始到目前位置的字节数。读和写操作都是从 current file offset开始的，并且会让offset增加，随着读和写的进行。默认的，当文件被打开时，这个位移初始化时0，除非指明了O_APPEND选项。</p>\n<p>An open file’s offset can be set explicitly by calling lseek.  通过调用 lseek函数，一个打开的文件的offset可以被设定。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">off_t</span> lseek(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">off_t</span> offset, <span class=\"keyword\">int</span> whence);</span><br><span class=\"line\"><span class=\"comment\">// Returns: new file offset if OK, −1 on error</span></span><br></pre></td></tr></table></figure>\n<p>The interpretation of the offset depends on the value of the whence argument. </p>\n<ul>\n<li><p>If whence is SEEK_SET, the file’s offset is set to offset bytes from the beginning of </p>\n<p>the file. </p>\n</li>\n<li><p>If whence is SEEK_CUR, the file’s offset is set to its current value plus the offset. </p>\n<p>The offset can be positive or negative. </p>\n</li>\n<li><p>If whence is SEEK_END, the file’s offset is set to the size of the file plus the offset. </p>\n<p>The offset can be positive or negative.</p>\n</li>\n</ul>\n<p>Because a successful call to lseek returns the new file offset, we can seek zero bytes </p>\n<p>from the current position to determine the current offset: </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">off_t</span>    currpos;</span><br><span class=\"line\">currpos = lseek(fd, <span class=\"number\">0</span>, SEEK_CUR);</span><br></pre></td></tr></table></figure>\n<p>This technique can also be used to determine if a file is capable of seeking. If the file descriptor refers to a pipe, FIFO, or socket, lseek sets errno to <strong>ESPIPE</strong> and returns −1.  </p>\n<blockquote>\n<p>The three symbolic constants—SEEK_SET, SEEK_CUR, and SEEK_END—were introduced with System V. Prior to this, <strong>whence was specified as 0 (absolute), 1 (relative to the current offset), or 2 (relative to the end of file). Much software still exists with these numbers hard coded</strong>. </p>\n<p><strong>The character l in the name lseek means ‘‘long integer.’’ Before the introduction of the off_t data type, the offset argument and the return value were long integers</strong>. lseek was introduced with Version 7 when long integers were added to C. (Similar functionality was provided in Version 6 by the functions seek and tell.) </p>\n</blockquote>\n<h3 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h3><p>The program in Figure 3.1 tests its standard input to see whether it is capable of seeking. </p>\n<blockquote>\n<p>Figure 3.1 Test whether standard input is capable of seeking </p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"apue.h\"</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lseek(STDIN_FILENO, <span class=\"number\">0</span>, SEEK_CUR) == <span class=\"number\">-1</span>)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"cannot seek\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"seek OK\\n\"</span>);</span><br><span class=\"line\"> \t<span class=\"built_in\">exit</span>(<span class=\"number\">0</span>); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>Normally, a file’s current offset must be a non-negative integer. It is possible, however, that certain devices could allow negative offsets. But for regular files, the offset must be non-negative. Because negative offsets are possible, we should be careful to compare the return value from lseek as being equal to or not equal to −1, rather than testing whether it is less than 0</strong>. </p>\n<blockquote>\n<p>The /dev/kmem device on FreeBSD for the Intel x86 processor supports negative offsets. Because the offset (off_t) is a signed data type (Figure 2.21), we lose a factor of 2 in the maximum file size. If off_t is a 32-bit integer, the maximum file size is $2^{31}$−1 bytes. </p>\n</blockquote>\n<p>lseek only records the current file offset within the kernel — it does not cause any I/O to take place. This offset is then used by the next read or write operation. </p>\n<p>The file’s offset can be greater than the file’s current size, in which case the next write to the file will extend the file. This is referred to as creating a hole in a file and is allowed. Any bytes in a file that have not been written are read back as 0.  文件偏移量可以大于文件的目前大小，在这种情况下下一次写文件将扩展文件。也就是说在文件中创建一个空洞是被允许的。在文件中任何没被写入的部分都将被读作0。</p>\n<p>A hole in a file isn’t required to have storage backing it on disk. Depending on the file system implementation, when you write after seeking past the end of a file, new disk blocks might be allocated to store the data, but there is no need to allocate disk blocks for the data between the old end of file and the location where you start writing.  文件中的空洞并不需要存储到磁盘上。根据文件系统的实现，当你在end of file之后写，为了存储数据新的磁盘空间可能会分配，但没有必要分配磁盘块给end of file和你开始写的地方之间的这些数据。</p>\n<h3 id=\"Example-1\"><a href=\"#Example-1\" class=\"headerlink\" title=\"Example\"></a>Example</h3><p>The program shown in Figure 3.2 creates a file with a hole in it. </p>\n<blockquote>\n<p>Figure 3.2  Create a file with a hole in it </p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"apue.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">char</span>    buf1[] = <span class=\"string\">\"abcdefghij\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span>    buf2[] = <span class=\"string\">\"ABCDEFGHIJ\"</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">true<span class=\"keyword\">int</span> fd;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((fd = creat(<span class=\"string\">\"file.hole\"</span>, FILE_MODE)) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    \terr_sys(<span class=\"string\">\"creat error\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (write(fd, buf1, <span class=\"number\">10</span>) != <span class=\"number\">10</span>)</span><br><span class=\"line\">    \terr_sys(<span class=\"string\">\"buf1 write error\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">/* offset now = 10 */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lseek(fd, <span class=\"number\">16384</span>, SEEK_SET) == <span class=\"number\">-1</span>)</span><br><span class=\"line\">    \terr_sys(<span class=\"string\">\"lseek error\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">/* offset now = 16384 */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (write(fd, buf2, <span class=\"number\">10</span>) != <span class=\"number\">10</span>)</span><br><span class=\"line\">        err_sys(<span class=\"string\">\"buf2 write error\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">/* offset now = 16394 */</span></span><br><span class=\"line\">true<span class=\"built_in\">exit</span>(<span class=\"number\">0</span>); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"File-Sharing\"><a href=\"#File-Sharing\" class=\"headerlink\" title=\"File Sharing\"></a>File Sharing</h2><p>The UNIX System supports the sharing of open files among different processes. Before describing the dup function, we need to describe this sharing. To do this, we’ll examine the data structures used by the kernel for all I/O. </p>\n<blockquote>\n<p>The following description is conceptual; it may or may not match a particular implementation. Refer to Bach [1986] for a discussion of these structures in System V. McKusick et al. [1996] describe these structures in 4.4BSD. McKusick and Neville-Neil [2005] cover FreeBSD 5.2. For a similar discussion of Solaris, see McDougall and Mauro [2007]. The Linux 2.6 kernel architecture is discussed in Bovet and Cesati [2006]. </p>\n</blockquote>\n<p>The kernel uses three data structures to represent an open file, and the relationships among them determine the effect one process has on another with regard to file sharing. </p>\n<ol>\n<li><p>Every process has an entry in the process table. Within each process table entry is a table of open file descriptors, which we can think of as a vector, with one entry per descriptor. Associated with each file descriptor are </p>\n<ol>\n<li>The file descriptor flags (close-on-exec; refer to Figure 3.7 and Section 3.14) </li>\n<li>A pointer to a file table entry </li>\n</ol>\n</li>\n<li><p>The kernel maintains a file table for all open files. Each file table entry contains </p>\n<ol>\n<li>The file status flags for the file, such as read, write, append, sync, and nonblocking; more on these in Section 3.14 </li>\n<li>The current file offset </li>\n<li>A pointer to the v-node table entry for the file </li>\n</ol>\n</li>\n<li><p>Each open file (or device) has a v-node structure that <strong>contains information about the type of file</strong> and <strong>pointers to functions that operate on the file</strong>. For most files, the v-node also contains the i-node for the file. <strong>This information is read from disk when the file is opened</strong>, so that all the pertinent information about the file is readily available. For example, <strong>the i-node contains the owner of the file, the size of the file, pointers to where the actual data blocks for the file are located on disk</strong>, and so on. (We talk more about i-nodes in Section 4.14 when we describe the typical UNIX file system in more detail.) </p>\n</li>\n</ol>\n<blockquote>\n<p>Linux has no v-node. Instead, a generic i-node structure is used. Although the implementations differ, the v-node is conceptually the same as a generic i-node. Both point to an i-node structure specific to the file system.</p>\n</blockquote>\n<p>We’re ignoring some implementation details that don’t affect our discussion. For example, the table of open file descriptors can be stored in the user area (a separate per- process structure that can be paged out) instead of the process table. Also, these tables can be implemented in numerous ways—they need not be arrays; one alternate implementation is a linked lists of structures. Regardless of the implementation details, the general concepts remain the same. </p>\n<p>Figure 3.7 shows a pictorial arrangement of these three tables for a single process that has two different files open: one file is open on standard input (file descriptor 0), and the other is open on standard output (file descriptor 1). </p>\n<p><img src=\"https://i.loli.net/2018/05/30/5b0e51e54c6d1.png\"></p>\n<p>The arrangement of these three tables has existed since the early versions of the UNIX System [Thompson 1978]. <strong>This arrangement is critical to the way files are shared among processes</strong>. We’ll return to this figure in later chapters, when we describe additional ways that files are shared. </p>\n<blockquote>\n<p><strong>The v-node was invented to provide support for multiple file system types on a single computer system</strong>. This work was done independently by Peter Weinberger (Bell Laboratories) and Bill Joy (Sun Microsystems). <strong>Sun called this the Virtual File System and called the file system–independent portion of the i-node the v-node</strong> [Kleiman 1986]. The v-node propagated through various vendor implementations as support for Sun’s Network File System (NFS) was added. The first release from Berkeley to provide v-nodes was the 4.3BSD Reno release, when NFS was added. </p>\n</blockquote>\n<blockquote>\n<p>In SVR4, the v-node replaced the file system–independent i-node of SVR3. Solaris is derived from SVR4 and, therefore, uses v-nodes. </p>\n</blockquote>\n<blockquote>\n<p>Instead of splitting the data structures into a v-node and an i-node, Linux uses a file system–independent i-node and a file system–dependent i-node. </p>\n</blockquote>\n<p>If two independent processes have the same file open, we could have the arrangement shown in Figure 3.8. </p>\n<p><img src=\"https://i.loli.net/2018/05/30/5b0e5b6638838.png\"></p>\n<p>We assume here that the first process has the file open on descriptor 3 and that the second process has that same file open on descriptor 4. Each process that opens the file gets its own file table entry, but only a single v-node table entry is required for a given file. One reason each process gets its own file table entry is so that each process has its own current offset for the file. </p>\n<p>Given these data structures, we now need to be more specific about what happens with certain operations that we’ve already described. </p>\n<ul>\n<li>After each write is complete, the current file offset in the file table entry is incremented by the number of bytes written. If this causes the current file offset to exceed the current file size, the current file size in the i-node table entry is set to the current file offset (for example, the file is extended). </li>\n<li>If a file is opened with the O_APPEND flag, a corresponding flag is set in the file status flags of the file table entry. Each time a write is performed for a file with this append flag set, the current file offset in the file table entry is first set to the current file size from the i-node table entry. This forces every write to be appended to the current end of file. </li>\n<li>If a file is positioned to its current end of file using lseek, all that happens is the current file offset in the file table entry is set to the current file size from the i-node table entry. (Note that this is not the same as if the file was opened with the O_APPEND flag, as we will see in Section 3.11.) </li>\n<li>The lseek function modifies only the current file offset in the file table entry. No I/O takes place. </li>\n</ul>\n<p>It is possible for more than one file descriptor entry to point to the same file table entry, as we’ll see when we discuss the dup function in Section 3.12. This also happens after a fork when the parent and the child share the same file table entry for each open descriptor (Section 8.3). </p>\n<p><strong>Note the difference in scope between the file descriptor flags and the file status flags. The former apply only to a single descriptor in a single process, whereas the latter apply to all descriptors in any process that point to the given file table entry</strong>. When we describe the fcntl function in Section 3.14, we’ll see how to fetch and modify both the file descriptor flags and the file status flags. </p>\n<p>Everything that we’ve described so far in this section works fine for multiple processes that are reading the same file. Each process has its own file table entry with its own current file offset. Unexpected results can arise, however, when multiple processes write to the same file. To see how to avoid some surprises, we need to understand the concept of atomic operations. </p>\n<h2 id=\"Atomic-Operations\"><a href=\"#Atomic-Operations\" class=\"headerlink\" title=\"Atomic Operations\"></a>Atomic Operations</h2><h3 id=\"Appending-to-a-File\"><a href=\"#Appending-to-a-File\" class=\"headerlink\" title=\"Appending to a File\"></a>Appending to a File</h3><p>Consider a single process that wants to append to the end of a file. Older versions of the UNIX System didn’t support the O_APPEND option to open, so the program was coded as follows: </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (lseek(fd, <span class=\"number\">0L</span>, <span class=\"number\">2</span>) &lt; <span class=\"number\">0</span>)         <span class=\"comment\">/* position to EOF */</span></span><br><span class=\"line\">trueerr_sys(<span class=\"string\">\"lseek error\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (write(fd, buf, <span class=\"number\">100</span>) != <span class=\"number\">100</span>)   <span class=\"comment\">/* and write */</span></span><br><span class=\"line\">trueerr_sys(<span class=\"string\">\"write error\"</span>);</span><br></pre></td></tr></table></figure>\n<p>This works fine for a single process, but problems arise if multiple processes use this technique to append to the same file. (This scenario can arise if multiple instances of the same program are appending messages to a log file, for example.) </p>\n<p>Assume that two independent processes, A and B, are appending to the same file. Each has opened the file but without the O_APPEND flag. This gives us the same picture as Figure 3.8. Each process has its own file table entry, but they share a single v-node table entry. Assume that process A does the lseek and that this sets the current offset for the file for process A to byte offset 1,500 (the current end of file). Then the kernel switches processes, and B continues running. Process B then does the lseek, which sets the current offset for the file for process B to byte offset 1,500 also (the current end of file). Then B calls write, which increments B’s current file offset for the file to 1,600. Because the file’s size has been extended, the kernel also updates the current file size in the v-node to 1,600. Then the kernel switches processes and A resumes. When A calls write, the data is written starting at the current file offset for A, which is byte offset 1,500. This overwrites the data that B wrote to the file. </p>\n<p>The problem here is that our logical operation of ‘‘position to the end of file and write’’ requires two separate function calls (as we’ve shown it). The solution is to have the positioning to the current end of file and the write be an atomic operation with regard to other processes. Any operation that requires more than one function call cannot be atomic, as there is always the possibility that the kernel might temporarily suspend the process between the two function calls (as we assumed previously). </p>\n<p>The UNIX System provides an atomic way to do this operation if we set the O_APPEND flag when a file is opened. As we described in the previous section, this causes the kernel to position the file to its current end of file before each write. We no longer have to call lseek before each write. </p>\n<h3 id=\"pread-and-pwrite-Functions\"><a href=\"#pread-and-pwrite-Functions\" class=\"headerlink\" title=\"pread and pwrite Functions\"></a>pread and pwrite Functions</h3><p>The Single UNIX Specification includes two functions that allow applications to seek and perform I/O atomically: pread and pwrite. </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Returns: number of bytes read, 0 if end of file, −1 on error</span></span><br><span class=\"line\"><span class=\"keyword\">ssize_t</span> pread(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">void</span> *buf, <span class=\"keyword\">size_t</span> nbytes, <span class=\"keyword\">off_t</span> offset);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Returns: number of bytes written if OK, −1 on error</span></span><br><span class=\"line\"><span class=\"keyword\">ssize_t</span> pwrite(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *buf, <span class=\"keyword\">size_t</span> nbytes, <span class=\"keyword\">off_t</span> offset);</span><br></pre></td></tr></table></figure>\n<p>Calling pread is equivalent to calling lseek followed by a call to read, with the following exceptions. </p>\n<ul>\n<li><p>There is no way to interrupt the two operations that occur when we call pread. </p>\n</li>\n<li><p>The current file offset is not updated. </p>\n</li>\n</ul>\n<p>Calling pwrite is equivalent to calling lseek followed by a call to write, with similar exceptions. </p>\n<h3 id=\"Creating-a-File\"><a href=\"#Creating-a-File\" class=\"headerlink\" title=\"Creating a File\"></a>Creating a File</h3><p>We saw another example of an atomic operation when we described the O_CREAT and O_EXCL options for the open function. When both of these options are specified, the open will fail if the file already exists. We also said that the check for the existence of the file and the creation of the file was performed as an atomic operation. If we didn’t have this atomic operation, we might try </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ((fd = open(path, O_WRONLY)) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (errno == ENOENT) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((fd = creat(path, mode)) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            err_sys(<span class=\"string\">\"creat error\"</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        err_sys(<span class=\"string\">\"open error\"</span>);</span><br><span class=\"line\">&#125; &#125;</span><br></pre></td></tr></table></figure>\n<p>The problem occurs if the file is created by another process between the open and the creat. If the file is created by another process between these two function calls, and if that other process writes something to the file, that data is erased when this creat is executed. Combining the test for existence and the creation into a single atomic operation avoids this problem. </p>\n<p>In general, the term atomic operation refers to an operation that might be composed of multiple steps. If the operation is performed atomically, either all the steps are performed (on success) or none are performed (on failure). It must not be possible for only a subset of the steps to be performed. We’ll return to the topic of atomic operations when we describe the link function (Section 4.15) and record locking (Section 14.3). </p>\n<h2 id=\"dup-and-dup2-Functions\"><a href=\"#dup-and-dup2-Functions\" class=\"headerlink\" title=\"dup and dup2 Functions\"></a>dup and dup2 Functions</h2><p>An existing file descriptor is duplicated by either of the following functions: </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Both return: new file descriptor if OK, −1 on error</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dup</span><span class=\"params\">(<span class=\"keyword\">int</span> fd)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dup2</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">int</span> fd2)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>The new file descriptor returned by dup is guaranteed to be the lowest-numbered available file descriptor. <strong>With dup2, we specify the value of the new descriptor with the fd2 argument. If fd2 is already open, it is first closed. If fd equals fd2, then dup2 returns fd2 without closing it. Otherwise, the FD_CLOEXEC file descriptor flag is cleared for fd2, so that fd2 is left open if the process calls exec</strong>.</p>\n<p>The new file descriptor that is returned as the value of the functions shares the same file table entry as the fd argument. We show this in Figure 3.9. </p>\n<p><img src=\"https://i.loli.net/2018/05/30/5b0e6c0a52034.png\"></p>\n<p>In this figure, we assume that when it’s started, the process executes </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">newfd = dup(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n<p>We assume that the next available descriptor is 3 (which it probably is, since 0, 1, and 2 are opened by the shell). Because both descriptors point to the same file table entry, they share the same file status flags—read, write, append, and so on—and the same current file offset. </p>\n<p>Each descriptor has its own set of file descriptor flags. As we describe in Section 3.14, the close-on-exec file descriptor flag for the new descriptor is always cleared by the dup functions. </p>\n<p>Another way to duplicate a descriptor is with the fcntl function, which we describe in Section 3.14. Indeed, the call </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dup(fd);</span><br></pre></td></tr></table></figure>\n<p>is equivalent to </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fcntl(fd, F_DUPFD, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n<p>Similarly, the call </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dup2(fd, fd2);</span><br></pre></td></tr></table></figure>\n<p>is equivalent to </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">close(fd2);</span><br><span class=\"line\">fcntl(fd, F_DUPFD, fd2);</span><br></pre></td></tr></table></figure>\n<p>In this last case, the dup2 is not exactly the same as a close followed by an fcntl. The differences are as follows: </p>\n<ol>\n<li>dup2 is an atomic operation, whereas the alternate form involves two function calls. It is possible in the latter case to have a signal catcher called between the close and the fcntl that could modify the file descriptors. (We describe signals in Chapter 10.) The same problem could occur if a different thread changes the file descriptors. (We describe threads in Chapter 11.) </li>\n<li>There are some errno differences between dup2 and fcntl. </li>\n</ol>\n<blockquote>\n<p>The dup2 system call originated with Version 7 and propagated through the BSD releases. The fcntl method for duplicating file descriptors appeared with System III and continued with SystemV. SVR3.2 picked up the dup2 function, and 4.2BSD picked up the fcntl function and the F_DUPFD functionality. POSIX.1 requires both dup2 and the F_DUPFD feature of fcntl. </p>\n</blockquote>\n<h2 id=\"sync-fsync-and-fdatasync-Functions\"><a href=\"#sync-fsync-and-fdatasync-Functions\" class=\"headerlink\" title=\"sync, fsync, and fdatasync Functions\"></a>sync, fsync, and fdatasync Functions</h2><p>Traditional implementations of the UNIX System have a buffer cache or page cache in the kernel through which most disk I/O passes. When we write data to a file, the data is normally copied by the kernel into one of its buffers and queued for writing to disk at some later time. This is called delayed write. (Chapter 3 of Bach [1986] discusses this buffer cache in detail.) </p>\n<p>The kernel eventually writes all the delayed-write blocks to disk, normally when it needs to reuse the buffer for some other disk block. To ensure consistency of the file system on disk with the contents of the buffer cache, the sync, fsync, and fdatasync functions are provided. </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt; </span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Both Returns: 0 if OK, −1 on error</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fsync</span><span class=\"params\">(<span class=\"keyword\">int</span> fd)</span></span>; </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fdatasync</span><span class=\"params\">(<span class=\"keyword\">int</span> fd)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sync</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n<p><strong>The sync function simply queues all the modified block buffers for writing and returns; it does not wait for the disk writes to take place</strong>. </p>\n<p><strong>The function sync is normally called periodically (usually every 30 seconds) from a system daemon, often called update</strong>. This guarantees regular flushing of the kernel’s block buffers. The command sync(1) also calls the sync function. </p>\n<p>The function fsync refers only to a single file, specified by the file descriptor fd, and <strong>waits for the disk writes to complete before returning</strong>. This function is used when an application, <strong>such as a database</strong>, needs to be sure that the modified blocks have been written to the disk. </p>\n<p><strong>The fdatasync function is similar to fsync, but it affects only the data portions of a file. With fsync, the file’s attributes are also updated synchronously</strong>. </p>\n<blockquote>\n<p>All four of the platforms described in this book support sync and fsync. However, FreeBSD 8.0 does not support fdatasync. </p>\n</blockquote>\n<h2 id=\"fcntl-Function\"><a href=\"#fcntl-Function\" class=\"headerlink\" title=\"fcntl Function\"></a>fcntl Function</h2><p>The fcntl function can change the properties of a file that is already open. </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Returns: depends on cmd if OK (see following), −1 on error</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fcntl</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">int</span> cmd, ... <span class=\"comment\">/* int arg */</span> )</span></span>;</span><br></pre></td></tr></table></figure>\n<p>In the examples in this section, the third argument is always an integer, corresponding to the comment in the function prototype just shown. When we describe record locking in Section 14.3, however, the third argument becomes a pointer to a structure. </p>\n<p>The fcntl function is used for five different purposes. </p>\n<ol>\n<li><p>Duplicate an existing descriptor (cmd = F_DUPFD or F_DUPFD_CLOEXEC) </p>\n</li>\n<li><p>Get/set file descriptor flags (cmd = F_GETFD or F_SETFD) </p>\n</li>\n<li><p>Get/set file status flags (cmd = F_GETFL or F_SETFL) </p>\n</li>\n<li><p>Get/set asynchronous I/O ownership (cmd = F_GETOWN or F_SETOWN) </p>\n</li>\n<li><p>Get/set record locks (cmd = F_GETLK, F_SETLK, or F_SETLKW) </p>\n</li>\n</ol>\n<p>We’ll now describe the first 8 of these 11 cmd values. (We’ll wait until Section 14.3 to describe the last 3, which deal with record locking.) Refer to Figure 3.7, as we’ll discuss both the file descriptor flags associated with each file descriptor in the process table entry and the file status flags associated with each file table entry. </p>\n<p>F_DUPFD     Duplicate the file descriptor fd. The new file descriptor is returned as the value of the function. It is the lowest-numbered descriptor that is not already open, and that is greater than or equal to the third argument (taken as an integer). The new descriptor shares the same file table entry as fd. (Refer to Figure 3.9.) But the new descriptor has its own set of file descriptor flags, and its FD_CLOEXEC file descriptor flag is cleared. (This means that the descriptor is left open across an exec, which we discuss in Chapter 8.) </p>\n<p>F_DUPFD_CLOEXEC    Duplicate the file descriptor and set the FD_CLOEXEC file descriptor flag associated with the new descriptor. Returns the new file descriptor. </p>\n<p>F_GETFD     Return the file descriptor flags for fd as the value of the function. Currently, only one file descriptor flag is defined: the FD_CLOEXEC flag. </p>\n<p>F_SETFD     Set the file descriptor flags for fd. The new flag value is set from the third argument (taken as an integer). </p>\n<blockquote>\n<p>Be aware that some existing programs that deal with the file descriptor flags don’t use the constant FD_CLOEXEC. Instead, these programs set the flag to either 0 (don’t close-on-exec, the default) or 1 (do close-on-exec). </p>\n</blockquote>\n<p>F_GETFL     Return the file status flags for fd as the value of the function. We described the file status flags when we described the open function. They are listed in Figure 3.10. </p>\n<p><img src=\"https://i.loli.net/2018/05/31/5b0f49576d719.png\" width=\"70%\"></p>\n<p>Unfortunately, the five access-mode flags—O_RDONLY, O_WRONLY, O_RDWR, O_EXEC, and O_SEARCH—are not separate bits that can be tested. (As we mentioned earlier, the first three often have the values 0, 1, and 2, respectively, for historical reasons. Also, these five values are mutually exclusive; a file can have only one of them enabled.) Therefore, we must first use the O_ACCMODE mask to obtain the access-mode bits and then compare the result against any of the five values. </p>\n<p>F_SETFL         Set the file status flags to the value of the third argument (taken as an integer). The only flags that can be changed are O_APPEND, O_NONBLOCK, O_SYNC, O_DSYNC, O_RSYNC, O_FSYNC, and O_ASYNC. </p>\n<p>F_GETOWN     Get the process ID or process group ID currently receiving the SIGIO and SIGURG signals. We describe these asynchronous I/O signals in Section 14.5.2. </p>\n<p>F_SETOWN     Set the process ID or process group ID to receive the SIGIO and SIGURG signals. A positive arg specifies a process ID. A negative arg implies a process group ID equal to the absolute value of arg. </p>\n<p>The return value from fcntl depends on the command. All commands return −1 on an error or some other value if OK. The following four commands have special return values: F_DUPFD, F_GETFD, F_GETFL, and F_GETOWN. The first command returns the new file descriptor, the next two return the corresponding flags, and the final command returns a positive process ID or a negative process group ID. </p>\n<h3 id=\"Example-2\"><a href=\"#Example-2\" class=\"headerlink\" title=\"Example\"></a>Example</h3><p>The program in Figure 3.11 takes a single command-line argument that specifies a file descriptor and prints a description of selected file flags for that descriptor. </p>\n<blockquote>\n<p>Figure 3.11 Print file flags for specified descriptor </p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"include/apue.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> val;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (argc != <span class=\"number\">2</span>)</span><br><span class=\"line\">     err_quit(<span class=\"string\">\"usage: a.out &lt;descriptor#&gt;\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((val = fcntl(atoi(argv[<span class=\"number\">1</span>]), F_GETFL, <span class=\"number\">0</span>)) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">     err_sys(<span class=\"string\">\"fcntl error for fd %d\"</span>, atoi(argv[<span class=\"number\">1</span>]));</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (val &amp; O_ACCMODE) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> O_RDONLY:</span><br><span class=\"line\">       <span class=\"built_in\">printf</span>(<span class=\"string\">\"read only\"</span>);</span><br><span class=\"line\">       <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> O_WRONLY:</span><br><span class=\"line\">       <span class=\"built_in\">printf</span>(<span class=\"string\">\"write only\"</span>);</span><br><span class=\"line\">       <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> O_RDWR:</span><br><span class=\"line\">       <span class=\"built_in\">printf</span>(<span class=\"string\">\"read write\"</span>);</span><br><span class=\"line\">       <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">       err_dump(<span class=\"string\">\"unknown access mode\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (val &amp; O_APPEND)</span><br><span class=\"line\">     <span class=\"built_in\">printf</span>(<span class=\"string\">\", append\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (val &amp; O_NONBLOCK)</span><br><span class=\"line\">     <span class=\"built_in\">printf</span>(<span class=\"string\">\", nonblocking\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (val &amp; O_SYNC)</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\", synchronous writes\"</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">if</span> !defined(_POSIX_C_SOURCE) &amp;&amp; defined(O_FSYNC) &amp;&amp; (O_FSYNC != O_SYNC)</span></span><br><span class=\"line\">         <span class=\"keyword\">if</span> (val &amp; O_FSYNC)</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\", synchronous writes\"</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">  <span class=\"built_in\">putchar</span>(<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Note that we use the feature test macro _POSIX_C_SOURCE and conditionally compile the file access flags that are not part of POSIX.1. The following script shows the operation of the program, when invoked from bash (the Bourne-again shell). Results will vary, depending on which shell you use. </p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  apue.3e ./fig3.11 0 &lt; /dev/tty</span><br><span class=\"line\">read only</span><br><span class=\"line\">➜  apue.3e ./fig3.11 1 &gt; temp.foo</span><br><span class=\"line\">➜  apue.3e cat temp.foo</span><br><span class=\"line\">write only</span><br><span class=\"line\">➜  apue.3e ./fig3.11 2 2&gt;&gt;temp.foo</span><br><span class=\"line\">write only, append</span><br><span class=\"line\">➜  apue.3e ./fig3.11 5 5&lt;&gt;temp.foo</span><br><span class=\"line\">read write</span><br></pre></td></tr></table></figure>\n<p>The clause 5&lt;&gt;temp.foo opens the file temp.foo for reading and writing on file descriptor 5. </p>\n<h3 id=\"Example-3\"><a href=\"#Example-3\" class=\"headerlink\" title=\"Example\"></a>Example</h3><p>When we modify either the file descriptor flags or the file status flags, we must be careful to fetch the existing flag value, modify it as desired, and then set the new flag value. We can’t simply issue an F_SETFD or an F_SETFL command, as this could turn off flag bits that were previously set. </p>\n<p>Figure 3.12 shows a function that sets one or more of the file status flags for a descriptor. </p>\n<blockquote>\n<p>Figure 3.12 Turn on one or more of the file status flags for a descriptor </p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"apue.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">set_fl</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">int</span> flags)</span> <span class=\"comment\">/* flags are file status flags to turn on */</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">true<span class=\"keyword\">int</span> val;</span><br><span class=\"line\">true<span class=\"keyword\">if</span> ((val = fcntl(fd, F_GETFL, <span class=\"number\">0</span>)) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">true   err_sys(<span class=\"string\">\"fcntl F_GETFL error\"</span>);</span><br><span class=\"line\">trueval |= flags;       <span class=\"comment\">/* turn on flags */</span></span><br><span class=\"line\">true<span class=\"keyword\">if</span> (fcntl(fd, F_SETFL, val) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">true   err_sys(<span class=\"string\">\"fcntl F_SETFL error\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>If we change the middle statement to </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">val &amp;=  ̃flags;      <span class=\"comment\">/* turn flags off */</span></span><br></pre></td></tr></table></figure>\n<p>we have a function named clr_fl, which we’ll use in some later examples. This statement logically ANDs the one’s complement of flags with the current val. </p>\n<p>If we add the line </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set_fl(STDOUT_FILENO, O_SYNC);</span><br></pre></td></tr></table></figure>\n<p>to the beginning of the program shown in Figure 3.5, we’ll turn on the synchronous- write flag. This causes each write to wait for the data to be written to disk before returning. Normally in the UNIX System, a write only queues the data for writing; the actual disk write operation can take place sometime later. A database system is a likely candidate for using O_SYNC, so that it knows on return from a write that the data is actually on the disk, in case of an abnormal system failure. </p>\n<p>We expect the O_SYNC flag to increase the system and clock times when the program runs. To test this, we can run the program in Figure 3.5, copying 492.6 MB of data from one file on disk to another and compare this with a version that does the same thing with the O_SYNC flag set. The results from a Linux system using the ext4 file system are shown in Figure 3.13. </p>\n<p><img src=\"https://i.loli.net/2018/05/31/5b0f4c0dc6161.png\" width=\"80%\"></p>\n<p>The six rows in Figure 3.13 were all measured with a BUFFSIZE of 4,096 bytes. The results in Figure 3.6 were measured while reading a disk file and writing to /dev/null, so there was no disk output. The second row in Figure 3.13 corresponds to reading a disk file and writing to another disk file. This is why the first and second rows in Figure 3.13 are different. The system time increases when we write to a disk file, because the kernel now copies the data from our process and queues the data for writing by the disk driver. We expect the clock time to increase as well when we write to a disk file. </p>\n<p>When we enable synchronous writes, the system and clock times should increase significantly. As the third row shows, the system time for writing synchronously is not much more expensive than when we used delayed writes. This implies that the Linux operating system is doing the same amount of work for delayed and synchronous writes (which is unlikely), or else the O_SYNC flag isn’t having the desired effect. In this case, the Linux operating system isn’t allowing us to set the O_SYNC flag using fcntl, instead failing without returning an error (but it would have honored the flag if we were able to specify it when the file was opened). </p>\n<p>The clock time in the last three rows reflects the extra time needed to wait for all of the writes to be committed to disk. After writing a file synchronously, we expect that a call to fsync will have no effect. This case is supposed to be represented by the last row in Figure 3.13, but since the O_SYNC flag isn’t having the intended effect, the last row behaves the same way as the fifth row. </p>\n<p>Figure 3.14 shows timing results for the same tests run on Mac OS X 10.6.8, which uses the HFS file system. Note that the times match our expectations: synchronous writes are far more expensive than delayed writes, and using fsync with synchronous writes makes very little difference. Note also that adding a call to fsync at the end of the delayed writes makes little measurable difference. It is likely that the operating system flushed previously written data to disk as we were writing new data to the file, so by the time that we called fsync, very little work was left to be done. </p>\n<p><img src=\"https://i.loli.net/2018/05/31/5b0f4c6873af3.png\" width=\"80%\"></p>\n<p>Compare fsync and fdatasync, both of which update a file’s contents when we say so, with the O_SYNC flag, which updates a file’s contents every time we write to the file. The performance of each alternative will depend on many factors, including the underlying operating system implementation, the speed of the disk drive, and the type of the file system. </p>\n<p>With this example, we see the need for fcntl. Our program operates on a descriptor (standard output), never knowing the name of the file that was opened on that descriptor. We can’t set the O_SYNC flag when the file is opened, since the shell opened the file. With fcntl, we can modify the properties of a descriptor, knowing only the descriptor for the open file. We’ll see another need for fcntl when we describe nonblocking pipes (Section 15.2), since all we have with a pipe is a descriptor. </p>\n<h2 id=\"ioctl-Function\"><a href=\"#ioctl-Function\" class=\"headerlink\" title=\"ioctl Function\"></a>ioctl Function</h2><p>The ioctl function has always been the catchall for I/O operations. Anything that couldn’t be expressed using one of the other functions in this chapter usually ended up being specified with an ioctl. Terminal I/O was the biggest user of this function. (When we get to Chapter 18, we’ll see that POSIX.1 has replaced the terminal I/O operations with separate functions.) </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;     /* System V */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/ioctl.h&gt;  /* BSD and Linux */</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Returns: −1 on error, something else if OK</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ioctl</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">int</span> request, ...)</span></span>;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>The ioctl function was included in the Single UNIX Specification only as an extension for dealing with STREAMS devices [Rago 1993], but it was moved to obsolescent status in SUSv4. UNIX System implementations use ioctl for many miscellaneous device operations. Some implementations have even extended it for use with regular files. </p>\n</blockquote>\n<p>The prototype that we show corresponds to POSIX.1. FreeBSD 8.0 and Mac OS X 10.6.8 declare the second argument as an unsigned long. This detail doesn’t matter, since the second argument is always a #defined name from a header. </p>\n<p>For the ISO C prototype, an ellipsis is used for the remaining arguments. Normally, however, there is only one more argument, and it’s usually a pointer to a variable or a structure. </p>\n<p>In this prototype, we show only the headers required for the function itself. Normally, additional device-specific headers are required. For example, the ioctl commands for terminal I/O, beyond the basic operations specified by POSIX.1, all require the &lt;termios.h&gt; header. </p>\n<p>Each device driver can define its own set of ioctl commands. The system, however, provides generic ioctl commands for different classes of devices. Examples of some of the categories for these generic ioctl commands supported in FreeBSD are summarized in Figure 3.15. </p>\n<p><img src=\"https://i.loli.net/2018/05/31/5b0f4cf6d20f6.png\" width=\"60%\"></p>\n<p>The mag tape operations allow us to write end-of-file marks on a tape, rewind a tape, space forward over a specified number of files or records, and the like. None of these operations is easily expressed in terms of the other functions in the chapter (read, write, lseek, and so on), so the easiest way to handle these devices has always been to access their operations using ioctl. </p>\n<p>We use the ioctl function in Section 18.12 to fetch and set the size of a terminal’s window, and in Section 19.7 when we access the advanced features of pseudo terminals. </p>\n<h2 id=\"dev-fd\"><a href=\"#dev-fd\" class=\"headerlink\" title=\"/dev/fd\"></a>/dev/fd</h2><p>Newer systems provide a directory named /dev/fd whose entries are files named 0, 1, 2, and so on. Opening the file /dev/fd/n is equivalent to duplicating descriptor n, assuming that descriptor n is open. </p>\n<blockquote>\n<p>The /dev/fd feature was developed by Tom Duff and appeared in the 8th Edition of the Research UNIX System. It is supported by all of the systems described in this book: FreeBSD 8.0, Linux 3.2.0, Mac OS X 10.6.8, and Solaris 10. It is not part of POSIX.1. </p>\n</blockquote>\n<p>In the function call </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fd = open(<span class=\"string\">\"/dev/fd/0\"</span>, mode);</span><br></pre></td></tr></table></figure>\n<p>most systems ignore the specified mode, whereas others require that it be a subset of the mode used when the referenced file (standard input, in this case) was originally opened. Because the previous open is equivalent to </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fd = dup(<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n<p>the descriptors 0 and fd share the same file table entry (Figure 3.9). For example, if descriptor 0 was opened read-only, we can only read on fd. Even if the system ignores the open mode and the call </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fd = open(<span class=\"string\">\"/dev/fd/0\"</span>, O_RDWR);</span><br></pre></td></tr></table></figure>\n<p>succeeds, we still can’t write to fd. </p>\n<blockquote>\n<p>The Linux implementation of /dev/fd is an exception. It maps file descriptors into symbolic links pointing to the underlying physical files. When you open /dev/fd/0, for example, you are really opening the file associated with your standard input. Thus the mode of the new file descriptor returned is unrelated to the mode of the /dev/fd file descriptor. </p>\n</blockquote>\n<p>We can also call creat with a /dev/fd pathname argument as well as specify O_CREAT in a call to open. This allows a program that calls creat to still work if the pathname argument is /dev/fd/1, for example. </p>\n<blockquote>\n<p>Beware of doing this on Linux. Because the Linux implementation uses symbolic links to the real files, using creat on a /dev/fd file will result in the underlying file being truncated. </p>\n</blockquote>\n<p>Some systems provide the pathnames /dev/stdin, /dev/stdout, and /dev/stderr. These pathnames are equivalent to /dev/fd/0, /dev/fd/1, and /dev/fd/2, respectively. </p>\n<p>The main use of the /dev/fd files is from the shell. It allows programs that use pathname arguments to handle standard input and standard output in the same manner as other pathnames. For example, the cat(1) program specifically looks for an input filename of - and uses it to mean standard input. The command </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">filter file2 | cat file1 - file3 | lpr</span><br></pre></td></tr></table></figure>\n<p>is an example. First, cat reads file1, then its standard input (the output of the filter program on file2), and then file3. If /dev/fd is supported, the special handling of - can be removed from cat, and we can enter </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">filter file2 | cat file1 /dev/fd/0 file3 | lpr</span><br></pre></td></tr></table></figure>\n<p>The special meaning of - as a command-line argument to refer to the standard input or the standard output is a kludge that has crept into many programs. There are also problems if we specify - as the first file, as it looks like the start of another command-line option. Using /dev/fd is a step toward uniformity and cleanliness. </p>\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><p>This chapter has described the basic I/O functions provided by the UNIX System. These are often called the unbuffered I/O functions because each read or write invokes a system call into the kernel. Using only read and write, we looked at the effect of various I/O sizes on the amount of time required to read a file. We also looked at several ways to flush written data to disk and their effect on application performance. </p>\n<p>Atomic operations were introduced when multiple processes append to the same file and when multiple processes create the same file. We also looked at the data structures used by the kernel to share information about open files. We’ll return to these data structures later in the text. </p>\n<p>We also described the ioctl and fcntl functions. We return to both of these functions later in the book. In Chapter 14, we’ll use fcntl for record locking. In Chapter 18 and Chapter 19, we’ll use ioctl when we deal with terminal devices. </p>\n<h2 id=\"Exercises\"><a href=\"#Exercises\" class=\"headerlink\" title=\"Exercises\"></a>Exercises</h2><ol>\n<li><p>When reading or writing a disk file, are the functions described in this chapter really unbuffered? Explain. </p>\n</li>\n<li><p>Write your own dup2 function that behaves the same way as the dup2 function described in Section 3.12, without calling the fcntl function. Be sure to handle errors correctly. </p>\n</li>\n<li><p>Assume that a process executes the following three function calls: </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fd1 = open(path, oflags);</span><br><span class=\"line\">fd2 = dup(fd1);</span><br><span class=\"line\">fd3 = open(path, oflags);</span><br></pre></td></tr></table></figure>\n<p>Draw the resulting picture, similar to Figure 3.9. Which descriptors are affected by an fcntl on fd1 with a command of F_SETFD? Which descriptors are affected by an fcntl on fd1 with a command of F_SETFL? </p>\n</li>\n<li><p>The following sequence of code has been observed in various programs: </p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dup2(fd, <span class=\"number\">0</span>);</span><br><span class=\"line\">dup2(fd, <span class=\"number\">1</span>);</span><br><span class=\"line\">dup2(fd, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (fd &gt; <span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>close(fd); </p>\n<p>To see why the if test is needed, assume that fd is 1 and draw a picture of what happens to the three descriptor entries and the corresponding file table entry with each call to dup2. Then assume that fd is 3 and draw the same picture. </p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>这章将的是文件IO，其中有几个非常重要的概念：</p>\n<ol>\n<li>File Desriptors，文件描述符</li>\n<li>current file offset，当前文件偏移量</li>\n<li>File Sharing Data Structure，文件共享数据模型</li>\n<li>file descriptor flags ，文件描述位</li>\n<li>file status flags ，文件状态位</li>\n</ol>\n<h2 id=\"File-Descriptors\"><a href=\"#File-Descriptors\" class=\"headerlink\" title=\"File Descriptors\"></a>File Descriptors</h2><ul>\n<li><p>对内核来说，所有 <strong>打开的文件</strong> 都使用file descriptor引用。</p>\n</li>\n<li><p>文件描述符是一个非负整数。当我们打开一个存在的文件或者创建一个新文件，内核返回一个文件描述符给进程。</p>\n</li>\n<li><p>当我们想要读或者写一个文件，我们通过文件描述符来确定这个文件，文件描述符是被open或者creat返回的，然后作为read或者write的一个参数。</p>\n</li>\n</ul>\n<blockquote>\n<p>文件描述符都使用尽可能小的非负整数，File descriptors range from 0 through OPEN_MAX−1. </p>\n</blockquote>\n<p>有三个magic number，0代表STDIN_FILENO，1代表STDOUT_FILENO，2代表STDERR_FILENO。虽然这已经是POSIX.1所定义的标准，但为了程序的可读性，还是不建议直接写数字。这三个常量定义在<code>&lt;unistd.h&gt;</code>中。</p>\n<h2 id=\"open-and-openat-Functions\"><a href=\"#open-and-openat-Functions\" class=\"headerlink\" title=\"open and openat Functions\"></a>open and openat Functions</h2><p>A file is opened or created by calling either the open function or the openat function. </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">open</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *path, <span class=\"keyword\">int</span> oflag, ... <span class=\"comment\">/* mode_t mode */</span> )</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">openat</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *path, <span class=\"keyword\">int</span> oflag, ... <span class=\"comment\">/* mode_t mode */</span> )</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// Both return: file descriptor if OK, −1 on error</span></span><br></pre></td></tr></table></figure>\n<p>最后一个参数是<code>…</code>，这是ISO C定义剩下的多个参数的方式。对这些函数来说，只有当新文件被创建时，最后一个参数才被使用，后面我们会讲。在这个原型中我们把这个参数写作一个注释。</p>\n<p>path这个参数是要打开或者要创建的文件的名字。这个函数有多种操作，定在在oflag参数里。这个参数由下列一个或者多个定义在<code>&lt;fcntl.h&gt;</code>头文件中的常量通过或操作构成：</p>\n<p>O_RDONLY    Open for reading only</p>\n<p>O_WRONLY    Open for writing only</p>\n<p>O_RDWR    Open for reading and writing</p>\n<blockquote>\n<p>Most implementations define O_RDONLY as 0, O_WRONLY as 1, and O_RDWR as 2, for compatibility with older programs.  <strong>为了兼容老程序，许多实现定义O_RDONLY as 0, O_WRONLY as 1, and O_RDWR as 2</strong>。</p>\n</blockquote>\n<p>O_EXEC        Open for execute only</p>\n<p>O_SEARCH    Open for search only(applies to directories)</p>\n<blockquote>\n<p>The purpose of the O_SEARCH constant is to evaluate search permissions at the time a directory is opened. Further operations using the directory’s file descriptor will not reevaluate permission to search the directory. None of the versions of the operating systems covered in this book support O_SEARCH yet. </p>\n</blockquote>\n<p>One and only one of the previous five constants must be specified. The following constants are optional: </p>\n<p>上面的五个常量有且只有一个必须被明确。接下来的是可选常量：</p>\n<p>O_APPEND    Append to the end of file on each write. We describe this option in detail in Section 3.11. </p>\n<p>O_CLOEXEC    Set the FD_CLOEXEC file descriptor flag. We discuss file descriptor flags in Section 3.14. </p>\n<p>O_CREAT    Create the file if it doesn’t exist. This option requires a third argument to the open function (a fourth argument to the openat function) — the mode, which specifies the access permission bits of the new file. (When we describe a file’s access permission bits in Section 4.5, we’ll see how to specify the mode and how it can be modified by the umask value of a process.)  创建一个文件，如果不存在。这个操作需要open函数的第三个参数（openat函数的第四个参数）— mode，<strong>它明确了这个新文件的访问权限位</strong>。（当我们在第4.5章节讨论文件的访问权限位，我们将看到如何明确mode，以及它如何修改进程的umask值。）</p>\n<p>O_DIRECTORY    Generate an error if path doesn’t refer to a directory. </p>\n<p>O_EXCL        Generate an error if O_CREAT is also specified and the file already exists. This test for whether the file already exists and the creation of the file if it doesn’t exist is an atomic operation. We describe atomic operations in more detail in Section 3.11.  如果O_CREAT被使用了且文件已经存在就会生成一个错误。这个常量的作用是检测文件是否存在如果文件不存在就创建，这是一个原子操作。我们将在第3.11章节讨论更多原子操作的细节。</p>\n<p>O_NOCTTY    If path refers to a terminal device, do not allocate the device as the controlling terminal for this process. We talk about controlling terminals in Section 9.6.  如果这个路径指向的是终端设备，则不将这个设备分配为此进程的控制终端。</p>\n<p>O_NONBLOCK    If path refers to a FIFO, a block special file, or a character special file, this option sets the nonblocking mode for both the opening of the file and subsequent I/O. We describe this mode in Section 14.2.  如果path指向FIFO（先进先出），一个块特殊文件，一个字符特殊文件，这个选项设置了非阻塞模式为本次的打开操作和后续的I/O操作。</p>\n<blockquote>\n<p>In earlier releases of System V, the O_NDELAY (no delay) flag was introduced. This option is similar to the O_NONBLOCK (nonblocking) option, but an ambiguity was introduced in the return value from a read operation. The no-delay option causes a read operation to return 0 if there is no data to be read from a pipe, FIFO, or device, but this conflicts with a return value of 0, indicating an end of file. SVR4-based systems still support the no-delay option, with the old semantics, but new applications should use the nonblocking option instead.  在早期的System V，有一个O_NDELAY(no delay)符号。这个符号和O_NONBLOCK(nonblocking)选项相似，但他的读操作返回值具有二义性。如果管道，先进先出，或者设备没有数据可读，no-delay选项就会造成read操作返回0，这与end of file造成的返回值0冲突了。虽然基于SVR4的系统还支持这个no-delay选项，但新的应用应该使用nonblocking选项。</p>\n</blockquote>\n<p>O_SYNC        Have each write wait for physical I/O to complete, including I/O necessary to update file attributes modified as a result of the write. We use this option in Section 3.14.  使每次write都等物理I/O完成，包括更新文件属性所需要的I/O。</p>\n<p>O_TTY_INIT    When opening a terminal device that is not already open, set the nonstandard termios parameters to values that result in behavior that conforms to the Single UNIX Specification. We discuss the termios structure when we discuss terminal I/O in Chapter 18.  当打开一个新的终端设备的时候，设置非标准参数 termios。</p>\n<p>The following two flags are also optional. They are part of the synchronized input and output option of the Single UNIX Specification (and thus POSIX.1). </p>\n<p>O_DSYNC    Have each write wait for physical I/O to complete, but don’t wait for file attributes to be updated if they don’t affect the ability to read the data just written.  让所有write都等待物理I/O完成，但是不用等文件属性更新，如果不影响刚刚写完的数据的读操作的话。</p>\n<p>O_RSYNC    Have each read operation on the file descriptor wait until any pending writes for the same portion of the file are complete.  使每个使用文件描述符的的读操作等待，直到对文件的同一部分的所有写操作完成。</p>\n<blockquote>\n<p>Solaris 10 supports all three synchronization flags. Historically, FreeBSD (and thus Mac OS X) have used the O_FSYNC flag, which has the same behavior as O_SYNC. Because the two flags are equivalent, they define the flags to have the same value. FreeBSD 8.0 doesn’t support the O_DSYNC or O_RSYNC flags. Mac OS X doesn’t support the O_RSYNC flag, but defines the O_DSYNC flag, treating it the same as the O_SYNC flag. Linux 3.2.0 supports the O_DSYNC flag, but treats the O_RSYNC flag the same as O_SYNC. </p>\n</blockquote>\n<p><strong>The file descriptor returned by open and openat is guaranteed to be the lowest- numbered unused descriptor</strong>. This fact is used by some applications to open a new file on standard input, standard output, or standard error. <strong>For example, an application might close standard output—normally, file descriptor 1—and then open another file, knowing that it will be opened on file descriptor 1</strong>. We’ll see a better way to guarantee that a file is open on a given descriptor in Section 3.12, when we explore the dup2 function. </p>\n<p><strong>The fd parameter</strong> distinguishes the openat function from the open function. There are three possibilities:</p>\n<ol>\n<li><p>The path parameter specifies an absolute pathname. In this case, the fd parameter is ignored and the openat function behaves like the open function. </p>\n</li>\n<li><p>The path parameter specifies a relative pathname and the fd parameter is a file descriptor that specifies the starting location in the file system where the relative pathname is to be evaluated. The fd parameter is obtained by opening the directory where the relative pathname is to be evaluated. </p>\n</li>\n<li><p>The path parameter specifies a relative pathname and the fd parameter has the special value AT_FDCWD. In this case, the pathname is evaluated starting in the current working directory and the openat function behaves like the open function. </p>\n</li>\n</ol>\n<p>The openat function is one of a class of functions added to the latest version of POSIX.1 to address two problems. First, it gives threads a way to use relative pathnames to open files in directories other than the current working directory. As we’ll see in Chapter 11, all threads in the same process share the same current working directory, so this makes it difficult for multiple threads in the same process to work in different directories at the same time. Second, it provides a way to avoid time-of-check- to-time-of-use (TOCTTOU) errors.  openat函数是在最后一个版本的POSIX.1加入的，为了解决两个问题。首先，它给线程以相对路径而非当前路径。我们将在第11章看到，在同一进程中的所有线程共享同一个当前目录，所以要让同一进程中的多线程同时在不同的目录工作是非常困难的。第二，它提供了避免 time-of-check-to-time-of-use（TOCTTOU） 错误。</p>\n<p>The basic idea behind TOCTTOU errors is that a program is vulnerable if it makes two file-based function calls where the second call depends on the results of the first call. Because the two calls are not atomic, the file can change between the two calls, thereby invalidating the results of the first call, leading to a program error. TOCTTOU errors in the file system namespace generally deal with attempts to subvert file system permissions by tricking a privileged program into either reducing permissions on a privileged file or modifying a privileged file to open up a security hole. Wei and Pu [2005] discuss TOCTTOU weaknesses in the UNIX file system interface.  TOCTTOU错误的意思是，一个调用横叉一脚影响了另一个调用，本来另一个调用应该是一个原子操作。</p>\n<h3 id=\"Filename-and-Pathname-Truncation\"><a href=\"#Filename-and-Pathname-Truncation\" class=\"headerlink\" title=\"Filename and Pathname Truncation\"></a>Filename and Pathname Truncation</h3><p>What happens if NAME_MAX is 14 and we try to create a new file in the current directory with a filename containing 15 characters? Traditionally, early releases of System V, such as SVR2, allowed this to happen, silently truncating the filename beyond the 14th character. BSD-derived systems, in contrast, returned an error status, with errno set to ENAMETOOLONG. Silently truncating the filename presents a problem that affects more than simply the creation of new files. If NAME_MAX is 14 and a file exists whose name is exactly 14 characters, any function that accepts a pathname argument, such as open or stat, has no way to determine what the original name of the file was, as the original name might have been truncated.  如果NAME_MAX是14怎么办？传统上，早期的System V系统，允许这发生，静默的将文件名截断成14字符。相反的，BSD派生的系统，返回一个错误状态，并把errno设置成ENAMETOOLONG。静默的截断文件名呈现的问题不仅仅是创建了一个新文件。如果NAME_MAX是14且文件存在，且它的名字就是14字符，任何接收一个路径名作为参数的函数，比如open或者stat，没办法判断文件原来的名字是什么，因为原始文件名可能已经被截断。</p>\n<p>With POSIX.1, the constant <code>_POSIX_NO_TRUNC</code> determines whether long filenames and long components of pathnames are truncated or an error is returned. As we saw in Chapter 2, this value can vary based on the type of the file system, and we can use fpathconf or pathconf to query a directory to see which behavior is supported.  在POSIX.1标准里，常量 <code>_POSIX_NO_TRUNC</code> 决定长文件名和路径名中长的组件是否被截断或者是否返回一个错误。正如我们在第二章中看到的，这个值在文件系统中是非常基本的，我们可以使用 <code>fpathconf</code> 或 <code>pathconf</code>查询一个目录看看它支持哪种行为。</p>\n<blockquote>\n<p>Whether an error is returned is largely historical. For example, SVR4-based systems do not generate an error for the traditional System V file system, S5. For the BSD-style file system (known as UFS), however, SVR4-based systems do generate an error. Figure 2.20 illustrates another example: Solaris will return an error for UFS, but not for PCFS, the DOS-compatible file system, as DOS silently truncates filenames that don’t fit in an 8.3 format. BSD-derived systems and Linux always return an error. </p>\n</blockquote>\n<p>If _POSIX_NO_TRUNC is in effect, errno is set to ENAMETOOLONG, and an error status is returned if any filename component of the pathname exceeds NAME_MAX. </p>\n<blockquote>\n<p>Most modern file systems support a maximum of 255 characters for filenames. Because filenames are usually shorter than this limit, this constraint tends to not present problems for most applications. </p>\n</blockquote>\n<h3 id=\"creat-Function\"><a href=\"#creat-Function\" class=\"headerlink\" title=\"creat Function\"></a>creat Function</h3><p>A new file can also be created by calling the creat function. </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">creat</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *path, <span class=\"keyword\">mode_t</span> mode)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// Returns: file descriptor opened for write-only if OK, −1 on error</span></span><br></pre></td></tr></table></figure>\n<p>Note that this function is equivalent to </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open(path, O_WRONLY | O_CREAT | O_TRUNC, mode);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>Historically, in early versions of the UNIX System, the second argument to open could be only 0, 1, or 2. There was no way to open a file that didn’t already exist. Therefore, a separate system call, creat, was needed to create new files. With the O_CREAT and O_TRUNC options now provided by open, a separate creat function is no longer needed.  这个函数诞生的原因是：历史上open函数的第二个参数只支持0，1，2这三个值，也就是读，写，读写。没办法打开一个不存在的文件。而现在有了O_CREAT and O_TRUNC options，creat函数也就没有存在的必要了。</p>\n</blockquote>\n<p>We’ll show how to specify mode in Section 4.5 when we describe a file’s access permissions in detail. </p>\n<p>One deficiency with creat is that the file is opened only for writing. Before the new version of open was provided, if we were creating a temporary file that we wanted to write and then read back, we had to call creat, close, and then open. A better way is to use the open function, as in </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">open(path, O_RDWR | O_CREAT | O_TRUNC, mode);</span><br></pre></td></tr></table></figure>\n<h3 id=\"close-Function\"><a href=\"#close-Function\" class=\"headerlink\" title=\"close Function\"></a>close Function</h3><p>An open file is closed by calling the close function. </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt; </span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Returns: 0 if OK, −1 on error</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">close</span><span class=\"params\">(<span class=\"keyword\">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>Closing a file also releases any record locks that the process may have on the file. We’ll discuss this point further in Section 14.3.  关闭一个文件同样会释放进程对该文件的所有锁。</p>\n<p>When a process terminates, all of its open files are closed automatically by the kernel. Many programs take advantage of this fact and don’t explicitly close open files. See the program in Figure 1.4, for example.  当一个进程终止，所有它打开的文件都会被内核自动关闭。许多程序利用了这一点，不明确关闭文件。</p>\n<h3 id=\"lseek-Function\"><a href=\"#lseek-Function\" class=\"headerlink\" title=\"lseek Function\"></a>lseek Function</h3><p>Every open file has an associated ‘‘current file offset,’’ normally a non-negative integer that measures the number of bytes from the beginning of the file. (We describe some exceptions to the ‘‘non-negative’’ qualifier later in this section.) Read and write operations normally start at the current file offset and cause the offset to be incremented by the number of bytes read or written. By default, this offset is initialized to 0 when a file is opened, unless the O_APPEND option is specified.  每个打开的文件都与 “current file offset”关联，正常情况下它是一个非负整形数，表示从文件开始到目前位置的字节数。读和写操作都是从 current file offset开始的，并且会让offset增加，随着读和写的进行。默认的，当文件被打开时，这个位移初始化时0，除非指明了O_APPEND选项。</p>\n<p>An open file’s offset can be set explicitly by calling lseek.  通过调用 lseek函数，一个打开的文件的offset可以被设定。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">off_t</span> lseek(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">off_t</span> offset, <span class=\"keyword\">int</span> whence);</span><br><span class=\"line\"><span class=\"comment\">// Returns: new file offset if OK, −1 on error</span></span><br></pre></td></tr></table></figure>\n<p>The interpretation of the offset depends on the value of the whence argument. </p>\n<ul>\n<li><p>If whence is SEEK_SET, the file’s offset is set to offset bytes from the beginning of </p>\n<p>the file. </p>\n</li>\n<li><p>If whence is SEEK_CUR, the file’s offset is set to its current value plus the offset. </p>\n<p>The offset can be positive or negative. </p>\n</li>\n<li><p>If whence is SEEK_END, the file’s offset is set to the size of the file plus the offset. </p>\n<p>The offset can be positive or negative.</p>\n</li>\n</ul>\n<p>Because a successful call to lseek returns the new file offset, we can seek zero bytes </p>\n<p>from the current position to determine the current offset: </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">off_t</span>    currpos;</span><br><span class=\"line\">currpos = lseek(fd, <span class=\"number\">0</span>, SEEK_CUR);</span><br></pre></td></tr></table></figure>\n<p>This technique can also be used to determine if a file is capable of seeking. If the file descriptor refers to a pipe, FIFO, or socket, lseek sets errno to <strong>ESPIPE</strong> and returns −1.  </p>\n<blockquote>\n<p>The three symbolic constants—SEEK_SET, SEEK_CUR, and SEEK_END—were introduced with System V. Prior to this, <strong>whence was specified as 0 (absolute), 1 (relative to the current offset), or 2 (relative to the end of file). Much software still exists with these numbers hard coded</strong>. </p>\n<p><strong>The character l in the name lseek means ‘‘long integer.’’ Before the introduction of the off_t data type, the offset argument and the return value were long integers</strong>. lseek was introduced with Version 7 when long integers were added to C. (Similar functionality was provided in Version 6 by the functions seek and tell.) </p>\n</blockquote>\n<h3 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h3><p>The program in Figure 3.1 tests its standard input to see whether it is capable of seeking. </p>\n<blockquote>\n<p>Figure 3.1 Test whether standard input is capable of seeking </p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"apue.h\"</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lseek(STDIN_FILENO, <span class=\"number\">0</span>, SEEK_CUR) == <span class=\"number\">-1</span>)</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"cannot seek\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"seek OK\\n\"</span>);</span><br><span class=\"line\"> \t<span class=\"built_in\">exit</span>(<span class=\"number\">0</span>); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>Normally, a file’s current offset must be a non-negative integer. It is possible, however, that certain devices could allow negative offsets. But for regular files, the offset must be non-negative. Because negative offsets are possible, we should be careful to compare the return value from lseek as being equal to or not equal to −1, rather than testing whether it is less than 0</strong>. </p>\n<blockquote>\n<p>The /dev/kmem device on FreeBSD for the Intel x86 processor supports negative offsets. Because the offset (off_t) is a signed data type (Figure 2.21), we lose a factor of 2 in the maximum file size. If off_t is a 32-bit integer, the maximum file size is $2^{31}$−1 bytes. </p>\n</blockquote>\n<p>lseek only records the current file offset within the kernel — it does not cause any I/O to take place. This offset is then used by the next read or write operation. </p>\n<p>The file’s offset can be greater than the file’s current size, in which case the next write to the file will extend the file. This is referred to as creating a hole in a file and is allowed. Any bytes in a file that have not been written are read back as 0.  文件偏移量可以大于文件的目前大小，在这种情况下下一次写文件将扩展文件。也就是说在文件中创建一个空洞是被允许的。在文件中任何没被写入的部分都将被读作0。</p>\n<p>A hole in a file isn’t required to have storage backing it on disk. Depending on the file system implementation, when you write after seeking past the end of a file, new disk blocks might be allocated to store the data, but there is no need to allocate disk blocks for the data between the old end of file and the location where you start writing.  文件中的空洞并不需要存储到磁盘上。根据文件系统的实现，当你在end of file之后写，为了存储数据新的磁盘空间可能会分配，但没有必要分配磁盘块给end of file和你开始写的地方之间的这些数据。</p>\n<h3 id=\"Example-1\"><a href=\"#Example-1\" class=\"headerlink\" title=\"Example\"></a>Example</h3><p>The program shown in Figure 3.2 creates a file with a hole in it. </p>\n<blockquote>\n<p>Figure 3.2  Create a file with a hole in it </p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"apue.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">char</span>    buf1[] = <span class=\"string\">\"abcdefghij\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span>    buf2[] = <span class=\"string\">\"ABCDEFGHIJ\"</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">true<span class=\"keyword\">int</span> fd;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((fd = creat(<span class=\"string\">\"file.hole\"</span>, FILE_MODE)) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    \terr_sys(<span class=\"string\">\"creat error\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (write(fd, buf1, <span class=\"number\">10</span>) != <span class=\"number\">10</span>)</span><br><span class=\"line\">    \terr_sys(<span class=\"string\">\"buf1 write error\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">/* offset now = 10 */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (lseek(fd, <span class=\"number\">16384</span>, SEEK_SET) == <span class=\"number\">-1</span>)</span><br><span class=\"line\">    \terr_sys(<span class=\"string\">\"lseek error\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">/* offset now = 16384 */</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (write(fd, buf2, <span class=\"number\">10</span>) != <span class=\"number\">10</span>)</span><br><span class=\"line\">        err_sys(<span class=\"string\">\"buf2 write error\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">/* offset now = 16394 */</span></span><br><span class=\"line\">true<span class=\"built_in\">exit</span>(<span class=\"number\">0</span>); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"File-Sharing\"><a href=\"#File-Sharing\" class=\"headerlink\" title=\"File Sharing\"></a>File Sharing</h2><p>The UNIX System supports the sharing of open files among different processes. Before describing the dup function, we need to describe this sharing. To do this, we’ll examine the data structures used by the kernel for all I/O. </p>\n<blockquote>\n<p>The following description is conceptual; it may or may not match a particular implementation. Refer to Bach [1986] for a discussion of these structures in System V. McKusick et al. [1996] describe these structures in 4.4BSD. McKusick and Neville-Neil [2005] cover FreeBSD 5.2. For a similar discussion of Solaris, see McDougall and Mauro [2007]. The Linux 2.6 kernel architecture is discussed in Bovet and Cesati [2006]. </p>\n</blockquote>\n<p>The kernel uses three data structures to represent an open file, and the relationships among them determine the effect one process has on another with regard to file sharing. </p>\n<ol>\n<li><p>Every process has an entry in the process table. Within each process table entry is a table of open file descriptors, which we can think of as a vector, with one entry per descriptor. Associated with each file descriptor are </p>\n<ol>\n<li>The file descriptor flags (close-on-exec; refer to Figure 3.7 and Section 3.14) </li>\n<li>A pointer to a file table entry </li>\n</ol>\n</li>\n<li><p>The kernel maintains a file table for all open files. Each file table entry contains </p>\n<ol>\n<li>The file status flags for the file, such as read, write, append, sync, and nonblocking; more on these in Section 3.14 </li>\n<li>The current file offset </li>\n<li>A pointer to the v-node table entry for the file </li>\n</ol>\n</li>\n<li><p>Each open file (or device) has a v-node structure that <strong>contains information about the type of file</strong> and <strong>pointers to functions that operate on the file</strong>. For most files, the v-node also contains the i-node for the file. <strong>This information is read from disk when the file is opened</strong>, so that all the pertinent information about the file is readily available. For example, <strong>the i-node contains the owner of the file, the size of the file, pointers to where the actual data blocks for the file are located on disk</strong>, and so on. (We talk more about i-nodes in Section 4.14 when we describe the typical UNIX file system in more detail.) </p>\n</li>\n</ol>\n<blockquote>\n<p>Linux has no v-node. Instead, a generic i-node structure is used. Although the implementations differ, the v-node is conceptually the same as a generic i-node. Both point to an i-node structure specific to the file system.</p>\n</blockquote>\n<p>We’re ignoring some implementation details that don’t affect our discussion. For example, the table of open file descriptors can be stored in the user area (a separate per- process structure that can be paged out) instead of the process table. Also, these tables can be implemented in numerous ways—they need not be arrays; one alternate implementation is a linked lists of structures. Regardless of the implementation details, the general concepts remain the same. </p>\n<p>Figure 3.7 shows a pictorial arrangement of these three tables for a single process that has two different files open: one file is open on standard input (file descriptor 0), and the other is open on standard output (file descriptor 1). </p>\n<p><img src=\"https://i.loli.net/2018/05/30/5b0e51e54c6d1.png\"></p>\n<p>The arrangement of these three tables has existed since the early versions of the UNIX System [Thompson 1978]. <strong>This arrangement is critical to the way files are shared among processes</strong>. We’ll return to this figure in later chapters, when we describe additional ways that files are shared. </p>\n<blockquote>\n<p><strong>The v-node was invented to provide support for multiple file system types on a single computer system</strong>. This work was done independently by Peter Weinberger (Bell Laboratories) and Bill Joy (Sun Microsystems). <strong>Sun called this the Virtual File System and called the file system–independent portion of the i-node the v-node</strong> [Kleiman 1986]. The v-node propagated through various vendor implementations as support for Sun’s Network File System (NFS) was added. The first release from Berkeley to provide v-nodes was the 4.3BSD Reno release, when NFS was added. </p>\n</blockquote>\n<blockquote>\n<p>In SVR4, the v-node replaced the file system–independent i-node of SVR3. Solaris is derived from SVR4 and, therefore, uses v-nodes. </p>\n</blockquote>\n<blockquote>\n<p>Instead of splitting the data structures into a v-node and an i-node, Linux uses a file system–independent i-node and a file system–dependent i-node. </p>\n</blockquote>\n<p>If two independent processes have the same file open, we could have the arrangement shown in Figure 3.8. </p>\n<p><img src=\"https://i.loli.net/2018/05/30/5b0e5b6638838.png\"></p>\n<p>We assume here that the first process has the file open on descriptor 3 and that the second process has that same file open on descriptor 4. Each process that opens the file gets its own file table entry, but only a single v-node table entry is required for a given file. One reason each process gets its own file table entry is so that each process has its own current offset for the file. </p>\n<p>Given these data structures, we now need to be more specific about what happens with certain operations that we’ve already described. </p>\n<ul>\n<li>After each write is complete, the current file offset in the file table entry is incremented by the number of bytes written. If this causes the current file offset to exceed the current file size, the current file size in the i-node table entry is set to the current file offset (for example, the file is extended). </li>\n<li>If a file is opened with the O_APPEND flag, a corresponding flag is set in the file status flags of the file table entry. Each time a write is performed for a file with this append flag set, the current file offset in the file table entry is first set to the current file size from the i-node table entry. This forces every write to be appended to the current end of file. </li>\n<li>If a file is positioned to its current end of file using lseek, all that happens is the current file offset in the file table entry is set to the current file size from the i-node table entry. (Note that this is not the same as if the file was opened with the O_APPEND flag, as we will see in Section 3.11.) </li>\n<li>The lseek function modifies only the current file offset in the file table entry. No I/O takes place. </li>\n</ul>\n<p>It is possible for more than one file descriptor entry to point to the same file table entry, as we’ll see when we discuss the dup function in Section 3.12. This also happens after a fork when the parent and the child share the same file table entry for each open descriptor (Section 8.3). </p>\n<p><strong>Note the difference in scope between the file descriptor flags and the file status flags. The former apply only to a single descriptor in a single process, whereas the latter apply to all descriptors in any process that point to the given file table entry</strong>. When we describe the fcntl function in Section 3.14, we’ll see how to fetch and modify both the file descriptor flags and the file status flags. </p>\n<p>Everything that we’ve described so far in this section works fine for multiple processes that are reading the same file. Each process has its own file table entry with its own current file offset. Unexpected results can arise, however, when multiple processes write to the same file. To see how to avoid some surprises, we need to understand the concept of atomic operations. </p>\n<h2 id=\"Atomic-Operations\"><a href=\"#Atomic-Operations\" class=\"headerlink\" title=\"Atomic Operations\"></a>Atomic Operations</h2><h3 id=\"Appending-to-a-File\"><a href=\"#Appending-to-a-File\" class=\"headerlink\" title=\"Appending to a File\"></a>Appending to a File</h3><p>Consider a single process that wants to append to the end of a file. Older versions of the UNIX System didn’t support the O_APPEND option to open, so the program was coded as follows: </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (lseek(fd, <span class=\"number\">0L</span>, <span class=\"number\">2</span>) &lt; <span class=\"number\">0</span>)         <span class=\"comment\">/* position to EOF */</span></span><br><span class=\"line\">trueerr_sys(<span class=\"string\">\"lseek error\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (write(fd, buf, <span class=\"number\">100</span>) != <span class=\"number\">100</span>)   <span class=\"comment\">/* and write */</span></span><br><span class=\"line\">trueerr_sys(<span class=\"string\">\"write error\"</span>);</span><br></pre></td></tr></table></figure>\n<p>This works fine for a single process, but problems arise if multiple processes use this technique to append to the same file. (This scenario can arise if multiple instances of the same program are appending messages to a log file, for example.) </p>\n<p>Assume that two independent processes, A and B, are appending to the same file. Each has opened the file but without the O_APPEND flag. This gives us the same picture as Figure 3.8. Each process has its own file table entry, but they share a single v-node table entry. Assume that process A does the lseek and that this sets the current offset for the file for process A to byte offset 1,500 (the current end of file). Then the kernel switches processes, and B continues running. Process B then does the lseek, which sets the current offset for the file for process B to byte offset 1,500 also (the current end of file). Then B calls write, which increments B’s current file offset for the file to 1,600. Because the file’s size has been extended, the kernel also updates the current file size in the v-node to 1,600. Then the kernel switches processes and A resumes. When A calls write, the data is written starting at the current file offset for A, which is byte offset 1,500. This overwrites the data that B wrote to the file. </p>\n<p>The problem here is that our logical operation of ‘‘position to the end of file and write’’ requires two separate function calls (as we’ve shown it). The solution is to have the positioning to the current end of file and the write be an atomic operation with regard to other processes. Any operation that requires more than one function call cannot be atomic, as there is always the possibility that the kernel might temporarily suspend the process between the two function calls (as we assumed previously). </p>\n<p>The UNIX System provides an atomic way to do this operation if we set the O_APPEND flag when a file is opened. As we described in the previous section, this causes the kernel to position the file to its current end of file before each write. We no longer have to call lseek before each write. </p>\n<h3 id=\"pread-and-pwrite-Functions\"><a href=\"#pread-and-pwrite-Functions\" class=\"headerlink\" title=\"pread and pwrite Functions\"></a>pread and pwrite Functions</h3><p>The Single UNIX Specification includes two functions that allow applications to seek and perform I/O atomically: pread and pwrite. </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Returns: number of bytes read, 0 if end of file, −1 on error</span></span><br><span class=\"line\"><span class=\"keyword\">ssize_t</span> pread(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">void</span> *buf, <span class=\"keyword\">size_t</span> nbytes, <span class=\"keyword\">off_t</span> offset);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Returns: number of bytes written if OK, −1 on error</span></span><br><span class=\"line\"><span class=\"keyword\">ssize_t</span> pwrite(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *buf, <span class=\"keyword\">size_t</span> nbytes, <span class=\"keyword\">off_t</span> offset);</span><br></pre></td></tr></table></figure>\n<p>Calling pread is equivalent to calling lseek followed by a call to read, with the following exceptions. </p>\n<ul>\n<li><p>There is no way to interrupt the two operations that occur when we call pread. </p>\n</li>\n<li><p>The current file offset is not updated. </p>\n</li>\n</ul>\n<p>Calling pwrite is equivalent to calling lseek followed by a call to write, with similar exceptions. </p>\n<h3 id=\"Creating-a-File\"><a href=\"#Creating-a-File\" class=\"headerlink\" title=\"Creating a File\"></a>Creating a File</h3><p>We saw another example of an atomic operation when we described the O_CREAT and O_EXCL options for the open function. When both of these options are specified, the open will fail if the file already exists. We also said that the check for the existence of the file and the creation of the file was performed as an atomic operation. If we didn’t have this atomic operation, we might try </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ((fd = open(path, O_WRONLY)) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (errno == ENOENT) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((fd = creat(path, mode)) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            err_sys(<span class=\"string\">\"creat error\"</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        err_sys(<span class=\"string\">\"open error\"</span>);</span><br><span class=\"line\">&#125; &#125;</span><br></pre></td></tr></table></figure>\n<p>The problem occurs if the file is created by another process between the open and the creat. If the file is created by another process between these two function calls, and if that other process writes something to the file, that data is erased when this creat is executed. Combining the test for existence and the creation into a single atomic operation avoids this problem. </p>\n<p>In general, the term atomic operation refers to an operation that might be composed of multiple steps. If the operation is performed atomically, either all the steps are performed (on success) or none are performed (on failure). It must not be possible for only a subset of the steps to be performed. We’ll return to the topic of atomic operations when we describe the link function (Section 4.15) and record locking (Section 14.3). </p>\n<h2 id=\"dup-and-dup2-Functions\"><a href=\"#dup-and-dup2-Functions\" class=\"headerlink\" title=\"dup and dup2 Functions\"></a>dup and dup2 Functions</h2><p>An existing file descriptor is duplicated by either of the following functions: </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Both return: new file descriptor if OK, −1 on error</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dup</span><span class=\"params\">(<span class=\"keyword\">int</span> fd)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">dup2</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">int</span> fd2)</span></span>;</span><br></pre></td></tr></table></figure>\n<p>The new file descriptor returned by dup is guaranteed to be the lowest-numbered available file descriptor. <strong>With dup2, we specify the value of the new descriptor with the fd2 argument. If fd2 is already open, it is first closed. If fd equals fd2, then dup2 returns fd2 without closing it. Otherwise, the FD_CLOEXEC file descriptor flag is cleared for fd2, so that fd2 is left open if the process calls exec</strong>.</p>\n<p>The new file descriptor that is returned as the value of the functions shares the same file table entry as the fd argument. We show this in Figure 3.9. </p>\n<p><img src=\"https://i.loli.net/2018/05/30/5b0e6c0a52034.png\"></p>\n<p>In this figure, we assume that when it’s started, the process executes </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">newfd = dup(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n<p>We assume that the next available descriptor is 3 (which it probably is, since 0, 1, and 2 are opened by the shell). Because both descriptors point to the same file table entry, they share the same file status flags—read, write, append, and so on—and the same current file offset. </p>\n<p>Each descriptor has its own set of file descriptor flags. As we describe in Section 3.14, the close-on-exec file descriptor flag for the new descriptor is always cleared by the dup functions. </p>\n<p>Another way to duplicate a descriptor is with the fcntl function, which we describe in Section 3.14. Indeed, the call </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dup(fd);</span><br></pre></td></tr></table></figure>\n<p>is equivalent to </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fcntl(fd, F_DUPFD, <span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n<p>Similarly, the call </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dup2(fd, fd2);</span><br></pre></td></tr></table></figure>\n<p>is equivalent to </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">close(fd2);</span><br><span class=\"line\">fcntl(fd, F_DUPFD, fd2);</span><br></pre></td></tr></table></figure>\n<p>In this last case, the dup2 is not exactly the same as a close followed by an fcntl. The differences are as follows: </p>\n<ol>\n<li>dup2 is an atomic operation, whereas the alternate form involves two function calls. It is possible in the latter case to have a signal catcher called between the close and the fcntl that could modify the file descriptors. (We describe signals in Chapter 10.) The same problem could occur if a different thread changes the file descriptors. (We describe threads in Chapter 11.) </li>\n<li>There are some errno differences between dup2 and fcntl. </li>\n</ol>\n<blockquote>\n<p>The dup2 system call originated with Version 7 and propagated through the BSD releases. The fcntl method for duplicating file descriptors appeared with System III and continued with SystemV. SVR3.2 picked up the dup2 function, and 4.2BSD picked up the fcntl function and the F_DUPFD functionality. POSIX.1 requires both dup2 and the F_DUPFD feature of fcntl. </p>\n</blockquote>\n<h2 id=\"sync-fsync-and-fdatasync-Functions\"><a href=\"#sync-fsync-and-fdatasync-Functions\" class=\"headerlink\" title=\"sync, fsync, and fdatasync Functions\"></a>sync, fsync, and fdatasync Functions</h2><p>Traditional implementations of the UNIX System have a buffer cache or page cache in the kernel through which most disk I/O passes. When we write data to a file, the data is normally copied by the kernel into one of its buffers and queued for writing to disk at some later time. This is called delayed write. (Chapter 3 of Bach [1986] discusses this buffer cache in detail.) </p>\n<p>The kernel eventually writes all the delayed-write blocks to disk, normally when it needs to reuse the buffer for some other disk block. To ensure consistency of the file system on disk with the contents of the buffer cache, the sync, fsync, and fdatasync functions are provided. </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt; </span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Both Returns: 0 if OK, −1 on error</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fsync</span><span class=\"params\">(<span class=\"keyword\">int</span> fd)</span></span>; </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fdatasync</span><span class=\"params\">(<span class=\"keyword\">int</span> fd)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sync</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>\n<p><strong>The sync function simply queues all the modified block buffers for writing and returns; it does not wait for the disk writes to take place</strong>. </p>\n<p><strong>The function sync is normally called periodically (usually every 30 seconds) from a system daemon, often called update</strong>. This guarantees regular flushing of the kernel’s block buffers. The command sync(1) also calls the sync function. </p>\n<p>The function fsync refers only to a single file, specified by the file descriptor fd, and <strong>waits for the disk writes to complete before returning</strong>. This function is used when an application, <strong>such as a database</strong>, needs to be sure that the modified blocks have been written to the disk. </p>\n<p><strong>The fdatasync function is similar to fsync, but it affects only the data portions of a file. With fsync, the file’s attributes are also updated synchronously</strong>. </p>\n<blockquote>\n<p>All four of the platforms described in this book support sync and fsync. However, FreeBSD 8.0 does not support fdatasync. </p>\n</blockquote>\n<h2 id=\"fcntl-Function\"><a href=\"#fcntl-Function\" class=\"headerlink\" title=\"fcntl Function\"></a>fcntl Function</h2><p>The fcntl function can change the properties of a file that is already open. </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Returns: depends on cmd if OK (see following), −1 on error</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">fcntl</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">int</span> cmd, ... <span class=\"comment\">/* int arg */</span> )</span></span>;</span><br></pre></td></tr></table></figure>\n<p>In the examples in this section, the third argument is always an integer, corresponding to the comment in the function prototype just shown. When we describe record locking in Section 14.3, however, the third argument becomes a pointer to a structure. </p>\n<p>The fcntl function is used for five different purposes. </p>\n<ol>\n<li><p>Duplicate an existing descriptor (cmd = F_DUPFD or F_DUPFD_CLOEXEC) </p>\n</li>\n<li><p>Get/set file descriptor flags (cmd = F_GETFD or F_SETFD) </p>\n</li>\n<li><p>Get/set file status flags (cmd = F_GETFL or F_SETFL) </p>\n</li>\n<li><p>Get/set asynchronous I/O ownership (cmd = F_GETOWN or F_SETOWN) </p>\n</li>\n<li><p>Get/set record locks (cmd = F_GETLK, F_SETLK, or F_SETLKW) </p>\n</li>\n</ol>\n<p>We’ll now describe the first 8 of these 11 cmd values. (We’ll wait until Section 14.3 to describe the last 3, which deal with record locking.) Refer to Figure 3.7, as we’ll discuss both the file descriptor flags associated with each file descriptor in the process table entry and the file status flags associated with each file table entry. </p>\n<p>F_DUPFD     Duplicate the file descriptor fd. The new file descriptor is returned as the value of the function. It is the lowest-numbered descriptor that is not already open, and that is greater than or equal to the third argument (taken as an integer). The new descriptor shares the same file table entry as fd. (Refer to Figure 3.9.) But the new descriptor has its own set of file descriptor flags, and its FD_CLOEXEC file descriptor flag is cleared. (This means that the descriptor is left open across an exec, which we discuss in Chapter 8.) </p>\n<p>F_DUPFD_CLOEXEC    Duplicate the file descriptor and set the FD_CLOEXEC file descriptor flag associated with the new descriptor. Returns the new file descriptor. </p>\n<p>F_GETFD     Return the file descriptor flags for fd as the value of the function. Currently, only one file descriptor flag is defined: the FD_CLOEXEC flag. </p>\n<p>F_SETFD     Set the file descriptor flags for fd. The new flag value is set from the third argument (taken as an integer). </p>\n<blockquote>\n<p>Be aware that some existing programs that deal with the file descriptor flags don’t use the constant FD_CLOEXEC. Instead, these programs set the flag to either 0 (don’t close-on-exec, the default) or 1 (do close-on-exec). </p>\n</blockquote>\n<p>F_GETFL     Return the file status flags for fd as the value of the function. We described the file status flags when we described the open function. They are listed in Figure 3.10. </p>\n<p><img src=\"https://i.loli.net/2018/05/31/5b0f49576d719.png\" width=\"70%\"></p>\n<p>Unfortunately, the five access-mode flags—O_RDONLY, O_WRONLY, O_RDWR, O_EXEC, and O_SEARCH—are not separate bits that can be tested. (As we mentioned earlier, the first three often have the values 0, 1, and 2, respectively, for historical reasons. Also, these five values are mutually exclusive; a file can have only one of them enabled.) Therefore, we must first use the O_ACCMODE mask to obtain the access-mode bits and then compare the result against any of the five values. </p>\n<p>F_SETFL         Set the file status flags to the value of the third argument (taken as an integer). The only flags that can be changed are O_APPEND, O_NONBLOCK, O_SYNC, O_DSYNC, O_RSYNC, O_FSYNC, and O_ASYNC. </p>\n<p>F_GETOWN     Get the process ID or process group ID currently receiving the SIGIO and SIGURG signals. We describe these asynchronous I/O signals in Section 14.5.2. </p>\n<p>F_SETOWN     Set the process ID or process group ID to receive the SIGIO and SIGURG signals. A positive arg specifies a process ID. A negative arg implies a process group ID equal to the absolute value of arg. </p>\n<p>The return value from fcntl depends on the command. All commands return −1 on an error or some other value if OK. The following four commands have special return values: F_DUPFD, F_GETFD, F_GETFL, and F_GETOWN. The first command returns the new file descriptor, the next two return the corresponding flags, and the final command returns a positive process ID or a negative process group ID. </p>\n<h3 id=\"Example-2\"><a href=\"#Example-2\" class=\"headerlink\" title=\"Example\"></a>Example</h3><p>The program in Figure 3.11 takes a single command-line argument that specifies a file descriptor and prints a description of selected file flags for that descriptor. </p>\n<blockquote>\n<p>Figure 3.11 Print file flags for specified descriptor </p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"include/apue.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">int</span> val;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (argc != <span class=\"number\">2</span>)</span><br><span class=\"line\">     err_quit(<span class=\"string\">\"usage: a.out &lt;descriptor#&gt;\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((val = fcntl(atoi(argv[<span class=\"number\">1</span>]), F_GETFL, <span class=\"number\">0</span>)) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">     err_sys(<span class=\"string\">\"fcntl error for fd %d\"</span>, atoi(argv[<span class=\"number\">1</span>]));</span><br><span class=\"line\">  <span class=\"keyword\">switch</span> (val &amp; O_ACCMODE) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> O_RDONLY:</span><br><span class=\"line\">       <span class=\"built_in\">printf</span>(<span class=\"string\">\"read only\"</span>);</span><br><span class=\"line\">       <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> O_WRONLY:</span><br><span class=\"line\">       <span class=\"built_in\">printf</span>(<span class=\"string\">\"write only\"</span>);</span><br><span class=\"line\">       <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">case</span> O_RDWR:</span><br><span class=\"line\">       <span class=\"built_in\">printf</span>(<span class=\"string\">\"read write\"</span>);</span><br><span class=\"line\">       <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    <span class=\"keyword\">default</span>:</span><br><span class=\"line\">       err_dump(<span class=\"string\">\"unknown access mode\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (val &amp; O_APPEND)</span><br><span class=\"line\">     <span class=\"built_in\">printf</span>(<span class=\"string\">\", append\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (val &amp; O_NONBLOCK)</span><br><span class=\"line\">     <span class=\"built_in\">printf</span>(<span class=\"string\">\", nonblocking\"</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (val &amp; O_SYNC)</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\", synchronous writes\"</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">if</span> !defined(_POSIX_C_SOURCE) &amp;&amp; defined(O_FSYNC) &amp;&amp; (O_FSYNC != O_SYNC)</span></span><br><span class=\"line\">         <span class=\"keyword\">if</span> (val &amp; O_FSYNC)</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\", synchronous writes\"</span>);</span><br><span class=\"line\">    <span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">  <span class=\"built_in\">putchar</span>(<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">  <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Note that we use the feature test macro _POSIX_C_SOURCE and conditionally compile the file access flags that are not part of POSIX.1. The following script shows the operation of the program, when invoked from bash (the Bourne-again shell). Results will vary, depending on which shell you use. </p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  apue.3e ./fig3.11 0 &lt; /dev/tty</span><br><span class=\"line\">read only</span><br><span class=\"line\">➜  apue.3e ./fig3.11 1 &gt; temp.foo</span><br><span class=\"line\">➜  apue.3e cat temp.foo</span><br><span class=\"line\">write only</span><br><span class=\"line\">➜  apue.3e ./fig3.11 2 2&gt;&gt;temp.foo</span><br><span class=\"line\">write only, append</span><br><span class=\"line\">➜  apue.3e ./fig3.11 5 5&lt;&gt;temp.foo</span><br><span class=\"line\">read write</span><br></pre></td></tr></table></figure>\n<p>The clause 5&lt;&gt;temp.foo opens the file temp.foo for reading and writing on file descriptor 5. </p>\n<h3 id=\"Example-3\"><a href=\"#Example-3\" class=\"headerlink\" title=\"Example\"></a>Example</h3><p>When we modify either the file descriptor flags or the file status flags, we must be careful to fetch the existing flag value, modify it as desired, and then set the new flag value. We can’t simply issue an F_SETFD or an F_SETFL command, as this could turn off flag bits that were previously set. </p>\n<p>Figure 3.12 shows a function that sets one or more of the file status flags for a descriptor. </p>\n<blockquote>\n<p>Figure 3.12 Turn on one or more of the file status flags for a descriptor </p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"apue.h\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">set_fl</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">int</span> flags)</span> <span class=\"comment\">/* flags are file status flags to turn on */</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">true<span class=\"keyword\">int</span> val;</span><br><span class=\"line\">true<span class=\"keyword\">if</span> ((val = fcntl(fd, F_GETFL, <span class=\"number\">0</span>)) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">true   err_sys(<span class=\"string\">\"fcntl F_GETFL error\"</span>);</span><br><span class=\"line\">trueval |= flags;       <span class=\"comment\">/* turn on flags */</span></span><br><span class=\"line\">true<span class=\"keyword\">if</span> (fcntl(fd, F_SETFL, val) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">true   err_sys(<span class=\"string\">\"fcntl F_SETFL error\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>If we change the middle statement to </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">val &amp;=  ̃flags;      <span class=\"comment\">/* turn flags off */</span></span><br></pre></td></tr></table></figure>\n<p>we have a function named clr_fl, which we’ll use in some later examples. This statement logically ANDs the one’s complement of flags with the current val. </p>\n<p>If we add the line </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set_fl(STDOUT_FILENO, O_SYNC);</span><br></pre></td></tr></table></figure>\n<p>to the beginning of the program shown in Figure 3.5, we’ll turn on the synchronous- write flag. This causes each write to wait for the data to be written to disk before returning. Normally in the UNIX System, a write only queues the data for writing; the actual disk write operation can take place sometime later. A database system is a likely candidate for using O_SYNC, so that it knows on return from a write that the data is actually on the disk, in case of an abnormal system failure. </p>\n<p>We expect the O_SYNC flag to increase the system and clock times when the program runs. To test this, we can run the program in Figure 3.5, copying 492.6 MB of data from one file on disk to another and compare this with a version that does the same thing with the O_SYNC flag set. The results from a Linux system using the ext4 file system are shown in Figure 3.13. </p>\n<p><img src=\"https://i.loli.net/2018/05/31/5b0f4c0dc6161.png\" width=\"80%\"></p>\n<p>The six rows in Figure 3.13 were all measured with a BUFFSIZE of 4,096 bytes. The results in Figure 3.6 were measured while reading a disk file and writing to /dev/null, so there was no disk output. The second row in Figure 3.13 corresponds to reading a disk file and writing to another disk file. This is why the first and second rows in Figure 3.13 are different. The system time increases when we write to a disk file, because the kernel now copies the data from our process and queues the data for writing by the disk driver. We expect the clock time to increase as well when we write to a disk file. </p>\n<p>When we enable synchronous writes, the system and clock times should increase significantly. As the third row shows, the system time for writing synchronously is not much more expensive than when we used delayed writes. This implies that the Linux operating system is doing the same amount of work for delayed and synchronous writes (which is unlikely), or else the O_SYNC flag isn’t having the desired effect. In this case, the Linux operating system isn’t allowing us to set the O_SYNC flag using fcntl, instead failing without returning an error (but it would have honored the flag if we were able to specify it when the file was opened). </p>\n<p>The clock time in the last three rows reflects the extra time needed to wait for all of the writes to be committed to disk. After writing a file synchronously, we expect that a call to fsync will have no effect. This case is supposed to be represented by the last row in Figure 3.13, but since the O_SYNC flag isn’t having the intended effect, the last row behaves the same way as the fifth row. </p>\n<p>Figure 3.14 shows timing results for the same tests run on Mac OS X 10.6.8, which uses the HFS file system. Note that the times match our expectations: synchronous writes are far more expensive than delayed writes, and using fsync with synchronous writes makes very little difference. Note also that adding a call to fsync at the end of the delayed writes makes little measurable difference. It is likely that the operating system flushed previously written data to disk as we were writing new data to the file, so by the time that we called fsync, very little work was left to be done. </p>\n<p><img src=\"https://i.loli.net/2018/05/31/5b0f4c6873af3.png\" width=\"80%\"></p>\n<p>Compare fsync and fdatasync, both of which update a file’s contents when we say so, with the O_SYNC flag, which updates a file’s contents every time we write to the file. The performance of each alternative will depend on many factors, including the underlying operating system implementation, the speed of the disk drive, and the type of the file system. </p>\n<p>With this example, we see the need for fcntl. Our program operates on a descriptor (standard output), never knowing the name of the file that was opened on that descriptor. We can’t set the O_SYNC flag when the file is opened, since the shell opened the file. With fcntl, we can modify the properties of a descriptor, knowing only the descriptor for the open file. We’ll see another need for fcntl when we describe nonblocking pipes (Section 15.2), since all we have with a pipe is a descriptor. </p>\n<h2 id=\"ioctl-Function\"><a href=\"#ioctl-Function\" class=\"headerlink\" title=\"ioctl Function\"></a>ioctl Function</h2><p>The ioctl function has always been the catchall for I/O operations. Anything that couldn’t be expressed using one of the other functions in this chapter usually ended up being specified with an ioctl. Terminal I/O was the biggest user of this function. (When we get to Chapter 18, we’ll see that POSIX.1 has replaced the terminal I/O operations with separate functions.) </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;     /* System V */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/ioctl.h&gt;  /* BSD and Linux */</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Returns: −1 on error, something else if OK</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">ioctl</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">int</span> request, ...)</span></span>;</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>The ioctl function was included in the Single UNIX Specification only as an extension for dealing with STREAMS devices [Rago 1993], but it was moved to obsolescent status in SUSv4. UNIX System implementations use ioctl for many miscellaneous device operations. Some implementations have even extended it for use with regular files. </p>\n</blockquote>\n<p>The prototype that we show corresponds to POSIX.1. FreeBSD 8.0 and Mac OS X 10.6.8 declare the second argument as an unsigned long. This detail doesn’t matter, since the second argument is always a #defined name from a header. </p>\n<p>For the ISO C prototype, an ellipsis is used for the remaining arguments. Normally, however, there is only one more argument, and it’s usually a pointer to a variable or a structure. </p>\n<p>In this prototype, we show only the headers required for the function itself. Normally, additional device-specific headers are required. For example, the ioctl commands for terminal I/O, beyond the basic operations specified by POSIX.1, all require the &lt;termios.h&gt; header. </p>\n<p>Each device driver can define its own set of ioctl commands. The system, however, provides generic ioctl commands for different classes of devices. Examples of some of the categories for these generic ioctl commands supported in FreeBSD are summarized in Figure 3.15. </p>\n<p><img src=\"https://i.loli.net/2018/05/31/5b0f4cf6d20f6.png\" width=\"60%\"></p>\n<p>The mag tape operations allow us to write end-of-file marks on a tape, rewind a tape, space forward over a specified number of files or records, and the like. None of these operations is easily expressed in terms of the other functions in the chapter (read, write, lseek, and so on), so the easiest way to handle these devices has always been to access their operations using ioctl. </p>\n<p>We use the ioctl function in Section 18.12 to fetch and set the size of a terminal’s window, and in Section 19.7 when we access the advanced features of pseudo terminals. </p>\n<h2 id=\"dev-fd\"><a href=\"#dev-fd\" class=\"headerlink\" title=\"/dev/fd\"></a>/dev/fd</h2><p>Newer systems provide a directory named /dev/fd whose entries are files named 0, 1, 2, and so on. Opening the file /dev/fd/n is equivalent to duplicating descriptor n, assuming that descriptor n is open. </p>\n<blockquote>\n<p>The /dev/fd feature was developed by Tom Duff and appeared in the 8th Edition of the Research UNIX System. It is supported by all of the systems described in this book: FreeBSD 8.0, Linux 3.2.0, Mac OS X 10.6.8, and Solaris 10. It is not part of POSIX.1. </p>\n</blockquote>\n<p>In the function call </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fd = open(<span class=\"string\">\"/dev/fd/0\"</span>, mode);</span><br></pre></td></tr></table></figure>\n<p>most systems ignore the specified mode, whereas others require that it be a subset of the mode used when the referenced file (standard input, in this case) was originally opened. Because the previous open is equivalent to </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fd = dup(<span class=\"number\">0</span>);</span><br></pre></td></tr></table></figure>\n<p>the descriptors 0 and fd share the same file table entry (Figure 3.9). For example, if descriptor 0 was opened read-only, we can only read on fd. Even if the system ignores the open mode and the call </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fd = open(<span class=\"string\">\"/dev/fd/0\"</span>, O_RDWR);</span><br></pre></td></tr></table></figure>\n<p>succeeds, we still can’t write to fd. </p>\n<blockquote>\n<p>The Linux implementation of /dev/fd is an exception. It maps file descriptors into symbolic links pointing to the underlying physical files. When you open /dev/fd/0, for example, you are really opening the file associated with your standard input. Thus the mode of the new file descriptor returned is unrelated to the mode of the /dev/fd file descriptor. </p>\n</blockquote>\n<p>We can also call creat with a /dev/fd pathname argument as well as specify O_CREAT in a call to open. This allows a program that calls creat to still work if the pathname argument is /dev/fd/1, for example. </p>\n<blockquote>\n<p>Beware of doing this on Linux. Because the Linux implementation uses symbolic links to the real files, using creat on a /dev/fd file will result in the underlying file being truncated. </p>\n</blockquote>\n<p>Some systems provide the pathnames /dev/stdin, /dev/stdout, and /dev/stderr. These pathnames are equivalent to /dev/fd/0, /dev/fd/1, and /dev/fd/2, respectively. </p>\n<p>The main use of the /dev/fd files is from the shell. It allows programs that use pathname arguments to handle standard input and standard output in the same manner as other pathnames. For example, the cat(1) program specifically looks for an input filename of - and uses it to mean standard input. The command </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">filter file2 | cat file1 - file3 | lpr</span><br></pre></td></tr></table></figure>\n<p>is an example. First, cat reads file1, then its standard input (the output of the filter program on file2), and then file3. If /dev/fd is supported, the special handling of - can be removed from cat, and we can enter </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">filter file2 | cat file1 /dev/fd/0 file3 | lpr</span><br></pre></td></tr></table></figure>\n<p>The special meaning of - as a command-line argument to refer to the standard input or the standard output is a kludge that has crept into many programs. There are also problems if we specify - as the first file, as it looks like the start of another command-line option. Using /dev/fd is a step toward uniformity and cleanliness. </p>\n<h2 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h2><p>This chapter has described the basic I/O functions provided by the UNIX System. These are often called the unbuffered I/O functions because each read or write invokes a system call into the kernel. Using only read and write, we looked at the effect of various I/O sizes on the amount of time required to read a file. We also looked at several ways to flush written data to disk and their effect on application performance. </p>\n<p>Atomic operations were introduced when multiple processes append to the same file and when multiple processes create the same file. We also looked at the data structures used by the kernel to share information about open files. We’ll return to these data structures later in the text. </p>\n<p>We also described the ioctl and fcntl functions. We return to both of these functions later in the book. In Chapter 14, we’ll use fcntl for record locking. In Chapter 18 and Chapter 19, we’ll use ioctl when we deal with terminal devices. </p>\n<h2 id=\"Exercises\"><a href=\"#Exercises\" class=\"headerlink\" title=\"Exercises\"></a>Exercises</h2><ol>\n<li><p>When reading or writing a disk file, are the functions described in this chapter really unbuffered? Explain. </p>\n</li>\n<li><p>Write your own dup2 function that behaves the same way as the dup2 function described in Section 3.12, without calling the fcntl function. Be sure to handle errors correctly. </p>\n</li>\n<li><p>Assume that a process executes the following three function calls: </p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fd1 = open(path, oflags);</span><br><span class=\"line\">fd2 = dup(fd1);</span><br><span class=\"line\">fd3 = open(path, oflags);</span><br></pre></td></tr></table></figure>\n<p>Draw the resulting picture, similar to Figure 3.9. Which descriptors are affected by an fcntl on fd1 with a command of F_SETFD? Which descriptors are affected by an fcntl on fd1 with a command of F_SETFL? </p>\n</li>\n<li><p>The following sequence of code has been observed in various programs: </p>\n <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dup2(fd, <span class=\"number\">0</span>);</span><br><span class=\"line\">dup2(fd, <span class=\"number\">1</span>);</span><br><span class=\"line\">dup2(fd, <span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span> (fd &gt; <span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>close(fd); </p>\n<p>To see why the if test is needed, assume that fd is 1 and draw a picture of what happens to the three descriptor entries and the corresponding file table entry with each call to dup2. Then assume that fd is 3 and draw the same picture. </p>\n"},{"title":"哲学思考","date":"2018-06-02T16:00:00.000Z","comments":1,"_content":"\n1. 量变和质变，可怕的唯一真理，连物理规律都难逃其魔爪，牛顿的经典力学不过是，量子力学的质变，相对论则是对牛顿力学的更宏大尺度上的补充。细胞只有简单的生理活动，但由细胞组成的生物，却发展出更加复杂、系统的生理活动，最后达到人这种具有智慧的水平，能够认识抽象。\n\n2. 有人的地方就有政治，有人的地方就有斗争跟合作，无政府主义只不过是天真的想法，无政府则会有黑帮横行，总会有组织站出来教你认识什么是政治。\n\n3. 世界的本质之一是概率，世界上所有的事都会发生，但由于量变质变对其的控制，显现出来的很多事都相对变得稳定，比如你理论上有一定概率可以穿过一堵墙，但这概率太小。由此延伸出的是平行宇宙和意识不灭：在平行宇宙的分化中总有一个意识可以完整的保持着清醒，一直到永远，而以这个意识的观察角度而言，它自诞生之日起就是永生的，而他周边的意识陪他到永远的概率几乎为0，这就是由唯物产生的唯心，唯物的尽头就是唯心。逻辑的基础也是概率吗？是的，逻辑和数学也是基于概率，不仅是基于概率，同样还有量变质变在起作用，1+1在某一个规模层级上，其抽象意义就是2。\n\n4. 我们所生活的这个世界里，什么都是有限的，光速是有限的，粒子的数量是有限的，无限只存在于抽象的数学之中，而我们的社会资源则更是有限，由此便会产生对资源的争夺，进而产生出不公，公平是建立在力量的制衡上的，公平的本质也是力量至上的体现。要得到更多的资源，便要能使出更强的力量（这力量不管是属于谁，只要你彼时能撬动，彼时他就属于你，而要长久的得到资源，便要长久的拥有力量）。举个例子，黑镜的第4季第6集，大脑共享那一段，女主的身体被车撞坏了，她后来只能依赖于男主，刚开始男主可能会对她很好，但身体的权利永远是掌握在男主手中。你也可以想象你如果残废了，失明了，缺胳膊少腿，无论别人多么同情你，关心你，你始终是个弱者，别人会出于同情帮助你，但主动权掌握在别人手里。国家之间没有永远的朋友和敌人，只有永远的利益，这句话堂而皇之，人和人之间却有道德的一些约束，这是好事，因为道德是大家一起拿出的一份力量，来制衡强者，帮助弱者，但你不要忘了，本质上还是力量在起效（我们要透过现象看本质），在道德沦丧的年代，没人能救得了弱者。多看看周边的人情冷暖，世态炎凉，你就知道利益的绑定和互相输送才能构成短暂的同盟。这里有个误区，就是教育体制里出来的人，一直专注于自我的提升和进步，太过于重视和他人的竞争关系，其实人类社会只有团结起大多数人的力量才能创造出真正的力量体，单个人的能量永远是有限的。还记得火影忍者里面，六道生了两个儿子，一个天赋异禀，拥有六道的瞳力，另一个则几乎没有天赋，但却擅长团结族人，最后后者战胜了前者。而且无数的当代给青少年灌输的文化作品里面，都几乎一致的幻想了一个个体强者无限强的世界，以一敌百随处可见，最典型的有：玄幻小说，武侠小说，热血小说，比如：《缥缈之旅》、《斗破苍穹》，金庸武侠，《海贼王》，《奥特曼》，漫威塑造的一系列英雄。人类社会确实是有英雄情结的，但英雄之所以是英雄，在于其领袖能力，而不是单体作战能力，或者说其他方面的能力。虽然伴随着技术的不断发展，人类所能调动的自然界能量变得越来越大，而人类社会的组织形式也赋予高层管理者强大的力量。也许未来会出现大刘科幻《赡养地球》中的一人掌控所有资源和力量，一人之力足以毁灭整个地球，但人类社会的社会属性决定了，组织的力量才是真正的力量，没有人是超人。\n\n5. 未来是最合乎逻辑的一条概率路线，长者讲，个人的努力奋斗固然重要，但也要考虑到历史的进程，人无法脱离其所在的历史大环境，把自己投身在历史的洪流里，历史会带你沉浮，历史会告诉你什么叫历史局限性，大胆的去想象世界的未来，然后从中获利，投机：炒房、炒币，确实比你努力工作要更能获得财富，因为人家是战略上的勤奋，你是战术上的勤奋。\n\n6. 人类的生产力会不断提高，最终不需要人来劳作，人类将面临转型，首先是身体上的，你难道还没发现身体的进化早已跟不上文明的进化了吗，你为什么需要戴眼镜，你为什么需要穿衣服，你为什么需要手表看时间，你为什么需要刷牙，你为什么需要健身，你为什么需要手机和互联网？这些都是人在利用工具来补上跟不上的那块短板。但你会发现慢慢的连工具都无法起作用了，人体本身需要一场变革，它虽然精妙，却是进化的产物，它只是目前还能用而已，更新速度却已经近乎停滞，总有一天我们会为自己打造躯壳。载体的变化，将带来许多变化，首先便是灵智的信息化，你去某地不用再让载体过去，而是换一个载体，你可以复制你，平行宇宙将在现实中上演，其次是更优秀的载体会给灵智带来更大的发展空间，狗的意识同样可以上传，然后他会慢慢变得跟你一样聪明。最后永生什么的只是顺带了。电气化和信息化已经为载体革命铺筑了坦途，未来让我们拭目以待。\n\n7. 在未来面前，过去不值一提。你回顾过去你就会发现，未来是惊世骇俗的，是难以想象的。\n","source":"_posts/2018/2018-06-03-哲学思考.md","raw":"---\ntitle: 哲学思考\ndate: 2018-06-03\ncategories: [哲学]\ncomments: true\n---\n\n1. 量变和质变，可怕的唯一真理，连物理规律都难逃其魔爪，牛顿的经典力学不过是，量子力学的质变，相对论则是对牛顿力学的更宏大尺度上的补充。细胞只有简单的生理活动，但由细胞组成的生物，却发展出更加复杂、系统的生理活动，最后达到人这种具有智慧的水平，能够认识抽象。\n\n2. 有人的地方就有政治，有人的地方就有斗争跟合作，无政府主义只不过是天真的想法，无政府则会有黑帮横行，总会有组织站出来教你认识什么是政治。\n\n3. 世界的本质之一是概率，世界上所有的事都会发生，但由于量变质变对其的控制，显现出来的很多事都相对变得稳定，比如你理论上有一定概率可以穿过一堵墙，但这概率太小。由此延伸出的是平行宇宙和意识不灭：在平行宇宙的分化中总有一个意识可以完整的保持着清醒，一直到永远，而以这个意识的观察角度而言，它自诞生之日起就是永生的，而他周边的意识陪他到永远的概率几乎为0，这就是由唯物产生的唯心，唯物的尽头就是唯心。逻辑的基础也是概率吗？是的，逻辑和数学也是基于概率，不仅是基于概率，同样还有量变质变在起作用，1+1在某一个规模层级上，其抽象意义就是2。\n\n4. 我们所生活的这个世界里，什么都是有限的，光速是有限的，粒子的数量是有限的，无限只存在于抽象的数学之中，而我们的社会资源则更是有限，由此便会产生对资源的争夺，进而产生出不公，公平是建立在力量的制衡上的，公平的本质也是力量至上的体现。要得到更多的资源，便要能使出更强的力量（这力量不管是属于谁，只要你彼时能撬动，彼时他就属于你，而要长久的得到资源，便要长久的拥有力量）。举个例子，黑镜的第4季第6集，大脑共享那一段，女主的身体被车撞坏了，她后来只能依赖于男主，刚开始男主可能会对她很好，但身体的权利永远是掌握在男主手中。你也可以想象你如果残废了，失明了，缺胳膊少腿，无论别人多么同情你，关心你，你始终是个弱者，别人会出于同情帮助你，但主动权掌握在别人手里。国家之间没有永远的朋友和敌人，只有永远的利益，这句话堂而皇之，人和人之间却有道德的一些约束，这是好事，因为道德是大家一起拿出的一份力量，来制衡强者，帮助弱者，但你不要忘了，本质上还是力量在起效（我们要透过现象看本质），在道德沦丧的年代，没人能救得了弱者。多看看周边的人情冷暖，世态炎凉，你就知道利益的绑定和互相输送才能构成短暂的同盟。这里有个误区，就是教育体制里出来的人，一直专注于自我的提升和进步，太过于重视和他人的竞争关系，其实人类社会只有团结起大多数人的力量才能创造出真正的力量体，单个人的能量永远是有限的。还记得火影忍者里面，六道生了两个儿子，一个天赋异禀，拥有六道的瞳力，另一个则几乎没有天赋，但却擅长团结族人，最后后者战胜了前者。而且无数的当代给青少年灌输的文化作品里面，都几乎一致的幻想了一个个体强者无限强的世界，以一敌百随处可见，最典型的有：玄幻小说，武侠小说，热血小说，比如：《缥缈之旅》、《斗破苍穹》，金庸武侠，《海贼王》，《奥特曼》，漫威塑造的一系列英雄。人类社会确实是有英雄情结的，但英雄之所以是英雄，在于其领袖能力，而不是单体作战能力，或者说其他方面的能力。虽然伴随着技术的不断发展，人类所能调动的自然界能量变得越来越大，而人类社会的组织形式也赋予高层管理者强大的力量。也许未来会出现大刘科幻《赡养地球》中的一人掌控所有资源和力量，一人之力足以毁灭整个地球，但人类社会的社会属性决定了，组织的力量才是真正的力量，没有人是超人。\n\n5. 未来是最合乎逻辑的一条概率路线，长者讲，个人的努力奋斗固然重要，但也要考虑到历史的进程，人无法脱离其所在的历史大环境，把自己投身在历史的洪流里，历史会带你沉浮，历史会告诉你什么叫历史局限性，大胆的去想象世界的未来，然后从中获利，投机：炒房、炒币，确实比你努力工作要更能获得财富，因为人家是战略上的勤奋，你是战术上的勤奋。\n\n6. 人类的生产力会不断提高，最终不需要人来劳作，人类将面临转型，首先是身体上的，你难道还没发现身体的进化早已跟不上文明的进化了吗，你为什么需要戴眼镜，你为什么需要穿衣服，你为什么需要手表看时间，你为什么需要刷牙，你为什么需要健身，你为什么需要手机和互联网？这些都是人在利用工具来补上跟不上的那块短板。但你会发现慢慢的连工具都无法起作用了，人体本身需要一场变革，它虽然精妙，却是进化的产物，它只是目前还能用而已，更新速度却已经近乎停滞，总有一天我们会为自己打造躯壳。载体的变化，将带来许多变化，首先便是灵智的信息化，你去某地不用再让载体过去，而是换一个载体，你可以复制你，平行宇宙将在现实中上演，其次是更优秀的载体会给灵智带来更大的发展空间，狗的意识同样可以上传，然后他会慢慢变得跟你一样聪明。最后永生什么的只是顺带了。电气化和信息化已经为载体革命铺筑了坦途，未来让我们拭目以待。\n\n7. 在未来面前，过去不值一提。你回顾过去你就会发现，未来是惊世骇俗的，是难以想象的。\n","slug":"哲学思考","published":1,"updated":"2018-06-03T04:48:44.520Z","layout":"post","photos":[],"link":"","_id":"cjm2w8ddy003hfgpxyvdlw0cu","content":"<ol>\n<li><p>量变和质变，可怕的唯一真理，连物理规律都难逃其魔爪，牛顿的经典力学不过是，量子力学的质变，相对论则是对牛顿力学的更宏大尺度上的补充。细胞只有简单的生理活动，但由细胞组成的生物，却发展出更加复杂、系统的生理活动，最后达到人这种具有智慧的水平，能够认识抽象。</p>\n</li>\n<li><p>有人的地方就有政治，有人的地方就有斗争跟合作，无政府主义只不过是天真的想法，无政府则会有黑帮横行，总会有组织站出来教你认识什么是政治。</p>\n</li>\n<li><p>世界的本质之一是概率，世界上所有的事都会发生，但由于量变质变对其的控制，显现出来的很多事都相对变得稳定，比如你理论上有一定概率可以穿过一堵墙，但这概率太小。由此延伸出的是平行宇宙和意识不灭：在平行宇宙的分化中总有一个意识可以完整的保持着清醒，一直到永远，而以这个意识的观察角度而言，它自诞生之日起就是永生的，而他周边的意识陪他到永远的概率几乎为0，这就是由唯物产生的唯心，唯物的尽头就是唯心。逻辑的基础也是概率吗？是的，逻辑和数学也是基于概率，不仅是基于概率，同样还有量变质变在起作用，1+1在某一个规模层级上，其抽象意义就是2。</p>\n</li>\n<li><p>我们所生活的这个世界里，什么都是有限的，光速是有限的，粒子的数量是有限的，无限只存在于抽象的数学之中，而我们的社会资源则更是有限，由此便会产生对资源的争夺，进而产生出不公，公平是建立在力量的制衡上的，公平的本质也是力量至上的体现。要得到更多的资源，便要能使出更强的力量（这力量不管是属于谁，只要你彼时能撬动，彼时他就属于你，而要长久的得到资源，便要长久的拥有力量）。举个例子，黑镜的第4季第6集，大脑共享那一段，女主的身体被车撞坏了，她后来只能依赖于男主，刚开始男主可能会对她很好，但身体的权利永远是掌握在男主手中。你也可以想象你如果残废了，失明了，缺胳膊少腿，无论别人多么同情你，关心你，你始终是个弱者，别人会出于同情帮助你，但主动权掌握在别人手里。国家之间没有永远的朋友和敌人，只有永远的利益，这句话堂而皇之，人和人之间却有道德的一些约束，这是好事，因为道德是大家一起拿出的一份力量，来制衡强者，帮助弱者，但你不要忘了，本质上还是力量在起效（我们要透过现象看本质），在道德沦丧的年代，没人能救得了弱者。多看看周边的人情冷暖，世态炎凉，你就知道利益的绑定和互相输送才能构成短暂的同盟。这里有个误区，就是教育体制里出来的人，一直专注于自我的提升和进步，太过于重视和他人的竞争关系，其实人类社会只有团结起大多数人的力量才能创造出真正的力量体，单个人的能量永远是有限的。还记得火影忍者里面，六道生了两个儿子，一个天赋异禀，拥有六道的瞳力，另一个则几乎没有天赋，但却擅长团结族人，最后后者战胜了前者。而且无数的当代给青少年灌输的文化作品里面，都几乎一致的幻想了一个个体强者无限强的世界，以一敌百随处可见，最典型的有：玄幻小说，武侠小说，热血小说，比如：《缥缈之旅》、《斗破苍穹》，金庸武侠，《海贼王》，《奥特曼》，漫威塑造的一系列英雄。人类社会确实是有英雄情结的，但英雄之所以是英雄，在于其领袖能力，而不是单体作战能力，或者说其他方面的能力。虽然伴随着技术的不断发展，人类所能调动的自然界能量变得越来越大，而人类社会的组织形式也赋予高层管理者强大的力量。也许未来会出现大刘科幻《赡养地球》中的一人掌控所有资源和力量，一人之力足以毁灭整个地球，但人类社会的社会属性决定了，组织的力量才是真正的力量，没有人是超人。</p>\n</li>\n<li><p>未来是最合乎逻辑的一条概率路线，长者讲，个人的努力奋斗固然重要，但也要考虑到历史的进程，人无法脱离其所在的历史大环境，把自己投身在历史的洪流里，历史会带你沉浮，历史会告诉你什么叫历史局限性，大胆的去想象世界的未来，然后从中获利，投机：炒房、炒币，确实比你努力工作要更能获得财富，因为人家是战略上的勤奋，你是战术上的勤奋。</p>\n</li>\n<li><p>人类的生产力会不断提高，最终不需要人来劳作，人类将面临转型，首先是身体上的，你难道还没发现身体的进化早已跟不上文明的进化了吗，你为什么需要戴眼镜，你为什么需要穿衣服，你为什么需要手表看时间，你为什么需要刷牙，你为什么需要健身，你为什么需要手机和互联网？这些都是人在利用工具来补上跟不上的那块短板。但你会发现慢慢的连工具都无法起作用了，人体本身需要一场变革，它虽然精妙，却是进化的产物，它只是目前还能用而已，更新速度却已经近乎停滞，总有一天我们会为自己打造躯壳。载体的变化，将带来许多变化，首先便是灵智的信息化，你去某地不用再让载体过去，而是换一个载体，你可以复制你，平行宇宙将在现实中上演，其次是更优秀的载体会给灵智带来更大的发展空间，狗的意识同样可以上传，然后他会慢慢变得跟你一样聪明。最后永生什么的只是顺带了。电气化和信息化已经为载体革命铺筑了坦途，未来让我们拭目以待。</p>\n</li>\n<li><p>在未来面前，过去不值一提。你回顾过去你就会发现，未来是惊世骇俗的，是难以想象的。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><p>量变和质变，可怕的唯一真理，连物理规律都难逃其魔爪，牛顿的经典力学不过是，量子力学的质变，相对论则是对牛顿力学的更宏大尺度上的补充。细胞只有简单的生理活动，但由细胞组成的生物，却发展出更加复杂、系统的生理活动，最后达到人这种具有智慧的水平，能够认识抽象。</p>\n</li>\n<li><p>有人的地方就有政治，有人的地方就有斗争跟合作，无政府主义只不过是天真的想法，无政府则会有黑帮横行，总会有组织站出来教你认识什么是政治。</p>\n</li>\n<li><p>世界的本质之一是概率，世界上所有的事都会发生，但由于量变质变对其的控制，显现出来的很多事都相对变得稳定，比如你理论上有一定概率可以穿过一堵墙，但这概率太小。由此延伸出的是平行宇宙和意识不灭：在平行宇宙的分化中总有一个意识可以完整的保持着清醒，一直到永远，而以这个意识的观察角度而言，它自诞生之日起就是永生的，而他周边的意识陪他到永远的概率几乎为0，这就是由唯物产生的唯心，唯物的尽头就是唯心。逻辑的基础也是概率吗？是的，逻辑和数学也是基于概率，不仅是基于概率，同样还有量变质变在起作用，1+1在某一个规模层级上，其抽象意义就是2。</p>\n</li>\n<li><p>我们所生活的这个世界里，什么都是有限的，光速是有限的，粒子的数量是有限的，无限只存在于抽象的数学之中，而我们的社会资源则更是有限，由此便会产生对资源的争夺，进而产生出不公，公平是建立在力量的制衡上的，公平的本质也是力量至上的体现。要得到更多的资源，便要能使出更强的力量（这力量不管是属于谁，只要你彼时能撬动，彼时他就属于你，而要长久的得到资源，便要长久的拥有力量）。举个例子，黑镜的第4季第6集，大脑共享那一段，女主的身体被车撞坏了，她后来只能依赖于男主，刚开始男主可能会对她很好，但身体的权利永远是掌握在男主手中。你也可以想象你如果残废了，失明了，缺胳膊少腿，无论别人多么同情你，关心你，你始终是个弱者，别人会出于同情帮助你，但主动权掌握在别人手里。国家之间没有永远的朋友和敌人，只有永远的利益，这句话堂而皇之，人和人之间却有道德的一些约束，这是好事，因为道德是大家一起拿出的一份力量，来制衡强者，帮助弱者，但你不要忘了，本质上还是力量在起效（我们要透过现象看本质），在道德沦丧的年代，没人能救得了弱者。多看看周边的人情冷暖，世态炎凉，你就知道利益的绑定和互相输送才能构成短暂的同盟。这里有个误区，就是教育体制里出来的人，一直专注于自我的提升和进步，太过于重视和他人的竞争关系，其实人类社会只有团结起大多数人的力量才能创造出真正的力量体，单个人的能量永远是有限的。还记得火影忍者里面，六道生了两个儿子，一个天赋异禀，拥有六道的瞳力，另一个则几乎没有天赋，但却擅长团结族人，最后后者战胜了前者。而且无数的当代给青少年灌输的文化作品里面，都几乎一致的幻想了一个个体强者无限强的世界，以一敌百随处可见，最典型的有：玄幻小说，武侠小说，热血小说，比如：《缥缈之旅》、《斗破苍穹》，金庸武侠，《海贼王》，《奥特曼》，漫威塑造的一系列英雄。人类社会确实是有英雄情结的，但英雄之所以是英雄，在于其领袖能力，而不是单体作战能力，或者说其他方面的能力。虽然伴随着技术的不断发展，人类所能调动的自然界能量变得越来越大，而人类社会的组织形式也赋予高层管理者强大的力量。也许未来会出现大刘科幻《赡养地球》中的一人掌控所有资源和力量，一人之力足以毁灭整个地球，但人类社会的社会属性决定了，组织的力量才是真正的力量，没有人是超人。</p>\n</li>\n<li><p>未来是最合乎逻辑的一条概率路线，长者讲，个人的努力奋斗固然重要，但也要考虑到历史的进程，人无法脱离其所在的历史大环境，把自己投身在历史的洪流里，历史会带你沉浮，历史会告诉你什么叫历史局限性，大胆的去想象世界的未来，然后从中获利，投机：炒房、炒币，确实比你努力工作要更能获得财富，因为人家是战略上的勤奋，你是战术上的勤奋。</p>\n</li>\n<li><p>人类的生产力会不断提高，最终不需要人来劳作，人类将面临转型，首先是身体上的，你难道还没发现身体的进化早已跟不上文明的进化了吗，你为什么需要戴眼镜，你为什么需要穿衣服，你为什么需要手表看时间，你为什么需要刷牙，你为什么需要健身，你为什么需要手机和互联网？这些都是人在利用工具来补上跟不上的那块短板。但你会发现慢慢的连工具都无法起作用了，人体本身需要一场变革，它虽然精妙，却是进化的产物，它只是目前还能用而已，更新速度却已经近乎停滞，总有一天我们会为自己打造躯壳。载体的变化，将带来许多变化，首先便是灵智的信息化，你去某地不用再让载体过去，而是换一个载体，你可以复制你，平行宇宙将在现实中上演，其次是更优秀的载体会给灵智带来更大的发展空间，狗的意识同样可以上传，然后他会慢慢变得跟你一样聪明。最后永生什么的只是顺带了。电气化和信息化已经为载体革命铺筑了坦途，未来让我们拭目以待。</p>\n</li>\n<li><p>在未来面前，过去不值一提。你回顾过去你就会发现，未来是惊世骇俗的，是难以想象的。</p>\n</li>\n</ol>\n"},{"title":"《代码整洁之道》读书笔记--第2章:有意义的命名","comments":1,"date":"2018-06-10T10:19:48.000Z","_content":"\n\n我们写代码的时候需要不停的命名，项目、类、函数、变量 等等都要命名。而命名关乎程序的可读性，而程序的可读性又至关重要（代码是写给人看的）。\n\n## 名副其实\n\n一个很重要的原则是：**如果命名需要注释来补充，那就不算名副其实。**\n\n举个例子：\n\n```\nint d;  //消逝的时间，以日计\n```\n\n名称`d`什么也没说，如果其他很多地方要用到这个变量那就十分糟糕了，因为用的人不一定想的起来`d`是什么意思（如果只是局部变量局部使用，那它的罪孽会轻一点，如果是全局变量或者类的成员变量那这简直就是大坑）。**其实我们很容易发现，注释没法像好的命名一样方便，因为我们不会在写代码的时候看到一个不懂的命名就去找它的定义处的注释，这样会浪费很多时间**。所以好的命名就应该能自己说明自己是什么。\n\n好的命名如下：\n\n```\nint elapsedTimeInDays;\nint daysSinceCreation;\nint daysSinceModification;\nint fileAgeInDays;\n```\n\n下面我们看一段代码：\n\n```Java\npublic List<int[]> getThem() {\n    List<int[]> list1 = new ArrayList<int[]>();\n    for (int[] x : theList){\n        if (x[0] == 4){\n            list1.add(x);\n        }\n    }\n    return list1;\n}\n```\n\n这段代码很糟糕，虽然里面没有复杂的表达式，空格和缩进中规中矩，只用到三个变量和两个常量，甚至没涉及到其他类或多态方法。但这段代码很难说清它在做什么。问题不在于代码的简洁度，而在于代码的 **模糊度：即上下文在代码中未被明确体现的程度**。比如随便提几个问题：\n\n1. theList 是什么类型的东西？\n2. theList 零下标条目的意义是什么？\n3. 值4的意义是什么？\n4. 我们怎么使用返回的list1？\n\n**问题的答案没体现在代码段中，可那就是它们该在的地方！如果不是对上下文及其熟悉，我们根本无法知道这代码在做什么！**\n\n比方说，我们在开发一种扫雷游戏，我们发现，盘面是名为 theList 的单元格列表，那就将其命名为：gameBoard。盘面上每个单元格都用一个简单数组表示。我们还发现，零下标条目是一种状态值，而这种状态值为4表示“已标记”。我们将代码修改如下：\n\n```Java\npublic List<int[]> getFlaggedCells() {\n    List<int[]> flaggedCells = new ArrayList<int[]>();\n    for (int[] cell : gameBoard){\n        if (cell[STATE_VALUE] == FLAGGED){\n            flaggedCells.add(cell);\n        }\n    }\n    return flaggedCells;\n}\n```\n\n这下这段代码是什么功能，做了些什么工作简直一目了然。还可以进一步，不用int数组表示单元格，而是另写一个类。该类包括一个名副其实的函数（称为 isFlagged），从而掩盖住那个魔术数。\n\n> 魔术数，magic number：指使用不明其意的立即数，至少我们应该用一个常量来对这种立即数进行命名，赋予其意义。\n\n```Java\npublic List<Cell> getFlaggedCells() {\n    List<Cell> flaggedCells = new ArrayList<>();\n    for (Cell cell : gameBoard){\n        if (cell.isFlagged()){\n            flaggedCells.add(cell);\n        }\n    }\n    return flaggedCells;\n}\n```\n\n从int数组到Cell类，**抽象程度又提高了，代码可重用性也就提高了**。\n\n## 避免误导\n\n例如，hp、aix 和 sco 都不应该用作变量名，因为它们都是UNIX平台或类UNIX平台的专有名称。别用accountList来指称一组账号，除非它们真的是List类型，List一词对程序员来说有特殊的意义，如果包纳账号的容器并非是一个List，就会引起错误的判断（即便容器就是个List，最好也别在名称中写出容器的类型）。所以，用accountGroup或bunchOfAccounts，甚至直接用accounts都会好一些。\n\n**提防使用不同之处较小的命名**。想区分模块中某处的XYZControllerForEfficientHandlingOfStrings 和另一处的 XYZControllerForEfficentStorageOfStrings，会花多长时间呢？这两个词外形实在太相似了。我们很享受线代Java编程环境的自动代码完成特性，键入某个名称的前几个字母，就可以得到一列该名称的可能性，假如相似的名字依字母顺序放在一起，且差异很明显，那就会相当有助益。\n\n>在某些字体里，1和l，0和O很难分清。要注意这种混淆。\n\n## 做有意义的区分\n\n如果程序员只是为满足编译器或解释器的需要而写代码，就会制造麻烦。例如，因为同一作用域内不能重名，你可能随手改掉其中一个命名，有时候干脆以错误的拼写充数，结果就是有人一不小心更正拼写错误，然后导致编译器出错。\n\n例如class已经是关键字，就给变量命名为klass，clazz，还有this，命名成thiz。\n\n以数字系列命名（a1, a2, ..., aN）是以意义命名的对立面。试看：\n\n```Java\npublic static void copyChars(char a1[], char a2[]){\n    for (int i=0;i<a1.length;i++){\n        a2[i] = a1[i];\n    }\n}\n```\n\n如果参数名改为 `source` 和 `destination`，这个函数就会像样许多。\n\n**废话是另一种没意义的区分**。假设你有一个 Product 类。如果还有一个 ProductInfo 或 ProductData 类，那它们的名称虽然不同，意思却并无区别。Info和Data就像a、an和the一样是意义含混的废话。\n注意，只要体现出有意义的区分，使用a和the这样的前缀就没错。例如，你可能把a用在域内变量，而把the用于函数参数。但如果你已经有一个名为zork的变量，又想调用一个名为theZork的变量，麻烦就来了。\n\n废话都是冗余。Variable一词永远不应当出现在变量名中。Table一词永远不应当出现在表名中。NameString会比Name好吗？难倒Name会是一个浮点数不成？如果是这样，就触犯了关于误导的规则。设想有个名为Customer的类，还有一个名为CustomerObject的类。区别何在呢？哪个是表示客户历史支付情况的最佳途径？\n\n举个例子：\n\n```\ngetActiveAccount();\ngetActiveAccounts();\ngetActiveAccountInfo();\n```\n\n程序员怎么知道该调用哪个函数呢？\n\n如果缺少明确约定，变量moneyAmount就与money没区别，customerInfo与custmoer没区别，accountData与account没区别，theMessage也与message没区别。**要区分名称，就要以读者能鉴别不同之处的方式来区分**。\n\n## 使用读的出来的名称\n\n人类长于记忆和使用单词，若不善加利用，实在是种耻辱。\n\n**如果名称读不出来，讨论的时候会像个傻鸟**。“哎，这儿，鼻涕阿三喜摁踢（bee cee arr three cee enn tee， BCR3CNT的读音）上头，有个皮挨死极翘（pee ess zee kyew）整数，看见没？” **这不是小事，因为编程本就是一种社会活动**。\n\n有家公司，程序里面写了个 genymdhms（生成日期，年、月、日、时、分、秒），他们一般读作：“gen why emm dee aich emm ess”，YMDHMS的读音。我有个见字照读的恶习，于是开口就念“gen-yah-mudda-hims”。后来好些设计师和分析师都有样学样，听起来傻乎乎。我们知道典故，所以觉得很搞笑。搞笑归搞笑，实际是在强忍糟糕的命名。在给新开发者解释变量的意义时，他们总是读出傻乎乎的自造词，而非恰当的英语词。比较：\n\n```Java\nclass DtaRcrd102 {\n    private Date genymdhms;\n    private Date modymdhms;\n    private final String pszqint = \"102\";\n    /* ... */\n}\n```\n\n```C++\nclass Customer {\n    private Date generationTimestamp;\n    private Date modificationTimestamp;\n    private final String recordId = \"102\";\n    /* ... */\n}\n```\n\n现在读起来就像人话了：“喂，Mikey，看看这条记录！生成时间戳（generation timestamp）被设置为明天了！不能这样吧？”\n\n## 使用可搜索的名称\n\n单字母名称和数字常量有个问题，就是很难在一大篇文字中找出来。\n\n## 避免使用编码\n\n编码已经太多，无谓再自找麻烦。把类型或作用域编进名称里面，徒然增加了解码的负担。没理由要求每位新人都在弄清要应付的编码之外（那算是正常的），还要再搞懂另一套编码“语言”。这对于解决问题而言，纯属多余的负担。带编码的名称通常也不便发音，容易打错。\n\n### 匈牙利命名法\n\n在往昔名称长短很要命的时代，我们毫无必要的破坏了不编码的规矩，如今后悔不迭。Fortran语言要求首字母体现出类型，导致了编码的产生。BASIC早期版本只允许使用一个字母再加一位数字。匈牙利命名法（Hungarian Notation，HN）将这种态势愈演愈烈。\n\n在Windows的C语言API的时代，HN相当重要，那时所有名称要么是个整数句柄，要么是个长指针或者void指针，要不然就是string的几种实现（有不同的用途和属性）之一。那时候编译器并不做类型检查，程序员需要匈牙利命名法来帮助自己记住类型。\n\n现代编程语言具有更丰富的类型系统，编译器也记得并强制使用类型。而且，人们趋向于使用更小的类、更短的方法，好让每个变量的定义都在视野范围内。\n\nJava程序员不需要类型编码。对象是强类型的，代码编辑环境已经先进到在编译开始前就侦测到类型错误的程度！所以，如今HN和其他类型编码形式都纯属多余。它们增加了修改变量、函数或类的名称或类型的难度。它们增加了阅读代码的难度。它们制造了让编码系统误导读者的可能性。\n\n```\nPhoneNumber phoneString;    // 类型变化时，名称并不会自动变化，若名称中编码了类型，还要我们手动去改。\n```\n\n### 成员前缀\n\n也不必用m_前缀来标明成员变量。应当把类和函数做得足够小，消除对成员前缀的需要。你应当使用某种可以高亮或用颜色标出成员的编辑环境。\n\n```\npublic class Part {\n    private String m_dsc;   // The textual description\n    void setName(String name) {\n        m_dsc = name;\n    }\n}\n```\n\n```Java\npublic class Part{\n    String description;\n    void setDescription(String description) {\n        this.description = description;\n    }\n}\n```\n\n此外，人们会很快就学会无视前缀（或后缀），只看到名称中有意义的部分。代码读的越多，眼中就越没有前缀。最终，前缀变作了不入法眼的废料，变作了旧代码的标志物。\n\n### 接口和实现\n\n有时也会出现采用编码的特殊情形。比如，你在做一个创建形态用的抽象工厂（Abstract Factory）。该工厂是个接口，要用具体类来实现。你怎么 命名工厂和具体类呢？IShapeFactory和ShapeFactory吗？我喜欢不加修饰的接口。前导字母I被滥用到了说好听点是干扰，说难听点根本就是废话的程度。我不想让用户知道我给他们的是接口。我就想让他们知道那是个ShapeFactory。如果接口和实现必须选一个来编码的话，我宁肯选择实现。ShapeFactoryImp，甚至是丑陋的CShapeFactory，都比对接口名称编码来得好。\n\n## 避免思维映射\n\n不应当让读者在脑海中把你的名称翻译为他们熟知的名称。这种问题经常出现在选择是使用问题领域术语还是解决方案领域术语时。\n\n单字母变量名就是个问题。在作用域较小，也没有名称冲突时，循环计数器自然有可能被命名为i或j或k（但千万别用字母l）。这是因为传统上惯用单字母名称做循环计数器。然而，在多数其他情况下，单字母名称不是个好选择，读者必须在脑海中将它映射为真实概念。仅仅是因为有了a和b，就要取名为c，实在并非像样的理由。\n\n程序员通常都是聪明人。聪明人有时会借脑筋急转弯炫耀其聪明。总而言之，假使你记得r代表不包含主机和图式（scheme）的小写字母版url的话，那你真是太聪明了。\n\n聪明程序员和专业程序员之间的区别在于，专业程序员了解，明确是王道。专业程序员善用其能，编写其他人能理解的代码。\n\n## 类名\n\n类名和对象名应该是名词或名词短语，如Customer、WikiPage、Account和AddressParser。避免使用Manager、Processor、Data或Info这样的类名。类名不应当是动词。\n\n>这里没看懂，举的例子并不是动词啊\n\n## 方法名\n\n方法名应当是动词或动词短语，如 postPayment、deletePage或save。属性访问器、修改器和断言应该根据其值命名，并依Javabean标准加上get、set和is前缀。\n\n```Java\nString name = employee.getName();\ncustomer.setName(\"mike\");\nif(paycheck.isPosted())...\n```\n\n重载构造器时，使用描述了参数的静态工厂方法名。例如：\n\n```Java\nComplex fulcrumPoint = Complex.FromRealNumber(23.0);\n```\n\n通常好于\n\n```Java\nComplex fulcrumPoint = new Complex(23.0);\n```\n\n可以考虑将相应的构造器设置为private，强制使用这种命名手段。\n\n## 别扮可爱\n\n如果名称太耍宝，那就只有同作者一般有幽默感的人才能记得住，而且还是在他们记得那个笑话的时候才行。谁会知道名为HolyHandGrenade的函数是用来做什么的呢？没错，这名字挺伶俐，不过DeleteItems或许是更好的名称。宁可明确，毋为好玩。\n\n扮可爱的做法在代码中经常体现为使用俗语或俚语。例如，别用whack()来表示kill()。别用eatMyShorts()这类与文化紧密相关的笑话来表示abort()。\n\n## 每个概念对应一个词\n\n给每个抽象概念选一个词，并且一以贯之。例如，使用fetch、retrieve和get来给在多个类中的同种方法命名。你怎么记得住哪个类中是哪个方法呢？\n\nEclipse和Intellj之类的线代编程环境提供了与环境相关的线索，比如某个对象能调用的方法列表。不过要注意，列表中通常不会给出你为函数名和参数列表编写的注释。如果参数名称来自函数声明，你就太幸运了。函数名称应当独一无二，而且要保持一致，这样你才能不借助多余的浏览就能找到正确的方法。\n\n同样，在同一堆代码中有controller，又有manager，还有driver，就会令人困惑。DeviceManager和Protocal-Controller之间有何根本区别？为什么不全用controllers或managers？他们都是Drivers吗？这种名称，让人觉得这两个对象是不同类型的，也分属不同的类。\n\n对于那些会用到你代码的程序员，一以贯之的命名法简直就是天降福音。\n\n## 别用双关语\n\n避免将同一个单词用于不同目的。如果遵循“一词一意”的规则，可能在好多类里面都会有add方法。只要这些add方法的参数列表和返回值在语义上等价，就一切顺利。\n\n但是，可能会有人决定为“保持一致”而使用add这个词来命名，即便并非真的想表示这种意思。比如，在多个类种都有add方法，该方法通过增加或连接两个现存值来获得新值。假设要写个新类，该类中有一个方法，把单个参数放到群集（collection）中。该把这个方法叫做add吗？这样做貌似和其他add方法保持了一致，但实际上语义却不同，应该用insert或append之类的词来命名才对。把该方法命名为add，就是双关语了。\n\n## 使用解决方案领域的名称\n\n记住，只有程序员才会读你的代码。所以，尽管用那些计算机科学（Computer Science, CS）术语、算法名、模式名、数学术语吧。\n\n对于熟悉访问者（VISITOR）模式的程序来说，名称AccountVisitor富有意义。那个程序员会不知道JobQueue的意思呢？\n\n## 使用源自所涉及问题领域的名称\n\n如果不能用程序员熟悉的术语来给手头的工作命名，就采用从所涉及领域而来的名称吧。至少，负责维护代码的程序员就能去请教领域专家了。\n\n## 添加有意义的语境\n\n很少有名称是能自我说明的--多数都不能。反之，你需要用有良好命名的类、函数或名称空间来放置名称，给读者提供语境。如果没这么做，给名称添加前缀就是最后一招了。\n\n设想你有名为firstName、lastName、street、houseNumber、city\\state和zipcode的变量。当它们搁一块儿的时候，很明确是构成了一个地址。不过，假使只是在某个方法中看见孤零零的一个state变量呢？你会理所当然推断那是某个地址的一部分吗？\n\n可以添加前缀addrFirstName、addrLastName、addrState等，以此提供语境。至少，读者会明白这些变量都是某个更大结构的一部分。当然，更好的方案是创建名为Address的类。这样，即便是编译器也会知道这些变量隶属某个更大的概念了。\n\n看一个例子：\n\n语境不明确的变量：\n\n```Java\nprivate void printGuessStatistics(char candidate, int count){\n    String number;\n    String verb;\n    String pluralModifier;\n    if(count==0){\n        number=\"no\";\n        verb=\"are\";\n        pluralModifier=\"s\";\n    }else if(count==1){\n        number=\"1\";\n        verb=\"is\";\n        pluralModifier=\"\";\n    }else{\n        number=Integer.toString(count);\n        verb=\"are\";\n        pluralModifier=\"s\";\n    }\n    String guessMessage = String.format(\n        \"There %s %s %s%s\", verb, number, candidate, pluralModifier);\n    print(guessMessage);\n}\n```\n\n上列函数有点过长，变量的使用贯穿始终。要分解这个函数，需要创建一个名为GuessStatisticsMessage的类，把三个变量做成该类的成员字段。这样它们就在定义上变作了GuessStatisticsMessage的一部分。语境的增强也让算法能够通过分解为更小的函数而变得更为干净利落。\n\n有语境的变量：\n\n```Java\npublic class GuessStatisticsMessage {\n    private String number;\n    private String verb;\n    private String pluralModifier;\n\n    public String make(char candidate, int count){\n        createPluralDependentMessageParts(count);\n        return String.format(\n            \"There %s %s %s%s\", verb, number, candidate, pluralModifier);\n    }\n\n    private void createPluralDependentMessageParts(int count){\n        if(count==0){\n            thereAreNoLetters();\n        }else if (count==1){\n            thereIsOneLetter();\n        }else{\n            thereAreManyLetters(count);\n        }\n    }\n\n    private void thereAreManyLetters(int count){\n        number = Integer.toString(count);\n        verb = \"are\";\n        pluralModifier=\"s\";\n    }\n\n    private void thereIsOneLetters(){\n        number=\"1\";\n        verb = \"is\";\n        pluralModifier = \"\";\n    }\n\n    private void thereAreNoLetters(){\n        number = \"no\";\n        verb = \"are\";\n        pluralModifier = \"s\";\n    }\n}\n```\n\n## 不要添加没用的语境\n\n设若有一个名为“加油站豪华版”（Gas Station Deluxe）的应用，在其中给每个类添加GSD前缀就不是什么好点子。说白了，你是在和自己在用的工具过不去。输入G，按下自动完成键，结果会得到系统中全部类的列表，列表恨不得有一英里那么长。这样做聪明吗？为什么要搞得IDE没法帮助你？\n\n再比如，你在GSD应用程序中的记账模块创建了一个表示邮件地址的类，然后给该类命名为GSDAccountAddress。稍后，你的客户联络应用中需要用到邮件地址，你会用GSDAccountAddress吗？这名字听起来没问题吗？在这17个字母里面，有10个字母纯属多余，与当前语境毫无关联。\n\n只要短名称足够清楚，就要比长名称好。别给名称添加不必要的语境。\n\n对于Address类的实体来说，accountAddress和customerAddress都是不错的名称，不过用在类名上就不太好了。Address是个好类名。如果需要与MAC地址、端口地址和Web地址相区别，我会考虑使用PostalAddress、MAC和URI。这样的名称更为精确，而精确正是命名的要点。\n","source":"_posts/2018/2018-06-10-《代码整洁之道》读书笔记-第2章-有意义的命名.md","raw":"---\ntitle: '《代码整洁之道》读书笔记--第2章:有意义的命名'\ntags:\n  - 代码规范\ncategories:\n  - 读书笔记\n  - 《代码整洁之道》\ncomments: true\ndate: 2018-06-10 18:19:48\n---\n\n\n我们写代码的时候需要不停的命名，项目、类、函数、变量 等等都要命名。而命名关乎程序的可读性，而程序的可读性又至关重要（代码是写给人看的）。\n\n## 名副其实\n\n一个很重要的原则是：**如果命名需要注释来补充，那就不算名副其实。**\n\n举个例子：\n\n```\nint d;  //消逝的时间，以日计\n```\n\n名称`d`什么也没说，如果其他很多地方要用到这个变量那就十分糟糕了，因为用的人不一定想的起来`d`是什么意思（如果只是局部变量局部使用，那它的罪孽会轻一点，如果是全局变量或者类的成员变量那这简直就是大坑）。**其实我们很容易发现，注释没法像好的命名一样方便，因为我们不会在写代码的时候看到一个不懂的命名就去找它的定义处的注释，这样会浪费很多时间**。所以好的命名就应该能自己说明自己是什么。\n\n好的命名如下：\n\n```\nint elapsedTimeInDays;\nint daysSinceCreation;\nint daysSinceModification;\nint fileAgeInDays;\n```\n\n下面我们看一段代码：\n\n```Java\npublic List<int[]> getThem() {\n    List<int[]> list1 = new ArrayList<int[]>();\n    for (int[] x : theList){\n        if (x[0] == 4){\n            list1.add(x);\n        }\n    }\n    return list1;\n}\n```\n\n这段代码很糟糕，虽然里面没有复杂的表达式，空格和缩进中规中矩，只用到三个变量和两个常量，甚至没涉及到其他类或多态方法。但这段代码很难说清它在做什么。问题不在于代码的简洁度，而在于代码的 **模糊度：即上下文在代码中未被明确体现的程度**。比如随便提几个问题：\n\n1. theList 是什么类型的东西？\n2. theList 零下标条目的意义是什么？\n3. 值4的意义是什么？\n4. 我们怎么使用返回的list1？\n\n**问题的答案没体现在代码段中，可那就是它们该在的地方！如果不是对上下文及其熟悉，我们根本无法知道这代码在做什么！**\n\n比方说，我们在开发一种扫雷游戏，我们发现，盘面是名为 theList 的单元格列表，那就将其命名为：gameBoard。盘面上每个单元格都用一个简单数组表示。我们还发现，零下标条目是一种状态值，而这种状态值为4表示“已标记”。我们将代码修改如下：\n\n```Java\npublic List<int[]> getFlaggedCells() {\n    List<int[]> flaggedCells = new ArrayList<int[]>();\n    for (int[] cell : gameBoard){\n        if (cell[STATE_VALUE] == FLAGGED){\n            flaggedCells.add(cell);\n        }\n    }\n    return flaggedCells;\n}\n```\n\n这下这段代码是什么功能，做了些什么工作简直一目了然。还可以进一步，不用int数组表示单元格，而是另写一个类。该类包括一个名副其实的函数（称为 isFlagged），从而掩盖住那个魔术数。\n\n> 魔术数，magic number：指使用不明其意的立即数，至少我们应该用一个常量来对这种立即数进行命名，赋予其意义。\n\n```Java\npublic List<Cell> getFlaggedCells() {\n    List<Cell> flaggedCells = new ArrayList<>();\n    for (Cell cell : gameBoard){\n        if (cell.isFlagged()){\n            flaggedCells.add(cell);\n        }\n    }\n    return flaggedCells;\n}\n```\n\n从int数组到Cell类，**抽象程度又提高了，代码可重用性也就提高了**。\n\n## 避免误导\n\n例如，hp、aix 和 sco 都不应该用作变量名，因为它们都是UNIX平台或类UNIX平台的专有名称。别用accountList来指称一组账号，除非它们真的是List类型，List一词对程序员来说有特殊的意义，如果包纳账号的容器并非是一个List，就会引起错误的判断（即便容器就是个List，最好也别在名称中写出容器的类型）。所以，用accountGroup或bunchOfAccounts，甚至直接用accounts都会好一些。\n\n**提防使用不同之处较小的命名**。想区分模块中某处的XYZControllerForEfficientHandlingOfStrings 和另一处的 XYZControllerForEfficentStorageOfStrings，会花多长时间呢？这两个词外形实在太相似了。我们很享受线代Java编程环境的自动代码完成特性，键入某个名称的前几个字母，就可以得到一列该名称的可能性，假如相似的名字依字母顺序放在一起，且差异很明显，那就会相当有助益。\n\n>在某些字体里，1和l，0和O很难分清。要注意这种混淆。\n\n## 做有意义的区分\n\n如果程序员只是为满足编译器或解释器的需要而写代码，就会制造麻烦。例如，因为同一作用域内不能重名，你可能随手改掉其中一个命名，有时候干脆以错误的拼写充数，结果就是有人一不小心更正拼写错误，然后导致编译器出错。\n\n例如class已经是关键字，就给变量命名为klass，clazz，还有this，命名成thiz。\n\n以数字系列命名（a1, a2, ..., aN）是以意义命名的对立面。试看：\n\n```Java\npublic static void copyChars(char a1[], char a2[]){\n    for (int i=0;i<a1.length;i++){\n        a2[i] = a1[i];\n    }\n}\n```\n\n如果参数名改为 `source` 和 `destination`，这个函数就会像样许多。\n\n**废话是另一种没意义的区分**。假设你有一个 Product 类。如果还有一个 ProductInfo 或 ProductData 类，那它们的名称虽然不同，意思却并无区别。Info和Data就像a、an和the一样是意义含混的废话。\n注意，只要体现出有意义的区分，使用a和the这样的前缀就没错。例如，你可能把a用在域内变量，而把the用于函数参数。但如果你已经有一个名为zork的变量，又想调用一个名为theZork的变量，麻烦就来了。\n\n废话都是冗余。Variable一词永远不应当出现在变量名中。Table一词永远不应当出现在表名中。NameString会比Name好吗？难倒Name会是一个浮点数不成？如果是这样，就触犯了关于误导的规则。设想有个名为Customer的类，还有一个名为CustomerObject的类。区别何在呢？哪个是表示客户历史支付情况的最佳途径？\n\n举个例子：\n\n```\ngetActiveAccount();\ngetActiveAccounts();\ngetActiveAccountInfo();\n```\n\n程序员怎么知道该调用哪个函数呢？\n\n如果缺少明确约定，变量moneyAmount就与money没区别，customerInfo与custmoer没区别，accountData与account没区别，theMessage也与message没区别。**要区分名称，就要以读者能鉴别不同之处的方式来区分**。\n\n## 使用读的出来的名称\n\n人类长于记忆和使用单词，若不善加利用，实在是种耻辱。\n\n**如果名称读不出来，讨论的时候会像个傻鸟**。“哎，这儿，鼻涕阿三喜摁踢（bee cee arr three cee enn tee， BCR3CNT的读音）上头，有个皮挨死极翘（pee ess zee kyew）整数，看见没？” **这不是小事，因为编程本就是一种社会活动**。\n\n有家公司，程序里面写了个 genymdhms（生成日期，年、月、日、时、分、秒），他们一般读作：“gen why emm dee aich emm ess”，YMDHMS的读音。我有个见字照读的恶习，于是开口就念“gen-yah-mudda-hims”。后来好些设计师和分析师都有样学样，听起来傻乎乎。我们知道典故，所以觉得很搞笑。搞笑归搞笑，实际是在强忍糟糕的命名。在给新开发者解释变量的意义时，他们总是读出傻乎乎的自造词，而非恰当的英语词。比较：\n\n```Java\nclass DtaRcrd102 {\n    private Date genymdhms;\n    private Date modymdhms;\n    private final String pszqint = \"102\";\n    /* ... */\n}\n```\n\n```C++\nclass Customer {\n    private Date generationTimestamp;\n    private Date modificationTimestamp;\n    private final String recordId = \"102\";\n    /* ... */\n}\n```\n\n现在读起来就像人话了：“喂，Mikey，看看这条记录！生成时间戳（generation timestamp）被设置为明天了！不能这样吧？”\n\n## 使用可搜索的名称\n\n单字母名称和数字常量有个问题，就是很难在一大篇文字中找出来。\n\n## 避免使用编码\n\n编码已经太多，无谓再自找麻烦。把类型或作用域编进名称里面，徒然增加了解码的负担。没理由要求每位新人都在弄清要应付的编码之外（那算是正常的），还要再搞懂另一套编码“语言”。这对于解决问题而言，纯属多余的负担。带编码的名称通常也不便发音，容易打错。\n\n### 匈牙利命名法\n\n在往昔名称长短很要命的时代，我们毫无必要的破坏了不编码的规矩，如今后悔不迭。Fortran语言要求首字母体现出类型，导致了编码的产生。BASIC早期版本只允许使用一个字母再加一位数字。匈牙利命名法（Hungarian Notation，HN）将这种态势愈演愈烈。\n\n在Windows的C语言API的时代，HN相当重要，那时所有名称要么是个整数句柄，要么是个长指针或者void指针，要不然就是string的几种实现（有不同的用途和属性）之一。那时候编译器并不做类型检查，程序员需要匈牙利命名法来帮助自己记住类型。\n\n现代编程语言具有更丰富的类型系统，编译器也记得并强制使用类型。而且，人们趋向于使用更小的类、更短的方法，好让每个变量的定义都在视野范围内。\n\nJava程序员不需要类型编码。对象是强类型的，代码编辑环境已经先进到在编译开始前就侦测到类型错误的程度！所以，如今HN和其他类型编码形式都纯属多余。它们增加了修改变量、函数或类的名称或类型的难度。它们增加了阅读代码的难度。它们制造了让编码系统误导读者的可能性。\n\n```\nPhoneNumber phoneString;    // 类型变化时，名称并不会自动变化，若名称中编码了类型，还要我们手动去改。\n```\n\n### 成员前缀\n\n也不必用m_前缀来标明成员变量。应当把类和函数做得足够小，消除对成员前缀的需要。你应当使用某种可以高亮或用颜色标出成员的编辑环境。\n\n```\npublic class Part {\n    private String m_dsc;   // The textual description\n    void setName(String name) {\n        m_dsc = name;\n    }\n}\n```\n\n```Java\npublic class Part{\n    String description;\n    void setDescription(String description) {\n        this.description = description;\n    }\n}\n```\n\n此外，人们会很快就学会无视前缀（或后缀），只看到名称中有意义的部分。代码读的越多，眼中就越没有前缀。最终，前缀变作了不入法眼的废料，变作了旧代码的标志物。\n\n### 接口和实现\n\n有时也会出现采用编码的特殊情形。比如，你在做一个创建形态用的抽象工厂（Abstract Factory）。该工厂是个接口，要用具体类来实现。你怎么 命名工厂和具体类呢？IShapeFactory和ShapeFactory吗？我喜欢不加修饰的接口。前导字母I被滥用到了说好听点是干扰，说难听点根本就是废话的程度。我不想让用户知道我给他们的是接口。我就想让他们知道那是个ShapeFactory。如果接口和实现必须选一个来编码的话，我宁肯选择实现。ShapeFactoryImp，甚至是丑陋的CShapeFactory，都比对接口名称编码来得好。\n\n## 避免思维映射\n\n不应当让读者在脑海中把你的名称翻译为他们熟知的名称。这种问题经常出现在选择是使用问题领域术语还是解决方案领域术语时。\n\n单字母变量名就是个问题。在作用域较小，也没有名称冲突时，循环计数器自然有可能被命名为i或j或k（但千万别用字母l）。这是因为传统上惯用单字母名称做循环计数器。然而，在多数其他情况下，单字母名称不是个好选择，读者必须在脑海中将它映射为真实概念。仅仅是因为有了a和b，就要取名为c，实在并非像样的理由。\n\n程序员通常都是聪明人。聪明人有时会借脑筋急转弯炫耀其聪明。总而言之，假使你记得r代表不包含主机和图式（scheme）的小写字母版url的话，那你真是太聪明了。\n\n聪明程序员和专业程序员之间的区别在于，专业程序员了解，明确是王道。专业程序员善用其能，编写其他人能理解的代码。\n\n## 类名\n\n类名和对象名应该是名词或名词短语，如Customer、WikiPage、Account和AddressParser。避免使用Manager、Processor、Data或Info这样的类名。类名不应当是动词。\n\n>这里没看懂，举的例子并不是动词啊\n\n## 方法名\n\n方法名应当是动词或动词短语，如 postPayment、deletePage或save。属性访问器、修改器和断言应该根据其值命名，并依Javabean标准加上get、set和is前缀。\n\n```Java\nString name = employee.getName();\ncustomer.setName(\"mike\");\nif(paycheck.isPosted())...\n```\n\n重载构造器时，使用描述了参数的静态工厂方法名。例如：\n\n```Java\nComplex fulcrumPoint = Complex.FromRealNumber(23.0);\n```\n\n通常好于\n\n```Java\nComplex fulcrumPoint = new Complex(23.0);\n```\n\n可以考虑将相应的构造器设置为private，强制使用这种命名手段。\n\n## 别扮可爱\n\n如果名称太耍宝，那就只有同作者一般有幽默感的人才能记得住，而且还是在他们记得那个笑话的时候才行。谁会知道名为HolyHandGrenade的函数是用来做什么的呢？没错，这名字挺伶俐，不过DeleteItems或许是更好的名称。宁可明确，毋为好玩。\n\n扮可爱的做法在代码中经常体现为使用俗语或俚语。例如，别用whack()来表示kill()。别用eatMyShorts()这类与文化紧密相关的笑话来表示abort()。\n\n## 每个概念对应一个词\n\n给每个抽象概念选一个词，并且一以贯之。例如，使用fetch、retrieve和get来给在多个类中的同种方法命名。你怎么记得住哪个类中是哪个方法呢？\n\nEclipse和Intellj之类的线代编程环境提供了与环境相关的线索，比如某个对象能调用的方法列表。不过要注意，列表中通常不会给出你为函数名和参数列表编写的注释。如果参数名称来自函数声明，你就太幸运了。函数名称应当独一无二，而且要保持一致，这样你才能不借助多余的浏览就能找到正确的方法。\n\n同样，在同一堆代码中有controller，又有manager，还有driver，就会令人困惑。DeviceManager和Protocal-Controller之间有何根本区别？为什么不全用controllers或managers？他们都是Drivers吗？这种名称，让人觉得这两个对象是不同类型的，也分属不同的类。\n\n对于那些会用到你代码的程序员，一以贯之的命名法简直就是天降福音。\n\n## 别用双关语\n\n避免将同一个单词用于不同目的。如果遵循“一词一意”的规则，可能在好多类里面都会有add方法。只要这些add方法的参数列表和返回值在语义上等价，就一切顺利。\n\n但是，可能会有人决定为“保持一致”而使用add这个词来命名，即便并非真的想表示这种意思。比如，在多个类种都有add方法，该方法通过增加或连接两个现存值来获得新值。假设要写个新类，该类中有一个方法，把单个参数放到群集（collection）中。该把这个方法叫做add吗？这样做貌似和其他add方法保持了一致，但实际上语义却不同，应该用insert或append之类的词来命名才对。把该方法命名为add，就是双关语了。\n\n## 使用解决方案领域的名称\n\n记住，只有程序员才会读你的代码。所以，尽管用那些计算机科学（Computer Science, CS）术语、算法名、模式名、数学术语吧。\n\n对于熟悉访问者（VISITOR）模式的程序来说，名称AccountVisitor富有意义。那个程序员会不知道JobQueue的意思呢？\n\n## 使用源自所涉及问题领域的名称\n\n如果不能用程序员熟悉的术语来给手头的工作命名，就采用从所涉及领域而来的名称吧。至少，负责维护代码的程序员就能去请教领域专家了。\n\n## 添加有意义的语境\n\n很少有名称是能自我说明的--多数都不能。反之，你需要用有良好命名的类、函数或名称空间来放置名称，给读者提供语境。如果没这么做，给名称添加前缀就是最后一招了。\n\n设想你有名为firstName、lastName、street、houseNumber、city\\state和zipcode的变量。当它们搁一块儿的时候，很明确是构成了一个地址。不过，假使只是在某个方法中看见孤零零的一个state变量呢？你会理所当然推断那是某个地址的一部分吗？\n\n可以添加前缀addrFirstName、addrLastName、addrState等，以此提供语境。至少，读者会明白这些变量都是某个更大结构的一部分。当然，更好的方案是创建名为Address的类。这样，即便是编译器也会知道这些变量隶属某个更大的概念了。\n\n看一个例子：\n\n语境不明确的变量：\n\n```Java\nprivate void printGuessStatistics(char candidate, int count){\n    String number;\n    String verb;\n    String pluralModifier;\n    if(count==0){\n        number=\"no\";\n        verb=\"are\";\n        pluralModifier=\"s\";\n    }else if(count==1){\n        number=\"1\";\n        verb=\"is\";\n        pluralModifier=\"\";\n    }else{\n        number=Integer.toString(count);\n        verb=\"are\";\n        pluralModifier=\"s\";\n    }\n    String guessMessage = String.format(\n        \"There %s %s %s%s\", verb, number, candidate, pluralModifier);\n    print(guessMessage);\n}\n```\n\n上列函数有点过长，变量的使用贯穿始终。要分解这个函数，需要创建一个名为GuessStatisticsMessage的类，把三个变量做成该类的成员字段。这样它们就在定义上变作了GuessStatisticsMessage的一部分。语境的增强也让算法能够通过分解为更小的函数而变得更为干净利落。\n\n有语境的变量：\n\n```Java\npublic class GuessStatisticsMessage {\n    private String number;\n    private String verb;\n    private String pluralModifier;\n\n    public String make(char candidate, int count){\n        createPluralDependentMessageParts(count);\n        return String.format(\n            \"There %s %s %s%s\", verb, number, candidate, pluralModifier);\n    }\n\n    private void createPluralDependentMessageParts(int count){\n        if(count==0){\n            thereAreNoLetters();\n        }else if (count==1){\n            thereIsOneLetter();\n        }else{\n            thereAreManyLetters(count);\n        }\n    }\n\n    private void thereAreManyLetters(int count){\n        number = Integer.toString(count);\n        verb = \"are\";\n        pluralModifier=\"s\";\n    }\n\n    private void thereIsOneLetters(){\n        number=\"1\";\n        verb = \"is\";\n        pluralModifier = \"\";\n    }\n\n    private void thereAreNoLetters(){\n        number = \"no\";\n        verb = \"are\";\n        pluralModifier = \"s\";\n    }\n}\n```\n\n## 不要添加没用的语境\n\n设若有一个名为“加油站豪华版”（Gas Station Deluxe）的应用，在其中给每个类添加GSD前缀就不是什么好点子。说白了，你是在和自己在用的工具过不去。输入G，按下自动完成键，结果会得到系统中全部类的列表，列表恨不得有一英里那么长。这样做聪明吗？为什么要搞得IDE没法帮助你？\n\n再比如，你在GSD应用程序中的记账模块创建了一个表示邮件地址的类，然后给该类命名为GSDAccountAddress。稍后，你的客户联络应用中需要用到邮件地址，你会用GSDAccountAddress吗？这名字听起来没问题吗？在这17个字母里面，有10个字母纯属多余，与当前语境毫无关联。\n\n只要短名称足够清楚，就要比长名称好。别给名称添加不必要的语境。\n\n对于Address类的实体来说，accountAddress和customerAddress都是不错的名称，不过用在类名上就不太好了。Address是个好类名。如果需要与MAC地址、端口地址和Web地址相区别，我会考虑使用PostalAddress、MAC和URI。这样的名称更为精确，而精确正是命名的要点。\n","slug":"《代码整洁之道》读书笔记-第2章-有意义的命名","published":1,"updated":"2018-06-10T13:50:23.150Z","layout":"post","photos":[],"link":"","_id":"cjm2w8ddz003kfgpxipg5al5z","content":"<p>我们写代码的时候需要不停的命名，项目、类、函数、变量 等等都要命名。而命名关乎程序的可读性，而程序的可读性又至关重要（代码是写给人看的）。</p>\n<h2 id=\"名副其实\"><a href=\"#名副其实\" class=\"headerlink\" title=\"名副其实\"></a>名副其实</h2><p>一个很重要的原则是：<strong>如果命名需要注释来补充，那就不算名副其实。</strong></p>\n<p>举个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int d;  //消逝的时间，以日计</span><br></pre></td></tr></table></figure>\n<p>名称<code>d</code>什么也没说，如果其他很多地方要用到这个变量那就十分糟糕了，因为用的人不一定想的起来<code>d</code>是什么意思（如果只是局部变量局部使用，那它的罪孽会轻一点，如果是全局变量或者类的成员变量那这简直就是大坑）。<strong>其实我们很容易发现，注释没法像好的命名一样方便，因为我们不会在写代码的时候看到一个不懂的命名就去找它的定义处的注释，这样会浪费很多时间</strong>。所以好的命名就应该能自己说明自己是什么。</p>\n<p>好的命名如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int elapsedTimeInDays;</span><br><span class=\"line\">int daysSinceCreation;</span><br><span class=\"line\">int daysSinceModification;</span><br><span class=\"line\">int fileAgeInDays;</span><br></pre></td></tr></table></figure>\n<p>下面我们看一段代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> List&lt;<span class=\"keyword\">int</span>[]&gt; getThem() &#123;</span><br><span class=\"line\">    List&lt;<span class=\"keyword\">int</span>[]&gt; list1 = <span class=\"keyword\">new</span> ArrayList&lt;<span class=\"keyword\">int</span>[]&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span>[] x : theList)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x[<span class=\"number\">0</span>] == <span class=\"number\">4</span>)&#123;</span><br><span class=\"line\">            list1.add(x);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码很糟糕，虽然里面没有复杂的表达式，空格和缩进中规中矩，只用到三个变量和两个常量，甚至没涉及到其他类或多态方法。但这段代码很难说清它在做什么。问题不在于代码的简洁度，而在于代码的 <strong>模糊度：即上下文在代码中未被明确体现的程度</strong>。比如随便提几个问题：</p>\n<ol>\n<li>theList 是什么类型的东西？</li>\n<li>theList 零下标条目的意义是什么？</li>\n<li>值4的意义是什么？</li>\n<li>我们怎么使用返回的list1？</li>\n</ol>\n<p><strong>问题的答案没体现在代码段中，可那就是它们该在的地方！如果不是对上下文及其熟悉，我们根本无法知道这代码在做什么！</strong></p>\n<p>比方说，我们在开发一种扫雷游戏，我们发现，盘面是名为 theList 的单元格列表，那就将其命名为：gameBoard。盘面上每个单元格都用一个简单数组表示。我们还发现，零下标条目是一种状态值，而这种状态值为4表示“已标记”。我们将代码修改如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> List&lt;<span class=\"keyword\">int</span>[]&gt; getFlaggedCells() &#123;</span><br><span class=\"line\">    List&lt;<span class=\"keyword\">int</span>[]&gt; flaggedCells = <span class=\"keyword\">new</span> ArrayList&lt;<span class=\"keyword\">int</span>[]&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span>[] cell : gameBoard)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cell[STATE_VALUE] == FLAGGED)&#123;</span><br><span class=\"line\">            flaggedCells.add(cell);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> flaggedCells;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这下这段代码是什么功能，做了些什么工作简直一目了然。还可以进一步，不用int数组表示单元格，而是另写一个类。该类包括一个名副其实的函数（称为 isFlagged），从而掩盖住那个魔术数。</p>\n<blockquote>\n<p>魔术数，magic number：指使用不明其意的立即数，至少我们应该用一个常量来对这种立即数进行命名，赋予其意义。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;Cell&gt; <span class=\"title\">getFlaggedCells</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Cell&gt; flaggedCells = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Cell cell : gameBoard)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cell.isFlagged())&#123;</span><br><span class=\"line\">            flaggedCells.add(cell);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> flaggedCells;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从int数组到Cell类，<strong>抽象程度又提高了，代码可重用性也就提高了</strong>。</p>\n<h2 id=\"避免误导\"><a href=\"#避免误导\" class=\"headerlink\" title=\"避免误导\"></a>避免误导</h2><p>例如，hp、aix 和 sco 都不应该用作变量名，因为它们都是UNIX平台或类UNIX平台的专有名称。别用accountList来指称一组账号，除非它们真的是List类型，List一词对程序员来说有特殊的意义，如果包纳账号的容器并非是一个List，就会引起错误的判断（即便容器就是个List，最好也别在名称中写出容器的类型）。所以，用accountGroup或bunchOfAccounts，甚至直接用accounts都会好一些。</p>\n<p><strong>提防使用不同之处较小的命名</strong>。想区分模块中某处的XYZControllerForEfficientHandlingOfStrings 和另一处的 XYZControllerForEfficentStorageOfStrings，会花多长时间呢？这两个词外形实在太相似了。我们很享受线代Java编程环境的自动代码完成特性，键入某个名称的前几个字母，就可以得到一列该名称的可能性，假如相似的名字依字母顺序放在一起，且差异很明显，那就会相当有助益。</p>\n<blockquote>\n<p>在某些字体里，1和l，0和O很难分清。要注意这种混淆。</p>\n</blockquote>\n<h2 id=\"做有意义的区分\"><a href=\"#做有意义的区分\" class=\"headerlink\" title=\"做有意义的区分\"></a>做有意义的区分</h2><p>如果程序员只是为满足编译器或解释器的需要而写代码，就会制造麻烦。例如，因为同一作用域内不能重名，你可能随手改掉其中一个命名，有时候干脆以错误的拼写充数，结果就是有人一不小心更正拼写错误，然后导致编译器出错。</p>\n<p>例如class已经是关键字，就给变量命名为klass，clazz，还有this，命名成thiz。</p>\n<p>以数字系列命名（a1, a2, …, aN）是以意义命名的对立面。试看：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">copyChars</span><span class=\"params\">(<span class=\"keyword\">char</span> a1[], <span class=\"keyword\">char</span> a2[])</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;a1.length;i++)&#123;</span><br><span class=\"line\">        a2[i] = a1[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果参数名改为 <code>source</code> 和 <code>destination</code>，这个函数就会像样许多。</p>\n<p><strong>废话是另一种没意义的区分</strong>。假设你有一个 Product 类。如果还有一个 ProductInfo 或 ProductData 类，那它们的名称虽然不同，意思却并无区别。Info和Data就像a、an和the一样是意义含混的废话。<br>注意，只要体现出有意义的区分，使用a和the这样的前缀就没错。例如，你可能把a用在域内变量，而把the用于函数参数。但如果你已经有一个名为zork的变量，又想调用一个名为theZork的变量，麻烦就来了。</p>\n<p>废话都是冗余。Variable一词永远不应当出现在变量名中。Table一词永远不应当出现在表名中。NameString会比Name好吗？难倒Name会是一个浮点数不成？如果是这样，就触犯了关于误导的规则。设想有个名为Customer的类，还有一个名为CustomerObject的类。区别何在呢？哪个是表示客户历史支付情况的最佳途径？</p>\n<p>举个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getActiveAccount();</span><br><span class=\"line\">getActiveAccounts();</span><br><span class=\"line\">getActiveAccountInfo();</span><br></pre></td></tr></table></figure>\n<p>程序员怎么知道该调用哪个函数呢？</p>\n<p>如果缺少明确约定，变量moneyAmount就与money没区别，customerInfo与custmoer没区别，accountData与account没区别，theMessage也与message没区别。<strong>要区分名称，就要以读者能鉴别不同之处的方式来区分</strong>。</p>\n<h2 id=\"使用读的出来的名称\"><a href=\"#使用读的出来的名称\" class=\"headerlink\" title=\"使用读的出来的名称\"></a>使用读的出来的名称</h2><p>人类长于记忆和使用单词，若不善加利用，实在是种耻辱。</p>\n<p><strong>如果名称读不出来，讨论的时候会像个傻鸟</strong>。“哎，这儿，鼻涕阿三喜摁踢（bee cee arr three cee enn tee， BCR3CNT的读音）上头，有个皮挨死极翘（pee ess zee kyew）整数，看见没？” <strong>这不是小事，因为编程本就是一种社会活动</strong>。</p>\n<p>有家公司，程序里面写了个 genymdhms（生成日期，年、月、日、时、分、秒），他们一般读作：“gen why emm dee aich emm ess”，YMDHMS的读音。我有个见字照读的恶习，于是开口就念“gen-yah-mudda-hims”。后来好些设计师和分析师都有样学样，听起来傻乎乎。我们知道典故，所以觉得很搞笑。搞笑归搞笑，实际是在强忍糟糕的命名。在给新开发者解释变量的意义时，他们总是读出傻乎乎的自造词，而非恰当的英语词。比较：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DtaRcrd102</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Date genymdhms;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Date modymdhms;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String pszqint = <span class=\"string\">\"102\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Customer</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Date generationTimestamp;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Date modificationTimestamp;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> final String recordId = <span class=\"string\">\"102\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在读起来就像人话了：“喂，Mikey，看看这条记录！生成时间戳（generation timestamp）被设置为明天了！不能这样吧？”</p>\n<h2 id=\"使用可搜索的名称\"><a href=\"#使用可搜索的名称\" class=\"headerlink\" title=\"使用可搜索的名称\"></a>使用可搜索的名称</h2><p>单字母名称和数字常量有个问题，就是很难在一大篇文字中找出来。</p>\n<h2 id=\"避免使用编码\"><a href=\"#避免使用编码\" class=\"headerlink\" title=\"避免使用编码\"></a>避免使用编码</h2><p>编码已经太多，无谓再自找麻烦。把类型或作用域编进名称里面，徒然增加了解码的负担。没理由要求每位新人都在弄清要应付的编码之外（那算是正常的），还要再搞懂另一套编码“语言”。这对于解决问题而言，纯属多余的负担。带编码的名称通常也不便发音，容易打错。</p>\n<h3 id=\"匈牙利命名法\"><a href=\"#匈牙利命名法\" class=\"headerlink\" title=\"匈牙利命名法\"></a>匈牙利命名法</h3><p>在往昔名称长短很要命的时代，我们毫无必要的破坏了不编码的规矩，如今后悔不迭。Fortran语言要求首字母体现出类型，导致了编码的产生。BASIC早期版本只允许使用一个字母再加一位数字。匈牙利命名法（Hungarian Notation，HN）将这种态势愈演愈烈。</p>\n<p>在Windows的C语言API的时代，HN相当重要，那时所有名称要么是个整数句柄，要么是个长指针或者void指针，要不然就是string的几种实现（有不同的用途和属性）之一。那时候编译器并不做类型检查，程序员需要匈牙利命名法来帮助自己记住类型。</p>\n<p>现代编程语言具有更丰富的类型系统，编译器也记得并强制使用类型。而且，人们趋向于使用更小的类、更短的方法，好让每个变量的定义都在视野范围内。</p>\n<p>Java程序员不需要类型编码。对象是强类型的，代码编辑环境已经先进到在编译开始前就侦测到类型错误的程度！所以，如今HN和其他类型编码形式都纯属多余。它们增加了修改变量、函数或类的名称或类型的难度。它们增加了阅读代码的难度。它们制造了让编码系统误导读者的可能性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PhoneNumber phoneString;    // 类型变化时，名称并不会自动变化，若名称中编码了类型，还要我们手动去改。</span><br></pre></td></tr></table></figure>\n<h3 id=\"成员前缀\"><a href=\"#成员前缀\" class=\"headerlink\" title=\"成员前缀\"></a>成员前缀</h3><p>也不必用m_前缀来标明成员变量。应当把类和函数做得足够小，消除对成员前缀的需要。你应当使用某种可以高亮或用颜色标出成员的编辑环境。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Part &#123;</span><br><span class=\"line\">    private String m_dsc;   // The textual description</span><br><span class=\"line\">    void setName(String name) &#123;</span><br><span class=\"line\">        m_dsc = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Part</span></span>&#123;</span><br><span class=\"line\">    String description;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setDescription</span><span class=\"params\">(String description)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.description = description;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此外，人们会很快就学会无视前缀（或后缀），只看到名称中有意义的部分。代码读的越多，眼中就越没有前缀。最终，前缀变作了不入法眼的废料，变作了旧代码的标志物。</p>\n<h3 id=\"接口和实现\"><a href=\"#接口和实现\" class=\"headerlink\" title=\"接口和实现\"></a>接口和实现</h3><p>有时也会出现采用编码的特殊情形。比如，你在做一个创建形态用的抽象工厂（Abstract Factory）。该工厂是个接口，要用具体类来实现。你怎么 命名工厂和具体类呢？IShapeFactory和ShapeFactory吗？我喜欢不加修饰的接口。前导字母I被滥用到了说好听点是干扰，说难听点根本就是废话的程度。我不想让用户知道我给他们的是接口。我就想让他们知道那是个ShapeFactory。如果接口和实现必须选一个来编码的话，我宁肯选择实现。ShapeFactoryImp，甚至是丑陋的CShapeFactory，都比对接口名称编码来得好。</p>\n<h2 id=\"避免思维映射\"><a href=\"#避免思维映射\" class=\"headerlink\" title=\"避免思维映射\"></a>避免思维映射</h2><p>不应当让读者在脑海中把你的名称翻译为他们熟知的名称。这种问题经常出现在选择是使用问题领域术语还是解决方案领域术语时。</p>\n<p>单字母变量名就是个问题。在作用域较小，也没有名称冲突时，循环计数器自然有可能被命名为i或j或k（但千万别用字母l）。这是因为传统上惯用单字母名称做循环计数器。然而，在多数其他情况下，单字母名称不是个好选择，读者必须在脑海中将它映射为真实概念。仅仅是因为有了a和b，就要取名为c，实在并非像样的理由。</p>\n<p>程序员通常都是聪明人。聪明人有时会借脑筋急转弯炫耀其聪明。总而言之，假使你记得r代表不包含主机和图式（scheme）的小写字母版url的话，那你真是太聪明了。</p>\n<p>聪明程序员和专业程序员之间的区别在于，专业程序员了解，明确是王道。专业程序员善用其能，编写其他人能理解的代码。</p>\n<h2 id=\"类名\"><a href=\"#类名\" class=\"headerlink\" title=\"类名\"></a>类名</h2><p>类名和对象名应该是名词或名词短语，如Customer、WikiPage、Account和AddressParser。避免使用Manager、Processor、Data或Info这样的类名。类名不应当是动词。</p>\n<blockquote>\n<p>这里没看懂，举的例子并不是动词啊</p>\n</blockquote>\n<h2 id=\"方法名\"><a href=\"#方法名\" class=\"headerlink\" title=\"方法名\"></a>方法名</h2><p>方法名应当是动词或动词短语，如 postPayment、deletePage或save。属性访问器、修改器和断言应该根据其值命名，并依Javabean标准加上get、set和is前缀。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String name = employee.getName();</span><br><span class=\"line\">customer.setName(<span class=\"string\">\"mike\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(paycheck.isPosted())...</span><br></pre></td></tr></table></figure>\n<p>重载构造器时，使用描述了参数的静态工厂方法名。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Complex fulcrumPoint = Complex.FromRealNumber(<span class=\"number\">23.0</span>);</span><br></pre></td></tr></table></figure>\n<p>通常好于</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Complex fulcrumPoint = <span class=\"keyword\">new</span> Complex(<span class=\"number\">23.0</span>);</span><br></pre></td></tr></table></figure>\n<p>可以考虑将相应的构造器设置为private，强制使用这种命名手段。</p>\n<h2 id=\"别扮可爱\"><a href=\"#别扮可爱\" class=\"headerlink\" title=\"别扮可爱\"></a>别扮可爱</h2><p>如果名称太耍宝，那就只有同作者一般有幽默感的人才能记得住，而且还是在他们记得那个笑话的时候才行。谁会知道名为HolyHandGrenade的函数是用来做什么的呢？没错，这名字挺伶俐，不过DeleteItems或许是更好的名称。宁可明确，毋为好玩。</p>\n<p>扮可爱的做法在代码中经常体现为使用俗语或俚语。例如，别用whack()来表示kill()。别用eatMyShorts()这类与文化紧密相关的笑话来表示abort()。</p>\n<h2 id=\"每个概念对应一个词\"><a href=\"#每个概念对应一个词\" class=\"headerlink\" title=\"每个概念对应一个词\"></a>每个概念对应一个词</h2><p>给每个抽象概念选一个词，并且一以贯之。例如，使用fetch、retrieve和get来给在多个类中的同种方法命名。你怎么记得住哪个类中是哪个方法呢？</p>\n<p>Eclipse和Intellj之类的线代编程环境提供了与环境相关的线索，比如某个对象能调用的方法列表。不过要注意，列表中通常不会给出你为函数名和参数列表编写的注释。如果参数名称来自函数声明，你就太幸运了。函数名称应当独一无二，而且要保持一致，这样你才能不借助多余的浏览就能找到正确的方法。</p>\n<p>同样，在同一堆代码中有controller，又有manager，还有driver，就会令人困惑。DeviceManager和Protocal-Controller之间有何根本区别？为什么不全用controllers或managers？他们都是Drivers吗？这种名称，让人觉得这两个对象是不同类型的，也分属不同的类。</p>\n<p>对于那些会用到你代码的程序员，一以贯之的命名法简直就是天降福音。</p>\n<h2 id=\"别用双关语\"><a href=\"#别用双关语\" class=\"headerlink\" title=\"别用双关语\"></a>别用双关语</h2><p>避免将同一个单词用于不同目的。如果遵循“一词一意”的规则，可能在好多类里面都会有add方法。只要这些add方法的参数列表和返回值在语义上等价，就一切顺利。</p>\n<p>但是，可能会有人决定为“保持一致”而使用add这个词来命名，即便并非真的想表示这种意思。比如，在多个类种都有add方法，该方法通过增加或连接两个现存值来获得新值。假设要写个新类，该类中有一个方法，把单个参数放到群集（collection）中。该把这个方法叫做add吗？这样做貌似和其他add方法保持了一致，但实际上语义却不同，应该用insert或append之类的词来命名才对。把该方法命名为add，就是双关语了。</p>\n<h2 id=\"使用解决方案领域的名称\"><a href=\"#使用解决方案领域的名称\" class=\"headerlink\" title=\"使用解决方案领域的名称\"></a>使用解决方案领域的名称</h2><p>记住，只有程序员才会读你的代码。所以，尽管用那些计算机科学（Computer Science, CS）术语、算法名、模式名、数学术语吧。</p>\n<p>对于熟悉访问者（VISITOR）模式的程序来说，名称AccountVisitor富有意义。那个程序员会不知道JobQueue的意思呢？</p>\n<h2 id=\"使用源自所涉及问题领域的名称\"><a href=\"#使用源自所涉及问题领域的名称\" class=\"headerlink\" title=\"使用源自所涉及问题领域的名称\"></a>使用源自所涉及问题领域的名称</h2><p>如果不能用程序员熟悉的术语来给手头的工作命名，就采用从所涉及领域而来的名称吧。至少，负责维护代码的程序员就能去请教领域专家了。</p>\n<h2 id=\"添加有意义的语境\"><a href=\"#添加有意义的语境\" class=\"headerlink\" title=\"添加有意义的语境\"></a>添加有意义的语境</h2><p>很少有名称是能自我说明的–多数都不能。反之，你需要用有良好命名的类、函数或名称空间来放置名称，给读者提供语境。如果没这么做，给名称添加前缀就是最后一招了。</p>\n<p>设想你有名为firstName、lastName、street、houseNumber、city\\state和zipcode的变量。当它们搁一块儿的时候，很明确是构成了一个地址。不过，假使只是在某个方法中看见孤零零的一个state变量呢？你会理所当然推断那是某个地址的一部分吗？</p>\n<p>可以添加前缀addrFirstName、addrLastName、addrState等，以此提供语境。至少，读者会明白这些变量都是某个更大结构的一部分。当然，更好的方案是创建名为Address的类。这样，即便是编译器也会知道这些变量隶属某个更大的概念了。</p>\n<p>看一个例子：</p>\n<p>语境不明确的变量：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">printGuessStatistics</span><span class=\"params\">(<span class=\"keyword\">char</span> candidate, <span class=\"keyword\">int</span> count)</span></span>&#123;</span><br><span class=\"line\">    String number;</span><br><span class=\"line\">    String verb;</span><br><span class=\"line\">    String pluralModifier;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(count==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        number=<span class=\"string\">\"no\"</span>;</span><br><span class=\"line\">        verb=<span class=\"string\">\"are\"</span>;</span><br><span class=\"line\">        pluralModifier=<span class=\"string\">\"s\"</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(count==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        number=<span class=\"string\">\"1\"</span>;</span><br><span class=\"line\">        verb=<span class=\"string\">\"is\"</span>;</span><br><span class=\"line\">        pluralModifier=<span class=\"string\">\"\"</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        number=Integer.toString(count);</span><br><span class=\"line\">        verb=<span class=\"string\">\"are\"</span>;</span><br><span class=\"line\">        pluralModifier=<span class=\"string\">\"s\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    String guessMessage = String.format(</span><br><span class=\"line\">        <span class=\"string\">\"There %s %s %s%s\"</span>, verb, number, candidate, pluralModifier);</span><br><span class=\"line\">    print(guessMessage);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上列函数有点过长，变量的使用贯穿始终。要分解这个函数，需要创建一个名为GuessStatisticsMessage的类，把三个变量做成该类的成员字段。这样它们就在定义上变作了GuessStatisticsMessage的一部分。语境的增强也让算法能够通过分解为更小的函数而变得更为干净利落。</p>\n<p>有语境的变量：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GuessStatisticsMessage</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String number;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String verb;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String pluralModifier;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">make</span><span class=\"params\">(<span class=\"keyword\">char</span> candidate, <span class=\"keyword\">int</span> count)</span></span>&#123;</span><br><span class=\"line\">        createPluralDependentMessageParts(count);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> String.format(</span><br><span class=\"line\">            <span class=\"string\">\"There %s %s %s%s\"</span>, verb, number, candidate, pluralModifier);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">createPluralDependentMessageParts</span><span class=\"params\">(<span class=\"keyword\">int</span> count)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(count==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            thereAreNoLetters();</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (count==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            thereIsOneLetter();</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            thereAreManyLetters(count);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">thereAreManyLetters</span><span class=\"params\">(<span class=\"keyword\">int</span> count)</span></span>&#123;</span><br><span class=\"line\">        number = Integer.toString(count);</span><br><span class=\"line\">        verb = <span class=\"string\">\"are\"</span>;</span><br><span class=\"line\">        pluralModifier=<span class=\"string\">\"s\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">thereIsOneLetters</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        number=<span class=\"string\">\"1\"</span>;</span><br><span class=\"line\">        verb = <span class=\"string\">\"is\"</span>;</span><br><span class=\"line\">        pluralModifier = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">thereAreNoLetters</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        number = <span class=\"string\">\"no\"</span>;</span><br><span class=\"line\">        verb = <span class=\"string\">\"are\"</span>;</span><br><span class=\"line\">        pluralModifier = <span class=\"string\">\"s\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"不要添加没用的语境\"><a href=\"#不要添加没用的语境\" class=\"headerlink\" title=\"不要添加没用的语境\"></a>不要添加没用的语境</h2><p>设若有一个名为“加油站豪华版”（Gas Station Deluxe）的应用，在其中给每个类添加GSD前缀就不是什么好点子。说白了，你是在和自己在用的工具过不去。输入G，按下自动完成键，结果会得到系统中全部类的列表，列表恨不得有一英里那么长。这样做聪明吗？为什么要搞得IDE没法帮助你？</p>\n<p>再比如，你在GSD应用程序中的记账模块创建了一个表示邮件地址的类，然后给该类命名为GSDAccountAddress。稍后，你的客户联络应用中需要用到邮件地址，你会用GSDAccountAddress吗？这名字听起来没问题吗？在这17个字母里面，有10个字母纯属多余，与当前语境毫无关联。</p>\n<p>只要短名称足够清楚，就要比长名称好。别给名称添加不必要的语境。</p>\n<p>对于Address类的实体来说，accountAddress和customerAddress都是不错的名称，不过用在类名上就不太好了。Address是个好类名。如果需要与MAC地址、端口地址和Web地址相区别，我会考虑使用PostalAddress、MAC和URI。这样的名称更为精确，而精确正是命名的要点。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>我们写代码的时候需要不停的命名，项目、类、函数、变量 等等都要命名。而命名关乎程序的可读性，而程序的可读性又至关重要（代码是写给人看的）。</p>\n<h2 id=\"名副其实\"><a href=\"#名副其实\" class=\"headerlink\" title=\"名副其实\"></a>名副其实</h2><p>一个很重要的原则是：<strong>如果命名需要注释来补充，那就不算名副其实。</strong></p>\n<p>举个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int d;  //消逝的时间，以日计</span><br></pre></td></tr></table></figure>\n<p>名称<code>d</code>什么也没说，如果其他很多地方要用到这个变量那就十分糟糕了，因为用的人不一定想的起来<code>d</code>是什么意思（如果只是局部变量局部使用，那它的罪孽会轻一点，如果是全局变量或者类的成员变量那这简直就是大坑）。<strong>其实我们很容易发现，注释没法像好的命名一样方便，因为我们不会在写代码的时候看到一个不懂的命名就去找它的定义处的注释，这样会浪费很多时间</strong>。所以好的命名就应该能自己说明自己是什么。</p>\n<p>好的命名如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int elapsedTimeInDays;</span><br><span class=\"line\">int daysSinceCreation;</span><br><span class=\"line\">int daysSinceModification;</span><br><span class=\"line\">int fileAgeInDays;</span><br></pre></td></tr></table></figure>\n<p>下面我们看一段代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> List&lt;<span class=\"keyword\">int</span>[]&gt; getThem() &#123;</span><br><span class=\"line\">    List&lt;<span class=\"keyword\">int</span>[]&gt; list1 = <span class=\"keyword\">new</span> ArrayList&lt;<span class=\"keyword\">int</span>[]&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span>[] x : theList)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x[<span class=\"number\">0</span>] == <span class=\"number\">4</span>)&#123;</span><br><span class=\"line\">            list1.add(x);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> list1;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这段代码很糟糕，虽然里面没有复杂的表达式，空格和缩进中规中矩，只用到三个变量和两个常量，甚至没涉及到其他类或多态方法。但这段代码很难说清它在做什么。问题不在于代码的简洁度，而在于代码的 <strong>模糊度：即上下文在代码中未被明确体现的程度</strong>。比如随便提几个问题：</p>\n<ol>\n<li>theList 是什么类型的东西？</li>\n<li>theList 零下标条目的意义是什么？</li>\n<li>值4的意义是什么？</li>\n<li>我们怎么使用返回的list1？</li>\n</ol>\n<p><strong>问题的答案没体现在代码段中，可那就是它们该在的地方！如果不是对上下文及其熟悉，我们根本无法知道这代码在做什么！</strong></p>\n<p>比方说，我们在开发一种扫雷游戏，我们发现，盘面是名为 theList 的单元格列表，那就将其命名为：gameBoard。盘面上每个单元格都用一个简单数组表示。我们还发现，零下标条目是一种状态值，而这种状态值为4表示“已标记”。我们将代码修改如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> List&lt;<span class=\"keyword\">int</span>[]&gt; getFlaggedCells() &#123;</span><br><span class=\"line\">    List&lt;<span class=\"keyword\">int</span>[]&gt; flaggedCells = <span class=\"keyword\">new</span> ArrayList&lt;<span class=\"keyword\">int</span>[]&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span>[] cell : gameBoard)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cell[STATE_VALUE] == FLAGGED)&#123;</span><br><span class=\"line\">            flaggedCells.add(cell);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> flaggedCells;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这下这段代码是什么功能，做了些什么工作简直一目了然。还可以进一步，不用int数组表示单元格，而是另写一个类。该类包括一个名副其实的函数（称为 isFlagged），从而掩盖住那个魔术数。</p>\n<blockquote>\n<p>魔术数，magic number：指使用不明其意的立即数，至少我们应该用一个常量来对这种立即数进行命名，赋予其意义。</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;Cell&gt; <span class=\"title\">getFlaggedCells</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Cell&gt; flaggedCells = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Cell cell : gameBoard)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cell.isFlagged())&#123;</span><br><span class=\"line\">            flaggedCells.add(cell);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> flaggedCells;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从int数组到Cell类，<strong>抽象程度又提高了，代码可重用性也就提高了</strong>。</p>\n<h2 id=\"避免误导\"><a href=\"#避免误导\" class=\"headerlink\" title=\"避免误导\"></a>避免误导</h2><p>例如，hp、aix 和 sco 都不应该用作变量名，因为它们都是UNIX平台或类UNIX平台的专有名称。别用accountList来指称一组账号，除非它们真的是List类型，List一词对程序员来说有特殊的意义，如果包纳账号的容器并非是一个List，就会引起错误的判断（即便容器就是个List，最好也别在名称中写出容器的类型）。所以，用accountGroup或bunchOfAccounts，甚至直接用accounts都会好一些。</p>\n<p><strong>提防使用不同之处较小的命名</strong>。想区分模块中某处的XYZControllerForEfficientHandlingOfStrings 和另一处的 XYZControllerForEfficentStorageOfStrings，会花多长时间呢？这两个词外形实在太相似了。我们很享受线代Java编程环境的自动代码完成特性，键入某个名称的前几个字母，就可以得到一列该名称的可能性，假如相似的名字依字母顺序放在一起，且差异很明显，那就会相当有助益。</p>\n<blockquote>\n<p>在某些字体里，1和l，0和O很难分清。要注意这种混淆。</p>\n</blockquote>\n<h2 id=\"做有意义的区分\"><a href=\"#做有意义的区分\" class=\"headerlink\" title=\"做有意义的区分\"></a>做有意义的区分</h2><p>如果程序员只是为满足编译器或解释器的需要而写代码，就会制造麻烦。例如，因为同一作用域内不能重名，你可能随手改掉其中一个命名，有时候干脆以错误的拼写充数，结果就是有人一不小心更正拼写错误，然后导致编译器出错。</p>\n<p>例如class已经是关键字，就给变量命名为klass，clazz，还有this，命名成thiz。</p>\n<p>以数字系列命名（a1, a2, …, aN）是以意义命名的对立面。试看：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">copyChars</span><span class=\"params\">(<span class=\"keyword\">char</span> a1[], <span class=\"keyword\">char</span> a2[])</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i=<span class=\"number\">0</span>;i&lt;a1.length;i++)&#123;</span><br><span class=\"line\">        a2[i] = a1[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>如果参数名改为 <code>source</code> 和 <code>destination</code>，这个函数就会像样许多。</p>\n<p><strong>废话是另一种没意义的区分</strong>。假设你有一个 Product 类。如果还有一个 ProductInfo 或 ProductData 类，那它们的名称虽然不同，意思却并无区别。Info和Data就像a、an和the一样是意义含混的废话。<br>注意，只要体现出有意义的区分，使用a和the这样的前缀就没错。例如，你可能把a用在域内变量，而把the用于函数参数。但如果你已经有一个名为zork的变量，又想调用一个名为theZork的变量，麻烦就来了。</p>\n<p>废话都是冗余。Variable一词永远不应当出现在变量名中。Table一词永远不应当出现在表名中。NameString会比Name好吗？难倒Name会是一个浮点数不成？如果是这样，就触犯了关于误导的规则。设想有个名为Customer的类，还有一个名为CustomerObject的类。区别何在呢？哪个是表示客户历史支付情况的最佳途径？</p>\n<p>举个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getActiveAccount();</span><br><span class=\"line\">getActiveAccounts();</span><br><span class=\"line\">getActiveAccountInfo();</span><br></pre></td></tr></table></figure>\n<p>程序员怎么知道该调用哪个函数呢？</p>\n<p>如果缺少明确约定，变量moneyAmount就与money没区别，customerInfo与custmoer没区别，accountData与account没区别，theMessage也与message没区别。<strong>要区分名称，就要以读者能鉴别不同之处的方式来区分</strong>。</p>\n<h2 id=\"使用读的出来的名称\"><a href=\"#使用读的出来的名称\" class=\"headerlink\" title=\"使用读的出来的名称\"></a>使用读的出来的名称</h2><p>人类长于记忆和使用单词，若不善加利用，实在是种耻辱。</p>\n<p><strong>如果名称读不出来，讨论的时候会像个傻鸟</strong>。“哎，这儿，鼻涕阿三喜摁踢（bee cee arr three cee enn tee， BCR3CNT的读音）上头，有个皮挨死极翘（pee ess zee kyew）整数，看见没？” <strong>这不是小事，因为编程本就是一种社会活动</strong>。</p>\n<p>有家公司，程序里面写了个 genymdhms（生成日期，年、月、日、时、分、秒），他们一般读作：“gen why emm dee aich emm ess”，YMDHMS的读音。我有个见字照读的恶习，于是开口就念“gen-yah-mudda-hims”。后来好些设计师和分析师都有样学样，听起来傻乎乎。我们知道典故，所以觉得很搞笑。搞笑归搞笑，实际是在强忍糟糕的命名。在给新开发者解释变量的意义时，他们总是读出傻乎乎的自造词，而非恰当的英语词。比较：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DtaRcrd102</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Date genymdhms;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Date modymdhms;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> String pszqint = <span class=\"string\">\"102\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Customer</span> &#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Date generationTimestamp;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Date modificationTimestamp;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> final String recordId = <span class=\"string\">\"102\"</span>;</span><br><span class=\"line\">    <span class=\"comment\">/* ... */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在读起来就像人话了：“喂，Mikey，看看这条记录！生成时间戳（generation timestamp）被设置为明天了！不能这样吧？”</p>\n<h2 id=\"使用可搜索的名称\"><a href=\"#使用可搜索的名称\" class=\"headerlink\" title=\"使用可搜索的名称\"></a>使用可搜索的名称</h2><p>单字母名称和数字常量有个问题，就是很难在一大篇文字中找出来。</p>\n<h2 id=\"避免使用编码\"><a href=\"#避免使用编码\" class=\"headerlink\" title=\"避免使用编码\"></a>避免使用编码</h2><p>编码已经太多，无谓再自找麻烦。把类型或作用域编进名称里面，徒然增加了解码的负担。没理由要求每位新人都在弄清要应付的编码之外（那算是正常的），还要再搞懂另一套编码“语言”。这对于解决问题而言，纯属多余的负担。带编码的名称通常也不便发音，容易打错。</p>\n<h3 id=\"匈牙利命名法\"><a href=\"#匈牙利命名法\" class=\"headerlink\" title=\"匈牙利命名法\"></a>匈牙利命名法</h3><p>在往昔名称长短很要命的时代，我们毫无必要的破坏了不编码的规矩，如今后悔不迭。Fortran语言要求首字母体现出类型，导致了编码的产生。BASIC早期版本只允许使用一个字母再加一位数字。匈牙利命名法（Hungarian Notation，HN）将这种态势愈演愈烈。</p>\n<p>在Windows的C语言API的时代，HN相当重要，那时所有名称要么是个整数句柄，要么是个长指针或者void指针，要不然就是string的几种实现（有不同的用途和属性）之一。那时候编译器并不做类型检查，程序员需要匈牙利命名法来帮助自己记住类型。</p>\n<p>现代编程语言具有更丰富的类型系统，编译器也记得并强制使用类型。而且，人们趋向于使用更小的类、更短的方法，好让每个变量的定义都在视野范围内。</p>\n<p>Java程序员不需要类型编码。对象是强类型的，代码编辑环境已经先进到在编译开始前就侦测到类型错误的程度！所以，如今HN和其他类型编码形式都纯属多余。它们增加了修改变量、函数或类的名称或类型的难度。它们增加了阅读代码的难度。它们制造了让编码系统误导读者的可能性。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PhoneNumber phoneString;    // 类型变化时，名称并不会自动变化，若名称中编码了类型，还要我们手动去改。</span><br></pre></td></tr></table></figure>\n<h3 id=\"成员前缀\"><a href=\"#成员前缀\" class=\"headerlink\" title=\"成员前缀\"></a>成员前缀</h3><p>也不必用m_前缀来标明成员变量。应当把类和函数做得足够小，消除对成员前缀的需要。你应当使用某种可以高亮或用颜色标出成员的编辑环境。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public class Part &#123;</span><br><span class=\"line\">    private String m_dsc;   // The textual description</span><br><span class=\"line\">    void setName(String name) &#123;</span><br><span class=\"line\">        m_dsc = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Part</span></span>&#123;</span><br><span class=\"line\">    String description;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setDescription</span><span class=\"params\">(String description)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.description = description;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此外，人们会很快就学会无视前缀（或后缀），只看到名称中有意义的部分。代码读的越多，眼中就越没有前缀。最终，前缀变作了不入法眼的废料，变作了旧代码的标志物。</p>\n<h3 id=\"接口和实现\"><a href=\"#接口和实现\" class=\"headerlink\" title=\"接口和实现\"></a>接口和实现</h3><p>有时也会出现采用编码的特殊情形。比如，你在做一个创建形态用的抽象工厂（Abstract Factory）。该工厂是个接口，要用具体类来实现。你怎么 命名工厂和具体类呢？IShapeFactory和ShapeFactory吗？我喜欢不加修饰的接口。前导字母I被滥用到了说好听点是干扰，说难听点根本就是废话的程度。我不想让用户知道我给他们的是接口。我就想让他们知道那是个ShapeFactory。如果接口和实现必须选一个来编码的话，我宁肯选择实现。ShapeFactoryImp，甚至是丑陋的CShapeFactory，都比对接口名称编码来得好。</p>\n<h2 id=\"避免思维映射\"><a href=\"#避免思维映射\" class=\"headerlink\" title=\"避免思维映射\"></a>避免思维映射</h2><p>不应当让读者在脑海中把你的名称翻译为他们熟知的名称。这种问题经常出现在选择是使用问题领域术语还是解决方案领域术语时。</p>\n<p>单字母变量名就是个问题。在作用域较小，也没有名称冲突时，循环计数器自然有可能被命名为i或j或k（但千万别用字母l）。这是因为传统上惯用单字母名称做循环计数器。然而，在多数其他情况下，单字母名称不是个好选择，读者必须在脑海中将它映射为真实概念。仅仅是因为有了a和b，就要取名为c，实在并非像样的理由。</p>\n<p>程序员通常都是聪明人。聪明人有时会借脑筋急转弯炫耀其聪明。总而言之，假使你记得r代表不包含主机和图式（scheme）的小写字母版url的话，那你真是太聪明了。</p>\n<p>聪明程序员和专业程序员之间的区别在于，专业程序员了解，明确是王道。专业程序员善用其能，编写其他人能理解的代码。</p>\n<h2 id=\"类名\"><a href=\"#类名\" class=\"headerlink\" title=\"类名\"></a>类名</h2><p>类名和对象名应该是名词或名词短语，如Customer、WikiPage、Account和AddressParser。避免使用Manager、Processor、Data或Info这样的类名。类名不应当是动词。</p>\n<blockquote>\n<p>这里没看懂，举的例子并不是动词啊</p>\n</blockquote>\n<h2 id=\"方法名\"><a href=\"#方法名\" class=\"headerlink\" title=\"方法名\"></a>方法名</h2><p>方法名应当是动词或动词短语，如 postPayment、deletePage或save。属性访问器、修改器和断言应该根据其值命名，并依Javabean标准加上get、set和is前缀。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">String name = employee.getName();</span><br><span class=\"line\">customer.setName(<span class=\"string\">\"mike\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">if</span>(paycheck.isPosted())...</span><br></pre></td></tr></table></figure>\n<p>重载构造器时，使用描述了参数的静态工厂方法名。例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Complex fulcrumPoint = Complex.FromRealNumber(<span class=\"number\">23.0</span>);</span><br></pre></td></tr></table></figure>\n<p>通常好于</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Complex fulcrumPoint = <span class=\"keyword\">new</span> Complex(<span class=\"number\">23.0</span>);</span><br></pre></td></tr></table></figure>\n<p>可以考虑将相应的构造器设置为private，强制使用这种命名手段。</p>\n<h2 id=\"别扮可爱\"><a href=\"#别扮可爱\" class=\"headerlink\" title=\"别扮可爱\"></a>别扮可爱</h2><p>如果名称太耍宝，那就只有同作者一般有幽默感的人才能记得住，而且还是在他们记得那个笑话的时候才行。谁会知道名为HolyHandGrenade的函数是用来做什么的呢？没错，这名字挺伶俐，不过DeleteItems或许是更好的名称。宁可明确，毋为好玩。</p>\n<p>扮可爱的做法在代码中经常体现为使用俗语或俚语。例如，别用whack()来表示kill()。别用eatMyShorts()这类与文化紧密相关的笑话来表示abort()。</p>\n<h2 id=\"每个概念对应一个词\"><a href=\"#每个概念对应一个词\" class=\"headerlink\" title=\"每个概念对应一个词\"></a>每个概念对应一个词</h2><p>给每个抽象概念选一个词，并且一以贯之。例如，使用fetch、retrieve和get来给在多个类中的同种方法命名。你怎么记得住哪个类中是哪个方法呢？</p>\n<p>Eclipse和Intellj之类的线代编程环境提供了与环境相关的线索，比如某个对象能调用的方法列表。不过要注意，列表中通常不会给出你为函数名和参数列表编写的注释。如果参数名称来自函数声明，你就太幸运了。函数名称应当独一无二，而且要保持一致，这样你才能不借助多余的浏览就能找到正确的方法。</p>\n<p>同样，在同一堆代码中有controller，又有manager，还有driver，就会令人困惑。DeviceManager和Protocal-Controller之间有何根本区别？为什么不全用controllers或managers？他们都是Drivers吗？这种名称，让人觉得这两个对象是不同类型的，也分属不同的类。</p>\n<p>对于那些会用到你代码的程序员，一以贯之的命名法简直就是天降福音。</p>\n<h2 id=\"别用双关语\"><a href=\"#别用双关语\" class=\"headerlink\" title=\"别用双关语\"></a>别用双关语</h2><p>避免将同一个单词用于不同目的。如果遵循“一词一意”的规则，可能在好多类里面都会有add方法。只要这些add方法的参数列表和返回值在语义上等价，就一切顺利。</p>\n<p>但是，可能会有人决定为“保持一致”而使用add这个词来命名，即便并非真的想表示这种意思。比如，在多个类种都有add方法，该方法通过增加或连接两个现存值来获得新值。假设要写个新类，该类中有一个方法，把单个参数放到群集（collection）中。该把这个方法叫做add吗？这样做貌似和其他add方法保持了一致，但实际上语义却不同，应该用insert或append之类的词来命名才对。把该方法命名为add，就是双关语了。</p>\n<h2 id=\"使用解决方案领域的名称\"><a href=\"#使用解决方案领域的名称\" class=\"headerlink\" title=\"使用解决方案领域的名称\"></a>使用解决方案领域的名称</h2><p>记住，只有程序员才会读你的代码。所以，尽管用那些计算机科学（Computer Science, CS）术语、算法名、模式名、数学术语吧。</p>\n<p>对于熟悉访问者（VISITOR）模式的程序来说，名称AccountVisitor富有意义。那个程序员会不知道JobQueue的意思呢？</p>\n<h2 id=\"使用源自所涉及问题领域的名称\"><a href=\"#使用源自所涉及问题领域的名称\" class=\"headerlink\" title=\"使用源自所涉及问题领域的名称\"></a>使用源自所涉及问题领域的名称</h2><p>如果不能用程序员熟悉的术语来给手头的工作命名，就采用从所涉及领域而来的名称吧。至少，负责维护代码的程序员就能去请教领域专家了。</p>\n<h2 id=\"添加有意义的语境\"><a href=\"#添加有意义的语境\" class=\"headerlink\" title=\"添加有意义的语境\"></a>添加有意义的语境</h2><p>很少有名称是能自我说明的–多数都不能。反之，你需要用有良好命名的类、函数或名称空间来放置名称，给读者提供语境。如果没这么做，给名称添加前缀就是最后一招了。</p>\n<p>设想你有名为firstName、lastName、street、houseNumber、city\\state和zipcode的变量。当它们搁一块儿的时候，很明确是构成了一个地址。不过，假使只是在某个方法中看见孤零零的一个state变量呢？你会理所当然推断那是某个地址的一部分吗？</p>\n<p>可以添加前缀addrFirstName、addrLastName、addrState等，以此提供语境。至少，读者会明白这些变量都是某个更大结构的一部分。当然，更好的方案是创建名为Address的类。这样，即便是编译器也会知道这些变量隶属某个更大的概念了。</p>\n<p>看一个例子：</p>\n<p>语境不明确的变量：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">printGuessStatistics</span><span class=\"params\">(<span class=\"keyword\">char</span> candidate, <span class=\"keyword\">int</span> count)</span></span>&#123;</span><br><span class=\"line\">    String number;</span><br><span class=\"line\">    String verb;</span><br><span class=\"line\">    String pluralModifier;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(count==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        number=<span class=\"string\">\"no\"</span>;</span><br><span class=\"line\">        verb=<span class=\"string\">\"are\"</span>;</span><br><span class=\"line\">        pluralModifier=<span class=\"string\">\"s\"</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(count==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">        number=<span class=\"string\">\"1\"</span>;</span><br><span class=\"line\">        verb=<span class=\"string\">\"is\"</span>;</span><br><span class=\"line\">        pluralModifier=<span class=\"string\">\"\"</span>;</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">        number=Integer.toString(count);</span><br><span class=\"line\">        verb=<span class=\"string\">\"are\"</span>;</span><br><span class=\"line\">        pluralModifier=<span class=\"string\">\"s\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    String guessMessage = String.format(</span><br><span class=\"line\">        <span class=\"string\">\"There %s %s %s%s\"</span>, verb, number, candidate, pluralModifier);</span><br><span class=\"line\">    print(guessMessage);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上列函数有点过长，变量的使用贯穿始终。要分解这个函数，需要创建一个名为GuessStatisticsMessage的类，把三个变量做成该类的成员字段。这样它们就在定义上变作了GuessStatisticsMessage的一部分。语境的增强也让算法能够通过分解为更小的函数而变得更为干净利落。</p>\n<p>有语境的变量：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">GuessStatisticsMessage</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String number;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String verb;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String pluralModifier;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">make</span><span class=\"params\">(<span class=\"keyword\">char</span> candidate, <span class=\"keyword\">int</span> count)</span></span>&#123;</span><br><span class=\"line\">        createPluralDependentMessageParts(count);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> String.format(</span><br><span class=\"line\">            <span class=\"string\">\"There %s %s %s%s\"</span>, verb, number, candidate, pluralModifier);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">createPluralDependentMessageParts</span><span class=\"params\">(<span class=\"keyword\">int</span> count)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(count==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">            thereAreNoLetters();</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (count==<span class=\"number\">1</span>)&#123;</span><br><span class=\"line\">            thereIsOneLetter();</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            thereAreManyLetters(count);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">thereAreManyLetters</span><span class=\"params\">(<span class=\"keyword\">int</span> count)</span></span>&#123;</span><br><span class=\"line\">        number = Integer.toString(count);</span><br><span class=\"line\">        verb = <span class=\"string\">\"are\"</span>;</span><br><span class=\"line\">        pluralModifier=<span class=\"string\">\"s\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">thereIsOneLetters</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        number=<span class=\"string\">\"1\"</span>;</span><br><span class=\"line\">        verb = <span class=\"string\">\"is\"</span>;</span><br><span class=\"line\">        pluralModifier = <span class=\"string\">\"\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">thereAreNoLetters</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        number = <span class=\"string\">\"no\"</span>;</span><br><span class=\"line\">        verb = <span class=\"string\">\"are\"</span>;</span><br><span class=\"line\">        pluralModifier = <span class=\"string\">\"s\"</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"不要添加没用的语境\"><a href=\"#不要添加没用的语境\" class=\"headerlink\" title=\"不要添加没用的语境\"></a>不要添加没用的语境</h2><p>设若有一个名为“加油站豪华版”（Gas Station Deluxe）的应用，在其中给每个类添加GSD前缀就不是什么好点子。说白了，你是在和自己在用的工具过不去。输入G，按下自动完成键，结果会得到系统中全部类的列表，列表恨不得有一英里那么长。这样做聪明吗？为什么要搞得IDE没法帮助你？</p>\n<p>再比如，你在GSD应用程序中的记账模块创建了一个表示邮件地址的类，然后给该类命名为GSDAccountAddress。稍后，你的客户联络应用中需要用到邮件地址，你会用GSDAccountAddress吗？这名字听起来没问题吗？在这17个字母里面，有10个字母纯属多余，与当前语境毫无关联。</p>\n<p>只要短名称足够清楚，就要比长名称好。别给名称添加不必要的语境。</p>\n<p>对于Address类的实体来说，accountAddress和customerAddress都是不错的名称，不过用在类名上就不太好了。Address是个好类名。如果需要与MAC地址、端口地址和Web地址相区别，我会考虑使用PostalAddress、MAC和URI。这样的名称更为精确，而精确正是命名的要点。</p>\n"},{"title":"Leetcode 804 Unique Morse Code Words","comments":1,"date":"2018-08-08T09:33:51.000Z","_content":"\n\n## 804. Unique Morse Code Words\n\nInternational Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: `\"a\"` maps to `\".-\"`, `\"b\"`maps to `\"-...\"`, `\"c\"` maps to `\"-.-.\"`, and so on.\n\nFor convenience, the full table for the 26 letters of the English alphabet is given below:\n\n```\n[\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\n```\n\nNow, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, \"cab\" can be written as \"-.-.-....-\", (which is the concatenation \"-.-.\" + \"-...\" + \".-\"). We'll call such a concatenation, the transformation of a word.\n\nReturn the number of different transformations among all words we have.\n\n```\nExample:\nInput: words = [\"gin\", \"zen\", \"gig\", \"msg\"]\nOutput: 2\nExplanation: \nThe transformation of each word is:\n\"gin\" -> \"--...-.\"\n\"zen\" -> \"--...-.\"\n\"gig\" -> \"--...--.\"\n\"msg\" -> \"--...--.\"\n\nThere are 2 different transformations, \"--...-.\" and \"--...--.\".\n```\n\nNote:\n\n- The length of `words` will be at most `100`.\n- Each `words[i]` will have length in range `[1, 12]`.\n- `words[i]` will only consist of lowercase letters.\n\n## Java Code\n\n```Java\nclass Solution{\n    public int uniqueMorseRepresentations(String[] words){\n        String[] Morse={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\n        Set<String> set = new HashSet();\n        for(String word : words){\n            StringBuilder code = new StringBuilder();\n            for(char c:word.toCharArray()){\n                code.append(Morse[c-'a']);\n            }\n            set.add(code.toString());\n        }\n        return set.size();\n    }\n}\n```\n\n这里用到的数据结构是`HashSet`，Set用来存放无序的、不重复的数据。","source":"_posts/2018/2018-08-07-Leetcode-804-Unique-Morse-Code-Words.md","raw":"---\ntitle: Leetcode 804 Unique Morse Code Words\ncategories:\n  - ACM\n  - Leetcode\ncomments: true\ndate: 2018-08-08 17:33:51\ntags:\n---\n\n\n## 804. Unique Morse Code Words\n\nInternational Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: `\"a\"` maps to `\".-\"`, `\"b\"`maps to `\"-...\"`, `\"c\"` maps to `\"-.-.\"`, and so on.\n\nFor convenience, the full table for the 26 letters of the English alphabet is given below:\n\n```\n[\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"]\n```\n\nNow, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, \"cab\" can be written as \"-.-.-....-\", (which is the concatenation \"-.-.\" + \"-...\" + \".-\"). We'll call such a concatenation, the transformation of a word.\n\nReturn the number of different transformations among all words we have.\n\n```\nExample:\nInput: words = [\"gin\", \"zen\", \"gig\", \"msg\"]\nOutput: 2\nExplanation: \nThe transformation of each word is:\n\"gin\" -> \"--...-.\"\n\"zen\" -> \"--...-.\"\n\"gig\" -> \"--...--.\"\n\"msg\" -> \"--...--.\"\n\nThere are 2 different transformations, \"--...-.\" and \"--...--.\".\n```\n\nNote:\n\n- The length of `words` will be at most `100`.\n- Each `words[i]` will have length in range `[1, 12]`.\n- `words[i]` will only consist of lowercase letters.\n\n## Java Code\n\n```Java\nclass Solution{\n    public int uniqueMorseRepresentations(String[] words){\n        String[] Morse={\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"};\n        Set<String> set = new HashSet();\n        for(String word : words){\n            StringBuilder code = new StringBuilder();\n            for(char c:word.toCharArray()){\n                code.append(Morse[c-'a']);\n            }\n            set.add(code.toString());\n        }\n        return set.size();\n    }\n}\n```\n\n这里用到的数据结构是`HashSet`，Set用来存放无序的、不重复的数据。","slug":"Leetcode-804-Unique-Morse-Code-Words","published":1,"updated":"2018-08-08T09:33:51.406Z","layout":"post","photos":[],"link":"","_id":"cjm2w8de1003mfgpx9esrtpp0","content":"<h2 id=\"804-Unique-Morse-Code-Words\"><a href=\"#804-Unique-Morse-Code-Words\" class=\"headerlink\" title=\"804. Unique Morse Code Words\"></a>804. Unique Morse Code Words</h2><p>International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: <code>&quot;a&quot;</code> maps to <code>&quot;.-&quot;</code>, <code>&quot;b&quot;</code>maps to <code>&quot;-...&quot;</code>, <code>&quot;c&quot;</code> maps to <code>&quot;-.-.&quot;</code>, and so on.</p>\n<p>For convenience, the full table for the 26 letters of the English alphabet is given below:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[&quot;.-&quot;,&quot;-...&quot;,&quot;-.-.&quot;,&quot;-..&quot;,&quot;.&quot;,&quot;..-.&quot;,&quot;--.&quot;,&quot;....&quot;,&quot;..&quot;,&quot;.---&quot;,&quot;-.-&quot;,&quot;.-..&quot;,&quot;--&quot;,&quot;-.&quot;,&quot;---&quot;,&quot;.--.&quot;,&quot;--.-&quot;,&quot;.-.&quot;,&quot;...&quot;,&quot;-&quot;,&quot;..-&quot;,&quot;...-&quot;,&quot;.--&quot;,&quot;-..-&quot;,&quot;-.--&quot;,&quot;--..&quot;]</span><br></pre></td></tr></table></figure>\n<p>Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, “cab” can be written as “-.-.-….-“, (which is the concatenation “-.-.” + “-…” + “.-“). We’ll call such a concatenation, the transformation of a word.</p>\n<p>Return the number of different transformations among all words we have.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Example:</span><br><span class=\"line\">Input: words = [&quot;gin&quot;, &quot;zen&quot;, &quot;gig&quot;, &quot;msg&quot;]</span><br><span class=\"line\">Output: 2</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">The transformation of each word is:</span><br><span class=\"line\">&quot;gin&quot; -&gt; &quot;--...-.&quot;</span><br><span class=\"line\">&quot;zen&quot; -&gt; &quot;--...-.&quot;</span><br><span class=\"line\">&quot;gig&quot; -&gt; &quot;--...--.&quot;</span><br><span class=\"line\">&quot;msg&quot; -&gt; &quot;--...--.&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">There are 2 different transformations, &quot;--...-.&quot; and &quot;--...--.&quot;.</span><br></pre></td></tr></table></figure>\n<p>Note:</p>\n<ul>\n<li>The length of <code>words</code> will be at most <code>100</code>.</li>\n<li>Each <code>words[i]</code> will have length in range <code>[1, 12]</code>.</li>\n<li><code>words[i]</code> will only consist of lowercase letters.</li>\n</ul>\n<h2 id=\"Java-Code\"><a href=\"#Java-Code\" class=\"headerlink\" title=\"Java Code\"></a>Java Code</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">uniqueMorseRepresentations</span><span class=\"params\">(String[] words)</span></span>&#123;</span><br><span class=\"line\">        String[] Morse=&#123;<span class=\"string\">\".-\"</span>,<span class=\"string\">\"-...\"</span>,<span class=\"string\">\"-.-.\"</span>,<span class=\"string\">\"-..\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\"..-.\"</span>,<span class=\"string\">\"--.\"</span>,<span class=\"string\">\"....\"</span>,<span class=\"string\">\"..\"</span>,<span class=\"string\">\".---\"</span>,<span class=\"string\">\"-.-\"</span>,<span class=\"string\">\".-..\"</span>,<span class=\"string\">\"--\"</span>,<span class=\"string\">\"-.\"</span>,<span class=\"string\">\"---\"</span>,<span class=\"string\">\".--.\"</span>,<span class=\"string\">\"--.-\"</span>,<span class=\"string\">\".-.\"</span>,<span class=\"string\">\"...\"</span>,<span class=\"string\">\"-\"</span>,<span class=\"string\">\"..-\"</span>,<span class=\"string\">\"...-\"</span>,<span class=\"string\">\".--\"</span>,<span class=\"string\">\"-..-\"</span>,<span class=\"string\">\"-.--\"</span>,<span class=\"string\">\"--..\"</span>&#125;;</span><br><span class=\"line\">        Set&lt;String&gt; set = <span class=\"keyword\">new</span> HashSet();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(String word : words)&#123;</span><br><span class=\"line\">            StringBuilder code = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">char</span> c:word.toCharArray())&#123;</span><br><span class=\"line\">                code.append(Morse[c-<span class=\"string\">'a'</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            set.add(code.toString());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> set.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里用到的数据结构是<code>HashSet</code>，Set用来存放无序的、不重复的数据。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"804-Unique-Morse-Code-Words\"><a href=\"#804-Unique-Morse-Code-Words\" class=\"headerlink\" title=\"804. Unique Morse Code Words\"></a>804. Unique Morse Code Words</h2><p>International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: <code>&quot;a&quot;</code> maps to <code>&quot;.-&quot;</code>, <code>&quot;b&quot;</code>maps to <code>&quot;-...&quot;</code>, <code>&quot;c&quot;</code> maps to <code>&quot;-.-.&quot;</code>, and so on.</p>\n<p>For convenience, the full table for the 26 letters of the English alphabet is given below:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[&quot;.-&quot;,&quot;-...&quot;,&quot;-.-.&quot;,&quot;-..&quot;,&quot;.&quot;,&quot;..-.&quot;,&quot;--.&quot;,&quot;....&quot;,&quot;..&quot;,&quot;.---&quot;,&quot;-.-&quot;,&quot;.-..&quot;,&quot;--&quot;,&quot;-.&quot;,&quot;---&quot;,&quot;.--.&quot;,&quot;--.-&quot;,&quot;.-.&quot;,&quot;...&quot;,&quot;-&quot;,&quot;..-&quot;,&quot;...-&quot;,&quot;.--&quot;,&quot;-..-&quot;,&quot;-.--&quot;,&quot;--..&quot;]</span><br></pre></td></tr></table></figure>\n<p>Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, “cab” can be written as “-.-.-….-“, (which is the concatenation “-.-.” + “-…” + “.-“). We’ll call such a concatenation, the transformation of a word.</p>\n<p>Return the number of different transformations among all words we have.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Example:</span><br><span class=\"line\">Input: words = [&quot;gin&quot;, &quot;zen&quot;, &quot;gig&quot;, &quot;msg&quot;]</span><br><span class=\"line\">Output: 2</span><br><span class=\"line\">Explanation: </span><br><span class=\"line\">The transformation of each word is:</span><br><span class=\"line\">&quot;gin&quot; -&gt; &quot;--...-.&quot;</span><br><span class=\"line\">&quot;zen&quot; -&gt; &quot;--...-.&quot;</span><br><span class=\"line\">&quot;gig&quot; -&gt; &quot;--...--.&quot;</span><br><span class=\"line\">&quot;msg&quot; -&gt; &quot;--...--.&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">There are 2 different transformations, &quot;--...-.&quot; and &quot;--...--.&quot;.</span><br></pre></td></tr></table></figure>\n<p>Note:</p>\n<ul>\n<li>The length of <code>words</code> will be at most <code>100</code>.</li>\n<li>Each <code>words[i]</code> will have length in range <code>[1, 12]</code>.</li>\n<li><code>words[i]</code> will only consist of lowercase letters.</li>\n</ul>\n<h2 id=\"Java-Code\"><a href=\"#Java-Code\" class=\"headerlink\" title=\"Java Code\"></a>Java Code</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Solution</span></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">uniqueMorseRepresentations</span><span class=\"params\">(String[] words)</span></span>&#123;</span><br><span class=\"line\">        String[] Morse=&#123;<span class=\"string\">\".-\"</span>,<span class=\"string\">\"-...\"</span>,<span class=\"string\">\"-.-.\"</span>,<span class=\"string\">\"-..\"</span>,<span class=\"string\">\".\"</span>,<span class=\"string\">\"..-.\"</span>,<span class=\"string\">\"--.\"</span>,<span class=\"string\">\"....\"</span>,<span class=\"string\">\"..\"</span>,<span class=\"string\">\".---\"</span>,<span class=\"string\">\"-.-\"</span>,<span class=\"string\">\".-..\"</span>,<span class=\"string\">\"--\"</span>,<span class=\"string\">\"-.\"</span>,<span class=\"string\">\"---\"</span>,<span class=\"string\">\".--.\"</span>,<span class=\"string\">\"--.-\"</span>,<span class=\"string\">\".-.\"</span>,<span class=\"string\">\"...\"</span>,<span class=\"string\">\"-\"</span>,<span class=\"string\">\"..-\"</span>,<span class=\"string\">\"...-\"</span>,<span class=\"string\">\".--\"</span>,<span class=\"string\">\"-..-\"</span>,<span class=\"string\">\"-.--\"</span>,<span class=\"string\">\"--..\"</span>&#125;;</span><br><span class=\"line\">        Set&lt;String&gt; set = <span class=\"keyword\">new</span> HashSet();</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(String word : words)&#123;</span><br><span class=\"line\">            StringBuilder code = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">            <span class=\"keyword\">for</span>(<span class=\"keyword\">char</span> c:word.toCharArray())&#123;</span><br><span class=\"line\">                code.append(Morse[c-<span class=\"string\">'a'</span>]);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            set.add(code.toString());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> set.size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里用到的数据结构是<code>HashSet</code>，Set用来存放无序的、不重复的数据。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjm2w8d5f0001fgpxl696hh7p","category_id":"cjm2w8d5k0004fgpxnh8sbwwe","_id":"cjm2w8d5t000hfgpx7cqzduxs"},{"post_id":"cjm2w8d5f0001fgpxl696hh7p","category_id":"cjm2w8d5t000ffgpx2med7t1r","_id":"cjm2w8d5u000jfgpxrwpeyiyv"},{"post_id":"cjm2w8d5j0003fgpxmcfrf1i3","category_id":"cjm2w8d5k0004fgpxnh8sbwwe","_id":"cjm2w8d5u000kfgpxumftj5hr"},{"post_id":"cjm2w8d5j0003fgpxmcfrf1i3","category_id":"cjm2w8d5t000gfgpx6qq3woht","_id":"cjm2w8d5u000lfgpxx1nhiu70"},{"post_id":"cjm2w8d5o0009fgpxztiscaqg","category_id":"cjm2w8d5s000dfgpx3f0egbog","_id":"cjm2w8d5u000mfgpx5xkskq70"},{"post_id":"cjm2w8d5o0009fgpxztiscaqg","category_id":"cjm2w8d5t000ifgpxv3u7ydlz","_id":"cjm2w8d5u000nfgpxgywd2js9"},{"post_id":"cjm2w8dcq000tfgpxxh4qbd85","category_id":"cjm2w8dcv0010fgpx5ikztkhc","_id":"cjm2w8dcz001afgpx3jdc3q29"},{"post_id":"cjm2w8dcw0014fgpx55zxmnpa","category_id":"cjm2w8dcv0010fgpx5ikztkhc","_id":"cjm2w8dd0001dfgpx1bxx6bsq"},{"post_id":"cjm2w8dcr000ufgpxquwx96om","category_id":"cjm2w8dcx0015fgpxh6xqgx44","_id":"cjm2w8dd2001hfgpx6fqxcaml"},{"post_id":"cjm2w8dco000qfgpx3p9g254y","category_id":"cjm2w8dcp000sfgpxa2hwvknw","_id":"cjm2w8dd5001pfgpx3ojivnv6"},{"post_id":"cjm2w8dco000qfgpx3p9g254y","category_id":"cjm2w8dcz001bfgpx7plompga","_id":"cjm2w8dd7001tfgpxce540g1b"},{"post_id":"cjm2w8dcs000vfgpxcaoa7hxy","category_id":"cjm2w8dcv0010fgpx5ikztkhc","_id":"cjm2w8dd8001wfgpx06emrbjc"},{"post_id":"cjm2w8dct000yfgpxie7qatmd","category_id":"cjm2w8dd5001ofgpx30578chg","_id":"cjm2w8ddb0023fgpxujsk5ydh"},{"post_id":"cjm2w8dcp000rfgpxz2a99uyi","category_id":"cjm2w8dcp000sfgpxa2hwvknw","_id":"cjm2w8ddd0027fgpxgwm26s63"},{"post_id":"cjm2w8dcp000rfgpxz2a99uyi","category_id":"cjm2w8dcz001bfgpx7plompga","_id":"cjm2w8dde0029fgpxk5bjd398"},{"post_id":"cjm2w8dcu000zfgpx9aipiej0","category_id":"cjm2w8dcv0010fgpx5ikztkhc","_id":"cjm2w8ddf002cfgpxnnsk6829"},{"post_id":"cjm2w8dcv0011fgpxukuwarth","category_id":"cjm2w8dcx0015fgpxh6xqgx44","_id":"cjm2w8ddh002ffgpxuif10gt5"},{"post_id":"cjm2w8dcx0017fgpxk24spqpg","category_id":"cjm2w8d5k0004fgpxnh8sbwwe","_id":"cjm2w8ddk002kfgpxr6ew9fki"},{"post_id":"cjm2w8dcx0017fgpxk24spqpg","category_id":"cjm2w8ddf002bfgpxr7nqzmdz","_id":"cjm2w8ddl002mfgpxo5htt3ov"},{"post_id":"cjm2w8ddh002efgpx1fv54zee","category_id":"cjm2w8dd5001ofgpx30578chg","_id":"cjm2w8ddm002pfgpxr8p03wyg"},{"post_id":"cjm2w8ddi002hfgpxzbobsus1","category_id":"cjm2w8dcp000sfgpxa2hwvknw","_id":"cjm2w8ddn002rfgpxvhbohr1i"},{"post_id":"cjm2w8dcy0019fgpx9onep9pk","category_id":"cjm2w8d5k0004fgpxnh8sbwwe","_id":"cjm2w8ddo002ufgpx9o4wdgz9"},{"post_id":"cjm2w8dcy0019fgpx9onep9pk","category_id":"cjm2w8ddf002bfgpxr7nqzmdz","_id":"cjm2w8ddp002wfgpxo6os5xpb"},{"post_id":"cjm2w8ddk002lfgpxhsekpx6t","category_id":"cjm2w8d5s000dfgpx3f0egbog","_id":"cjm2w8ddq002yfgpxc0an9zme"},{"post_id":"cjm2w8ddk002lfgpxhsekpx6t","category_id":"cjm2w8d5t000ifgpxv3u7ydlz","_id":"cjm2w8ddr0031fgpxjt5judf8"},{"post_id":"cjm2w8dcz001cfgpx7ac2uv93","category_id":"cjm2w8d5k0004fgpxnh8sbwwe","_id":"cjm2w8dds0033fgpx2limeghs"},{"post_id":"cjm2w8dcz001cfgpx7ac2uv93","category_id":"cjm2w8ddf002bfgpxr7nqzmdz","_id":"cjm2w8ddt0036fgpxxitej28q"},{"post_id":"cjm2w8dd1001ffgpxg58cmriq","category_id":"cjm2w8d5k0004fgpxnh8sbwwe","_id":"cjm2w8ddu0038fgpx6pcd5kde"},{"post_id":"cjm2w8dd1001ffgpxg58cmriq","category_id":"cjm2w8ddf002bfgpxr7nqzmdz","_id":"cjm2w8ddv003bfgpxahmrfwij"},{"post_id":"cjm2w8dd4001mfgpxw2qwvmk2","category_id":"cjm2w8d5s000dfgpx3f0egbog","_id":"cjm2w8ddw003dfgpxysvi3ed8"},{"post_id":"cjm2w8dd4001mfgpxw2qwvmk2","category_id":"cjm2w8ddq002zfgpx47hvkafw","_id":"cjm2w8ddy003gfgpxgjtfzggc"},{"post_id":"cjm2w8dd5001qfgpxnhck7ys3","category_id":"cjm2w8d5s000dfgpx3f0egbog","_id":"cjm2w8ddz003ifgpxwysmaehk"},{"post_id":"cjm2w8dd5001qfgpxnhck7ys3","category_id":"cjm2w8ddq002zfgpx47hvkafw","_id":"cjm2w8de0003lfgpxrpancjmd"},{"post_id":"cjm2w8dd7001ufgpxfxrtr2qr","category_id":"cjm2w8d5s000dfgpx3f0egbog","_id":"cjm2w8de1003nfgpx0inl1108"},{"post_id":"cjm2w8dd7001ufgpxfxrtr2qr","category_id":"cjm2w8ddq002zfgpx47hvkafw","_id":"cjm2w8de2003qfgpxsi5qszcs"},{"post_id":"cjm2w8dd8001xfgpxm72tqj6u","category_id":"cjm2w8d5s000dfgpx3f0egbog","_id":"cjm2w8de2003rfgpx30538tb2"},{"post_id":"cjm2w8dd8001xfgpxm72tqj6u","category_id":"cjm2w8ddq002zfgpx47hvkafw","_id":"cjm2w8de3003tfgpxoj91owl3"},{"post_id":"cjm2w8ddz003kfgpxipg5al5z","category_id":"cjm2w8d5k0004fgpxnh8sbwwe","_id":"cjm2w8de3003ufgpxo0oa16ia"},{"post_id":"cjm2w8ddz003kfgpxipg5al5z","category_id":"cjm2w8d5t000ffgpx2med7t1r","_id":"cjm2w8de3003wfgpx4801h16e"},{"post_id":"cjm2w8dd9001zfgpx0elpn0jx","category_id":"cjm2w8d5s000dfgpx3f0egbog","_id":"cjm2w8de4003xfgpxlba9qeon"},{"post_id":"cjm2w8dd9001zfgpx0elpn0jx","category_id":"cjm2w8ddq002zfgpx47hvkafw","_id":"cjm2w8de4003zfgpxqm3q6qeu"},{"post_id":"cjm2w8de1003mfgpx9esrtpp0","category_id":"cjm2w8d5s000dfgpx3f0egbog","_id":"cjm2w8de40040fgpx0ks0nt1s"},{"post_id":"cjm2w8de1003mfgpx9esrtpp0","category_id":"cjm2w8d5t000ifgpxv3u7ydlz","_id":"cjm2w8de50042fgpx2g2hftwn"},{"post_id":"cjm2w8dda0021fgpxl6kehe4x","category_id":"cjm2w8d5s000dfgpx3f0egbog","_id":"cjm2w8de50043fgpxqf698cgc"},{"post_id":"cjm2w8dda0021fgpxl6kehe4x","category_id":"cjm2w8ddq002zfgpx47hvkafw","_id":"cjm2w8de50045fgpxvoqmewlk"},{"post_id":"cjm2w8ddb0024fgpx141ubpmj","category_id":"cjm2w8d5s000dfgpx3f0egbog","_id":"cjm2w8de50046fgpx47hqvdos"},{"post_id":"cjm2w8ddb0024fgpx141ubpmj","category_id":"cjm2w8ddq002zfgpx47hvkafw","_id":"cjm2w8de50048fgpx8d0xdi1s"},{"post_id":"cjm2w8ddc0025fgpx13mibade","category_id":"cjm2w8d5s000dfgpx3f0egbog","_id":"cjm2w8de60049fgpxp7go4t9b"},{"post_id":"cjm2w8ddc0025fgpx13mibade","category_id":"cjm2w8ddq002zfgpx47hvkafw","_id":"cjm2w8de6004bfgpxfswen5lh"},{"post_id":"cjm2w8dde0028fgpx7maz5vpr","category_id":"cjm2w8d5s000dfgpx3f0egbog","_id":"cjm2w8de6004cfgpxxxrqa679"},{"post_id":"cjm2w8dde0028fgpx7maz5vpr","category_id":"cjm2w8ddq002zfgpx47hvkafw","_id":"cjm2w8de6004dfgpx92b733ym"},{"post_id":"cjm2w8dde002afgpxg10suxhr","category_id":"cjm2w8de40041fgpx5czj0u6t","_id":"cjm2w8de6004ffgpx9i43d69z"},{"post_id":"cjm2w8ddg002dfgpxmry1l86b","category_id":"cjm2w8de50044fgpxz2vgeibn","_id":"cjm2w8de7004gfgpxbmsovyqd"},{"post_id":"cjm2w8ddl002nfgpx3y02tq61","category_id":"cjm2w8de6004afgpx5j0h27co","_id":"cjm2w8de7004ifgpx5vwtbl6i"},{"post_id":"cjm2w8ddm002qfgpx4mpelz8z","category_id":"cjm2w8dcp000sfgpxa2hwvknw","_id":"cjm2w8de7004kfgpxoajew6w2"},{"post_id":"cjm2w8ddm002qfgpx4mpelz8z","category_id":"cjm2w8de6004efgpxwj749e16","_id":"cjm2w8de8004lfgpxjbh7sg0w"},{"post_id":"cjm2w8dd3001jfgpxc07847if","category_id":"cjm2w8ddo002tfgpxu4hmnv8d","_id":"cjm2w8de9004pfgpxcri00dk8"},{"post_id":"cjm2w8dd3001jfgpxc07847if","category_id":"cjm2w8de8004mfgpxwpcl7168","_id":"cjm2w8de9004qfgpxgswtqcjd"},{"post_id":"cjm2w8ddr0032fgpx5ldxwm2b","category_id":"cjm2w8de8004ofgpxsn3f6jtv","_id":"cjm2w8dea004tfgpxjttl7zhn"},{"post_id":"cjm2w8dds0035fgpxnfsgt1o2","category_id":"cjm2w8de9004sfgpxxw9ankj2","_id":"cjm2w8dea004vfgpxcsu8d1u1"},{"post_id":"cjm2w8ddt0037fgpx9mg6m22w","category_id":"cjm2w8dea004ufgpxbna4tjaw","_id":"cjm2w8dea004xfgpxyqtc191j"},{"post_id":"cjm2w8ddu003afgpx0omhimvr","category_id":"cjm2w8dea004wfgpxltvam42m","_id":"cjm2w8deb004zfgpx0zhne8e5"},{"post_id":"cjm2w8ddv003cfgpxrdda174h","category_id":"cjm2w8dea004yfgpxc3ggj0pb","_id":"cjm2w8deb0052fgpx82am73sb"},{"post_id":"cjm2w8ddw003ffgpxe5f5k33r","category_id":"cjm2w8dea004wfgpxltvam42m","_id":"cjm2w8deb0053fgpxeooasfnq"},{"post_id":"cjm2w8ddy003hfgpxyvdlw0cu","category_id":"cjm2w8deb0051fgpxra38265k","_id":"cjm2w8dec0056fgpxjy88c97j"},{"post_id":"cjm2w8ddj002ifgpxqjv10lys","category_id":"cjm2w8ddo002tfgpxu4hmnv8d","_id":"cjm2w8dec0057fgpx4ukentf4"},{"post_id":"cjm2w8ddj002ifgpxqjv10lys","category_id":"cjm2w8de8004mfgpxwpcl7168","_id":"cjm2w8ded0059fgpxvi98lflc"},{"post_id":"cjm2w8ddn002sfgpxiwbaaj6m","category_id":"cjm2w8de50044fgpxz2vgeibn","_id":"cjm2w8ded005afgpxthjoq34b"},{"post_id":"cjm2w8ddn002sfgpxiwbaaj6m","category_id":"cjm2w8dec0055fgpxvxfbba6j","_id":"cjm2w8ded005cfgpxpu3jnkmk"},{"post_id":"cjm2w8ddo002vfgpxjo38gn28","category_id":"cjm2w8de7004jfgpx2rcfw0nr","_id":"cjm2w8dee005dfgpx8zii9tzp"},{"post_id":"cjm2w8ddo002vfgpxjo38gn28","category_id":"cjm2w8dec0058fgpx3izdnb2w","_id":"cjm2w8def005ffgpxnj4jdwhq"},{"post_id":"cjm2w8ddp002xfgpx8x97ehl4","category_id":"cjm2w8de7004jfgpx2rcfw0nr","_id":"cjm2w8def005gfgpx340steq7"},{"post_id":"cjm2w8ddp002xfgpx8x97ehl4","category_id":"cjm2w8ded005bfgpxazc1iccn","_id":"cjm2w8def005hfgpxsuqw4jiq"},{"post_id":"cjm2w8ddq0030fgpxiit15aia","category_id":"cjm2w8de8004ofgpxsn3f6jtv","_id":"cjm2w8def005ifgpx1sxg4xlr"},{"post_id":"cjm2w8ddq0030fgpxiit15aia","category_id":"cjm2w8dee005efgpxnszwl983","_id":"cjm2w8def005jfgpxr8grz5gs"}],"PostTag":[{"post_id":"cjm2w8d5f0001fgpxl696hh7p","tag_id":"cjm2w8d5l0005fgpxuo0kyqz3","_id":"cjm2w8d5r000cfgpx8i6jkxhe"},{"post_id":"cjm2w8d5j0003fgpxmcfrf1i3","tag_id":"cjm2w8d5p000bfgpxebnkuwup","_id":"cjm2w8d5s000efgpxks3fexdi"},{"post_id":"cjm2w8dcr000ufgpxquwx96om","tag_id":"cjm2w8dct000xfgpxrfgdq9mf","_id":"cjm2w8dcw0013fgpxvp3q2qnb"},{"post_id":"cjm2w8dcv0011fgpxukuwarth","tag_id":"cjm2w8dct000xfgpxrfgdq9mf","_id":"cjm2w8dcx0016fgpx6prc622g"},{"post_id":"cjm2w8dct000yfgpxie7qatmd","tag_id":"cjm2w8dcw0012fgpxskbm6hmw","_id":"cjm2w8dd2001gfgpx9wrq3g1g"},{"post_id":"cjm2w8dct000yfgpxie7qatmd","tag_id":"cjm2w8dcy0018fgpxcmwhqg9a","_id":"cjm2w8dd4001kfgpxzo8wbo3c"},{"post_id":"cjm2w8dd1001ffgpxg58cmriq","tag_id":"cjm2w8dd0001efgpx8kc31gi9","_id":"cjm2w8dd5001nfgpxf3ur9iul"},{"post_id":"cjm2w8dcx0017fgpxk24spqpg","tag_id":"cjm2w8dd0001efgpx8kc31gi9","_id":"cjm2w8dd6001rfgpxf9lmao5p"},{"post_id":"cjm2w8dcy0019fgpx9onep9pk","tag_id":"cjm2w8dd0001efgpx8kc31gi9","_id":"cjm2w8dd8001vfgpxzupcr75l"},{"post_id":"cjm2w8dcz001cfgpx7ac2uv93","tag_id":"cjm2w8dd0001efgpx8kc31gi9","_id":"cjm2w8dda0020fgpxmx9qlze4"},{"post_id":"cjm2w8ddz003kfgpxipg5al5z","tag_id":"cjm2w8d5l0005fgpxuo0kyqz3","_id":"cjm2w8de1003ofgpxfh0ikbd7"}],"Tag":[{"name":"代码规范","_id":"cjm2w8d5l0005fgpxuo0kyqz3"},{"name":"操作系统","_id":"cjm2w8d5p000bfgpxebnkuwup"},{"name":"工具","_id":"cjm2w8dct000xfgpxrfgdq9mf"},{"name":"爬虫","_id":"cjm2w8dcw0012fgpxskbm6hmw"},{"name":"Python","_id":"cjm2w8dcy0018fgpxcmwhqg9a"},{"name":"C++","_id":"cjm2w8dd0001efgpx8kc31gi9"}]}}